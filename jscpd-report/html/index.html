<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>Copy/Paste Detector Report</title><link href="styles/tailwind.css" rel="stylesheet"><link href="styles/prism.css" rel="stylesheet"></head><body class="bg-gray-100"><header class="bg-white shadow py-4"><div class="container mx-auto px-4"><h1 class="text-3xl font-semibold text-gray-800">jscpd - copy/paste report</h1></div></header><main class="container mx-auto my-8 p-4 bg-white shadow rounded"><section class="mb-8" id="dashboard"><h2 class="text-2xl font-semibold text-gray-700 mb-4">Dashboard</h2><div class="grid grid-cols-4 gap-4"><div class="bg-blue-200 p-4 rounded text-center"><h3 class="text-lg font-semibold text-blue-800 mb-2">Total Files</h3><span class="text-4xl font-bold text-blue-800">1374</span></div><div class="bg-green-200 p-4 rounded text-center"><h3 class="text-lg font-semibold text-green-800 mb-2">Total Lines of Code</h3><span class="text-4xl font-bold text-green-800">124459</span></div><div class="bg-yellow-200 p-4 rounded text-center"><h3 class="text-lg font-semibold text-yellow-800 mb-2">Number of Clones</h3><span class="text-4xl font-bold text-yellow-800">648</span></div><div class="bg-red-200 p-4 rounded text-center"><h3 class="text-lg font-semibold text-red-800 mb-2">Duplicated Lines</h3><span class="text-4xl font-bold text-red-800">45549 (36.60%)</span></div></div></section><section class="mb-8" id="formats"><h2 class="text-2xl font-semibold text-gray-700 mb-4">Formats with Duplications</h2><table class="w-full table-auto"><thead><tr class="bg-gray-200 text-gray-600 uppercase text-sm leading-normal"><th class="py-3 px-6 text-left">Format</th><th class="py-3 px-6 text-left">Files</th><th class="py-3 px-6 text-left">Lines</th><th class="py-3 px-6 text-left">Clones</th><th class="py-3 px-6 text-left">Duplicated Lines</th><th class="py-3 px-6 text-left">Duplicated Tokens</th></tr></thead><tbody><tr class="bg-white border-b border-gray-200 text-gray-800 text-sm"><td class="py-3 px-6"><a class="text-blue-600 hover:underline" href="#javascript-clones">javascript</a></td><td class="py-3 px-6">621</td><td class="py-3 px-6">62003</td><td class="py-3 px-6">386</td><td class="py-3 px-6">34340</td><td class="py-3 px-6">262452</td></tr><tr class="bg-white border-b border-gray-200 text-gray-800 text-sm"><td class="py-3 px-6"><a class="text-blue-600 hover:underline" href="#typescript-clones">typescript</a></td><td class="py-3 px-6">341</td><td class="py-3 px-6">33646</td><td class="py-3 px-6">169</td><td class="py-3 px-6">9290</td><td class="py-3 px-6">54955</td></tr><tr class="bg-white border-b border-gray-200 text-gray-800 text-sm"><td class="py-3 px-6"><a class="text-blue-600 hover:underline" href="#jsx-clones">jsx</a></td><td class="py-3 px-6">201</td><td class="py-3 px-6">11168</td><td class="py-3 px-6">81</td><td class="py-3 px-6">1754</td><td class="py-3 px-6">21857</td></tr><tr class="bg-white border-b border-gray-200 text-gray-800 text-sm"><td class="py-3 px-6"><a class="text-blue-600 hover:underline" href="#tsx-clones">tsx</a></td><td class="py-3 px-6">183</td><td class="py-3 px-6">15161</td><td class="py-3 px-6">12</td><td class="py-3 px-6">165</td><td class="py-3 px-6">1224</td></tr><tr class="bg-white border-b border-gray-200 text-gray-800 text-sm"><td class="py-3 px-6"><a class="text-blue-600 hover:underline" href="#css-clones">css</a></td><td class="py-3 px-6">4</td><td class="py-3 px-6">654</td><td class="py-3 px-6">0</td><td class="py-3 px-6">0</td><td class="py-3 px-6">0</td></tr><tr class="bg-white border-b border-gray-200 text-gray-800 text-sm"><td class="py-3 px-6"><a class="text-blue-600 hover:underline" href="#markup-clones">markup</a></td><td class="py-3 px-6">2</td><td class="py-3 px-6">217</td><td class="py-3 px-6">0</td><td class="py-3 px-6">0</td><td class="py-3 px-6">0</td></tr><tr class="bg-white border-b border-gray-200 text-gray-800 text-sm"><td class="py-3 px-6"><a class="text-blue-600 hover:underline" href="#json-clones">json</a></td><td class="py-3 px-6">16</td><td class="py-3 px-6">500</td><td class="py-3 px-6">0</td><td class="py-3 px-6">0</td><td class="py-3 px-6">0</td></tr><tr class="bg-white border-b border-gray-200 text-gray-800 text-sm"><td class="py-3 px-6"><a class="text-blue-600 hover:underline" href="#markdown-clones">markdown</a></td><td class="py-3 px-6">2</td><td class="py-3 px-6">439</td><td class="py-3 px-6">0</td><td class="py-3 px-6">0</td><td class="py-3 px-6">0</td></tr><tr class="bg-white border-b border-gray-200 text-gray-800 text-sm"><td class="py-3 px-6"><a class="text-blue-600 hover:underline" href="#powershell-clones">powershell</a></td><td class="py-3 px-6">1</td><td class="py-3 px-6">103</td><td class="py-3 px-6">0</td><td class="py-3 px-6">0</td><td class="py-3 px-6">0</td></tr><tr class="bg-white border-b border-gray-200 text-gray-800 text-sm"><td class="py-3 px-6"><a class="text-blue-600 hover:underline" href="#sql-clones">sql</a></td><td class="py-3 px-6">3</td><td class="py-3 px-6">568</td><td class="py-3 px-6">0</td><td class="py-3 px-6">0</td><td class="py-3 px-6">0</td></tr></tbody></table></section><section class="mb-8" id="txt-clones"><a name="javascript-clones"></a><h2 class="text-2xl font-semibold text-gray-700 mb-4">javascript</h2><div class="divide-y divide-gray-200 border-b-2"><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/lib/lib/api/cron/auto-scrape/handlers.js (Line 64:21 - Line 74:2), C:/AI/food-truck-finder-poc/dist/lib/lib/api/cron/auto-scrape/improvedHandler.js (Line 94:2 - Line 104:7)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn0" onclick="toggleCodeBlock('cloneGroup0', 'expandBtn0', 'collapseBtn0')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn0" onclick="toggleCodeBlock('cloneGroup0', 'expandBtn0', 'collapseBtn0')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup0"><code class="language-javascript text-sm text-gray-800">(error) {
    console.error('Auto-scraping cron job failed:', error);
    logActivity({
        type: 'cron_job',
        action: 'auto_scrape_failed',
        details: {
            timestamp: new Date().toISOString(),
            error: error instanceof Error ? error.message : 'Unknown error',
        },
    });
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/lib/api/monitoring/api-usage/handlers.js (Line 1:1 - Line 89:2), C:/AI/food-truck-finder-poc/dist/lib/lib/api/monitoring/api-usage/handlers.js (Line 1:1 - Line 89:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn2" onclick="toggleCodeBlock('cloneGroup2', 'expandBtn2', 'collapseBtn2')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn2" onclick="toggleCodeBlock('cloneGroup2', 'expandBtn2', 'collapseBtn2')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup2"><code class="language-javascript text-sm text-gray-800">import { NextResponse } from 'next/server';
import { APIMonitor } from '../../monitoring/apiMonitor';
export function handleComprehensiveMonitoring() {
    const monitoringResult = APIMonitor.checkAllAPIs();
    return NextResponse.json({
        success: true,
        data: monitoringResult,
        timestamp: new Date().toISOString(),
    });
}
/**
 * Handles monitoring of API service usage based on the request parameters.
 * @example
 * handleServiceSpecificMonitoring(nextRequestInstance, apiServiceInstance)
 * { success: true, service: apiServiceInstance, usage: { requests: 50, tokens: 200 }, timestamp: &quot;2023-10-05T14:48:00.000Z&quot; }
 * @param {NextRequest} request - Incoming request instance containing URL and search parameters.
 * @param {APIService} service - The API service instance for which usage monitoring is being handled.
 * @returns {NextResponse} JSON response containing the service usage and possibility of making requests.
 * @description
 *   - Parses URL search parameters to extract action type and usage metrics.
 *   - Calls `APIMonitor.canMakeRequest` to determine if the request can be made when action is 'check'.
 *   - Returns current usage statistics when action is not 'check'.
 */
export async function handleServiceSpecificMonitoring(request, service) {
    const { searchParams } = new URL(request.url);
    const action = searchParams.get('action');
    if (action === 'check') {
        const requestCount = Number.parseInt(searchParams.get('requests') ?? '1', 10);
        const tokenCount = Number.parseInt(searchParams.get('tokens') ?? '0', 10);
        const canMakeRequest = await APIMonitor.canMakeRequest(service, requestCount, tokenCount);
        const usage = APIMonitor.getCurrentUsage(service);
        return NextResponse.json({
            success: true,
            service,
            canMakeRequest: canMakeRequest.allowed,
            reason: canMakeRequest.reason,
            waitTime: canMakeRequest.waitTime,
            usage,
            timestamp: new Date().toISOString(),
        });
    }
    const usage = APIMonitor.getCurrentUsage(service);
    return NextResponse.json({
        success: true,
        service,
        usage,
        timestamp: new Date().toISOString(),
    });
}
export function handleClearAlerts() {
    APIMonitor.clearAlertHistory();
    return NextResponse.json({
        success: true,
        message: 'Alert history cleared',
    });
}
export function handleGetAlerts() {
    const alerts = APIMonitor.getAlertHistory();
    return NextResponse.json({
        success: true,
        alerts,
        count: alerts.length,
    });
}
/**
 * Handles test alert triggering based on service and level provided.
 * @example
 * handleTestAlert({service: 'database', level: 'high'})
 * // Expected response in JSON format with success message.
 * @param {Object} body - The object containing service and level details.
 * @param {string} body.service - The name of the service for which the alert is triggered.
 * @param {string} body.level - The severity level of the alert.
 * @returns {Object} JSON response indicating success or failure status.
 * @description
 *   - Returns a success message with service and level if both are provided.
 *   - Responds with an error message if either service or level is missing.
 *   - Simulates alert triggering functionality - no real alert system interaction.
 */
export function handleTestAlert(body) {
    const { service, level } = body;
    if (service == undefined || level == undefined) {
        return NextResponse.json({ success: false, error: 'Missing service or level' }, { status: 400 });
    }
    // This would trigger a test alert in a real implementation
    return NextResponse.json({
        success: true,
        message: `Test alert triggered for ${service} at ${level} level`,
    });
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/lib/api/cron/auto-scrape/improvedHandler.js (Line 1:1 - Line 141:2), C:/AI/food-truck-finder-poc/dist/lib/lib/api/cron/auto-scrape/improvedHandler.js (Line 1:1 - Line 141:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn5" onclick="toggleCodeBlock('cloneGroup5', 'expandBtn5', 'collapseBtn5')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn5" onclick="toggleCodeBlock('cloneGroup5', 'expandBtn5', 'collapseBtn5')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup5"><code class="language-javascript text-sm text-gray-800">import { NextResponse } from 'next/server';
import { ScrapingJobService, FoodTruckService } from '../../supabase/client.js';
import { logActivity } from '../../activityLogger';
import { DEFAULT_SCRAPE_URLS } from '../../config';
// Vercel hobby plan has 10 second timeout, leave some buffer
const FUNCTION_TIMEOUT_MS = 9000;
const PROCESSING_TIMEOUT_MS = 8000;
/**
 * Lightweight CRON handler that creates jobs but doesn't process them
 * This avoids timeout issues on Vercel hobby plan
 */
export async function handleAutoScrapeImproved(request) {
    const startTime = Date.now();
    try {
        // Verify authorization
        const authHeader = request.headers.get('authorization');
        const cronSecret = process.env.CRON_SECRET;
        if (!cronSecret || authHeader !== `Bearer ${cronSecret}`) {
            return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
        }
        logActivity({
            type: 'cron_job',
            action: 'auto_scrape_started',
            details: { timestamp: new Date().toISOString() },
        });
        const result = {
            trucksProcessed: 0,
            newTrucksFound: 0,
            errors: []
        };
        // Get URLs to scrape
        const urlsToScrape = await getUrlsToScrape();
        console.info(`Found ${urlsToScrape.length} URLs to process`);
        // Check existing trucks to determine which are new
        const { trucks: existingTrucks } = await FoodTruckService.getAllTrucks(1000, 0);
        const existingUrls = new Set(existingTrucks.flatMap(truck =&gt; truck.source_urls || []));
        // Create jobs for URLs (but don't process them)
        for (const url of urlsToScrape) {
            // Check if we're approaching timeout
            if (Date.now() - startTime &gt; PROCESSING_TIMEOUT_MS) {
                console.warn('Approaching function timeout, stopping job creation');
                break;
            }
            try {
                const isNew = !existingUrls.has(url);
                // Check if job already exists
                const existingJobs = await ScrapingJobService.getJobsByStatus('all');
                const jobExists = existingJobs.some(job =&gt; job.target_url === url &amp;&amp; ['pending', 'running'].includes(job.status));
                if (!jobExists) {
                    // Create job but don't process it
                    await ScrapingJobService.createJob({
                        job_type: 'website_auto',
                        target_url: url,
                        priority: isNew ? 10 : 5, // Higher priority for new trucks
                        scheduled_at: new Date().toISOString(),
                    });
                    result.trucksProcessed++;
                    if (isNew) {
                        result.newTrucksFound++;
                    }
                }
            }
            catch (error) {
                console.error(`Error creating job for ${url}:`, error);
                result.errors.push(url);
            }
        }
        // Process a few high-priority pending jobs if we have time
        const remainingTime = FUNCTION_TIMEOUT_MS - (Date.now() - startTime);
        if (remainingTime &gt; 2000) {
            await processHighPriorityJobs(remainingTime - 1000);
        }
        logActivity({
            type: 'cron_job',
            action: 'auto_scrape_completed',
            details: {
                timestamp: new Date().toISOString(),
                trucksProcessed: result.trucksProcessed,
                newTrucksFound: result.newTrucksFound,
                errorsCount: result.errors.length,
            },
        });
        return NextResponse.json({
            success: true,
            message: 'Auto-scraping jobs created successfully',
            data: {
                trucksProcessed: result.trucksProcessed,
                newTrucksFound: result.newTrucksFound,
                timestamp: new Date().toISOString(),
                note: 'Jobs created but not processed. Use separate job processor to avoid timeouts.',
            },
        });
    }
    catch (error) {
        console.error('Auto-scraping cron job failed:', error);
        logActivity({
            type: 'cron_job',
            action: 'auto_scrape_failed',
            details: {
                timestamp: new Date().toISOString(),
                error: error instanceof Error ? error.message : 'Unknown error',
            },
        });
        return NextResponse.json({
            success: false,
            error: 'Auto-scraping failed',
            message: error instanceof Error ? error.message : 'Unknown error',
        }, { status: 500 });
    }
}
async function getUrlsToScrape() {
    // This is a simplified version - in production, you'd also check discovered_urls table
    return DEFAULT_SCRAPE_URLS;
}
async function processHighPriorityJobs(timeLimit) {
    const startTime = Date.now();
    try {
        // Get high priority pending jobs
        const pendingJobs = await ScrapingJobService.getJobsByStatus('pending');
        const highPriorityJobs = pendingJobs
            .filter(job =&gt; job.priority &gt;= 10)
            .sort((a, b) =&gt; b.priority - a.priority)
            .slice(0, 3); // Process at most 3 jobs
        for (const job of highPriorityJobs) {
            if (Date.now() - startTime &gt; timeLimit) {
                break;
            }
            // Just update status to indicate it's been queued
            await ScrapingJobService.updateJobStatus(job.id, 'pending', {
                data_collected: {
                    ...job.data_collected,
                    queued_at: new Date().toISOString(),
                    queued_note: 'Queued for processing by job processor'
                }
            });
        }
    }
    catch (error) {
        console.error('Error processing high priority jobs:', error);
    }
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/lib/api/cron/auto-scrape/handlers.js (Line 4:23 - Line 125:2), C:/AI/food-truck-finder-poc/dist/lib/lib/api/cron/auto-scrape/handlers.js (Line 4:23 - Line 125:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn6" onclick="toggleCodeBlock('cloneGroup6', 'expandBtn6', 'collapseBtn6')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn6" onclick="toggleCodeBlock('cloneGroup6', 'expandBtn6', 'collapseBtn6')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup6"><code class="language-javascript text-sm text-gray-800">;
/**
* Verifies the cron secret authorization header against a stored environment variable.
* @example
* verifyCronSecret(request)
* NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
* @param {NextRequest} request - The incoming request object containing headers.
* @returns {NextResponse | null} Returns an error response if authorization fails or if the secret is not set.
* @description
*   - Logs an error message if the CRON_SECRET environment variable is not configured or is empty.
*   - Logs unauthorized attempts, including the provided authorization header value.
*   - Relies on the Bearer token scheme for authorization.
*/
function verifyCronSecret(request) {
    const authHeader = request.headers.get('authorization');
    const cronSecret = process.env.CRON_SECRET;
    if (cronSecret === undefined || cronSecret === '') {
        console.error('CRON_SECRET not configured');
        return NextResponse.json({ error: 'Server configuration error' }, { status: 500 });
    }
    if (authHeader !== `Bearer ${cronSecret}`) {
        console.error('Unauthorized cron attempt:', authHeader);
        return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }
    return null;
}
function logAutoScrapeStart() {
    console.info('Starting automated scraping job...');
    logActivity({
        type: 'cron_job',
        action: 'auto_scrape_started',
        details: { timestamp: new Date().toISOString() },
    });
}
/**
 * Logs the completion of an automated scraping job with pertinent details.
 * @example
 * logAutoScrapeCompletion(autoScrapeResult)
 * Automated scraping job completed successfully
 * @param {AutoScrapeResult} result - The result object containing details of the scraping job.
 * @returns {void} Does not return a value.
 * @description
 *   - Logs activity including the number of trucks processed and found, as well as any errors encountered.
 *   - Utilizes a standardized logActivity function to record job completion.
 *   - Converts the current timestamp to an ISO string format.
 *   - Provides a console message indicating successful job completion.
 */
function logAutoScrapeCompletion(result) {
    logActivity({
        type: 'cron_job',
        action: 'auto_scrape_completed',
        details: {
            timestamp: new Date().toISOString(),
            trucksProcessed: result.trucksProcessed,
            newTrucksFound: result.newTrucksFound,
            errorsCount: result.errors?.length ?? 0,
        },
    });
    console.info('Automated scraping job completed successfully');
}
function logAutoScrapeFailure(error) {
    console.error('Auto-scraping cron job failed:', error);
    logActivity({
        type: 'cron_job',
        action: 'auto_scrape_failed',
        details: {
            timestamp: new Date().toISOString(),
            error: error instanceof Error ? error.message : 'Unknown error',
        },
    });
}
/**
 * Handles a POST request to initiate an auto-scraping process and returns the result.
 * @example
 * handlePostRequest(request)
 * { success: true, message: 'Auto-scraping completed successfully', data: { trucksProcessed: 10, newTrucksFound: 2, timestamp: '2023-08-23T18:25:43.511Z' } }
 * @param {NextRequest} request - The request object containing necessary parameters and headers for processing.
 * @returns {NextResponse} JSON response with either the success data or an error message.
 * @description
 *   - Validates request with a secret key before processing.
 *   - Logs scraping start and completion along with processed results.
 *   - Schedules follow-up tasks after successful scraping.
 *   - Catches and logs errors with a failure response in case of any exceptions during the process.
 */
export async function handlePostRequest(request) {
    try {
        const authResponse = verifyCronSecret(request);
        if (authResponse) {
            return authResponse;
        }
        logAutoScrapeStart();
        const rawResult = await autoScraper.runAutoScraping();
        // Map errors to string[] for compatibility
        const result = {
            trucksProcessed: rawResult.trucksProcessed,
            newTrucksFound: rawResult.newTrucksFound,
            errors: rawResult.errors?.map((e) =&gt; e.url + (e.details ? `: ${e.details}` : '')),
        };
        scheduler.scheduleFollowUpTasks(result);
        logAutoScrapeCompletion(result);
        return NextResponse.json({
            success: true,
            message: 'Auto-scraping completed successfully',
            data: {
                trucksProcessed: result.trucksProcessed,
                newTrucksFound: result.newTrucksFound,
                timestamp: new Date().toISOString(),
            },
        });
    }
    catch (error) {
        logAutoScrapeFailure(error);
        return NextResponse.json({
            success: false,
            error: 'Auto-scraping failed',
            message: error instanceof Error ? error.message : 'Unknown error',
        }, { status: 500 });
    }
}
export function handleGetRequest() {
    return NextResponse.json({ error: 'Method not allowed. Use POST for cron jobs.' }, { status: 405 });
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/lib/api/analytics/web-vitals/handlers.js (Line 2:17 - Line 197:2), C:/AI/food-truck-finder-poc/dist/lib/lib/api/analytics/web-vitals/handlers.js (Line 2:27 - Line 197:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn7" onclick="toggleCodeBlock('cloneGroup7', 'expandBtn7', 'collapseBtn7')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn7" onclick="toggleCodeBlock('cloneGroup7', 'expandBtn7', 'collapseBtn7')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup7"><code class="language-javascript text-sm text-gray-800">;
/**
 * Get Web Vitals Analytics Data
 */
export function getRequestParams(request) {
    const { searchParams } = new URL(request.url);
    const days = Number.parseInt(searchParams.get('days') ?? '7', 10);
    const page = searchParams.get('page');
    return { days, page };
}
/**
 * Fetches and filters web vital metrics based on the given request parameters.
 * @example
 * fetchAndFilterMetrics(request)
 * { metrics: [{...}], days: 7, startDate: 2023-01-01T00:00:00.000Z }
 * @param {NextRequest} request - The request object containing parameters for filtering metrics such as days and page.
 * @returns {Object} An object containing an array of metrics, the number of days for the range, and the start date.
 * @description
 *   - Throws an error if the Supabase database connection is not available.
 *   - Builds a query to select metrics recorded after a specific start date.
 *   - Filters metrics by page URL if specified in the request parameters.
 *   - Limits the number of returned metrics to 1000 to avoid overwhelming the client.
 */
export async function fetchAndFilterMetrics(request) {
    const { days, page } = getRequestParams(request);
    if (!supabaseAdmin) {
        throw new Error('Database not available');
    }
    const startDate = new Date();
    startDate.setDate(startDate.getDate() - days);
    let query = supabaseAdmin
        .from('web_vitals_metrics')
        .select('*')
        .gte('recorded_at', startDate.toISOString())
        .order('recorded_at', { ascending: false });
    if (page != undefined &amp;&amp; page !== '') {
        query = query.ilike('page_url', `%${page}%`);
    }
    const { data: metrics, error } = await query.limit(1000);
    if (error) {
        throw error;
    }
    return { metrics: metrics ?? [], days, startDate };
}
/**
 * Calculate summary statistics for metrics
 */
export function calculateMetricsSummary(metrics) {
    const metricTypes = [
        'LCP',
        'FID',
        'CLS',
        'FCP',
        'TTFB',
    ];
    const summary = {};
    for (const metricName of metricTypes) {
        const metricData = metrics.filter((m) =&gt; m.metric_name === metricName);
        if (metricData.length === 0) {
            summary[metricName] = {
                count: 0,
                average: undefined,
                median: undefined,
                p75: undefined,
                p95: undefined,
                goodCount: 0,
                needsImprovementCount: 0,
                poorCount: 0,
            };
            continue;
        }
        const values = metricData.map((m) =&gt; m.metric_value).sort((a, b) =&gt; a - b);
        const ratings = metricData.map((m) =&gt; m.rating);
        summary[metricName] = {
            count: metricData.length,
            average: Math.round(values.reduce((sum, val) =&gt; sum + val, 0) / values.length),
            median: getPercentile(values, 50),
            p75: getPercentile(values, 75),
            p95: getPercentile(values, 95),
            goodCount: ratings.filter((r) =&gt; r === 'good').length,
            needsImprovementCount: ratings.filter((r) =&gt; r === 'needs-improvement').length,
            poorCount: ratings.filter((r) =&gt; r === 'poor').length,
        };
    }
    return summary;
}
/**
 * Calculate percentile value from sorted array
 */
export function getPercentile(sortedValues, percentile) {
    if (sortedValues.length === 0)
        return 0;
    const index = (percentile / 100) * (sortedValues.length - 1);
    const lower = Math.floor(index);
    const upper = Math.ceil(index);
    if (lower === upper) {
        return Math.round(sortedValues[lower]);
    }
    const weight = index - lower;
    return Math.round(sortedValues[lower] * (1 - weight) + sortedValues[upper] * weight);
}
/**
 * Handles POST requests to store and validate web vital metrics.
 * @example
 * handlePostRequest(request)
 * { success: true }
 * @param {NextRequest} request - The incoming request containing the web vital metric data.
 * @returns {NextResponse} JSON response indicating success or failure of storing the metric.
 * @description
 *   - Validates that the metric contains required fields and checks the types of values.
 *   - Stores validated metrics in a Supabase table if `supabaseAdmin` is available.
 *   - Logs any 'poor' performance metrics for monitoring purposes.
 *   - Ensures metrics collection is non-blocking, even if an error occurs during database operations.
 */
export async function handlePostRequest(request) {
    try {
        const metric = await request.json();
        // Validate metric data
        if (typeof metric !== 'object' ||
            metric == undefined ||
            !('name' in metric) ||
            !('value' in metric) ||
            !('url' in metric) ||
            typeof metric.value !== 'number') {
            return NextResponse.json({ success: false, error: 'Invalid metric data' }, { status: 400 });
        }
        const validatedMetric = metric;
        if (supabaseAdmin) {
            try {
                const { error } = await supabaseAdmin.from('web_vitals_metrics').insert({
                    metric_name: validatedMetric.name,
                    metric_value: validatedMetric.value,
                    rating: validatedMetric.rating,
                    page_url: validatedMetric.url,
                    user_agent: validatedMetric.userAgent,
                    recorded_at: new Date(validatedMetric.timestamp).toISOString(),
                });
                if (error) {
                    console.warn('Failed to store web vital metric:', error);
                    // Don't fail the request - metrics collection should be non-blocking
                }
            }
            catch (dbError) {
                console.warn('Database error storing web vital:', dbError);
            }
        }
        // Log performance issues for monitoring
        if (validatedMetric.rating === 'poor') {
            console.warn(`Poor ${validatedMetric.name} performance detected:`, {
                value: validatedMetric.value,
                url: validatedMetric.url,
                timestamp: new Date(validatedMetric.timestamp).toISOString(),
            });
        }
        return NextResponse.json({ success: true });
    }
    catch (error) {
        console.error('Web vitals endpoint error:', error);
        return NextResponse.json({ success: false, error: 'Internal server error' }, { status: 500 });
    }
}
/**
* Handles a GET request to fetch web vitals analytics data, process it, and respond with a summary.
* @example
* handleGetRequest(request)
* { success: true, data: { metrics: [...], summary: {...}, period: {...} } }
* @param {NextRequest} request - The incoming request object containing the necessary parameters.
* @returns {Promise&lt;NextResponse&gt;} Returns a JSON response indicating success or failure along with the data.
* @description
*   - Fetches metrics which are filtered and evaluated from the request data.
*   - Constructs a summary of the metrics including names, values, and ratings.
*   - Generates a response containing the metrics, summary, and calculated time period.
*   - Logs errors and responses with a status code in case of failure during data fetching.
*/
export async function handleGetRequest(request) {
    try {
        const { metrics, days, startDate } = await fetchAndFilterMetrics(request);
        const summary = calculateMetricsSummary(metrics);
        return NextResponse.json({
            success: true,
            data: {
                metrics,
                summary,
                period: {
                    days,
                    startDate: startDate.toISOString(),
                    endDate: new Date().toISOString(),
                },
            },
        });
    }
    catch (error) {
        console.error('Failed to fetch web vitals analytics:', error);
        return NextResponse.json({ success: false, error: 'Failed to fetch analytics data' }, { status: 500 });
    }
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/lib/api/admin/scraping-metrics/handlers.js (Line 2:17 - Line 56:2), C:/AI/food-truck-finder-poc/dist/lib/lib/api/admin/scraping-metrics/handlers.js (Line 2:27 - Line 56:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn9" onclick="toggleCodeBlock('cloneGroup9', 'expandBtn9', 'collapseBtn9')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn9" onclick="toggleCodeBlock('cloneGroup9', 'expandBtn9', 'collapseBtn9')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup9"><code class="language-javascript text-sm text-gray-800">;
export async function handleGetRequest() {
    const metrics = await getScrapingMetrics();
    return NextResponse.json({
        success: true,
        data: metrics,
        timestamp: new Date().toISOString(),
    });
}
/**
 * Retrieves real-time scraping metrics from the database.
 * @example
 * getScrapingMetrics().then(metrics =&gt; console.log(metrics))
 * // { scrapingJobs: {...}, dataQuality: {...}, systemHealth: {...} }
 * @returns {Promise&lt;RealtimeMetrics&gt;} A promise that resolves to an object containing scraping job metrics, data quality information, and system health stats.
 * @description
 *   - Fetches data from ScrapingJobService and FoodTruckService to compute metrics.
 *   - Placeholder values are used for averageScore and recentChanges in dataQuality.
 *   - Computes the number of jobs by their status: running, completed, failed, and pending.
 */
async function getScrapingMetrics() {
    // Fetch real scraping metrics from database
    const [allJobsResult, recentTrucksResult] = await Promise.all([
        ScrapingJobService.getAllJobs(100, 0), // Get last 100 jobs for metrics
        FoodTruckService.getAllTrucks(1000, 0), // Get trucks for processing count
    ]);
    // Type guard for allJobsResult
    const allJobs = Array.isArray(allJobsResult) ? allJobsResult : [];
    const recentTrucks = typeof recentTrucksResult === 'object' &amp;&amp;
        'trucks' in recentTrucksResult &amp;&amp;
        Array.isArray(recentTrucksResult.trucks)
        ? recentTrucksResult
        : { trucks: [], total: 0 };
    const typedJobs = allJobs;
    const successfulRuns = typedJobs.filter((job) =&gt; job.status === 'completed').length;
    const failedRuns = typedJobs.filter((job) =&gt; job.status === 'failed').length;
    return {
        scrapingJobs: {
            active: typedJobs.filter((job) =&gt; job.status === 'running').length,
            completed: successfulRuns,
            failed: failedRuns,
            pending: typedJobs.filter((job) =&gt; job.status === 'pending').length,
        },
        dataQuality: {
            averageScore: 0, // Placeholder, actual calculation might be complex
            totalTrucks: recentTrucks.total,
            recentChanges: 0, // Placeholder
        },
        systemHealth: {
            status: 'healthy',
            uptime: process.uptime(),
            lastUpdate: new Date().toISOString(),
        },
    };
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/lib/api/admin/realtime-events/handlers.js (Line 1:17 - Line 370:2), C:/AI/food-truck-finder-poc/dist/lib/lib/api/admin/realtime-events/handlers.js (Line 1:27 - Line 370:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn10" onclick="toggleCodeBlock('cloneGroup10', 'expandBtn10', 'collapseBtn10')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn10" onclick="toggleCodeBlock('cloneGroup10', 'expandBtn10', 'collapseBtn10')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup10"><code class="language-javascript text-sm text-gray-800">;
/**
* Handles incoming GET requests by streaming real-time admin events through Server-Sent Events.
* @example
* handleGetRequest(request)
* Response object with event stream data
* @param {NextRequest} request - Incoming request to handle and process.
* @returns {Response} Returns a streaming Response object containing the SSE data.
* @description
*   - Initializes a readable stream for emitting real-time events as SSE.
*   - Enqueues a connection event upon a new client connection.
*   - Sets up periodic heartbeat events every 5 seconds.
*   - Registers an abort event listener to gracefully close streams and clear intervals.
*/
export function handleGetRequest(request) {
    const stream = new ReadableStream({
        start(controller) {
            const encoder = new TextEncoder();
            const connectionEvent = {
                id: generateEventId(),
                type: 'heartbeat',
                timestamp: new Date().toISOString(),
                data: {
                    message: 'Real-time admin dashboard connected',
                    connectionId: generateEventId(),
                },
            };
            controller.enqueue(encoder.encode(formatSSEMessage(connectionEvent)));
            const intervalId = setInterval(async () =&gt; {
                await sendHeartbeatEvent(controller, encoder);
            }, 5000);
            const changeMonitorId = setupDataChangeMonitor(controller, encoder);
            request.signal.addEventListener('abort', () =&gt; {
                clearInterval(intervalId);
                clearInterval(changeMonitorId);
                controller.close();
            });
        },
    });
    return new Response(stream, {
        headers: {
            'Content-Type': 'text/event-stream',
            'Cache-Control': 'no-cache',
            Connection: 'keep-alive',
            'Access-Control-Allow-Origin': '*',
            'Access-Control-Allow-Headers': 'Cache-Control',
        },
    });
}
/**
* Sends a heartbeat event by fetching realtime metrics or logs an error alert when unsuccessful
* @example
* sendHeartbeatEvent(controller, encoder)
* // No return value
* @param {ReadableStreamDefaultController&lt;Uint8Array&gt;} controller - The controller used for enqueueing the event data.
* @param {TextEncoder} encoder - The encoder used to convert the event data to a Uint8Array.
* @returns {Promise&lt;void&gt;} Promise that resolves when event has been sent or error has been handled.
* @description
*   - Utilizes `fetchRealtimeMetrics()` to gather current system metrics.
*   - Generates a unique event id via `generateEventId()`.
*   - Formats the event data using `formatSSEMessage()` before enqueueing.
*   - Handles errors by creating a system alert event if metrics fetching fails.
*/
async function sendHeartbeatEvent(controller, encoder) {
    try {
        const metrics = await fetchRealtimeMetrics();
        const event = {
            id: generateEventId(),
            type: 'heartbeat',
            timestamp: new Date().toISOString(),
            data: { ...metrics },
        };
        controller.enqueue(encoder.encode(formatSSEMessage(event)));
    }
    catch (error) {
        console.error('Error fetching realtime metrics:', error);
        const errorEvent = {
            id: generateEventId(),
            type: 'system_alert',
            timestamp: new Date().toISOString(),
            data: {
                error: 'Failed to fetch metrics',
                details: error instanceof Error ? error.message : 'Unknown error',
            },
            severity: 'error',
        };
        controller.enqueue(encoder.encode(formatSSEMessage(errorEvent)));
    }
}
/**
* Sets up a periodic monitor for data changes using provided controller and encoder.
* @example
* setupDataChangeMonitor(controller, encoder)
* // returns a NodeJS.Timeout object that repeatedly monitors data changes every 10 seconds
* @param {ReadableStreamDefaultController&lt;Uint8Array&gt;} controller - Controller to handle readable stream of Uint8Array.
* @param {TextEncoder} encoder - Encoder to encode texts for processing the monitor.
* @returns {NodeJS.Timeout} Returns a timeout object responsible for invoking data change monitoring at set intervals.
* @description
*   - Utilizes async operation to monitor data changes ensuring non-blocking execution.
*   - Handles errors by logging them to the console, useful for debugging.
*/
function setupDataChangeMonitor(controller, encoder) {
    return setInterval(async () =&gt; {
        try {
            await monitorDataChanges(controller, encoder);
        }
        catch (error) {
            console.error('Error monitoring data changes:', error);
        }
    }, 10_000);
}
/**
 * Handles a POST request and performs an action based on the 'action' property in the request body.
 * @example
 * handlePostRequest(request)
 * Promise&lt;Response&gt;
 * @param {NextRequest} request - The incoming request object containing the POST data.
 * @returns {Promise&lt;Response&gt;} A response object indicating the result of the action.
 * @description
 *   - Utilizes type guarding to validate the presence of the 'action' property in the request body.
 *   - Executes different actions like 'health_check' or 'trigger_test_event' based on the 'action' value.
 *   - Provides error handling to return appropriate response codes and error messages.
 */
export async function handlePostRequest(request) {
    try {
        const rawBody = await request.json();
        const isPostRequestBody = (obj) =&gt; {
            return (typeof obj === 'object' &amp;&amp;
                obj !== null &amp;&amp;
                'action' in obj &amp;&amp;
                typeof obj.action === 'string' &amp;&amp;
                (obj.action === 'health_check' ||
                    obj.action === 'trigger_test_event'));
        };
        if (!isPostRequestBody(rawBody)) {
            return new Response(JSON.stringify({
                success: false,
                error: &quot;Invalid request body: 'action' property is missing or not a valid action.&quot;,
            }), {
                status: 400,
                headers: { 'Content-Type': 'application/json' },
            });
        }
        const body = rawBody;
        switch (body.action) {
            case 'health_check': {
                return await handleHealthCheck();
            }
            case 'trigger_test_event': {
                return handleTriggerTestEvent();
            }
            default: {
                return new Response(JSON.stringify({
                    success: false,
                    error: &quot;That didn't work, please try again later.&quot;,
                }), {
                    status: 400,
                    headers: { 'Content-Type': 'application/json' },
                });
            }
        }
    }
    catch (error) {
        console.error('Realtime events POST error:', error);
        return new Response(JSON.stringify({
            success: false,
            error: &quot;That didn't work, please try again later.&quot;,
        }), {
            status: 500,
            headers: { 'Content-Type': 'application/json' },
        });
    }
}
/**
 * Fetches current scraping job metrics, data quality statistics, and system health status.
 * @example
 * fetchRealtimeMetrics()
 * {
 *   scrapingJobs: { active: 4, completed: 5, failed: 1, pending: 2 },
 *   dataQuality: { averageScore: 85, totalTrucks: 50, recentChanges: 0 },
 *   systemHealth: { status: 'healthy', uptime: 3600, lastUpdate: '2023-10-01T12:00:00Z' }
 * }
 * @returns {Promise&lt;RealtimeMetrics&gt;} An object containing metrics about scraping jobs, data quality, and system health.
 * @description
 *   - Utilizes external services ScrapingJobService and FoodTruckService to gather data.
 *   - Provides comprehensive metrics for monitoring system health and data processing status.
 *   - Catches errors to ensure consistent return structure even upon failure.
 */
async function fetchRealtimeMetrics() {
    try {
        const recentJobs = await ScrapingJobService.getJobsByStatus('all');
        const scrapingMetrics = {
            active: recentJobs.filter((job) =&gt; job.status === 'running').length,
            completed: recentJobs.filter((job) =&gt; job.status === 'completed').length,
            failed: recentJobs.filter((job) =&gt; job.status === 'failed').length,
            pending: recentJobs.filter((job) =&gt; job.status === 'pending').length,
        };
        const qualityStats = await FoodTruckService.getDataQualityStats();
        const dataQualityMetrics = {
            averageScore: qualityStats.avg_quality_score ?? 0,
            totalTrucks: qualityStats.total_trucks ?? 0,
            recentChanges: 0,
        };
        const systemHealth = {
            status: 'healthy',
            uptime: process.uptime(),
            lastUpdate: new Date().toISOString(),
        };
        return {
            scrapingJobs: scrapingMetrics,
            dataQuality: dataQualityMetrics,
            systemHealth,
        };
    }
    catch (error) {
        console.error('Error fetching realtime metrics:', error);
        return {
            scrapingJobs: { active: 0, completed: 0, failed: 0, pending: 0 },
            dataQuality: { averageScore: 0, totalTrucks: 0, recentChanges: 0 },
            systemHealth: {
                status: 'error',
                uptime: 0,
                lastUpdate: new Date().toISOString(),
            },
        };
    }
}
function isScrapingJob(obj) {
    return typeof obj === 'object' &amp;&amp; obj !== null &amp;&amp; 'id' in obj &amp;&amp; 'status' in obj;
}
// Removed isFoodTruck function as it is unused.
// function isFoodTruck(obj: unknown): obj is FoodTruck {
//   return typeof obj === 'object' &amp;&amp; obj !== null &amp;&amp; 'id' in obj &amp;&amp; 'name' in obj;
// }
/**
 * Sends an update event about recent scraping jobs to a stream.
 * @example
 * sendScrapingUpdateEvent(controller, encoder)
 * @param {ReadableStreamDefaultController&lt;Uint8Array&gt;} controller - The stream controller to enqueue the event data.
 * @param {TextEncoder} encoder - The TextEncoder used to encode the event message.
 * @returns {Promise&lt;void&gt;} Resolves when the event has been enqueued.
 * @description
 *   - The function retrieves all recent scraping jobs with their status.
 *   - Filters the jobs to include only valid scraping jobs.
 *   - Constructs an event object adhering to the expected format.
 *   - Uses the controller to stream the encoded event to the client.
 */
async function sendScrapingUpdateEvent(controller, encoder) {
    const recentJobs = await ScrapingJobService.getJobsByStatus('all');
    if (Array.isArray(recentJobs) &amp;&amp; recentJobs.length &gt; 0) {
        const event = {
            id: generateEventId(),
            type: 'scraping_update',
            timestamp: new Date().toISOString(),
            data: {
                recentJobs: recentJobs
                    .filter((job) =&gt; isScrapingJob(job))
                    .map((job) =&gt; ({
                    // Fixed unicorn/no-array-callback-reference
                    id: job.id,
                    status: job.status,
                    started_at: job.started_at,
                    completed_at: job.completed_at,
                })),
                count: recentJobs.length,
            },
            severity: 'info',
        };
        controller.enqueue(encoder.encode(formatSSEMessage(event)));
    }
}
/**
 * Sends a data quality change event if recent updates are detected.
 * @example
 * sendDataQualityChangeEvent(controller, encoder)
 * // Enqueues an event to the provided controller.
 * @param {ReadableStreamDefaultController&lt;Uint8Array&gt;} controller - The controller that enqueues the encoded event data.
 * @param {TextEncoder} encoder - The encoder used to transform event data into Uint8Array format.
 * @returns {Promise&lt;void&gt;} Resolves when the event is successfully handled and enqueued.
 * @description
 *   - Retrieves recent food truck updates from the FoodTruckService.
 *   - Filters food trucks updated within the last minute.
 *   - Formats a server-sent event message with the updates.
 *   - Only enqueues the event if there are updates detected.
 */
async function sendDataQualityChangeEvent(controller, encoder) {
    const recentTrucksResult = await FoodTruckService.getAllTrucks(10, 0);
    const recentlyUpdated = recentTrucksResult.trucks.filter((truck) =&gt; {
        if (!truck.updated_at)
            return false;
        const updatedAt = new Date(truck.updated_at);
        const oneMinuteAgo = new Date(Date.now() - 60_000);
        return updatedAt &gt; oneMinuteAgo;
    });
    if (recentlyUpdated.length &gt; 0) {
        const event = {
            id: generateEventId(),
            type: 'data_quality_change',
            timestamp: new Date().toISOString(),
            data: {
                updatedTrucks: recentlyUpdated.map((truck) =&gt; ({
                    id: truck.id,
                    name: truck.name,
                    data_quality_score: truck.data_quality_score,
                    updated_at: truck.updated_at,
                })),
                count: recentlyUpdated.length,
            },
            severity: 'info',
        };
        controller.enqueue(encoder.encode(formatSSEMessage(event)));
    }
}
async function monitorDataChanges(controller, encoder) {
    try {
        await sendScrapingUpdateEvent(controller, encoder);
        await sendDataQualityChangeEvent(controller, encoder);
    }
    catch (error) {
        console.error('Error monitoring data changes:', error);
    }
}
function formatSSEMessage(event) {
    return `id: ${event.id}\nevent: ${event.type}\ndata: ${JSON.stringify(event)}\n\n`;
}
function generateEventId() {
    // eslint-disable-next-line sonarjs/pseudo-random -- Math.random is acceptable for generating non-security-sensitive event IDs.
    return `${Date.now()}-${Math.random().toString(36).slice(2, 11)}`;
}
/**
 * Performs a health check and returns the system status along with real-time metrics.
 * @example
 * handleHealthCheck().then(response =&gt; console.log(response));
 * Response { &quot;success&quot;: true, &quot;status&quot;: &quot;healthy&quot;, &quot;metrics&quot;: {...}, &quot;timestamp&quot;: &quot;2023-03-17T12:34:56.789Z&quot; }
 * @returns {Promise&lt;Response&gt;} A Promise that resolves to a Response object containing JSON data.
 * @description
 *   - Utilizes real-time metrics to provide current system health information.
 *   - Returns a JSON response formatted with specific headers and structure.
 */
async function handleHealthCheck() {
    const metrics = await fetchRealtimeMetrics();
    return new Response(JSON.stringify({
        success: true,
        status: 'healthy',
        metrics,
        timestamp: new Date().toISOString(),
    }), {
        headers: { 'Content-Type': 'application/json' },
    });
}
/**
 * Returns a JSON response indicating a test event has been triggered.
 * @example
 * handleTriggerTestEvent()
 * Response object with a success message.
 * @returns {Response} JSON response containing success status, message, and timestamp.
 * @description
 *   - The response content type is set to 'application/json'.
 *   - The timestamp is generated using the current date and time.
 *   - Ensures consistent response formatting for realtime event triggers.
 */
function handleTriggerTestEvent() {
    return new Response(JSON.stringify({
        success: true,
        message: 'Test event triggered',
        timestamp: new Date().toISOString(),
    }), {
        headers: { 'Content-Type': 'application/json' },
    });
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/lib/api/admin/oauth-status/helpers.js (Line 2:17 - Line 332:2), C:/AI/food-truck-finder-poc/dist/lib/lib/api/admin/oauth-status/helpers.js (Line 2:27 - Line 332:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn12" onclick="toggleCodeBlock('cloneGroup12', 'expandBtn12', 'collapseBtn12')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn12" onclick="toggleCodeBlock('cloneGroup12', 'expandBtn12', 'collapseBtn12')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup12"><code class="language-javascript text-sm text-gray-800">;
/**
 * Handles a GET request to retrieve OAuth configuration status.
 * @example
 * handleGetRequest(request)
 * Returns a JSON response with OAuth status details and legacy format.
 * @param {NextRequest} _request - The incoming request object.
 * @returns {NextResponse} JSON response indicating the current OAuth status.
 * @description
 *   - Retrieves the current OAuth configuration status from the server.
 *   - Adapts the response to include both modern and legacy format details.
 *   - Provides a step-by-step legacy configuration guide if OAuth is not ready.
 */
export async function handleGetRequest(_request) {
    const status = await getOAuthStatus();
    return NextResponse.json({
        success: true,
        ...status,
        legacy_format: {
            oauth_status: status.overall_status,
            message: getStatusMessage(status.overall_status),
            configuration_steps: status.overall_status === 'ready'
                ? undefined
                : [
                    '1. Go to Supabase Dashboard &gt; Authentication &gt; Providers',
                    '2. Enable Google provider',
                    '3. Add Google OAuth Client ID and Secret',
                    '4. Configure redirect URLs',
                    '5. Test OAuth flow',
                ],
        },
    });
}
// 1. Refactor nested template literals in generateOAuthTestUrl
function generateOAuthTestUrl(baseUrl) {
    const redirectPath = `${baseUrl}/auth/callback`;
    const encodedRedirect = encodeURIComponent(redirectPath);
    return (process.env.NEXT_PUBLIC_SUPABASE_URL +
        '/auth/v1/authorize?provider=google&amp;redirect_to=' +
        encodedRedirect);
}
/**
 * Handles a post request to generate an OAuth test URL based on the environment.
 * @example
 * handlePostRequest()
 * {
 *   success: true,
 *   message: 'OAuth test URL generated',
 *   test_url: 'http://localhost:3000/...',
 *   environment: 'development',
 *   instructions: [ ... ],
 *   manual_test_steps: [ ... ],
 *   automation_commands: [ ... ]
 * }
 * @returns {object} An object containing success status, message, the test URL, the environment, instructions, manual test steps, and automation commands.
 * @description
 *   - Determines the base URL depending on whether the environment is production or development.
 *   - Utilizes `generateOAuthTestUrl` to construct the OAuth test URL.
 *   - Responds with JSON containing test instructions and automation commands for verifying OAuth functionality.
 */
export function handlePostRequest() {
    // Removed _request parameter
    const baseUrl = process.env.NODE_ENV === 'production'
        ? 'https://food-truck-finder-poc-git-feat-s-20ec1c-codedeficients-projects.vercel.app'
        : 'http://localhost:3000';
    const testUrl = generateOAuthTestUrl(baseUrl);
    return NextResponse.json({
        success: true,
        message: 'OAuth test URL generated',
        test_url: testUrl,
        environment: process.env.NODE_ENV ?? 'development',
        instructions: [
            '1. Open the test_url in a new browser tab',
            '2. Complete Google OAuth flow',
            '3. Verify redirect to admin dashboard',
            '4. Check for proper role assignment',
        ],
        manual_test_steps: [
            'Navigate to /login page',
            'Click Google login button',
            'Complete OAuth flow',
            'Verify admin access',
        ],
        automation_commands: [
            'npm run oauth:verify - Check configuration',
            'npm run oauth:test:dev - Test development flow',
            'npm run oauth:test:prod - Test production flow',
        ],
    });
}
/**
 * Retrieves the current OAuth status including configuration and connectivity information.
 * @example
 * getOAuthStatus().then(status =&gt; {
 *   console.log(status);
 * });
 * // Output: OAuthStatus object with current configuration and connection status details
 * @returns {Promise&lt;OAuthStatus&gt;} An object representing the current status of OAuth configuration and connectivity.
 * @description
 *   - The function assesses the connectivity and configuration of Supabase and its authentication settings.
 *   - It checks if the necessary environment variables are set.
 *   - Executes a series of asynchronous checks to determine if the OAuth provider is properly configured.
 *   - Recommendations for improving the OAuth setup are generated based on the current status.
 */
async function getOAuthStatus() {
    const status = {
        timestamp: new Date().toISOString(),
        environment: process.env.NODE_ENV === 'production' ? 'production' : 'development',
        supabase: {
            connected: false,
            projectId: 'zkwliyjjkdnigizidlln',
        },
        environment_variables: {
            supabaseUrl: process.env.NEXT_PUBLIC_SUPABASE_URL !== undefined,
            supabaseAnonKey: process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY !== undefined,
            supabaseServiceKey: process.env.SUPABASE_SERVICE_ROLE_KEY !== undefined,
        },
        oauth_flow: {
            loginPageExists: true,
            callbackRouteExists: true,
            authProviderConfigured: false,
        },
        recommendations: [],
        overall_status: 'not_configured',
    };
    await checkSupabaseConnection(status, supabase);
    await checkSupabaseAuthSettings(status);
    await testOAuthProvider(status, supabase);
    status.recommendations = generateRecommendations(status);
    status.overall_status = determineOverallStatus(status);
    return status;
}
/**
 * Checks the connection status with Supabase and updates the `OAuthStatus`.
 * @example
 * checkSupabaseConnection(status, supabase)
 * // Updates the `status.supabase.connected` property based on connection success
 * @param {OAuthStatus} status - The current OAuthStatus object that tracks connection state and errors.
 * @param {SupabaseClient} supabase - The Supabase client instance used to interact with the database.
 * @returns {void} No explicit return value, operates directly on the `status` object.
 * @description
 *   - Attempts a query to the 'profiles' table to ensure Supabase connection.
 *   - Updates `status.supabase.connected` based on query success.
 *   - Captures and records detailed error messages in case of connection failure.
 */
async function checkSupabaseConnection(status, supabase) {
    try {
        const { error } = await supabase.from('profiles').select('count').limit(1);
        if (error === null) {
            status.supabase.connected = true;
        }
        else {
            status.supabase.error = error.message;
        }
    }
    catch (error) {
        status.supabase.error = error instanceof Error ? error.message : 'Unknown connection error';
    }
}
/**
 * Checks and processes Supabase authentication settings.
 * @example
 * checkSupabaseAuthSettings(oAuthStatusInstance)
 * { supabase: { authSettings: { googleEnabled: true, signupEnabled: false, autoconfirm: true } } }
 * @param {OAuthStatus} status - An object that holds OAuth configuration status.
 * @returns {void} Modifies the passed status object with fetched authentication settings.
 * @description
 *   - The function fetches authentication settings from the Supabase URL defined in environment variables.
 *   - If Supabase settings are fetched successfully, it updates the OAuth status with authentication settings like Google integration, signup availability, and autoconfirm feature.
 *   - Provides a fallback log for cases where fetching settings require authentication.
 */
async function checkSupabaseAuthSettings(status) {
    try {
        const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;
        if (typeof supabaseUrl === 'string' &amp;&amp; supabaseUrl.length &gt; 0) {
            // Explicit check for undefined and empty string
            const settingsResponse = await fetch(`${supabaseUrl}/auth/v1/settings`);
            if (settingsResponse.ok === true) {
                const settings = (await settingsResponse.json());
                status.supabase.authSettings = {
                    googleEnabled: settings.external?.google ?? false,
                    signupEnabled: settings.disable_signup === false,
                    autoconfirm: settings.autoconfirm ?? false,
                };
                if (settings.external?.google !== undefined) {
                    // Explicit check for undefined
                    status.oauth_flow.authProviderConfigured = true;
                }
            }
        }
    }
    catch {
        console.info('Auth settings endpoint requires authentication (normal)');
    }
}
/**
 * Tests the configuration of an OAuth provider and updates the status based on the result.
 * @example
 * testOAuthProvider(status, supabase)
 * undefined
 * @param {OAuthStatus} status - An object representing the current OAuth status and configuration.
 * @param {SupabaseClient} supabase - The Supabase client instance used to interact with the authentication system.
 * @returns {void} Does not return any value.
 * @description
 *   - Utilizes Google as the OAuth provider for the sign-in attempt.
 *   - Redirects to a localhost callback URL to simulate the OAuth process.
 *   - Direct usage of the Supabase auth method to initiate OAuth process.
 *   - Handles exceptions without altering the control flow and logs them for informational purposes.
 */
async function testOAuthProvider(status, supabase) {
    try {
        const { error: oauthError } = await supabase.auth.signInWithOAuth({
            provider: 'google',
            options: {
                redirectTo: 'http://localhost:3000/auth/callback',
                skipBrowserRedirect: true,
            },
        });
        if (oauthError !== null &amp;&amp; oauthError.message !== 'Provider not found') {
            // Explicitly check for oauthError existence
            status.oauth_flow.authProviderConfigured = true;
        }
    }
    catch (error) {
        console.info('OAuth provider test failed (may be normal):', error);
    }
}
/**
 * Generates a list of recommendations for OAuth configuration based on the current status.
 * @example
 * generateRecommendations(status)
 * [' Configure NEXT_PUBLIC_SUPABASE_URL environment variable', ...]
 * @param {OAuthStatus} status - The current status of OAuth configuration and environment variables.
 * @returns {string[]} Array of recommendation messages to guide configuration setup.
 * @description
 *   - Checks for necessary environment variables and Supabase connectivity.
 *   - Provides guidance on enabling Google OAuth.
 *   - Suggests consulting documentation for further setup instructions.
 */
function generateRecommendations(status) {
    const recommendations = [];
    if (!status.environment_variables.supabaseUrl) {
        recommendations.push(' Configure NEXT_PUBLIC_SUPABASE_URL environment variable');
    }
    if (!status.environment_variables.supabaseAnonKey) {
        recommendations.push(' Configure NEXT_PUBLIC_SUPABASE_ANON_KEY environment variable');
    }
    if (!status.environment_variables.supabaseServiceKey) {
        recommendations.push(' Configure SUPABASE_SERVICE_ROLE_KEY environment variable');
    }
    if (!status.supabase.connected) {
        recommendations.push(' Fix Supabase connection issue');
        if (typeof status.supabase.error === 'string' &amp;&amp; status.supabase.error.length &gt; 0) {
            recommendations.push(`   Error: ${status.supabase.error}`);
        }
    }
    if (status.supabase.authSettings?.googleEnabled === true) {
        recommendations.push(' Google OAuth provider is enabled');
    }
    else {
        recommendations.push(' Enable Google OAuth provider in Supabase Dashboard', '   Go to: Authentication &gt; Providers &gt; Google');
    }
    if (status.overall_status === 'ready') {
        recommendations.push(' OAuth configuration is complete!', ' Test the login flow at /login');
    }
    if (recommendations.length &gt; 1) {
        recommendations.push(' See docs/GOOGLE_OAUTH_SETUP_GUIDE.md for detailed instructions', ' Run: npm run oauth:verify for automated checks');
    }
    return recommendations;
}
/**
 * Determines the overall OAuth status based on provided conditions.
 * @example
 * determineOverallStatus(status)
 * 'ready'
 * @param {OAuthStatus} status - The status object containing configuration details.
 * @returns {'ready' | 'partial' | 'not_configured' | 'error'} Overall status derived from the evaluations.
 * @description
 *   - Evaluates connectivity and configuration status from various parameters within the status object.
 *   - Prioritizes returning 'error' if Supabase connection fails or if an error is detected.
 *   - Checks completeness of environment variables before proceeding to other status evaluations.
 *   - Distinguishes between 'ready' and 'partial' based on specific OAuth settings.
 */
function determineOverallStatus(status) {
    // eslint-disable-next-line sonarjs/different-types-comparison
    if (!status.supabase.connected || status.supabase.error !== null) {
        return 'error';
    }
    const envVarsComplete = Object.values(status.environment_variables).every(Boolean);
    if (!envVarsComplete) {
        return 'not_configured';
    }
    if (status.supabase.authSettings?.googleEnabled &amp;&amp; status.oauth_flow.authProviderConfigured) {
        return 'ready';
    }
    if (status.supabase.connected &amp;&amp; envVarsComplete) {
        return 'partial';
    }
    return 'not_configured';
}
/**
 * Retrieves a human-readable message based on the OAuth configuration status.
 * @example
 * getStatusMessage('ready')
 * 'Google OAuth is fully configured and ready to use'
 * @param {string} status - The current status of the OAuth configuration.
 * @returns {string} A message explaining the OAuth configuration status.
 * @description
 *   - Handles several predefined status cases.
 *   - Provides feedback for both success and error states.
 *   - Returns a default message for unrecognized statuses.
 */
function getStatusMessage(status) {
    switch (status) {
        case 'ready': {
            return 'Google OAuth is fully configured and ready to use';
        }
        case 'partial': {
            return 'Basic configuration complete, OAuth provider needs setup';
        }
        case 'not_configured': {
            return 'Google OAuth is not configured';
        }
        case 'error': {
            return 'Configuration error detected';
        }
        default: {
            return 'Unknown configuration status';
        }
    }
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/lib/api/admin/data-quality/handlers.js (Line 2:17 - Line 207:2), C:/AI/food-truck-finder-poc/dist/lib/lib/api/admin/data-quality/handlers.js (Line 2:27 - Line 207:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn14" onclick="toggleCodeBlock('cloneGroup14', 'expandBtn14', 'collapseBtn14')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn14" onclick="toggleCodeBlock('cloneGroup14', 'expandBtn14', 'collapseBtn14')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup14"><code class="language-javascript text-sm text-gray-800">;
/**
 * Handles GET requests by executing different actions based on query parameters.
 * @example
 * handleGetRequest(request)
 * Returns a response based on the action specified in the query parameters.
 * @param {NextRequest} request - The incoming request object containing URL and query parameters.
 * @returns {Promise&lt;NextResponse&gt;} A Promise resolving to a NextResponse object with the result of the action.
 * @description
 *   - Processes 'stats', 'assess', and defaults actions based on the 'action' query parameter.
 *   - Requires 'truckId' for the 'assess' action; otherwise, returns a 400 error.
 *   - Utilizes async handling for processing actions.
 */
export async function handleGetRequest(request) {
    const { searchParams } = new URL(request.url);
    const action = searchParams.get('action');
    const truckId = searchParams.get('truckId');
    switch (action) {
        case 'stats': {
            return await handleStatsAction();
        }
        case 'assess': {
            if (!truckId) {
                return NextResponse.json({ success: false, error: 'Missing truckId for assess action' }, { status: 400 });
            }
            return await handleAssessAction(truckId);
        }
        default: {
            return await handleDefaultGetAction();
        }
    }
}
/**
* Handles different types of POST requests by determining the action and executing appropriate functions.
* @example
* handlePostRequest(request)
* NextResponse containing success status and result or error message
* @param {NextRequest} request - Incoming request object containing body data as JSON.
* @returns {Promise&lt;NextResponse&gt;} Response indicating success or failure and any relevant data or error messages.
* @description
*   - Validates request body to ensure it's a non-null object.
*   - Extracts action and truckId from request body to decide on processing steps.
*   - Handles actions like &quot;update-single&quot;, &quot;batch-update&quot;, and &quot;recalculate-all&quot;, returning an appropriate NextResponse.
*   - Responds with an error JSON if the action is unknown or if required fields are missing.
*/
export async function handlePostRequest(request) {
    const body = await request.json();
    if (typeof body !== 'object' || body === null) {
        return NextResponse.json({ success: false, error: 'Invalid request body' }, { status: 400 });
    }
    const { action, truckId } = body;
    switch (action) {
        case 'update-single': {
            if (truckId === undefined || truckId === '') {
                return NextResponse.json({ success: false, error: 'Missing truckId for update-single action' }, { status: 400 });
            }
            return await handleUpdateSingle(truckId);
        }
        case 'batch-update': {
            return handleBatchUpdate();
        }
        case 'recalculate-all': {
            return await handleRecalculateAll();
        }
        default: {
            return NextResponse.json({ success: false, error: `Unknown action: ${action}` }, { status: 400 });
        }
    }
}
async function handleStatsAction() {
    const qualityStats = await FoodTruckService.getDataQualityStats();
    return NextResponse.json({
        success: true,
        data: {
            ...qualityStats,
            timestamp: new Date().toISOString(),
        },
    });
}
/**
 * Processes and returns the assessment result of a food truck action by its ID.
 * @example
 * handleAssessAction(&quot;12345&quot;)
 * { success: true, data: { truckId: &quot;12345&quot;, truckName: &quot;Best Food Truck&quot;, currentScore: 95, timestamp: &quot;2023-10-05T14:48:00.000Z&quot; } }
 * @param {string} truckId - The identifier of the food truck to be assessed.
 * @returns {object} Returns a JSON response containing either the assessment data or an error.
 * @description
 *   - Retrieves data of the specified food truck using FoodTruckService.
 *   - Casts the retrieved data explicitly to a FoodTruck object type to ensure type safety.
 *   - Responds with a 404 status and the error description if the truck is not found.
 */
async function handleAssessAction(truckId) {
    const truckResult = await FoodTruckService.getTruckById(truckId);
    if ('error' in truckResult) {
        return NextResponse.json({ success: false, error: truckResult.error }, { status: 404 });
    }
    const truck = truckResult; // Explicitly cast to FoodTruck
    return NextResponse.json({
        success: true,
        data: {
            truckId,
            truckName: truck.name,
            currentScore: truck.data_quality_score,
            timestamp: new Date().toISOString(),
        },
    });
}
async function handleDefaultGetAction() {
    const qualityStats = await FoodTruckService.getDataQualityStats();
    return NextResponse.json({
        success: true,
        data: qualityStats,
    });
}
/**
 * Handles updating a single food truck's quality score and returns the result.
 * @example
 * handleUpdateSingle(&quot;1234&quot;)
 * { success: true, message: 'Quality score updated successfully', data: { truckId: '1234', truckName: 'Food Truck A', newScore: 95, verificationStatus: 'verified', timestamp: '2023-10-30T14:48:00.000Z' } }
 * @param {string} truckId - The unique identifier of the food truck to update.
 * @returns {Object} An object containing the success status, message, and either updated truck data or error information.
 * @description
 *   - Utilizes `FoodTruckService.getTruckById` to fetch truck details.
 *   - Responds differently based on whether an error is encountered or not.
 *   - Formats the response appropriately for successful updates.
 *   - Includes a timestamp in the response when successful.
 */
async function handleUpdateSingle(truckId) {
    const updatedTruckResult = await FoodTruckService.getTruckById(truckId);
    if ('error' in updatedTruckResult) {
        return NextResponse.json({ success: false, error: updatedTruckResult.error }, { status: 404 });
    }
    const updatedTruck = updatedTruckResult;
    return NextResponse.json({
        success: true,
        message: 'Quality score updated successfully',
        data: {
            truckId: updatedTruck.id,
            truckName: updatedTruck.name,
            newScore: updatedTruck.data_quality_score,
            verificationStatus: updatedTruck.verification_status,
            timestamp: new Date().toISOString(),
        },
    });
}
function handleBatchUpdate() {
    return NextResponse.json({
        success: true,
        message: 'Batch quality score update completed',
        data: {
            timestamp: new Date().toISOString(),
        },
    });
}
function updateSingleTruckQualityScore(truck) {
    try {
        // Placeholder for actual update logic if needed
        // DataQualityService.updateTruckQualityScore(truck.id);
        return true;
    }
    catch (error) {
        console.error(`Failed to update truck ${truck.id}:`, error);
        return false;
    }
}
/**
 * Recalculates the quality score for all food trucks.
 * @example
 * handleRecalculateAll()
 * { success: true, message: 'Quality score recalculation completed', data: { totalTrucks: 100, updated: 95, errors: 5, timestamp: '2023-10-07T10:30:00.000Z' } }
 * @param {undefined} undefined - No arguments are needed.
 * @returns {Object} JSON response with success status, message, and data containing recalculation statistics.
 * @description
 *   - Fetches all food trucks in batches for recalculation using the FoodTruckService.
 *   - Logs an error message if the API call to fetch all trucks fails.
 *   - Updates the `qualityScore` for each truck and maintains a count of successful and unsuccessful updates.
 */
async function handleRecalculateAll() {
    const allTrucksResult = await FoodTruckService.getAllTrucks(1000, 0);
    if (allTrucksResult.error !== undefined) {
        console.error('Error fetching all trucks for recalculation:', allTrucksResult.error);
        return NextResponse.json({ success: false, error: 'Failed to fetch trucks for recalculation' }, { status: 500 });
    }
    const { trucks } = allTrucksResult;
    let updated = 0;
    let errors = 0;
    for (const truck of trucks) {
        const success = updateSingleTruckQualityScore(truck);
        if (success) {
            updated += 1;
        }
        else {
            errors += 1;
        }
    }
    return NextResponse.json({
        success: true,
        message: 'Quality score recalculation completed',
        data: {
            totalTrucks: trucks.length,
            updated,
            errors,
            timestamp: new Date().toISOString(),
        },
    });
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/lib/api/admin/data-cleanup/handlers.js (Line 1:1 - Line 246:2), C:/AI/food-truck-finder-poc/dist/lib/lib/api/admin/data-cleanup/handlers.js (Line 1:1 - Line 246:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn15" onclick="toggleCodeBlock('cloneGroup15', 'expandBtn15', 'collapseBtn15')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn15" onclick="toggleCodeBlock('cloneGroup15', 'expandBtn15', 'collapseBtn15')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup15"><code class="language-javascript text-sm text-gray-800">import { NextResponse } from 'next/server';
import { BatchCleanupService } from '../../data-quality/batchCleanup.js';
import { DuplicatePreventionService } from '../../data-quality/duplicatePrevention.js';
/**
 * Handles different types of data cleanup requests and returns appropriate responses.
 * @example
 * handlePostRequest({ action: 'full-cleanup', options: {} })
 * returns a promise resolving to a NextResponse with cleanup result
 * @param {DataCleanupRequestBody} body - Object containing an action type and optional parameters for the cleanup process.
 * @returns {Promise&lt;NextResponse&gt;} Resolves to a NextResponse object indicating success or failure with details about the performed action.
 * @description
 *   - Handles specific actions: 'full-cleanup', 'check-duplicates', 'merge-duplicates', 'dry-run'.
 *   - Defaults to returning an error response for unknown actions.
 *   - Provides flexibility in defining options for each specific cleanup action.
 *   - Integrates with Next.js response mechanism for API endpoints.
 */
export async function handlePostRequest(body) {
    const { action, options = {} } = body;
    switch (action) {
        case 'full-cleanup': {
            return await handleFullCleanup(options);
        }
        case 'check-duplicates': {
            return await handleCheckDuplicates(options);
        }
        case 'merge-duplicates': {
            return await handleMergeDuplicates(options);
        }
        case 'dry-run': {
            return await handleDryRun(options);
        }
        default: {
            return NextResponse.json({ success: false, error: `Unknown action: ${action}` }, { status: 400 });
        }
    }
}
/**
 * Processes a GET request and performs actions based on query parameters.
 * @example
 * handleGetRequest(request)
 * Promise&lt;NextResponse&gt;
 * @param {NextRequest} request - Incoming Next.js request object containing the URL and search parameters.
 * @returns {Promise&lt;NextResponse&gt;} Promise resolving to a NextResponse object.
 * @description
 *   - It extracts the `action` parameter from the request URL's query string.
 *   - Based on the action parameter value, it delegates the request to specific handlers like `handleGetStatus`, `handleGetPreview`, or `handleGetDefault`.
 *   - Handles asynchronous operations within the action cases when necessary (e.g., `preview`).
 *   - Ensures proper response handling while maintaining the server-side asynchronous flow.
 */
export async function handleGetRequest(request) {
    const { searchParams } = new URL(request.url);
    const action = searchParams.get('action');
    switch (action) {
        case 'status': {
            return handleGetStatus();
        }
        case 'preview': {
            return await handleGetPreview();
        }
        default: {
            return handleGetDefault();
        }
    }
}
/**
* Executes a full data cleanup operation based on provided options.
* @example
* handleFullCleanup({ batchSize: 100, dryRun: true, operations: ['removeDuplicates', 'optimizeData'] })
* Returns a JSON response confirming the success of the cleanup.
* @param {Object} options - Configuration for the cleanup operation.
* @returns {Promise&lt;Object&gt;} A JSON response with the cleanup result summary.
* @description
*   - Default batch size for cleanup is set to 50 if not specified.
*   - Supports a dry-run mode for testing cleanup without making changes.
*   - Utilizes operations parameter to specify types of cleanup tasks.
*   - Provides detailed summary in the response message.
*/
export async function handleFullCleanup(options) {
    const result = await BatchCleanupService.runFullCleanup({
        batchSize: options?.batchSize ?? 50,
        dryRun: options?.dryRun ?? false,
        operations: options?.operations,
    });
    return NextResponse.json({
        success: true,
        action: 'full-cleanup',
        result,
        message: `Cleanup completed: ${result.summary.trucksImproved} trucks improved, ${result.summary.duplicatesRemoved} duplicates removed`,
    });
}
/**
 * Handles the duplicate check functionality for truck data.
 * @example
 * handleCheckDuplicates({ options: { truckData: [...] } })
 * Returns a promise with a JSON response indicating success or failure of duplicate check.
 * @param {DataCleanupRequestBody['options']} options - The request body containing truck data to be checked.
 * @returns {Promise&lt;NextResponse&gt;} A promise that resolves to a NextResponse object containing the result of the duplicate check.
 * @description
 *   - Utilizes the Duplicate Prevention Service to verify the presence of duplicates.
 *   - Expects `truckData` within the provided options for processing.
 *   - Returns an error JSON response with status 400 if `truckData` is not supplied.
 */
export async function handleCheckDuplicates(options) {
    const { truckData } = options ?? {};
    if (!truckData) {
        return NextResponse.json({ success: false, error: 'Missing truckData for duplicate check' }, { status: 400 });
    }
    const duplicateCheck = await DuplicatePreventionService.checkForDuplicates(truckData);
    return NextResponse.json({
        success: true,
        action: 'check-duplicates',
        result: duplicateCheck,
    });
}
/**
* Handles the merge operation for duplicate truck entries.
* @example
* handleMergeDuplicates({ targetId: '123', sourceId: '456' })
* Returns a NextResponse indicating the success or failure of the merge operation.
* @param {DataCleanupRequestBody['options']} options - Options containing targetId and sourceId for the merge operation.
* @returns {Promise&lt;NextResponse&gt;} Returns a NextResponse object indicating the merge result.
* @description
*   - Utilizes DuplicatePreventionService to merge duplicate entries.
*   - Sends an error response with status 400 if targetId or sourceId is missing.
*/
export async function handleMergeDuplicates(options) {
    const { targetId, sourceId } = options ?? {};
    if (targetId === undefined || sourceId === undefined) {
        return NextResponse.json({ success: false, error: 'Missing targetId or sourceId for merge operation' }, { status: 400 });
    }
    const mergedTruck = await DuplicatePreventionService.mergeDuplicates(targetId, sourceId);
    return NextResponse.json({
        success: true,
        action: 'merge-duplicates',
        result: mergedTruck,
        message: `Successfully merged truck ${sourceId} into ${targetId}`,
    });
}
/**
 * Executes a dry run of the data cleanup process without making changes to the database.
 * @example
 * handleDryRun({ operations: ['deleteUnused', 'optimizeData'] })
 * Promise resolves to NextResponse with details of the dry run.
 * @param {DataCleanupRequestBody['options']} options - Cleanup options including operations to simulate.
 * @returns {Promise&lt;NextResponse&gt;} A response object indicating the success of the dry run and its results.
 * @description
 *   - Utilizes the BatchCleanupService to simulate cleanup operations.
 *   - Ensures no changes are made to the database during the dry run.
 *   - Provides details of simulated operations in the response result.
 */
export async function handleDryRun(options) {
    const result = await BatchCleanupService.runFullCleanup({
        ...options,
        operations: options?.operations,
        dryRun: true,
    });
    return NextResponse.json({
        success: true,
        action: 'dry-run',
        result,
        message: 'Dry run completed - no changes made to database',
    });
}
/**
* Returns the current status with details on available operations, default batch size, and dry-run support.
* @example
* handleGetStatus()
* returns a JSON response with success status and operational details
* @returns {NextResponse} JSON response containing operation details.
* @description
*   - Lists available operations such as 'remove_placeholders', 'normalize_phone', and more.
*   - Provides default batch size set to 50.
*   - Indicates support for dry-run operations.
*/
export function handleGetStatus() {
    return NextResponse.json({
        success: true,
        status: {
            available_operations: [
                'remove_placeholders',
                'normalize_phone',
                'fix_coordinates',
                'update_quality_scores',
                'merge_duplicates',
            ],
            default_batch_size: 50,
            supports_dry_run: true,
        },
    });
}
/**
 * Generates a preview of the batch cleanup process.
 * @example
 * handleGetPreview()
 * Promise&lt;NextResponse&gt;
 * @returns {Promise&lt;NextResponse&gt;} Returns a JSON response containing the cleanup preview.
 * @description
 *   - Utilizes the BatchCleanupService to execute a dry run with a specified batch size.
 *   - Extracts summary information including estimated improvements and duplicates removed.
 *   - Structures the operations in a detailed format for review.
 */
export async function handleGetPreview() {
    const result = await BatchCleanupService.runFullCleanup({
        batchSize: 10,
        dryRun: true,
    });
    return NextResponse.json({
        success: true,
        preview: {
            estimated_improvements: result.summary.trucksImproved,
            estimated_duplicates: result.summary.duplicatesRemoved,
            operations: result.operations.map((op) =&gt; ({
                type: op.type,
                description: op.description,
                affected_count: op.affectedCount,
            })),
        },
    });
}
/**
* Provides a JSON response containing available endpoints and actions related to data cleanup.
* @example
* handleGetDefault()
* Returns a JSON response with success status, endpoints, and actions.
* @returns {NextResponse} Returns a JSON response with structure defining success, endpoints, and actions related to data cleanup.
* @description
*   - The function targets administrative cleanup operations within the system.
*   - Provides metadata for functionalities aimed at data cleanup processes.
*   - Intended to support endpoint consumption and decision-making for administrative tasks.
*/
export function handleGetDefault() {
    return NextResponse.json({
        success: true,
        endpoints: [
            'GET /api/admin/data-cleanup?action=status - Get cleanup system status',
            'GET /api/admin/data-cleanup?action=preview - Preview cleanup changes',
            'POST /api/admin/data-cleanup - Run cleanup operations',
        ],
        actions: [
            'full-cleanup - Run all cleanup operations',
            'check-duplicates - Check if truck data is duplicate',
            'merge-duplicates - Merge two duplicate trucks',
            'dry-run - Preview changes without making them',
        ],
    });
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/lib/api/admin/automated-cleanup/handlers.js (Line 1:1 - Line 461:2), C:/AI/food-truck-finder-poc/dist/lib/lib/api/admin/automated-cleanup/handlers.js (Line 1:1 - Line 461:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn17" onclick="toggleCodeBlock('cloneGroup17', 'expandBtn17', 'collapseBtn17')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn17" onclick="toggleCodeBlock('cloneGroup17', 'expandBtn17', 'collapseBtn17')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup17"><code class="language-javascript text-sm text-gray-800">import { NextResponse } from 'next/server';
import { BatchCleanupService } from '../../data-quality/batchCleanup.js';
/**
 * Handles post requests by executing specific actions based on the provided body.
 * @example
 * handlePostRequest({ action: 'run_scheduled', options: { key: 'value' } })
 * Returns the result of executing handleRunScheduled with the provided options.
 * @param {Object} body - The body of the request containing action type and optional parameters.
 * @param {string} body.action - The action to perform such as 'run_scheduled', 'update_schedule', etc.
 * @param {Object} [body.options] - Optional parameters for the specified action, default is an empty object.
 * @returns {Promise&lt;Object&gt;} Resolves with the result of the corresponding action handler or an error object for unknown actions.
 * @description
 *   - Supports multiple predefined actions like scheduling, running, and cleanup operations.
 *   - Provides feedback on available actions when an unknown action is specified.
 *   - Uses async functions to perform operations, ensuring asynchronous behavior.
 *   - Returns JSON responses compliant with NextResponse standards.
 */
function isRunScheduledOptions(obj) {
    return typeof obj.scheduleId === &quot;string&quot;;
}
function isRunImmediateOptions(obj) {
    return ((obj.operations === undefined || Array.isArray(obj.operations)) &amp;&amp;
        (obj.batchSize === undefined || typeof obj.batchSize === &quot;number&quot;) &amp;&amp;
        (obj.dryRun === undefined || typeof obj.dryRun === &quot;boolean&quot;));
}
function isScheduleCleanupOptions(obj) {
    return (typeof obj.name === &quot;string&quot; &amp;&amp;
        Array.isArray(obj.operations) &amp;&amp;
        typeof obj.schedule === &quot;string&quot; &amp;&amp;
        (obj.enabled === undefined || typeof obj.enabled === &quot;boolean&quot;));
}
function isUpdateScheduleOptions(obj) {
    return (typeof obj.scheduleId === &quot;string&quot; &amp;&amp;
        typeof obj.updates === &quot;object&quot;);
}
function isDeleteScheduleOptions(obj) {
    return typeof obj.scheduleId === &quot;string&quot;;
}
export async function handlePostRequest(body) {
    const { action, options = {} } = body;
    switch (action) {
        case 'run_scheduled': {
            if (!isRunScheduledOptions(options)) {
                return NextResponse.json({ success: false, error: 'Invalid options for run_scheduled' }, { status: 400 });
            }
            return await handleRunScheduled(options);
        }
        case 'run_immediate': {
            if (!isRunImmediateOptions(options)) {
                return NextResponse.json({ success: false, error: 'Invalid options for run_immediate' }, { status: 400 });
            }
            return await handleRunImmediate(options);
        }
        case 'schedule_cleanup': {
            if (!isScheduleCleanupOptions(options)) {
                return NextResponse.json({ success: false, error: 'Invalid options for schedule_cleanup' }, { status: 400 });
            }
            return await handleScheduleCleanup(options);
        }
        case 'update_schedule': {
            if (!isUpdateScheduleOptions(options)) {
                return NextResponse.json({ success: false, error: 'Invalid options for update_schedule' }, { status: 400 });
            }
            return await handleUpdateSchedule(options);
        }
        case 'delete_schedule': {
            if (!isDeleteScheduleOptions(options)) {
                return NextResponse.json({ success: false, error: 'Invalid options for delete_schedule' }, { status: 400 });
            }
            return await handleDeleteSchedule(options);
        }
        default: {
            return NextResponse.json({
                success: false,
                error: 'Unknown action',
                available_actions: [
                    'run_scheduled',
                    'run_immediate',
                    'schedule_cleanup',
                    'update_schedule',
                    'delete_schedule',
                    'analyze_duplicates',
                ],
            }, { status: 400 });
        }
    }
}
export async function handleGetStatus() {
    const status = await getCleanupStatus();
    return NextResponse.json({
        success: true,
        status,
    });
}
export async function handleGetSchedules() {
    const schedules = await getCleanupSchedules();
    return NextResponse.json({
        success: true,
        schedules,
    });
}
export async function handleGetHistory(searchParams) {
    const limit = Number.parseInt(searchParams.get('limit') ?? '10', 10);
    const history = await getCleanupHistory(limit);
    return NextResponse.json({
        success: true,
        history,
    });
}
export async function handleGetPreview(searchParams) {
    const operations = searchParams.get('operations')?.split(',') ?? [];
    const preview = await previewCleanupOperations(operations);
    return NextResponse.json({
        success: true,
        preview,
    });
}
/**
 * Handles the retrieval of default cleanup status and returns a JSON response.
 * @example
 * handleGetDefault().then(response =&gt; console.log(response));
 * // { success: true, status: ..., endpoints: [...] }
 * @param {none} {none} - No arguments are required for this function.
 * @returns {Promise&lt;NextResponse&gt;} A promise that resolves to a NextResponse JSON object containing cleanup status and endpoints.
 * @description
 *   - Utilizes the getCleanupStatus function to fetch the current cleanup status.
 *   - Constructs a response object detailing available cleanup-related endpoints.
 *   - Follow API endpoint descriptions to properly utilize cleanup functionalities.
 */
export async function handleGetDefault() {
    const status = await getCleanupStatus();
    return NextResponse.json({
        success: true,
        status,
        endpoints: [
            'GET ?action=status - Get overall cleanup status',
            'GET ?action=schedules - Get cleanup schedules',
            'GET ?action=history&amp;limit=N - Get cleanup history',
            'GET ?action=preview&amp;operations=op1,op2 - Preview cleanup operations',
            'POST - Run cleanup operations',
        ],
    });
}
export async function handleRunScheduled(options) {
    const { scheduleId } = options;
    const result = await runScheduledCleanup(scheduleId);
    return NextResponse.json({
        success: true,
        action: 'run_scheduled',
        result,
    });
}
/**
* Executes a batch cleanup operation immediately based on provided options.
* @example
* handleRunImmediate({ dryRun: true, batchSize: 100 })
* Returns: { success: true, action: 'run_immediate', result: {...}, message: 'Dry run completed successfully' }
* @param {Object} options - Configuration options for the cleanup operation.
* @returns {Promise&lt;NextResponse&gt;} A promise that resolves to the NextResponse object containing the cleanup result.
* @description
*   - The `operations` parameter defaults to a set of predefined cleanup tasks if not specified.
*   - If `dryRun` is true, the function simulates the cleanup without making any modifications.
*   - Utilizes `BatchCleanupService` for executing the cleanup logic.
*   - Operation results are logged with `logCleanupOperation` for tracking purposes.
*/
export async function handleRunImmediate(options) {
    const { operations = [
        'remove_placeholders',
        'normalize_phone',
        'fix_coordinates',
        'update_quality_scores',
    ], batchSize = 50, dryRun = false, } = options;
    const result = await BatchCleanupService.runFullCleanup({
        operations: operations,
        batchSize,
        dryRun,
    });
    await logCleanupOperation('immediate', result, options);
    return NextResponse.json({
        success: true,
        action: 'run_immediate',
        result,
        message: dryRun ? 'Dry run completed successfully' : 'Cleanup completed successfully',
    });
}
export async function handleScheduleCleanup(options) {
    const { name, operations, schedule, enabled = true } = options;
    const scheduleResult = await createCleanupSchedule(name, operations, schedule, enabled);
    return NextResponse.json({
        success: true,
        action: 'schedule_cleanup',
        result: scheduleResult,
    });
}
export async function handleUpdateSchedule(options) {
    const { scheduleId, updates } = options;
    const updateResult = await updateCleanupSchedule(scheduleId, updates);
    return NextResponse.json({
        success: true,
        action: 'update_schedule',
        result: updateResult,
    });
}
export async function handleDeleteSchedule(options) {
    const { scheduleId } = options;
    const deleteResult = await deleteCleanupSchedule(scheduleId);
    return NextResponse.json({
        success: true,
        action: 'delete_schedule',
        result: deleteResult,
    });
}
export async function handleAnalyzeDuplicates(options) {
    const { threshold = 0.8 } = options;
    const analysis = await analyzeDuplicates(threshold);
    return NextResponse.json({
        success: true,
        action: 'analyze_duplicates',
        result: analysis,
    });
}
/**
 * Retrieves the status of automated cleanup operations.
 * @example
 * getCleanupStatus()
 * // returns: Promise&lt;AutomatedCleanupStatus&gt;
 * @returns {Promise&lt;AutomatedCleanupStatus&gt;} An object representing the status of cleanup operations.
 * @description
 *   - The status includes statistics on cleanup runs such as total number of runs, successful runs, and failed runs.
 *   - Provides information on whether a cleanup operation is currently running and when it last ran.
 *   - Fetches schedules asynchronously using the getCleanupSchedules() function.
 *   - Includes data on recent cleanup results and operations performed, such as the number of trucks improved and duplicates removed.
 */
async function getCleanupStatus() {
    return {
        isRunning: false,
        lastRun: new Date(Date.now() - 3_600_000).toISOString(),
        nextScheduledRun: new Date(Date.now() + 3_600_000).toISOString(),
        schedules: await getCleanupSchedules(),
        recentResults: [],
        statistics: {
            totalRuns: 42,
            successfulRuns: 40,
            failedRuns: 2,
            trucksImproved: 156,
            duplicatesRemoved: 23,
        },
    };
}
/**
 * Retrieves the scheduled cleanup operations including their details.
 * @example
 * getCleanupSchedules()
 * Promise resolves to an array of cleanup schedule objects.
 * @returns {Promise&lt;CleanupSchedule[]&gt;} Promise resolving to an array of cleanup schedule objects.
 * @description
 *   - Schedules are defined using cron-like syntax for timing.
 *   - Both daily and weekly cleanup operations are included.
 *   - Each schedule has a record of success and error counts from the last execution.
 *   - Each schedule has a record of success and error counts from the last execution.
 *   - Enabled status indicates if the schedule is currently active.
 */
function getCleanupSchedules() {
    return Promise.resolve([
        {
            id: 'daily-maintenance',
            name: 'Daily Maintenance Cleanup',
            operations: ['remove_placeholders', 'normalize_phone', 'update_quality_scores'],
            schedule: '0 2 * * *',
            enabled: true,
            lastRun: new Date(Date.now() - 86_400_000).toISOString(),
            nextRun: new Date(Date.now() + 3_600_000).toISOString(),
            successCount: 30,
            errorCount: 1,
        },
        {
            id: 'weekly-deep-clean',
            name: 'Weekly Deep Cleanup',
            operations: [
                'remove_placeholders',
                'normalize_phone',
                'fix_coordinates',
                'update_quality_scores',
                'merge_duplicates',
            ],
            schedule: '0 3 * * 0',
            enabled: true,
            lastRun: new Date(Date.now() - 604_800_000).toISOString(),
            nextRun: new Date(Date.now() + 259_200_000).toISOString(),
            successCount: 4,
            errorCount: 0,
        },
    ]);
}
function getCleanupHistory(_limit) {
    return Promise.resolve([]);
}
/**
 * Generates a preview of cleanup operations and their estimated impact.
 * @example
 * previewCleanupOperations(['delete_logs', 'archive_data'])
 * // Returns a Promise resolving to an object with estimated changes and operation details
 * @param {string[]} operations - An array of cleanup operation names to preview.
 * @returns {Promise&lt;PreviewResult&gt;} A promise that resolves to a preview result containing estimated changes and details.
 * @description
 *   - The function uses BatchCleanupService to simulate cleanup operations in a dry-run mode.
 *   - Each operation's details include types, descriptions, and counts of affected, successful, and erroneous items.
 *   - Returns comprehensive information including estimated changes, durations, and affected entities.
 */
async function previewCleanupOperations(operations) {
    try {
        const result = await BatchCleanupService.runFullCleanup({
            operations: operations,
            batchSize: 10,
            dryRun: true,
        });
        return {
            estimatedChanges: result.summary,
            operationDetails: (() =&gt; {
                const details = {};
                for (const [index, op] of result.operations.entries()) {
                    details[`operation_${index}`] = {
                        type: op.type,
                        description: op.description,
                        affectedCount: op.affectedCount,
                        successCount: op.successCount,
                        errorCount: op.errorCount,
                    };
                }
                return details;
            })(),
            estimatedDuration: result.duration,
            affectedTrucks: result.totalProcessed,
        };
    }
    catch (error) {
        throw new Error(`Preview failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
}
/**
 * Executes a cleanup based on a given schedule ID.
 * @example
 * runScheduledCleanup('schedule123')
 * { success: true, cleanedRecords: 150 }
 * @param {string} scheduleId - The ID of the cleanup schedule to run.
 * @returns {Promise&lt;Record&lt;string, unknown&gt;&gt;} Result of the cleanup operation.
 * @description
 *   - Throws an error if the schedule is not found or is disabled.
 *   - Utilizes BatchCleanupService for performing the cleanup operation.
 *   - Logs the result of the cleanup operation with a 'scheduled' context.
 */
async function runScheduledCleanup(scheduleId) {
    const schedules = await getCleanupSchedules();
    const schedule = schedules.find((s) =&gt; s.id === scheduleId);
    if (!schedule) {
        throw new Error(`Schedule ${scheduleId} not found`);
    }
    if (!schedule.enabled) {
        throw new Error(`Schedule ${scheduleId} is disabled`);
    }
    const result = await BatchCleanupService.runFullCleanup({
        operations: schedule.operations,
        batchSize: 50,
        dryRun: false,
    });
    await logCleanupOperation('scheduled', result, { scheduleId });
    return result;
}
/**
* Creates a cleanup schedule with the specified parameters
* @example
* createCleanupSchedule('Daily Cleanup', ['delete', 'archive'], '0 0 * * *', true)
* Promise&lt;ScheduleCreateResult&gt; { id: 'schedule-1609459200000', name: 'Daily Cleanup', operations: ['delete', 'archive'], schedule: '0 0 * * *', enabled: true, created: '2021-01-01T00:00:00.000Z' }
* @param {string} name - The name of the cleanup schedule.
* @param {Array&lt;string&gt;} operations - List of operations to be included in the cleanup.
* @param {string} schedule - Cron-style string for schedule timings.
* @param {boolean} enabled - Status of whether the schedule is active.
* @returns {Promise&lt;ScheduleCreateResult&gt;} Promise resolving to the details of the created schedule.
* @description
*   - Returns a Promise that resolves to a ScheduleCreateResult object.
*   - Automatically generates a unique ID based on the current timestamp.
*   - Includes a creation timestamp in ISO format.
*/
function createCleanupSchedule(name, operations, schedule, enabled) {
    return Promise.resolve({
        id: `schedule-${Date.now()}`,
        name,
        operations,
        schedule,
        enabled,
        created: new Date().toISOString(),
    });
}
function updateCleanupSchedule(scheduleId, updates) {
    return Promise.resolve({
        scheduleId,
        updates,
        updated: new Date().toISOString(),
    });
}
function deleteCleanupSchedule(scheduleId) {
    return Promise.resolve({
        scheduleId,
        deleted: new Date().toISOString(),
    });
}
/**
* Analyzes duplicates based on a given threshold and returns a summary of the analysis.
* @example
* analyzeDuplicates(0.8)
* // Returns: { threshold: 0.8, potentialDuplicates: 0, highConfidenceMatches: 0, mediumConfidenceMatches: 0, lowConfidenceMatches: 0, analysisTime: &quot;2023-10-01T12:34:56.789Z&quot; }
* @param {number} threshold - The threshold value used to determine duplicate matching confidence.
* @returns {Promise&lt;DuplicateAnalysisResult&gt;} An object representing the duplicate analysis results including counts of potential matches and confidence levels.
* @description
*   - Executes the analysis asynchronously, returning a promise that resolves with the analysis results.
*   - Initializes match counts to zero as defaults.
*   - Includes the analysis time formatted as an ISO string.
*/
function analyzeDuplicates(threshold) {
    try {
        return Promise.resolve({
            threshold,
            potentialDuplicates: 0,
            highConfidenceMatches: 0,
            mediumConfidenceMatches: 0,
            lowConfidenceMatches: 0,
            analysisTime: new Date().toISOString(),
        });
    }
    catch (error) {
        throw new Error(`Duplicate analysis failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
}
/**
 * Logs the completion details of a cleanup operation.
 * @example
 * logCleanupOperation('database', {summary: {success: true}}, {verbose: true})
 * // No return value
 * @param {string} type - The type of cleanup operation performed (e.g., 'database').
 * @param {Record&lt;string, unknown&gt;} result - An object containing the results of the cleanup operation.
 * @param {Record&lt;string, unknown&gt;} options - Additional options related to the logging of the cleanup.
 * @returns {Promise&lt;void&gt;} A Promise that resolves when the logging is complete.
 * @description
 *   - Utilizes `console.info` for successful logging and `console.warn` for handling errors during logging.
 *   - Ensures the operation's details include the type, result summary, options, and a timestamp.
 */
function logCleanupOperation(type, result, options) {
    try {
        console.info(`Cleanup operation completed:`, {
            type,
            result: result.summary,
            options,
            timestamp: new Date().toISOString(),
        });
        return Promise.resolve();
    }
    catch (error) {
        console.warn('Failed to log cleanup operation:', error);
        return Promise.resolve();
    }
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/app/api/admin/realtime-events/route.js (Line 33:30 - Line 43:2), C:/AI/food-truck-finder-poc/dist/app/api/admin/realtime-events/route.js (Line 13:29 - Line 23:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn19" onclick="toggleCodeBlock('cloneGroup19', 'expandBtn19', 'collapseBtn19')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn19" onclick="toggleCodeBlock('cloneGroup19', 'expandBtn19', 'collapseBtn19')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup19"><code class="language-javascript text-sm text-gray-800">, error);
        return new Response(JSON.stringify({
            success: false,
            error: 'Internal server error',
            details: error instanceof Error ? error.message : 'Unknown error',
        }), {
            status: 500,
            headers: { 'Content-Type': 'application/json' },
        });
    }
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/app/api/admin/data-quality/route.js (Line 2:40 - Line 10:8), C:/AI/food-truck-finder-poc/dist/app/api/admin/scraping-metrics/route.js (Line 2:44 - Line 10:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn20" onclick="toggleCodeBlock('cloneGroup20', 'expandBtn20', 'collapseBtn20')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn20" onclick="toggleCodeBlock('cloneGroup20', 'expandBtn20', 'collapseBtn20')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup20"><code class="language-javascript text-sm text-gray-800">;
import { verifyAdminAccess } from '@/lib/auth/authHelpers';
export async function GET(request) {
    const hasAdminAccess = await verifyAdminAccess(request);
    if (!hasAdminAccess) {
        return NextResponse.json({ success: false, error: 'Unauthorized access' }, { status: 401 });
    }
    try {
        return await handleGetRequest(request</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/api/monitoring/api-usage/handlers.js (Line 24:1 - Line 78:4), C:/AI/food-truck-finder-poc/dist/lib/lib/api/monitoring/api-usage/handlers.js (Line 24:1 - Line 78:4)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn21" onclick="toggleCodeBlock('cloneGroup21', 'expandBtn21', 'collapseBtn21')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn21" onclick="toggleCodeBlock('cloneGroup21', 'expandBtn21', 'collapseBtn21')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup21"><code class="language-javascript text-sm text-gray-800">export async function handleServiceSpecificMonitoring(request, service) {
    const { searchParams } = new URL(request.url);
    const action = searchParams.get('action');
    if (action === 'check') {
        const requestCount = Number.parseInt(searchParams.get('requests') ?? '1', 10);
        const tokenCount = Number.parseInt(searchParams.get('tokens') ?? '0', 10);
        const canMakeRequest = await APIMonitor.canMakeRequest(service, requestCount, tokenCount);
        const usage = APIMonitor.getCurrentUsage(service);
        return NextResponse.json({
            success: true,
            service,
            canMakeRequest: canMakeRequest.allowed,
            reason: canMakeRequest.reason,
            waitTime: canMakeRequest.waitTime,
            usage,
            timestamp: new Date().toISOString(),
        });
    }
    const usage = APIMonitor.getCurrentUsage(service);
    return NextResponse.json({
        success: true,
        service,
        usage,
        timestamp: new Date().toISOString(),
    });
}
export function handleClearAlerts() {
    APIMonitor.clearAlertHistory();
    return NextResponse.json({
        success: true,
        message: 'Alert history cleared',
    });
}
export function handleGetAlerts() {
    const alerts = APIMonitor.getAlertHistory();
    return NextResponse.json({
        success: true,
        alerts,
        count: alerts.length,
    });
}
/**
 * Handles test alert triggering based on service and level provided.
 * @example
 * handleTestAlert({service: 'database', level: 'high'})
 * // Expected response in JSON format with success message.
 * @param {Object} body - The object containing service and level details.
 * @param {string} body.service - The name of the service for which the alert is triggered.
 * @param {string} body.level - The severity level of the alert.
 * @returns {Object} JSON response indicating success or failure status.
 * @description
 *   - Returns a success message with service and level if both are provided.
 *   - Responds with an error message if either service or level is missing.
 *   - Simulates alert triggering functionality - no real alert system interaction.
 */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/api/monitoring/api-usage/handlers.js (Line 79:1 - Line 89:2), C:/AI/food-truck-finder-poc/dist/lib/lib/api/monitoring/api-usage/handlers.js (Line 79:1 - Line 89:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn22" onclick="toggleCodeBlock('cloneGroup22', 'expandBtn22', 'collapseBtn22')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn22" onclick="toggleCodeBlock('cloneGroup22', 'expandBtn22', 'collapseBtn22')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup22"><code class="language-javascript text-sm text-gray-800">export function handleTestAlert(body) {
    const { service, level } = body;
    if (service == undefined || level == undefined) {
        return NextResponse.json({ success: false, error: 'Missing service or level' }, { status: 400 });
    }
    // This would trigger a test alert in a real implementation
    return NextResponse.json({
        success: true,
        message: `Test alert triggered for ${service} at ${level} level`,
    });
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/api/cron/auto-scrape/improvedHandler.js (Line 12:1 - Line 141:2), C:/AI/food-truck-finder-poc/dist/lib/lib/api/cron/auto-scrape/improvedHandler.js (Line 12:1 - Line 141:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn23" onclick="toggleCodeBlock('cloneGroup23', 'expandBtn23', 'collapseBtn23')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn23" onclick="toggleCodeBlock('cloneGroup23', 'expandBtn23', 'collapseBtn23')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup23"><code class="language-javascript text-sm text-gray-800">export async function handleAutoScrapeImproved(request) {
    const startTime = Date.now();
    try {
        // Verify authorization
        const authHeader = request.headers.get('authorization');
        const cronSecret = process.env.CRON_SECRET;
        if (!cronSecret || authHeader !== `Bearer ${cronSecret}`) {
            return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
        }
        logActivity({
            type: 'cron_job',
            action: 'auto_scrape_started',
            details: { timestamp: new Date().toISOString() },
        });
        const result = {
            trucksProcessed: 0,
            newTrucksFound: 0,
            errors: []
        };
        // Get URLs to scrape
        const urlsToScrape = await getUrlsToScrape();
        console.info(`Found ${urlsToScrape.length} URLs to process`);
        // Check existing trucks to determine which are new
        const { trucks: existingTrucks } = await FoodTruckService.getAllTrucks(1000, 0);
        const existingUrls = new Set(existingTrucks.flatMap(truck =&gt; truck.source_urls || []));
        // Create jobs for URLs (but don't process them)
        for (const url of urlsToScrape) {
            // Check if we're approaching timeout
            if (Date.now() - startTime &gt; PROCESSING_TIMEOUT_MS) {
                console.warn('Approaching function timeout, stopping job creation');
                break;
            }
            try {
                const isNew = !existingUrls.has(url);
                // Check if job already exists
                const existingJobs = await ScrapingJobService.getJobsByStatus('all');
                const jobExists = existingJobs.some(job =&gt; job.target_url === url &amp;&amp; ['pending', 'running'].includes(job.status));
                if (!jobExists) {
                    // Create job but don't process it
                    await ScrapingJobService.createJob({
                        job_type: 'website_auto',
                        target_url: url,
                        priority: isNew ? 10 : 5, // Higher priority for new trucks
                        scheduled_at: new Date().toISOString(),
                    });
                    result.trucksProcessed++;
                    if (isNew) {
                        result.newTrucksFound++;
                    }
                }
            }
            catch (error) {
                console.error(`Error creating job for ${url}:`, error);
                result.errors.push(url);
            }
        }
        // Process a few high-priority pending jobs if we have time
        const remainingTime = FUNCTION_TIMEOUT_MS - (Date.now() - startTime);
        if (remainingTime &gt; 2000) {
            await processHighPriorityJobs(remainingTime - 1000);
        }
        logActivity({
            type: 'cron_job',
            action: 'auto_scrape_completed',
            details: {
                timestamp: new Date().toISOString(),
                trucksProcessed: result.trucksProcessed,
                newTrucksFound: result.newTrucksFound,
                errorsCount: result.errors.length,
            },
        });
        return NextResponse.json({
            success: true,
            message: 'Auto-scraping jobs created successfully',
            data: {
                trucksProcessed: result.trucksProcessed,
                newTrucksFound: result.newTrucksFound,
                timestamp: new Date().toISOString(),
                note: 'Jobs created but not processed. Use separate job processor to avoid timeouts.',
            },
        });
    }
    catch (error) {
        console.error('Auto-scraping cron job failed:', error);
        logActivity({
            type: 'cron_job',
            action: 'auto_scrape_failed',
            details: {
                timestamp: new Date().toISOString(),
                error: error instanceof Error ? error.message : 'Unknown error',
            },
        });
        return NextResponse.json({
            success: false,
            error: 'Auto-scraping failed',
            message: error instanceof Error ? error.message : 'Unknown error',
        }, { status: 500 });
    }
}
async function getUrlsToScrape() {
    // This is a simplified version - in production, you'd also check discovered_urls table
    return DEFAULT_SCRAPE_URLS;
}
async function processHighPriorityJobs(timeLimit) {
    const startTime = Date.now();
    try {
        // Get high priority pending jobs
        const pendingJobs = await ScrapingJobService.getJobsByStatus('pending');
        const highPriorityJobs = pendingJobs
            .filter(job =&gt; job.priority &gt;= 10)
            .sort((a, b) =&gt; b.priority - a.priority)
            .slice(0, 3); // Process at most 3 jobs
        for (const job of highPriorityJobs) {
            if (Date.now() - startTime &gt; timeLimit) {
                break;
            }
            // Just update status to indicate it's been queued
            await ScrapingJobService.updateJobStatus(job.id, 'pending', {
                data_collected: {
                    ...job.data_collected,
                    queued_at: new Date().toISOString(),
                    queued_note: 'Queued for processing by job processor'
                }
            });
        }
    }
    catch (error) {
        console.error('Error processing high priority jobs:', error);
    }
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/api/cron/auto-scrape/handlers.js (Line 17:1 - Line 50:4), C:/AI/food-truck-finder-poc/dist/lib/lib/api/cron/auto-scrape/handlers.js (Line 17:1 - Line 50:4)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn25" onclick="toggleCodeBlock('cloneGroup25', 'expandBtn25', 'collapseBtn25')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn25" onclick="toggleCodeBlock('cloneGroup25', 'expandBtn25', 'collapseBtn25')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup25"><code class="language-javascript text-sm text-gray-800">function verifyCronSecret(request) {
    const authHeader = request.headers.get('authorization');
    const cronSecret = process.env.CRON_SECRET;
    if (cronSecret === undefined || cronSecret === '') {
        console.error('CRON_SECRET not configured');
        return NextResponse.json({ error: 'Server configuration error' }, { status: 500 });
    }
    if (authHeader !== `Bearer ${cronSecret}`) {
        console.error('Unauthorized cron attempt:', authHeader);
        return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }
    return null;
}
function logAutoScrapeStart() {
    console.info('Starting automated scraping job...');
    logActivity({
        type: 'cron_job',
        action: 'auto_scrape_started',
        details: { timestamp: new Date().toISOString() },
    });
}
/**
 * Logs the completion of an automated scraping job with pertinent details.
 * @example
 * logAutoScrapeCompletion(autoScrapeResult)
 * Automated scraping job completed successfully
 * @param {AutoScrapeResult} result - The result object containing details of the scraping job.
 * @returns {void} Does not return a value.
 * @description
 *   - Logs activity including the number of trucks processed and found, as well as any errors encountered.
 *   - Utilizes a standardized logActivity function to record job completion.
 *   - Converts the current timestamp to an ISO string format.
 *   - Provides a console message indicating successful job completion.
 */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/api/cron/auto-scrape/handlers.js (Line 51:1 - Line 87:4), C:/AI/food-truck-finder-poc/dist/lib/lib/api/cron/auto-scrape/handlers.js (Line 51:1 - Line 87:4)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn26" onclick="toggleCodeBlock('cloneGroup26', 'expandBtn26', 'collapseBtn26')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn26" onclick="toggleCodeBlock('cloneGroup26', 'expandBtn26', 'collapseBtn26')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup26"><code class="language-javascript text-sm text-gray-800">function logAutoScrapeCompletion(result) {
    logActivity({
        type: 'cron_job',
        action: 'auto_scrape_completed',
        details: {
            timestamp: new Date().toISOString(),
            trucksProcessed: result.trucksProcessed,
            newTrucksFound: result.newTrucksFound,
            errorsCount: result.errors?.length ?? 0,
        },
    });
    console.info('Automated scraping job completed successfully');
}
function logAutoScrapeFailure(error) {
    console.error('Auto-scraping cron job failed:', error);
    logActivity({
        type: 'cron_job',
        action: 'auto_scrape_failed',
        details: {
            timestamp: new Date().toISOString(),
            error: error instanceof Error ? error.message : 'Unknown error',
        },
    });
}
/**
 * Handles a POST request to initiate an auto-scraping process and returns the result.
 * @example
 * handlePostRequest(request)
 * { success: true, message: 'Auto-scraping completed successfully', data: { trucksProcessed: 10, newTrucksFound: 2, timestamp: '2023-08-23T18:25:43.511Z' } }
 * @param {NextRequest} request - The request object containing necessary parameters and headers for processing.
 * @returns {NextResponse} JSON response with either the success data or an error message.
 * @description
 *   - Validates request with a secret key before processing.
 *   - Logs scraping start and completion along with processed results.
 *   - Schedules follow-up tasks after successful scraping.
 *   - Catches and logs errors with a failure response in case of any exceptions during the process.
 */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/api/cron/auto-scrape/handlers.js (Line 88:1 - Line 125:2), C:/AI/food-truck-finder-poc/dist/lib/lib/api/cron/auto-scrape/handlers.js (Line 88:1 - Line 125:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn27" onclick="toggleCodeBlock('cloneGroup27', 'expandBtn27', 'collapseBtn27')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn27" onclick="toggleCodeBlock('cloneGroup27', 'expandBtn27', 'collapseBtn27')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup27"><code class="language-javascript text-sm text-gray-800">export async function handlePostRequest(request) {
    try {
        const authResponse = verifyCronSecret(request);
        if (authResponse) {
            return authResponse;
        }
        logAutoScrapeStart();
        const rawResult = await autoScraper.runAutoScraping();
        // Map errors to string[] for compatibility
        const result = {
            trucksProcessed: rawResult.trucksProcessed,
            newTrucksFound: rawResult.newTrucksFound,
            errors: rawResult.errors?.map((e) =&gt; e.url + (e.details ? `: ${e.details}` : '')),
        };
        scheduler.scheduleFollowUpTasks(result);
        logAutoScrapeCompletion(result);
        return NextResponse.json({
            success: true,
            message: 'Auto-scraping completed successfully',
            data: {
                trucksProcessed: result.trucksProcessed,
                newTrucksFound: result.newTrucksFound,
                timestamp: new Date().toISOString(),
            },
        });
    }
    catch (error) {
        logAutoScrapeFailure(error);
        return NextResponse.json({
            success: false,
            error: 'Auto-scraping failed',
            message: error instanceof Error ? error.message : 'Unknown error',
        }, { status: 500 });
    }
}
export function handleGetRequest() {
    return NextResponse.json({ error: 'Method not allowed. Use POST for cron jobs.' }, { status: 405 });
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/api/analytics/web-vitals/handlers.js (Line 6:1 - Line 24:4), C:/AI/food-truck-finder-poc/dist/lib/lib/api/analytics/web-vitals/handlers.js (Line 6:1 - Line 24:4)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn28" onclick="toggleCodeBlock('cloneGroup28', 'expandBtn28', 'collapseBtn28')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn28" onclick="toggleCodeBlock('cloneGroup28', 'expandBtn28', 'collapseBtn28')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup28"><code class="language-javascript text-sm text-gray-800">export function getRequestParams(request) {
    const { searchParams } = new URL(request.url);
    const days = Number.parseInt(searchParams.get('days') ?? '7', 10);
    const page = searchParams.get('page');
    return { days, page };
}
/**
 * Fetches and filters web vital metrics based on the given request parameters.
 * @example
 * fetchAndFilterMetrics(request)
 * { metrics: [{...}], days: 7, startDate: 2023-01-01T00:00:00.000Z }
 * @param {NextRequest} request - The request object containing parameters for filtering metrics such as days and page.
 * @returns {Object} An object containing an array of metrics, the number of days for the range, and the start date.
 * @description
 *   - Throws an error if the Supabase database connection is not available.
 *   - Builds a query to select metrics recorded after a specific start date.
 *   - Filters metrics by page URL if specified in the request parameters.
 *   - Limits the number of returned metrics to 1000 to avoid overwhelming the client.
 */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/api/analytics/web-vitals/handlers.js (Line 25:1 - Line 48:4), C:/AI/food-truck-finder-poc/dist/lib/lib/api/analytics/web-vitals/handlers.js (Line 25:1 - Line 48:4)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn29" onclick="toggleCodeBlock('cloneGroup29', 'expandBtn29', 'collapseBtn29')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn29" onclick="toggleCodeBlock('cloneGroup29', 'expandBtn29', 'collapseBtn29')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup29"><code class="language-javascript text-sm text-gray-800">export async function fetchAndFilterMetrics(request) {
    const { days, page } = getRequestParams(request);
    if (!supabaseAdmin) {
        throw new Error('Database not available');
    }
    const startDate = new Date();
    startDate.setDate(startDate.getDate() - days);
    let query = supabaseAdmin
        .from('web_vitals_metrics')
        .select('*')
        .gte('recorded_at', startDate.toISOString())
        .order('recorded_at', { ascending: false });
    if (page != undefined &amp;&amp; page !== '') {
        query = query.ilike('page_url', `%${page}%`);
    }
    const { data: metrics, error } = await query.limit(1000);
    if (error) {
        throw error;
    }
    return { metrics: metrics ?? [], days, startDate };
}
/**
 * Calculate summary statistics for metrics
 */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/api/analytics/web-vitals/handlers.js (Line 49:1 - Line 90:4), C:/AI/food-truck-finder-poc/dist/lib/lib/api/analytics/web-vitals/handlers.js (Line 49:1 - Line 90:4)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn30" onclick="toggleCodeBlock('cloneGroup30', 'expandBtn30', 'collapseBtn30')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn30" onclick="toggleCodeBlock('cloneGroup30', 'expandBtn30', 'collapseBtn30')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup30"><code class="language-javascript text-sm text-gray-800">export function calculateMetricsSummary(metrics) {
    const metricTypes = [
        'LCP',
        'FID',
        'CLS',
        'FCP',
        'TTFB',
    ];
    const summary = {};
    for (const metricName of metricTypes) {
        const metricData = metrics.filter((m) =&gt; m.metric_name === metricName);
        if (metricData.length === 0) {
            summary[metricName] = {
                count: 0,
                average: undefined,
                median: undefined,
                p75: undefined,
                p95: undefined,
                goodCount: 0,
                needsImprovementCount: 0,
                poorCount: 0,
            };
            continue;
        }
        const values = metricData.map((m) =&gt; m.metric_value).sort((a, b) =&gt; a - b);
        const ratings = metricData.map((m) =&gt; m.rating);
        summary[metricName] = {
            count: metricData.length,
            average: Math.round(values.reduce((sum, val) =&gt; sum + val, 0) / values.length),
            median: getPercentile(values, 50),
            p75: getPercentile(values, 75),
            p95: getPercentile(values, 95),
            goodCount: ratings.filter((r) =&gt; r === 'good').length,
            needsImprovementCount: ratings.filter((r) =&gt; r === 'needs-improvement').length,
            poorCount: ratings.filter((r) =&gt; r === 'poor').length,
        };
    }
    return summary;
}
/**
 * Calculate percentile value from sorted array
 */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/api/analytics/web-vitals/handlers.js (Line 91:1 - Line 115:4), C:/AI/food-truck-finder-poc/dist/lib/lib/api/analytics/web-vitals/handlers.js (Line 91:1 - Line 115:4)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn31" onclick="toggleCodeBlock('cloneGroup31', 'expandBtn31', 'collapseBtn31')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn31" onclick="toggleCodeBlock('cloneGroup31', 'expandBtn31', 'collapseBtn31')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup31"><code class="language-javascript text-sm text-gray-800">export function getPercentile(sortedValues, percentile) {
    if (sortedValues.length === 0)
        return 0;
    const index = (percentile / 100) * (sortedValues.length - 1);
    const lower = Math.floor(index);
    const upper = Math.ceil(index);
    if (lower === upper) {
        return Math.round(sortedValues[lower]);
    }
    const weight = index - lower;
    return Math.round(sortedValues[lower] * (1 - weight) + sortedValues[upper] * weight);
}
/**
 * Handles POST requests to store and validate web vital metrics.
 * @example
 * handlePostRequest(request)
 * { success: true }
 * @param {NextRequest} request - The incoming request containing the web vital metric data.
 * @returns {NextResponse} JSON response indicating success or failure of storing the metric.
 * @description
 *   - Validates that the metric contains required fields and checks the types of values.
 *   - Stores validated metrics in a Supabase table if `supabaseAdmin` is available.
 *   - Logs any 'poor' performance metrics for monitoring purposes.
 *   - Ensures metrics collection is non-blocking, even if an error occurs during database operations.
 */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/api/analytics/web-vitals/handlers.js (Line 116:1 - Line 175:3), C:/AI/food-truck-finder-poc/dist/lib/lib/api/analytics/web-vitals/handlers.js (Line 116:1 - Line 175:3)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn32" onclick="toggleCodeBlock('cloneGroup32', 'expandBtn32', 'collapseBtn32')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn32" onclick="toggleCodeBlock('cloneGroup32', 'expandBtn32', 'collapseBtn32')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup32"><code class="language-javascript text-sm text-gray-800">export async function handlePostRequest(request) {
    try {
        const metric = await request.json();
        // Validate metric data
        if (typeof metric !== 'object' ||
            metric == undefined ||
            !('name' in metric) ||
            !('value' in metric) ||
            !('url' in metric) ||
            typeof metric.value !== 'number') {
            return NextResponse.json({ success: false, error: 'Invalid metric data' }, { status: 400 });
        }
        const validatedMetric = metric;
        if (supabaseAdmin) {
            try {
                const { error } = await supabaseAdmin.from('web_vitals_metrics').insert({
                    metric_name: validatedMetric.name,
                    metric_value: validatedMetric.value,
                    rating: validatedMetric.rating,
                    page_url: validatedMetric.url,
                    user_agent: validatedMetric.userAgent,
                    recorded_at: new Date(validatedMetric.timestamp).toISOString(),
                });
                if (error) {
                    console.warn('Failed to store web vital metric:', error);
                    // Don't fail the request - metrics collection should be non-blocking
                }
            }
            catch (dbError) {
                console.warn('Database error storing web vital:', dbError);
            }
        }
        // Log performance issues for monitoring
        if (validatedMetric.rating === 'poor') {
            console.warn(`Poor ${validatedMetric.name} performance detected:`, {
                value: validatedMetric.value,
                url: validatedMetric.url,
                timestamp: new Date(validatedMetric.timestamp).toISOString(),
            });
        }
        return NextResponse.json({ success: true });
    }
    catch (error) {
        console.error('Web vitals endpoint error:', error);
        return NextResponse.json({ success: false, error: 'Internal server error' }, { status: 500 });
    }
}
/**
* Handles a GET request to fetch web vitals analytics data, process it, and respond with a summary.
* @example
* handleGetRequest(request)
* { success: true, data: { metrics: [...], summary: {...}, period: {...} } }
* @param {NextRequest} request - The incoming request object containing the necessary parameters.
* @returns {Promise&lt;NextResponse&gt;} Returns a JSON response indicating success or failure along with the data.
* @description
*   - Fetches metrics which are filtered and evaluated from the request data.
*   - Constructs a summary of the metrics including names, values, and ratings.
*   - Generates a response containing the metrics, summary, and calculated time period.
*   - Logs errors and responses with a status code in case of failure during data fetching.
*/</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/api/analytics/web-vitals/handlers.js (Line 176:1 - Line 197:2), C:/AI/food-truck-finder-poc/dist/lib/lib/api/analytics/web-vitals/handlers.js (Line 176:1 - Line 197:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn33" onclick="toggleCodeBlock('cloneGroup33', 'expandBtn33', 'collapseBtn33')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn33" onclick="toggleCodeBlock('cloneGroup33', 'expandBtn33', 'collapseBtn33')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup33"><code class="language-javascript text-sm text-gray-800">export async function handleGetRequest(request) {
    try {
        const { metrics, days, startDate } = await fetchAndFilterMetrics(request);
        const summary = calculateMetricsSummary(metrics);
        return NextResponse.json({
            success: true,
            data: {
                metrics,
                summary,
                period: {
                    days,
                    startDate: startDate.toISOString(),
                    endDate: new Date().toISOString(),
                },
            },
        });
    }
    catch (error) {
        console.error('Failed to fetch web vitals analytics:', error);
        return NextResponse.json({ success: false, error: 'Failed to fetch analytics data' }, { status: 500 });
    }
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/api/admin/scraping-metrics/handlers.js (Line 22:1 - Line 56:2), C:/AI/food-truck-finder-poc/dist/lib/lib/api/admin/scraping-metrics/handlers.js (Line 22:1 - Line 56:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn34" onclick="toggleCodeBlock('cloneGroup34', 'expandBtn34', 'collapseBtn34')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn34" onclick="toggleCodeBlock('cloneGroup34', 'expandBtn34', 'collapseBtn34')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup34"><code class="language-javascript text-sm text-gray-800">async function getScrapingMetrics() {
    // Fetch real scraping metrics from database
    const [allJobsResult, recentTrucksResult] = await Promise.all([
        ScrapingJobService.getAllJobs(100, 0), // Get last 100 jobs for metrics
        FoodTruckService.getAllTrucks(1000, 0), // Get trucks for processing count
    ]);
    // Type guard for allJobsResult
    const allJobs = Array.isArray(allJobsResult) ? allJobsResult : [];
    const recentTrucks = typeof recentTrucksResult === 'object' &amp;&amp;
        'trucks' in recentTrucksResult &amp;&amp;
        Array.isArray(recentTrucksResult.trucks)
        ? recentTrucksResult
        : { trucks: [], total: 0 };
    const typedJobs = allJobs;
    const successfulRuns = typedJobs.filter((job) =&gt; job.status === 'completed').length;
    const failedRuns = typedJobs.filter((job) =&gt; job.status === 'failed').length;
    return {
        scrapingJobs: {
            active: typedJobs.filter((job) =&gt; job.status === 'running').length,
            completed: successfulRuns,
            failed: failedRuns,
            pending: typedJobs.filter((job) =&gt; job.status === 'pending').length,
        },
        dataQuality: {
            averageScore: 0, // Placeholder, actual calculation might be complex
            totalTrucks: recentTrucks.total,
            recentChanges: 0, // Placeholder
        },
        systemHealth: {
            status: 'healthy',
            uptime: process.uptime(),
            lastUpdate: new Date().toISOString(),
        },
    };
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/api/admin/realtime-events/handlers.js (Line 15:1 - Line 63:3), C:/AI/food-truck-finder-poc/dist/lib/lib/api/admin/realtime-events/handlers.js (Line 15:1 - Line 63:3)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn35" onclick="toggleCodeBlock('cloneGroup35', 'expandBtn35', 'collapseBtn35')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn35" onclick="toggleCodeBlock('cloneGroup35', 'expandBtn35', 'collapseBtn35')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup35"><code class="language-javascript text-sm text-gray-800">export function handleGetRequest(request) {
    const stream = new ReadableStream({
        start(controller) {
            const encoder = new TextEncoder();
            const connectionEvent = {
                id: generateEventId(),
                type: 'heartbeat',
                timestamp: new Date().toISOString(),
                data: {
                    message: 'Real-time admin dashboard connected',
                    connectionId: generateEventId(),
                },
            };
            controller.enqueue(encoder.encode(formatSSEMessage(connectionEvent)));
            const intervalId = setInterval(async () =&gt; {
                await sendHeartbeatEvent(controller, encoder);
            }, 5000);
            const changeMonitorId = setupDataChangeMonitor(controller, encoder);
            request.signal.addEventListener('abort', () =&gt; {
                clearInterval(intervalId);
                clearInterval(changeMonitorId);
                controller.close();
            });
        },
    });
    return new Response(stream, {
        headers: {
            'Content-Type': 'text/event-stream',
            'Cache-Control': 'no-cache',
            Connection: 'keep-alive',
            'Access-Control-Allow-Origin': '*',
            'Access-Control-Allow-Headers': 'Cache-Control',
        },
    });
}
/**
* Sends a heartbeat event by fetching realtime metrics or logs an error alert when unsuccessful
* @example
* sendHeartbeatEvent(controller, encoder)
* // No return value
* @param {ReadableStreamDefaultController&lt;Uint8Array&gt;} controller - The controller used for enqueueing the event data.
* @param {TextEncoder} encoder - The encoder used to convert the event data to a Uint8Array.
* @returns {Promise&lt;void&gt;} Promise that resolves when event has been sent or error has been handled.
* @description
*   - Utilizes `fetchRealtimeMetrics()` to gather current system metrics.
*   - Generates a unique event id via `generateEventId()`.
*   - Formats the event data using `formatSSEMessage()` before enqueueing.
*   - Handles errors by creating a system alert event if metrics fetching fails.
*/</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/api/admin/realtime-events/handlers.js (Line 64:1 - Line 101:3), C:/AI/food-truck-finder-poc/dist/lib/lib/api/admin/realtime-events/handlers.js (Line 64:1 - Line 101:3)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn36" onclick="toggleCodeBlock('cloneGroup36', 'expandBtn36', 'collapseBtn36')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn36" onclick="toggleCodeBlock('cloneGroup36', 'expandBtn36', 'collapseBtn36')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup36"><code class="language-javascript text-sm text-gray-800">async function sendHeartbeatEvent(controller, encoder) {
    try {
        const metrics = await fetchRealtimeMetrics();
        const event = {
            id: generateEventId(),
            type: 'heartbeat',
            timestamp: new Date().toISOString(),
            data: { ...metrics },
        };
        controller.enqueue(encoder.encode(formatSSEMessage(event)));
    }
    catch (error) {
        console.error('Error fetching realtime metrics:', error);
        const errorEvent = {
            id: generateEventId(),
            type: 'system_alert',
            timestamp: new Date().toISOString(),
            data: {
                error: 'Failed to fetch metrics',
                details: error instanceof Error ? error.message : 'Unknown error',
            },
            severity: 'error',
        };
        controller.enqueue(encoder.encode(formatSSEMessage(errorEvent)));
    }
}
/**
* Sets up a periodic monitor for data changes using provided controller and encoder.
* @example
* setupDataChangeMonitor(controller, encoder)
* // returns a NodeJS.Timeout object that repeatedly monitors data changes every 10 seconds
* @param {ReadableStreamDefaultController&lt;Uint8Array&gt;} controller - Controller to handle readable stream of Uint8Array.
* @param {TextEncoder} encoder - Encoder to encode texts for processing the monitor.
* @returns {NodeJS.Timeout} Returns a timeout object responsible for invoking data change monitoring at set intervals.
* @description
*   - Utilizes async operation to monitor data changes ensuring non-blocking execution.
*   - Handles errors by logging them to the console, useful for debugging.
*/</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/api/admin/realtime-events/handlers.js (Line 124:1 - Line 188:4), C:/AI/food-truck-finder-poc/dist/lib/lib/api/admin/realtime-events/handlers.js (Line 124:1 - Line 188:4)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn37" onclick="toggleCodeBlock('cloneGroup37', 'expandBtn37', 'collapseBtn37')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn37" onclick="toggleCodeBlock('cloneGroup37', 'expandBtn37', 'collapseBtn37')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup37"><code class="language-javascript text-sm text-gray-800">export async function handlePostRequest(request) {
    try {
        const rawBody = await request.json();
        const isPostRequestBody = (obj) =&gt; {
            return (typeof obj === 'object' &amp;&amp;
                obj !== null &amp;&amp;
                'action' in obj &amp;&amp;
                typeof obj.action === 'string' &amp;&amp;
                (obj.action === 'health_check' ||
                    obj.action === 'trigger_test_event'));
        };
        if (!isPostRequestBody(rawBody)) {
            return new Response(JSON.stringify({
                success: false,
                error: &quot;Invalid request body: 'action' property is missing or not a valid action.&quot;,
            }), {
                status: 400,
                headers: { 'Content-Type': 'application/json' },
            });
        }
        const body = rawBody;
        switch (body.action) {
            case 'health_check': {
                return await handleHealthCheck();
            }
            case 'trigger_test_event': {
                return handleTriggerTestEvent();
            }
            default: {
                return new Response(JSON.stringify({
                    success: false,
                    error: &quot;That didn't work, please try again later.&quot;,
                }), {
                    status: 400,
                    headers: { 'Content-Type': 'application/json' },
                });
            }
        }
    }
    catch (error) {
        console.error('Realtime events POST error:', error);
        return new Response(JSON.stringify({
            success: false,
            error: &quot;That didn't work, please try again later.&quot;,
        }), {
            status: 500,
            headers: { 'Content-Type': 'application/json' },
        });
    }
}
/**
 * Fetches current scraping job metrics, data quality statistics, and system health status.
 * @example
 * fetchRealtimeMetrics()
 * {
 *   scrapingJobs: { active: 4, completed: 5, failed: 1, pending: 2 },
 *   dataQuality: { averageScore: 85, totalTrucks: 50, recentChanges: 0 },
 *   systemHealth: { status: 'healthy', uptime: 3600, lastUpdate: '2023-10-01T12:00:00Z' }
 * }
 * @returns {Promise&lt;RealtimeMetrics&gt;} An object containing metrics about scraping jobs, data quality, and system health.
 * @description
 *   - Utilizes external services ScrapingJobService and FoodTruckService to gather data.
 *   - Provides comprehensive metrics for monitoring system health and data processing status.
 *   - Catches errors to ensure consistent return structure even upon failure.
 */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/api/admin/realtime-events/handlers.js (Line 189:1 - Line 247:4), C:/AI/food-truck-finder-poc/dist/lib/lib/api/admin/realtime-events/handlers.js (Line 189:1 - Line 247:4)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn38" onclick="toggleCodeBlock('cloneGroup38', 'expandBtn38', 'collapseBtn38')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn38" onclick="toggleCodeBlock('cloneGroup38', 'expandBtn38', 'collapseBtn38')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup38"><code class="language-javascript text-sm text-gray-800">async function fetchRealtimeMetrics() {
    try {
        const recentJobs = await ScrapingJobService.getJobsByStatus('all');
        const scrapingMetrics = {
            active: recentJobs.filter((job) =&gt; job.status === 'running').length,
            completed: recentJobs.filter((job) =&gt; job.status === 'completed').length,
            failed: recentJobs.filter((job) =&gt; job.status === 'failed').length,
            pending: recentJobs.filter((job) =&gt; job.status === 'pending').length,
        };
        const qualityStats = await FoodTruckService.getDataQualityStats();
        const dataQualityMetrics = {
            averageScore: qualityStats.avg_quality_score ?? 0,
            totalTrucks: qualityStats.total_trucks ?? 0,
            recentChanges: 0,
        };
        const systemHealth = {
            status: 'healthy',
            uptime: process.uptime(),
            lastUpdate: new Date().toISOString(),
        };
        return {
            scrapingJobs: scrapingMetrics,
            dataQuality: dataQualityMetrics,
            systemHealth,
        };
    }
    catch (error) {
        console.error('Error fetching realtime metrics:', error);
        return {
            scrapingJobs: { active: 0, completed: 0, failed: 0, pending: 0 },
            dataQuality: { averageScore: 0, totalTrucks: 0, recentChanges: 0 },
            systemHealth: {
                status: 'error',
                uptime: 0,
                lastUpdate: new Date().toISOString(),
            },
        };
    }
}
function isScrapingJob(obj) {
    return typeof obj === 'object' &amp;&amp; obj !== null &amp;&amp; 'id' in obj &amp;&amp; 'status' in obj;
}
// Removed isFoodTruck function as it is unused.
// function isFoodTruck(obj: unknown): obj is FoodTruck {
//   return typeof obj === 'object' &amp;&amp; obj !== null &amp;&amp; 'id' in obj &amp;&amp; 'name' in obj;
// }
/**
 * Sends an update event about recent scraping jobs to a stream.
 * @example
 * sendScrapingUpdateEvent(controller, encoder)
 * @param {ReadableStreamDefaultController&lt;Uint8Array&gt;} controller - The stream controller to enqueue the event data.
 * @param {TextEncoder} encoder - The TextEncoder used to encode the event message.
 * @returns {Promise&lt;void&gt;} Resolves when the event has been enqueued.
 * @description
 *   - The function retrieves all recent scraping jobs with their status.
 *   - Filters the jobs to include only valid scraping jobs.
 *   - Constructs an event object adhering to the expected format.
 *   - Uses the controller to stream the encoded event to the client.
 */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/api/admin/realtime-events/handlers.js (Line 248:1 - Line 285:4), C:/AI/food-truck-finder-poc/dist/lib/lib/api/admin/realtime-events/handlers.js (Line 248:1 - Line 285:4)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn39" onclick="toggleCodeBlock('cloneGroup39', 'expandBtn39', 'collapseBtn39')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn39" onclick="toggleCodeBlock('cloneGroup39', 'expandBtn39', 'collapseBtn39')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup39"><code class="language-javascript text-sm text-gray-800">async function sendScrapingUpdateEvent(controller, encoder) {
    const recentJobs = await ScrapingJobService.getJobsByStatus('all');
    if (Array.isArray(recentJobs) &amp;&amp; recentJobs.length &gt; 0) {
        const event = {
            id: generateEventId(),
            type: 'scraping_update',
            timestamp: new Date().toISOString(),
            data: {
                recentJobs: recentJobs
                    .filter((job) =&gt; isScrapingJob(job))
                    .map((job) =&gt; ({
                    // Fixed unicorn/no-array-callback-reference
                    id: job.id,
                    status: job.status,
                    started_at: job.started_at,
                    completed_at: job.completed_at,
                })),
                count: recentJobs.length,
            },
            severity: 'info',
        };
        controller.enqueue(encoder.encode(formatSSEMessage(event)));
    }
}
/**
 * Sends a data quality change event if recent updates are detected.
 * @example
 * sendDataQualityChangeEvent(controller, encoder)
 * // Enqueues an event to the provided controller.
 * @param {ReadableStreamDefaultController&lt;Uint8Array&gt;} controller - The controller that enqueues the encoded event data.
 * @param {TextEncoder} encoder - The encoder used to transform event data into Uint8Array format.
 * @returns {Promise&lt;void&gt;} Resolves when the event is successfully handled and enqueued.
 * @description
 *   - Retrieves recent food truck updates from the FoodTruckService.
 *   - Filters food trucks updated within the last minute.
 *   - Formats a server-sent event message with the updates.
 *   - Only enqueues the event if there are updates detected.
 */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/api/admin/realtime-events/handlers.js (Line 286:1 - Line 339:4), C:/AI/food-truck-finder-poc/dist/lib/lib/api/admin/realtime-events/handlers.js (Line 286:1 - Line 339:4)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn40" onclick="toggleCodeBlock('cloneGroup40', 'expandBtn40', 'collapseBtn40')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn40" onclick="toggleCodeBlock('cloneGroup40', 'expandBtn40', 'collapseBtn40')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup40"><code class="language-javascript text-sm text-gray-800">async function sendDataQualityChangeEvent(controller, encoder) {
    const recentTrucksResult = await FoodTruckService.getAllTrucks(10, 0);
    const recentlyUpdated = recentTrucksResult.trucks.filter((truck) =&gt; {
        if (!truck.updated_at)
            return false;
        const updatedAt = new Date(truck.updated_at);
        const oneMinuteAgo = new Date(Date.now() - 60_000);
        return updatedAt &gt; oneMinuteAgo;
    });
    if (recentlyUpdated.length &gt; 0) {
        const event = {
            id: generateEventId(),
            type: 'data_quality_change',
            timestamp: new Date().toISOString(),
            data: {
                updatedTrucks: recentlyUpdated.map((truck) =&gt; ({
                    id: truck.id,
                    name: truck.name,
                    data_quality_score: truck.data_quality_score,
                    updated_at: truck.updated_at,
                })),
                count: recentlyUpdated.length,
            },
            severity: 'info',
        };
        controller.enqueue(encoder.encode(formatSSEMessage(event)));
    }
}
async function monitorDataChanges(controller, encoder) {
    try {
        await sendScrapingUpdateEvent(controller, encoder);
        await sendDataQualityChangeEvent(controller, encoder);
    }
    catch (error) {
        console.error('Error monitoring data changes:', error);
    }
}
function formatSSEMessage(event) {
    return `id: ${event.id}\nevent: ${event.type}\ndata: ${JSON.stringify(event)}\n\n`;
}
function generateEventId() {
    // eslint-disable-next-line sonarjs/pseudo-random -- Math.random is acceptable for generating non-security-sensitive event IDs.
    return `${Date.now()}-${Math.random().toString(36).slice(2, 11)}`;
}
/**
 * Performs a health check and returns the system status along with real-time metrics.
 * @example
 * handleHealthCheck().then(response =&gt; console.log(response));
 * Response { &quot;success&quot;: true, &quot;status&quot;: &quot;healthy&quot;, &quot;metrics&quot;: {...}, &quot;timestamp&quot;: &quot;2023-03-17T12:34:56.789Z&quot; }
 * @returns {Promise&lt;Response&gt;} A Promise that resolves to a Response object containing JSON data.
 * @description
 *   - Utilizes real-time metrics to provide current system health information.
 *   - Returns a JSON response formatted with specific headers and structure.
 */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/api/admin/realtime-events/handlers.js (Line 340:1 - Line 361:4), C:/AI/food-truck-finder-poc/dist/lib/lib/api/admin/realtime-events/handlers.js (Line 340:1 - Line 361:4)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn41" onclick="toggleCodeBlock('cloneGroup41', 'expandBtn41', 'collapseBtn41')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn41" onclick="toggleCodeBlock('cloneGroup41', 'expandBtn41', 'collapseBtn41')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup41"><code class="language-javascript text-sm text-gray-800">async function handleHealthCheck() {
    const metrics = await fetchRealtimeMetrics();
    return new Response(JSON.stringify({
        success: true,
        status: 'healthy',
        metrics,
        timestamp: new Date().toISOString(),
    }), {
        headers: { 'Content-Type': 'application/json' },
    });
}
/**
 * Returns a JSON response indicating a test event has been triggered.
 * @example
 * handleTriggerTestEvent()
 * Response object with a success message.
 * @returns {Response} JSON response containing success status, message, and timestamp.
 * @description
 *   - The response content type is set to 'application/json'.
 *   - The timestamp is generated using the current date and time.
 *   - Ensures consistent response formatting for realtime event triggers.
 */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/api/admin/oauth-status/helpers.js (Line 15:1 - Line 61:4), C:/AI/food-truck-finder-poc/dist/lib/lib/api/admin/oauth-status/helpers.js (Line 15:1 - Line 61:4)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn43" onclick="toggleCodeBlock('cloneGroup43', 'expandBtn43', 'collapseBtn43')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn43" onclick="toggleCodeBlock('cloneGroup43', 'expandBtn43', 'collapseBtn43')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup43"><code class="language-javascript text-sm text-gray-800">export async function handleGetRequest(_request) {
    const status = await getOAuthStatus();
    return NextResponse.json({
        success: true,
        ...status,
        legacy_format: {
            oauth_status: status.overall_status,
            message: getStatusMessage(status.overall_status),
            configuration_steps: status.overall_status === 'ready'
                ? undefined
                : [
                    '1. Go to Supabase Dashboard &gt; Authentication &gt; Providers',
                    '2. Enable Google provider',
                    '3. Add Google OAuth Client ID and Secret',
                    '4. Configure redirect URLs',
                    '5. Test OAuth flow',
                ],
        },
    });
}
// 1. Refactor nested template literals in generateOAuthTestUrl
function generateOAuthTestUrl(baseUrl) {
    const redirectPath = `${baseUrl}/auth/callback`;
    const encodedRedirect = encodeURIComponent(redirectPath);
    return (process.env.NEXT_PUBLIC_SUPABASE_URL +
        '/auth/v1/authorize?provider=google&amp;redirect_to=' +
        encodedRedirect);
}
/**
 * Handles a post request to generate an OAuth test URL based on the environment.
 * @example
 * handlePostRequest()
 * {
 *   success: true,
 *   message: 'OAuth test URL generated',
 *   test_url: 'http://localhost:3000/...',
 *   environment: 'development',
 *   instructions: [ ... ],
 *   manual_test_steps: [ ... ],
 *   automation_commands: [ ... ]
 * }
 * @returns {object} An object containing success status, message, the test URL, the environment, instructions, manual test steps, and automation commands.
 * @description
 *   - Determines the base URL depending on whether the environment is production or development.
 *   - Utilizes `generateOAuthTestUrl` to construct the OAuth test URL.
 *   - Responds with JSON containing test instructions and automation commands for verifying OAuth functionality.
 */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/api/admin/oauth-status/helpers.js (Line 62:1 - Line 105:4), C:/AI/food-truck-finder-poc/dist/lib/lib/api/admin/oauth-status/helpers.js (Line 62:1 - Line 105:4)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn44" onclick="toggleCodeBlock('cloneGroup44', 'expandBtn44', 'collapseBtn44')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn44" onclick="toggleCodeBlock('cloneGroup44', 'expandBtn44', 'collapseBtn44')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup44"><code class="language-javascript text-sm text-gray-800">export function handlePostRequest() {
    // Removed _request parameter
    const baseUrl = process.env.NODE_ENV === 'production'
        ? 'https://food-truck-finder-poc-git-feat-s-20ec1c-codedeficients-projects.vercel.app'
        : 'http://localhost:3000';
    const testUrl = generateOAuthTestUrl(baseUrl);
    return NextResponse.json({
        success: true,
        message: 'OAuth test URL generated',
        test_url: testUrl,
        environment: process.env.NODE_ENV ?? 'development',
        instructions: [
            '1. Open the test_url in a new browser tab',
            '2. Complete Google OAuth flow',
            '3. Verify redirect to admin dashboard',
            '4. Check for proper role assignment',
        ],
        manual_test_steps: [
            'Navigate to /login page',
            'Click Google login button',
            'Complete OAuth flow',
            'Verify admin access',
        ],
        automation_commands: [
            'npm run oauth:verify - Check configuration',
            'npm run oauth:test:dev - Test development flow',
            'npm run oauth:test:prod - Test production flow',
        ],
    });
}
/**
 * Retrieves the current OAuth status including configuration and connectivity information.
 * @example
 * getOAuthStatus().then(status =&gt; {
 *   console.log(status);
 * });
 * // Output: OAuthStatus object with current configuration and connection status details
 * @returns {Promise&lt;OAuthStatus&gt;} An object representing the current status of OAuth configuration and connectivity.
 * @description
 *   - The function assesses the connectivity and configuration of Supabase and its authentication settings.
 *   - It checks if the necessary environment variables are set.
 *   - Executes a series of asynchronous checks to determine if the OAuth provider is properly configured.
 *   - Recommendations for improving the OAuth setup are generated based on the current status.
 */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/api/admin/oauth-status/helpers.js (Line 106:1 - Line 146:4), C:/AI/food-truck-finder-poc/dist/lib/lib/api/admin/oauth-status/helpers.js (Line 106:1 - Line 146:4)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn45" onclick="toggleCodeBlock('cloneGroup45', 'expandBtn45', 'collapseBtn45')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn45" onclick="toggleCodeBlock('cloneGroup45', 'expandBtn45', 'collapseBtn45')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup45"><code class="language-javascript text-sm text-gray-800">async function getOAuthStatus() {
    const status = {
        timestamp: new Date().toISOString(),
        environment: process.env.NODE_ENV === 'production' ? 'production' : 'development',
        supabase: {
            connected: false,
            projectId: 'zkwliyjjkdnigizidlln',
        },
        environment_variables: {
            supabaseUrl: process.env.NEXT_PUBLIC_SUPABASE_URL !== undefined,
            supabaseAnonKey: process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY !== undefined,
            supabaseServiceKey: process.env.SUPABASE_SERVICE_ROLE_KEY !== undefined,
        },
        oauth_flow: {
            loginPageExists: true,
            callbackRouteExists: true,
            authProviderConfigured: false,
        },
        recommendations: [],
        overall_status: 'not_configured',
    };
    await checkSupabaseConnection(status, supabase);
    await checkSupabaseAuthSettings(status);
    await testOAuthProvider(status, supabase);
    status.recommendations = generateRecommendations(status);
    status.overall_status = determineOverallStatus(status);
    return status;
}
/**
 * Checks the connection status with Supabase and updates the `OAuthStatus`.
 * @example
 * checkSupabaseConnection(status, supabase)
 * // Updates the `status.supabase.connected` property based on connection success
 * @param {OAuthStatus} status - The current OAuthStatus object that tracks connection state and errors.
 * @param {SupabaseClient} supabase - The Supabase client instance used to interact with the database.
 * @returns {void} No explicit return value, operates directly on the `status` object.
 * @description
 *   - Attempts a query to the 'profiles' table to ensure Supabase connection.
 *   - Updates `status.supabase.connected` based on query success.
 *   - Captures and records detailed error messages in case of connection failure.
 */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/api/admin/oauth-status/helpers.js (Line 147:1 - Line 172:4), C:/AI/food-truck-finder-poc/dist/lib/lib/api/admin/oauth-status/helpers.js (Line 147:1 - Line 172:4)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn46" onclick="toggleCodeBlock('cloneGroup46', 'expandBtn46', 'collapseBtn46')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn46" onclick="toggleCodeBlock('cloneGroup46', 'expandBtn46', 'collapseBtn46')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup46"><code class="language-javascript text-sm text-gray-800">async function checkSupabaseConnection(status, supabase) {
    try {
        const { error } = await supabase.from('profiles').select('count').limit(1);
        if (error === null) {
            status.supabase.connected = true;
        }
        else {
            status.supabase.error = error.message;
        }
    }
    catch (error) {
        status.supabase.error = error instanceof Error ? error.message : 'Unknown connection error';
    }
}
/**
 * Checks and processes Supabase authentication settings.
 * @example
 * checkSupabaseAuthSettings(oAuthStatusInstance)
 * { supabase: { authSettings: { googleEnabled: true, signupEnabled: false, autoconfirm: true } } }
 * @param {OAuthStatus} status - An object that holds OAuth configuration status.
 * @returns {void} Modifies the passed status object with fetched authentication settings.
 * @description
 *   - The function fetches authentication settings from the Supabase URL defined in environment variables.
 *   - If Supabase settings are fetched successfully, it updates the OAuth status with authentication settings like Google integration, signup availability, and autoconfirm feature.
 *   - Provides a fallback log for cases where fetching settings require authentication.
 */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/api/admin/oauth-status/helpers.js (Line 173:1 - Line 210:4), C:/AI/food-truck-finder-poc/dist/lib/lib/api/admin/oauth-status/helpers.js (Line 173:1 - Line 210:4)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn47" onclick="toggleCodeBlock('cloneGroup47', 'expandBtn47', 'collapseBtn47')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn47" onclick="toggleCodeBlock('cloneGroup47', 'expandBtn47', 'collapseBtn47')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup47"><code class="language-javascript text-sm text-gray-800">async function checkSupabaseAuthSettings(status) {
    try {
        const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;
        if (typeof supabaseUrl === 'string' &amp;&amp; supabaseUrl.length &gt; 0) {
            // Explicit check for undefined and empty string
            const settingsResponse = await fetch(`${supabaseUrl}/auth/v1/settings`);
            if (settingsResponse.ok === true) {
                const settings = (await settingsResponse.json());
                status.supabase.authSettings = {
                    googleEnabled: settings.external?.google ?? false,
                    signupEnabled: settings.disable_signup === false,
                    autoconfirm: settings.autoconfirm ?? false,
                };
                if (settings.external?.google !== undefined) {
                    // Explicit check for undefined
                    status.oauth_flow.authProviderConfigured = true;
                }
            }
        }
    }
    catch {
        console.info('Auth settings endpoint requires authentication (normal)');
    }
}
/**
 * Tests the configuration of an OAuth provider and updates the status based on the result.
 * @example
 * testOAuthProvider(status, supabase)
 * undefined
 * @param {OAuthStatus} status - An object representing the current OAuth status and configuration.
 * @param {SupabaseClient} supabase - The Supabase client instance used to interact with the authentication system.
 * @returns {void} Does not return any value.
 * @description
 *   - Utilizes Google as the OAuth provider for the sign-in attempt.
 *   - Redirects to a localhost callback URL to simulate the OAuth process.
 *   - Direct usage of the Supabase auth method to initiate OAuth process.
 *   - Handles exceptions without altering the control flow and logs them for informational purposes.
 */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/api/admin/oauth-status/helpers.js (Line 211:1 - Line 240:4), C:/AI/food-truck-finder-poc/dist/lib/lib/api/admin/oauth-status/helpers.js (Line 211:1 - Line 240:4)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn48" onclick="toggleCodeBlock('cloneGroup48', 'expandBtn48', 'collapseBtn48')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn48" onclick="toggleCodeBlock('cloneGroup48', 'expandBtn48', 'collapseBtn48')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup48"><code class="language-javascript text-sm text-gray-800">async function testOAuthProvider(status, supabase) {
    try {
        const { error: oauthError } = await supabase.auth.signInWithOAuth({
            provider: 'google',
            options: {
                redirectTo: 'http://localhost:3000/auth/callback',
                skipBrowserRedirect: true,
            },
        });
        if (oauthError !== null &amp;&amp; oauthError.message !== 'Provider not found') {
            // Explicitly check for oauthError existence
            status.oauth_flow.authProviderConfigured = true;
        }
    }
    catch (error) {
        console.info('OAuth provider test failed (may be normal):', error);
    }
}
/**
 * Generates a list of recommendations for OAuth configuration based on the current status.
 * @example
 * generateRecommendations(status)
 * [' Configure NEXT_PUBLIC_SUPABASE_URL environment variable', ...]
 * @param {OAuthStatus} status - The current status of OAuth configuration and environment variables.
 * @returns {string[]} Array of recommendation messages to guide configuration setup.
 * @description
 *   - Checks for necessary environment variables and Supabase connectivity.
 *   - Provides guidance on enabling Google OAuth.
 *   - Suggests consulting documentation for further setup instructions.
 */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/api/admin/oauth-status/helpers.js (Line 241:1 - Line 284:4), C:/AI/food-truck-finder-poc/dist/lib/lib/api/admin/oauth-status/helpers.js (Line 241:1 - Line 284:4)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn49" onclick="toggleCodeBlock('cloneGroup49', 'expandBtn49', 'collapseBtn49')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn49" onclick="toggleCodeBlock('cloneGroup49', 'expandBtn49', 'collapseBtn49')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup49"><code class="language-javascript text-sm text-gray-800">function generateRecommendations(status) {
    const recommendations = [];
    if (!status.environment_variables.supabaseUrl) {
        recommendations.push(' Configure NEXT_PUBLIC_SUPABASE_URL environment variable');
    }
    if (!status.environment_variables.supabaseAnonKey) {
        recommendations.push(' Configure NEXT_PUBLIC_SUPABASE_ANON_KEY environment variable');
    }
    if (!status.environment_variables.supabaseServiceKey) {
        recommendations.push(' Configure SUPABASE_SERVICE_ROLE_KEY environment variable');
    }
    if (!status.supabase.connected) {
        recommendations.push(' Fix Supabase connection issue');
        if (typeof status.supabase.error === 'string' &amp;&amp; status.supabase.error.length &gt; 0) {
            recommendations.push(`   Error: ${status.supabase.error}`);
        }
    }
    if (status.supabase.authSettings?.googleEnabled === true) {
        recommendations.push(' Google OAuth provider is enabled');
    }
    else {
        recommendations.push(' Enable Google OAuth provider in Supabase Dashboard', '   Go to: Authentication &gt; Providers &gt; Google');
    }
    if (status.overall_status === 'ready') {
        recommendations.push(' OAuth configuration is complete!', ' Test the login flow at /login');
    }
    if (recommendations.length &gt; 1) {
        recommendations.push(' See docs/GOOGLE_OAUTH_SETUP_GUIDE.md for detailed instructions', ' Run: npm run oauth:verify for automated checks');
    }
    return recommendations;
}
/**
 * Determines the overall OAuth status based on provided conditions.
 * @example
 * determineOverallStatus(status)
 * 'ready'
 * @param {OAuthStatus} status - The status object containing configuration details.
 * @returns {'ready' | 'partial' | 'not_configured' | 'error'} Overall status derived from the evaluations.
 * @description
 *   - Evaluates connectivity and configuration status from various parameters within the status object.
 *   - Prioritizes returning 'error' if Supabase connection fails or if an error is detected.
 *   - Checks completeness of environment variables before proceeding to other status evaluations.
 *   - Distinguishes between 'ready' and 'partial' based on specific OAuth settings.
 */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/api/admin/oauth-status/helpers.js (Line 285:1 - Line 313:4), C:/AI/food-truck-finder-poc/dist/lib/lib/api/admin/oauth-status/helpers.js (Line 285:1 - Line 313:4)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn50" onclick="toggleCodeBlock('cloneGroup50', 'expandBtn50', 'collapseBtn50')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn50" onclick="toggleCodeBlock('cloneGroup50', 'expandBtn50', 'collapseBtn50')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup50"><code class="language-javascript text-sm text-gray-800">function determineOverallStatus(status) {
    // eslint-disable-next-line sonarjs/different-types-comparison
    if (!status.supabase.connected || status.supabase.error !== null) {
        return 'error';
    }
    const envVarsComplete = Object.values(status.environment_variables).every(Boolean);
    if (!envVarsComplete) {
        return 'not_configured';
    }
    if (status.supabase.authSettings?.googleEnabled &amp;&amp; status.oauth_flow.authProviderConfigured) {
        return 'ready';
    }
    if (status.supabase.connected &amp;&amp; envVarsComplete) {
        return 'partial';
    }
    return 'not_configured';
}
/**
 * Retrieves a human-readable message based on the OAuth configuration status.
 * @example
 * getStatusMessage('ready')
 * 'Google OAuth is fully configured and ready to use'
 * @param {string} status - The current status of the OAuth configuration.
 * @returns {string} A message explaining the OAuth configuration status.
 * @description
 *   - Handles several predefined status cases.
 *   - Provides feedback for both success and error states.
 *   - Returns a default message for unrecognized statuses.
 */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/api/admin/oauth-status/helpers.js (Line 314:1 - Line 332:2), C:/AI/food-truck-finder-poc/dist/lib/lib/api/admin/oauth-status/helpers.js (Line 314:1 - Line 332:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn51" onclick="toggleCodeBlock('cloneGroup51', 'expandBtn51', 'collapseBtn51')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn51" onclick="toggleCodeBlock('cloneGroup51', 'expandBtn51', 'collapseBtn51')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup51"><code class="language-javascript text-sm text-gray-800">function getStatusMessage(status) {
    switch (status) {
        case 'ready': {
            return 'Google OAuth is fully configured and ready to use';
        }
        case 'partial': {
            return 'Basic configuration complete, OAuth provider needs setup';
        }
        case 'not_configured': {
            return 'Google OAuth is not configured';
        }
        case 'error': {
            return 'Configuration error detected';
        }
        default: {
            return 'Unknown configuration status';
        }
    }
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/api/admin/data-quality/handlers.js (Line 15:1 - Line 46:3), C:/AI/food-truck-finder-poc/dist/lib/lib/api/admin/data-quality/handlers.js (Line 15:1 - Line 46:3)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn52" onclick="toggleCodeBlock('cloneGroup52', 'expandBtn52', 'collapseBtn52')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn52" onclick="toggleCodeBlock('cloneGroup52', 'expandBtn52', 'collapseBtn52')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup52"><code class="language-javascript text-sm text-gray-800">export async function handleGetRequest(request) {
    const { searchParams } = new URL(request.url);
    const action = searchParams.get('action');
    const truckId = searchParams.get('truckId');
    switch (action) {
        case 'stats': {
            return await handleStatsAction();
        }
        case 'assess': {
            if (!truckId) {
                return NextResponse.json({ success: false, error: 'Missing truckId for assess action' }, { status: 400 });
            }
            return await handleAssessAction(truckId);
        }
        default: {
            return await handleDefaultGetAction();
        }
    }
}
/**
* Handles different types of POST requests by determining the action and executing appropriate functions.
* @example
* handlePostRequest(request)
* NextResponse containing success status and result or error message
* @param {NextRequest} request - Incoming request object containing body data as JSON.
* @returns {Promise&lt;NextResponse&gt;} Response indicating success or failure and any relevant data or error messages.
* @description
*   - Validates request body to ensure it's a non-null object.
*   - Extracts action and truckId from request body to decide on processing steps.
*   - Handles actions like &quot;update-single&quot;, &quot;batch-update&quot;, and &quot;recalculate-all&quot;, returning an appropriate NextResponse.
*   - Responds with an error JSON if the action is unknown or if required fields are missing.
*/</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/api/admin/data-quality/handlers.js (Line 47:1 - Line 92:4), C:/AI/food-truck-finder-poc/dist/lib/lib/api/admin/data-quality/handlers.js (Line 47:1 - Line 92:4)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn53" onclick="toggleCodeBlock('cloneGroup53', 'expandBtn53', 'collapseBtn53')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn53" onclick="toggleCodeBlock('cloneGroup53', 'expandBtn53', 'collapseBtn53')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup53"><code class="language-javascript text-sm text-gray-800">export async function handlePostRequest(request) {
    const body = await request.json();
    if (typeof body !== 'object' || body === null) {
        return NextResponse.json({ success: false, error: 'Invalid request body' }, { status: 400 });
    }
    const { action, truckId } = body;
    switch (action) {
        case 'update-single': {
            if (truckId === undefined || truckId === '') {
                return NextResponse.json({ success: false, error: 'Missing truckId for update-single action' }, { status: 400 });
            }
            return await handleUpdateSingle(truckId);
        }
        case 'batch-update': {
            return handleBatchUpdate();
        }
        case 'recalculate-all': {
            return await handleRecalculateAll();
        }
        default: {
            return NextResponse.json({ success: false, error: `Unknown action: ${action}` }, { status: 400 });
        }
    }
}
async function handleStatsAction() {
    const qualityStats = await FoodTruckService.getDataQualityStats();
    return NextResponse.json({
        success: true,
        data: {
            ...qualityStats,
            timestamp: new Date().toISOString(),
        },
    });
}
/**
 * Processes and returns the assessment result of a food truck action by its ID.
 * @example
 * handleAssessAction(&quot;12345&quot;)
 * { success: true, data: { truckId: &quot;12345&quot;, truckName: &quot;Best Food Truck&quot;, currentScore: 95, timestamp: &quot;2023-10-05T14:48:00.000Z&quot; } }
 * @param {string} truckId - The identifier of the food truck to be assessed.
 * @returns {object} Returns a JSON response containing either the assessment data or an error.
 * @description
 *   - Retrieves data of the specified food truck using FoodTruckService.
 *   - Casts the retrieved data explicitly to a FoodTruck object type to ensure type safety.
 *   - Responds with a 404 status and the error description if the truck is not found.
 */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/api/admin/data-quality/handlers.js (Line 93:1 - Line 128:4), C:/AI/food-truck-finder-poc/dist/lib/lib/api/admin/data-quality/handlers.js (Line 93:1 - Line 128:4)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn54" onclick="toggleCodeBlock('cloneGroup54', 'expandBtn54', 'collapseBtn54')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn54" onclick="toggleCodeBlock('cloneGroup54', 'expandBtn54', 'collapseBtn54')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup54"><code class="language-javascript text-sm text-gray-800">async function handleAssessAction(truckId) {
    const truckResult = await FoodTruckService.getTruckById(truckId);
    if ('error' in truckResult) {
        return NextResponse.json({ success: false, error: truckResult.error }, { status: 404 });
    }
    const truck = truckResult; // Explicitly cast to FoodTruck
    return NextResponse.json({
        success: true,
        data: {
            truckId,
            truckName: truck.name,
            currentScore: truck.data_quality_score,
            timestamp: new Date().toISOString(),
        },
    });
}
async function handleDefaultGetAction() {
    const qualityStats = await FoodTruckService.getDataQualityStats();
    return NextResponse.json({
        success: true,
        data: qualityStats,
    });
}
/**
 * Handles updating a single food truck's quality score and returns the result.
 * @example
 * handleUpdateSingle(&quot;1234&quot;)
 * { success: true, message: 'Quality score updated successfully', data: { truckId: '1234', truckName: 'Food Truck A', newScore: 95, verificationStatus: 'verified', timestamp: '2023-10-30T14:48:00.000Z' } }
 * @param {string} truckId - The unique identifier of the food truck to update.
 * @returns {Object} An object containing the success status, message, and either updated truck data or error information.
 * @description
 *   - Utilizes `FoodTruckService.getTruckById` to fetch truck details.
 *   - Responds differently based on whether an error is encountered or not.
 *   - Formats the response appropriately for successful updates.
 *   - Includes a timestamp in the response when successful.
 */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/api/admin/data-quality/handlers.js (Line 129:1 - Line 178:4), C:/AI/food-truck-finder-poc/dist/lib/lib/api/admin/data-quality/handlers.js (Line 129:1 - Line 178:4)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn55" onclick="toggleCodeBlock('cloneGroup55', 'expandBtn55', 'collapseBtn55')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn55" onclick="toggleCodeBlock('cloneGroup55', 'expandBtn55', 'collapseBtn55')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup55"><code class="language-javascript text-sm text-gray-800">async function handleUpdateSingle(truckId) {
    const updatedTruckResult = await FoodTruckService.getTruckById(truckId);
    if ('error' in updatedTruckResult) {
        return NextResponse.json({ success: false, error: updatedTruckResult.error }, { status: 404 });
    }
    const updatedTruck = updatedTruckResult;
    return NextResponse.json({
        success: true,
        message: 'Quality score updated successfully',
        data: {
            truckId: updatedTruck.id,
            truckName: updatedTruck.name,
            newScore: updatedTruck.data_quality_score,
            verificationStatus: updatedTruck.verification_status,
            timestamp: new Date().toISOString(),
        },
    });
}
function handleBatchUpdate() {
    return NextResponse.json({
        success: true,
        message: 'Batch quality score update completed',
        data: {
            timestamp: new Date().toISOString(),
        },
    });
}
function updateSingleTruckQualityScore(truck) {
    try {
        // Placeholder for actual update logic if needed
        // DataQualityService.updateTruckQualityScore(truck.id);
        return true;
    }
    catch (error) {
        console.error(`Failed to update truck ${truck.id}:`, error);
        return false;
    }
}
/**
 * Recalculates the quality score for all food trucks.
 * @example
 * handleRecalculateAll()
 * { success: true, message: 'Quality score recalculation completed', data: { totalTrucks: 100, updated: 95, errors: 5, timestamp: '2023-10-07T10:30:00.000Z' } }
 * @param {undefined} undefined - No arguments are needed.
 * @returns {Object} JSON response with success status, message, and data containing recalculation statistics.
 * @description
 *   - Fetches all food trucks in batches for recalculation using the FoodTruckService.
 *   - Logs an error message if the API call to fetch all trucks fails.
 *   - Updates the `qualityScore` for each truck and maintains a count of successful and unsuccessful updates.
 */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/api/admin/data-quality/handlers.js (Line 179:1 - Line 207:2), C:/AI/food-truck-finder-poc/dist/lib/lib/api/admin/data-quality/handlers.js (Line 179:1 - Line 207:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn56" onclick="toggleCodeBlock('cloneGroup56', 'expandBtn56', 'collapseBtn56')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn56" onclick="toggleCodeBlock('cloneGroup56', 'expandBtn56', 'collapseBtn56')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup56"><code class="language-javascript text-sm text-gray-800">async function handleRecalculateAll() {
    const allTrucksResult = await FoodTruckService.getAllTrucks(1000, 0);
    if (allTrucksResult.error !== undefined) {
        console.error('Error fetching all trucks for recalculation:', allTrucksResult.error);
        return NextResponse.json({ success: false, error: 'Failed to fetch trucks for recalculation' }, { status: 500 });
    }
    const { trucks } = allTrucksResult;
    let updated = 0;
    let errors = 0;
    for (const truck of trucks) {
        const success = updateSingleTruckQualityScore(truck);
        if (success) {
            updated += 1;
        }
        else {
            errors += 1;
        }
    }
    return NextResponse.json({
        success: true,
        message: 'Quality score recalculation completed',
        data: {
            totalTrucks: trucks.length,
            updated,
            errors,
            timestamp: new Date().toISOString(),
        },
    });
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/api/admin/data-cleanup/handlers.js (Line 17:1 - Line 49:4), C:/AI/food-truck-finder-poc/dist/lib/lib/api/admin/data-cleanup/handlers.js (Line 17:1 - Line 49:4)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn57" onclick="toggleCodeBlock('cloneGroup57', 'expandBtn57', 'collapseBtn57')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn57" onclick="toggleCodeBlock('cloneGroup57', 'expandBtn57', 'collapseBtn57')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup57"><code class="language-javascript text-sm text-gray-800">export async function handlePostRequest(body) {
    const { action, options = {} } = body;
    switch (action) {
        case 'full-cleanup': {
            return await handleFullCleanup(options);
        }
        case 'check-duplicates': {
            return await handleCheckDuplicates(options);
        }
        case 'merge-duplicates': {
            return await handleMergeDuplicates(options);
        }
        case 'dry-run': {
            return await handleDryRun(options);
        }
        default: {
            return NextResponse.json({ success: false, error: `Unknown action: ${action}` }, { status: 400 });
        }
    }
}
/**
 * Processes a GET request and performs actions based on query parameters.
 * @example
 * handleGetRequest(request)
 * Promise&lt;NextResponse&gt;
 * @param {NextRequest} request - Incoming Next.js request object containing the URL and search parameters.
 * @returns {Promise&lt;NextResponse&gt;} Promise resolving to a NextResponse object.
 * @description
 *   - It extracts the `action` parameter from the request URL's query string.
 *   - Based on the action parameter value, it delegates the request to specific handlers like `handleGetStatus`, `handleGetPreview`, or `handleGetDefault`.
 *   - Handles asynchronous operations within the action cases when necessary (e.g., `preview`).
 *   - Ensures proper response handling while maintaining the server-side asynchronous flow.
 */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/api/admin/data-cleanup/handlers.js (Line 50:1 - Line 77:3), C:/AI/food-truck-finder-poc/dist/lib/lib/api/admin/data-cleanup/handlers.js (Line 50:1 - Line 77:3)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn58" onclick="toggleCodeBlock('cloneGroup58', 'expandBtn58', 'collapseBtn58')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn58" onclick="toggleCodeBlock('cloneGroup58', 'expandBtn58', 'collapseBtn58')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup58"><code class="language-javascript text-sm text-gray-800">export async function handleGetRequest(request) {
    const { searchParams } = new URL(request.url);
    const action = searchParams.get('action');
    switch (action) {
        case 'status': {
            return handleGetStatus();
        }
        case 'preview': {
            return await handleGetPreview();
        }
        default: {
            return handleGetDefault();
        }
    }
}
/**
* Executes a full data cleanup operation based on provided options.
* @example
* handleFullCleanup({ batchSize: 100, dryRun: true, operations: ['removeDuplicates', 'optimizeData'] })
* Returns a JSON response confirming the success of the cleanup.
* @param {Object} options - Configuration for the cleanup operation.
* @returns {Promise&lt;Object&gt;} A JSON response with the cleanup result summary.
* @description
*   - Default batch size for cleanup is set to 50 if not specified.
*   - Supports a dry-run mode for testing cleanup without making changes.
*   - Utilizes operations parameter to specify types of cleanup tasks.
*   - Provides detailed summary in the response message.
*/</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/api/admin/data-cleanup/handlers.js (Line 78:1 - Line 102:4), C:/AI/food-truck-finder-poc/dist/lib/lib/api/admin/data-cleanup/handlers.js (Line 78:1 - Line 102:4)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn59" onclick="toggleCodeBlock('cloneGroup59', 'expandBtn59', 'collapseBtn59')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn59" onclick="toggleCodeBlock('cloneGroup59', 'expandBtn59', 'collapseBtn59')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup59"><code class="language-javascript text-sm text-gray-800">export async function handleFullCleanup(options) {
    const result = await BatchCleanupService.runFullCleanup({
        batchSize: options?.batchSize ?? 50,
        dryRun: options?.dryRun ?? false,
        operations: options?.operations,
    });
    return NextResponse.json({
        success: true,
        action: 'full-cleanup',
        result,
        message: `Cleanup completed: ${result.summary.trucksImproved} trucks improved, ${result.summary.duplicatesRemoved} duplicates removed`,
    });
}
/**
 * Handles the duplicate check functionality for truck data.
 * @example
 * handleCheckDuplicates({ options: { truckData: [...] } })
 * Returns a promise with a JSON response indicating success or failure of duplicate check.
 * @param {DataCleanupRequestBody['options']} options - The request body containing truck data to be checked.
 * @returns {Promise&lt;NextResponse&gt;} A promise that resolves to a NextResponse object containing the result of the duplicate check.
 * @description
 *   - Utilizes the Duplicate Prevention Service to verify the presence of duplicates.
 *   - Expects `truckData` within the provided options for processing.
 *   - Returns an error JSON response with status 400 if `truckData` is not supplied.
 */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/api/admin/data-cleanup/handlers.js (Line 103:1 - Line 125:3), C:/AI/food-truck-finder-poc/dist/lib/lib/api/admin/data-cleanup/handlers.js (Line 103:1 - Line 125:3)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn60" onclick="toggleCodeBlock('cloneGroup60', 'expandBtn60', 'collapseBtn60')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn60" onclick="toggleCodeBlock('cloneGroup60', 'expandBtn60', 'collapseBtn60')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup60"><code class="language-javascript text-sm text-gray-800">export async function handleCheckDuplicates(options) {
    const { truckData } = options ?? {};
    if (!truckData) {
        return NextResponse.json({ success: false, error: 'Missing truckData for duplicate check' }, { status: 400 });
    }
    const duplicateCheck = await DuplicatePreventionService.checkForDuplicates(truckData);
    return NextResponse.json({
        success: true,
        action: 'check-duplicates',
        result: duplicateCheck,
    });
}
/**
* Handles the merge operation for duplicate truck entries.
* @example
* handleMergeDuplicates({ targetId: '123', sourceId: '456' })
* Returns a NextResponse indicating the success or failure of the merge operation.
* @param {DataCleanupRequestBody['options']} options - Options containing targetId and sourceId for the merge operation.
* @returns {Promise&lt;NextResponse&gt;} Returns a NextResponse object indicating the merge result.
* @description
*   - Utilizes DuplicatePreventionService to merge duplicate entries.
*   - Sends an error response with status 400 if targetId or sourceId is missing.
*/</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/api/admin/data-cleanup/handlers.js (Line 126:1 - Line 150:4), C:/AI/food-truck-finder-poc/dist/lib/lib/api/admin/data-cleanup/handlers.js (Line 126:1 - Line 150:4)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn61" onclick="toggleCodeBlock('cloneGroup61', 'expandBtn61', 'collapseBtn61')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn61" onclick="toggleCodeBlock('cloneGroup61', 'expandBtn61', 'collapseBtn61')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup61"><code class="language-javascript text-sm text-gray-800">export async function handleMergeDuplicates(options) {
    const { targetId, sourceId } = options ?? {};
    if (targetId === undefined || sourceId === undefined) {
        return NextResponse.json({ success: false, error: 'Missing targetId or sourceId for merge operation' }, { status: 400 });
    }
    const mergedTruck = await DuplicatePreventionService.mergeDuplicates(targetId, sourceId);
    return NextResponse.json({
        success: true,
        action: 'merge-duplicates',
        result: mergedTruck,
        message: `Successfully merged truck ${sourceId} into ${targetId}`,
    });
}
/**
 * Executes a dry run of the data cleanup process without making changes to the database.
 * @example
 * handleDryRun({ operations: ['deleteUnused', 'optimizeData'] })
 * Promise resolves to NextResponse with details of the dry run.
 * @param {DataCleanupRequestBody['options']} options - Cleanup options including operations to simulate.
 * @returns {Promise&lt;NextResponse&gt;} A response object indicating the success of the dry run and its results.
 * @description
 *   - Utilizes the BatchCleanupService to simulate cleanup operations.
 *   - Ensures no changes are made to the database during the dry run.
 *   - Provides details of simulated operations in the response result.
 */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/api/admin/data-cleanup/handlers.js (Line 151:1 - Line 174:3), C:/AI/food-truck-finder-poc/dist/lib/lib/api/admin/data-cleanup/handlers.js (Line 151:1 - Line 174:3)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn62" onclick="toggleCodeBlock('cloneGroup62', 'expandBtn62', 'collapseBtn62')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn62" onclick="toggleCodeBlock('cloneGroup62', 'expandBtn62', 'collapseBtn62')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup62"><code class="language-javascript text-sm text-gray-800">export async function handleDryRun(options) {
    const result = await BatchCleanupService.runFullCleanup({
        ...options,
        operations: options?.operations,
        dryRun: true,
    });
    return NextResponse.json({
        success: true,
        action: 'dry-run',
        result,
        message: 'Dry run completed - no changes made to database',
    });
}
/**
* Returns the current status with details on available operations, default batch size, and dry-run support.
* @example
* handleGetStatus()
* returns a JSON response with success status and operational details
* @returns {NextResponse} JSON response containing operation details.
* @description
*   - Lists available operations such as 'remove_placeholders', 'normalize_phone', and more.
*   - Provides default batch size set to 50.
*   - Indicates support for dry-run operations.
*/</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/api/admin/data-cleanup/handlers.js (Line 202:1 - Line 230:3), C:/AI/food-truck-finder-poc/dist/lib/lib/api/admin/data-cleanup/handlers.js (Line 202:1 - Line 230:3)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn63" onclick="toggleCodeBlock('cloneGroup63', 'expandBtn63', 'collapseBtn63')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn63" onclick="toggleCodeBlock('cloneGroup63', 'expandBtn63', 'collapseBtn63')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup63"><code class="language-javascript text-sm text-gray-800">export async function handleGetPreview() {
    const result = await BatchCleanupService.runFullCleanup({
        batchSize: 10,
        dryRun: true,
    });
    return NextResponse.json({
        success: true,
        preview: {
            estimated_improvements: result.summary.trucksImproved,
            estimated_duplicates: result.summary.duplicatesRemoved,
            operations: result.operations.map((op) =&gt; ({
                type: op.type,
                description: op.description,
                affected_count: op.affectedCount,
            })),
        },
    });
}
/**
* Provides a JSON response containing available endpoints and actions related to data cleanup.
* @example
* handleGetDefault()
* Returns a JSON response with success status, endpoints, and actions.
* @returns {NextResponse} Returns a JSON response with structure defining success, endpoints, and actions related to data cleanup.
* @description
*   - The function targets administrative cleanup operations within the system.
*   - Provides metadata for functionalities aimed at data cleanup processes.
*   - Intended to support endpoint consumption and decision-making for administrative tasks.
*/</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/api/admin/automated-cleanup/handlers.js (Line 18:1 - Line 129:4), C:/AI/food-truck-finder-poc/dist/lib/lib/api/admin/automated-cleanup/handlers.js (Line 18:1 - Line 129:4)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn65" onclick="toggleCodeBlock('cloneGroup65', 'expandBtn65', 'collapseBtn65')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn65" onclick="toggleCodeBlock('cloneGroup65', 'expandBtn65', 'collapseBtn65')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup65"><code class="language-javascript text-sm text-gray-800">function isRunScheduledOptions(obj) {
    return typeof obj.scheduleId === &quot;string&quot;;
}
function isRunImmediateOptions(obj) {
    return ((obj.operations === undefined || Array.isArray(obj.operations)) &amp;&amp;
        (obj.batchSize === undefined || typeof obj.batchSize === &quot;number&quot;) &amp;&amp;
        (obj.dryRun === undefined || typeof obj.dryRun === &quot;boolean&quot;));
}
function isScheduleCleanupOptions(obj) {
    return (typeof obj.name === &quot;string&quot; &amp;&amp;
        Array.isArray(obj.operations) &amp;&amp;
        typeof obj.schedule === &quot;string&quot; &amp;&amp;
        (obj.enabled === undefined || typeof obj.enabled === &quot;boolean&quot;));
}
function isUpdateScheduleOptions(obj) {
    return (typeof obj.scheduleId === &quot;string&quot; &amp;&amp;
        typeof obj.updates === &quot;object&quot;);
}
function isDeleteScheduleOptions(obj) {
    return typeof obj.scheduleId === &quot;string&quot;;
}
export async function handlePostRequest(body) {
    const { action, options = {} } = body;
    switch (action) {
        case 'run_scheduled': {
            if (!isRunScheduledOptions(options)) {
                return NextResponse.json({ success: false, error: 'Invalid options for run_scheduled' }, { status: 400 });
            }
            return await handleRunScheduled(options);
        }
        case 'run_immediate': {
            if (!isRunImmediateOptions(options)) {
                return NextResponse.json({ success: false, error: 'Invalid options for run_immediate' }, { status: 400 });
            }
            return await handleRunImmediate(options);
        }
        case 'schedule_cleanup': {
            if (!isScheduleCleanupOptions(options)) {
                return NextResponse.json({ success: false, error: 'Invalid options for schedule_cleanup' }, { status: 400 });
            }
            return await handleScheduleCleanup(options);
        }
        case 'update_schedule': {
            if (!isUpdateScheduleOptions(options)) {
                return NextResponse.json({ success: false, error: 'Invalid options for update_schedule' }, { status: 400 });
            }
            return await handleUpdateSchedule(options);
        }
        case 'delete_schedule': {
            if (!isDeleteScheduleOptions(options)) {
                return NextResponse.json({ success: false, error: 'Invalid options for delete_schedule' }, { status: 400 });
            }
            return await handleDeleteSchedule(options);
        }
        default: {
            return NextResponse.json({
                success: false,
                error: 'Unknown action',
                available_actions: [
                    'run_scheduled',
                    'run_immediate',
                    'schedule_cleanup',
                    'update_schedule',
                    'delete_schedule',
                    'analyze_duplicates',
                ],
            }, { status: 400 });
        }
    }
}
export async function handleGetStatus() {
    const status = await getCleanupStatus();
    return NextResponse.json({
        success: true,
        status,
    });
}
export async function handleGetSchedules() {
    const schedules = await getCleanupSchedules();
    return NextResponse.json({
        success: true,
        schedules,
    });
}
export async function handleGetHistory(searchParams) {
    const limit = Number.parseInt(searchParams.get('limit') ?? '10', 10);
    const history = await getCleanupHistory(limit);
    return NextResponse.json({
        success: true,
        history,
    });
}
export async function handleGetPreview(searchParams) {
    const operations = searchParams.get('operations')?.split(',') ?? [];
    const preview = await previewCleanupOperations(operations);
    return NextResponse.json({
        success: true,
        preview,
    });
}
/**
 * Handles the retrieval of default cleanup status and returns a JSON response.
 * @example
 * handleGetDefault().then(response =&gt; console.log(response));
 * // { success: true, status: ..., endpoints: [...] }
 * @param {none} {none} - No arguments are required for this function.
 * @returns {Promise&lt;NextResponse&gt;} A promise that resolves to a NextResponse JSON object containing cleanup status and endpoints.
 * @description
 *   - Utilizes the getCleanupStatus function to fetch the current cleanup status.
 *   - Constructs a response object detailing available cleanup-related endpoints.
 *   - Follow API endpoint descriptions to properly utilize cleanup functionalities.
 */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/api/admin/automated-cleanup/handlers.js (Line 130:1 - Line 165:3), C:/AI/food-truck-finder-poc/dist/lib/lib/api/admin/automated-cleanup/handlers.js (Line 130:1 - Line 165:3)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn66" onclick="toggleCodeBlock('cloneGroup66', 'expandBtn66', 'collapseBtn66')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn66" onclick="toggleCodeBlock('cloneGroup66', 'expandBtn66', 'collapseBtn66')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup66"><code class="language-javascript text-sm text-gray-800">export async function handleGetDefault() {
    const status = await getCleanupStatus();
    return NextResponse.json({
        success: true,
        status,
        endpoints: [
            'GET ?action=status - Get overall cleanup status',
            'GET ?action=schedules - Get cleanup schedules',
            'GET ?action=history&amp;limit=N - Get cleanup history',
            'GET ?action=preview&amp;operations=op1,op2 - Preview cleanup operations',
            'POST - Run cleanup operations',
        ],
    });
}
export async function handleRunScheduled(options) {
    const { scheduleId } = options;
    const result = await runScheduledCleanup(scheduleId);
    return NextResponse.json({
        success: true,
        action: 'run_scheduled',
        result,
    });
}
/**
* Executes a batch cleanup operation immediately based on provided options.
* @example
* handleRunImmediate({ dryRun: true, batchSize: 100 })
* Returns: { success: true, action: 'run_immediate', result: {...}, message: 'Dry run completed successfully' }
* @param {Object} options - Configuration options for the cleanup operation.
* @returns {Promise&lt;NextResponse&gt;} A promise that resolves to the NextResponse object containing the cleanup result.
* @description
*   - The `operations` parameter defaults to a set of predefined cleanup tasks if not specified.
*   - If `dryRun` is true, the function simulates the cleanup without making any modifications.
*   - Utilizes `BatchCleanupService` for executing the cleanup logic.
*   - Operation results are logged with `logCleanupOperation` for tracking purposes.
*/</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/api/admin/automated-cleanup/handlers.js (Line 166:1 - Line 233:4), C:/AI/food-truck-finder-poc/dist/lib/lib/api/admin/automated-cleanup/handlers.js (Line 166:1 - Line 233:4)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn67" onclick="toggleCodeBlock('cloneGroup67', 'expandBtn67', 'collapseBtn67')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn67" onclick="toggleCodeBlock('cloneGroup67', 'expandBtn67', 'collapseBtn67')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup67"><code class="language-javascript text-sm text-gray-800">export async function handleRunImmediate(options) {
    const { operations = [
        'remove_placeholders',
        'normalize_phone',
        'fix_coordinates',
        'update_quality_scores',
    ], batchSize = 50, dryRun = false, } = options;
    const result = await BatchCleanupService.runFullCleanup({
        operations: operations,
        batchSize,
        dryRun,
    });
    await logCleanupOperation('immediate', result, options);
    return NextResponse.json({
        success: true,
        action: 'run_immediate',
        result,
        message: dryRun ? 'Dry run completed successfully' : 'Cleanup completed successfully',
    });
}
export async function handleScheduleCleanup(options) {
    const { name, operations, schedule, enabled = true } = options;
    const scheduleResult = await createCleanupSchedule(name, operations, schedule, enabled);
    return NextResponse.json({
        success: true,
        action: 'schedule_cleanup',
        result: scheduleResult,
    });
}
export async function handleUpdateSchedule(options) {
    const { scheduleId, updates } = options;
    const updateResult = await updateCleanupSchedule(scheduleId, updates);
    return NextResponse.json({
        success: true,
        action: 'update_schedule',
        result: updateResult,
    });
}
export async function handleDeleteSchedule(options) {
    const { scheduleId } = options;
    const deleteResult = await deleteCleanupSchedule(scheduleId);
    return NextResponse.json({
        success: true,
        action: 'delete_schedule',
        result: deleteResult,
    });
}
export async function handleAnalyzeDuplicates(options) {
    const { threshold = 0.8 } = options;
    const analysis = await analyzeDuplicates(threshold);
    return NextResponse.json({
        success: true,
        action: 'analyze_duplicates',
        result: analysis,
    });
}
/**
 * Retrieves the status of automated cleanup operations.
 * @example
 * getCleanupStatus()
 * // returns: Promise&lt;AutomatedCleanupStatus&gt;
 * @returns {Promise&lt;AutomatedCleanupStatus&gt;} An object representing the status of cleanup operations.
 * @description
 *   - The status includes statistics on cleanup runs such as total number of runs, successful runs, and failed runs.
 *   - Provides information on whether a cleanup operation is currently running and when it last ran.
 *   - Fetches schedules asynchronously using the getCleanupSchedules() function.
 *   - Includes data on recent cleanup results and operations performed, such as the number of trucks improved and duplicates removed.
 */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/api/admin/automated-cleanup/handlers.js (Line 234:1 - Line 262:4), C:/AI/food-truck-finder-poc/dist/lib/lib/api/admin/automated-cleanup/handlers.js (Line 234:1 - Line 262:4)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn68" onclick="toggleCodeBlock('cloneGroup68', 'expandBtn68', 'collapseBtn68')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn68" onclick="toggleCodeBlock('cloneGroup68', 'expandBtn68', 'collapseBtn68')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup68"><code class="language-javascript text-sm text-gray-800">async function getCleanupStatus() {
    return {
        isRunning: false,
        lastRun: new Date(Date.now() - 3_600_000).toISOString(),
        nextScheduledRun: new Date(Date.now() + 3_600_000).toISOString(),
        schedules: await getCleanupSchedules(),
        recentResults: [],
        statistics: {
            totalRuns: 42,
            successfulRuns: 40,
            failedRuns: 2,
            trucksImproved: 156,
            duplicatesRemoved: 23,
        },
    };
}
/**
 * Retrieves the scheduled cleanup operations including their details.
 * @example
 * getCleanupSchedules()
 * Promise resolves to an array of cleanup schedule objects.
 * @returns {Promise&lt;CleanupSchedule[]&gt;} Promise resolving to an array of cleanup schedule objects.
 * @description
 *   - Schedules are defined using cron-like syntax for timing.
 *   - Both daily and weekly cleanup operations are included.
 *   - Each schedule has a record of success and error counts from the last execution.
 *   - Each schedule has a record of success and error counts from the last execution.
 *   - Enabled status indicates if the schedule is currently active.
 */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/api/admin/automated-cleanup/handlers.js (Line 263:1 - Line 309:4), C:/AI/food-truck-finder-poc/dist/lib/lib/api/admin/automated-cleanup/handlers.js (Line 263:1 - Line 309:4)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn69" onclick="toggleCodeBlock('cloneGroup69', 'expandBtn69', 'collapseBtn69')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn69" onclick="toggleCodeBlock('cloneGroup69', 'expandBtn69', 'collapseBtn69')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup69"><code class="language-javascript text-sm text-gray-800">function getCleanupSchedules() {
    return Promise.resolve([
        {
            id: 'daily-maintenance',
            name: 'Daily Maintenance Cleanup',
            operations: ['remove_placeholders', 'normalize_phone', 'update_quality_scores'],
            schedule: '0 2 * * *',
            enabled: true,
            lastRun: new Date(Date.now() - 86_400_000).toISOString(),
            nextRun: new Date(Date.now() + 3_600_000).toISOString(),
            successCount: 30,
            errorCount: 1,
        },
        {
            id: 'weekly-deep-clean',
            name: 'Weekly Deep Cleanup',
            operations: [
                'remove_placeholders',
                'normalize_phone',
                'fix_coordinates',
                'update_quality_scores',
                'merge_duplicates',
            ],
            schedule: '0 3 * * 0',
            enabled: true,
            lastRun: new Date(Date.now() - 604_800_000).toISOString(),
            nextRun: new Date(Date.now() + 259_200_000).toISOString(),
            successCount: 4,
            errorCount: 0,
        },
    ]);
}
function getCleanupHistory(_limit) {
    return Promise.resolve([]);
}
/**
 * Generates a preview of cleanup operations and their estimated impact.
 * @example
 * previewCleanupOperations(['delete_logs', 'archive_data'])
 * // Returns a Promise resolving to an object with estimated changes and operation details
 * @param {string[]} operations - An array of cleanup operation names to preview.
 * @returns {Promise&lt;PreviewResult&gt;} A promise that resolves to a preview result containing estimated changes and details.
 * @description
 *   - The function uses BatchCleanupService to simulate cleanup operations in a dry-run mode.
 *   - Each operation's details include types, descriptions, and counts of affected, successful, and erroneous items.
 *   - Returns comprehensive information including estimated changes, durations, and affected entities.
 */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/api/admin/automated-cleanup/handlers.js (Line 310:1 - Line 351:4), C:/AI/food-truck-finder-poc/dist/lib/lib/api/admin/automated-cleanup/handlers.js (Line 310:1 - Line 351:4)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn70" onclick="toggleCodeBlock('cloneGroup70', 'expandBtn70', 'collapseBtn70')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn70" onclick="toggleCodeBlock('cloneGroup70', 'expandBtn70', 'collapseBtn70')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup70"><code class="language-javascript text-sm text-gray-800">async function previewCleanupOperations(operations) {
    try {
        const result = await BatchCleanupService.runFullCleanup({
            operations: operations,
            batchSize: 10,
            dryRun: true,
        });
        return {
            estimatedChanges: result.summary,
            operationDetails: (() =&gt; {
                const details = {};
                for (const [index, op] of result.operations.entries()) {
                    details[`operation_${index}`] = {
                        type: op.type,
                        description: op.description,
                        affectedCount: op.affectedCount,
                        successCount: op.successCount,
                        errorCount: op.errorCount,
                    };
                }
                return details;
            })(),
            estimatedDuration: result.duration,
            affectedTrucks: result.totalProcessed,
        };
    }
    catch (error) {
        throw new Error(`Preview failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
}
/**
 * Executes a cleanup based on a given schedule ID.
 * @example
 * runScheduledCleanup('schedule123')
 * { success: true, cleanedRecords: 150 }
 * @param {string} scheduleId - The ID of the cleanup schedule to run.
 * @returns {Promise&lt;Record&lt;string, unknown&gt;&gt;} Result of the cleanup operation.
 * @description
 *   - Throws an error if the schedule is not found or is disabled.
 *   - Utilizes BatchCleanupService for performing the cleanup operation.
 *   - Logs the result of the cleanup operation with a 'scheduled' context.
 */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/api/admin/automated-cleanup/handlers.js (Line 352:1 - Line 383:3), C:/AI/food-truck-finder-poc/dist/lib/lib/api/admin/automated-cleanup/handlers.js (Line 352:1 - Line 383:3)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn71" onclick="toggleCodeBlock('cloneGroup71', 'expandBtn71', 'collapseBtn71')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn71" onclick="toggleCodeBlock('cloneGroup71', 'expandBtn71', 'collapseBtn71')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup71"><code class="language-javascript text-sm text-gray-800">async function runScheduledCleanup(scheduleId) {
    const schedules = await getCleanupSchedules();
    const schedule = schedules.find((s) =&gt; s.id === scheduleId);
    if (!schedule) {
        throw new Error(`Schedule ${scheduleId} not found`);
    }
    if (!schedule.enabled) {
        throw new Error(`Schedule ${scheduleId} is disabled`);
    }
    const result = await BatchCleanupService.runFullCleanup({
        operations: schedule.operations,
        batchSize: 50,
        dryRun: false,
    });
    await logCleanupOperation('scheduled', result, { scheduleId });
    return result;
}
/**
* Creates a cleanup schedule with the specified parameters
* @example
* createCleanupSchedule('Daily Cleanup', ['delete', 'archive'], '0 0 * * *', true)
* Promise&lt;ScheduleCreateResult&gt; { id: 'schedule-1609459200000', name: 'Daily Cleanup', operations: ['delete', 'archive'], schedule: '0 0 * * *', enabled: true, created: '2021-01-01T00:00:00.000Z' }
* @param {string} name - The name of the cleanup schedule.
* @param {Array&lt;string&gt;} operations - List of operations to be included in the cleanup.
* @param {string} schedule - Cron-style string for schedule timings.
* @param {boolean} enabled - Status of whether the schedule is active.
* @returns {Promise&lt;ScheduleCreateResult&gt;} Promise resolving to the details of the created schedule.
* @description
*   - Returns a Promise that resolves to a ScheduleCreateResult object.
*   - Automatically generates a unique ID based on the current timestamp.
*   - Includes a creation timestamp in ISO format.
*/</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/api/admin/automated-cleanup/handlers.js (Line 384:1 - Line 418:3), C:/AI/food-truck-finder-poc/dist/lib/lib/api/admin/automated-cleanup/handlers.js (Line 384:1 - Line 418:3)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn72" onclick="toggleCodeBlock('cloneGroup72', 'expandBtn72', 'collapseBtn72')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn72" onclick="toggleCodeBlock('cloneGroup72', 'expandBtn72', 'collapseBtn72')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup72"><code class="language-javascript text-sm text-gray-800">function createCleanupSchedule(name, operations, schedule, enabled) {
    return Promise.resolve({
        id: `schedule-${Date.now()}`,
        name,
        operations,
        schedule,
        enabled,
        created: new Date().toISOString(),
    });
}
function updateCleanupSchedule(scheduleId, updates) {
    return Promise.resolve({
        scheduleId,
        updates,
        updated: new Date().toISOString(),
    });
}
function deleteCleanupSchedule(scheduleId) {
    return Promise.resolve({
        scheduleId,
        deleted: new Date().toISOString(),
    });
}
/**
* Analyzes duplicates based on a given threshold and returns a summary of the analysis.
* @example
* analyzeDuplicates(0.8)
* // Returns: { threshold: 0.8, potentialDuplicates: 0, highConfidenceMatches: 0, mediumConfidenceMatches: 0, lowConfidenceMatches: 0, analysisTime: &quot;2023-10-01T12:34:56.789Z&quot; }
* @param {number} threshold - The threshold value used to determine duplicate matching confidence.
* @returns {Promise&lt;DuplicateAnalysisResult&gt;} An object representing the duplicate analysis results including counts of potential matches and confidence levels.
* @description
*   - Executes the analysis asynchronously, returning a promise that resolves with the analysis results.
*   - Initializes match counts to zero as defaults.
*   - Includes the analysis time formatted as an ISO string.
*/</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/api/admin/automated-cleanup/handlers.js (Line 419:1 - Line 446:4), C:/AI/food-truck-finder-poc/dist/lib/lib/api/admin/automated-cleanup/handlers.js (Line 419:1 - Line 446:4)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn73" onclick="toggleCodeBlock('cloneGroup73', 'expandBtn73', 'collapseBtn73')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn73" onclick="toggleCodeBlock('cloneGroup73', 'expandBtn73', 'collapseBtn73')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup73"><code class="language-javascript text-sm text-gray-800">function analyzeDuplicates(threshold) {
    try {
        return Promise.resolve({
            threshold,
            potentialDuplicates: 0,
            highConfidenceMatches: 0,
            mediumConfidenceMatches: 0,
            lowConfidenceMatches: 0,
            analysisTime: new Date().toISOString(),
        });
    }
    catch (error) {
        throw new Error(`Duplicate analysis failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
}
/**
 * Logs the completion details of a cleanup operation.
 * @example
 * logCleanupOperation('database', {summary: {success: true}}, {verbose: true})
 * // No return value
 * @param {string} type - The type of cleanup operation performed (e.g., 'database').
 * @param {Record&lt;string, unknown&gt;} result - An object containing the results of the cleanup operation.
 * @param {Record&lt;string, unknown&gt;} options - Additional options related to the logging of the cleanup.
 * @returns {Promise&lt;void&gt;} A Promise that resolves when the logging is complete.
 * @description
 *   - Utilizes `console.info` for successful logging and `console.warn` for handling errors during logging.
 *   - Ensures the operation's details include the type, result summary, options, and a timestamp.
 */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/api/admin/automated-cleanup/handlers.js (Line 447:1 - Line 461:2), C:/AI/food-truck-finder-poc/dist/lib/lib/api/admin/automated-cleanup/handlers.js (Line 447:1 - Line 461:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn74" onclick="toggleCodeBlock('cloneGroup74', 'expandBtn74', 'collapseBtn74')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn74" onclick="toggleCodeBlock('cloneGroup74', 'expandBtn74', 'collapseBtn74')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup74"><code class="language-javascript text-sm text-gray-800">function logCleanupOperation(type, result, options) {
    try {
        console.info(`Cleanup operation completed:`, {
            type,
            result: result.summary,
            options,
            timestamp: new Date().toISOString(),
        });
        return Promise.resolve();
    }
    catch (error) {
        console.warn('Failed to log cleanup operation:', error);
        return Promise.resolve();
    }
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/lib/lib/utils/foodTruckHelpers.js (Line 242:2 - Line 247:6), C:/AI/food-truck-finder-poc/dist/lib/lib/api/search/filters.js (Line 60:6 - Line 64:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn75" onclick="toggleCodeBlock('cloneGroup75', 'expandBtn75', 'collapseBtn75')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn75" onclick="toggleCodeBlock('cloneGroup75', 'expandBtn75', 'collapseBtn75')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup75"><code class="language-javascript text-sm text-gray-800">;
        const openTime = Number.parseInt(hours.open.replace(':', ''), 10);
        const closeTime = Number.parseInt(hours.close.replace(':', ''), 10);
        return currentTime &gt;= openTime &amp;&amp; currentTime &lt;= closeTime;
    }
    catch</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/lib/lib/pipeline/pipelineHelpers.js (Line 49:2 - Line 57:2), C:/AI/food-truck-finder-poc/dist/lib/lib/api/test-integration/helpers.js (Line 45:2 - Line 53:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn76" onclick="toggleCodeBlock('cloneGroup76', 'expandBtn76', 'collapseBtn76')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn76" onclick="toggleCodeBlock('cloneGroup76', 'expandBtn76', 'collapseBtn76')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup76"><code class="language-javascript text-sm text-gray-800">{
            monday: { closed: true },
            tuesday: { closed: true },
            wednesday: { closed: true },
            thursday: { closed: true },
            friday: { closed: true },
            saturday: { closed: true },
            sunday: { closed: true },
        };</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/lib/lib/data-quality/duplicatePrevention.js (Line 183:21 - Line 197:8), C:/AI/food-truck-finder-poc/dist/lib/lib/performance/databaseCache.js (Line 206:18 - Line 218:9)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn77" onclick="toggleCodeBlock('cloneGroup77', 'expandBtn77', 'collapseBtn77')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn77" onclick="toggleCodeBlock('cloneGroup77', 'expandBtn77', 'collapseBtn77')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup77"><code class="language-javascript text-sm text-gray-800">(lat1, lng1, lat2, lng2) {
        const R = 6371; // Earth's radius in kilometers
        const dLat = ((lat2 - lat1) * Math.PI) / 180;
        const dLng = ((lng2 - lng1) * Math.PI) / 180;
        const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
            Math.cos((lat1 * Math.PI) / 180) *
                Math.cos((lat2 * Math.PI) / 180) *
                Math.sin(dLng / 2) *
                Math.sin(dLng / 2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        return R * c;
    }
    /**
     * Calculate contact similarity
     */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/lib/api/trucks/handlers.js (Line 1:1 - Line 134:2), C:/AI/food-truck-finder-poc/dist/lib/lib/api/trucks/handlers.js (Line 1:1 - Line 134:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn80" onclick="toggleCodeBlock('cloneGroup80', 'expandBtn80', 'collapseBtn80')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn80" onclick="toggleCodeBlock('cloneGroup80', 'expandBtn80', 'collapseBtn80')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup80"><code class="language-javascript text-sm text-gray-800">import { NextResponse } from 'next/server';
import { FoodTruckService } from '../../supabase/client.js';
export async function handleGetTruckById(id) {
    const truckResult = await FoodTruckService.getTruckById(id);
    if ('error' in truckResult) {
        return NextResponse.json({ error: truckResult.error }, { status: 500 });
    }
    return NextResponse.json({ truck: truckResult });
}
/**
 * Retrieves a list of food trucks within a specified radius.
 * @example
 * handleGetTrucksByLocation(&quot;37.7749&quot;, &quot;-122.4194&quot;, &quot;5&quot;)
 * Returns an object with the list of nearby food trucks and additional metadata.
 * @param {string} lat - Latitude of the location from which to search for food trucks.
 * @param {string} lng - Longitude of the location from which to search for food trucks.
 * @param {string} radius - The radius (in kilometers) within which to find food trucks.
 * @returns {Object} An object containing a list of nearby food trucks along with metadata related to the query.
 * @description
 *   - Converts latitude, longitude, and radius from string to float.
 *   - Invokes an asynchronous service call to fetch trucks.
 *   - Returns an error message with status 500 if an error is encountered.
 *   - Currently, assumes no pagination is needed for location-based searches.
 */
export async function handleGetTrucksByLocation(lat, lng, radius) {
    const userLat = Number.parseFloat(lat);
    const userLng = Number.parseFloat(lng);
    const radiusKm = Number.parseFloat(radius);
    const nearbyTrucks = await FoodTruckService.getTrucksByLocation(userLat, userLng, radiusKm);
    if ('error' in nearbyTrucks) {
        return NextResponse.json({ error: &quot;That didn't work, please try again later.&quot; }, { status: 500 });
    }
    return NextResponse.json({
        trucks: nearbyTrucks,
        total: nearbyTrucks.length,
        limit: nearbyTrucks.length, // Assuming no pagination for location-based
        offset: 0,
        hasMore: false,
    });
}
/**
 * Retrieves truck data with pagination support.
 * @example
 * handleGetAllTrucks(10, 0)
 * { trucks: [...], total: 100, limit: 10, offset: 0, hasMore: true, summary: {...} }
 * @param {number} limit - Number of trucks to retrieve per request.
 * @param {number} offset - Starting position of truck data to retrieve.
 * @returns {object} JSON response containing truck data, pagination information, and summary.
 * @description
 *   - Checks for errors returned by the FoodTruckService API and responds with a generic error message.
 *   - Computes an `averageQuality` score for the retrieved trucks.
 *   - Determines `hasMore` by comparing total trucks to limit and offset.
 *   - Calculates `lastUpdated` timestamp from truck data.
 */
export async function handleGetAllTrucks(limit, offset) {
    const { trucks, total, error } = await FoodTruckService.getAllTrucks(limit, offset);
    if (error != undefined &amp;&amp; error !== '') {
        return NextResponse.json({ error: &quot;That didn't work, please try again later.&quot; }, { status: 500 });
    }
    const hasTrucks = Array.isArray(trucks) &amp;&amp; trucks.length &gt; 0;
    return NextResponse.json({
        trucks,
        total,
        limit,
        offset,
        hasMore: offset + limit &lt; (total ?? 0),
        summary: {
            totalTrucks: total,
            averageQuality: hasTrucks
                ? trucks.reduce((acc, t) =&gt; acc + (t.data_quality_score ?? 0), 0) / trucks.length
                : 0,
            lastUpdated: hasTrucks ? Math.max(...trucks.map((t) =&gt; new Date(t.updated_at).getTime())) : 0,
        },
    });
}
/**
* Handles the creation of a food truck by delegating to the FoodTruckService.
* @example
* handlePostTruck({ name: 'Best Food Truck', location: 'Downtown' })
* // returns a JSON response with status 201 and a success message
* @param {unknown} truckData - Data for creating a new food truck.
* @returns {object} JSON response indicating success or failure.
* @description
*   - Utilizes FoodTruckService to create a new truck record.
*   - Handles errors, logging them and returning appropriate HTTP statuses.
*   - Converts the data into a Partial&lt;FoodTruck&gt; type before passing it to the service.
*/
export async function handlePostTruck(truckData) {
    try {
        const newTruckResult = await FoodTruckService.createTruck(truckData);
        if ('error' in newTruckResult) {
            console.error('Error creating truck:', newTruckResult.error);
            return NextResponse.json({ error: newTruckResult.error }, { status: 500 });
        }
        return NextResponse.json({
            message: 'Food truck created successfully',
            truck: newTruckResult,
        }, { status: 201 });
    }
    catch (error) {
        console.error('Error in handlePostTruck:', error);
        return NextResponse.json({ error: 'An unexpected error occurred while creating the food truck.' }, { status: 500 });
    }
}
/**
 * Updates food truck information with given updates and returns the operation status.
 * @example
 * handlePutTruck('1234', { name: 'New Food Truck Name' })
 * { message: 'Food truck updated successfully', truck: updatedTruckResult }
 * @param {string} id - The ID of the food truck to be updated.
 * @param {unknown} updates - The updates to apply to the food truck as a partial object.
 * @returns {Promise&lt;NextResponse&gt;} A response indicating success or failure of the update operation in JSON format.
 * @description
 *   - The function uses FoodTruckService.updateTruck to apply updates.
 *   - It logs errors to the console if the update operation fails.
 *   - Responds with HTTP status 500 in case of any error during the update process.
 */
export async function handlePutTruck(id, updates) {
    try {
        const updatedTruckResult = await FoodTruckService.updateTruck(id, updates);
        if ('error' in updatedTruckResult) {
            console.error('Error updating truck:', updatedTruckResult.error);
            return NextResponse.json({ error: updatedTruckResult.error }, { status: 500 });
        }
        return NextResponse.json({
            message: 'Food truck updated successfully',
            truck: updatedTruckResult,
        });
    }
    catch (error) {
        console.error('Error in handlePutTruck:', error);
        return NextResponse.json({ error: 'An unexpected error occurred while updating the food truck.' }, { status: 500 });
    }
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/lib/api/test-integration/stageHandlers.js (Line 4:20 - Line 140:2), C:/AI/food-truck-finder-poc/dist/lib/lib/api/test-integration/stageHandlers.js (Line 4:17 - Line 140:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn82" onclick="toggleCodeBlock('cloneGroup82', 'expandBtn82', 'collapseBtn82')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn82" onclick="toggleCodeBlock('cloneGroup82', 'expandBtn82', 'collapseBtn82')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup82"><code class="language-javascript text-sm text-gray-800">;
function getErrorMessage(error, fallback) {
    if (error instanceof Error)
        return error.message;
    if (typeof error === 'string')
        return error;
    return fallback;
}
async function handleUrlScrape(url, logs) {
    logs.push(`Starting Firecrawl scrape for URL: ${url}`);
    try {
        const fcOutput = await firecrawl.scrapeFoodTruckWebsite(url);
        if (fcOutput.success === true &amp;&amp;
            fcOutput.data?.markdown !== undefined &amp;&amp;
            fcOutput.data?.markdown !== '') {
            return {
                contentToProcess: fcOutput.data.markdown,
                sourceUrlForProcessing: fcOutput.data.source_url ?? url,
                firecrawlResult: {
                    status: 'Success',
                    rawContent: fcOutput.data.markdown,
                    metadata: { name: fcOutput.data.name, source_url: fcOutput.data.source_url },
                    details: `Markdown length: ${fcOutput.data.markdown.length}`,
                },
            };
        }
        else {
            throw new Error(fcOutput.error ?? 'Firecrawl failed to return markdown.');
        }
    }
    catch (error) {
        const errorMessage = getErrorMessage(error, 'An unknown error occurred during Firecrawl scrape.');
        logs.push(`Firecrawl error: ${errorMessage}`);
        return {
            firecrawlResult: { status: 'Error', error: errorMessage },
            contentToProcess: undefined,
            sourceUrlForProcessing: url,
        };
    }
}
function handleRawTextProcessing(rawText, logs) {
    logs.push('Using raw text input for processing.');
    return {
        contentToProcess: rawText,
        sourceUrlForProcessing: 'raw_text_input',
        firecrawlResult: {
            status: 'Skipped (Raw Text Provided)',
            details: `Raw text length: ${rawText.length}`,
        },
    };
}
function determineFirecrawlStageOutput(url, rawText, logs) {
    if (url &amp;&amp; rawText === undefined) {
        return handleUrlScrape(url, logs);
    }
    else if (rawText === undefined) {
        logs.push('No URL or raw text provided.');
        throw new Error('Either a URL or raw text must be provided for testing.');
    }
    else {
        return Promise.resolve(handleRawTextProcessing(rawText, logs));
    }
}
function handleEmptyContent(logs) {
    logs.push('Content to process is empty after Firecrawl/raw text stage.');
    throw new Error('Content to process is empty.');
}
export async function handleFirecrawlStage(url, rawText, logs) {
    const stageOutput = await determineFirecrawlStageOutput(url, rawText, logs);
    if (stageOutput.contentToProcess === undefined) {
        handleEmptyContent(logs);
    }
    return stageOutput;
}
export async function handleGeminiStage(contentToProcess, sourceUrlForProcessing, logs) {
    let geminiResult;
    let extractedData;
    logs.push('Starting Gemini processing.');
    try {
        const geminiOutput = await gemini.extractFoodTruckDetailsFromMarkdown(contentToProcess, sourceUrlForProcessing);
        if (geminiOutput.success === true &amp;&amp; geminiOutput.data !== undefined) {
            extractedData = geminiOutput.data;
            geminiResult = {
                status: 'Success',
                data: geminiOutput.data,
                tokensUsed: geminiOutput.tokensUsed,
                prompt: geminiOutput.promptSent,
                details: 'Gemini extraction successful.',
            };
            logs.push('Gemini processing successful.');
        }
        else {
            throw new Error(geminiOutput.error ?? 'Gemini processing failed to return data.');
        }
    }
    catch (error) {
        const errorMessage = getErrorMessage(error, 'An unknown error occurred during Gemini processing.');
        logs.push(`Gemini error: ${errorMessage}`);
        geminiResult = { status: 'Error', error: errorMessage };
    }
    return { geminiResult, extractedData };
}
async function saveToSupabase(truckDataToSave, logs) {
    logs.push('Attempting to save to Supabase (Dry Run is FALSE).');
    const createdTruckResult = await FoodTruckService.createTruck(truckDataToSave);
    if ('error' in createdTruckResult) {
        throw new Error(`Failed to create truck in Supabase: ${createdTruckResult.error}`);
    }
    const createdTruck = createdTruckResult;
    logs.push(`Data saved to Supabase. Record ID: ${createdTruck.id}`);
    return {
        status: 'Success (Saved)',
        preparedData: truckDataToSave,
        recordId: createdTruck.id,
        details: `Truck data saved with ID: ${createdTruck.id}`,
    };
}
export async function handleSupabaseStage(extractedData, sourceUrlForProcessing, isDryRun, logs) {
    logs.push('Preparing for Supabase interaction.');
    try {
        const truckDataToSave = mapExtractedDataToTruckSchema(extractedData, sourceUrlForProcessing, isDryRun);
        if (isDryRun) {
            logs.push('Supabase interaction skipped (Dry Run).');
            return {
                status: 'Success (Dry Run)',
                preparedData: truckDataToSave,
                details: 'Dry Run: Data was prepared but not saved.',
            };
        }
        return await saveToSupabase(truckDataToSave, logs);
    }
    catch (error) {
        const errorMessage = getErrorMessage(error, 'An unknown error occurred during Supabase interaction.');
        logs.push(`Supabase interaction error: ${errorMessage}`);
        return { status: 'Error', error: errorMessage };
    }
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/lib/api/test-integration/schemaMapper.js (Line 1:1 - Line 46:2), C:/AI/food-truck-finder-poc/dist/lib/lib/api/test-integration/schemaMapper.js (Line 1:1 - Line 46:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn84" onclick="toggleCodeBlock('cloneGroup84', 'expandBtn84', 'collapseBtn84')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn84" onclick="toggleCodeBlock('cloneGroup84', 'expandBtn84', 'collapseBtn84')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup84"><code class="language-javascript text-sm text-gray-800">export function mapExtractedDataToTruckSchema(extractedData, sourceUrl, isDryRun) {
    if (!extractedData || typeof extractedData !== 'object') {
        throw new Error('Invalid extractedData for mapping.');
    }
    const name = extractedData.name ?? 'Unknown Test Truck';
    const locationData = extractedData.current_location ?? {};
    const fullAddress = [
        locationData.address,
        locationData.city,
        locationData.state,
        locationData.zip_code,
    ]
        .filter(Boolean)
        .join(', ');
    return {
        name: name,
        description: extractedData.description ?? undefined,
        current_location: {
            lat: locationData.lat ?? 0,
            lng: locationData.lng ?? 0,
            address: fullAddress ?? locationData.raw_text ?? undefined,
            timestamp: new Date().toISOString(),
        },
        scheduled_locations: extractedData.scheduled_locations ?? undefined,
        operating_hours: extractedData.operating_hours ?? undefined,
        menu: (extractedData.menu ?? []).map((category) =&gt; ({
            name: category.name ?? 'Uncategorized',
            items: (category.items ?? []).map((item) =&gt; ({
                name: item.name ?? 'Unknown Item',
                description: item.description ?? undefined,
                price: typeof item.price === 'number' || typeof item.price === 'string' ? item.price : undefined,
                dietary_tags: item.dietary_tags ?? [],
            })),
        })),
        contact_info: extractedData.contact_info ?? undefined,
        social_media: extractedData.social_media ?? undefined,
        cuisine_type: extractedData.cuisine_type ?? [],
        price_range: extractedData.price_range ?? undefined,
        specialties: extractedData.specialties ?? [],
        data_quality_score: isDryRun ? 0.5 : 0.6, // Differentiate test/dry run
        verification_status: 'pending',
        source_urls: [sourceUrl].filter(Boolean),
        last_scraped_at: new Date().toISOString(),
        ...(isDryRun &amp;&amp; { test_run_flag: true }), // Add a flag for actual test saves if needed
    };
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/lib/api/test-integration/pipelineRunnerHelpers.js (Line 1:21 - Line 147:2), C:/AI/food-truck-finder-poc/dist/lib/lib/api/test-integration/pipelineRunnerHelpers.js (Line 1:18 - Line 147:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn85" onclick="toggleCodeBlock('cloneGroup85', 'expandBtn85', 'collapseBtn85')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn85" onclick="toggleCodeBlock('cloneGroup85', 'expandBtn85', 'collapseBtn85')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup85"><code class="language-javascript text-sm text-gray-800">;
// Helper function to handle stage errors and return a consistent error object
function handleStageErrorAndReturn(firecrawlResult, geminiResult, supabaseResult, logs) {
    return {
        firecrawl: firecrawlResult,
        gemini: geminiResult,
        supabase: supabaseResult,
        logs,
        overallStatus: 'Error',
    };
}
// Helper function to process the Firecrawl stage
async function processFirecrawlStage(url, rawText, logs) {
    const firecrawlStageOutput = await handleFirecrawlStage(url ?? '', rawText, logs);
    const { firecrawlResult, contentToProcess, sourceUrlForProcessing } = firecrawlStageOutput;
    if (firecrawlResult.status === 'Error') {
        return undefined;
    }
    return { firecrawlResult, contentToProcess, sourceUrlForProcessing };
}
// Helper function to process the Gemini stage
async function processGeminiStage(contentToProcess, sourceUrlForProcessing, logs) {
    if (contentToProcess === undefined) {
        logs.push('Content to process is undefined before Gemini stage.');
        return undefined;
    }
    const geminiStageOutput = await handleGeminiStage(contentToProcess, sourceUrlForProcessing, logs);
    const { geminiResult, extractedData } = geminiStageOutput;
    if (geminiResult.status === 'Error' || extractedData === undefined) {
        logs.push(`Gemini stage failed or returned no data. Status: ${geminiResult.status}, Data: ${JSON.stringify(extractedData)}`);
        return undefined;
    }
    return { geminiResult, extractedData };
}
// Helper function to process the Supabase stage
async function processSupabaseStage(extractedData, sourceUrlForProcessing, isDryRun, logs) {
    const supabaseResult = await handleSupabaseStage(extractedData, sourceUrlForProcessing, isDryRun, logs);
    if (supabaseResult.status === 'Error') {
        return undefined;
    }
    return supabaseResult;
}
// Helper function to handle the result of the Gemini stage
function handleGeminiStageResult(geminiStage, firecrawlResult, logs) {
    if (geminiStage === undefined) {
        return {
            status: 'Error',
            result: handleStageErrorAndReturn(firecrawlResult, { status: 'Error', error: 'Gemini stage failed' }, undefined, logs),
        };
    }
    const { geminiResult, extractedData } = geminiStage;
    if (extractedData === undefined) {
        return {
            status: 'Error',
            result: handleStageErrorAndReturn(firecrawlResult, geminiResult, { status: 'Error', error: 'Extracted data is undefined after Gemini stage' }, logs),
        };
    }
    return { status: 'Success', geminiResult, extractedData };
}
// Type guard for PipelineRunResult
function isPipelineRunResult(obj) {
    return (typeof obj === 'object' &amp;&amp;
        obj !== null &amp;&amp;
        'overallStatus' in obj &amp;&amp;
        obj.overallStatus === 'Error');
}
// Define Gemini and Supabase stage helpers before runTestPipeline and ensure they are async if needed
async function handleGeminiStagePipeline(contentToProcess, sourceUrlForProcessing, logs, firecrawlResult) {
    const geminiStage = await processGeminiStage(contentToProcess, sourceUrlForProcessing, logs);
    const geminiStageHandled = handleGeminiStageResult(geminiStage, firecrawlResult, logs);
    if (geminiStageHandled.status === 'Error') {
        return geminiStageHandled.result;
    }
    return geminiStageHandled;
}
// Make handleSupabaseStagePipeline async and ensure it is awaited in runTestPipeline
async function handleSupabaseStagePipeline(config) {
    const { extractedData, sourceUrlForProcessing, isDryRun, logs, firecrawlResult, geminiResult } = config;
    const supabaseStage = await processSupabaseStage(extractedData, sourceUrlForProcessing, isDryRun, logs);
    if (supabaseStage === undefined) {
        return handleStageErrorAndReturn(firecrawlResult, geminiResult, { status: 'Error', error: 'Supabase stage failed' }, logs);
    }
    return supabaseStage;
}
// Helper function to handle the Firecrawl stage within the pipeline
async function executeFirecrawlStage(url, rawText, logs) {
    const firecrawlStageOutput = await processFirecrawlStage(url ?? '', rawText, logs);
    if (!firecrawlStageOutput) {
        return handleStageErrorAndReturn({ status: 'Error', error: 'Firecrawl stage failed' }, undefined, undefined, logs);
    }
    return firecrawlStageOutput;
}
// Helper function to handle the Gemini stage within the pipeline
async function executeGeminiStage(contentToProcess, sourceUrlForProcessing, logs, firecrawlResult) {
    const geminiStageHandled = await handleGeminiStagePipeline(contentToProcess, sourceUrlForProcessing, logs, firecrawlResult);
    if ('overallStatus' in geminiStageHandled) {
        return geminiStageHandled;
    }
    return geminiStageHandled;
}
// Helper function to handle the Supabase stage within the pipeline
async function executeSupabaseStage(config) {
    const supabaseStage = await handleSupabaseStagePipeline(config);
    return supabaseStage;
}
// Generic helper to execute a pipeline stage and handle its result
async function executePipelineStage(stageFunction, args) {
    const output = await stageFunction(...args);
    return output;
}
// Extracted helper function for pipeline execution
export async function executePipeline(url, rawText, isDryRun, logs) {
    const firecrawlOutput = await executePipelineStage(executeFirecrawlStage, [
        url ?? '',
        rawText,
        logs,
    ]);
    if (isPipelineRunResult(firecrawlOutput)) {
        return firecrawlOutput;
    }
    const { firecrawlResult, contentToProcess, sourceUrlForProcessing } = firecrawlOutput;
    const geminiResultObject = await executeGeminiStage(contentToProcess, sourceUrlForProcessing, logs, firecrawlResult);
    if (isPipelineRunResult(geminiResultObject)) {
        return geminiResultObject;
    }
    const { geminiResult, extractedData } = geminiResultObject;
    const supabaseOutput = await executePipelineStage(executeSupabaseStage, [
        {
            extractedData,
            sourceUrlForProcessing,
            isDryRun,
            logs,
            firecrawlResult,
            geminiResult,
        },
    ]);
    if (isPipelineRunResult(supabaseOutput)) {
        return supabaseOutput;
    }
    return {
        firecrawl: firecrawlResult,
        gemini: geminiResult,
        supabase: supabaseOutput,
        logs: [...logs, 'Test pipeline run completed successfully.'],
        overallStatus: 'Success',
    };
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/lib/api/test-integration/helpers.js (Line 1:1 - Line 156:2), C:/AI/food-truck-finder-poc/dist/lib/lib/api/test-integration/helpers.js (Line 1:1 - Line 156:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn86" onclick="toggleCodeBlock('cloneGroup86', 'expandBtn86', 'collapseBtn86')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn86" onclick="toggleCodeBlock('cloneGroup86', 'expandBtn86', 'collapseBtn86')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup86"><code class="language-javascript text-sm text-gray-800">import { firecrawl } from '../../firecrawl';
import { gemini } from '../../gemini/geminiApiClient.js';
import { FoodTruckService, ScrapingJobService, DataProcessingService, } from '../../supabase/client.js';
// Helper function to test Firecrawl scraping
export async function testFirecrawlScraping(testUrl) {
    console.info('Testing Firecrawl scraping...');
    const scrapeResult = await firecrawl.scrapeUrl(testUrl, {
        formats: ['markdown'],
        onlyMainContent: true,
    });
    if (!scrapeResult.success) {
        return {
            success: false,
            error: 'Firecrawl test failed',
            details: scrapeResult.error,
        };
    }
    return { success: true, result: scrapeResult };
}
// Helper function to test Gemini processing
export async function testGeminiProcessing() {
    console.info('Testing Gemini processing...');
    const testMenuText = 'Burgers: Classic Burger $12.99, Veggie Burger $11.99. Sides: Fries $4.99, Onion Rings $5.99';
    const geminiResult = await gemini.processMenuData(testMenuText);
    if (!geminiResult.success) {
        return {
            success: false,
            error: 'Gemini test failed',
            details: geminiResult.error,
        };
    }
    return { success: true, result: geminiResult };
}
async function createTestFoodTruck(testUrl, menuData) {
    const result = await FoodTruckService.createTruck({
        name: 'Test Food Truck',
        description: 'Integration test truck',
        current_location: {
            lat: 37.7749,
            lng: -122.4194,
            address: 'San Francisco, CA',
            timestamp: new Date().toISOString(),
        },
        scheduled_locations: [],
        operating_hours: {
            monday: { closed: true },
            tuesday: { closed: true },
            wednesday: { closed: true },
            thursday: { closed: true },
            friday: { closed: true },
            saturday: { closed: true },
            sunday: { closed: true },
        },
        menu: menuData,
        contact_info: { phone: '+1-555-TEST', email: undefined, website: undefined },
        social_media: {
            instagram: undefined,
            facebook: undefined,
            twitter: undefined,
            tiktok: undefined,
            yelp: undefined,
        },
        source_urls: [testUrl],
        data_quality_score: 0.8,
        verification_status: 'pending',
    });
    if ('error' in result) {
        throw new Error(`Failed to create test food truck: ${result.error}`);
    }
    return result;
}
function createTestScrapingJob(testUrl) {
    return ScrapingJobService.createJob({
        job_type: 'integration_test',
        target_url: testUrl,
        priority: 10,
        scheduled_at: new Date().toISOString(),
    });
}
function addTestToProcessingQueue(truckId) {
    return DataProcessingService.addToQueue({
        truck_id: truckId,
        processing_type: 'integration_test',
        raw_data: { test: true },
        priority: 10,
    });
}
// Helper function to test Supabase operations
export async function testSupabaseOperations(testUrl, geminiResult) {
    // Create a test food truck
    const testTruck = await createTestFoodTruck(testUrl, geminiResult.data ?? []);
    // Create a test scraping job
    const testJob = await createTestScrapingJob(testUrl);
    // Add to processing queue
    const queueItem = await addTestToProcessingQueue(testTruck.id);
    // Test geospatial query
    const nearbyTrucksResult = await FoodTruckService.getTrucksByLocation(37.7749, -122.4194, 10);
    if ('error' in nearbyTrucksResult) {
        throw new Error(`Failed to get nearby trucks: ${nearbyTrucksResult.error}`);
    }
    const nearbyTrucks = nearbyTrucksResult;
    return {
        testTruck,
        testJob,
        queueItem,
        nearbyTrucks,
    };
}
// Helper function to format test results
export function formatTestResults(scrapeResult, geminiResult, supabaseResults) {
    return {
        success: true,
        message: 'Integration test completed successfully',
        results: {
            firecrawl: {
                success: scrapeResult.result?.success ?? false,
                dataLength: scrapeResult.result?.data?.markdown?.length ?? 0,
            },
            gemini: {
                success: geminiResult.success,
                tokensUsed: geminiResult.tokensUsed,
                categoriesFound: geminiResult.data?.length ?? 0,
            },
            supabase: {
                truckCreated: supabaseResults.testTruck.id,
                jobCreated: supabaseResults.testJob.id,
                queueItemCreated: supabaseResults.queueItem.id,
                nearbyTrucksFound: supabaseResults.nearbyTrucks.length,
            },
        },
        testData: {
            truck: supabaseResults.testTruck,
            processedMenu: geminiResult.data,
            nearbyTrucks: supabaseResults.nearbyTrucks.slice(0, 3),
        },
    };
}
export async function runIntegrationTestSteps(testUrl) {
    console.info('Starting integration test...');
    // Step 1: Test Firecrawl scraping
    const firecrawlTest = await testFirecrawlScraping(testUrl);
    if (!firecrawlTest.success) {
        return firecrawlTest;
    }
    // Step 2: Test Gemini processing
    const geminiTest = await testGeminiProcessing();
    if (!geminiTest.success) {
        return geminiTest;
    }
    // Step 3: Test Supabase operations
    console.info('Testing Supabase operations...');
    const supabaseResults = await testSupabaseOperations(testUrl, geminiTest.result);
    // Step 4: Format and return results
    const results = formatTestResults(firecrawlTest, geminiTest.result, supabaseResults);
    return { success: true, results };
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/lib/api/tavily/handlers.js (Line 1:1 - Line 115:2), C:/AI/food-truck-finder-poc/dist/lib/lib/api/tavily/handlers.js (Line 1:1 - Line 115:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn88" onclick="toggleCodeBlock('cloneGroup88', 'expandBtn88', 'collapseBtn88')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn88" onclick="toggleCodeBlock('cloneGroup88', 'expandBtn88', 'collapseBtn88')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup88"><code class="language-javascript text-sm text-gray-800">/**
 * Sends a search query to the Tavily API and retrieves results.
 * @example
 * callTavilySearchApi('your_api_key', { query: 'example search', limit: 5 })
 * Returns an object containing a list of search results including titles and URLs.
 * @param {string} apiKey - The API key used for authorization with the Tavily API.
 * @param {Record&lt;string, unknown&gt;} params - An object containing search parameters such as the query and limits.
 * @returns {Object} An object containing search results with titles, URLs, and content.
 * @description
 *   - Uses fetch API to send a POST request to Tavily's search endpoint.
 *   - Automatically includes relevant headers for JSON content type and authorization.
 *   - Provides default values for certain parameters (e.g., max_results and search_depth).
 *   - Maps and structures the results before returning them to ensure consistency in the returned format.
 */
async function callTavilySearchApi(apiKey, params) {
    const response = await fetch('https://api.tavily.com/search', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            Authorization: `Bearer ${apiKey}`,
        },
        body: JSON.stringify({
            query: params.query ?? params.q,
            max_results: params.limit ?? 10,
            search_depth: params.search_depth ?? 'advanced',
            include_answer: true,
            include_raw_content: true,
        }),
    });
    if (!response.ok) {
        const errorText = await response.text();
        console.error('Tavily API error response:', errorText);
        throw new Error(`Tavily API error: ${response.status} ${response.statusText} - ${errorText}`);
    }
    const data = (await response.json());
    return {
        results: data.results?.map((result) =&gt; ({
            title: result.title,
            url: result.url,
            content: result.content,
            raw_content: result.raw_content,
        })) ?? [],
    };
}
/**
 * Performs a search operation using Tavily API or returns mock data if API key is unavailable.
 * @example
 * performTavilySearch({ location: 'South Carolina', query: 'food trucks' })
 * { results: [{ title: 'South Carolina Food Trucks (Mock)', url: 'https://example-foodtruck1.com', ... }] }
 * @param {Record&lt;string, unknown&gt;} params - Parameters for the Tavily API search.
 * @returns {Promise&lt;any&gt;} The search results from the Tavily API or mock data.
 * @description
 *   - Utilizes the TAVILY_API_KEY from environment variables to make API requests.
 *   - Returns mock data if the API key is missing or empty.
 *   - Logs a warning if mock data is being used due to missing API key.
 *   - Throws an error if the Tavily API call fails.
 */
export async function performTavilySearch(params) {
    const apiKey = process.env.TAVILY_API_KEY;
    if (apiKey === undefined || apiKey === '') {
        console.warn('TAVILY_API_KEY not found, using mock data');
        return {
            results: [
                {
                    title: 'South Carolina Food Trucks (Mock)',
                    url: 'https://example-foodtruck1.com',
                    content: 'Check out the best food trucks in South Carolina. Visit https://carolinabbq.com for amazing BBQ on wheels.',
                    raw_content: 'Carolina BBQ Food Truck serves authentic South Carolina barbecue...',
                },
                {
                    title: 'Charleston Mobile Food Directory (Mock)',
                    url: 'https://example-directory.com',
                    content: 'Directory of Charleston area food trucks including https://charlestontacos.com and https://lowcountryeats.com',
                    raw_content: 'Complete listing of mobile food vendors in the Charleston area...',
                },
            ],
        };
    }
    try {
        return await callTavilySearchApi(apiKey, params);
    }
    catch (error) {
        console.error('Tavily API call failed:', error);
        throw error;
    }
}
/**
* Performs a mock Tavily crawl operation.
* @example
* performTavilyCrawl({ key: 'value' })
* { results: [ { url: 'https://example-crawled-truck.com', title: 'Gourmet Food Truck', content: 'Premium mobile dining experience...' } ] }
* @param {Record&lt;string, unknown&gt;} params - Parameters for the mock crawl operation.
* @returns {Object} An object containing mock crawl results.
* @description
*   - Utilizes a mock implementation for demonstration purposes.
*   - Logs the crawling parameters to the console for debugging.
*/
export function performTavilyCrawl(params) {
    console.info('Mock Tavily crawl with params:', params);
    return {
        results: [
            {
                url: 'https://example-crawled-truck.com',
                title: 'Gourmet Food Truck',
                content: 'Premium mobile dining experience...',
            },
        ],
    };
}
export function performTavilyMap(params) {
    console.info('Mock Tavily map with params:', params);
    return {
        results: ['https://foodtruckdirectory.com/truck1', 'https://foodtruckdirectory.com/truck2'],
    };
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/lib/api/search/helpers.js (Line 10:5 - Line 30:2), C:/AI/food-truck-finder-poc/dist/lib/lib/api/search/helpers.js (Line 17:5 - Line 37:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn90" onclick="toggleCodeBlock('cloneGroup90', 'expandBtn90', 'collapseBtn90')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn90" onclick="toggleCodeBlock('cloneGroup90', 'expandBtn90', 'collapseBtn90')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup90"><code class="language-javascript text-sm text-gray-800">let trucks = await getAndFilterFoodTrucks(lat, lng, radius);
    // Apply filters
    trucks = applyTextSearchFilter(trucks, query);
    trucks = applyCuisineFilter(trucks, cuisine);
    trucks = applyOpenNowFilter(trucks, openNow);
    // Sort by data quality score
    const filteredAndSortedTrucks = sortFoodTrucksByQuality(trucks);
    return NextResponse.json({
        trucks: filteredAndSortedTrucks,
        total: filteredAndSortedTrucks.length,
        filters: {
            query,
            cuisine,
            openNow,
            location: lat != undefined &amp;&amp; lng != undefined
                ? { lat: Number.parseFloat(lat), lng: Number.parseFloat(lng) }
                : undefined,
            radius: Number.parseFloat(radius ?? '10'),
        },
    });
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/lib/api/search/filters.js (Line 1:1 - Line 67:2), C:/AI/food-truck-finder-poc/dist/lib/lib/api/search/filters.js (Line 1:1 - Line 67:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn92" onclick="toggleCodeBlock('cloneGroup92', 'expandBtn92', 'collapseBtn92')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn92" onclick="toggleCodeBlock('cloneGroup92', 'expandBtn92', 'collapseBtn92')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup92"><code class="language-javascript text-sm text-gray-800">/**
* Filters an array of FoodTruck objects based on a given search query.
* @example
* applyTextSearchFilter(foodTrucksArray, 'taco')
* // Returns an array of FoodTruck objects where the truck name, description, or menu contains 'taco'
* @param {FoodTruck[]} trucks - An array of FoodTruck objects to be filtered.
* @param {string | null} query - Search query to filter the food trucks by.
* @returns {FoodTruck[]} An array of FoodTruck objects that match the search query.
* @description
*   - If the query is null or an empty string, the original array is returned unfiltered.
*   - The search is case-insensitive.
*   - Searches through truck names, descriptions, and menu item names and descriptions.
*   - Utilizes optional chaining to handle undefined or null values in truck descriptions and menus.
*/
export function applyTextSearchFilter(trucks, query) {
    if (query != undefined &amp;&amp; query !== '') {
        return trucks.filter((truck) =&gt; truck.name.toLowerCase().includes(query.toLowerCase()) ||
            (truck.description?.toLowerCase().includes(query.toLowerCase()) ?? false) ||
            (truck.menu?.some((category) =&gt; category.items?.some((item) =&gt; item.name.toLowerCase().includes(query.toLowerCase()) ||
                (item.description?.toLowerCase().includes(query.toLowerCase()) ?? false))) ??
                false));
    }
    return trucks;
}
export function applyCuisineFilter(trucks, cuisine) {
    if (cuisine != undefined &amp;&amp; cuisine !== '') {
        return trucks.filter((truck) =&gt; truck.menu?.some((category) =&gt; category.name.toLowerCase().includes(cuisine.toLowerCase())));
    }
    return trucks;
}
/**
 * Filters a list of food trucks to only include those that are currently open.
 * @example
 * applyOpenNowFilter(trucks, true)
 * // returns list of trucks open at the current date and time
 * @param {FoodTruck[]} trucks - Array of food truck objects to be filtered.
 * @param {boolean} openNow - Flag to filter trucks that are open at the current time.
 * @returns {FoodTruck[]} Array of food trucks that are open now, or the unfiltered array if openNow is false.
 * @description
 *   - Uses the system's current date and time to determine if trucks are open.
 *   - Filters based on the truck's operating hours for the current day.
 */
export function applyOpenNowFilter(trucks, openNow) {
    if (openNow) {
        const now = new Date();
        const daysOfWeek = [
            'sunday',
            'monday',
            'tuesday',
            'wednesday',
            'thursday',
            'friday',
            'saturday',
        ];
        const currentDay = daysOfWeek[now.getDay()];
        const currentTime = now.getHours() * 100 + now.getMinutes();
        return trucks.filter((truck) =&gt; {
            const hours = truck.operating_hours?.[currentDay];
            if (!hours || hours.closed)
                return false;
            const openTime = Number.parseInt(hours.open.replace(':', ''), 10);
            const closeTime = Number.parseInt(hours.close.replace(':', ''), 10);
            return currentTime &gt;= openTime &amp;&amp; currentTime &lt;= closeTime;
        });
    }
    return trucks;
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/lib/api/search/data.js (Line 1:1 - Line 32:2), C:/AI/food-truck-finder-poc/dist/lib/lib/api/search/data.js (Line 1:1 - Line 32:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn94" onclick="toggleCodeBlock('cloneGroup94', 'expandBtn94', 'collapseBtn94')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn94" onclick="toggleCodeBlock('cloneGroup94', 'expandBtn94', 'collapseBtn94')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup94"><code class="language-javascript text-sm text-gray-800">import { CachedFoodTruckService } from '../../performance/databaseCache.js';
/**
* Retrieves and filters food trucks based on specified location and radius.
* @example
* getAndFilterFoodTrucks(&quot;37.7749&quot;, &quot;-122.4194&quot;, &quot;5&quot;)
* [FoodTruck, FoodTruck, FoodTruck]
* @param {string | null} lat - Latitude of the user's location.
* @param {string | null} lng - Longitude of the user's location.
* @param {string | null} radius - Search radius in kilometers.
* @returns {Promise&lt;FoodTruck[]&gt;} List of food trucks within the specified location and radius.
* @description
*   - Parses latitude, longitude, and radius from strings to floats for calculations.
*   - If latitude or longitude are not provided, fetches all cached food trucks.
*   - Defaults radius to 10 kilometers if not provided.
*/
export async function getAndFilterFoodTrucks(lat, lng, radius) {
    let trucks = [];
    if (lat != undefined &amp;&amp; lng != undefined) {
        const userLat = Number.parseFloat(lat);
        const userLng = Number.parseFloat(lng);
        const radiusKm = Number.parseFloat(radius ?? '10');
        trucks = await CachedFoodTruckService.getTrucksByLocationCached(userLat, userLng, radiusKm);
    }
    else {
        const result = await CachedFoodTruckService.getAllTrucksCached();
        trucks = result.trucks;
    }
    return trucks;
}
export function sortFoodTrucksByQuality(trucks) {
    return [...trucks].sort((a, b) =&gt; (b.data_quality_score ?? 0) - (a.data_quality_score ?? 0));
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/lib/api/scheduler/handlers.js (Line 2:12 - Line 211:2), C:/AI/food-truck-finder-poc/dist/lib/lib/api/scheduler/handlers.js (Line 2:9 - Line 211:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn97" onclick="toggleCodeBlock('cloneGroup97', 'expandBtn97', 'collapseBtn97')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn97" onclick="toggleCodeBlock('cloneGroup97', 'expandBtn97', 'collapseBtn97')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup97"><code class="language-javascript text-sm text-gray-800">;
/**
 * Retrieves the current status and summary information of scheduler tasks.
 * @example
 * handleSchedulerStatus()
 * {
 *   isRunning: true,
 *   tasks: [...],
 *   summary: {
 *     totalTasks: 5,
 *     enabledTasks: 3,
 *     runningTasks: 2,
 *     totalSuccesses: 12,
 *     totalErrors: 3
 *   }
 * }
 * @returns {Object} An object containing the runtime status and a summary of the scheduler tasks.
 * @description
 *   - Determines if the scheduler is currently running based on the presence of `schedulerInstance`.
 *   - Provides a detailed summary of the tasks, including counts of total, enabled, and running tasks.
 *   - Accumulates total successes and errors from all scheduler tasks for comprehensive reporting.
 */
export function handleSchedulerStatus() {
    return NextResponse.json({
        isRunning: schedulerInstance != undefined,
        tasks: schedulerTasks,
        summary: {
            totalTasks: schedulerTasks.length,
            enabledTasks: schedulerTasks.filter((t) =&gt; t.enabled).length,
            runningTasks: schedulerTasks.filter((t) =&gt; t.enabled &amp;&amp; t.nextRun != undefined).length,
            totalSuccesses: schedulerTasks.reduce((acc, t) =&gt; acc + t.successCount, 0),
            totalErrors: schedulerTasks.reduce((acc, t) =&gt; acc + t.errorCount, 0),
        },
    });
}
/**
* Generates a JSON response containing a list of scheduler logs
* @example
* handleSchedulerLogs()
* { logs: [...] }
* @returns {Object} A JSON object containing an array of log entries with details.
* @description
*   - Each log entry includes a timestamp, task identifier, log level, and a message.
*   - The log levels include 'info', 'error', and 'warning'.
*   - Log timestamps are derived from the current time and adjusted to simulate real-time delays.
*   - Provides insight into scheduler task execution and any issues encountered.
*/
export function handleSchedulerLogs() {
    return NextResponse.json({
        logs: [
            {
                timestamp: new Date(Date.now() - 300_000).toISOString(),
                taskId: 'location_update',
                level: 'info',
                message: 'Successfully updated locations for 12 food trucks',
            },
            {
                timestamp: new Date(Date.now() - 900_000).toISOString(),
                taskId: 'instagram_scrape',
                level: 'info',
                message: 'Scraped 3 Instagram accounts, found 8 new posts',
            },
            {
                timestamp: new Date(Date.now() - 1_800_000).toISOString(),
                taskId: 'gemini_processing',
                level: 'error',
                message: 'Rate limit exceeded, skipping AI processing',
            },
            {
                timestamp: new Date(Date.now() - 3_600_000).toISOString(),
                taskId: 'website_crawl',
                level: 'warning',
                message: 'Failed to crawl tacoparadise.com - site temporarily unavailable',
            },
        ],
    });
}
export function handleSchedulerDefault() {
    return NextResponse.json({
        message: 'Task Scheduler API',
        endpoints: [
            'GET /api/scheduler?action=status - Get scheduler status',
            'GET /api/scheduler?action=logs - Get execution logs',
            'POST /api/scheduler - Start/stop scheduler or execute task',
            'PUT /api/scheduler - Update task configuration',
        ],
    });
}
/**
* Initializes the scheduler if it's not already running
* @example
* handleStartScheduler()
* { &quot;message&quot;: &quot;Scheduler started successfully&quot;, &quot;status&quot;: &quot;running&quot; }
* @param {none}
* @returns {NextResponse} Returns a JSON response indicating the status of the scheduler.
* @description
*   - Checks if a scheduler instance already exists before proceeding.
*   - Sets the current time as the start time for the new scheduler instance.
*   - Returns a 409 status code if the scheduler is already running.
*/
export function handleStartScheduler() {
    if (schedulerInstance) {
        return NextResponse.json({ error: 'Scheduler is already running' }, { status: 409 });
    }
    setSchedulerInstance({ started: new Date().toISOString() });
    return NextResponse.json({
        message: 'Scheduler started successfully',
        status: 'running',
    });
}
/**
* Stops the scheduler if it is currently running and returns a status message.
* @example
* handleStopScheduler()
* { message: 'Scheduler stopped successfully', status: 'stopped' }
* @param {undefined} schedulerInstance - Represents the current instance of the scheduler.
* @returns {Object} JSON response object containing a message and a status of the operation.
* @description
*   - Returns an error message if the scheduler is not running.
*   - Sets the scheduler instance to undefined to signify it has been stopped.
*/
export function handleStopScheduler() {
    if (!schedulerInstance) {
        return NextResponse.json({ error: 'Scheduler is not running' }, { status: 409 });
    }
    setSchedulerInstance(undefined);
    return NextResponse.json({
        message: 'Scheduler stopped successfully',
        status: 'stopped',
    });
}
/**
 * Executes a task by its ID and returns the execution result.
 * @example
 * handleExecuteTask('12345')
 * { message: 'Task 12345 executed', task: { ... } }
 * @param {string} taskId - Unique identifier of the task to be executed.
 * @returns {NextResponse} JSON response containing the execution result and task details.
 * @description
 *   - If the task ID is undefined or an empty string, returns a 400 JSON error response.
 *   - Finds the task associated with the given ID; returns a 404 JSON error if not found.
 *   - Task execution includes simulating success or failure. Math.random is used for simulation.
 *   - Updates task properties like lastRun, lastSuccess, successCount, errorCount based on execution result.
 */
export function handleExecuteTask(taskId) {
    if (taskId == undefined || taskId === '') {
        return NextResponse.json({ error: 'Task ID is required for execution' }, { status: 400 });
    }
    const task = schedulerTasks.find((t) =&gt; t.id === taskId);
    if (!task) {
        return NextResponse.json({ error: 'Task not found' }, { status: 404 });
    }
    // Simulate task execution
    task.lastRun = new Date().toISOString();
    // Simulate success/failure
    // eslint-disable-next-line sonarjs/pseudo-random -- Math.random is acceptable for simulating task execution.
    if (Math.random() &gt; 0.1) {
        // 90% success rate
        task.lastSuccess = task.lastRun;
        task.successCount += 1;
        task.lastError = undefined;
    }
    else {
        task.errorCount += 1;
        task.lastError = 'Simulated execution error';
    }
    return NextResponse.json({
        message: `Task ${taskId} executed`,
        task: task,
    });
}
/**
 * Handles the update of a task configuration by modifying schedulerTasks.
 * @example
 * handleUpdateTask({ taskId: '123', config: { intervalMinutes: 10 } })
 * { message: 'Task configuration updated', task: { ...updatedTaskDetails } }
 * @param {PutRequestBody} body - Contains taskId and config object for updating task.
 * @returns {NextResponse} JSON response with status indicating the result of the operation.
 * @description
 *   - Checks for required taskId and existence of the task within schedulerTasks.
 *   - Modifies the task configuration using provided config object.
 *   - Updates nextRun time if intervalMinutes is specified and task is enabled.
 */
export function handleUpdateTask(body) {
    const { taskId, config } = body;
    if (!taskId) {
        return NextResponse.json({ error: 'Task ID is required' }, { status: 400 });
    }
    const taskIndex = schedulerTasks.findIndex((t) =&gt; t.id === taskId);
    if (taskIndex === -1) {
        return NextResponse.json({ error: 'Task not found' }, { status: 404 });
    }
    // Update task configuration
    schedulerTasks[taskIndex] = {
        ...schedulerTasks[taskIndex],
        ...config,
    };
    // Update next run time if interval changed
    if (config.intervalMinutes != undefined &amp;&amp;
        config.intervalMinutes &gt; 0 &amp;&amp;
        schedulerTasks[taskIndex].enabled) {
        const lastRun = new Date(schedulerTasks[taskIndex].lastRun ?? Date.now());
        const nextRun = new Date(lastRun.getTime() + config.intervalMinutes * 60 * 1000);
        schedulerTasks[taskIndex].nextRun = nextRun.toISOString();
    }
    return NextResponse.json({
        message: 'Task configuration updated',
        task: schedulerTasks[taskIndex],
    });
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/lib/api/scheduler/data.js (Line 1:1 - Line 62:2), C:/AI/food-truck-finder-poc/dist/lib/lib/api/scheduler/data.js (Line 1:1 - Line 62:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn99" onclick="toggleCodeBlock('cloneGroup99', 'expandBtn99', 'collapseBtn99')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn99" onclick="toggleCodeBlock('cloneGroup99', 'expandBtn99', 'collapseBtn99')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup99"><code class="language-javascript text-sm text-gray-800">export let schedulerInstance;
export const schedulerTasks = [
    {
        id: 'instagram_scrape',
        name: 'Instagram Data Scraping',
        enabled: true,
        intervalMinutes: 120,
        lastRun: new Date(Date.now() - 1_800_000).toISOString(),
        lastSuccess: new Date(Date.now() - 1_800_000).toISOString(),
        successCount: 45,
        errorCount: 3,
        nextRun: new Date(Date.now() + 5_400_000).toISOString(),
    },
    {
        id: 'website_crawl',
        name: 'Website Crawling',
        enabled: true,
        intervalMinutes: 360,
        lastRun: new Date(Date.now() - 7_200_000).toISOString(),
        lastSuccess: new Date(Date.now() - 7_200_000).toISOString(),
        successCount: 23,
        errorCount: 1,
        nextRun: new Date(Date.now() + 14_400_000).toISOString(),
    },
    {
        id: 'data_quality_check',
        name: 'Data Quality Assessment',
        enabled: true,
        intervalMinutes: 720,
        lastRun: new Date(Date.now() - 21_600_000).toISOString(),
        lastSuccess: new Date(Date.now() - 21_600_000).toISOString(),
        successCount: 12,
        errorCount: 0,
        nextRun: new Date(Date.now() + 21_600_000).toISOString(),
    },
    {
        id: 'gemini_processing',
        name: 'AI Data Processing',
        enabled: false,
        intervalMinutes: 480,
        lastRun: new Date(Date.now() - 28_800_000).toISOString(),
        lastSuccess: new Date(Date.now() - 28_800_000).toISOString(),
        successCount: 8,
        errorCount: 2,
        lastError: 'Rate limit exceeded',
        nextRun: undefined,
    },
    {
        id: 'location_update',
        name: 'Real-time Location Updates',
        enabled: true,
        intervalMinutes: 30,
        lastRun: new Date(Date.now() - 900_000).toISOString(),
        lastSuccess: new Date(Date.now() - 900_000).toISOString(),
        successCount: 156,
        errorCount: 8,
        nextRun: new Date(Date.now() + 900_000).toISOString(),
    },
];
export function setSchedulerInstance(instance) {
    schedulerInstance = instance;
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/lib/api/pipeline/handlers.js (Line 2:17 - Line 41:2), C:/AI/food-truck-finder-poc/dist/lib/lib/api/pipeline/handlers.js (Line 2:27 - Line 41:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn101" onclick="toggleCodeBlock('cloneGroup101', 'expandBtn101', 'collapseBtn101')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn101" onclick="toggleCodeBlock('cloneGroup101', 'expandBtn101', 'collapseBtn101')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup101"><code class="language-javascript text-sm text-gray-800">;
/**
 * Handles a legacy scraping request and creates a scraping job.
 * @example
 * handleLegacyScrapingRequest({ target_url: 'https://example.com', job_type: 'website_scrape', priority: 2 })
 * { message: 'Scraping job created (legacy mode)', job_id: '123', target_url: 'https://example.com', note: 'Consider using the new unified pipeline API with action parameter' }
 * @param {PipelineRequestBody} body - The request body containing scraping job details.
 * @returns {NextResponse} Response indicating the outcome of creating the scraping job.
 * @description
 *   - Validates the `target_url` and returns errors for missing or invalid URLs.
 *   - Defaults `job_type` to 'website_scrape' and `priority` to 1 if not provided.
 *   - Includes a suggestion note about using the new unified pipeline API.
 */
export async function handleLegacyScrapingRequest(body) {
    const { target_url, job_type = 'website_scrape', priority = 1 } = body;
    if (target_url == undefined || target_url === '') {
        return NextResponse.json({ error: 'target_url is required' }, { status: 400 });
    }
    try {
        new URL(target_url);
    }
    catch {
        return NextResponse.json({ error: 'Invalid target_url format' }, { status: 400 });
    }
    const job = await ScrapingJobService.createJob({
        target_url,
        job_type,
        priority,
        scheduled_at: new Date().toISOString(),
    });
    if (job == undefined) {
        return NextResponse.json({ error: 'Failed to create scraping job' }, { status: 500 });
    }
    return NextResponse.json({
        message: 'Scraping job created (legacy mode)',
        job_id: job.id,
        target_url,
        note: 'Consider using the new unified pipeline API with action parameter',
    });
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/lib/api/firecrawl/handlers.js (Line 1:1 - Line 110:2), C:/AI/food-truck-finder-poc/dist/lib/lib/api/firecrawl/handlers.js (Line 1:1 - Line 110:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn102" onclick="toggleCodeBlock('cloneGroup102', 'expandBtn102', 'collapseBtn102')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn102" onclick="toggleCodeBlock('cloneGroup102', 'expandBtn102', 'collapseBtn102')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup102"><code class="language-javascript text-sm text-gray-800">import { NextResponse } from 'next/server';
import { firecrawl } from '../../firecrawl';
// Helper function to handle scrape operation
/**
 * Executes a web scraping operation on the specified URL.
 * @example
 * handleScrapeOperation('https://example.com', { headers: {'User-Agent': 'Mozilla/5.0'} })
 * { success: true, data: [ &lt;scrapedContent&gt; ], error: null }
 * @param {string} url - The URL to be scraped.
 * @param {Record&lt;string, unknown&gt;} options - Additional configurations for the scraping operation.
 * @returns {object} An object containing the success status, scraped data if successful, and any error encountered.
 * @description
 *   - Utilizes 'firecrawl' library to perform the scraping.
 *   - The scrape operation targets the main content of the page only.
 *   - The resulting data is returned in both 'markdown' and 'html' formats.
 */
export async function handleScrapeOperation(url, options) {
    const scrapeResult = await firecrawl.scrapeUrl(url, {
        formats: ['markdown', 'html'],
        onlyMainContent: true,
        ...options,
    });
    return NextResponse.json({
        success: scrapeResult.success,
        data: scrapeResult.success ? [scrapeResult.data] : undefined,
        error: scrapeResult.error,
    });
}
// Helper function to poll crawl status
/**
* Polls the crawl status of a given job ID until the job is completed or a maximum number of attempts is reached.
* @example
* pollCrawlStatus('12345xyz')
* NextResponse { success: true, data: {...} }
* @param {string} jobId - The unique identifier for the crawl job.
* @returns {Promise&lt;NextResponse&gt;} A JSON response indicating the result of the crawl job: completed, failed, or timed out.
* @description
*   - Uses a polling mechanism with a fixed interval to check the job status repeatedly.
*   - Handles completed and failed job statuses with different JSON responses.
*   - Implemented timeout after 30 attempts to prevent indefinite polling.
*   - Provides appropriate HTTP status codes for each response scenario.
*/
export async function pollCrawlStatus(jobId) {
    let attempts = 0;
    const maxAttempts = 30; // 5 minutes max
    const pollInterval = 10_000; // 10 seconds
    while (attempts &lt; maxAttempts) {
        await new Promise((resolve) =&gt; { setTimeout(resolve, pollInterval); });
        const status = await firecrawl.getCrawlStatus(jobId);
        if (status.success &amp;&amp; status.status === 'completed' &amp;&amp; status.data) {
            return NextResponse.json({
                success: true,
                data: status.data,
            });
        }
        else if (status.success &amp;&amp; status.status === 'failed') {
            return NextResponse.json({
                success: false,
                error: 'Crawl job failed',
            }, { status: 500 });
        }
        attempts += 1;
    }
    // Timeout
    return NextResponse.json({
        success: false,
        error: 'Crawl job timed out',
    }, { status: 408 });
}
// Helper function to handle crawl operation
/**
* Initiates and handles the web crawling operation with specified options.
* @example
* handleCrawlOperation('http://example.com', { maxDepth: 3, limit: 50 })
* Returns the status of the crawl job operation.
* @param {string} url - The URL of the website to be crawled.
* @param {Record&lt;string, unknown&gt;} options - Options to configure the crawling operation including maxDepth, limit, includes, and excludes.
* @returns {Promise&lt;Object&gt;} A JSON response object containing the success status and error message, or initiates the crawl status polling.
* @description
*   - Uses `firecrawl` library to start a web crawling job with specific configurations.
*   - Handles crawl job initiation success and failure scenarios.
*   - Returns a JSON response on failure with error details.
*/
export async function handleCrawlOperation(url, options) {
    const crawlJob = await firecrawl.crawlWebsite(url, {
        crawlerOptions: {
            maxDepth: options.maxDepth || 2,
            limit: options.limit || 20,
            includes: options.includes,
            excludes: options.excludes,
        },
        pageOptions: {
            formats: ['markdown'],
            onlyMainContent: true,
        },
    });
    if (!crawlJob.success || crawlJob.jobId == undefined) {
        return NextResponse.json({
            success: false,
            error: crawlJob.error ?? 'Failed to start crawl job',
        }, { status: 500 });
    }
    return pollCrawlStatus(crawlJob.jobId);
}
export function handleSearchOperation() {
    return NextResponse.json({
        success: false,
        error: 'Search operation not directly supported by Firecrawl API. Use crawl on directory URLs instead.',
    }, { status: 400 });
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/app/api/trucks/route.js (Line 60:2 - Line 67:2), C:/AI/food-truck-finder-poc/dist/lib/lib/schemas/truck.js (Line 73:2 - Line 80:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn108" onclick="toggleCodeBlock('cloneGroup108', 'expandBtn108', 'collapseBtn108')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn108" onclick="toggleCodeBlock('cloneGroup108', 'expandBtn108', 'collapseBtn108')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup108"><code class="language-javascript text-sm text-gray-800">z.object({
        address: z.string().optional(),
        city: z.string().optional(),
        state: z.string().optional(),
        zip_code: z.string().optional(),
        lat: z.number().optional(),
        lng: z.number().optional(),
        timestamp: z.string().</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/app/api/trucks/route.js (Line 105:2 - Line 113:2), C:/AI/food-truck-finder-poc/dist/lib/lib/api/test-integration/helpers.js (Line 45:2 - Line 53:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn109" onclick="toggleCodeBlock('cloneGroup109', 'expandBtn109', 'collapseBtn109')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn109" onclick="toggleCodeBlock('cloneGroup109', 'expandBtn109', 'collapseBtn109')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup109"><code class="language-javascript text-sm text-gray-800">{
        monday: { closed: true },
        tuesday: { closed: true },
        wednesday: { closed: true },
        thursday: { closed: true },
        friday: { closed: true },
        saturday: { closed: true },
        sunday: { closed: true },
    })</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/app/api/trucks/route.js (Line 122:2 - Line 130:2), C:/AI/food-truck-finder-poc/dist/lib/lib/schemas/truck.js (Line 65:2 - Line 71:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn110" onclick="toggleCodeBlock('cloneGroup110', 'expandBtn110', 'collapseBtn110')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn110" onclick="toggleCodeBlock('cloneGroup110', 'expandBtn110', 'collapseBtn110')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup110"><code class="language-javascript text-sm text-gray-800">z
        .object({
        instagram: z.string().optional(),
        facebook: z.string().optional(),
        twitter: z.string().optional(),
        tiktok: z.string().optional(),
        yelp: z.string().optional(),
    })
        .</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/app/api/trucks/route.js (Line 147:2 - Line 152:2), C:/AI/food-truck-finder-poc/dist/lib/lib/utils/apiHelpers.js (Line 5:2 - Line 10:7)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn111" onclick="toggleCodeBlock('cloneGroup111', 'expandBtn111', 'collapseBtn111')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn111" onclick="toggleCodeBlock('cloneGroup111', 'expandBtn111', 'collapseBtn111')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup111"><code class="language-javascript text-sm text-gray-800">ZodError) {
            return NextResponse.json({ error: error.errors }, { status: 400 });
        }
        return NextResponse.json({ error: error instanceof Error ? error.message : String(error) }, { status: 500 });
    }
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/app/api/trucks/route.js (Line 161:29 - Line 167:2), C:/AI/food-truck-finder-poc/dist/app/api/trucks/route.js (Line 146:29 - Line 10:7)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn112" onclick="toggleCodeBlock('cloneGroup112', 'expandBtn112', 'collapseBtn112')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn112" onclick="toggleCodeBlock('cloneGroup112', 'expandBtn112', 'collapseBtn112')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup112"><code class="language-javascript text-sm text-gray-800">, error);
        if (error instanceof z.ZodError) {
            return NextResponse.json({ error: error.errors }, { status: 400 });
        }
        return NextResponse.json({ error: error instanceof Error ? error.message : String(error) }, { status: 500 });
    }
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/app/api/process-jobs/route.js (Line 10:9 - Line 15:6), C:/AI/food-truck-finder-poc/dist/lib/lib/api/cron/auto-scrape/improvedHandler.js (Line 16:9 - Line 21:12)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn113" onclick="toggleCodeBlock('cloneGroup113', 'expandBtn113', 'collapseBtn113')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn113" onclick="toggleCodeBlock('cloneGroup113', 'expandBtn113', 'collapseBtn113')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup113"><code class="language-javascript text-sm text-gray-800">const authHeader = request.headers.get('authorization');
        const cronSecret = process.env.CRON_SECRET;
        if (!cronSecret || authHeader !== `Bearer ${cronSecret}`) {
            return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
        }
        const</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/app/api/autonomous-discovery/route.js (Line 17:47 - Line 33:2), C:/AI/food-truck-finder-poc/dist/app/api/enhanced-pipeline/route.js (Line 17:62 - Line 33:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn114" onclick="toggleCodeBlock('cloneGroup114', 'expandBtn114', 'collapseBtn114')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn114" onclick="toggleCodeBlock('cloneGroup114', 'expandBtn114', 'collapseBtn114')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup114"><code class="language-javascript text-sm text-gray-800">,
            },
        },
    }, { status: 410 }); // 410 Gone - Resource no longer available
}
export function GET() {
    return NextResponse.json({
        status: 'DEPRECATED',
        message: 'This endpoint has been consolidated into /api/pipeline',
        migration: {
            newEndpoint: '/api/pipeline',
            documentation: 'See /api/pipeline for current API documentation',
            deprecationDate: '2024-12-09',
            removalDate: '2025-01-01',
        },
    }, { status: 410 });
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/app/admin/food-trucks/page.jsx (Line 76:8 - Line 146:2), C:/AI/food-truck-finder-poc/dist/lib/app/admin/food-trucks/page.jsx (Line 75:8 - Line 145:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn115" onclick="toggleCodeBlock('cloneGroup115', 'expandBtn115', 'collapseBtn115')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn115" onclick="toggleCodeBlock('cloneGroup115', 'expandBtn115', 'collapseBtn115')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup115"><code class="language-javascript text-sm text-gray-800">={truck.verification_status === 'verified' ? 'default' : 'outline'}&gt;
          {truck.verification_status}
        &lt;/Badge&gt;
      &lt;/TableCell&gt;
      &lt;TableCell&gt;
        &lt;div className=&quot;flex items-center gap-2&quot;&gt;
          &lt;span&gt;{(qualityScore * 100).toFixed(0)}%&lt;/span&gt;
          &lt;Badge variant={getQualityScoreVariant(qualityScore)} className=&quot;text-xs&quot;&gt;
            {getQualityScoreLabel(qualityScore)}
          &lt;/Badge&gt;
        &lt;/div&gt;
      &lt;/TableCell&gt;
      &lt;TableCell&gt;
        {truck.last_scraped_at == undefined
            ? 'N/A'
            : new Date(truck.last_scraped_at).toLocaleDateString()}
      &lt;/TableCell&gt;
      &lt;TableCell className=&quot;text-right&quot;&gt;
        &lt;Button asChild&gt;
          &lt;Link href={`/admin/food-trucks/${truck.id}`}&gt;Edit&lt;/Link&gt;
        &lt;/Button&gt;
      &lt;/TableCell&gt;
    &lt;/TableRow&gt;);
}
// Food trucks table component
/**
 * Displays a table of food trucks with detailed information
 * @example
 * FoodTrucksTable({ trucks: [{ id: 1, name: 'Truck 1' }], total: 10 })
 * // Returns a JSX element rendering the table
 * @param {{readonly trucks: FoodTruck[], readonly total: number}} props - An object containing an array of food trucks and the total count of trucks.
 * @returns {JSX.Element} A React component that displays a table of food trucks.
 * @description
 *   - Renders a table inside a card layout to manage food truck details.
 *   - Shows various attributes like Name, Contact, and Cuisine of each food truck.
 *   - Maps through the trucks array to create a row for each food truck using the FoodTruckTableRow component.
 *   - Provides a descriptive header highlighting the total count of food trucks.
 */
function FoodTrucksTable({ trucks, total, }) {
    return (&lt;Card&gt;
      &lt;CardHeader&gt;
        &lt;CardTitle&gt;Food Trucks&lt;/CardTitle&gt;
        &lt;CardDescription&gt;
          Manage your food trucks and their details. ({total} total)
        &lt;/CardDescription&gt;
      &lt;/CardHeader&gt;
      &lt;CardContent&gt;
        &lt;Table&gt;
          &lt;TableHeader&gt;
            &lt;TableRow&gt;
              &lt;TableHead&gt;Name&lt;/TableHead&gt;
              &lt;TableHead&gt;Contact&lt;/TableHead&gt;
              &lt;TableHead&gt;Cuisine&lt;/TableHead&gt;
              &lt;TableHead&gt;Status&lt;/TableHead&gt;
              &lt;TableHead&gt;Quality Score&lt;/TableHead&gt;
              &lt;TableHead&gt;Last Scraped&lt;/TableHead&gt;
              &lt;TableHead className=&quot;text-right&quot;&gt;Actions&lt;/TableHead&gt;
            &lt;/TableRow&gt;
          &lt;/TableHeader&gt;
          &lt;TableBody&gt;
            {trucks.map((truck) =&gt; (&lt;FoodTruckTableRow key={truck.id} truck={truck}/&gt;))}
          &lt;/TableBody&gt;
        &lt;/Table&gt;
      &lt;/CardContent&gt;
    &lt;/Card&gt;);
}
export default async function FoodTruckManagementPage() {
    const { trucks, total } = await FoodTruckService.getAllTrucks(100, 0); // Fetch first 100 trucks
    return (&lt;div className=&quot;flex flex-col gap-4&quot;&gt;
      &lt;PageHeader /&gt;
      &lt;FoodTrucksTable trucks={trucks} total={total}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/api/monitoring/api-usage/handlers.js (Line 2:30 - Line 89:2), C:/AI/food-truck-finder-poc/dist/lib/lib/api/monitoring/api-usage/handlers.js (Line 2:30 - Line 89:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn125" onclick="toggleCodeBlock('cloneGroup125', 'expandBtn125', 'collapseBtn125')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn125" onclick="toggleCodeBlock('cloneGroup125', 'expandBtn125', 'collapseBtn125')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup125"><code class="language-javascript text-sm text-gray-800">;
export function handleComprehensiveMonitoring() {
    const monitoringResult = APIMonitor.checkAllAPIs();
    return NextResponse.json({
        success: true,
        data: monitoringResult,
        timestamp: new Date().toISOString(),
    });
}
/**
 * Handles monitoring of API service usage based on the request parameters.
 * @example
 * handleServiceSpecificMonitoring(nextRequestInstance, apiServiceInstance)
 * { success: true, service: apiServiceInstance, usage: { requests: 50, tokens: 200 }, timestamp: &quot;2023-10-05T14:48:00.000Z&quot; }
 * @param {NextRequest} request - Incoming request instance containing URL and search parameters.
 * @param {APIService} service - The API service instance for which usage monitoring is being handled.
 * @returns {NextResponse} JSON response containing the service usage and possibility of making requests.
 * @description
 *   - Parses URL search parameters to extract action type and usage metrics.
 *   - Calls `APIMonitor.canMakeRequest` to determine if the request can be made when action is 'check'.
 *   - Returns current usage statistics when action is not 'check'.
 */
export async function handleServiceSpecificMonitoring(request, service) {
    const { searchParams } = new URL(request.url);
    const action = searchParams.get('action');
    if (action === 'check') {
        const requestCount = Number.parseInt(searchParams.get('requests') ?? '1', 10);
        const tokenCount = Number.parseInt(searchParams.get('tokens') ?? '0', 10);
        const canMakeRequest = await APIMonitor.canMakeRequest(service, requestCount, tokenCount);
        const usage = APIMonitor.getCurrentUsage(service);
        return NextResponse.json({
            success: true,
            service,
            canMakeRequest: canMakeRequest.allowed,
            reason: canMakeRequest.reason,
            waitTime: canMakeRequest.waitTime,
            usage,
            timestamp: new Date().toISOString(),
        });
    }
    const usage = APIMonitor.getCurrentUsage(service);
    return NextResponse.json({
        success: true,
        service,
        usage,
        timestamp: new Date().toISOString(),
    });
}
export function handleClearAlerts() {
    APIMonitor.clearAlertHistory();
    return NextResponse.json({
        success: true,
        message: 'Alert history cleared',
    });
}
export function handleGetAlerts() {
    const alerts = APIMonitor.getAlertHistory();
    return NextResponse.json({
        success: true,
        alerts,
        count: alerts.length,
    });
}
/**
 * Handles test alert triggering based on service and level provided.
 * @example
 * handleTestAlert({service: 'database', level: 'high'})
 * // Expected response in JSON format with success message.
 * @param {Object} body - The object containing service and level details.
 * @param {string} body.service - The name of the service for which the alert is triggered.
 * @param {string} body.level - The severity level of the alert.
 * @returns {Object} JSON response indicating success or failure status.
 * @description
 *   - Returns a success message with service and level if both are provided.
 *   - Responds with an error message if either service or level is missing.
 *   - Simulates alert triggering functionality - no real alert system interaction.
 */
export function handleTestAlert(body) {
    const { service, level } = body;
    if (service == undefined || level == undefined) {
        return NextResponse.json({ success: false, error: 'Missing service or level' }, { status: 400 });
    }
    // This would trigger a test alert in a real implementation
    return NextResponse.json({
        success: true,
        message: `Test alert triggered for ${service} at ${level} level`,
    });
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/api/cron/auto-scrape/improvedHandler.js (Line 4:15 - Line 141:2), C:/AI/food-truck-finder-poc/dist/lib/lib/api/cron/auto-scrape/improvedHandler.js (Line 4:15 - Line 141:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn126" onclick="toggleCodeBlock('cloneGroup126', 'expandBtn126', 'collapseBtn126')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn126" onclick="toggleCodeBlock('cloneGroup126', 'expandBtn126', 'collapseBtn126')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup126"><code class="language-javascript text-sm text-gray-800">;
// Vercel hobby plan has 10 second timeout, leave some buffer
const FUNCTION_TIMEOUT_MS = 9000;
const PROCESSING_TIMEOUT_MS = 8000;
/**
 * Lightweight CRON handler that creates jobs but doesn't process them
 * This avoids timeout issues on Vercel hobby plan
 */
export async function handleAutoScrapeImproved(request) {
    const startTime = Date.now();
    try {
        // Verify authorization
        const authHeader = request.headers.get('authorization');
        const cronSecret = process.env.CRON_SECRET;
        if (!cronSecret || authHeader !== `Bearer ${cronSecret}`) {
            return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
        }
        logActivity({
            type: 'cron_job',
            action: 'auto_scrape_started',
            details: { timestamp: new Date().toISOString() },
        });
        const result = {
            trucksProcessed: 0,
            newTrucksFound: 0,
            errors: []
        };
        // Get URLs to scrape
        const urlsToScrape = await getUrlsToScrape();
        console.info(`Found ${urlsToScrape.length} URLs to process`);
        // Check existing trucks to determine which are new
        const { trucks: existingTrucks } = await FoodTruckService.getAllTrucks(1000, 0);
        const existingUrls = new Set(existingTrucks.flatMap(truck =&gt; truck.source_urls || []));
        // Create jobs for URLs (but don't process them)
        for (const url of urlsToScrape) {
            // Check if we're approaching timeout
            if (Date.now() - startTime &gt; PROCESSING_TIMEOUT_MS) {
                console.warn('Approaching function timeout, stopping job creation');
                break;
            }
            try {
                const isNew = !existingUrls.has(url);
                // Check if job already exists
                const existingJobs = await ScrapingJobService.getJobsByStatus('all');
                const jobExists = existingJobs.some(job =&gt; job.target_url === url &amp;&amp; ['pending', 'running'].includes(job.status));
                if (!jobExists) {
                    // Create job but don't process it
                    await ScrapingJobService.createJob({
                        job_type: 'website_auto',
                        target_url: url,
                        priority: isNew ? 10 : 5, // Higher priority for new trucks
                        scheduled_at: new Date().toISOString(),
                    });
                    result.trucksProcessed++;
                    if (isNew) {
                        result.newTrucksFound++;
                    }
                }
            }
            catch (error) {
                console.error(`Error creating job for ${url}:`, error);
                result.errors.push(url);
            }
        }
        // Process a few high-priority pending jobs if we have time
        const remainingTime = FUNCTION_TIMEOUT_MS - (Date.now() - startTime);
        if (remainingTime &gt; 2000) {
            await processHighPriorityJobs(remainingTime - 1000);
        }
        logActivity({
            type: 'cron_job',
            action: 'auto_scrape_completed',
            details: {
                timestamp: new Date().toISOString(),
                trucksProcessed: result.trucksProcessed,
                newTrucksFound: result.newTrucksFound,
                errorsCount: result.errors.length,
            },
        });
        return NextResponse.json({
            success: true,
            message: 'Auto-scraping jobs created successfully',
            data: {
                trucksProcessed: result.trucksProcessed,
                newTrucksFound: result.newTrucksFound,
                timestamp: new Date().toISOString(),
                note: 'Jobs created but not processed. Use separate job processor to avoid timeouts.',
            },
        });
    }
    catch (error) {
        console.error('Auto-scraping cron job failed:', error);
        logActivity({
            type: 'cron_job',
            action: 'auto_scrape_failed',
            details: {
                timestamp: new Date().toISOString(),
                error: error instanceof Error ? error.message : 'Unknown error',
            },
        });
        return NextResponse.json({
            success: false,
            error: 'Auto-scraping failed',
            message: error instanceof Error ? error.message : 'Unknown error',
        }, { status: 500 });
    }
}
async function getUrlsToScrape() {
    // This is a simplified version - in production, you'd also check discovered_urls table
    return DEFAULT_SCRAPE_URLS;
}
async function processHighPriorityJobs(timeLimit) {
    const startTime = Date.now();
    try {
        // Get high priority pending jobs
        const pendingJobs = await ScrapingJobService.getJobsByStatus('pending');
        const highPriorityJobs = pendingJobs
            .filter(job =&gt; job.priority &gt;= 10)
            .sort((a, b) =&gt; b.priority - a.priority)
            .slice(0, 3); // Process at most 3 jobs
        for (const job of highPriorityJobs) {
            if (Date.now() - startTime &gt; timeLimit) {
                break;
            }
            // Just update status to indicate it's been queued
            await ScrapingJobService.updateJobStatus(job.id, 'pending', {
                data_collected: {
                    ...job.data_collected,
                    queued_at: new Date().toISOString(),
                    queued_note: 'Queued for processing by job processor'
                }
            });
        }
    }
    catch (error) {
        console.error('Error processing high priority jobs:', error);
    }
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/api/cron/auto-scrape/handlers.js (Line 1:1 - Line 125:2), C:/AI/food-truck-finder-poc/dist/lib/api/cron/auto-scrape/handlers.js (Line 1:1 - Line 125:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn127" onclick="toggleCodeBlock('cloneGroup127', 'expandBtn127', 'collapseBtn127')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn127" onclick="toggleCodeBlock('cloneGroup127', 'expandBtn127', 'collapseBtn127')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup127"><code class="language-javascript text-sm text-gray-800">import { NextResponse } from 'next/server';
import { autoScraper } from '@/lib/autoScraper';
import { scheduler } from '@/lib/scheduler';
import { logActivity } from '@/lib/activityLogger';
/**
* Verifies the cron secret authorization header against a stored environment variable.
* @example
* verifyCronSecret(request)
* NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
* @param {NextRequest} request - The incoming request object containing headers.
* @returns {NextResponse | null} Returns an error response if authorization fails or if the secret is not set.
* @description
*   - Logs an error message if the CRON_SECRET environment variable is not configured or is empty.
*   - Logs unauthorized attempts, including the provided authorization header value.
*   - Relies on the Bearer token scheme for authorization.
*/
function verifyCronSecret(request) {
    const authHeader = request.headers.get('authorization');
    const cronSecret = process.env.CRON_SECRET;
    if (cronSecret === undefined || cronSecret === '') {
        console.error('CRON_SECRET not configured');
        return NextResponse.json({ error: 'Server configuration error' }, { status: 500 });
    }
    if (authHeader !== `Bearer ${cronSecret}`) {
        console.error('Unauthorized cron attempt:', authHeader);
        return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }
    return null;
}
function logAutoScrapeStart() {
    console.info('Starting automated scraping job...');
    logActivity({
        type: 'cron_job',
        action: 'auto_scrape_started',
        details: { timestamp: new Date().toISOString() },
    });
}
/**
 * Logs the completion of an automated scraping job with pertinent details.
 * @example
 * logAutoScrapeCompletion(autoScrapeResult)
 * Automated scraping job completed successfully
 * @param {AutoScrapeResult} result - The result object containing details of the scraping job.
 * @returns {void} Does not return a value.
 * @description
 *   - Logs activity including the number of trucks processed and found, as well as any errors encountered.
 *   - Utilizes a standardized logActivity function to record job completion.
 *   - Converts the current timestamp to an ISO string format.
 *   - Provides a console message indicating successful job completion.
 */
function logAutoScrapeCompletion(result) {
    logActivity({
        type: 'cron_job',
        action: 'auto_scrape_completed',
        details: {
            timestamp: new Date().toISOString(),
            trucksProcessed: result.trucksProcessed,
            newTrucksFound: result.newTrucksFound,
            errorsCount: result.errors?.length ?? 0,
        },
    });
    console.info('Automated scraping job completed successfully');
}
function logAutoScrapeFailure(error) {
    console.error('Auto-scraping cron job failed:', error);
    logActivity({
        type: 'cron_job',
        action: 'auto_scrape_failed',
        details: {
            timestamp: new Date().toISOString(),
            error: error instanceof Error ? error.message : 'Unknown error',
        },
    });
}
/**
 * Handles a POST request to initiate an auto-scraping process and returns the result.
 * @example
 * handlePostRequest(request)
 * { success: true, message: 'Auto-scraping completed successfully', data: { trucksProcessed: 10, newTrucksFound: 2, timestamp: '2023-08-23T18:25:43.511Z' } }
 * @param {NextRequest} request - The request object containing necessary parameters and headers for processing.
 * @returns {NextResponse} JSON response with either the success data or an error message.
 * @description
 *   - Validates request with a secret key before processing.
 *   - Logs scraping start and completion along with processed results.
 *   - Schedules follow-up tasks after successful scraping.
 *   - Catches and logs errors with a failure response in case of any exceptions during the process.
 */
export async function handlePostRequest(request) {
    try {
        const authResponse = verifyCronSecret(request);
        if (authResponse) {
            return authResponse;
        }
        logAutoScrapeStart();
        const rawResult = await autoScraper.runAutoScraping();
        // Map errors to string[] for compatibility
        const result = {
            trucksProcessed: rawResult.trucksProcessed,
            newTrucksFound: rawResult.newTrucksFound,
            errors: rawResult.errors?.map((e) =&gt; e.url + (e.details ? `: ${e.details}` : '')),
        };
        scheduler.scheduleFollowUpTasks(result);
        logAutoScrapeCompletion(result);
        return NextResponse.json({
            success: true,
            message: 'Auto-scraping completed successfully',
            data: {
                trucksProcessed: result.trucksProcessed,
                newTrucksFound: result.newTrucksFound,
                timestamp: new Date().toISOString(),
            },
        });
    }
    catch (error) {
        logAutoScrapeFailure(error);
        return NextResponse.json({
            success: false,
            error: 'Auto-scraping failed',
            message: error instanceof Error ? error.message : 'Unknown error',
        }, { status: 500 });
    }
}
export function handleGetRequest() {
    return NextResponse.json({ error: 'Method not allowed. Use POST for cron jobs.' }, { status: 405 });
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/api/analytics/web-vitals/handlers.js (Line 1:1 - Line 197:2), C:/AI/food-truck-finder-poc/dist/lib/api/analytics/web-vitals/handlers.js (Line 1:1 - Line 197:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn128" onclick="toggleCodeBlock('cloneGroup128', 'expandBtn128', 'collapseBtn128')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn128" onclick="toggleCodeBlock('cloneGroup128', 'expandBtn128', 'collapseBtn128')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup128"><code class="language-javascript text-sm text-gray-800">import { NextResponse } from 'next/server';
import { supabaseAdmin } from '@/lib/supabase';
/**
 * Get Web Vitals Analytics Data
 */
export function getRequestParams(request) {
    const { searchParams } = new URL(request.url);
    const days = Number.parseInt(searchParams.get('days') ?? '7', 10);
    const page = searchParams.get('page');
    return { days, page };
}
/**
 * Fetches and filters web vital metrics based on the given request parameters.
 * @example
 * fetchAndFilterMetrics(request)
 * { metrics: [{...}], days: 7, startDate: 2023-01-01T00:00:00.000Z }
 * @param {NextRequest} request - The request object containing parameters for filtering metrics such as days and page.
 * @returns {Object} An object containing an array of metrics, the number of days for the range, and the start date.
 * @description
 *   - Throws an error if the Supabase database connection is not available.
 *   - Builds a query to select metrics recorded after a specific start date.
 *   - Filters metrics by page URL if specified in the request parameters.
 *   - Limits the number of returned metrics to 1000 to avoid overwhelming the client.
 */
export async function fetchAndFilterMetrics(request) {
    const { days, page } = getRequestParams(request);
    if (!supabaseAdmin) {
        throw new Error('Database not available');
    }
    const startDate = new Date();
    startDate.setDate(startDate.getDate() - days);
    let query = supabaseAdmin
        .from('web_vitals_metrics')
        .select('*')
        .gte('recorded_at', startDate.toISOString())
        .order('recorded_at', { ascending: false });
    if (page != undefined &amp;&amp; page !== '') {
        query = query.ilike('page_url', `%${page}%`);
    }
    const { data: metrics, error } = await query.limit(1000);
    if (error) {
        throw error;
    }
    return { metrics: metrics ?? [], days, startDate };
}
/**
 * Calculate summary statistics for metrics
 */
export function calculateMetricsSummary(metrics) {
    const metricTypes = [
        'LCP',
        'FID',
        'CLS',
        'FCP',
        'TTFB',
    ];
    const summary = {};
    for (const metricName of metricTypes) {
        const metricData = metrics.filter((m) =&gt; m.metric_name === metricName);
        if (metricData.length === 0) {
            summary[metricName] = {
                count: 0,
                average: undefined,
                median: undefined,
                p75: undefined,
                p95: undefined,
                goodCount: 0,
                needsImprovementCount: 0,
                poorCount: 0,
            };
            continue;
        }
        const values = metricData.map((m) =&gt; m.metric_value).sort((a, b) =&gt; a - b);
        const ratings = metricData.map((m) =&gt; m.rating);
        summary[metricName] = {
            count: metricData.length,
            average: Math.round(values.reduce((sum, val) =&gt; sum + val, 0) / values.length),
            median: getPercentile(values, 50),
            p75: getPercentile(values, 75),
            p95: getPercentile(values, 95),
            goodCount: ratings.filter((r) =&gt; r === 'good').length,
            needsImprovementCount: ratings.filter((r) =&gt; r === 'needs-improvement').length,
            poorCount: ratings.filter((r) =&gt; r === 'poor').length,
        };
    }
    return summary;
}
/**
 * Calculate percentile value from sorted array
 */
export function getPercentile(sortedValues, percentile) {
    if (sortedValues.length === 0)
        return 0;
    const index = (percentile / 100) * (sortedValues.length - 1);
    const lower = Math.floor(index);
    const upper = Math.ceil(index);
    if (lower === upper) {
        return Math.round(sortedValues[lower]);
    }
    const weight = index - lower;
    return Math.round(sortedValues[lower] * (1 - weight) + sortedValues[upper] * weight);
}
/**
 * Handles POST requests to store and validate web vital metrics.
 * @example
 * handlePostRequest(request)
 * { success: true }
 * @param {NextRequest} request - The incoming request containing the web vital metric data.
 * @returns {NextResponse} JSON response indicating success or failure of storing the metric.
 * @description
 *   - Validates that the metric contains required fields and checks the types of values.
 *   - Stores validated metrics in a Supabase table if `supabaseAdmin` is available.
 *   - Logs any 'poor' performance metrics for monitoring purposes.
 *   - Ensures metrics collection is non-blocking, even if an error occurs during database operations.
 */
export async function handlePostRequest(request) {
    try {
        const metric = await request.json();
        // Validate metric data
        if (typeof metric !== 'object' ||
            metric == undefined ||
            !('name' in metric) ||
            !('value' in metric) ||
            !('url' in metric) ||
            typeof metric.value !== 'number') {
            return NextResponse.json({ success: false, error: 'Invalid metric data' }, { status: 400 });
        }
        const validatedMetric = metric;
        if (supabaseAdmin) {
            try {
                const { error } = await supabaseAdmin.from('web_vitals_metrics').insert({
                    metric_name: validatedMetric.name,
                    metric_value: validatedMetric.value,
                    rating: validatedMetric.rating,
                    page_url: validatedMetric.url,
                    user_agent: validatedMetric.userAgent,
                    recorded_at: new Date(validatedMetric.timestamp).toISOString(),
                });
                if (error) {
                    console.warn('Failed to store web vital metric:', error);
                    // Don't fail the request - metrics collection should be non-blocking
                }
            }
            catch (dbError) {
                console.warn('Database error storing web vital:', dbError);
            }
        }
        // Log performance issues for monitoring
        if (validatedMetric.rating === 'poor') {
            console.warn(`Poor ${validatedMetric.name} performance detected:`, {
                value: validatedMetric.value,
                url: validatedMetric.url,
                timestamp: new Date(validatedMetric.timestamp).toISOString(),
            });
        }
        return NextResponse.json({ success: true });
    }
    catch (error) {
        console.error('Web vitals endpoint error:', error);
        return NextResponse.json({ success: false, error: 'Internal server error' }, { status: 500 });
    }
}
/**
* Handles a GET request to fetch web vitals analytics data, process it, and respond with a summary.
* @example
* handleGetRequest(request)
* { success: true, data: { metrics: [...], summary: {...}, period: {...} } }
* @param {NextRequest} request - The incoming request object containing the necessary parameters.
* @returns {Promise&lt;NextResponse&gt;} Returns a JSON response indicating success or failure along with the data.
* @description
*   - Fetches metrics which are filtered and evaluated from the request data.
*   - Constructs a summary of the metrics including names, values, and ratings.
*   - Generates a response containing the metrics, summary, and calculated time period.
*   - Logs errors and responses with a status code in case of failure during data fetching.
*/
export async function handleGetRequest(request) {
    try {
        const { metrics, days, startDate } = await fetchAndFilterMetrics(request);
        const summary = calculateMetricsSummary(metrics);
        return NextResponse.json({
            success: true,
            data: {
                metrics,
                summary,
                period: {
                    days,
                    startDate: startDate.toISOString(),
                    endDate: new Date().toISOString(),
                },
            },
        });
    }
    catch (error) {
        console.error('Failed to fetch web vitals analytics:', error);
        return NextResponse.json({ success: false, error: 'Failed to fetch analytics data' }, { status: 500 });
    }
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/api/admin/scraping-metrics/handlers.js (Line 1:1 - Line 56:2), C:/AI/food-truck-finder-poc/dist/lib/api/admin/scraping-metrics/handlers.js (Line 1:1 - Line 56:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn130" onclick="toggleCodeBlock('cloneGroup130', 'expandBtn130', 'collapseBtn130')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn130" onclick="toggleCodeBlock('cloneGroup130', 'expandBtn130', 'collapseBtn130')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup130"><code class="language-javascript text-sm text-gray-800">import { NextResponse } from 'next/server';
import { ScrapingJobService, FoodTruckService } from '@/lib/supabase';
export async function handleGetRequest() {
    const metrics = await getScrapingMetrics();
    return NextResponse.json({
        success: true,
        data: metrics,
        timestamp: new Date().toISOString(),
    });
}
/**
 * Retrieves real-time scraping metrics from the database.
 * @example
 * getScrapingMetrics().then(metrics =&gt; console.log(metrics))
 * // { scrapingJobs: {...}, dataQuality: {...}, systemHealth: {...} }
 * @returns {Promise&lt;RealtimeMetrics&gt;} A promise that resolves to an object containing scraping job metrics, data quality information, and system health stats.
 * @description
 *   - Fetches data from ScrapingJobService and FoodTruckService to compute metrics.
 *   - Placeholder values are used for averageScore and recentChanges in dataQuality.
 *   - Computes the number of jobs by their status: running, completed, failed, and pending.
 */
async function getScrapingMetrics() {
    // Fetch real scraping metrics from database
    const [allJobsResult, recentTrucksResult] = await Promise.all([
        ScrapingJobService.getAllJobs(100, 0), // Get last 100 jobs for metrics
        FoodTruckService.getAllTrucks(1000, 0), // Get trucks for processing count
    ]);
    // Type guard for allJobsResult
    const allJobs = Array.isArray(allJobsResult) ? allJobsResult : [];
    const recentTrucks = typeof recentTrucksResult === 'object' &amp;&amp;
        'trucks' in recentTrucksResult &amp;&amp;
        Array.isArray(recentTrucksResult.trucks)
        ? recentTrucksResult
        : { trucks: [], total: 0 };
    const typedJobs = allJobs;
    const successfulRuns = typedJobs.filter((job) =&gt; job.status === 'completed').length;
    const failedRuns = typedJobs.filter((job) =&gt; job.status === 'failed').length;
    return {
        scrapingJobs: {
            active: typedJobs.filter((job) =&gt; job.status === 'running').length,
            completed: successfulRuns,
            failed: failedRuns,
            pending: typedJobs.filter((job) =&gt; job.status === 'pending').length,
        },
        dataQuality: {
            averageScore: 0, // Placeholder, actual calculation might be complex
            totalTrucks: recentTrucks.total,
            recentChanges: 0, // Placeholder
        },
        systemHealth: {
            status: 'healthy',
            uptime: process.uptime(),
            lastUpdate: new Date().toISOString(),
        },
    };
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/api/admin/realtime-events/handlers.js (Line 1:1 - Line 370:2), C:/AI/food-truck-finder-poc/dist/lib/api/admin/realtime-events/handlers.js (Line 1:1 - Line 370:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn131" onclick="toggleCodeBlock('cloneGroup131', 'expandBtn131', 'collapseBtn131')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn131" onclick="toggleCodeBlock('cloneGroup131', 'expandBtn131', 'collapseBtn131')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup131"><code class="language-javascript text-sm text-gray-800">import { ScrapingJobService, FoodTruckService, } from '@/lib/supabase';
/**
* Handles incoming GET requests by streaming real-time admin events through Server-Sent Events.
* @example
* handleGetRequest(request)
* Response object with event stream data
* @param {NextRequest} request - Incoming request to handle and process.
* @returns {Response} Returns a streaming Response object containing the SSE data.
* @description
*   - Initializes a readable stream for emitting real-time events as SSE.
*   - Enqueues a connection event upon a new client connection.
*   - Sets up periodic heartbeat events every 5 seconds.
*   - Registers an abort event listener to gracefully close streams and clear intervals.
*/
export function handleGetRequest(request) {
    const stream = new ReadableStream({
        start(controller) {
            const encoder = new TextEncoder();
            const connectionEvent = {
                id: generateEventId(),
                type: 'heartbeat',
                timestamp: new Date().toISOString(),
                data: {
                    message: 'Real-time admin dashboard connected',
                    connectionId: generateEventId(),
                },
            };
            controller.enqueue(encoder.encode(formatSSEMessage(connectionEvent)));
            const intervalId = setInterval(async () =&gt; {
                await sendHeartbeatEvent(controller, encoder);
            }, 5000);
            const changeMonitorId = setupDataChangeMonitor(controller, encoder);
            request.signal.addEventListener('abort', () =&gt; {
                clearInterval(intervalId);
                clearInterval(changeMonitorId);
                controller.close();
            });
        },
    });
    return new Response(stream, {
        headers: {
            'Content-Type': 'text/event-stream',
            'Cache-Control': 'no-cache',
            Connection: 'keep-alive',
            'Access-Control-Allow-Origin': '*',
            'Access-Control-Allow-Headers': 'Cache-Control',
        },
    });
}
/**
* Sends a heartbeat event by fetching realtime metrics or logs an error alert when unsuccessful
* @example
* sendHeartbeatEvent(controller, encoder)
* // No return value
* @param {ReadableStreamDefaultController&lt;Uint8Array&gt;} controller - The controller used for enqueueing the event data.
* @param {TextEncoder} encoder - The encoder used to convert the event data to a Uint8Array.
* @returns {Promise&lt;void&gt;} Promise that resolves when event has been sent or error has been handled.
* @description
*   - Utilizes `fetchRealtimeMetrics()` to gather current system metrics.
*   - Generates a unique event id via `generateEventId()`.
*   - Formats the event data using `formatSSEMessage()` before enqueueing.
*   - Handles errors by creating a system alert event if metrics fetching fails.
*/
async function sendHeartbeatEvent(controller, encoder) {
    try {
        const metrics = await fetchRealtimeMetrics();
        const event = {
            id: generateEventId(),
            type: 'heartbeat',
            timestamp: new Date().toISOString(),
            data: { ...metrics },
        };
        controller.enqueue(encoder.encode(formatSSEMessage(event)));
    }
    catch (error) {
        console.error('Error fetching realtime metrics:', error);
        const errorEvent = {
            id: generateEventId(),
            type: 'system_alert',
            timestamp: new Date().toISOString(),
            data: {
                error: 'Failed to fetch metrics',
                details: error instanceof Error ? error.message : 'Unknown error',
            },
            severity: 'error',
        };
        controller.enqueue(encoder.encode(formatSSEMessage(errorEvent)));
    }
}
/**
* Sets up a periodic monitor for data changes using provided controller and encoder.
* @example
* setupDataChangeMonitor(controller, encoder)
* // returns a NodeJS.Timeout object that repeatedly monitors data changes every 10 seconds
* @param {ReadableStreamDefaultController&lt;Uint8Array&gt;} controller - Controller to handle readable stream of Uint8Array.
* @param {TextEncoder} encoder - Encoder to encode texts for processing the monitor.
* @returns {NodeJS.Timeout} Returns a timeout object responsible for invoking data change monitoring at set intervals.
* @description
*   - Utilizes async operation to monitor data changes ensuring non-blocking execution.
*   - Handles errors by logging them to the console, useful for debugging.
*/
function setupDataChangeMonitor(controller, encoder) {
    return setInterval(async () =&gt; {
        try {
            await monitorDataChanges(controller, encoder);
        }
        catch (error) {
            console.error('Error monitoring data changes:', error);
        }
    }, 10_000);
}
/**
 * Handles a POST request and performs an action based on the 'action' property in the request body.
 * @example
 * handlePostRequest(request)
 * Promise&lt;Response&gt;
 * @param {NextRequest} request - The incoming request object containing the POST data.
 * @returns {Promise&lt;Response&gt;} A response object indicating the result of the action.
 * @description
 *   - Utilizes type guarding to validate the presence of the 'action' property in the request body.
 *   - Executes different actions like 'health_check' or 'trigger_test_event' based on the 'action' value.
 *   - Provides error handling to return appropriate response codes and error messages.
 */
export async function handlePostRequest(request) {
    try {
        const rawBody = await request.json();
        const isPostRequestBody = (obj) =&gt; {
            return (typeof obj === 'object' &amp;&amp;
                obj !== null &amp;&amp;
                'action' in obj &amp;&amp;
                typeof obj.action === 'string' &amp;&amp;
                (obj.action === 'health_check' ||
                    obj.action === 'trigger_test_event'));
        };
        if (!isPostRequestBody(rawBody)) {
            return new Response(JSON.stringify({
                success: false,
                error: &quot;Invalid request body: 'action' property is missing or not a valid action.&quot;,
            }), {
                status: 400,
                headers: { 'Content-Type': 'application/json' },
            });
        }
        const body = rawBody;
        switch (body.action) {
            case 'health_check': {
                return await handleHealthCheck();
            }
            case 'trigger_test_event': {
                return handleTriggerTestEvent();
            }
            default: {
                return new Response(JSON.stringify({
                    success: false,
                    error: &quot;That didn't work, please try again later.&quot;,
                }), {
                    status: 400,
                    headers: { 'Content-Type': 'application/json' },
                });
            }
        }
    }
    catch (error) {
        console.error('Realtime events POST error:', error);
        return new Response(JSON.stringify({
            success: false,
            error: &quot;That didn't work, please try again later.&quot;,
        }), {
            status: 500,
            headers: { 'Content-Type': 'application/json' },
        });
    }
}
/**
 * Fetches current scraping job metrics, data quality statistics, and system health status.
 * @example
 * fetchRealtimeMetrics()
 * {
 *   scrapingJobs: { active: 4, completed: 5, failed: 1, pending: 2 },
 *   dataQuality: { averageScore: 85, totalTrucks: 50, recentChanges: 0 },
 *   systemHealth: { status: 'healthy', uptime: 3600, lastUpdate: '2023-10-01T12:00:00Z' }
 * }
 * @returns {Promise&lt;RealtimeMetrics&gt;} An object containing metrics about scraping jobs, data quality, and system health.
 * @description
 *   - Utilizes external services ScrapingJobService and FoodTruckService to gather data.
 *   - Provides comprehensive metrics for monitoring system health and data processing status.
 *   - Catches errors to ensure consistent return structure even upon failure.
 */
async function fetchRealtimeMetrics() {
    try {
        const recentJobs = await ScrapingJobService.getJobsByStatus('all');
        const scrapingMetrics = {
            active: recentJobs.filter((job) =&gt; job.status === 'running').length,
            completed: recentJobs.filter((job) =&gt; job.status === 'completed').length,
            failed: recentJobs.filter((job) =&gt; job.status === 'failed').length,
            pending: recentJobs.filter((job) =&gt; job.status === 'pending').length,
        };
        const qualityStats = await FoodTruckService.getDataQualityStats();
        const dataQualityMetrics = {
            averageScore: qualityStats.avg_quality_score ?? 0,
            totalTrucks: qualityStats.total_trucks ?? 0,
            recentChanges: 0,
        };
        const systemHealth = {
            status: 'healthy',
            uptime: process.uptime(),
            lastUpdate: new Date().toISOString(),
        };
        return {
            scrapingJobs: scrapingMetrics,
            dataQuality: dataQualityMetrics,
            systemHealth,
        };
    }
    catch (error) {
        console.error('Error fetching realtime metrics:', error);
        return {
            scrapingJobs: { active: 0, completed: 0, failed: 0, pending: 0 },
            dataQuality: { averageScore: 0, totalTrucks: 0, recentChanges: 0 },
            systemHealth: {
                status: 'error',
                uptime: 0,
                lastUpdate: new Date().toISOString(),
            },
        };
    }
}
function isScrapingJob(obj) {
    return typeof obj === 'object' &amp;&amp; obj !== null &amp;&amp; 'id' in obj &amp;&amp; 'status' in obj;
}
// Removed isFoodTruck function as it is unused.
// function isFoodTruck(obj: unknown): obj is FoodTruck {
//   return typeof obj === 'object' &amp;&amp; obj !== null &amp;&amp; 'id' in obj &amp;&amp; 'name' in obj;
// }
/**
 * Sends an update event about recent scraping jobs to a stream.
 * @example
 * sendScrapingUpdateEvent(controller, encoder)
 * @param {ReadableStreamDefaultController&lt;Uint8Array&gt;} controller - The stream controller to enqueue the event data.
 * @param {TextEncoder} encoder - The TextEncoder used to encode the event message.
 * @returns {Promise&lt;void&gt;} Resolves when the event has been enqueued.
 * @description
 *   - The function retrieves all recent scraping jobs with their status.
 *   - Filters the jobs to include only valid scraping jobs.
 *   - Constructs an event object adhering to the expected format.
 *   - Uses the controller to stream the encoded event to the client.
 */
async function sendScrapingUpdateEvent(controller, encoder) {
    const recentJobs = await ScrapingJobService.getJobsByStatus('all');
    if (Array.isArray(recentJobs) &amp;&amp; recentJobs.length &gt; 0) {
        const event = {
            id: generateEventId(),
            type: 'scraping_update',
            timestamp: new Date().toISOString(),
            data: {
                recentJobs: recentJobs
                    .filter((job) =&gt; isScrapingJob(job))
                    .map((job) =&gt; ({
                    // Fixed unicorn/no-array-callback-reference
                    id: job.id,
                    status: job.status,
                    started_at: job.started_at,
                    completed_at: job.completed_at,
                })),
                count: recentJobs.length,
            },
            severity: 'info',
        };
        controller.enqueue(encoder.encode(formatSSEMessage(event)));
    }
}
/**
 * Sends a data quality change event if recent updates are detected.
 * @example
 * sendDataQualityChangeEvent(controller, encoder)
 * // Enqueues an event to the provided controller.
 * @param {ReadableStreamDefaultController&lt;Uint8Array&gt;} controller - The controller that enqueues the encoded event data.
 * @param {TextEncoder} encoder - The encoder used to transform event data into Uint8Array format.
 * @returns {Promise&lt;void&gt;} Resolves when the event is successfully handled and enqueued.
 * @description
 *   - Retrieves recent food truck updates from the FoodTruckService.
 *   - Filters food trucks updated within the last minute.
 *   - Formats a server-sent event message with the updates.
 *   - Only enqueues the event if there are updates detected.
 */
async function sendDataQualityChangeEvent(controller, encoder) {
    const recentTrucksResult = await FoodTruckService.getAllTrucks(10, 0);
    const recentlyUpdated = recentTrucksResult.trucks.filter((truck) =&gt; {
        if (!truck.updated_at)
            return false;
        const updatedAt = new Date(truck.updated_at);
        const oneMinuteAgo = new Date(Date.now() - 60_000);
        return updatedAt &gt; oneMinuteAgo;
    });
    if (recentlyUpdated.length &gt; 0) {
        const event = {
            id: generateEventId(),
            type: 'data_quality_change',
            timestamp: new Date().toISOString(),
            data: {
                updatedTrucks: recentlyUpdated.map((truck) =&gt; ({
                    id: truck.id,
                    name: truck.name,
                    data_quality_score: truck.data_quality_score,
                    updated_at: truck.updated_at,
                })),
                count: recentlyUpdated.length,
            },
            severity: 'info',
        };
        controller.enqueue(encoder.encode(formatSSEMessage(event)));
    }
}
async function monitorDataChanges(controller, encoder) {
    try {
        await sendScrapingUpdateEvent(controller, encoder);
        await sendDataQualityChangeEvent(controller, encoder);
    }
    catch (error) {
        console.error('Error monitoring data changes:', error);
    }
}
function formatSSEMessage(event) {
    return `id: ${event.id}\nevent: ${event.type}\ndata: ${JSON.stringify(event)}\n\n`;
}
function generateEventId() {
    // eslint-disable-next-line sonarjs/pseudo-random -- Math.random is acceptable for generating non-security-sensitive event IDs.
    return `${Date.now()}-${Math.random().toString(36).slice(2, 11)}`;
}
/**
 * Performs a health check and returns the system status along with real-time metrics.
 * @example
 * handleHealthCheck().then(response =&gt; console.log(response));
 * Response { &quot;success&quot;: true, &quot;status&quot;: &quot;healthy&quot;, &quot;metrics&quot;: {...}, &quot;timestamp&quot;: &quot;2023-03-17T12:34:56.789Z&quot; }
 * @returns {Promise&lt;Response&gt;} A Promise that resolves to a Response object containing JSON data.
 * @description
 *   - Utilizes real-time metrics to provide current system health information.
 *   - Returns a JSON response formatted with specific headers and structure.
 */
async function handleHealthCheck() {
    const metrics = await fetchRealtimeMetrics();
    return new Response(JSON.stringify({
        success: true,
        status: 'healthy',
        metrics,
        timestamp: new Date().toISOString(),
    }), {
        headers: { 'Content-Type': 'application/json' },
    });
}
/**
 * Returns a JSON response indicating a test event has been triggered.
 * @example
 * handleTriggerTestEvent()
 * Response object with a success message.
 * @returns {Response} JSON response containing success status, message, and timestamp.
 * @description
 *   - The response content type is set to 'application/json'.
 *   - The timestamp is generated using the current date and time.
 *   - Ensures consistent response formatting for realtime event triggers.
 */
function handleTriggerTestEvent() {
    return new Response(JSON.stringify({
        success: true,
        message: 'Test event triggered',
        timestamp: new Date().toISOString(),
    }), {
        headers: { 'Content-Type': 'application/json' },
    });
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/api/admin/oauth-status/helpers.js (Line 1:1 - Line 332:2), C:/AI/food-truck-finder-poc/dist/lib/api/admin/oauth-status/helpers.js (Line 1:1 - Line 332:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn133" onclick="toggleCodeBlock('cloneGroup133', 'expandBtn133', 'collapseBtn133')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn133" onclick="toggleCodeBlock('cloneGroup133', 'expandBtn133', 'collapseBtn133')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup133"><code class="language-javascript text-sm text-gray-800">import { NextResponse } from 'next/server';
import { supabase } from '@/lib/supabase';
/**
 * Handles a GET request to retrieve OAuth configuration status.
 * @example
 * handleGetRequest(request)
 * Returns a JSON response with OAuth status details and legacy format.
 * @param {NextRequest} _request - The incoming request object.
 * @returns {NextResponse} JSON response indicating the current OAuth status.
 * @description
 *   - Retrieves the current OAuth configuration status from the server.
 *   - Adapts the response to include both modern and legacy format details.
 *   - Provides a step-by-step legacy configuration guide if OAuth is not ready.
 */
export async function handleGetRequest(_request) {
    const status = await getOAuthStatus();
    return NextResponse.json({
        success: true,
        ...status,
        legacy_format: {
            oauth_status: status.overall_status,
            message: getStatusMessage(status.overall_status),
            configuration_steps: status.overall_status === 'ready'
                ? undefined
                : [
                    '1. Go to Supabase Dashboard &gt; Authentication &gt; Providers',
                    '2. Enable Google provider',
                    '3. Add Google OAuth Client ID and Secret',
                    '4. Configure redirect URLs',
                    '5. Test OAuth flow',
                ],
        },
    });
}
// 1. Refactor nested template literals in generateOAuthTestUrl
function generateOAuthTestUrl(baseUrl) {
    const redirectPath = `${baseUrl}/auth/callback`;
    const encodedRedirect = encodeURIComponent(redirectPath);
    return (process.env.NEXT_PUBLIC_SUPABASE_URL +
        '/auth/v1/authorize?provider=google&amp;redirect_to=' +
        encodedRedirect);
}
/**
 * Handles a post request to generate an OAuth test URL based on the environment.
 * @example
 * handlePostRequest()
 * {
 *   success: true,
 *   message: 'OAuth test URL generated',
 *   test_url: 'http://localhost:3000/...',
 *   environment: 'development',
 *   instructions: [ ... ],
 *   manual_test_steps: [ ... ],
 *   automation_commands: [ ... ]
 * }
 * @returns {object} An object containing success status, message, the test URL, the environment, instructions, manual test steps, and automation commands.
 * @description
 *   - Determines the base URL depending on whether the environment is production or development.
 *   - Utilizes `generateOAuthTestUrl` to construct the OAuth test URL.
 *   - Responds with JSON containing test instructions and automation commands for verifying OAuth functionality.
 */
export function handlePostRequest() {
    // Removed _request parameter
    const baseUrl = process.env.NODE_ENV === 'production'
        ? 'https://food-truck-finder-poc-git-feat-s-20ec1c-codedeficients-projects.vercel.app'
        : 'http://localhost:3000';
    const testUrl = generateOAuthTestUrl(baseUrl);
    return NextResponse.json({
        success: true,
        message: 'OAuth test URL generated',
        test_url: testUrl,
        environment: process.env.NODE_ENV ?? 'development',
        instructions: [
            '1. Open the test_url in a new browser tab',
            '2. Complete Google OAuth flow',
            '3. Verify redirect to admin dashboard',
            '4. Check for proper role assignment',
        ],
        manual_test_steps: [
            'Navigate to /login page',
            'Click Google login button',
            'Complete OAuth flow',
            'Verify admin access',
        ],
        automation_commands: [
            'npm run oauth:verify - Check configuration',
            'npm run oauth:test:dev - Test development flow',
            'npm run oauth:test:prod - Test production flow',
        ],
    });
}
/**
 * Retrieves the current OAuth status including configuration and connectivity information.
 * @example
 * getOAuthStatus().then(status =&gt; {
 *   console.log(status);
 * });
 * // Output: OAuthStatus object with current configuration and connection status details
 * @returns {Promise&lt;OAuthStatus&gt;} An object representing the current status of OAuth configuration and connectivity.
 * @description
 *   - The function assesses the connectivity and configuration of Supabase and its authentication settings.
 *   - It checks if the necessary environment variables are set.
 *   - Executes a series of asynchronous checks to determine if the OAuth provider is properly configured.
 *   - Recommendations for improving the OAuth setup are generated based on the current status.
 */
async function getOAuthStatus() {
    const status = {
        timestamp: new Date().toISOString(),
        environment: process.env.NODE_ENV === 'production' ? 'production' : 'development',
        supabase: {
            connected: false,
            projectId: 'zkwliyjjkdnigizidlln',
        },
        environment_variables: {
            supabaseUrl: process.env.NEXT_PUBLIC_SUPABASE_URL !== undefined,
            supabaseAnonKey: process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY !== undefined,
            supabaseServiceKey: process.env.SUPABASE_SERVICE_ROLE_KEY !== undefined,
        },
        oauth_flow: {
            loginPageExists: true,
            callbackRouteExists: true,
            authProviderConfigured: false,
        },
        recommendations: [],
        overall_status: 'not_configured',
    };
    await checkSupabaseConnection(status, supabase);
    await checkSupabaseAuthSettings(status);
    await testOAuthProvider(status, supabase);
    status.recommendations = generateRecommendations(status);
    status.overall_status = determineOverallStatus(status);
    return status;
}
/**
 * Checks the connection status with Supabase and updates the `OAuthStatus`.
 * @example
 * checkSupabaseConnection(status, supabase)
 * // Updates the `status.supabase.connected` property based on connection success
 * @param {OAuthStatus} status - The current OAuthStatus object that tracks connection state and errors.
 * @param {SupabaseClient} supabase - The Supabase client instance used to interact with the database.
 * @returns {void} No explicit return value, operates directly on the `status` object.
 * @description
 *   - Attempts a query to the 'profiles' table to ensure Supabase connection.
 *   - Updates `status.supabase.connected` based on query success.
 *   - Captures and records detailed error messages in case of connection failure.
 */
async function checkSupabaseConnection(status, supabase) {
    try {
        const { error } = await supabase.from('profiles').select('count').limit(1);
        if (error === null) {
            status.supabase.connected = true;
        }
        else {
            status.supabase.error = error.message;
        }
    }
    catch (error) {
        status.supabase.error = error instanceof Error ? error.message : 'Unknown connection error';
    }
}
/**
 * Checks and processes Supabase authentication settings.
 * @example
 * checkSupabaseAuthSettings(oAuthStatusInstance)
 * { supabase: { authSettings: { googleEnabled: true, signupEnabled: false, autoconfirm: true } } }
 * @param {OAuthStatus} status - An object that holds OAuth configuration status.
 * @returns {void} Modifies the passed status object with fetched authentication settings.
 * @description
 *   - The function fetches authentication settings from the Supabase URL defined in environment variables.
 *   - If Supabase settings are fetched successfully, it updates the OAuth status with authentication settings like Google integration, signup availability, and autoconfirm feature.
 *   - Provides a fallback log for cases where fetching settings require authentication.
 */
async function checkSupabaseAuthSettings(status) {
    try {
        const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;
        if (typeof supabaseUrl === 'string' &amp;&amp; supabaseUrl.length &gt; 0) {
            // Explicit check for undefined and empty string
            const settingsResponse = await fetch(`${supabaseUrl}/auth/v1/settings`);
            if (settingsResponse.ok === true) {
                const settings = (await settingsResponse.json());
                status.supabase.authSettings = {
                    googleEnabled: settings.external?.google ?? false,
                    signupEnabled: settings.disable_signup === false,
                    autoconfirm: settings.autoconfirm ?? false,
                };
                if (settings.external?.google !== undefined) {
                    // Explicit check for undefined
                    status.oauth_flow.authProviderConfigured = true;
                }
            }
        }
    }
    catch {
        console.info('Auth settings endpoint requires authentication (normal)');
    }
}
/**
 * Tests the configuration of an OAuth provider and updates the status based on the result.
 * @example
 * testOAuthProvider(status, supabase)
 * undefined
 * @param {OAuthStatus} status - An object representing the current OAuth status and configuration.
 * @param {SupabaseClient} supabase - The Supabase client instance used to interact with the authentication system.
 * @returns {void} Does not return any value.
 * @description
 *   - Utilizes Google as the OAuth provider for the sign-in attempt.
 *   - Redirects to a localhost callback URL to simulate the OAuth process.
 *   - Direct usage of the Supabase auth method to initiate OAuth process.
 *   - Handles exceptions without altering the control flow and logs them for informational purposes.
 */
async function testOAuthProvider(status, supabase) {
    try {
        const { error: oauthError } = await supabase.auth.signInWithOAuth({
            provider: 'google',
            options: {
                redirectTo: 'http://localhost:3000/auth/callback',
                skipBrowserRedirect: true,
            },
        });
        if (oauthError !== null &amp;&amp; oauthError.message !== 'Provider not found') {
            // Explicitly check for oauthError existence
            status.oauth_flow.authProviderConfigured = true;
        }
    }
    catch (error) {
        console.info('OAuth provider test failed (may be normal):', error);
    }
}
/**
 * Generates a list of recommendations for OAuth configuration based on the current status.
 * @example
 * generateRecommendations(status)
 * [' Configure NEXT_PUBLIC_SUPABASE_URL environment variable', ...]
 * @param {OAuthStatus} status - The current status of OAuth configuration and environment variables.
 * @returns {string[]} Array of recommendation messages to guide configuration setup.
 * @description
 *   - Checks for necessary environment variables and Supabase connectivity.
 *   - Provides guidance on enabling Google OAuth.
 *   - Suggests consulting documentation for further setup instructions.
 */
function generateRecommendations(status) {
    const recommendations = [];
    if (!status.environment_variables.supabaseUrl) {
        recommendations.push(' Configure NEXT_PUBLIC_SUPABASE_URL environment variable');
    }
    if (!status.environment_variables.supabaseAnonKey) {
        recommendations.push(' Configure NEXT_PUBLIC_SUPABASE_ANON_KEY environment variable');
    }
    if (!status.environment_variables.supabaseServiceKey) {
        recommendations.push(' Configure SUPABASE_SERVICE_ROLE_KEY environment variable');
    }
    if (!status.supabase.connected) {
        recommendations.push(' Fix Supabase connection issue');
        if (typeof status.supabase.error === 'string' &amp;&amp; status.supabase.error.length &gt; 0) {
            recommendations.push(`   Error: ${status.supabase.error}`);
        }
    }
    if (status.supabase.authSettings?.googleEnabled === true) {
        recommendations.push(' Google OAuth provider is enabled');
    }
    else {
        recommendations.push(' Enable Google OAuth provider in Supabase Dashboard', '   Go to: Authentication &gt; Providers &gt; Google');
    }
    if (status.overall_status === 'ready') {
        recommendations.push(' OAuth configuration is complete!', ' Test the login flow at /login');
    }
    if (recommendations.length &gt; 1) {
        recommendations.push(' See docs/GOOGLE_OAUTH_SETUP_GUIDE.md for detailed instructions', ' Run: npm run oauth:verify for automated checks');
    }
    return recommendations;
}
/**
 * Determines the overall OAuth status based on provided conditions.
 * @example
 * determineOverallStatus(status)
 * 'ready'
 * @param {OAuthStatus} status - The status object containing configuration details.
 * @returns {'ready' | 'partial' | 'not_configured' | 'error'} Overall status derived from the evaluations.
 * @description
 *   - Evaluates connectivity and configuration status from various parameters within the status object.
 *   - Prioritizes returning 'error' if Supabase connection fails or if an error is detected.
 *   - Checks completeness of environment variables before proceeding to other status evaluations.
 *   - Distinguishes between 'ready' and 'partial' based on specific OAuth settings.
 */
function determineOverallStatus(status) {
    // eslint-disable-next-line sonarjs/different-types-comparison
    if (!status.supabase.connected || status.supabase.error !== null) {
        return 'error';
    }
    const envVarsComplete = Object.values(status.environment_variables).every(Boolean);
    if (!envVarsComplete) {
        return 'not_configured';
    }
    if (status.supabase.authSettings?.googleEnabled &amp;&amp; status.oauth_flow.authProviderConfigured) {
        return 'ready';
    }
    if (status.supabase.connected &amp;&amp; envVarsComplete) {
        return 'partial';
    }
    return 'not_configured';
}
/**
 * Retrieves a human-readable message based on the OAuth configuration status.
 * @example
 * getStatusMessage('ready')
 * 'Google OAuth is fully configured and ready to use'
 * @param {string} status - The current status of the OAuth configuration.
 * @returns {string} A message explaining the OAuth configuration status.
 * @description
 *   - Handles several predefined status cases.
 *   - Provides feedback for both success and error states.
 *   - Returns a default message for unrecognized statuses.
 */
function getStatusMessage(status) {
    switch (status) {
        case 'ready': {
            return 'Google OAuth is fully configured and ready to use';
        }
        case 'partial': {
            return 'Basic configuration complete, OAuth provider needs setup';
        }
        case 'not_configured': {
            return 'Google OAuth is not configured';
        }
        case 'error': {
            return 'Configuration error detected';
        }
        default: {
            return 'Unknown configuration status';
        }
    }
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/api/admin/data-quality/handlers.js (Line 1:1 - Line 207:2), C:/AI/food-truck-finder-poc/dist/lib/api/admin/data-quality/handlers.js (Line 1:1 - Line 207:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn134" onclick="toggleCodeBlock('cloneGroup134', 'expandBtn134', 'collapseBtn134')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn134" onclick="toggleCodeBlock('cloneGroup134', 'expandBtn134', 'collapseBtn134')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup134"><code class="language-javascript text-sm text-gray-800">import { NextResponse } from 'next/server';
import { FoodTruckService } from '@/lib/supabase';
/**
 * Handles GET requests by executing different actions based on query parameters.
 * @example
 * handleGetRequest(request)
 * Returns a response based on the action specified in the query parameters.
 * @param {NextRequest} request - The incoming request object containing URL and query parameters.
 * @returns {Promise&lt;NextResponse&gt;} A Promise resolving to a NextResponse object with the result of the action.
 * @description
 *   - Processes 'stats', 'assess', and defaults actions based on the 'action' query parameter.
 *   - Requires 'truckId' for the 'assess' action; otherwise, returns a 400 error.
 *   - Utilizes async handling for processing actions.
 */
export async function handleGetRequest(request) {
    const { searchParams } = new URL(request.url);
    const action = searchParams.get('action');
    const truckId = searchParams.get('truckId');
    switch (action) {
        case 'stats': {
            return await handleStatsAction();
        }
        case 'assess': {
            if (!truckId) {
                return NextResponse.json({ success: false, error: 'Missing truckId for assess action' }, { status: 400 });
            }
            return await handleAssessAction(truckId);
        }
        default: {
            return await handleDefaultGetAction();
        }
    }
}
/**
* Handles different types of POST requests by determining the action and executing appropriate functions.
* @example
* handlePostRequest(request)
* NextResponse containing success status and result or error message
* @param {NextRequest} request - Incoming request object containing body data as JSON.
* @returns {Promise&lt;NextResponse&gt;} Response indicating success or failure and any relevant data or error messages.
* @description
*   - Validates request body to ensure it's a non-null object.
*   - Extracts action and truckId from request body to decide on processing steps.
*   - Handles actions like &quot;update-single&quot;, &quot;batch-update&quot;, and &quot;recalculate-all&quot;, returning an appropriate NextResponse.
*   - Responds with an error JSON if the action is unknown or if required fields are missing.
*/
export async function handlePostRequest(request) {
    const body = await request.json();
    if (typeof body !== 'object' || body === null) {
        return NextResponse.json({ success: false, error: 'Invalid request body' }, { status: 400 });
    }
    const { action, truckId } = body;
    switch (action) {
        case 'update-single': {
            if (truckId === undefined || truckId === '') {
                return NextResponse.json({ success: false, error: 'Missing truckId for update-single action' }, { status: 400 });
            }
            return await handleUpdateSingle(truckId);
        }
        case 'batch-update': {
            return handleBatchUpdate();
        }
        case 'recalculate-all': {
            return await handleRecalculateAll();
        }
        default: {
            return NextResponse.json({ success: false, error: `Unknown action: ${action}` }, { status: 400 });
        }
    }
}
async function handleStatsAction() {
    const qualityStats = await FoodTruckService.getDataQualityStats();
    return NextResponse.json({
        success: true,
        data: {
            ...qualityStats,
            timestamp: new Date().toISOString(),
        },
    });
}
/**
 * Processes and returns the assessment result of a food truck action by its ID.
 * @example
 * handleAssessAction(&quot;12345&quot;)
 * { success: true, data: { truckId: &quot;12345&quot;, truckName: &quot;Best Food Truck&quot;, currentScore: 95, timestamp: &quot;2023-10-05T14:48:00.000Z&quot; } }
 * @param {string} truckId - The identifier of the food truck to be assessed.
 * @returns {object} Returns a JSON response containing either the assessment data or an error.
 * @description
 *   - Retrieves data of the specified food truck using FoodTruckService.
 *   - Casts the retrieved data explicitly to a FoodTruck object type to ensure type safety.
 *   - Responds with a 404 status and the error description if the truck is not found.
 */
async function handleAssessAction(truckId) {
    const truckResult = await FoodTruckService.getTruckById(truckId);
    if ('error' in truckResult) {
        return NextResponse.json({ success: false, error: truckResult.error }, { status: 404 });
    }
    const truck = truckResult; // Explicitly cast to FoodTruck
    return NextResponse.json({
        success: true,
        data: {
            truckId,
            truckName: truck.name,
            currentScore: truck.data_quality_score,
            timestamp: new Date().toISOString(),
        },
    });
}
async function handleDefaultGetAction() {
    const qualityStats = await FoodTruckService.getDataQualityStats();
    return NextResponse.json({
        success: true,
        data: qualityStats,
    });
}
/**
 * Handles updating a single food truck's quality score and returns the result.
 * @example
 * handleUpdateSingle(&quot;1234&quot;)
 * { success: true, message: 'Quality score updated successfully', data: { truckId: '1234', truckName: 'Food Truck A', newScore: 95, verificationStatus: 'verified', timestamp: '2023-10-30T14:48:00.000Z' } }
 * @param {string} truckId - The unique identifier of the food truck to update.
 * @returns {Object} An object containing the success status, message, and either updated truck data or error information.
 * @description
 *   - Utilizes `FoodTruckService.getTruckById` to fetch truck details.
 *   - Responds differently based on whether an error is encountered or not.
 *   - Formats the response appropriately for successful updates.
 *   - Includes a timestamp in the response when successful.
 */
async function handleUpdateSingle(truckId) {
    const updatedTruckResult = await FoodTruckService.getTruckById(truckId);
    if ('error' in updatedTruckResult) {
        return NextResponse.json({ success: false, error: updatedTruckResult.error }, { status: 404 });
    }
    const updatedTruck = updatedTruckResult;
    return NextResponse.json({
        success: true,
        message: 'Quality score updated successfully',
        data: {
            truckId: updatedTruck.id,
            truckName: updatedTruck.name,
            newScore: updatedTruck.data_quality_score,
            verificationStatus: updatedTruck.verification_status,
            timestamp: new Date().toISOString(),
        },
    });
}
function handleBatchUpdate() {
    return NextResponse.json({
        success: true,
        message: 'Batch quality score update completed',
        data: {
            timestamp: new Date().toISOString(),
        },
    });
}
function updateSingleTruckQualityScore(truck) {
    try {
        // Placeholder for actual update logic if needed
        // DataQualityService.updateTruckQualityScore(truck.id);
        return true;
    }
    catch (error) {
        console.error(`Failed to update truck ${truck.id}:`, error);
        return false;
    }
}
/**
 * Recalculates the quality score for all food trucks.
 * @example
 * handleRecalculateAll()
 * { success: true, message: 'Quality score recalculation completed', data: { totalTrucks: 100, updated: 95, errors: 5, timestamp: '2023-10-07T10:30:00.000Z' } }
 * @param {undefined} undefined - No arguments are needed.
 * @returns {Object} JSON response with success status, message, and data containing recalculation statistics.
 * @description
 *   - Fetches all food trucks in batches for recalculation using the FoodTruckService.
 *   - Logs an error message if the API call to fetch all trucks fails.
 *   - Updates the `qualityScore` for each truck and maintains a count of successful and unsuccessful updates.
 */
async function handleRecalculateAll() {
    const allTrucksResult = await FoodTruckService.getAllTrucks(1000, 0);
    if (allTrucksResult.error !== undefined) {
        console.error('Error fetching all trucks for recalculation:', allTrucksResult.error);
        return NextResponse.json({ success: false, error: 'Failed to fetch trucks for recalculation' }, { status: 500 });
    }
    const { trucks } = allTrucksResult;
    let updated = 0;
    let errors = 0;
    for (const truck of trucks) {
        const success = updateSingleTruckQualityScore(truck);
        if (success) {
            updated += 1;
        }
        else {
            errors += 1;
        }
    }
    return NextResponse.json({
        success: true,
        message: 'Quality score recalculation completed',
        data: {
            totalTrucks: trucks.length,
            updated,
            errors,
            timestamp: new Date().toISOString(),
        },
    });
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/api/admin/data-cleanup/handlers.js (Line 3:41 - Line 246:2), C:/AI/food-truck-finder-poc/dist/lib/lib/api/admin/data-cleanup/handlers.js (Line 3:44 - Line 246:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn135" onclick="toggleCodeBlock('cloneGroup135', 'expandBtn135', 'collapseBtn135')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn135" onclick="toggleCodeBlock('cloneGroup135', 'expandBtn135', 'collapseBtn135')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup135"><code class="language-javascript text-sm text-gray-800">;
/**
 * Handles different types of data cleanup requests and returns appropriate responses.
 * @example
 * handlePostRequest({ action: 'full-cleanup', options: {} })
 * returns a promise resolving to a NextResponse with cleanup result
 * @param {DataCleanupRequestBody} body - Object containing an action type and optional parameters for the cleanup process.
 * @returns {Promise&lt;NextResponse&gt;} Resolves to a NextResponse object indicating success or failure with details about the performed action.
 * @description
 *   - Handles specific actions: 'full-cleanup', 'check-duplicates', 'merge-duplicates', 'dry-run'.
 *   - Defaults to returning an error response for unknown actions.
 *   - Provides flexibility in defining options for each specific cleanup action.
 *   - Integrates with Next.js response mechanism for API endpoints.
 */
export async function handlePostRequest(body) {
    const { action, options = {} } = body;
    switch (action) {
        case 'full-cleanup': {
            return await handleFullCleanup(options);
        }
        case 'check-duplicates': {
            return await handleCheckDuplicates(options);
        }
        case 'merge-duplicates': {
            return await handleMergeDuplicates(options);
        }
        case 'dry-run': {
            return await handleDryRun(options);
        }
        default: {
            return NextResponse.json({ success: false, error: `Unknown action: ${action}` }, { status: 400 });
        }
    }
}
/**
 * Processes a GET request and performs actions based on query parameters.
 * @example
 * handleGetRequest(request)
 * Promise&lt;NextResponse&gt;
 * @param {NextRequest} request - Incoming Next.js request object containing the URL and search parameters.
 * @returns {Promise&lt;NextResponse&gt;} Promise resolving to a NextResponse object.
 * @description
 *   - It extracts the `action` parameter from the request URL's query string.
 *   - Based on the action parameter value, it delegates the request to specific handlers like `handleGetStatus`, `handleGetPreview`, or `handleGetDefault`.
 *   - Handles asynchronous operations within the action cases when necessary (e.g., `preview`).
 *   - Ensures proper response handling while maintaining the server-side asynchronous flow.
 */
export async function handleGetRequest(request) {
    const { searchParams } = new URL(request.url);
    const action = searchParams.get('action');
    switch (action) {
        case 'status': {
            return handleGetStatus();
        }
        case 'preview': {
            return await handleGetPreview();
        }
        default: {
            return handleGetDefault();
        }
    }
}
/**
* Executes a full data cleanup operation based on provided options.
* @example
* handleFullCleanup({ batchSize: 100, dryRun: true, operations: ['removeDuplicates', 'optimizeData'] })
* Returns a JSON response confirming the success of the cleanup.
* @param {Object} options - Configuration for the cleanup operation.
* @returns {Promise&lt;Object&gt;} A JSON response with the cleanup result summary.
* @description
*   - Default batch size for cleanup is set to 50 if not specified.
*   - Supports a dry-run mode for testing cleanup without making changes.
*   - Utilizes operations parameter to specify types of cleanup tasks.
*   - Provides detailed summary in the response message.
*/
export async function handleFullCleanup(options) {
    const result = await BatchCleanupService.runFullCleanup({
        batchSize: options?.batchSize ?? 50,
        dryRun: options?.dryRun ?? false,
        operations: options?.operations,
    });
    return NextResponse.json({
        success: true,
        action: 'full-cleanup',
        result,
        message: `Cleanup completed: ${result.summary.trucksImproved} trucks improved, ${result.summary.duplicatesRemoved} duplicates removed`,
    });
}
/**
 * Handles the duplicate check functionality for truck data.
 * @example
 * handleCheckDuplicates({ options: { truckData: [...] } })
 * Returns a promise with a JSON response indicating success or failure of duplicate check.
 * @param {DataCleanupRequestBody['options']} options - The request body containing truck data to be checked.
 * @returns {Promise&lt;NextResponse&gt;} A promise that resolves to a NextResponse object containing the result of the duplicate check.
 * @description
 *   - Utilizes the Duplicate Prevention Service to verify the presence of duplicates.
 *   - Expects `truckData` within the provided options for processing.
 *   - Returns an error JSON response with status 400 if `truckData` is not supplied.
 */
export async function handleCheckDuplicates(options) {
    const { truckData } = options ?? {};
    if (!truckData) {
        return NextResponse.json({ success: false, error: 'Missing truckData for duplicate check' }, { status: 400 });
    }
    const duplicateCheck = await DuplicatePreventionService.checkForDuplicates(truckData);
    return NextResponse.json({
        success: true,
        action: 'check-duplicates',
        result: duplicateCheck,
    });
}
/**
* Handles the merge operation for duplicate truck entries.
* @example
* handleMergeDuplicates({ targetId: '123', sourceId: '456' })
* Returns a NextResponse indicating the success or failure of the merge operation.
* @param {DataCleanupRequestBody['options']} options - Options containing targetId and sourceId for the merge operation.
* @returns {Promise&lt;NextResponse&gt;} Returns a NextResponse object indicating the merge result.
* @description
*   - Utilizes DuplicatePreventionService to merge duplicate entries.
*   - Sends an error response with status 400 if targetId or sourceId is missing.
*/
export async function handleMergeDuplicates(options) {
    const { targetId, sourceId } = options ?? {};
    if (targetId === undefined || sourceId === undefined) {
        return NextResponse.json({ success: false, error: 'Missing targetId or sourceId for merge operation' }, { status: 400 });
    }
    const mergedTruck = await DuplicatePreventionService.mergeDuplicates(targetId, sourceId);
    return NextResponse.json({
        success: true,
        action: 'merge-duplicates',
        result: mergedTruck,
        message: `Successfully merged truck ${sourceId} into ${targetId}`,
    });
}
/**
 * Executes a dry run of the data cleanup process without making changes to the database.
 * @example
 * handleDryRun({ operations: ['deleteUnused', 'optimizeData'] })
 * Promise resolves to NextResponse with details of the dry run.
 * @param {DataCleanupRequestBody['options']} options - Cleanup options including operations to simulate.
 * @returns {Promise&lt;NextResponse&gt;} A response object indicating the success of the dry run and its results.
 * @description
 *   - Utilizes the BatchCleanupService to simulate cleanup operations.
 *   - Ensures no changes are made to the database during the dry run.
 *   - Provides details of simulated operations in the response result.
 */
export async function handleDryRun(options) {
    const result = await BatchCleanupService.runFullCleanup({
        ...options,
        operations: options?.operations,
        dryRun: true,
    });
    return NextResponse.json({
        success: true,
        action: 'dry-run',
        result,
        message: 'Dry run completed - no changes made to database',
    });
}
/**
* Returns the current status with details on available operations, default batch size, and dry-run support.
* @example
* handleGetStatus()
* returns a JSON response with success status and operational details
* @returns {NextResponse} JSON response containing operation details.
* @description
*   - Lists available operations such as 'remove_placeholders', 'normalize_phone', and more.
*   - Provides default batch size set to 50.
*   - Indicates support for dry-run operations.
*/
export function handleGetStatus() {
    return NextResponse.json({
        success: true,
        status: {
            available_operations: [
                'remove_placeholders',
                'normalize_phone',
                'fix_coordinates',
                'update_quality_scores',
                'merge_duplicates',
            ],
            default_batch_size: 50,
            supports_dry_run: true,
        },
    });
}
/**
 * Generates a preview of the batch cleanup process.
 * @example
 * handleGetPreview()
 * Promise&lt;NextResponse&gt;
 * @returns {Promise&lt;NextResponse&gt;} Returns a JSON response containing the cleanup preview.
 * @description
 *   - Utilizes the BatchCleanupService to execute a dry run with a specified batch size.
 *   - Extracts summary information including estimated improvements and duplicates removed.
 *   - Structures the operations in a detailed format for review.
 */
export async function handleGetPreview() {
    const result = await BatchCleanupService.runFullCleanup({
        batchSize: 10,
        dryRun: true,
    });
    return NextResponse.json({
        success: true,
        preview: {
            estimated_improvements: result.summary.trucksImproved,
            estimated_duplicates: result.summary.duplicatesRemoved,
            operations: result.operations.map((op) =&gt; ({
                type: op.type,
                description: op.description,
                affected_count: op.affectedCount,
            })),
        },
    });
}
/**
* Provides a JSON response containing available endpoints and actions related to data cleanup.
* @example
* handleGetDefault()
* Returns a JSON response with success status, endpoints, and actions.
* @returns {NextResponse} Returns a JSON response with structure defining success, endpoints, and actions related to data cleanup.
* @description
*   - The function targets administrative cleanup operations within the system.
*   - Provides metadata for functionalities aimed at data cleanup processes.
*   - Intended to support endpoint consumption and decision-making for administrative tasks.
*/
export function handleGetDefault() {
    return NextResponse.json({
        success: true,
        endpoints: [
            'GET /api/admin/data-cleanup?action=status - Get cleanup system status',
            'GET /api/admin/data-cleanup?action=preview - Preview cleanup changes',
            'POST /api/admin/data-cleanup - Run cleanup operations',
        ],
        actions: [
            'full-cleanup - Run all cleanup operations',
            'check-duplicates - Check if truck data is duplicate',
            'merge-duplicates - Merge two duplicate trucks',
            'dry-run - Preview changes without making them',
        ],
    });
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/api/admin/automated-cleanup/handlers.js (Line 2:34 - Line 461:2), C:/AI/food-truck-finder-poc/dist/lib/lib/api/admin/automated-cleanup/handlers.js (Line 2:37 - Line 461:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn137" onclick="toggleCodeBlock('cloneGroup137', 'expandBtn137', 'collapseBtn137')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn137" onclick="toggleCodeBlock('cloneGroup137', 'expandBtn137', 'collapseBtn137')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup137"><code class="language-javascript text-sm text-gray-800">;
/**
 * Handles post requests by executing specific actions based on the provided body.
 * @example
 * handlePostRequest({ action: 'run_scheduled', options: { key: 'value' } })
 * Returns the result of executing handleRunScheduled with the provided options.
 * @param {Object} body - The body of the request containing action type and optional parameters.
 * @param {string} body.action - The action to perform such as 'run_scheduled', 'update_schedule', etc.
 * @param {Object} [body.options] - Optional parameters for the specified action, default is an empty object.
 * @returns {Promise&lt;Object&gt;} Resolves with the result of the corresponding action handler or an error object for unknown actions.
 * @description
 *   - Supports multiple predefined actions like scheduling, running, and cleanup operations.
 *   - Provides feedback on available actions when an unknown action is specified.
 *   - Uses async functions to perform operations, ensuring asynchronous behavior.
 *   - Returns JSON responses compliant with NextResponse standards.
 */
function isRunScheduledOptions(obj) {
    return typeof obj.scheduleId === &quot;string&quot;;
}
function isRunImmediateOptions(obj) {
    return ((obj.operations === undefined || Array.isArray(obj.operations)) &amp;&amp;
        (obj.batchSize === undefined || typeof obj.batchSize === &quot;number&quot;) &amp;&amp;
        (obj.dryRun === undefined || typeof obj.dryRun === &quot;boolean&quot;));
}
function isScheduleCleanupOptions(obj) {
    return (typeof obj.name === &quot;string&quot; &amp;&amp;
        Array.isArray(obj.operations) &amp;&amp;
        typeof obj.schedule === &quot;string&quot; &amp;&amp;
        (obj.enabled === undefined || typeof obj.enabled === &quot;boolean&quot;));
}
function isUpdateScheduleOptions(obj) {
    return (typeof obj.scheduleId === &quot;string&quot; &amp;&amp;
        typeof obj.updates === &quot;object&quot;);
}
function isDeleteScheduleOptions(obj) {
    return typeof obj.scheduleId === &quot;string&quot;;
}
export async function handlePostRequest(body) {
    const { action, options = {} } = body;
    switch (action) {
        case 'run_scheduled': {
            if (!isRunScheduledOptions(options)) {
                return NextResponse.json({ success: false, error: 'Invalid options for run_scheduled' }, { status: 400 });
            }
            return await handleRunScheduled(options);
        }
        case 'run_immediate': {
            if (!isRunImmediateOptions(options)) {
                return NextResponse.json({ success: false, error: 'Invalid options for run_immediate' }, { status: 400 });
            }
            return await handleRunImmediate(options);
        }
        case 'schedule_cleanup': {
            if (!isScheduleCleanupOptions(options)) {
                return NextResponse.json({ success: false, error: 'Invalid options for schedule_cleanup' }, { status: 400 });
            }
            return await handleScheduleCleanup(options);
        }
        case 'update_schedule': {
            if (!isUpdateScheduleOptions(options)) {
                return NextResponse.json({ success: false, error: 'Invalid options for update_schedule' }, { status: 400 });
            }
            return await handleUpdateSchedule(options);
        }
        case 'delete_schedule': {
            if (!isDeleteScheduleOptions(options)) {
                return NextResponse.json({ success: false, error: 'Invalid options for delete_schedule' }, { status: 400 });
            }
            return await handleDeleteSchedule(options);
        }
        default: {
            return NextResponse.json({
                success: false,
                error: 'Unknown action',
                available_actions: [
                    'run_scheduled',
                    'run_immediate',
                    'schedule_cleanup',
                    'update_schedule',
                    'delete_schedule',
                    'analyze_duplicates',
                ],
            }, { status: 400 });
        }
    }
}
export async function handleGetStatus() {
    const status = await getCleanupStatus();
    return NextResponse.json({
        success: true,
        status,
    });
}
export async function handleGetSchedules() {
    const schedules = await getCleanupSchedules();
    return NextResponse.json({
        success: true,
        schedules,
    });
}
export async function handleGetHistory(searchParams) {
    const limit = Number.parseInt(searchParams.get('limit') ?? '10', 10);
    const history = await getCleanupHistory(limit);
    return NextResponse.json({
        success: true,
        history,
    });
}
export async function handleGetPreview(searchParams) {
    const operations = searchParams.get('operations')?.split(',') ?? [];
    const preview = await previewCleanupOperations(operations);
    return NextResponse.json({
        success: true,
        preview,
    });
}
/**
 * Handles the retrieval of default cleanup status and returns a JSON response.
 * @example
 * handleGetDefault().then(response =&gt; console.log(response));
 * // { success: true, status: ..., endpoints: [...] }
 * @param {none} {none} - No arguments are required for this function.
 * @returns {Promise&lt;NextResponse&gt;} A promise that resolves to a NextResponse JSON object containing cleanup status and endpoints.
 * @description
 *   - Utilizes the getCleanupStatus function to fetch the current cleanup status.
 *   - Constructs a response object detailing available cleanup-related endpoints.
 *   - Follow API endpoint descriptions to properly utilize cleanup functionalities.
 */
export async function handleGetDefault() {
    const status = await getCleanupStatus();
    return NextResponse.json({
        success: true,
        status,
        endpoints: [
            'GET ?action=status - Get overall cleanup status',
            'GET ?action=schedules - Get cleanup schedules',
            'GET ?action=history&amp;limit=N - Get cleanup history',
            'GET ?action=preview&amp;operations=op1,op2 - Preview cleanup operations',
            'POST - Run cleanup operations',
        ],
    });
}
export async function handleRunScheduled(options) {
    const { scheduleId } = options;
    const result = await runScheduledCleanup(scheduleId);
    return NextResponse.json({
        success: true,
        action: 'run_scheduled',
        result,
    });
}
/**
* Executes a batch cleanup operation immediately based on provided options.
* @example
* handleRunImmediate({ dryRun: true, batchSize: 100 })
* Returns: { success: true, action: 'run_immediate', result: {...}, message: 'Dry run completed successfully' }
* @param {Object} options - Configuration options for the cleanup operation.
* @returns {Promise&lt;NextResponse&gt;} A promise that resolves to the NextResponse object containing the cleanup result.
* @description
*   - The `operations` parameter defaults to a set of predefined cleanup tasks if not specified.
*   - If `dryRun` is true, the function simulates the cleanup without making any modifications.
*   - Utilizes `BatchCleanupService` for executing the cleanup logic.
*   - Operation results are logged with `logCleanupOperation` for tracking purposes.
*/
export async function handleRunImmediate(options) {
    const { operations = [
        'remove_placeholders',
        'normalize_phone',
        'fix_coordinates',
        'update_quality_scores',
    ], batchSize = 50, dryRun = false, } = options;
    const result = await BatchCleanupService.runFullCleanup({
        operations: operations,
        batchSize,
        dryRun,
    });
    await logCleanupOperation('immediate', result, options);
    return NextResponse.json({
        success: true,
        action: 'run_immediate',
        result,
        message: dryRun ? 'Dry run completed successfully' : 'Cleanup completed successfully',
    });
}
export async function handleScheduleCleanup(options) {
    const { name, operations, schedule, enabled = true } = options;
    const scheduleResult = await createCleanupSchedule(name, operations, schedule, enabled);
    return NextResponse.json({
        success: true,
        action: 'schedule_cleanup',
        result: scheduleResult,
    });
}
export async function handleUpdateSchedule(options) {
    const { scheduleId, updates } = options;
    const updateResult = await updateCleanupSchedule(scheduleId, updates);
    return NextResponse.json({
        success: true,
        action: 'update_schedule',
        result: updateResult,
    });
}
export async function handleDeleteSchedule(options) {
    const { scheduleId } = options;
    const deleteResult = await deleteCleanupSchedule(scheduleId);
    return NextResponse.json({
        success: true,
        action: 'delete_schedule',
        result: deleteResult,
    });
}
export async function handleAnalyzeDuplicates(options) {
    const { threshold = 0.8 } = options;
    const analysis = await analyzeDuplicates(threshold);
    return NextResponse.json({
        success: true,
        action: 'analyze_duplicates',
        result: analysis,
    });
}
/**
 * Retrieves the status of automated cleanup operations.
 * @example
 * getCleanupStatus()
 * // returns: Promise&lt;AutomatedCleanupStatus&gt;
 * @returns {Promise&lt;AutomatedCleanupStatus&gt;} An object representing the status of cleanup operations.
 * @description
 *   - The status includes statistics on cleanup runs such as total number of runs, successful runs, and failed runs.
 *   - Provides information on whether a cleanup operation is currently running and when it last ran.
 *   - Fetches schedules asynchronously using the getCleanupSchedules() function.
 *   - Includes data on recent cleanup results and operations performed, such as the number of trucks improved and duplicates removed.
 */
async function getCleanupStatus() {
    return {
        isRunning: false,
        lastRun: new Date(Date.now() - 3_600_000).toISOString(),
        nextScheduledRun: new Date(Date.now() + 3_600_000).toISOString(),
        schedules: await getCleanupSchedules(),
        recentResults: [],
        statistics: {
            totalRuns: 42,
            successfulRuns: 40,
            failedRuns: 2,
            trucksImproved: 156,
            duplicatesRemoved: 23,
        },
    };
}
/**
 * Retrieves the scheduled cleanup operations including their details.
 * @example
 * getCleanupSchedules()
 * Promise resolves to an array of cleanup schedule objects.
 * @returns {Promise&lt;CleanupSchedule[]&gt;} Promise resolving to an array of cleanup schedule objects.
 * @description
 *   - Schedules are defined using cron-like syntax for timing.
 *   - Both daily and weekly cleanup operations are included.
 *   - Each schedule has a record of success and error counts from the last execution.
 *   - Each schedule has a record of success and error counts from the last execution.
 *   - Enabled status indicates if the schedule is currently active.
 */
function getCleanupSchedules() {
    return Promise.resolve([
        {
            id: 'daily-maintenance',
            name: 'Daily Maintenance Cleanup',
            operations: ['remove_placeholders', 'normalize_phone', 'update_quality_scores'],
            schedule: '0 2 * * *',
            enabled: true,
            lastRun: new Date(Date.now() - 86_400_000).toISOString(),
            nextRun: new Date(Date.now() + 3_600_000).toISOString(),
            successCount: 30,
            errorCount: 1,
        },
        {
            id: 'weekly-deep-clean',
            name: 'Weekly Deep Cleanup',
            operations: [
                'remove_placeholders',
                'normalize_phone',
                'fix_coordinates',
                'update_quality_scores',
                'merge_duplicates',
            ],
            schedule: '0 3 * * 0',
            enabled: true,
            lastRun: new Date(Date.now() - 604_800_000).toISOString(),
            nextRun: new Date(Date.now() + 259_200_000).toISOString(),
            successCount: 4,
            errorCount: 0,
        },
    ]);
}
function getCleanupHistory(_limit) {
    return Promise.resolve([]);
}
/**
 * Generates a preview of cleanup operations and their estimated impact.
 * @example
 * previewCleanupOperations(['delete_logs', 'archive_data'])
 * // Returns a Promise resolving to an object with estimated changes and operation details
 * @param {string[]} operations - An array of cleanup operation names to preview.
 * @returns {Promise&lt;PreviewResult&gt;} A promise that resolves to a preview result containing estimated changes and details.
 * @description
 *   - The function uses BatchCleanupService to simulate cleanup operations in a dry-run mode.
 *   - Each operation's details include types, descriptions, and counts of affected, successful, and erroneous items.
 *   - Returns comprehensive information including estimated changes, durations, and affected entities.
 */
async function previewCleanupOperations(operations) {
    try {
        const result = await BatchCleanupService.runFullCleanup({
            operations: operations,
            batchSize: 10,
            dryRun: true,
        });
        return {
            estimatedChanges: result.summary,
            operationDetails: (() =&gt; {
                const details = {};
                for (const [index, op] of result.operations.entries()) {
                    details[`operation_${index}`] = {
                        type: op.type,
                        description: op.description,
                        affectedCount: op.affectedCount,
                        successCount: op.successCount,
                        errorCount: op.errorCount,
                    };
                }
                return details;
            })(),
            estimatedDuration: result.duration,
            affectedTrucks: result.totalProcessed,
        };
    }
    catch (error) {
        throw new Error(`Preview failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
}
/**
 * Executes a cleanup based on a given schedule ID.
 * @example
 * runScheduledCleanup('schedule123')
 * { success: true, cleanedRecords: 150 }
 * @param {string} scheduleId - The ID of the cleanup schedule to run.
 * @returns {Promise&lt;Record&lt;string, unknown&gt;&gt;} Result of the cleanup operation.
 * @description
 *   - Throws an error if the schedule is not found or is disabled.
 *   - Utilizes BatchCleanupService for performing the cleanup operation.
 *   - Logs the result of the cleanup operation with a 'scheduled' context.
 */
async function runScheduledCleanup(scheduleId) {
    const schedules = await getCleanupSchedules();
    const schedule = schedules.find((s) =&gt; s.id === scheduleId);
    if (!schedule) {
        throw new Error(`Schedule ${scheduleId} not found`);
    }
    if (!schedule.enabled) {
        throw new Error(`Schedule ${scheduleId} is disabled`);
    }
    const result = await BatchCleanupService.runFullCleanup({
        operations: schedule.operations,
        batchSize: 50,
        dryRun: false,
    });
    await logCleanupOperation('scheduled', result, { scheduleId });
    return result;
}
/**
* Creates a cleanup schedule with the specified parameters
* @example
* createCleanupSchedule('Daily Cleanup', ['delete', 'archive'], '0 0 * * *', true)
* Promise&lt;ScheduleCreateResult&gt; { id: 'schedule-1609459200000', name: 'Daily Cleanup', operations: ['delete', 'archive'], schedule: '0 0 * * *', enabled: true, created: '2021-01-01T00:00:00.000Z' }
* @param {string} name - The name of the cleanup schedule.
* @param {Array&lt;string&gt;} operations - List of operations to be included in the cleanup.
* @param {string} schedule - Cron-style string for schedule timings.
* @param {boolean} enabled - Status of whether the schedule is active.
* @returns {Promise&lt;ScheduleCreateResult&gt;} Promise resolving to the details of the created schedule.
* @description
*   - Returns a Promise that resolves to a ScheduleCreateResult object.
*   - Automatically generates a unique ID based on the current timestamp.
*   - Includes a creation timestamp in ISO format.
*/
function createCleanupSchedule(name, operations, schedule, enabled) {
    return Promise.resolve({
        id: `schedule-${Date.now()}`,
        name,
        operations,
        schedule,
        enabled,
        created: new Date().toISOString(),
    });
}
function updateCleanupSchedule(scheduleId, updates) {
    return Promise.resolve({
        scheduleId,
        updates,
        updated: new Date().toISOString(),
    });
}
function deleteCleanupSchedule(scheduleId) {
    return Promise.resolve({
        scheduleId,
        deleted: new Date().toISOString(),
    });
}
/**
* Analyzes duplicates based on a given threshold and returns a summary of the analysis.
* @example
* analyzeDuplicates(0.8)
* // Returns: { threshold: 0.8, potentialDuplicates: 0, highConfidenceMatches: 0, mediumConfidenceMatches: 0, lowConfidenceMatches: 0, analysisTime: &quot;2023-10-01T12:34:56.789Z&quot; }
* @param {number} threshold - The threshold value used to determine duplicate matching confidence.
* @returns {Promise&lt;DuplicateAnalysisResult&gt;} An object representing the duplicate analysis results including counts of potential matches and confidence levels.
* @description
*   - Executes the analysis asynchronously, returning a promise that resolves with the analysis results.
*   - Initializes match counts to zero as defaults.
*   - Includes the analysis time formatted as an ISO string.
*/
function analyzeDuplicates(threshold) {
    try {
        return Promise.resolve({
            threshold,
            potentialDuplicates: 0,
            highConfidenceMatches: 0,
            mediumConfidenceMatches: 0,
            lowConfidenceMatches: 0,
            analysisTime: new Date().toISOString(),
        });
    }
    catch (error) {
        throw new Error(`Duplicate analysis failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
}
/**
 * Logs the completion details of a cleanup operation.
 * @example
 * logCleanupOperation('database', {summary: {success: true}}, {verbose: true})
 * // No return value
 * @param {string} type - The type of cleanup operation performed (e.g., 'database').
 * @param {Record&lt;string, unknown&gt;} result - An object containing the results of the cleanup operation.
 * @param {Record&lt;string, unknown&gt;} options - Additional options related to the logging of the cleanup.
 * @returns {Promise&lt;void&gt;} A Promise that resolves when the logging is complete.
 * @description
 *   - Utilizes `console.info` for successful logging and `console.warn` for handling errors during logging.
 *   - Ensures the operation's details include the type, result summary, options, and a timestamp.
 */
function logCleanupOperation(type, result, options) {
    try {
        console.info(`Cleanup operation completed:`, {
            type,
            result: result.summary,
            options,
            timestamp: new Date().toISOString(),
        });
        return Promise.resolve();
    }
    catch (error) {
        console.warn('Failed to log cleanup operation:', error);
        return Promise.resolve();
    }
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/api/trucks/handlers.js (Line 2:27 - Line 24:4), C:/AI/food-truck-finder-poc/dist/lib/lib/api/trucks/handlers.js (Line 2:27 - Line 24:4)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn141" onclick="toggleCodeBlock('cloneGroup141', 'expandBtn141', 'collapseBtn141')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn141" onclick="toggleCodeBlock('cloneGroup141', 'expandBtn141', 'collapseBtn141')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup141"><code class="language-javascript text-sm text-gray-800">;
export async function handleGetTruckById(id) {
    const truckResult = await FoodTruckService.getTruckById(id);
    if ('error' in truckResult) {
        return NextResponse.json({ error: truckResult.error }, { status: 500 });
    }
    return NextResponse.json({ truck: truckResult });
}
/**
 * Retrieves a list of food trucks within a specified radius.
 * @example
 * handleGetTrucksByLocation(&quot;37.7749&quot;, &quot;-122.4194&quot;, &quot;5&quot;)
 * Returns an object with the list of nearby food trucks and additional metadata.
 * @param {string} lat - Latitude of the location from which to search for food trucks.
 * @param {string} lng - Longitude of the location from which to search for food trucks.
 * @param {string} radius - The radius (in kilometers) within which to find food trucks.
 * @returns {Object} An object containing a list of nearby food trucks along with metadata related to the query.
 * @description
 *   - Converts latitude, longitude, and radius from string to float.
 *   - Invokes an asynchronous service call to fetch trucks.
 *   - Returns an error message with status 500 if an error is encountered.
 *   - Currently, assumes no pagination is needed for location-based searches.
 */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/api/trucks/handlers.js (Line 25:1 - Line 54:4), C:/AI/food-truck-finder-poc/dist/lib/lib/api/trucks/handlers.js (Line 25:1 - Line 54:4)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn142" onclick="toggleCodeBlock('cloneGroup142', 'expandBtn142', 'collapseBtn142')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn142" onclick="toggleCodeBlock('cloneGroup142', 'expandBtn142', 'collapseBtn142')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup142"><code class="language-javascript text-sm text-gray-800">export async function handleGetTrucksByLocation(lat, lng, radius) {
    const userLat = Number.parseFloat(lat);
    const userLng = Number.parseFloat(lng);
    const radiusKm = Number.parseFloat(radius);
    const nearbyTrucks = await FoodTruckService.getTrucksByLocation(userLat, userLng, radiusKm);
    if ('error' in nearbyTrucks) {
        return NextResponse.json({ error: &quot;That didn't work, please try again later.&quot; }, { status: 500 });
    }
    return NextResponse.json({
        trucks: nearbyTrucks,
        total: nearbyTrucks.length,
        limit: nearbyTrucks.length, // Assuming no pagination for location-based
        offset: 0,
        hasMore: false,
    });
}
/**
 * Retrieves truck data with pagination support.
 * @example
 * handleGetAllTrucks(10, 0)
 * { trucks: [...], total: 100, limit: 10, offset: 0, hasMore: true, summary: {...} }
 * @param {number} limit - Number of trucks to retrieve per request.
 * @param {number} offset - Starting position of truck data to retrieve.
 * @returns {object} JSON response containing truck data, pagination information, and summary.
 * @description
 *   - Checks for errors returned by the FoodTruckService API and responds with a generic error message.
 *   - Computes an `averageQuality` score for the retrieved trucks.
 *   - Determines `hasMore` by comparing total trucks to limit and offset.
 *   - Calculates `lastUpdated` timestamp from truck data.
 */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/api/trucks/handlers.js (Line 55:1 - Line 87:3), C:/AI/food-truck-finder-poc/dist/lib/lib/api/trucks/handlers.js (Line 55:1 - Line 87:3)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn143" onclick="toggleCodeBlock('cloneGroup143', 'expandBtn143', 'collapseBtn143')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn143" onclick="toggleCodeBlock('cloneGroup143', 'expandBtn143', 'collapseBtn143')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup143"><code class="language-javascript text-sm text-gray-800">export async function handleGetAllTrucks(limit, offset) {
    const { trucks, total, error } = await FoodTruckService.getAllTrucks(limit, offset);
    if (error != undefined &amp;&amp; error !== '') {
        return NextResponse.json({ error: &quot;That didn't work, please try again later.&quot; }, { status: 500 });
    }
    const hasTrucks = Array.isArray(trucks) &amp;&amp; trucks.length &gt; 0;
    return NextResponse.json({
        trucks,
        total,
        limit,
        offset,
        hasMore: offset + limit &lt; (total ?? 0),
        summary: {
            totalTrucks: total,
            averageQuality: hasTrucks
                ? trucks.reduce((acc, t) =&gt; acc + (t.data_quality_score ?? 0), 0) / trucks.length
                : 0,
            lastUpdated: hasTrucks ? Math.max(...trucks.map((t) =&gt; new Date(t.updated_at).getTime())) : 0,
        },
    });
}
/**
* Handles the creation of a food truck by delegating to the FoodTruckService.
* @example
* handlePostTruck({ name: 'Best Food Truck', location: 'Downtown' })
* // returns a JSON response with status 201 and a success message
* @param {unknown} truckData - Data for creating a new food truck.
* @returns {object} JSON response indicating success or failure.
* @description
*   - Utilizes FoodTruckService to create a new truck record.
*   - Handles errors, logging them and returning appropriate HTTP statuses.
*   - Converts the data into a Partial&lt;FoodTruck&gt; type before passing it to the service.
*/</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/api/trucks/handlers.js (Line 88:1 - Line 117:4), C:/AI/food-truck-finder-poc/dist/lib/lib/api/trucks/handlers.js (Line 88:1 - Line 117:4)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn144" onclick="toggleCodeBlock('cloneGroup144', 'expandBtn144', 'collapseBtn144')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn144" onclick="toggleCodeBlock('cloneGroup144', 'expandBtn144', 'collapseBtn144')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup144"><code class="language-javascript text-sm text-gray-800">export async function handlePostTruck(truckData) {
    try {
        const newTruckResult = await FoodTruckService.createTruck(truckData);
        if ('error' in newTruckResult) {
            console.error('Error creating truck:', newTruckResult.error);
            return NextResponse.json({ error: newTruckResult.error }, { status: 500 });
        }
        return NextResponse.json({
            message: 'Food truck created successfully',
            truck: newTruckResult,
        }, { status: 201 });
    }
    catch (error) {
        console.error('Error in handlePostTruck:', error);
        return NextResponse.json({ error: 'An unexpected error occurred while creating the food truck.' }, { status: 500 });
    }
}
/**
 * Updates food truck information with given updates and returns the operation status.
 * @example
 * handlePutTruck('1234', { name: 'New Food Truck Name' })
 * { message: 'Food truck updated successfully', truck: updatedTruckResult }
 * @param {string} id - The ID of the food truck to be updated.
 * @param {unknown} updates - The updates to apply to the food truck as a partial object.
 * @returns {Promise&lt;NextResponse&gt;} A response indicating success or failure of the update operation in JSON format.
 * @description
 *   - The function uses FoodTruckService.updateTruck to apply updates.
 *   - It logs errors to the console if the update operation fails.
 *   - Responds with HTTP status 500 in case of any error during the update process.
 */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/api/trucks/handlers.js (Line 118:1 - Line 134:2), C:/AI/food-truck-finder-poc/dist/lib/lib/api/trucks/handlers.js (Line 118:1 - Line 134:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn145" onclick="toggleCodeBlock('cloneGroup145', 'expandBtn145', 'collapseBtn145')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn145" onclick="toggleCodeBlock('cloneGroup145', 'expandBtn145', 'collapseBtn145')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup145"><code class="language-javascript text-sm text-gray-800">export async function handlePutTruck(id, updates) {
    try {
        const updatedTruckResult = await FoodTruckService.updateTruck(id, updates);
        if ('error' in updatedTruckResult) {
            console.error('Error updating truck:', updatedTruckResult.error);
            return NextResponse.json({ error: updatedTruckResult.error }, { status: 500 });
        }
        return NextResponse.json({
            message: 'Food truck updated successfully',
            truck: updatedTruckResult,
        });
    }
    catch (error) {
        console.error('Error in handlePutTruck:', error);
        return NextResponse.json({ error: 'An unexpected error occurred while updating the food truck.' }, { status: 500 });
    }
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/api/test-integration/stageHandlers.js (Line 3:27 - Line 140:2), C:/AI/food-truck-finder-poc/dist/lib/api/test-integration/stageHandlers.js (Line 3:17 - Line 140:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn146" onclick="toggleCodeBlock('cloneGroup146', 'expandBtn146', 'collapseBtn146')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn146" onclick="toggleCodeBlock('cloneGroup146', 'expandBtn146', 'collapseBtn146')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup146"><code class="language-javascript text-sm text-gray-800">;
import { mapExtractedDataToTruckSchema } from './schemaMapper.js';
function getErrorMessage(error, fallback) {
    if (error instanceof Error)
        return error.message;
    if (typeof error === 'string')
        return error;
    return fallback;
}
async function handleUrlScrape(url, logs) {
    logs.push(`Starting Firecrawl scrape for URL: ${url}`);
    try {
        const fcOutput = await firecrawl.scrapeFoodTruckWebsite(url);
        if (fcOutput.success === true &amp;&amp;
            fcOutput.data?.markdown !== undefined &amp;&amp;
            fcOutput.data?.markdown !== '') {
            return {
                contentToProcess: fcOutput.data.markdown,
                sourceUrlForProcessing: fcOutput.data.source_url ?? url,
                firecrawlResult: {
                    status: 'Success',
                    rawContent: fcOutput.data.markdown,
                    metadata: { name: fcOutput.data.name, source_url: fcOutput.data.source_url },
                    details: `Markdown length: ${fcOutput.data.markdown.length}`,
                },
            };
        }
        else {
            throw new Error(fcOutput.error ?? 'Firecrawl failed to return markdown.');
        }
    }
    catch (error) {
        const errorMessage = getErrorMessage(error, 'An unknown error occurred during Firecrawl scrape.');
        logs.push(`Firecrawl error: ${errorMessage}`);
        return {
            firecrawlResult: { status: 'Error', error: errorMessage },
            contentToProcess: undefined,
            sourceUrlForProcessing: url,
        };
    }
}
function handleRawTextProcessing(rawText, logs) {
    logs.push('Using raw text input for processing.');
    return {
        contentToProcess: rawText,
        sourceUrlForProcessing: 'raw_text_input',
        firecrawlResult: {
            status: 'Skipped (Raw Text Provided)',
            details: `Raw text length: ${rawText.length}`,
        },
    };
}
function determineFirecrawlStageOutput(url, rawText, logs) {
    if (url &amp;&amp; rawText === undefined) {
        return handleUrlScrape(url, logs);
    }
    else if (rawText === undefined) {
        logs.push('No URL or raw text provided.');
        throw new Error('Either a URL or raw text must be provided for testing.');
    }
    else {
        return Promise.resolve(handleRawTextProcessing(rawText, logs));
    }
}
function handleEmptyContent(logs) {
    logs.push('Content to process is empty after Firecrawl/raw text stage.');
    throw new Error('Content to process is empty.');
}
export async function handleFirecrawlStage(url, rawText, logs) {
    const stageOutput = await determineFirecrawlStageOutput(url, rawText, logs);
    if (stageOutput.contentToProcess === undefined) {
        handleEmptyContent(logs);
    }
    return stageOutput;
}
export async function handleGeminiStage(contentToProcess, sourceUrlForProcessing, logs) {
    let geminiResult;
    let extractedData;
    logs.push('Starting Gemini processing.');
    try {
        const geminiOutput = await gemini.extractFoodTruckDetailsFromMarkdown(contentToProcess, sourceUrlForProcessing);
        if (geminiOutput.success === true &amp;&amp; geminiOutput.data !== undefined) {
            extractedData = geminiOutput.data;
            geminiResult = {
                status: 'Success',
                data: geminiOutput.data,
                tokensUsed: geminiOutput.tokensUsed,
                prompt: geminiOutput.promptSent,
                details: 'Gemini extraction successful.',
            };
            logs.push('Gemini processing successful.');
        }
        else {
            throw new Error(geminiOutput.error ?? 'Gemini processing failed to return data.');
        }
    }
    catch (error) {
        const errorMessage = getErrorMessage(error, 'An unknown error occurred during Gemini processing.');
        logs.push(`Gemini error: ${errorMessage}`);
        geminiResult = { status: 'Error', error: errorMessage };
    }
    return { geminiResult, extractedData };
}
async function saveToSupabase(truckDataToSave, logs) {
    logs.push('Attempting to save to Supabase (Dry Run is FALSE).');
    const createdTruckResult = await FoodTruckService.createTruck(truckDataToSave);
    if ('error' in createdTruckResult) {
        throw new Error(`Failed to create truck in Supabase: ${createdTruckResult.error}`);
    }
    const createdTruck = createdTruckResult;
    logs.push(`Data saved to Supabase. Record ID: ${createdTruck.id}`);
    return {
        status: 'Success (Saved)',
        preparedData: truckDataToSave,
        recordId: createdTruck.id,
        details: `Truck data saved with ID: ${createdTruck.id}`,
    };
}
export async function handleSupabaseStage(extractedData, sourceUrlForProcessing, isDryRun, logs) {
    logs.push('Preparing for Supabase interaction.');
    try {
        const truckDataToSave = mapExtractedDataToTruckSchema(extractedData, sourceUrlForProcessing, isDryRun);
        if (isDryRun) {
            logs.push('Supabase interaction skipped (Dry Run).');
            return {
                status: 'Success (Dry Run)',
                preparedData: truckDataToSave,
                details: 'Dry Run: Data was prepared but not saved.',
            };
        }
        return await saveToSupabase(truckDataToSave, logs);
    }
    catch (error) {
        const errorMessage = getErrorMessage(error, 'An unknown error occurred during Supabase interaction.');
        logs.push(`Supabase interaction error: ${errorMessage}`);
        return { status: 'Error', error: errorMessage };
    }
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/api/test-integration/schemaMapper.js (Line 1:1 - Line 46:2), C:/AI/food-truck-finder-poc/dist/lib/lib/api/test-integration/schemaMapper.js (Line 1:1 - Line 46:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn147" onclick="toggleCodeBlock('cloneGroup147', 'expandBtn147', 'collapseBtn147')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn147" onclick="toggleCodeBlock('cloneGroup147', 'expandBtn147', 'collapseBtn147')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup147"><code class="language-javascript text-sm text-gray-800">export function mapExtractedDataToTruckSchema(extractedData, sourceUrl, isDryRun) {
    if (!extractedData || typeof extractedData !== 'object') {
        throw new Error('Invalid extractedData for mapping.');
    }
    const name = extractedData.name ?? 'Unknown Test Truck';
    const locationData = extractedData.current_location ?? {};
    const fullAddress = [
        locationData.address,
        locationData.city,
        locationData.state,
        locationData.zip_code,
    ]
        .filter(Boolean)
        .join(', ');
    return {
        name: name,
        description: extractedData.description ?? undefined,
        current_location: {
            lat: locationData.lat ?? 0,
            lng: locationData.lng ?? 0,
            address: fullAddress ?? locationData.raw_text ?? undefined,
            timestamp: new Date().toISOString(),
        },
        scheduled_locations: extractedData.scheduled_locations ?? undefined,
        operating_hours: extractedData.operating_hours ?? undefined,
        menu: (extractedData.menu ?? []).map((category) =&gt; ({
            name: category.name ?? 'Uncategorized',
            items: (category.items ?? []).map((item) =&gt; ({
                name: item.name ?? 'Unknown Item',
                description: item.description ?? undefined,
                price: typeof item.price === 'number' || typeof item.price === 'string' ? item.price : undefined,
                dietary_tags: item.dietary_tags ?? [],
            })),
        })),
        contact_info: extractedData.contact_info ?? undefined,
        social_media: extractedData.social_media ?? undefined,
        cuisine_type: extractedData.cuisine_type ?? [],
        price_range: extractedData.price_range ?? undefined,
        specialties: extractedData.specialties ?? [],
        data_quality_score: isDryRun ? 0.5 : 0.6, // Differentiate test/dry run
        verification_status: 'pending',
        source_urls: [sourceUrl].filter(Boolean),
        last_scraped_at: new Date().toISOString(),
        ...(isDryRun &amp;&amp; { test_run_flag: true }), // Add a flag for actual test saves if needed
    };
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/api/test-integration/pipelineRunnerHelpers.js (Line 1:1 - Line 147:2), C:/AI/food-truck-finder-poc/dist/lib/api/test-integration/pipelineRunnerHelpers.js (Line 1:1 - Line 147:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn148" onclick="toggleCodeBlock('cloneGroup148', 'expandBtn148', 'collapseBtn148')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn148" onclick="toggleCodeBlock('cloneGroup148', 'expandBtn148', 'collapseBtn148')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup148"><code class="language-javascript text-sm text-gray-800">import { handleFirecrawlStage, handleGeminiStage, handleSupabaseStage } from './stageHandlers.js';
// Helper function to handle stage errors and return a consistent error object
function handleStageErrorAndReturn(firecrawlResult, geminiResult, supabaseResult, logs) {
    return {
        firecrawl: firecrawlResult,
        gemini: geminiResult,
        supabase: supabaseResult,
        logs,
        overallStatus: 'Error',
    };
}
// Helper function to process the Firecrawl stage
async function processFirecrawlStage(url, rawText, logs) {
    const firecrawlStageOutput = await handleFirecrawlStage(url ?? '', rawText, logs);
    const { firecrawlResult, contentToProcess, sourceUrlForProcessing } = firecrawlStageOutput;
    if (firecrawlResult.status === 'Error') {
        return undefined;
    }
    return { firecrawlResult, contentToProcess, sourceUrlForProcessing };
}
// Helper function to process the Gemini stage
async function processGeminiStage(contentToProcess, sourceUrlForProcessing, logs) {
    if (contentToProcess === undefined) {
        logs.push('Content to process is undefined before Gemini stage.');
        return undefined;
    }
    const geminiStageOutput = await handleGeminiStage(contentToProcess, sourceUrlForProcessing, logs);
    const { geminiResult, extractedData } = geminiStageOutput;
    if (geminiResult.status === 'Error' || extractedData === undefined) {
        logs.push(`Gemini stage failed or returned no data. Status: ${geminiResult.status}, Data: ${JSON.stringify(extractedData)}`);
        return undefined;
    }
    return { geminiResult, extractedData };
}
// Helper function to process the Supabase stage
async function processSupabaseStage(extractedData, sourceUrlForProcessing, isDryRun, logs) {
    const supabaseResult = await handleSupabaseStage(extractedData, sourceUrlForProcessing, isDryRun, logs);
    if (supabaseResult.status === 'Error') {
        return undefined;
    }
    return supabaseResult;
}
// Helper function to handle the result of the Gemini stage
function handleGeminiStageResult(geminiStage, firecrawlResult, logs) {
    if (geminiStage === undefined) {
        return {
            status: 'Error',
            result: handleStageErrorAndReturn(firecrawlResult, { status: 'Error', error: 'Gemini stage failed' }, undefined, logs),
        };
    }
    const { geminiResult, extractedData } = geminiStage;
    if (extractedData === undefined) {
        return {
            status: 'Error',
            result: handleStageErrorAndReturn(firecrawlResult, geminiResult, { status: 'Error', error: 'Extracted data is undefined after Gemini stage' }, logs),
        };
    }
    return { status: 'Success', geminiResult, extractedData };
}
// Type guard for PipelineRunResult
function isPipelineRunResult(obj) {
    return (typeof obj === 'object' &amp;&amp;
        obj !== null &amp;&amp;
        'overallStatus' in obj &amp;&amp;
        obj.overallStatus === 'Error');
}
// Define Gemini and Supabase stage helpers before runTestPipeline and ensure they are async if needed
async function handleGeminiStagePipeline(contentToProcess, sourceUrlForProcessing, logs, firecrawlResult) {
    const geminiStage = await processGeminiStage(contentToProcess, sourceUrlForProcessing, logs);
    const geminiStageHandled = handleGeminiStageResult(geminiStage, firecrawlResult, logs);
    if (geminiStageHandled.status === 'Error') {
        return geminiStageHandled.result;
    }
    return geminiStageHandled;
}
// Make handleSupabaseStagePipeline async and ensure it is awaited in runTestPipeline
async function handleSupabaseStagePipeline(config) {
    const { extractedData, sourceUrlForProcessing, isDryRun, logs, firecrawlResult, geminiResult } = config;
    const supabaseStage = await processSupabaseStage(extractedData, sourceUrlForProcessing, isDryRun, logs);
    if (supabaseStage === undefined) {
        return handleStageErrorAndReturn(firecrawlResult, geminiResult, { status: 'Error', error: 'Supabase stage failed' }, logs);
    }
    return supabaseStage;
}
// Helper function to handle the Firecrawl stage within the pipeline
async function executeFirecrawlStage(url, rawText, logs) {
    const firecrawlStageOutput = await processFirecrawlStage(url ?? '', rawText, logs);
    if (!firecrawlStageOutput) {
        return handleStageErrorAndReturn({ status: 'Error', error: 'Firecrawl stage failed' }, undefined, undefined, logs);
    }
    return firecrawlStageOutput;
}
// Helper function to handle the Gemini stage within the pipeline
async function executeGeminiStage(contentToProcess, sourceUrlForProcessing, logs, firecrawlResult) {
    const geminiStageHandled = await handleGeminiStagePipeline(contentToProcess, sourceUrlForProcessing, logs, firecrawlResult);
    if ('overallStatus' in geminiStageHandled) {
        return geminiStageHandled;
    }
    return geminiStageHandled;
}
// Helper function to handle the Supabase stage within the pipeline
async function executeSupabaseStage(config) {
    const supabaseStage = await handleSupabaseStagePipeline(config);
    return supabaseStage;
}
// Generic helper to execute a pipeline stage and handle its result
async function executePipelineStage(stageFunction, args) {
    const output = await stageFunction(...args);
    return output;
}
// Extracted helper function for pipeline execution
export async function executePipeline(url, rawText, isDryRun, logs) {
    const firecrawlOutput = await executePipelineStage(executeFirecrawlStage, [
        url ?? '',
        rawText,
        logs,
    ]);
    if (isPipelineRunResult(firecrawlOutput)) {
        return firecrawlOutput;
    }
    const { firecrawlResult, contentToProcess, sourceUrlForProcessing } = firecrawlOutput;
    const geminiResultObject = await executeGeminiStage(contentToProcess, sourceUrlForProcessing, logs, firecrawlResult);
    if (isPipelineRunResult(geminiResultObject)) {
        return geminiResultObject;
    }
    const { geminiResult, extractedData } = geminiResultObject;
    const supabaseOutput = await executePipelineStage(executeSupabaseStage, [
        {
            extractedData,
            sourceUrlForProcessing,
            isDryRun,
            logs,
            firecrawlResult,
            geminiResult,
        },
    ]);
    if (isPipelineRunResult(supabaseOutput)) {
        return supabaseOutput;
    }
    return {
        firecrawl: firecrawlResult,
        gemini: geminiResult,
        supabase: supabaseOutput,
        logs: [...logs, 'Test pipeline run completed successfully.'],
        overallStatus: 'Success',
    };
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/api/test-integration/helpers.js (Line 3:27 - Line 156:2), C:/AI/food-truck-finder-poc/dist/lib/lib/api/test-integration/helpers.js (Line 3:27 - Line 156:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn150" onclick="toggleCodeBlock('cloneGroup150', 'expandBtn150', 'collapseBtn150')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn150" onclick="toggleCodeBlock('cloneGroup150', 'expandBtn150', 'collapseBtn150')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup150"><code class="language-javascript text-sm text-gray-800">;
// Helper function to test Firecrawl scraping
export async function testFirecrawlScraping(testUrl) {
    console.info('Testing Firecrawl scraping...');
    const scrapeResult = await firecrawl.scrapeUrl(testUrl, {
        formats: ['markdown'],
        onlyMainContent: true,
    });
    if (!scrapeResult.success) {
        return {
            success: false,
            error: 'Firecrawl test failed',
            details: scrapeResult.error,
        };
    }
    return { success: true, result: scrapeResult };
}
// Helper function to test Gemini processing
export async function testGeminiProcessing() {
    console.info('Testing Gemini processing...');
    const testMenuText = 'Burgers: Classic Burger $12.99, Veggie Burger $11.99. Sides: Fries $4.99, Onion Rings $5.99';
    const geminiResult = await gemini.processMenuData(testMenuText);
    if (!geminiResult.success) {
        return {
            success: false,
            error: 'Gemini test failed',
            details: geminiResult.error,
        };
    }
    return { success: true, result: geminiResult };
}
async function createTestFoodTruck(testUrl, menuData) {
    const result = await FoodTruckService.createTruck({
        name: 'Test Food Truck',
        description: 'Integration test truck',
        current_location: {
            lat: 37.7749,
            lng: -122.4194,
            address: 'San Francisco, CA',
            timestamp: new Date().toISOString(),
        },
        scheduled_locations: [],
        operating_hours: {
            monday: { closed: true },
            tuesday: { closed: true },
            wednesday: { closed: true },
            thursday: { closed: true },
            friday: { closed: true },
            saturday: { closed: true },
            sunday: { closed: true },
        },
        menu: menuData,
        contact_info: { phone: '+1-555-TEST', email: undefined, website: undefined },
        social_media: {
            instagram: undefined,
            facebook: undefined,
            twitter: undefined,
            tiktok: undefined,
            yelp: undefined,
        },
        source_urls: [testUrl],
        data_quality_score: 0.8,
        verification_status: 'pending',
    });
    if ('error' in result) {
        throw new Error(`Failed to create test food truck: ${result.error}`);
    }
    return result;
}
function createTestScrapingJob(testUrl) {
    return ScrapingJobService.createJob({
        job_type: 'integration_test',
        target_url: testUrl,
        priority: 10,
        scheduled_at: new Date().toISOString(),
    });
}
function addTestToProcessingQueue(truckId) {
    return DataProcessingService.addToQueue({
        truck_id: truckId,
        processing_type: 'integration_test',
        raw_data: { test: true },
        priority: 10,
    });
}
// Helper function to test Supabase operations
export async function testSupabaseOperations(testUrl, geminiResult) {
    // Create a test food truck
    const testTruck = await createTestFoodTruck(testUrl, geminiResult.data ?? []);
    // Create a test scraping job
    const testJob = await createTestScrapingJob(testUrl);
    // Add to processing queue
    const queueItem = await addTestToProcessingQueue(testTruck.id);
    // Test geospatial query
    const nearbyTrucksResult = await FoodTruckService.getTrucksByLocation(37.7749, -122.4194, 10);
    if ('error' in nearbyTrucksResult) {
        throw new Error(`Failed to get nearby trucks: ${nearbyTrucksResult.error}`);
    }
    const nearbyTrucks = nearbyTrucksResult;
    return {
        testTruck,
        testJob,
        queueItem,
        nearbyTrucks,
    };
}
// Helper function to format test results
export function formatTestResults(scrapeResult, geminiResult, supabaseResults) {
    return {
        success: true,
        message: 'Integration test completed successfully',
        results: {
            firecrawl: {
                success: scrapeResult.result?.success ?? false,
                dataLength: scrapeResult.result?.data?.markdown?.length ?? 0,
            },
            gemini: {
                success: geminiResult.success,
                tokensUsed: geminiResult.tokensUsed,
                categoriesFound: geminiResult.data?.length ?? 0,
            },
            supabase: {
                truckCreated: supabaseResults.testTruck.id,
                jobCreated: supabaseResults.testJob.id,
                queueItemCreated: supabaseResults.queueItem.id,
                nearbyTrucksFound: supabaseResults.nearbyTrucks.length,
            },
        },
        testData: {
            truck: supabaseResults.testTruck,
            processedMenu: geminiResult.data,
            nearbyTrucks: supabaseResults.nearbyTrucks.slice(0, 3),
        },
    };
}
export async function runIntegrationTestSteps(testUrl) {
    console.info('Starting integration test...');
    // Step 1: Test Firecrawl scraping
    const firecrawlTest = await testFirecrawlScraping(testUrl);
    if (!firecrawlTest.success) {
        return firecrawlTest;
    }
    // Step 2: Test Gemini processing
    const geminiTest = await testGeminiProcessing();
    if (!geminiTest.success) {
        return geminiTest;
    }
    // Step 3: Test Supabase operations
    console.info('Testing Supabase operations...');
    const supabaseResults = await testSupabaseOperations(testUrl, geminiTest.result);
    // Step 4: Format and return results
    const results = formatTestResults(firecrawlTest, geminiTest.result, supabaseResults);
    return { success: true, results };
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/api/tavily/handlers.js (Line 1:1 - Line 115:2), C:/AI/food-truck-finder-poc/dist/lib/lib/api/tavily/handlers.js (Line 1:1 - Line 115:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn151" onclick="toggleCodeBlock('cloneGroup151', 'expandBtn151', 'collapseBtn151')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn151" onclick="toggleCodeBlock('cloneGroup151', 'expandBtn151', 'collapseBtn151')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup151"><code class="language-javascript text-sm text-gray-800">/**
 * Sends a search query to the Tavily API and retrieves results.
 * @example
 * callTavilySearchApi('your_api_key', { query: 'example search', limit: 5 })
 * Returns an object containing a list of search results including titles and URLs.
 * @param {string} apiKey - The API key used for authorization with the Tavily API.
 * @param {Record&lt;string, unknown&gt;} params - An object containing search parameters such as the query and limits.
 * @returns {Object} An object containing search results with titles, URLs, and content.
 * @description
 *   - Uses fetch API to send a POST request to Tavily's search endpoint.
 *   - Automatically includes relevant headers for JSON content type and authorization.
 *   - Provides default values for certain parameters (e.g., max_results and search_depth).
 *   - Maps and structures the results before returning them to ensure consistency in the returned format.
 */
async function callTavilySearchApi(apiKey, params) {
    const response = await fetch('https://api.tavily.com/search', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            Authorization: `Bearer ${apiKey}`,
        },
        body: JSON.stringify({
            query: params.query ?? params.q,
            max_results: params.limit ?? 10,
            search_depth: params.search_depth ?? 'advanced',
            include_answer: true,
            include_raw_content: true,
        }),
    });
    if (!response.ok) {
        const errorText = await response.text();
        console.error('Tavily API error response:', errorText);
        throw new Error(`Tavily API error: ${response.status} ${response.statusText} - ${errorText}`);
    }
    const data = (await response.json());
    return {
        results: data.results?.map((result) =&gt; ({
            title: result.title,
            url: result.url,
            content: result.content,
            raw_content: result.raw_content,
        })) ?? [],
    };
}
/**
 * Performs a search operation using Tavily API or returns mock data if API key is unavailable.
 * @example
 * performTavilySearch({ location: 'South Carolina', query: 'food trucks' })
 * { results: [{ title: 'South Carolina Food Trucks (Mock)', url: 'https://example-foodtruck1.com', ... }] }
 * @param {Record&lt;string, unknown&gt;} params - Parameters for the Tavily API search.
 * @returns {Promise&lt;any&gt;} The search results from the Tavily API or mock data.
 * @description
 *   - Utilizes the TAVILY_API_KEY from environment variables to make API requests.
 *   - Returns mock data if the API key is missing or empty.
 *   - Logs a warning if mock data is being used due to missing API key.
 *   - Throws an error if the Tavily API call fails.
 */
export async function performTavilySearch(params) {
    const apiKey = process.env.TAVILY_API_KEY;
    if (apiKey === undefined || apiKey === '') {
        console.warn('TAVILY_API_KEY not found, using mock data');
        return {
            results: [
                {
                    title: 'South Carolina Food Trucks (Mock)',
                    url: 'https://example-foodtruck1.com',
                    content: 'Check out the best food trucks in South Carolina. Visit https://carolinabbq.com for amazing BBQ on wheels.',
                    raw_content: 'Carolina BBQ Food Truck serves authentic South Carolina barbecue...',
                },
                {
                    title: 'Charleston Mobile Food Directory (Mock)',
                    url: 'https://example-directory.com',
                    content: 'Directory of Charleston area food trucks including https://charlestontacos.com and https://lowcountryeats.com',
                    raw_content: 'Complete listing of mobile food vendors in the Charleston area...',
                },
            ],
        };
    }
    try {
        return await callTavilySearchApi(apiKey, params);
    }
    catch (error) {
        console.error('Tavily API call failed:', error);
        throw error;
    }
}
/**
* Performs a mock Tavily crawl operation.
* @example
* performTavilyCrawl({ key: 'value' })
* { results: [ { url: 'https://example-crawled-truck.com', title: 'Gourmet Food Truck', content: 'Premium mobile dining experience...' } ] }
* @param {Record&lt;string, unknown&gt;} params - Parameters for the mock crawl operation.
* @returns {Object} An object containing mock crawl results.
* @description
*   - Utilizes a mock implementation for demonstration purposes.
*   - Logs the crawling parameters to the console for debugging.
*/
export function performTavilyCrawl(params) {
    console.info('Mock Tavily crawl with params:', params);
    return {
        results: [
            {
                url: 'https://example-crawled-truck.com',
                title: 'Gourmet Food Truck',
                content: 'Premium mobile dining experience...',
            },
        ],
    };
}
export function performTavilyMap(params) {
    console.info('Mock Tavily map with params:', params);
    return {
        results: ['https://foodtruckdirectory.com/truck1', 'https://foodtruckdirectory.com/truck2'],
    };
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/api/search/helpers.js (Line 9:1 - Line 37:2), C:/AI/food-truck-finder-poc/dist/lib/lib/api/search/helpers.js (Line 9:1 - Line 37:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn153" onclick="toggleCodeBlock('cloneGroup153', 'expandBtn153', 'collapseBtn153')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn153" onclick="toggleCodeBlock('cloneGroup153', 'expandBtn153', 'collapseBtn153')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup153"><code class="language-javascript text-sm text-gray-800">export async function processSearchRequest(request) {
    const { searchParams } = new URL(request.url);
    const query = searchParams.get('q');
    const cuisine = searchParams.get('cuisine');
    const openNow = searchParams.get('openNow') === 'true';
    const lat = searchParams.get('lat');
    const lng = searchParams.get('lng');
    const radius = searchParams.get('radius');
    let trucks = await getAndFilterFoodTrucks(lat, lng, radius);
    // Apply filters
    trucks = applyTextSearchFilter(trucks, query);
    trucks = applyCuisineFilter(trucks, cuisine);
    trucks = applyOpenNowFilter(trucks, openNow);
    // Sort by data quality score
    const filteredAndSortedTrucks = sortFoodTrucksByQuality(trucks);
    return NextResponse.json({
        trucks: filteredAndSortedTrucks,
        total: filteredAndSortedTrucks.length,
        filters: {
            query,
            cuisine,
            openNow,
            location: lat != undefined &amp;&amp; lng != undefined
                ? { lat: Number.parseFloat(lat), lng: Number.parseFloat(lng) }
                : undefined,
            radius: Number.parseFloat(radius ?? '10'),
        },
    });
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/api/search/filters.js (Line 1:1 - Line 67:2), C:/AI/food-truck-finder-poc/dist/lib/lib/api/search/filters.js (Line 1:1 - Line 67:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn154" onclick="toggleCodeBlock('cloneGroup154', 'expandBtn154', 'collapseBtn154')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn154" onclick="toggleCodeBlock('cloneGroup154', 'expandBtn154', 'collapseBtn154')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup154"><code class="language-javascript text-sm text-gray-800">/**
* Filters an array of FoodTruck objects based on a given search query.
* @example
* applyTextSearchFilter(foodTrucksArray, 'taco')
* // Returns an array of FoodTruck objects where the truck name, description, or menu contains 'taco'
* @param {FoodTruck[]} trucks - An array of FoodTruck objects to be filtered.
* @param {string | null} query - Search query to filter the food trucks by.
* @returns {FoodTruck[]} An array of FoodTruck objects that match the search query.
* @description
*   - If the query is null or an empty string, the original array is returned unfiltered.
*   - The search is case-insensitive.
*   - Searches through truck names, descriptions, and menu item names and descriptions.
*   - Utilizes optional chaining to handle undefined or null values in truck descriptions and menus.
*/
export function applyTextSearchFilter(trucks, query) {
    if (query != undefined &amp;&amp; query !== '') {
        return trucks.filter((truck) =&gt; truck.name.toLowerCase().includes(query.toLowerCase()) ||
            (truck.description?.toLowerCase().includes(query.toLowerCase()) ?? false) ||
            (truck.menu?.some((category) =&gt; category.items?.some((item) =&gt; item.name.toLowerCase().includes(query.toLowerCase()) ||
                (item.description?.toLowerCase().includes(query.toLowerCase()) ?? false))) ??
                false));
    }
    return trucks;
}
export function applyCuisineFilter(trucks, cuisine) {
    if (cuisine != undefined &amp;&amp; cuisine !== '') {
        return trucks.filter((truck) =&gt; truck.menu?.some((category) =&gt; category.name.toLowerCase().includes(cuisine.toLowerCase())));
    }
    return trucks;
}
/**
 * Filters a list of food trucks to only include those that are currently open.
 * @example
 * applyOpenNowFilter(trucks, true)
 * // returns list of trucks open at the current date and time
 * @param {FoodTruck[]} trucks - Array of food truck objects to be filtered.
 * @param {boolean} openNow - Flag to filter trucks that are open at the current time.
 * @returns {FoodTruck[]} Array of food trucks that are open now, or the unfiltered array if openNow is false.
 * @description
 *   - Uses the system's current date and time to determine if trucks are open.
 *   - Filters based on the truck's operating hours for the current day.
 */
export function applyOpenNowFilter(trucks, openNow) {
    if (openNow) {
        const now = new Date();
        const daysOfWeek = [
            'sunday',
            'monday',
            'tuesday',
            'wednesday',
            'thursday',
            'friday',
            'saturday',
        ];
        const currentDay = daysOfWeek[now.getDay()];
        const currentTime = now.getHours() * 100 + now.getMinutes();
        return trucks.filter((truck) =&gt; {
            const hours = truck.operating_hours?.[currentDay];
            if (!hours || hours.closed)
                return false;
            const openTime = Number.parseInt(hours.open.replace(':', ''), 10);
            const closeTime = Number.parseInt(hours.close.replace(':', ''), 10);
            return currentTime &gt;= openTime &amp;&amp; currentTime &lt;= closeTime;
        });
    }
    return trucks;
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/api/search/data.js (Line 1:37 - Line 32:2), C:/AI/food-truck-finder-poc/dist/lib/lib/api/search/data.js (Line 1:37 - Line 32:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn155" onclick="toggleCodeBlock('cloneGroup155', 'expandBtn155', 'collapseBtn155')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn155" onclick="toggleCodeBlock('cloneGroup155', 'expandBtn155', 'collapseBtn155')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup155"><code class="language-javascript text-sm text-gray-800">;
/**
* Retrieves and filters food trucks based on specified location and radius.
* @example
* getAndFilterFoodTrucks(&quot;37.7749&quot;, &quot;-122.4194&quot;, &quot;5&quot;)
* [FoodTruck, FoodTruck, FoodTruck]
* @param {string | null} lat - Latitude of the user's location.
* @param {string | null} lng - Longitude of the user's location.
* @param {string | null} radius - Search radius in kilometers.
* @returns {Promise&lt;FoodTruck[]&gt;} List of food trucks within the specified location and radius.
* @description
*   - Parses latitude, longitude, and radius from strings to floats for calculations.
*   - If latitude or longitude are not provided, fetches all cached food trucks.
*   - Defaults radius to 10 kilometers if not provided.
*/
export async function getAndFilterFoodTrucks(lat, lng, radius) {
    let trucks = [];
    if (lat != undefined &amp;&amp; lng != undefined) {
        const userLat = Number.parseFloat(lat);
        const userLng = Number.parseFloat(lng);
        const radiusKm = Number.parseFloat(radius ?? '10');
        trucks = await CachedFoodTruckService.getTrucksByLocationCached(userLat, userLng, radiusKm);
    }
    else {
        const result = await CachedFoodTruckService.getAllTrucksCached();
        trucks = result.trucks;
    }
    return trucks;
}
export function sortFoodTrucksByQuality(trucks) {
    return [...trucks].sort((a, b) =&gt; (b.data_quality_score ?? 0) - (a.data_quality_score ?? 0));
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/api/scheduler/handlers.js (Line 24:1 - Line 48:3), C:/AI/food-truck-finder-poc/dist/lib/lib/api/scheduler/handlers.js (Line 24:1 - Line 48:3)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn157" onclick="toggleCodeBlock('cloneGroup157', 'expandBtn157', 'collapseBtn157')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn157" onclick="toggleCodeBlock('cloneGroup157', 'expandBtn157', 'collapseBtn157')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup157"><code class="language-javascript text-sm text-gray-800">export function handleSchedulerStatus() {
    return NextResponse.json({
        isRunning: schedulerInstance != undefined,
        tasks: schedulerTasks,
        summary: {
            totalTasks: schedulerTasks.length,
            enabledTasks: schedulerTasks.filter((t) =&gt; t.enabled).length,
            runningTasks: schedulerTasks.filter((t) =&gt; t.enabled &amp;&amp; t.nextRun != undefined).length,
            totalSuccesses: schedulerTasks.reduce((acc, t) =&gt; acc + t.successCount, 0),
            totalErrors: schedulerTasks.reduce((acc, t) =&gt; acc + t.errorCount, 0),
        },
    });
}
/**
* Generates a JSON response containing a list of scheduler logs
* @example
* handleSchedulerLogs()
* { logs: [...] }
* @returns {Object} A JSON object containing an array of log entries with details.
* @description
*   - Each log entry includes a timestamp, task identifier, log level, and a message.
*   - The log levels include 'info', 'error', and 'warning'.
*   - Log timestamps are derived from the current time and adjusted to simulate real-time delays.
*   - Provides insight into scheduler task execution and any issues encountered.
*/</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/api/scheduler/handlers.js (Line 49:1 - Line 101:3), C:/AI/food-truck-finder-poc/dist/lib/lib/api/scheduler/handlers.js (Line 49:1 - Line 101:3)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn158" onclick="toggleCodeBlock('cloneGroup158', 'expandBtn158', 'collapseBtn158')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn158" onclick="toggleCodeBlock('cloneGroup158', 'expandBtn158', 'collapseBtn158')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup158"><code class="language-javascript text-sm text-gray-800">export function handleSchedulerLogs() {
    return NextResponse.json({
        logs: [
            {
                timestamp: new Date(Date.now() - 300_000).toISOString(),
                taskId: 'location_update',
                level: 'info',
                message: 'Successfully updated locations for 12 food trucks',
            },
            {
                timestamp: new Date(Date.now() - 900_000).toISOString(),
                taskId: 'instagram_scrape',
                level: 'info',
                message: 'Scraped 3 Instagram accounts, found 8 new posts',
            },
            {
                timestamp: new Date(Date.now() - 1_800_000).toISOString(),
                taskId: 'gemini_processing',
                level: 'error',
                message: 'Rate limit exceeded, skipping AI processing',
            },
            {
                timestamp: new Date(Date.now() - 3_600_000).toISOString(),
                taskId: 'website_crawl',
                level: 'warning',
                message: 'Failed to crawl tacoparadise.com - site temporarily unavailable',
            },
        ],
    });
}
export function handleSchedulerDefault() {
    return NextResponse.json({
        message: 'Task Scheduler API',
        endpoints: [
            'GET /api/scheduler?action=status - Get scheduler status',
            'GET /api/scheduler?action=logs - Get execution logs',
            'POST /api/scheduler - Start/stop scheduler or execute task',
            'PUT /api/scheduler - Update task configuration',
        ],
    });
}
/**
* Initializes the scheduler if it's not already running
* @example
* handleStartScheduler()
* { &quot;message&quot;: &quot;Scheduler started successfully&quot;, &quot;status&quot;: &quot;running&quot; }
* @param {none}
* @returns {NextResponse} Returns a JSON response indicating the status of the scheduler.
* @description
*   - Checks if a scheduler instance already exists before proceeding.
*   - Sets the current time as the start time for the new scheduler instance.
*   - Returns a 409 status code if the scheduler is already running.
*/</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/api/scheduler/handlers.js (Line 102:1 - Line 122:3), C:/AI/food-truck-finder-poc/dist/lib/lib/api/scheduler/handlers.js (Line 102:1 - Line 122:3)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn159" onclick="toggleCodeBlock('cloneGroup159', 'expandBtn159', 'collapseBtn159')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn159" onclick="toggleCodeBlock('cloneGroup159', 'expandBtn159', 'collapseBtn159')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup159"><code class="language-javascript text-sm text-gray-800">export function handleStartScheduler() {
    if (schedulerInstance) {
        return NextResponse.json({ error: 'Scheduler is already running' }, { status: 409 });
    }
    setSchedulerInstance({ started: new Date().toISOString() });
    return NextResponse.json({
        message: 'Scheduler started successfully',
        status: 'running',
    });
}
/**
* Stops the scheduler if it is currently running and returns a status message.
* @example
* handleStopScheduler()
* { message: 'Scheduler stopped successfully', status: 'stopped' }
* @param {undefined} schedulerInstance - Represents the current instance of the scheduler.
* @returns {Object} JSON response object containing a message and a status of the operation.
* @description
*   - Returns an error message if the scheduler is not running.
*   - Sets the scheduler instance to undefined to signify it has been stopped.
*/</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/api/scheduler/handlers.js (Line 123:1 - Line 145:4), C:/AI/food-truck-finder-poc/dist/lib/lib/api/scheduler/handlers.js (Line 123:1 - Line 145:4)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn160" onclick="toggleCodeBlock('cloneGroup160', 'expandBtn160', 'collapseBtn160')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn160" onclick="toggleCodeBlock('cloneGroup160', 'expandBtn160', 'collapseBtn160')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup160"><code class="language-javascript text-sm text-gray-800">export function handleStopScheduler() {
    if (!schedulerInstance) {
        return NextResponse.json({ error: 'Scheduler is not running' }, { status: 409 });
    }
    setSchedulerInstance(undefined);
    return NextResponse.json({
        message: 'Scheduler stopped successfully',
        status: 'stopped',
    });
}
/**
 * Executes a task by its ID and returns the execution result.
 * @example
 * handleExecuteTask('12345')
 * { message: 'Task 12345 executed', task: { ... } }
 * @param {string} taskId - Unique identifier of the task to be executed.
 * @returns {NextResponse} JSON response containing the execution result and task details.
 * @description
 *   - If the task ID is undefined or an empty string, returns a 400 JSON error response.
 *   - Finds the task associated with the given ID; returns a 404 JSON error if not found.
 *   - Task execution includes simulating success or failure. Math.random is used for simulation.
 *   - Updates task properties like lastRun, lastSuccess, successCount, errorCount based on execution result.
 */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/api/scheduler/handlers.js (Line 146:1 - Line 184:4), C:/AI/food-truck-finder-poc/dist/lib/lib/api/scheduler/handlers.js (Line 146:1 - Line 184:4)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn161" onclick="toggleCodeBlock('cloneGroup161', 'expandBtn161', 'collapseBtn161')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn161" onclick="toggleCodeBlock('cloneGroup161', 'expandBtn161', 'collapseBtn161')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup161"><code class="language-javascript text-sm text-gray-800">export function handleExecuteTask(taskId) {
    if (taskId == undefined || taskId === '') {
        return NextResponse.json({ error: 'Task ID is required for execution' }, { status: 400 });
    }
    const task = schedulerTasks.find((t) =&gt; t.id === taskId);
    if (!task) {
        return NextResponse.json({ error: 'Task not found' }, { status: 404 });
    }
    // Simulate task execution
    task.lastRun = new Date().toISOString();
    // Simulate success/failure
    // eslint-disable-next-line sonarjs/pseudo-random -- Math.random is acceptable for simulating task execution.
    if (Math.random() &gt; 0.1) {
        // 90% success rate
        task.lastSuccess = task.lastRun;
        task.successCount += 1;
        task.lastError = undefined;
    }
    else {
        task.errorCount += 1;
        task.lastError = 'Simulated execution error';
    }
    return NextResponse.json({
        message: `Task ${taskId} executed`,
        task: task,
    });
}
/**
 * Handles the update of a task configuration by modifying schedulerTasks.
 * @example
 * handleUpdateTask({ taskId: '123', config: { intervalMinutes: 10 } })
 * { message: 'Task configuration updated', task: { ...updatedTaskDetails } }
 * @param {PutRequestBody} body - Contains taskId and config object for updating task.
 * @returns {NextResponse} JSON response with status indicating the result of the operation.
 * @description
 *   - Checks for required taskId and existence of the task within schedulerTasks.
 *   - Modifies the task configuration using provided config object.
 *   - Updates nextRun time if intervalMinutes is specified and task is enabled.
 */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/api/scheduler/handlers.js (Line 185:1 - Line 211:2), C:/AI/food-truck-finder-poc/dist/lib/lib/api/scheduler/handlers.js (Line 185:1 - Line 211:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn162" onclick="toggleCodeBlock('cloneGroup162', 'expandBtn162', 'collapseBtn162')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn162" onclick="toggleCodeBlock('cloneGroup162', 'expandBtn162', 'collapseBtn162')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup162"><code class="language-javascript text-sm text-gray-800">export function handleUpdateTask(body) {
    const { taskId, config } = body;
    if (!taskId) {
        return NextResponse.json({ error: 'Task ID is required' }, { status: 400 });
    }
    const taskIndex = schedulerTasks.findIndex((t) =&gt; t.id === taskId);
    if (taskIndex === -1) {
        return NextResponse.json({ error: 'Task not found' }, { status: 404 });
    }
    // Update task configuration
    schedulerTasks[taskIndex] = {
        ...schedulerTasks[taskIndex],
        ...config,
    };
    // Update next run time if interval changed
    if (config.intervalMinutes != undefined &amp;&amp;
        config.intervalMinutes &gt; 0 &amp;&amp;
        schedulerTasks[taskIndex].enabled) {
        const lastRun = new Date(schedulerTasks[taskIndex].lastRun ?? Date.now());
        const nextRun = new Date(lastRun.getTime() + config.intervalMinutes * 60 * 1000);
        schedulerTasks[taskIndex].nextRun = nextRun.toISOString();
    }
    return NextResponse.json({
        message: 'Task configuration updated',
        task: schedulerTasks[taskIndex],
    });
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/api/scheduler/data.js (Line 1:1 - Line 62:2), C:/AI/food-truck-finder-poc/dist/lib/lib/api/scheduler/data.js (Line 1:1 - Line 62:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn163" onclick="toggleCodeBlock('cloneGroup163', 'expandBtn163', 'collapseBtn163')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn163" onclick="toggleCodeBlock('cloneGroup163', 'expandBtn163', 'collapseBtn163')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup163"><code class="language-javascript text-sm text-gray-800">export let schedulerInstance;
export const schedulerTasks = [
    {
        id: 'instagram_scrape',
        name: 'Instagram Data Scraping',
        enabled: true,
        intervalMinutes: 120,
        lastRun: new Date(Date.now() - 1_800_000).toISOString(),
        lastSuccess: new Date(Date.now() - 1_800_000).toISOString(),
        successCount: 45,
        errorCount: 3,
        nextRun: new Date(Date.now() + 5_400_000).toISOString(),
    },
    {
        id: 'website_crawl',
        name: 'Website Crawling',
        enabled: true,
        intervalMinutes: 360,
        lastRun: new Date(Date.now() - 7_200_000).toISOString(),
        lastSuccess: new Date(Date.now() - 7_200_000).toISOString(),
        successCount: 23,
        errorCount: 1,
        nextRun: new Date(Date.now() + 14_400_000).toISOString(),
    },
    {
        id: 'data_quality_check',
        name: 'Data Quality Assessment',
        enabled: true,
        intervalMinutes: 720,
        lastRun: new Date(Date.now() - 21_600_000).toISOString(),
        lastSuccess: new Date(Date.now() - 21_600_000).toISOString(),
        successCount: 12,
        errorCount: 0,
        nextRun: new Date(Date.now() + 21_600_000).toISOString(),
    },
    {
        id: 'gemini_processing',
        name: 'AI Data Processing',
        enabled: false,
        intervalMinutes: 480,
        lastRun: new Date(Date.now() - 28_800_000).toISOString(),
        lastSuccess: new Date(Date.now() - 28_800_000).toISOString(),
        successCount: 8,
        errorCount: 2,
        lastError: 'Rate limit exceeded',
        nextRun: undefined,
    },
    {
        id: 'location_update',
        name: 'Real-time Location Updates',
        enabled: true,
        intervalMinutes: 30,
        lastRun: new Date(Date.now() - 900_000).toISOString(),
        lastSuccess: new Date(Date.now() - 900_000).toISOString(),
        successCount: 156,
        errorCount: 8,
        nextRun: new Date(Date.now() + 900_000).toISOString(),
    },
];
export function setSchedulerInstance(instance) {
    schedulerInstance = instance;
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/api/pipeline/handlers.js (Line 15:1 - Line 41:2), C:/AI/food-truck-finder-poc/dist/lib/lib/api/pipeline/handlers.js (Line 15:1 - Line 41:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn165" onclick="toggleCodeBlock('cloneGroup165', 'expandBtn165', 'collapseBtn165')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn165" onclick="toggleCodeBlock('cloneGroup165', 'expandBtn165', 'collapseBtn165')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup165"><code class="language-javascript text-sm text-gray-800">export async function handleLegacyScrapingRequest(body) {
    const { target_url, job_type = 'website_scrape', priority = 1 } = body;
    if (target_url == undefined || target_url === '') {
        return NextResponse.json({ error: 'target_url is required' }, { status: 400 });
    }
    try {
        new URL(target_url);
    }
    catch {
        return NextResponse.json({ error: 'Invalid target_url format' }, { status: 400 });
    }
    const job = await ScrapingJobService.createJob({
        target_url,
        job_type,
        priority,
        scheduled_at: new Date().toISOString(),
    });
    if (job == undefined) {
        return NextResponse.json({ error: 'Failed to create scraping job' }, { status: 500 });
    }
    return NextResponse.json({
        message: 'Scraping job created (legacy mode)',
        job_id: job.id,
        target_url,
        note: 'Consider using the new unified pipeline API with action parameter',
    });
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/api/firecrawl/handlers.js (Line 17:1 - Line 42:3), C:/AI/food-truck-finder-poc/dist/lib/lib/api/firecrawl/handlers.js (Line 17:1 - Line 42:3)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn166" onclick="toggleCodeBlock('cloneGroup166', 'expandBtn166', 'collapseBtn166')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn166" onclick="toggleCodeBlock('cloneGroup166', 'expandBtn166', 'collapseBtn166')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup166"><code class="language-javascript text-sm text-gray-800">export async function handleScrapeOperation(url, options) {
    const scrapeResult = await firecrawl.scrapeUrl(url, {
        formats: ['markdown', 'html'],
        onlyMainContent: true,
        ...options,
    });
    return NextResponse.json({
        success: scrapeResult.success,
        data: scrapeResult.success ? [scrapeResult.data] : undefined,
        error: scrapeResult.error,
    });
}
// Helper function to poll crawl status
/**
* Polls the crawl status of a given job ID until the job is completed or a maximum number of attempts is reached.
* @example
* pollCrawlStatus('12345xyz')
* NextResponse { success: true, data: {...} }
* @param {string} jobId - The unique identifier for the crawl job.
* @returns {Promise&lt;NextResponse&gt;} A JSON response indicating the result of the crawl job: completed, failed, or timed out.
* @description
*   - Uses a polling mechanism with a fixed interval to check the job status repeatedly.
*   - Handles completed and failed job statuses with different JSON responses.
*   - Implemented timeout after 30 attempts to prevent indefinite polling.
*   - Provides appropriate HTTP status codes for each response scenario.
*/</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/api/firecrawl/handlers.js (Line 43:1 - Line 83:3), C:/AI/food-truck-finder-poc/dist/lib/lib/api/firecrawl/handlers.js (Line 43:1 - Line 83:3)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn167" onclick="toggleCodeBlock('cloneGroup167', 'expandBtn167', 'collapseBtn167')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn167" onclick="toggleCodeBlock('cloneGroup167', 'expandBtn167', 'collapseBtn167')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup167"><code class="language-javascript text-sm text-gray-800">export async function pollCrawlStatus(jobId) {
    let attempts = 0;
    const maxAttempts = 30; // 5 minutes max
    const pollInterval = 10_000; // 10 seconds
    while (attempts &lt; maxAttempts) {
        await new Promise((resolve) =&gt; { setTimeout(resolve, pollInterval); });
        const status = await firecrawl.getCrawlStatus(jobId);
        if (status.success &amp;&amp; status.status === 'completed' &amp;&amp; status.data) {
            return NextResponse.json({
                success: true,
                data: status.data,
            });
        }
        else if (status.success &amp;&amp; status.status === 'failed') {
            return NextResponse.json({
                success: false,
                error: 'Crawl job failed',
            }, { status: 500 });
        }
        attempts += 1;
    }
    // Timeout
    return NextResponse.json({
        success: false,
        error: 'Crawl job timed out',
    }, { status: 408 });
}
// Helper function to handle crawl operation
/**
* Initiates and handles the web crawling operation with specified options.
* @example
* handleCrawlOperation('http://example.com', { maxDepth: 3, limit: 50 })
* Returns the status of the crawl job operation.
* @param {string} url - The URL of the website to be crawled.
* @param {Record&lt;string, unknown&gt;} options - Options to configure the crawling operation including maxDepth, limit, includes, and excludes.
* @returns {Promise&lt;Object&gt;} A JSON response object containing the success status and error message, or initiates the crawl status polling.
* @description
*   - Uses `firecrawl` library to start a web crawling job with specific configurations.
*   - Handles crawl job initiation success and failure scenarios.
*   - Returns a JSON response on failure with error details.
*/</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/api/firecrawl/handlers.js (Line 84:1 - Line 110:2), C:/AI/food-truck-finder-poc/dist/lib/lib/api/firecrawl/handlers.js (Line 84:1 - Line 110:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn168" onclick="toggleCodeBlock('cloneGroup168', 'expandBtn168', 'collapseBtn168')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn168" onclick="toggleCodeBlock('cloneGroup168', 'expandBtn168', 'collapseBtn168')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup168"><code class="language-javascript text-sm text-gray-800">export async function handleCrawlOperation(url, options) {
    const crawlJob = await firecrawl.crawlWebsite(url, {
        crawlerOptions: {
            maxDepth: options.maxDepth || 2,
            limit: options.limit || 20,
            includes: options.includes,
            excludes: options.excludes,
        },
        pageOptions: {
            formats: ['markdown'],
            onlyMainContent: true,
        },
    });
    if (!crawlJob.success || crawlJob.jobId == undefined) {
        return NextResponse.json({
            success: false,
            error: crawlJob.error ?? 'Failed to start crawl job',
        }, { status: 500 });
    }
    return pollCrawlStatus(crawlJob.jobId);
}
export function handleSearchOperation() {
    return NextResponse.json({
        success: false,
        error: 'Search operation not directly supported by Firecrawl API. Use crawl on directory URLs instead.',
    }, { status: 400 });
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/lib/utils/typeGuards.js (Line 1:1 - Line 124:2), C:/AI/food-truck-finder-poc/dist/lib/lib/utils/typeGuards.js (Line 1:1 - Line 124:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn169" onclick="toggleCodeBlock('cloneGroup169', 'expandBtn169', 'collapseBtn169')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn169" onclick="toggleCodeBlock('cloneGroup169', 'expandBtn169', 'collapseBtn169')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup169"><code class="language-javascript text-sm text-gray-800">// lib/utils/typeGuards.ts
// --- CORE UTILITY FUNCTIONS (Task 1.1.1 &amp; 1.1.2) ---
/**
 * Checks if a value is a non-null object.
 */
export function isValidObject(value) {
    return typeof value === 'object' &amp;&amp; value !== null &amp;&amp; !Array.isArray(value);
}
/**
 * Safely checks if an object has a specific property. This is a robust implementation.
 */
export function hasProperty(obj, prop) {
    return Object.prototype.hasOwnProperty.call(obj, prop);
}
/**
 * Checks if a value is a string.
 */
export function isString(value) {
    return typeof value === 'string';
}
/**
 * Checks if a value is a valid number (and not NaN).
 */
export function isNumber(value) {
    return typeof value === 'number' &amp;&amp; !Number.isNaN(value);
}
/**
 * Checks if a value is an array.
 */
export function isArray(value) {
    return Array.isArray(value);
}
/**
 * Checks if a value is an array of strings.
 */
export function isStringArray(value) {
    return Array.isArray(value) &amp;&amp; value.every(item =&gt; typeof item === 'string');
}
/**
 * Asserts that a value is of a specific type, throwing a TypeError if validation fails.
 */
export function assertType(value, validator, errorMessage) {
    if (!validator(value)) {
        throw new TypeError(errorMessage ?? `Value does not match expected type.`);
    }
}
/**
 * Safely assigns a value if it passes validation, otherwise returns a fallback.
 * Useful for providing default values for potentially invalid or missing data.
 */
export function safeAssign(value, fallback, validator) {
    return validator(value) ? value : fallback;
}
// --- APPLICATION-SPECIFIC TYPE GUARDS ---
function isPriceRange(value) {
    // Added '$$$$' to the check to fully match the PriceRange type definition.
    return isString(value) &amp;&amp; (value === '$' || value === '$$' || value === '$$$' || value === '$$$$');
}
function isLocationData(value) {
    if (!isValidObject(value))
        return false;
    return hasProperty(value, 'lat') &amp;&amp; isNumber(value.lat) &amp;&amp;
        hasProperty(value, 'lng') &amp;&amp; isNumber(value.lng);
}
function isDailyOperatingHours(value) {
    if (value === undefined)
        return true;
    if (!isValidObject(value))
        return false;
    if (hasProperty(value, 'closed') &amp;&amp; value.closed === true) {
        return true;
    }
    return hasProperty(value, 'open') &amp;&amp; isString(value.open) &amp;&amp;
        hasProperty(value, 'close') &amp;&amp; isString(value.close);
}
function isOperatingHours(value) {
    if (!isValidObject(value))
        return false;
    const days = ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday'];
    return days.every(day =&gt; hasProperty(value, day) &amp;&amp; isDailyOperatingHours(value[day]));
}
function isMenuItem(value) {
    if (!isValidObject(value))
        return false;
    return hasProperty(value, 'name') &amp;&amp; isString(value.name) &amp;&amp;
        hasProperty(value, 'dietary_tags') &amp;&amp; isArray(value.dietary_tags);
}
function isMenuCategory(value) {
    if (!isValidObject(value))
        return false;
    return hasProperty(value, 'name') &amp;&amp; isString(value.name) &amp;&amp;
        hasProperty(value, 'items') &amp;&amp; isArray(value.items) &amp;&amp;
        value.items.every(item =&gt; isMenuItem(item));
}
/**
 * Type guard for the base FoodTruckSchema.
 */
export function isFoodTruckSchema(value) {
    if (!isValidObject(value))
        return false;
    // This property is optional, so it's valid if it's missing, undefined, or matches the type.
    const isPriceRangeValid = !hasProperty(value, 'price_range') || value.price_range === undefined || isPriceRange(value.price_range);
    return hasProperty(value, 'name') &amp;&amp; isString(value.name) &amp;&amp;
        hasProperty(value, 'description') &amp;&amp; isString(value.description) &amp;&amp;
        hasProperty(value, 'current_location') &amp;&amp; isValidObject(value.current_location) &amp;&amp; isLocationData(value.current_location) &amp;&amp;
        hasProperty(value, 'operating_hours') &amp;&amp; isOperatingHours(value.operating_hours) &amp;&amp;
        hasProperty(value, 'menu') &amp;&amp; isArray(value.menu) &amp;&amp; value.menu.every(item =&gt; isMenuCategory(item)) &amp;&amp;
        hasProperty(value, 'cuisine_type') &amp;&amp; isStringArray(value.cuisine_type) &amp;&amp;
        isPriceRangeValid &amp;&amp; // Using the isPriceRange function here
        hasProperty(value, 'data_quality_score') &amp;&amp; isNumber(value.data_quality_score) &amp;&amp;
        hasProperty(value, 'verification_status') &amp;&amp; isString(value.verification_status) &amp;&amp;
        hasProperty(value, 'source_urls') &amp;&amp; isStringArray(value.source_urls) &amp;&amp;
        hasProperty(value, 'last_scraped_at') &amp;&amp; isString(value.last_scraped_at);
}
/**
 * Type guard for the full FoodTruck object (schema + ID fields).
 */
export function isFoodTruck(value) {
    if (!isValidObject(value) || !isFoodTruckSchema(value))
        return false;
    return hasProperty(value, 'id') &amp;&amp; isString(value.id) &amp;&amp;
        hasProperty(value, 'created_at') &amp;&amp; isString(value.created_at) &amp;&amp;
        hasProperty(value, 'updated_at') &amp;&amp; isString(value.updated_at);
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/lib/utils/QualityScorer.js (Line 1:1 - Line 244:2), C:/AI/food-truck-finder-poc/dist/lib/lib/utils/QualityScorer.js (Line 1:1 - Line 244:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn171" onclick="toggleCodeBlock('cloneGroup171', 'expandBtn171', 'collapseBtn171')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn171" onclick="toggleCodeBlock('cloneGroup171', 'expandBtn171', 'collapseBtn171')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup171"><code class="language-javascript text-sm text-gray-800">import { supabase } from '../../supabase/client.js';
/**
 * Assess basic information of a FoodTruck object and adjust its score based on missing attributes.
 * @example
 * assessBasicInfo({name: 'Taste', description: 'Good food', cuisine_type: ['Italian'], price_range: '$$', average_rating: 4.5, review_count: 100}, [], 1.0)
 * Returns 1.0 if the truck information is complete and correct, otherwise returns a lower score with issues noted in the issues array.
 * @param {FoodTruck} truck - Object containing details about the food truck.
 * @param {string[]} issues - Array to hold descriptions of any issues found in the truck's information.
 * @param {number} currentScore - Initial score from which deductions are made based on detected issues.
 * @returns {number} Updated score after assessing the truck's basic information.
 * @description
 *   - Reduces score for missing or invalid 'name', 'description', 'cuisine_type', 'price_range', 'average_rating', and 'review_count'.
 *   - Appends issue descriptions to the 'issues' array corresponding to each attribute that fails validation.
 */
function assessBasicInfo(truck, issues, currentScore) {
    let score = currentScore;
    if (typeof truck.name !== 'string' || truck.name.trim().length === 0) {
        score -= 0.2;
        issues.push('Missing name');
    }
    if (typeof truck.description !== 'string' || truck.description.trim().length === 0) {
        score -= 0.1;
        issues.push('Missing description');
    }
    if (!Array.isArray(truck.cuisine_type) ||
        truck.cuisine_type.length === 0 ||
        !truck.cuisine_type.every((item) =&gt; typeof item === 'string')) {
        score -= 0.1;
        issues.push('Missing or invalid cuisine type');
    }
    if (typeof truck.price_range !== 'string' || truck.price_range.trim().length === 0) {
        score -= 0.05;
        issues.push('Missing price range');
    }
    if (typeof truck.average_rating !== 'number' || Number.isNaN(truck.average_rating)) {
        score -= 0.05;
        issues.push('Missing average rating');
    }
    if (typeof truck.review_count !== 'number' || Number.isNaN(truck.review_count)) {
        score -= 0.05;
        issues.push('Missing review count');
    }
    return score;
}
/**
 * Evaluates the contact information of a food truck and modifies its score accordingly.
 * @example
 * assessContactInfo(truckInstance, [], 1.0)
 * // returns 0.88 if all arguments are missing
 * @param {FoodTruck} truck - An object representing a food truck with various contact attributes.
 * @param {string[]} issues - An array to store any identified issues with contact information.
 * @param {number} currentScore - The initial score before evaluation.
 * @returns {number} A modified score based on the presence and validity of contact details.
 * @description
 *   - Reduces the score by a small percentage for each missing contact detail.
 *   - Appends specific issue messages to the 'issues' array for each missing detail.
 *   - Scores attribute presence in descending impact order: website, phone number, email, social media handles.
 */
function assessContactInfo(truck, issues, currentScore) {
    let score = currentScore;
    if (typeof truck.website !== 'string' || truck.website.trim().length === 0) {
        score -= 0.05;
        issues.push('Missing website');
    }
    if (typeof truck.phone_number !== 'string' || truck.phone_number.trim().length === 0) {
        score -= 0.05;
        issues.push('Missing phone number');
    }
    if (typeof truck.email !== 'string' || truck.email.trim().length === 0) {
        score -= 0.05;
        issues.push('Missing email');
    }
    if (typeof truck.instagram_handle !== 'string' || truck.instagram_handle.trim().length === 0) {
        score -= 0.02;
        issues.push('Missing Instagram handle');
    }
    if (typeof truck.facebook_handle !== 'string' || truck.facebook_handle.trim().length === 0) {
        score -= 0.02;
        issues.push('Missing Facebook handle');
    }
    if (typeof truck.twitter_handle !== 'string' || truck.twitter_handle.trim().length === 0) {
        score -= 0.02;
        issues.push('Missing Twitter handle');
    }
    return score;
}
/**
 * Evaluates the quality of location data for a food truck and updates the score accordingly.
 * @example
 * assessLocationData(truck, issues, currentScore)
 * // Returns a modified score based on location data analysis
 * @param {FoodTruck} truck - The food truck object containing location details.
 * @param {string[]} issues - Array to record any issues identified during evaluation.
 * @param {number} currentScore - The current scoring value before assessment.
 * @returns {number} Updated score reflecting the quality of the location data.
 * @description
 *   - Reduces the score if location data is missing or invalid.
 *   - Checks the age of the location data to determine its staleness.
 *   - Updates the issues array with specific reasons when penalizing the score.
 */
function assessLocationData(truck, issues, currentScore) {
    let score = currentScore;
    if (typeof truck.current_location?.lat !== 'number' ||
        Number.isNaN(truck.current_location.lat) ||
        typeof truck.current_location?.lng !== 'number' ||
        Number.isNaN(truck.current_location.lng)) {
        score -= 0.15;
        issues.push('Missing current location data');
    }
    else {
        if (typeof truck.current_location.timestamp === 'string' &amp;&amp;
            truck.current_location.timestamp.length &gt; 0) {
            const locationAge = Date.now() - new Date(truck.current_location.timestamp).getTime();
            const daysSinceUpdate = locationAge / (1000 * 60 * 60 * 24);
            if (daysSinceUpdate &gt; 7) {
                score -= 0.1;
                issues.push('Stale location data');
            }
        }
        else {
            score -= 0.05;
            issues.push('Missing location timestamp');
        }
    }
    return score;
}
function assessScheduleData(truck, issues, currentScore) {
    let score = currentScore;
    if (!Array.isArray(truck.schedule) || truck.schedule.length === 0) {
        score -= 0.1;
        issues.push('Missing schedule data');
    }
    return score;
}
/**
 * Computes the quality score of a given food truck based on multiple criteria.
 * @example
 * calculateQualityScore(truckInstance)
 * { score: 3, issues: [&quot;Missing contact information&quot;, &quot;Incomplete schedule&quot;] }
 * @param {FoodTruck} truck - The food truck object to be assessed.
 * @returns {QualityAssessment} An object containing the computed score and a list of identified issues.
 * @description
 *   - The score starts at 1 and is adjusted based on various assessments.
 *   - The function ensures the score never drops below zero.
 *   - Issues that affect the score are collected and returned for analysis.
 */
export function calculateQualityScore(truck) {
    let score = 1; // Start with a perfect score
    const issues = [];
    score = assessBasicInfo(truck, issues, score);
    score = assessContactInfo(truck, issues, score);
    score = assessLocationData(truck, issues, score);
    score = assessScheduleData(truck, issues, score);
    // Ensure score doesn't go below 0
    score = Math.max(0, score);
    return { score, issues };
}
export function categorizeQualityScore(score) {
    if (score &gt;= 0.8) {
        return { label: 'High', color: 'bg-green-500' };
    }
    else if (score &gt;= 0.5) {
        return { label: 'Medium', color: 'bg-yellow-500' };
    }
    return { label: 'Low', color: 'bg-red-500' };
}
export function formatQualityScore(score) {
    if (score === null || score === undefined) {
        return 'N/A';
    }
    return `${(score * 100).toFixed(0)}%`;
}
export function getQualityBadgeClasses(score) {
    if (score === null || score === undefined) {
        return 'bg-gray-500';
    }
    const category = categorizeQualityScore(score);
    return category.color;
}
export function getQualityScoreAriaLabel(score) {
    if (score === null || score === undefined) {
        return 'Data quality score not available';
    }
    const formattedScore = formatQualityScore(score);
    const category = categorizeQualityScore(score);
    return `Data quality: ${formattedScore}, Category: ${category.label}`;
}
export const DataQualityService = {
    calculateQualityScore,
    categorizeQualityScore,
    formatQualityScore,
    getQualityBadgeClasses,
    getQualityScoreAriaLabel,
    async batchUpdateQualityScores(limit = 100) {
        const { data, error } = await supabase
            .from('food_trucks')
            .select('*')
            .limit(limit)
            .overrideTypes();
        if (error) {
            console.error('Error fetching trucks for batch update:', error);
            return { updatedCount: 0, errors: [error.message] };
        }
        const trucks = data ?? [];
        const updates = trucks.map((truck) =&gt; {
            const { score } = calculateQualityScore(truck);
            return {
                id: truck.id,
                data_quality_score: score,
            };
        });
        const { error: updateError, count } = await supabase
            .from('food_trucks')
            .upsert(updates, { onConflict: 'id' })
            .select();
        if (updateError) {
            console.error('Error batch updating quality scores:', updateError);
            return { updatedCount: 0, errors: [updateError.message] };
        }
        return { updatedCount: count ?? 0, errors: [] };
    },
    async updateTruckQualityScore(truckId) {
        const { data: truck, error: fetchError } = await supabase
            .from('food_trucks')
            .select('*')
            .eq('id', truckId)
            .single()
            .overrideTypes();
        if (fetchError || truck === null) {
            console.error(`Error fetching truck ${truckId} for quality update:`, fetchError);
            return { success: false };
        }
        const { score } = calculateQualityScore(truck);
        const { error: updateError } = await supabase
            .from('food_trucks')
            .update({ data_quality_score: score })
            .eq('id', truckId);
        if (updateError) {
            console.error(`Error updating quality score for truck ${truckId}:`, updateError);
            return { success: false };
        }
        return { success: true };
    },
};</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/lib/utils/geocoding.js (Line 1:1 - Line 102:2), C:/AI/food-truck-finder-poc/dist/lib/lib/utils/geocoding.js (Line 1:1 - Line 102:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn173" onclick="toggleCodeBlock('cloneGroup173', 'expandBtn173', 'collapseBtn173')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn173" onclick="toggleCodeBlock('cloneGroup173', 'expandBtn173', 'collapseBtn173')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup173"><code class="language-javascript text-sm text-gray-800">/**
 * Geocoding utilities using Nominatim (OpenStreetMap's free geocoding service)
 * Converts addresses to lat/lng coordinates for map display
 */
/**
 * Geocodes an address to get latitude and longitude coordinates
 * @param address - The address to geocode
 * @param city - Optional city to improve accuracy (defaults to Charleston, SC)
 * @returns Promise containing coordinates and formatted address
 */
export async function geocodeAddress(address, city = 'Charleston, SC') {
    try {
        // Clean and format the address
        const cleanAddress = address.trim();
        if (!cleanAddress) {
            throw new Error('Empty address provided');
        }
        // Construct search query - add city if not already in address
        const searchQuery = cleanAddress.toLowerCase().includes('charleston')
            ? cleanAddress
            : `${cleanAddress}, ${city}`;
        // Use Nominatim API with proper headers and rate limiting
        const url = new URL('https://nominatim.openstreetmap.org/search');
        url.searchParams.set('q', searchQuery);
        url.searchParams.set('format', 'json');
        url.searchParams.set('limit', '1');
        url.searchParams.set('countrycodes', 'us');
        url.searchParams.set('addressdetails', '1');
        console.log(' Geocoding address:', searchQuery);
        const response = await fetch(url.toString(), {
            headers: {
                'User-Agent': 'FoodTruckFinder/1.0 (https://your-domain.com)', // Required by Nominatim
            },
        });
        if (!response.ok) {
            throw new Error(`Geocoding API error: ${response.status}`);
        }
        const data = await response.json();
        if (!data || data.length === 0) {
            console.warn(' No geocoding results for:', searchQuery);
            return {
                lat: 0,
                lng: 0,
                formatted_address: address,
                success: false,
            };
        }
        const result = data[0];
        const lat = parseFloat(result.lat);
        const lng = parseFloat(result.lon);
        // Validate coordinates are reasonable for Charleston area
        if (isNaN(lat) || isNaN(lng)) {
            throw new Error('Invalid coordinates returned');
        }
        console.log(' Geocoded successfully:', {
            original: address,
            coordinates: { lat, lng },
            formatted: result.display_name,
        });
        return {
            lat,
            lng,
            formatted_address: result.display_name,
            success: true,
        };
    }
    catch (error) {
        console.error(' Geocoding failed for address:', address, error);
        return {
            lat: 0,
            lng: 0,
            formatted_address: address,
            success: false,
        };
    }
}
/**
 * Fallback coordinates for Charleston, SC when geocoding fails
 */
export const CHARLESTON_FALLBACK = {
    lat: 32.7765,
    lng: -79.9311,
};
/**
 * Geocodes multiple addresses with rate limiting to avoid overwhelming the service
 * @param addresses - Array of addresses to geocode
 * @param delayMs - Delay between requests (default 1000ms as recommended by Nominatim)
 * @returns Promise array of geocoding results
 */
export async function geocodeAddressesBatch(addresses, delayMs = 1000) {
    const results = [];
    for (let i = 0; i &lt; addresses.length; i++) {
        const address = addresses[i];
        const result = await geocodeAddress(address);
        results.push(result);
        // Rate limiting - wait between requests
        if (i &lt; addresses.length - 1) {
            await new Promise(resolve =&gt; setTimeout(resolve, delayMs));
        }
    }
    return results;
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/lib/utils/foodTruckHelpers.js (Line 1:1 - Line 251:2), C:/AI/food-truck-finder-poc/dist/lib/lib/utils/foodTruckHelpers.js (Line 1:1 - Line 251:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn175" onclick="toggleCodeBlock('cloneGroup175', 'expandBtn175', 'collapseBtn175')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn175" onclick="toggleCodeBlock('cloneGroup175', 'expandBtn175', 'collapseBtn175')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup175"><code class="language-javascript text-sm text-gray-800">import { supabaseFallback } from '../../fallback/supabaseFallback';
export const getCurrentDay = () =&gt; {
    const days = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];
    return days[new Date().getDay()];
};
export const formatPrice = (price) =&gt; {
    // Updated to accept string
    if (typeof price === 'string') {
        // Handle cases where price might be a string like &quot;$10-$20&quot; or &quot;Varies&quot;
        return price;
    }
    return new Intl.NumberFormat('en-US', {
        style: 'currency',
        currency: 'USD',
    }).format(price);
};
/**
* Converts operational hours to a readable format or returns 'Closed' if applicable.
* @example
* formatOperatingHours({ open: '09:00', close: '17:00', closed: false })
* '9:00 AM - 5:00 PM'
* @param {DailyOperatingHours} hours - Object containing daily opening and closing times, and closed status.
* @returns {string} Formatted operating hours string or 'Closed'.
* @description
*   - Handles conversion of military time to 12-hour format.
*   - Adjusts for typical date parsing without relying on actual date due to fixed date string.
*   - Properly responds to 'closed' status by returning 'Closed'.
*   - Locales can impact formatted output by changing time conventions.
*/
export const formatHours = (hours) =&gt; {
    // Updated to accept DailyOperatingHours
    if (!hours || hours.closed) {
        return 'Closed';
    }
    const open = new Date(`1970-01-01T${hours.open}Z`).toLocaleTimeString('en-US', {
        hour: 'numeric',
        minute: 'numeric',
        hour12: true,
    });
    const close = new Date(`1970-01-01T${hours.close}Z`).toLocaleTimeString('en-US', {
        hour: 'numeric',
        minute: 'numeric',
        hour12: true,
    });
    return `${open} - ${close}`;
};
export const getPopularItems = (truck) =&gt; {
    // Explicitly define return type
    // Explicitly check for nullish and boolean
    return (truck.menu
        ?.flatMap((category) =&gt; category.items)
        .filter((item) =&gt; Boolean(item &amp;&amp; item.is_popular === true)) ?? []);
};
/**
 * Calculates the price range of all items in the food truck's menu.
 * @example
 * getPriceRange(foodTruck)
 * &quot;5.00 - 12.50&quot;
 * @param {FoodTruck} truck - The food truck object containing menu details.
 * @returns {string} Returns a formatted string representing the price range or 'N/A' if no valid prices are found.
 * @description
 *   - Utilizes the optional chaining operator to safely access nested menu items.
 *   - Filters out non-numeric and undefined prices before calculating the range.
 *   - Formats the minimum and maximum prices using a helper function.
 */
export const getPriceRange = (truck) =&gt; {
    const allItems = truck.menu?.flatMap((category) =&gt; category.items);
    if (!allItems || allItems.length === 0) {
        return 'N/A';
    }
    const numericPrices = allItems
        .map((item) =&gt; item.price)
        .filter((price) =&gt; typeof price === 'number' &amp;&amp; price != undefined); // Filter for numbers
    if (numericPrices.length === 0) {
        return 'N/A'; // No numeric prices found
    }
    const minPrice = Math.min(...numericPrices);
    const maxPrice = Math.max(...numericPrices);
    return `${formatPrice(minPrice)} - ${formatPrice(maxPrice)}`;
};
export const getTodayHours = (truck) =&gt; {
    const today = getCurrentDay();
    return truck.operating_hours?.[today];
};
// Get user's current location or default to San Francisco
/**
 * Retrieves the user's geolocation and updates the location state.
 * @example
 * getUserLocationHelper(setUserLocation)
 * // Updates user's location or defaults to San Francisco
 * @param {function} setUserLocation - Callback function to update user's location state with latitude and longitude.
 * @returns {void} Function does not return anything.
 * @description
 *   - Defaults the location to San Francisco if geolocation access is denied or not supported.
 *   - Utilizes browser's geolocation API to fetch current coordinates.
 *   - Provides a warning in the console if location access is denied.
 */
export function getUserLocationHelper(setUserLocation) {
    if (typeof navigator !== 'undefined' &amp;&amp; navigator.geolocation != undefined) {
        // eslint-disable-next-line sonarjs/no-intrusive-permissions -- Geolocation is essential for finding nearby food trucks
        navigator.geolocation.getCurrentPosition((position) =&gt; {
            console.log(' User location accuracy:', position.coords.accuracy, 'meters');
            setUserLocation({
                lat: position.coords.latitude,
                lng: position.coords.longitude,
            });
        }, (error) =&gt; {
            console.warn('Location access denied:', error);
            // Default to Charleston, SC for this project
            setUserLocation({ lat: 32.7765, lng: -79.9311 });
        }, {
            enableHighAccuracy: true,
            timeout: 10000,
            maximumAge: 300000 // 5 minutes
        });
    }
    else {
        // Default to San Francisco if geolocation is not supported
        setUserLocation({ lat: 37.7749, lng: -122.4194 });
    }
}
// Load all food trucks from API
/**
 * Loads food truck data from the server and updates state.
 * @example
 * loadFoodTrucksHelper(setTrucks, setLoading)
 * undefined
 * @param {(trucks: FoodTruck[]) =&gt; void} setTrucks - Callback to update the state with loaded food trucks.
 * @param {(loading: boolean) =&gt; void} setLoading - Callback to update the loading state.
 * @returns {void} No return value.
 * @description
 *   - Fetches data from '/api/trucks' endpoint.
 *   - Parses the response and expects an object containing a 'trucks' array.
 *   - Logs an error message to the console if fetching or parsing fails.
 *   - Ensures loading state is updated to false in all cases.
 */
export async function loadFoodTrucksHelper(setTrucks, setLoading) {
    try {
        console.log(' Starting to load food trucks...');
        const result = await supabaseFallback.getFoodTrucks();
        console.log(' Full result from supabaseFallback:', result);
        console.log(' Number of trucks found:', result.trucks.length);
        console.log(' Data status:', result.status);
        console.log(' Is from cache:', result.isFromCache);
        setTrucks(result.trucks);
    }
    catch (error) {
        console.error(' Failed to load food trucks:', error);
        setTrucks([]);
    }
    finally {
        setLoading(false);
    }
}
// Load nearby food trucks based on user location
/**
* Loads nearby food trucks based on user's location.
* @example
* loadNearbyTrucksHelper({ lat: 37.7749, lng: -122.4194 }, setTrucksCallback)
* // sets trucks with food truck data or an empty array
* @param {{ lat: number; lng: number } | undefined} userLocation - The location of the user used to find nearby trucks.
* @param {(trucks: FoodTruck[]) =&gt; void} setTrucks - Callback function to set the trucks data.
* @returns {void} No return value.
* @description
*   - Fetches nearby trucks from the API using latitude and longitude.
*   - Uses a fixed radius of 10 units for truck search.
*   - Handles errors by logging them to the console.
*/
export async function loadNearbyTrucksHelper(userLocation, setTrucks) {
    if (!userLocation)
        return;
    try {
        const { trucks } = await supabaseFallback.getFoodTrucks();
        setTrucks(trucks);
    }
    catch (error) {
        console.error('Failed to load nearby trucks:', error);
    }
}
// Filter trucks that have minimum viable data to display
/**
 * Determines if a food truck has enough essential data to be displayed to users.
 * @example
 * isViableTruck(foodTruck)
 * // returns true if truck has name and location, false otherwise
 * @param {FoodTruck} truck - The food truck object to validate.
 * @returns {boolean} Indicates whether the truck should be displayed.
 * @description
 *   - Checks for minimum required fields: name and valid location coordinates.
 *   - Ensures location has either coordinates OR a meaningful address.
 *   - Flags trucks missing essential data for admin review.
 */
export function isViableTruck(truck) {
    // Must have a name
    if (!truck.name || truck.name.trim() === '' || truck.name === 'Unnamed Truck') {
        console.warn(' Truck missing name:', truck.id);
        return false;
    }
    // Must have location data
    if (!truck.current_location) {
        console.warn(' Truck missing location data:', truck.name);
        return false;
    }
    // Must have either coordinates OR a meaningful address
    const hasCoordinates = typeof truck.current_location.lat === 'number' &amp;&amp;
        typeof truck.current_location.lng === 'number';
    const hasAddress = truck.current_location.address &amp;&amp;
        truck.current_location.address.trim() !== '' &amp;&amp;
        truck.current_location.address !== 'Unknown';
    if (!hasCoordinates &amp;&amp; !hasAddress) {
        console.warn(' Truck missing both coordinates and address:', truck.name);
        return false;
    }
    return true;
}
// Check if a food truck is currently open
/**
 * Determines if the food truck is currently open based on its operating hours.
 * @example
 * isTruckOpen(myFoodTruck)
 * // returns true or false depending on current time and truck's operating hours
 * @param {FoodTruck} truck - The food truck object with operating hours.
 * @returns {boolean} Indicates whether the truck is open.
 * @description
 *   - Utilizes the current day's name to fetch operating hours.
 *   - Handles potential errors in parsing operating hours.
 *   - Logs errors related to parsing time and truck name.
 *   - Uses military time format (HHMM) for comparison.
 */
export function isTruckOpen(truck) {
    const today = getCurrentDay();
    const hours = truck.operating_hours?.[today];
    // Ensure hours and its properties are not null/undefined before accessing
    if (hours == undefined ||
        hours.closed === true ||
        hours.open == undefined ||
        hours.close == undefined) {
        return false;
    }
    try {
        const now = new Date();
        const currentTime = now.getHours() * 100 + now.getMinutes();
        const openTime = Number.parseInt(hours.open.replace(':', ''), 10);
        const closeTime = Number.parseInt(hours.close.replace(':', ''), 10);
        return currentTime &gt;= openTime &amp;&amp; currentTime &lt;= closeTime;
    }
    catch (error) {
        console.error('Error parsing operating hours for truck', truck.name, error);
        return false;
    }
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/lib/utils/dataQualityFormatters.js (Line 1:1 - Line 180:2), C:/AI/food-truck-finder-poc/dist/lib/lib/utils/dataQualityFormatters.js (Line 1:1 - Line 180:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn178" onclick="toggleCodeBlock('cloneGroup178', 'expandBtn178', 'collapseBtn178')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn178" onclick="toggleCodeBlock('cloneGroup178', 'expandBtn178', 'collapseBtn178')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup178"><code class="language-javascript text-sm text-gray-800">/**
 * SOTA Data Quality Formatting Utilities
 * Provides consistent formatting and categorization for data quality metrics
 */
// SOTA quality thresholds based on industry standards
export const QUALITY_THRESHOLDS = {
    high: 0.8, // 80%+ = High quality
    medium: 0.6, // 60-79% = Medium quality
    low: 0.6, // &lt;60% = Low quality
};
// SOTA color scheme for accessibility and visual hierarchy
export const QUALITY_CATEGORIES = {
    high: {
        label: 'High',
        color: '#22c55e',
        bgColor: 'bg-green-100',
        textColor: 'text-green-800',
    },
    medium: {
        label: 'Medium',
        color: '#f59e0b',
        bgColor: 'bg-yellow-100',
        textColor: 'text-yellow-800',
    },
    low: {
        label: 'Low',
        color: '#ef4444',
        bgColor: 'bg-red-100',
        textColor: 'text-red-800',
    },
};
/**
 * Formats a quality score as a percentage with proper precision
 * @param score - Quality score (0-1 range)
 * @param precision - Number of decimal places (default: 1)
 * @returns Formatted percentage string
 */
export function formatQualityScore(score, precision = 1) {
    if (score === null || score === undefined || Number.isNaN(score)) {
        return 'N/A';
    }
    // Ensure score is in 0-1 range
    const normalizedScore = Math.max(0, Math.min(1, score));
    return `${(normalizedScore * 100).toFixed(precision)}%`;
}
/**
 * Categorizes a quality score into high/medium/low categories
 * @param score - Quality score (0-1 range)
 * @returns Quality category object
 */
export function categorizeQualityScore(score) {
    if (score === null || score === undefined || Number.isNaN(score)) {
        return QUALITY_CATEGORIES.low;
    }
    if (score &gt;= QUALITY_THRESHOLDS.high) {
        return QUALITY_CATEGORIES.high;
    }
    else if (score &gt;= QUALITY_THRESHOLDS.medium) {
        return QUALITY_CATEGORIES.medium;
    }
    return QUALITY_CATEGORIES.low;
}
/**
 * Gets the appropriate CSS classes for a quality score badge
 * @param score - Quality score (0-1 range)
 * @returns CSS class string for badge styling
 */
export function getQualityBadgeClasses(score) {
    const category = categorizeQualityScore(score);
    return `${category.bgColor} ${category.textColor}`;
}
/**
 * Calculates quality score trend indicator
 * @param currentScore - Current quality score
 * @param previousScore - Previous quality score
 * @returns Trend object with direction and percentage change
 */
export function calculateQualityTrend(currentScore, previousScore) {
    if (currentScore == undefined || previousScore == undefined) {
        return {
            direction: 'unknown',
            change: 0,
            changeText: 'N/A',
        };
    }
    const change = currentScore - previousScore;
    const changePercentage = Math.abs(change * 100);
    if (Math.abs(change) &lt; 0.01) {
        // Less than 1% change
        return {
            direction: 'stable',
            change: 0,
            changeText: 'No change',
        };
    }
    return {
        direction: change &gt; 0 ? 'up' : 'down',
        change: changePercentage,
        changeText: `${change &gt; 0 ? '+' : '-'}${changePercentage.toFixed(1)}%`,
    };
}
/**
 * Generates quality improvement suggestions based on score
 * @param score - Quality score (0-1 range)
 * @returns Array of improvement suggestions
 */
export function getQualityImprovementSuggestions(score) {
    if (score == undefined || score &gt;= QUALITY_THRESHOLDS.high) {
        return ['Quality score is excellent! Continue maintaining data standards.'];
    }
    const suggestions = [];
    if (score &lt; QUALITY_THRESHOLDS.medium) {
        suggestions.push('Critical: Add missing core information (name, location, contact details)', 'Verify and update GPS coordinates for accurate location data', 'Add comprehensive menu information and pricing', 'Update operating hours and schedule information');
    }
    else {
        suggestions.push('Add missing optional fields (website, social media, ratings)', 'Enhance menu descriptions and categories', 'Update recent photos and promotional content', 'Verify contact information accuracy');
    }
    return suggestions;
}
/**
 * Formats quality statistics for display
 * @param stats - Raw quality statistics from database
 * @returns Formatted statistics object
 */
export function formatQualityStats(stats) {
    return {
        totalTrucks: stats.total_trucks,
        averageScore: formatQualityScore(stats.avg_quality_score),
        averageScoreRaw: stats.avg_quality_score,
        distribution: {
            high: {
                count: stats.high_quality_count,
                percentage: ((stats.high_quality_count / stats.total_trucks) * 100).toFixed(1),
            },
            medium: {
                count: stats.medium_quality_count,
                percentage: ((stats.medium_quality_count / stats.total_trucks) * 100).toFixed(1),
            },
            low: {
                count: stats.low_quality_count,
                percentage: ((stats.low_quality_count / stats.total_trucks) * 100).toFixed(1),
            },
        },
        verification: {
            verified: {
                count: stats.verified_count,
                percentage: ((stats.verified_count / stats.total_trucks) * 100).toFixed(1),
            },
            pending: {
                count: stats.pending_count,
                percentage: ((stats.pending_count / stats.total_trucks) * 100).toFixed(1),
            },
            flagged: {
                count: stats.flagged_count,
                percentage: ((stats.flagged_count / stats.total_trucks) * 100).toFixed(1),
            },
        },
    };
}
/**
 * Validates if a quality score is within acceptable range
 * @param score - Quality score to validate
 * @returns Boolean indicating if score is valid
 */
export function isValidQualityScore(score) {
    return typeof score === 'number' &amp;&amp; !Number.isNaN(score) &amp;&amp; score &gt;= 0 &amp;&amp; score &lt;= 1;
}
/**
 * Generates accessibility-friendly description for quality score
 * @param score - Quality score (0-1 range)
 * @returns Screen reader friendly description
 */
export function getQualityScoreAriaLabel(score) {
    if (!isValidQualityScore(score)) {
        return 'Quality score not available';
    }
    const category = categorizeQualityScore(score);
    const percentage = formatQualityScore(score);
    return `Data quality score: ${percentage}, categorized as ${category.label.toLowerCase()} quality`;
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/lib/utils/apiHelpers.js (Line 1:1 - Line 21:2), C:/AI/food-truck-finder-poc/dist/lib/lib/utils/apiHelpers.js (Line 1:1 - Line 21:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn180" onclick="toggleCodeBlock('cloneGroup180', 'expandBtn180', 'collapseBtn180')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn180" onclick="toggleCodeBlock('cloneGroup180', 'expandBtn180', 'collapseBtn180')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup180"><code class="language-javascript text-sm text-gray-800">import { NextResponse } from 'next/server';
import { ZodError } from 'zod';
export function handleErrorResponse(error) {
    console.error('API error:', error);
    if (error instanceof ZodError) {
        return NextResponse.json({ error: error.errors }, { status: 400 });
    }
    return NextResponse.json({ error: error instanceof Error ? error.message : String(error) }, { status: 500 });
}
export function handleDeprecatedEndpoint(newEndpoint, documentation) {
    return NextResponse.json({
        status: 'DEPRECATED',
        message: `This endpoint has been consolidated into ${newEndpoint}`,
        migration: {
            newEndpoint,
            documentation,
            deprecationDate: '2024-12-09',
            removalDate: '2025-01-01',
        },
    }, { status: 410 });
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/lib/security/rateLimiter.js (Line 1:1 - Line 237:2), C:/AI/food-truck-finder-poc/dist/lib/lib/security/rateLimiter.js (Line 1:1 - Line 237:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn181" onclick="toggleCodeBlock('cloneGroup181', 'expandBtn181', 'collapseBtn181')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn181" onclick="toggleCodeBlock('cloneGroup181', 'expandBtn181', 'collapseBtn181')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup181"><code class="language-javascript text-sm text-gray-800">/**
 * SOTA Rate Limiting Implementation
 * Prevents brute force attacks and API abuse with intelligent rate limiting
 */
import { NextResponse } from 'next/server'; // Added import for NextResponse
// In-memory rate limit store (in production, use Redis)
const rateLimitStore = new Map();
// Rate limit configurations for different endpoints
export const RATE_LIMIT_CONFIGS = {
    // Authentication endpoints - strict limits
    auth: {
        windowMs: 15 * 60 * 1000, // 15 minutes
        maxRequests: 5, // 5 attempts per 15 minutes
        blockDurationMs: 30 * 60 * 1000, // Block for 30 minutes
        skipSuccessfulRequests: true,
    },
    // API endpoints - moderate limits
    api: {
        windowMs: 60 * 1000, // 1 minute
        maxRequests: 60, // 60 requests per minute
        blockDurationMs: 5 * 60 * 1000, // Block for 5 minutes
        skipSuccessfulRequests: false,
    },
    // Admin endpoints - very strict limits
    admin: {
        windowMs: 60 * 1000, // 1 minute
        maxRequests: 20, // 20 requests per minute
        blockDurationMs: 15 * 60 * 1000, // Block for 15 minutes
        skipSuccessfulRequests: false,
    },
};
/**
 * Rate Limiter Service
 */
export class RateLimiter {
    // Extract logic from checkRateLimit to reduce function size
    static isBlocked(entry, now) {
        return Boolean(entry &amp;&amp; entry.blocked &amp;&amp; entry.blockUntil != undefined &amp;&amp; now &lt; entry.blockUntil);
    }
    static resetEntry(entry, now, config) {
        entry.count = 0;
        entry.resetTime = now + config.windowMs;
        entry.blocked = false;
        entry.blockUntil = undefined;
    }
    /**
     * Check if request should be rate limited
     */
    static checkRateLimit(identifier, type = 'api') {
        const config = RATE_LIMIT_CONFIGS[type];
        const now = Date.now();
        const key = `${type}:${identifier}`;
        this.cleanupExpiredEntries();
        let entry = rateLimitStore.get(key);
        if (!entry) {
            entry = { count: 0, resetTime: now + config.windowMs, blocked: false };
            rateLimitStore.set(key, entry);
        }
        if (this.isBlocked(entry, now)) {
            return {
                allowed: false,
                remaining: 0,
                resetTime: entry.resetTime,
                retryAfter: Math.ceil((entry.blockUntil - now) / 1000),
            };
        }
        if (now &gt;= entry.resetTime) {
            this.resetEntry(entry, now, config);
        }
        if (entry.count &gt;= config.maxRequests) {
            entry.blocked = true;
            entry.blockUntil = now + config.blockDurationMs;
            return {
                allowed: false,
                remaining: 0,
                resetTime: entry.resetTime,
                retryAfter: Math.ceil(config.blockDurationMs / 1000),
            };
        }
        entry.count += 1;
        rateLimitStore.set(key, entry);
        return {
            allowed: true,
            remaining: config.maxRequests - entry.count,
            resetTime: entry.resetTime,
        };
    }
    /**
     * Record successful request (for auth endpoints)
     */
    static recordSuccess(identifier, type = 'api') {
        const config = RATE_LIMIT_CONFIGS[type];
        if (!config.skipSuccessfulRequests)
            return;
        const key = `${type}:${identifier}`;
        const entry = rateLimitStore.get(key);
        if (entry) {
            // Reset counter on successful auth
            entry.count = 0;
            entry.blocked = false;
            entry.blockUntil = undefined;
            rateLimitStore.set(key, entry);
        }
    }
    /**
     * Get rate limit status without incrementing
     */
    static getStatus(identifier, type = 'api') {
        const config = RATE_LIMIT_CONFIGS[type];
        const now = Date.now();
        const key = `${type}:${identifier}`;
        const entry = rateLimitStore.get(key);
        if (!entry) {
            return {
                remaining: config.maxRequests,
                resetTime: now + config.windowMs,
                blocked: false,
            };
        }
        // Check if blocked
        if (entry.blocked &amp;&amp; entry.blockUntil != undefined &amp;&amp; now &lt; entry.blockUntil) {
            // Changed != undefined to != null
            return {
                remaining: 0,
                resetTime: entry.resetTime,
                blocked: true,
                retryAfter: Math.ceil((entry.blockUntil - now) / 1000),
            };
        }
        // Check if window expired
        if (now &gt;= entry.resetTime) {
            return {
                remaining: config.maxRequests,
                resetTime: now + config.windowMs,
                blocked: false,
            };
        }
        return {
            remaining: Math.max(0, config.maxRequests - entry.count),
            resetTime: entry.resetTime,
            blocked: false,
        };
    }
    /**
     * Clean up expired entries to prevent memory leaks
     */
    static cleanupExpiredEntries() {
        const now = Date.now();
        for (const [key, entry] of rateLimitStore.entries()) {
            // Remove entries that are expired and not blocked
            if (now &gt;= entry.resetTime &amp;&amp;
                (!entry.blocked || entry.blockUntil == undefined || now &gt;= entry.blockUntil)) {
                // Changed == undefined to == null
                rateLimitStore.delete(key);
            }
        }
    }
    /**
     * Clear all rate limit data for an identifier
     */
    static clearLimits(identifier, type) {
        if (type) {
            const key = `${type}:${identifier}`;
            rateLimitStore.delete(key);
        }
        else {
            // Clear all types for this identifier
            for (const limitType of Object.keys(RATE_LIMIT_CONFIGS)) {
                // Added type assertion
                const key = `${limitType}:${identifier}`;
                rateLimitStore.delete(key);
            }
        }
    }
    /**
     * Get rate limit statistics
     */
    static getStats() {
        const stats = {
            totalEntries: rateLimitStore.size,
            blockedEntries: 0,
            entriesByType: {},
        };
        for (const [key, entry] of rateLimitStore.entries()) {
            const type = key.split(':')[0];
            stats.entriesByType[type] = (stats.entriesByType[type] ?? 0) + 1;
            if (entry.blocked) {
                stats.blockedEntries += 1;
            }
        }
        return stats;
    }
}
/**
 * Utility function to get client identifier from request
 */
export function getClientIdentifier(request) {
    // Try to get IP address from various headers
    const forwarded = request.headers.get('x-forwarded-for');
    const realIp = request.headers.get('x-real-ip');
    const cfConnectingIp = request.headers.get('cf-connecting-ip');
    // Use the first available IP
    const ip = forwarded?.split(',')[0]?.trim() ?? realIp ?? cfConnectingIp ?? 'unknown';
    // Include user agent for more specific identification
    const userAgent = request.headers.get('user-agent') ?? 'unknown';
    // Create a hash of IP + User Agent for better identification
    return `${ip}:${userAgent.slice(0, 50)}`;
}
/**
 * Rate limiting middleware for API routes
 */
export function withRateLimit(handler, type = 'api') {
    return async (request) =&gt; {
        const identifier = getClientIdentifier(request);
        const result = RateLimiter.checkRateLimit(identifier, type);
        if (result.allowed === false) {
            const headers = new Headers({
                'X-RateLimit-Limit': RATE_LIMIT_CONFIGS[type].maxRequests.toString(),
                'X-RateLimit-Remaining': '0',
                'X-RateLimit-Reset': new Date(result.resetTime).toISOString(),
            });
            if (result.retryAfter) {
                headers.set('Retry-After', result.retryAfter.toString());
            }
            return new NextResponse('Too Many Requests', { status: 429, headers });
        }
        const response = await handler(request);
        // Update headers on successful requests if not skipped
        if (RATE_LIMIT_CONFIGS[type].skipSuccessfulRequests === false) {
            const status = RateLimiter.getStatus(identifier, type);
            response.headers.set('X-RateLimit-Limit', RATE_LIMIT_CONFIGS[type].maxRequests.toString());
            response.headers.set('X-RateLimit-Remaining', status.remaining.toString());
            response.headers.set('X-RateLimit-Reset', new Date(status.resetTime).toISOString());
        }
        return response;
    };
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/lib/security/auditLogger.js (Line 1:1 - Line 234:2), C:/AI/food-truck-finder-poc/dist/lib/lib/security/auditLogger.js (Line 1:1 - Line 234:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn183" onclick="toggleCodeBlock('cloneGroup183', 'expandBtn183', 'collapseBtn183')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn183" onclick="toggleCodeBlock('cloneGroup183', 'expandBtn183', 'collapseBtn183')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup183"><code class="language-javascript text-sm text-gray-800">/**
 * SOTA Security Audit Logging System
 * Implements comprehensive audit logging for admin actions and security events
 */
import { supabaseAdmin } from '../../supabase/client.js';
/**
 * Audit Logger Service
 */
export class AuditLogger {
    /**
     * Log admin action with full audit trail
     */
    static async logAdminAction(options) {
        const { userId, userEmail, action, resourceType, resourceId, details, request } = options;
        const auditEntry = {
            user_id: userId,
            user_email: userEmail,
            action,
            resource_type: resourceType,
            resource_id: resourceId,
            details,
            ip_address: request?.ip,
            user_agent: request?.userAgent,
            session_id: request?.sessionId,
            timestamp: new Date().toISOString(),
            severity: this.determineSeverity(action, resourceType),
        };
        await this.writeAuditLog(auditEntry);
        // Log to console for immediate monitoring
        console.info('Admin Action Audit:', {
            user: userEmail,
            action,
            resource: resourceId === undefined ? resourceType : `${resourceType}:${resourceId}`,
            timestamp: auditEntry.timestamp,
        });
    }
    /**
     * Log security event
     */
    static async logSecurityEvent(event) {
        const logEntry = {
            event_type: event.event_type,
            user_id: event.user_id,
            user_email: event.user_email,
            ip_address: event.ip_address,
            user_agent: event.user_agent,
            details: event.details,
            severity: event.severity,
            timestamp: new Date().toISOString(),
        };
        try {
            if (supabaseAdmin) {
                await supabaseAdmin.from('security_events').insert(logEntry);
            }
        }
        catch (error) {
            console.error('Failed to log security event:', error);
        }
        // Always log security events to console
        console.info('Security Event:', logEntry);
        // Alert on critical security events
        if (event.severity === 'critical' || event.severity === 'error') {
            console.warn('SECURITY ALERT:', logEntry);
        }
    }
    /**
     * Log authentication events
     */
    static async logAuthEvent(options) {
        const { eventType, userEmail, userId, request, details } = options;
        const severity = eventType === 'login_failure' ? 'warning' : 'info';
        await this.logSecurityEvent({
            event_type: eventType,
            user_id: userId,
            user_email: userEmail,
            ip_address: request?.ip,
            user_agent: request?.userAgent,
            details,
            severity,
        });
    }
    /**
     * Log data access events
     */
    static async logDataAccess(options) {
        const { userId, userEmail, resourceType, resourceId, action = 'read', request } = options;
        await this.logSecurityEvent({
            event_type: 'data_access',
            user_id: userId,
            user_email: userEmail,
            ip_address: request?.ip,
            user_agent: request?.userAgent,
            details: {
                resource_type: resourceType,
                resource_id: resourceId,
                action,
            },
            severity: 'info',
        });
    }
    /**
     * Write audit log to database
     */
    static async writeAuditLog(entry) {
        try {
            if (supabaseAdmin) {
                await supabaseAdmin.from('audit_logs').insert(entry);
            }
        }
        catch (error) {
            console.error('Failed to write audit log:', error);
            // Don't throw - audit logging should not break application flow
        }
    }
    /**
     * Determine severity based on action and resource type
     */
    static determineSeverity(action, resourceType) {
        // Critical actions
        if (action.includes('delete') || action.includes('remove')) {
            return 'critical';
        }
        // Warning actions
        if (action.includes('update') || action.includes('modify') || action.includes('change')) {
            return 'warning';
        }
        // Admin-specific actions
        if (resourceType === 'user' || resourceType === 'admin' || resourceType === 'system') {
            return 'warning';
        }
        // Default to info
        return 'info';
    }
    /**
     * Get audit logs for a specific user
     */
    static async getUserAuditLogs(userId, limit = 100, offset = 0) {
        try {
            if (!supabaseAdmin) {
                return [];
            }
            const { data, error } = await supabaseAdmin
                .from('audit_logs')
                .select('*')
                .eq('user_id', userId)
                .order('timestamp', { ascending: false })
                .range(offset, offset + limit - 1);
            if (error) {
                console.error('Failed to fetch user audit logs:', error);
                return [];
            }
            return data ?? [];
        }
        catch (error) {
            console.error('Error fetching user audit logs:', error);
            return [];
        }
    }
    /**
     * Get recent security events
     */
    static async getRecentSecurityEvents(hours = 24, severity) {
        try {
            if (!supabaseAdmin) {
                return [];
            }
            const startTime = new Date();
            startTime.setHours(startTime.getHours() - hours);
            let query = supabaseAdmin
                .from('security_events')
                .select('*')
                .gte('timestamp', startTime.toISOString())
                .order('timestamp', { ascending: false });
            if (severity) {
                query = query.eq('severity', severity);
            }
            const { data, error } = await query.limit(500);
            if (error) {
                console.error('Failed to fetch security events:', error);
                return [];
            }
            return data ?? [];
        }
        catch (error) {
            console.error('Error fetching security events:', error);
            return [];
        }
    }
}
/**
 * Security monitoring utilities
 */
export const SecurityMonitor = {
    /**
     * Check for suspicious activity patterns
     */
    async checkSuspiciousActivity(userId) {
        const reasons = [];
        let riskLevel = 'low';
        try {
            // Check recent failed login attempts
            const recentEvents = await AuditLogger.getRecentSecurityEvents(1, 'warning');
            const failedLogins = recentEvents.filter((event) =&gt; event.event_type === 'login_failed' &amp;&amp; event.user_id === userId);
            if (failedLogins.length &gt; 5) {
                reasons.push('Multiple failed login attempts');
                riskLevel = 'high';
            }
            else if (failedLogins.length &gt; 2) {
                reasons.push('Recent failed login attempts');
                riskLevel = 'medium';
            }
            // Check for unusual access patterns
            const auditLogs = await AuditLogger.getUserAuditLogs(userId, 50);
            const recentActions = auditLogs.filter((log) =&gt; new Date(log.timestamp) &gt; new Date(Date.now() - 60 * 60 * 1000));
            if (recentActions.length &gt; 20) {
                reasons.push('High activity volume');
                riskLevel = riskLevel === 'high' ? 'high' : 'medium';
            }
            return {
                suspicious: reasons.length &gt; 0,
                reasons,
                riskLevel,
            };
        }
        catch (error) {
            console.error('Error checking suspicious activity:', error);
            return {
                suspicious: false,
                reasons: [],
                riskLevel: 'low',
            };
        }
    },
};</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/lib/schemas/truck.js (Line 1:1 - Line 127:2), C:/AI/food-truck-finder-poc/dist/lib/lib/schemas/truck.js (Line 1:1 - Line 127:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn185" onclick="toggleCodeBlock('cloneGroup185', 'expandBtn185', 'collapseBtn185')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn185" onclick="toggleCodeBlock('cloneGroup185', 'expandBtn185', 'collapseBtn185')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup185"><code class="language-javascript text-sm text-gray-800">import { z } from 'zod';
// PriceRange Schema
export const PriceRangeSchema = z.union([
    z.literal('$'),
    z.literal('$$'),
    z.literal('$$$'),
]);
// Coordinates Schema
export const CoordinatesSchema = z.object({
    lat: z.number().optional(),
    lng: z.number().optional(),
});
// LocationData Schema
export const LocationDataSchema = z.object({
    address: z.string().optional(),
    city: z.string().optional(),
    state: z.string().optional(),
    landmarks: z.array(z.string()),
    coordinates: CoordinatesSchema,
    confidence: z.number(),
    raw_location_text: z.string().optional(),
});
// DailyOperatingHours Schema
export const DailyOperatingHoursSchema = z.union([
    z.object({
        open: z.string(),
        close: z.string(),
        closed: z.literal(false),
    }),
    z.object({
        closed: z.literal(true),
    }),
    z.undefined(),
]);
// OperatingHours Schema
export const OperatingHoursSchema = z.object({
    monday: DailyOperatingHoursSchema,
    tuesday: DailyOperatingHoursSchema,
    wednesday: DailyOperatingHoursSchema,
    thursday: DailyOperatingHoursSchema,
    friday: DailyOperatingHoursSchema,
    saturday: DailyOperatingHoursSchema,
    sunday: DailyOperatingHoursSchema,
}).catchall(DailyOperatingHoursSchema); // For the index signature [key: string]: DailyOperatingHours;
// MenuItem Schema
export const MenuItemSchema = z.object({
    name: z.string(),
    description: z.string().optional(),
    price: z.union([z.number(), z.string()]).optional(),
    dietary_tags: z.array(z.any()), // 'any[]' in interface, so 'z.any()' for now
    is_popular: z.boolean().optional(),
});
// MenuCategory Schema
export const MenuCategorySchema = z.object({
    name: z.string(),
    items: z.array(MenuItemSchema),
});
// ContactInfo Schema (from ExtractedFoodTruckDetails)
export const ContactInfoSchema = z.object({
    phone: z.string().optional(),
    email: z.string().optional(),
    website: z.string().optional(),
});
// SocialMedia Schema (from ExtractedFoodTruckDetails)
export const SocialMediaSchema = z.object({
    instagram: z.string().optional(),
    facebook: z.string().optional(),
    twitter: z.string().optional(),
    tiktok: z.string().optional(),
    yelp: z.string().optional(),
});
// ScheduledLocation Schema (from ExtractedFoodTruckDetails)
export const ScheduledLocationSchema = z.object({
    address: z.string().optional(),
    city: z.string().optional(),
    state: z.string().optional(),
    zip_code: z.string().optional(),
    lat: z.number().optional(),
    lng: z.number().optional(),
    timestamp: z.string(),
    start_time: z.string(),
    end_time: z.string(),
});
// FoodTruckSchema
export const FoodTruckSchema = z.object({
    name: z.string(),
    description: z.string().optional(),
    current_location: z.object({
        lat: z.number(),
        lng: z.number(),
        address: z.string().optional(),
        timestamp: z.string(),
    }),
    scheduled_locations: z.array(ScheduledLocationSchema).optional(),
    operating_hours: OperatingHoursSchema,
    menu: z.array(MenuCategorySchema),
    contact_info: ContactInfoSchema,
    social_media: SocialMediaSchema,
    cuisine_type: z.array(z.string()),
    price_range: PriceRangeSchema.optional(),
    specialties: z.array(z.string()),
    data_quality_score: z.number(),
    verification_status: z.union([
        z.literal('pending'),
        z.literal('verified'),
        z.literal('flagged'),
    ]),
    source_urls: z.array(z.string()),
    last_scraped_at: z.string(),
    test_run_flag: z.boolean().optional(),
    website: z.string().optional(),
    phone_number: z.string().optional(),
    email: z.string().optional(),
    instagram_handle: z.string().optional(),
    facebook_handle: z.string().optional(),
    twitter_handle: z.string().optional(),
    schedule: z.array(z.any()).optional(), // 'unknown[]' in interface, so 'z.any()' for now
    average_rating: z.number().optional(),
    review_count: z.number().optional(),
});
// Truck Schema (extends FoodTruckSchema)
export const TruckSchema = FoodTruckSchema.extend({
    id: z.string(),
    created_at: z.string(),
    updated_at: z.string(),
    is_active: z.boolean().optional(),
});</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/lib/pipeline/scrapingProcessor.js (Line 4:23 - Line 176:2), C:/AI/food-truck-finder-poc/dist/lib/lib/pipeline/scrapingProcessor.js (Line 4:20 - Line 176:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn186" onclick="toggleCodeBlock('cloneGroup186', 'expandBtn186', 'collapseBtn186')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn186" onclick="toggleCodeBlock('cloneGroup186', 'expandBtn186', 'collapseBtn186')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup186"><code class="language-javascript text-sm text-gray-800">;
/**
 * Initiates web scraping for a specified food truck website.
 * @example
 * handleScraping(&quot;https://foodtruck.com&quot;, &quot;job123&quot;)
 * Returns data object with markdown content
 * @param {string} targetUrl - The URL of the food truck website to scrape.
 * @param {string} jobId - The unique identifier for the scraping job.
 * @returns {Object} An object containing the scraped data, including markdown content.
 * @description
 *   - Utilizes firecrawl library to perform web scraping.
 *   - Calls handleJobFailure if scraping is unsuccessful or markdown content is missing.
 *   - Logs the progress and success of the scraping process in the console.
 */
async function handleScraping(targetUrl, jobId) {
    console.info(`Starting scrape for ${targetUrl}`);
    const scrapeResult = await firecrawl.scrapeFoodTruckWebsite(targetUrl);
    if (!scrapeResult.success || !scrapeResult.data?.markdown) {
        const error = scrapeResult.error ?? 'Scraping failed or markdown content not found';
        await handleJobFailure(jobId, error);
        throw new Error(error);
    }
    console.info(`Scraping successful for ${targetUrl}, proceeding to Gemini extraction.`);
    return scrapeResult.data;
}
/**
 * Handles the extraction of food truck details using Gemini and manages job failures.
 * @example
 * handleGeminiExtraction(&quot;sample_markdown&quot;, &quot;http://example.com&quot;, &quot;12345&quot;)
 * { name: &quot;Sample Food Truck&quot;, location: &quot;123 Main St.&quot; }
 * @param {string} markdown - The Markdown content containing food truck details.
 * @param {string} sourceUrl - The URL of the source from which details are extracted.
 * @param {string} jobId - The identifier for the job being processed.
 * @returns {Object} The extracted food truck details if successful.
 * @description
 *   - Utilizes Gemini to extract data from the provided Markdown content.
 *   - Handles failure scenarios by logging errors and updating job status.
 *   - Throws an error when extraction is unsuccessful.
 */
async function handleGeminiExtraction(markdown, sourceUrl, jobId) {
    const geminiResult = await gemini.extractFoodTruckDetailsFromMarkdown(markdown, sourceUrl);
    if (!geminiResult.success || !geminiResult.data) {
        const error = geminiResult.error ?? 'Gemini data extraction failed';
        await handleJobFailure(jobId, error);
        throw new Error(error);
    }
    console.info(`Gemini extraction successful for ${sourceUrl}.`);
    return geminiResult.data;
}
/**
* Handles the failure of a job by updating its status.
* @example
* handleJobFailure('job1234', 'Timeout error')
* // Output: Logs an error message and updates the job status.
* @param {string} jobId - The unique identifier of the job that failed.
* @param {string} error - The error message describing the reason for failure.
* @returns {Promise&lt;void&gt;} Resolves successfully once the job status is updated.
* @description
*   - Logs the error to the console for debugging purposes.
*   - Checks if the current job status is not already 'failed' before updating.
*   - Updates the job status to 'failed' if applicable, capturing any errors encountered.
*   - Manages any errors that arise during the status update attempt.
*/
async function handleJobFailure(jobId, error) {
    console.error(`Job ${jobId} failed:`, error);
    try {
        const currentJob = await ScrapingJobService.getJobsByStatus('all').then((jobs) =&gt; jobs.find((j) =&gt; j.id === jobId));
        if (currentJob &amp;&amp; currentJob.status !== 'failed') {
            await ScrapingJobService.updateJobStatus(jobId, 'failed', { errors: [error] });
        }
    }
    catch (statusUpdateError) {
        console.error(`Error updating job ${jobId} status to failed:`, statusUpdateError);
    }
}
/**
 * Manages retry logic for a scraping job based on its current retry count.
 * @example
 * handleRetryLogic(&quot;job123&quot;)
 * undefined
 * @param {string} jobId - The unique identifier for the scraping job.
 * @returns {Promise&lt;void&gt;} Does not return a value but handles retries or logs errors.
 * @description
 *   - Utilizes ScrapingJobService to increment the retry count for the given job.
 *   - Determines whether to retry the job based on retry_count and max_retries properties.
 *   - Logs messages to inform about retry attempts or if max retries have been reached.
 *   - Catches and logs errors encountered during the retry process.
 */
async function handleRetryLogic(jobId) {
    try {
        const job = await ScrapingJobService.incrementRetryCount(jobId);
        if (job &amp;&amp; typeof job.retry_count === 'number' &amp;&amp; typeof job.max_retries === 'number') {
            if (job.retry_count &lt; job.max_retries) {
                console.info(`Retrying job ${jobId} (attempt ${job.retry_count}/${job.max_retries})`);
                setTimeout(() =&gt; {
                    void processScrapingJob(jobId);
                }, 5000);
            }
            else {
                console.warn(`Job ${jobId} reached max retries (${job.max_retries}).`);
            }
        }
        else {
            console.error(`Job ${jobId}: Could not get valid retry_count or max_retries. Won't attempt retry.`);
        }
    }
    catch (retryError) {
        console.error(`Error during retry logic for job ${jobId}:`, retryError);
    }
}
/**
 * Processes a scraping job by managing its lifecycle and data extraction.
 * @example
 * processScrapingJob('12345')
 * // Scraping job 12345 completed successfully and data processed.
 * @param {string} jobId - The unique identifier for the scraping job.
 * @returns {Promise&lt;void&gt;} Resolves when the job is completed or retried.
 * @description
 *   - Updates the scraping job status to 'running' at the beginning and 'completed' at the end of the process.
 *   - Performs data scraping and extraction using job's target URL.
 *   - Handles scenarios where a target URL is not specified, resulting in an error.
 *   - Implements retry logic in case of failure during the job processing.
 */
export async function processScrapingJob(jobId) {
    try {
        const job = await ScrapingJobService.updateJobStatus(jobId, 'running');
        if (!job.target_url) {
            throw new Error('No target URL specified');
        }
        const scrapeData = await handleScraping(job.target_url, jobId);
        const extractedData = await handleGeminiExtraction(scrapeData.markdown, scrapeData.source_url ?? job.target_url, jobId);
        await ScrapingJobService.updateJobStatus(jobId, 'completed', {
            data_collected: extractedData,
            completed_at: new Date().toISOString(),
        });
        await createOrUpdateFoodTruck(jobId, extractedData, scrapeData.source_url ?? job.target_url);
        console.info(`Scraping job ${jobId} completed successfully and data processed.`);
    }
    catch {
        await handleRetryLogic(jobId);
    }
}
/**
* Creates or updates a food truck entry based on extracted data and handles job processing.
* @example
* createOrUpdateFoodTruck('123abc', extractedTruckData, 'http://example.com')
* undefined
* @param {string} jobId - Unique identifier for the job being processed.
* @param {ExtractedFoodTruckDetails} extractedTruckData - Object containing details about the food truck extracted from a source.
* @param {string} sourceUrl - The URL from which the food truck data was extracted.
* @returns {Promise&lt;void&gt;} Resolves when processing is complete; returns nothing explicitly.
* @description
*   - Validates the input data before proceeding with creation or update.
*   - Applies a duplicate check mechanism to avoid redundant entries.
*   - Finalizes the job status, ensuring proper completion or failure handling.
*   - Logs error details for troubleshooting job processing issues.
*/
export async function createOrUpdateFoodTruck(jobId, extractedTruckData, sourceUrl) {
    try {
        const validation = await validateInputAndPrepare(jobId, extractedTruckData, sourceUrl);
        if (!validation.isValid) {
            return;
        }
        const truckData = buildTruckDataSchema(extractedTruckData, sourceUrl, validation.name);
        const truck = await handleDuplicateCheck(jobId, truckData, validation.name);
        await finalizeJobStatus(jobId, truck, sourceUrl);
    }
    catch (error) {
        const errorMessage = error instanceof Error ? error.message : 'Unknown error';
        console.error(`Job ${jobId}: Error in createOrUpdateFoodTruck from ${sourceUrl ?? 'Unknown Source'}:`, error);
        await handleJobFailure(jobId, `Food truck data processing/saving failed: ${errorMessage}`);
    }
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/lib/pipeline/pipelineHelpers.js (Line 1:17 - Line 30:96), C:/AI/food-truck-finder-poc/dist/lib/lib/pipeline/pipelineHelpers.js (Line 1:24 - Line 30:6)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn187" onclick="toggleCodeBlock('cloneGroup187', 'expandBtn187', 'collapseBtn187')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn187" onclick="toggleCodeBlock('cloneGroup187', 'expandBtn187', 'collapseBtn187')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup187"><code class="language-javascript text-sm text-gray-800">;
import { DuplicatePreventionService } from '../data-quality/duplicatePrevention.js';
// Helper function to validate input and prepare basic data
/**
 * Validates input data and prepares food truck information.
 * @example
 * validateInputAndPrepare('job123', extractedTruckDataInstance, 'http://sourceurl.com')
 * { isValid: true, name: 'Food Truck Name' }
 * @param {string} jobId - The job identifier used for logging and job status updates.
 * @param {ExtractedFoodTruckDetails} extractedTruckData - Contains details about the food truck such as name and other attributes.
 * @param {string} sourceUrl - URL where the data was originally extracted from.
 * @returns {Promise&lt;{ isValid: boolean; name: string }&gt;} Result of validation with food truck name.
 * @description
 *   - Logs a warning if the source URL is missing, but continues process as it might not be critical.
 *   - Ensures the food truck name has a fallback value if it's missing in the extracted data.
 *   - Updates job status as 'failed' if validation does not pass.
 */
export async function validateInputAndPrepare(jobId, extractedTruckData, sourceUrl) {
    // Basic input validation
    if (!validateTruckData(jobId, extractedTruckData)) {
        await ScrapingJobService.updateJobStatus(jobId, 'failed', {
            errors: ['Invalid extracted data received from AI processing step.'],
        });
        return { isValid: false, name: '' };
    }
    if (!sourceUrl) {
        // Log a warning but proceed if sourceUrl is missing, as it might not be critical for all data.
        console.warn(`Job ${jobId}: Missing sourceUrl for food truck data, proceeding without it.`);
    }
    // CRITICAL: If name is null, undefined, empty, or &quot;Unknown Food Truck&quot;, discard the truck data</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/lib/pipeline/pipelineHelpers.js (Line 39:5 - Line 398:2), C:/AI/food-truck-finder-poc/dist/lib/lib/pipeline/pipelineHelpers.js (Line 31:5 - Line 390:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn188" onclick="toggleCodeBlock('cloneGroup188', 'expandBtn188', 'collapseBtn188')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn188" onclick="toggleCodeBlock('cloneGroup188', 'expandBtn188', 'collapseBtn188')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup188"><code class="language-javascript text-sm text-gray-800">console.info(`Job ${jobId}: Preparing to create/update food truck: ${name} from ${sourceUrl ?? 'Unknown Source'}`);
    return { isValid: true, name };
}
// New helper function for operating hours
/**
 * Constructs a weekly operating hours object for a food truck.
 * @example
 * buildOperatingHours({ monday: { open: '8:00', close: '17:00' } })
 * // Returns: { monday: { open: '8:00', close: '17:00' }, tuesday: { closed: true }, ... }
 * @param {ExtractedFoodTruckDetails['operating_hours']} extractedOperatingHours - The raw operating hours extracted for each day of the week.
 * @returns {Object} An object containing operating hours for each day of the week, defaulting to closed if not provided.
 * @description
 *   - Days without specified operating hours default to closed.
 *   - Ensures consistency in data structure by providing default closed status.
 *   - Uses TypeScript's 'const' assertion for type safety on closed status.
 */
function buildOperatingHours(extractedOperatingHours) {
    if (extractedOperatingHours == undefined) {
        return {
            monday: { closed: true },
            tuesday: { closed: true },
            wednesday: { closed: true },
            thursday: { closed: true },
            friday: { closed: true },
            saturday: { closed: true },
            sunday: { closed: true },
        };
    }
    return {
        monday: extractedOperatingHours.monday ?? { closed: true },
        tuesday: extractedOperatingHours.tuesday ?? { closed: true },
        wednesday: extractedOperatingHours.wednesday ?? { closed: true },
        thursday: extractedOperatingHours.thursday ?? { closed: true },
        friday: extractedOperatingHours.friday ?? { closed: true },
        saturday: extractedOperatingHours.saturday ?? { closed: true },
        sunday: extractedOperatingHours.sunday ?? { closed: true },
    };
}
// New helper function for scheduled locations
/**
 * Transforms and sanitizes an array of scheduled food truck locations.
 * @example
 * buildScheduledLocations([{ lat: 34.05, lng: -118.25, address: &quot;123 Main St&quot;, start_time: &quot;10:00&quot;, end_time: &quot;14:00&quot; }])
 * [{ lat: 34.05, lng: -118.25, address: &quot;123 Main St&quot;, start_time: &quot;10:00&quot;, end_time: &quot;14:00&quot;, timestamp: &quot;2023-10-19T14:00:00.000Z&quot; }]
 * @param {ExtractedFoodTruckDetails['scheduled_locations']} scheduledLocations - Array of scheduled food truck location objects.
 * @returns {Array} Array of sanitized location objects.
 * @description
 *   - Ensures latitude and longitude values are numbers; defaults to 0 if not.
 *   - Adds a current timestamp to each location object in ISO format.
 *   - Uses nullish coalescing to ensure address, start_time, and end_time are either their values or undefined.
 */
function buildScheduledLocations(scheduledLocations) {
    if (!Array.isArray(scheduledLocations)) {
        return;
    }
    return scheduledLocations.map((loc) =&gt; ({
        lat: typeof loc.lat === 'number' ? loc.lat : 0,
        lng: typeof loc.lng === 'number' ? loc.lng : 0,
        address: loc.address ?? undefined,
        start_time: loc.start_time ?? undefined,
        end_time: loc.end_time ?? undefined,
        timestamp: new Date().toISOString(),
    }));
}
// Helper function to build truck data schema
/**
 * Constructs a FoodTruckSchema object from extracted food truck details.
 * @example
 * buildTruckDataSchema(extractedTruckData, 'http://sourceUrl.com', 'Truck Name')
 * { name: 'Truck Name', ... }
 * @param {ExtractedFoodTruckDetails} extractedTruckData - Object containing raw data extracted from a food truck resource.
 * @param {string} sourceUrl - URL source where the truck data was extracted from.
 * @param {string} name - Name of the food truck.
 * @returns {FoodTruckSchema} Fully constructed food truck schema ready for use.
 * @description
 *   - Ensures `description` and `price_range` are kept undefined if missing or null from extracted data.
 *   - Filters any non-string values from the `cuisine_type` array.
 *   - Ensures the `source_urls` field is always an array, even if empty or undefined.
 *   - Default verification status is 'pending' and a default data quality score is set to 0.5.
 */
export function buildTruckDataSchema(extractedTruckData, sourceUrl, name) {
    const currentLocation = buildLocationData(extractedTruckData);
    return {
        name: name,
        description: extractedTruckData.description ?? undefined, // Keep as undefined if null/missing
        current_location: currentLocation,
        scheduled_locations: buildScheduledLocations(extractedTruckData.scheduled_locations),
        operating_hours: buildOperatingHours(extractedTruckData.operating_hours),
        menu: processMenuData(extractedTruckData),
        contact_info: buildContactInfo(extractedTruckData.contact_info),
        social_media: buildSocialMedia(extractedTruckData.social_media),
        cuisine_type: Array.isArray(extractedTruckData.cuisine_type)
            ? extractedTruckData.cuisine_type.filter((c) =&gt; typeof c === 'string')
            : [],
        price_range: extractedTruckData.price_range ?? undefined, // Ensure it's one of the allowed enum values or undefined
        specialties: Array.isArray(extractedTruckData.specialties)
            ? extractedTruckData.specialties
            : [],
        data_quality_score: 0.5, // Default score - confidence_score not available in type
        verification_status: 'pending',
        source_urls: sourceUrl != undefined &amp;&amp; sourceUrl !== '' ? [sourceUrl] : [], // Ensure source_urls is always an array
        last_scraped_at: new Date().toISOString(),
    };
}
// Helper function to handle duplicate checking and resolution
/**
 * Checks for duplicates before creating a new food truck entry.
 * @example
 * handleDuplicateCheck('12345', truckDataObject, 'Awesome Food Truck')
 * // Returns a promise resolving to the created truck object or result from handling a duplicate.
 * @param {string} jobId - The unique identifier for the job process.
 * @param {FoodTruckSchema} truckData - The data schema representing the food truck details.
 * @param {string} name - The name of the food truck being processed.
 * @returns {Promise&lt;FoodTruck&gt;} Returns a promise that resolves to the created or existing food truck.
 * @description
 *   - Utilizes the DuplicatePreventionService to verify if a similar truck already exists.
 *   - If a duplicate is detected, delegates to a separate function to handle the duplicate scenario.
 *   - Logs errors encountered during the creation process.
 */
export async function handleDuplicateCheck(jobId, truckData, name) {
    // Check for duplicates before creating
    console.info(`Job ${jobId}: Checking for duplicates before creating truck: ${name}`);
    const duplicateCheck = await DuplicatePreventionService.checkForDuplicates(truckData);
    if (duplicateCheck.isDuplicate &amp;&amp; duplicateCheck.bestMatch) {
        return await handleDuplicate(jobId, truckData, duplicateCheck);
    }
    // No duplicates found, create new truck
    const truck = await FoodTruckService.createTruck(truckData);
    if ('error' in truck) {
        console.error(`Job ${jobId}: Error creating new truck: ${truck.error}`);
        throw new Error(`Failed to create truck: ${truck.error}`);
    }
    return truck;
}
/**
 * Handles potential duplicate food truck entries by either merging, updating, or creating new truck data.
 * @example
 * handleDuplicate(&quot;job123&quot;, truckData, duplicateCheck)
 * // Returns the processed Food Truck object.
 * @param {string} jobId - Unique identifier for the job processing potential duplicates.
 * @param {FoodTruckSchema} truckData - Data representing the food truck to be processed.
 * @param {DuplicateCheckResult} duplicateCheck - Results from a duplicate check operation.
 * @returns {Promise&lt;FoodTruck&gt;} Returns a promise that resolves to a Food Truck object if successful.
 * @description
 *   - Uses duplicate check results to determine whether to merge, update, or create new truck data.
 *   - Logs information about the operation performed and potential duplicates found.
 *   - Contains error handling for each operation, including fallback creations in case of failures.
 *   - Provides warnings when creating new entries despite finding possible duplicates.
 */
async function handleDuplicate(jobId, truckData, duplicateCheck) {
    const { bestMatch } = duplicateCheck;
    if (!bestMatch) {
        // This should not happen if isDuplicate is true, but as a safeguard:
        const truck = await FoodTruckService.createTruck(truckData);
        if ('error' in truck) {
            throw new Error(`Failed to create truck: ${truck.error}`);
        }
        return truck;
    }
    console.info(`Job ${jobId}: Found potential duplicate (${Math.round(bestMatch.similarity * 100)}% similarity) with truck: ${bestMatch.existingTruck.name}`);
    if (bestMatch.confidence === 'high' &amp;&amp; bestMatch.recommendation === 'merge') {
        const truck = await DuplicatePreventionService.mergeDuplicates(bestMatch.existingTruck.id, bestMatch.existingTruck.id);
        if ('error' in truck) {
            console.error(`Job ${jobId}: Error merging duplicates: ${truck.error}`);
            const newTruck = await FoodTruckService.createTruck(truckData);
            if ('error' in newTruck) {
                console.error(`Job ${jobId}: Error creating truck after merge failure: ${newTruck.error}`);
                throw new Error(`Failed to merge or create truck: ${newTruck.error}`);
            }
            return newTruck;
        }
        console.info(`Job ${jobId}: Merged data with existing truck: ${truck.name} (ID: ${truck.id})`);
        return truck;
    }
    else if (bestMatch.recommendation === 'update') {
        const truck = await FoodTruckService.updateTruck(bestMatch.existingTruck.id, truckData);
        if ('error' in truck) {
            console.error(`Job ${jobId}: Error updating existing truck: ${truck.error}`);
            const newTruck = await FoodTruckService.createTruck(truckData);
            if ('error' in newTruck) {
                console.error(`Job ${jobId}: Error creating truck after update failure: ${newTruck.error}`);
                throw new Error(`Failed to update or create truck: ${newTruck.error}`);
            }
            return newTruck;
        }
        console.info(`Job ${jobId}: Updated existing truck: ${truck.name} (ID: ${truck.id})`);
        return truck;
    }
    else {
        const truck = await FoodTruckService.createTruck(truckData);
        if ('error' in truck) {
            console.error(`Job ${jobId}: Error creating truck despite potential duplicate: ${truck.error}`);
            throw new Error(`Failed to create truck: ${truck.error}`);
        }
        console.warn(`Job ${jobId}: Created new truck despite potential duplicate (${duplicateCheck.reason ?? 'unknown reason'})`);
        return truck;
    }
}
// Helper function to finalize job status
/**
* Logs the successful creation of a food truck and updates the job status to completed.
* @example
* finalizeJobStatus('12345', { name: 'Best Food Truck', id: 'FT123' }, 'http://example.com')
* // Logs: Job 12345: Successfully created food truck: Best Food Truck (ID: FT123) from http://example.com
* @param {string} jobId - Unique identifier of the scraping job.
* @param {FoodTruck} truck - Object representing the food truck that was created.
* @param {string} sourceUrl - URL from where the data was sourced.
* @returns {Promise&lt;void&gt;} Resolves when the job status is updated.
* @description
*   - Logs the truck creation event using `console.info`.
*   - Ensures the job status is set to 'completed' with the current timestamp.
*   - Uses a default source message if sourceUrl is not provided.
*/
export async function finalizeJobStatus(jobId, truck, sourceUrl) {
    console.info(`Job ${jobId}: Successfully created food truck: ${truck.name} (ID: ${truck.id}) from ${sourceUrl ?? 'Unknown Source'}`);
    // Link truck_id back to the scraping job
    await ScrapingJobService.updateJobStatus(jobId, 'completed', {
        completed_at: new Date().toISOString(),
    });
}
// Helper function to validate input data
function validateTruckData(jobId, extractedTruckData) {
    if (extractedTruckData == undefined || typeof extractedTruckData !== 'object') {
        console.error(`Job ${jobId}: Invalid extractedTruckData, cannot create/update food truck.`);
        return false;
    }
    return true;
}
// Helper function to build location data
/**
 * Constructs location data from extracted truck details.
 * @example
 * buildLocationData({
 *   current_location: {
 *     address: &quot;123 Example St&quot;,
 *     city: &quot;Sample City&quot;,
 *     state: &quot;SC&quot;,
 *     zip_code: &quot;12345&quot;,
 *     lat: 34.05,
 *     lng: -118.25,
 *     raw_text: &quot;Raw Location Data&quot;
 *   }
 * })
 * // Returns: {
 * //   lat: 34.05,
 * //   lng: -118.25,
 * //   address: &quot;123 Example St, Sample City, SC, 12345&quot;,
 * //   timestamp: &quot;2023-09-15T14:38:00.000Z&quot;
 * // }
 * @param {ExtractedFoodTruckDetails} extractedTruckData - Details of the food truck, including its current location.
 * @returns {Object} Location data comprising latitude, longitude, formatted address, and current timestamp.
 * @description
 *   - Constructs a full address by combining address components.
 *   - Defaults latitude and longitude to 0 if not provided as numbers.
 *   - Uses raw text as address if address components are missing.
 *   - Generates an ISO 8601 timestamp for the current date and time.
 */
function buildLocationData(extractedTruckData) {
    const locationData = extractedTruckData.current_location ?? {};
    const fullAddress = [
        locationData.address,
        locationData.city,
        locationData.state,
        locationData.zip_code,
    ]
        .filter(Boolean)
        .join(', ');
    return {
        lat: typeof locationData.lat === 'number' ? locationData.lat : 0,
        lng: typeof locationData.lng === 'number' ? locationData.lng : 0,
        address: fullAddress || (locationData.raw_text ?? undefined),
        timestamp: new Date().toISOString(),
    };
}
// New helper function for contact info
function buildContactInfo(contactInfo) {
    return {
        phone: contactInfo?.phone ?? undefined,
        email: contactInfo?.email ?? undefined,
        website: contactInfo?.website ?? undefined,
    };
}
// New helper function for social media
function buildSocialMedia(socialMedia) {
    return {
        instagram: socialMedia?.instagram ?? undefined,
        facebook: socialMedia?.facebook ?? undefined,
        twitter: socialMedia?.twitter ?? undefined,
        tiktok: socialMedia?.tiktok ?? undefined,
        yelp: socialMedia?.yelp ?? undefined,
    };
}
// Type guard for RawMenuCategory
function isRawMenuCategory(obj) {
    return (typeof obj === 'object' &amp;&amp;
        obj != undefined &amp;&amp;
        ('category' in obj || 'name' in obj || 'items' in obj));
}
// Type guard for RawMenuItem
function isRawMenuItem(obj) {
    return (typeof obj === 'object' &amp;&amp;
        obj != undefined &amp;&amp;
        ('name' in obj || 'description' in obj || 'price' in obj || 'dietary_tags' in obj));
}
// Helper function to process menu data
/**
 * Processes extracted food truck data into structured menu categories.
 * @example
 * processMenuData(sample_truck_data)
 * [ { name: 'Uncategorized', items: [{ name: 'Pizza', description: 'Cheese Pizza', price: 9.99, dietary_tags: ['vegetarian'] }] } ]
 * @param {ExtractedFoodTruckDetails} extractedTruckData - The extracted food truck data.
 * @returns {MenuCategory[]} Array of structured menu categories.
 * @description
 *   - Validates categories and items before mapping to a structured format.
 *   - Converts item price to number and handles invalid input gracefully.
 *   - Provides default values for category and item names in the case of invalid data.
 *   - Logs warnings for encountered invalid category or item data.
 */
function processMenuData(extractedTruckData) {
    if (!Array.isArray(extractedTruckData.menu)) {
        return [];
    }
    return extractedTruckData.menu.map((category) =&gt; {
        if (!isRawMenuCategory(category)) {
            console.warn('Invalid category data encountered:', category);
            return { name: 'Invalid Category', items: [] };
        }
        const items = (Array.isArray(category.items) ? category.items : []).map((item) =&gt; {
            if (!isRawMenuItem(item)) {
                console.warn('Invalid item data encountered:', item);
                return {
                    name: 'Invalid Item',
                    description: undefined,
                    price: undefined,
                    dietary_tags: [],
                };
            }
            let price = undefined;
            if (typeof item.price === 'number') {
                price = item.price;
            }
            else if (typeof item.price === 'string') {
                const parsedPrice = Number.parseFloat(item.price.replaceAll(/[^\d.-]/g, ''));
                if (!Number.isNaN(parsedPrice)) {
                    price = parsedPrice;
                }
            }
            return {
                name: item.name ?? 'Unknown Item',
                description: item.description ?? undefined,
                price: price,
                dietary_tags: Array.isArray(item.dietary_tags) ? item.dietary_tags : [],
            };
        });
        return {
            name: category.category ?? category.name ?? 'Uncategorized',
            items: items,
        };
    });
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/lib/performance/webVitals.js (Line 1:1 - Line 374:2), C:/AI/food-truck-finder-poc/dist/lib/lib/performance/webVitals.js (Line 1:1 - Line 374:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn190" onclick="toggleCodeBlock('cloneGroup190', 'expandBtn190', 'collapseBtn190')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn190" onclick="toggleCodeBlock('cloneGroup190', 'expandBtn190', 'collapseBtn190')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup190"><code class="language-javascript text-sm text-gray-800">/**
 * SOTA Core Web Vitals Monitoring Implementation
 * Tracks LCP, FID, CLS, FCP, and TTFB metrics for performance optimization
 */
import { getCLS, getFCP, getFID, getLCP, getTTFB } from 'web-vitals';
// Performance thresholds based on Google's Core Web Vitals standards
export const PERFORMANCE_THRESHOLDS = {
    LCP: { good: 2500, needsImprovement: 4000 }, // Largest Contentful Paint
    FID: { good: 100, needsImprovement: 300 }, // First Input Delay
    CLS: { good: 0.1, needsImprovement: 0.25 }, // Cumulative Layout Shift
    FCP: { good: 1800, needsImprovement: 3000 }, // First Contentful Paint
    TTFB: { good: 800, needsImprovement: 1800 }, // Time to First Byte
};
// In-memory storage for metrics (in production, send to analytics service)
const metricsStore = [];
/**
 * Categorizes metric value based on thresholds
 */
function getRating(name, value) {
    const thresholds = PERFORMANCE_THRESHOLDS[name];
    if (value &lt;= thresholds.good)
        return 'good';
    if (value &lt;= thresholds.needsImprovement)
        return 'needs-improvement';
    return 'poor';
}
/**
 * Processes and stores a web vital metric
 */
function handleMetric(metric) {
    // Type-safe casting with validation
    const metricName = String(metric.name);
    const metricValue = Number(metric.value);
    const performanceMetric = {
        name: metricName,
        value: metricValue,
        rating: getRating(metricName, metricValue),
        timestamp: Date.now(),
        url: globalThis.location.href,
        userAgent: navigator.userAgent,
    };
    // Store metric locally
    metricsStore.push(performanceMetric);
    // Send to analytics endpoint (non-blocking)
    sendMetricToAnalytics(performanceMetric).catch((error) =&gt; {
        console.warn('Failed to send metric to analytics:', error);
    });
    // Log performance issues
    if (performanceMetric.rating === 'poor') {
        console.warn(`Poor ${metricName} performance:`, {
            value: metricValue,
            threshold: PERFORMANCE_THRESHOLDS[metricName],
            url: performanceMetric.url,
        });
    }
}
/**
 * Sends metric data to analytics endpoint
 */
async function sendMetricToAnalytics(metric) {
    try {
        await fetch('/api/analytics/web-vitals', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(metric),
        });
    }
    catch (error) {
        // Silently fail - don't impact user experience
        console.info('Analytics endpoint unavailable:', error);
    }
}
/**
 * Initializes Core Web Vitals monitoring
 * Call this in your app's root component or _app.tsx
 */
export function initWebVitalsMonitoring() {
    try {
        // Type-safe metric handlers with explicit casting
        const safeHandleMetric = (metric) =&gt; handleMetric(metric);
        getCLS(safeHandleMetric);
        getFCP(safeHandleMetric);
        getFID(safeHandleMetric);
        getLCP(safeHandleMetric);
        getTTFB(safeHandleMetric);
    }
    catch (error) {
        console.warn('Failed to initialize web vitals monitoring:', error);
    }
}
/**
 * Gets current performance metrics summary
 */
export function getPerformanceMetrics() {
    const summary = {};
    // Initialize summary for all metrics
    for (const metricName of Object.keys(PERFORMANCE_THRESHOLDS)) {
        const name = metricName;
        const metricData = metricsStore.filter((m) =&gt; m.name === name);
        if (metricData.length === 0) {
            summary[name] = {
                latest: null,
                average: 0,
                rating: 'no-data',
                count: 0,
            };
        }
        else {
            const latest = metricData.at(-1);
            const average = metricData.reduce((sum, m) =&gt; sum + m.value, 0) / metricData.length;
            summary[name] = {
                latest: latest?.value ?? null,
                average: Math.round(average),
                rating: getRating(name, average),
                count: metricData.length,
            };
        }
    }
    return {
        metrics: [...metricsStore],
        summary,
    };
}
/**
 * Performance budget checker
 */
export function checkPerformanceBudget() {
    const { summary } = getPerformanceMetrics();
    const violations = [];
    for (const [metricName, data] of Object.entries(summary)) {
        const name = metricName;
        if (data.latest == undefined)
            continue;
        const thresholds = PERFORMANCE_THRESHOLDS[name];
        if (data.latest &gt; thresholds.needsImprovement) {
            violations.push({
                metric: name,
                value: data.latest,
                threshold: thresholds.needsImprovement,
                severity: 'critical',
            });
        }
        else if (data.latest &gt; thresholds.good) {
            violations.push({
                metric: name,
                value: data.latest,
                threshold: thresholds.good,
                severity: 'warning',
            });
        }
    }
    return {
        passed: violations.length === 0,
        violations,
    };
}
/**
 * Generates a list of suggestions to improve Largest Contentful Paint (LCP).
 * @example
 * getLCPSuggestions({ latest: 3000 })
 * Returns an array with LCP improvement suggestions when the latest LCP is 3000ms.
 * @param {Object} data - Contains performance metrics data.
 * @param {number|null} data.latest - The latest LCP measure in milliseconds.
 * @returns {PerformanceSuggestion[]} An array of performance suggestions for optimizing LCP.
 * @description
 *   - The function assumes the LCP target is less than 2500ms.
 *   - Suggestions focus on optimizing various aspects like image loading, server response, and resource preloading.
 */
function getLCPSuggestions(data) {
    return [
        {
            metric: 'LCP',
            issue: `Largest Contentful Paint is ${data.latest}ms (target: &lt;2500ms)`,
            suggestions: [
                'Optimize images with Next.js Image component',
                'Implement lazy loading for non-critical content',
                'Use CDN for static assets',
                'Optimize server response times',
                'Preload critical resources',
            ],
            priority: 'high',
        },
    ];
}
/**
 * Generates suggestions to improve First Input Delay (FID) performance.
 * @example
 * getFIDSuggestions({ latest: 150 })
 * [
 *   {
 *     metric: 'FID',
 *     issue: 'First Input Delay is 150ms (target: &lt;100ms)',
 *     suggestions: [
 *       'Reduce JavaScript bundle size',
 *       'Implement code splitting',
 *       'Use web workers for heavy computations',
 *       'Optimize third-party scripts',
 *       'Defer non-critical JavaScript',
 *     ],
 *     priority: 'high',
 *   },
 * ]
 * @param {Object} data - Contains the latest FID measurement.
 * @param {number|null} data.latest - The latest FID metric value.
 * @returns {PerformanceSuggestion[]} A list of suggestions to improve FID.
 * @description
 *   - Suggests actionable improvements if FID exceeds target threshold.
 *   - Provides solutions focusing on JS optimizations.
 */
function getFIDSuggestions(data) {
    return [
        {
            metric: 'FID',
            issue: `First Input Delay is ${data.latest}ms (target: &lt;100ms)`,
            suggestions: [
                'Reduce JavaScript bundle size',
                'Implement code splitting',
                'Use web workers for heavy computations',
                'Optimize third-party scripts',
                'Defer non-critical JavaScript',
            ],
            priority: 'high',
        },
    ];
}
/**
 * Generates performance suggestions based on Cumulative Layout Shift (CLS) data.
 * @example
 * getCLSSuggestions({ latest: 0.25 })
 * // Returns array of suggestions indicating the CLS value and recommendations on improving it.
 * @param {{ latest: number | null }} data - Object containing the latest CLS measurement.
 * @returns {PerformanceSuggestion[]} An array of performance suggestions to address CLS issues.
 * @description
 *   - Suggests best practices to reduce CLS, aiming for a value below 0.1.
 *   - Prioritizes medium concern for updates that could improve visual stability.
 *   - Incorporates practical strategies for developers focusing on layout changes.
 */
function getCLSSuggestions(data) {
    return [
        {
            metric: 'CLS',
            issue: `Cumulative Layout Shift is ${data.latest} (target: &lt;0.1)`,
            suggestions: [
                'Set explicit dimensions for images and videos',
                'Reserve space for dynamic content',
                'Use CSS aspect-ratio for responsive images',
                'Avoid inserting content above existing content',
                'Use transform animations instead of layout changes',
            ],
            priority: 'medium',
        },
    ];
}
/**
* Generates suggestions to improve the First Contentful Paint performance metric.
* @example
* getFCPSuggestions({ latest: 2000 })
* Returns an array with suggestions to optimize FCP targeting &lt;1800ms.
* @param {Object} data - Contains performance metric values.
* @param {number|null} data.latest - Latest measured FCP value in milliseconds.
* @returns {PerformanceSuggestion[]} Array of suggestions for improving FCP metric.
* @description
*   - Suggests optimizations related to the rendering path and resource loading.
*   - Provides actions with a medium priority level to improve website performance.
*/
function getFCPSuggestions(data) {
    return [
        {
            metric: 'FCP',
            issue: `First Contentful Paint is ${data.latest}ms (target: &lt;1800ms)`,
            suggestions: [
                'Optimize critical rendering path',
                'Inline critical CSS',
                'Minimize render-blocking resources',
                'Use resource hints (preload, prefetch)',
                'Optimize web fonts loading',
            ],
            priority: 'medium',
        },
    ];
}
/**
 * Generates suggestions to improve Time to First Byte (TTFB) performance based on the latest measurement.
 * @example
 * getTTFBSuggestions({ latest: 950 })
 * [
 *   {
 *     metric: 'TTFB',
 *     issue: 'Time to First Byte is 950ms (target: &lt;800ms)',
 *     suggestions: [
 *       'Optimize server response times',
 *       'Use CDN for global distribution',
 *       'Implement server-side caching',
 *       'Optimize database queries',
 *       'Use edge computing for dynamic content'
 *     ],
 *     priority: 'high'
 *   }
 * ]
 * @param {Object} data - An object containing the latest TTFB measurement.
 * @param {number|null} data.latest - The latest TTFB value in milliseconds or null if not available.
 * @returns {PerformanceSuggestion[]} An array containing performance improvement suggestions for TTFB.
 * @description
 *   - The function assumes a target TTFB of under 800ms.
 *   - Generates a high-priority performance suggestion report.
 */
function getTTFBSuggestions(data) {
    return [
        {
            metric: 'TTFB',
            issue: `Time to First Byte is ${data.latest}ms (target: &lt;800ms)`,
            suggestions: [
                'Optimize server response times',
                'Use CDN for global distribution',
                'Implement server-side caching',
                'Optimize database queries',
                'Use edge computing for dynamic content',
            ],
            priority: 'high',
        },
    ];
}
/**
 * Generates a list of performance optimization suggestions based on Web Vitals metrics.
 * @example
 * getPerformanceOptimizationSuggestions()
 * [
 *   { name: 'Optimize LCP', priority: 'high' },
 *   { name: 'Improve FID', priority: 'medium' }
 * ]
 * @returns {PerformanceSuggestion[]} An array of performance suggestions sorted by priority.
 * @description
 *   - Analyzes performance metrics including LCP, FID, CLS, FCP, and TTFB.
 *   - Generates suggestions only for metrics rated as 'poor' or 'needs-improvement'.
 *   - Prioritizes suggestions based on urgency, sorting them by priority level.
 *   - Utilizes helper functions to generate specific suggestions for each metric type.
 */
export function getPerformanceOptimizationSuggestions() {
    const { summary } = getPerformanceMetrics();
    let allSuggestions = [];
    for (const [metricName, data] of Object.entries(summary)) {
        const name = metricName;
        if (data.rating === 'poor' || data.rating === 'needs-improvement') {
            switch (name) {
                case 'LCP': {
                    allSuggestions = [...allSuggestions, ...getLCPSuggestions(data)];
                    break;
                }
                case 'FID': {
                    allSuggestions = [...allSuggestions, ...getFIDSuggestions(data)];
                    break;
                }
                case 'CLS': {
                    allSuggestions = [...allSuggestions, ...getCLSSuggestions(data)];
                    break;
                }
                case 'FCP': {
                    allSuggestions = [...allSuggestions, ...getFCPSuggestions(data)];
                    break;
                }
                case 'TTFB': {
                    allSuggestions = [...allSuggestions, ...getTTFBSuggestions(data)];
                    break;
                }
            }
        }
    }
    return allSuggestions.sort((a, b) =&gt; {
        const priorityOrder = { high: 3, medium: 2, low: 1 };
        return priorityOrder[b.priority] - priorityOrder[a.priority];
    });
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/lib/performance/databaseCache.js (Line 1:1 - Line 223:2), C:/AI/food-truck-finder-poc/dist/lib/lib/performance/databaseCache.js (Line 1:1 - Line 223:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn192" onclick="toggleCodeBlock('cloneGroup192', 'expandBtn192', 'collapseBtn192')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn192" onclick="toggleCodeBlock('cloneGroup192', 'expandBtn192', 'collapseBtn192')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup192"><code class="language-javascript text-sm text-gray-800">/**
 * SOTA Database Query Optimization and Caching
 * Implements Next.js unstable_cache for optimal performance
 */
import { unstable_cache } from 'next/cache';
import { supabaseAdmin, FoodTruckService } from '../../supabase/client.js';
// Cache configuration
const CACHE_CONFIG = {
    // Short-term cache for frequently changing data
    SHORT_TTL: 60 * 5, // 5 minutes
    // Medium-term cache for semi-static data
    MEDIUM_TTL: 60 * 30, // 30 minutes
    // Long-term cache for static data
    LONG_TTL: 60 * 60 * 24, // 24 hours
};
/**
 * Cached food truck queries with optimized database access
 */
export const CachedFoodTruckService = {
    /**
     * Get all food trucks with caching
     * Cache for 30 minutes since truck data changes moderately
     */
    getAllTrucksCached: unstable_cache(async () =&gt; {
        console.info('CachedFoodTruckService: Cache miss - fetching all trucks from database');
        const result = await FoodTruckService.getAllTrucks();
        if ('error' in result) {
            throw new Error(`Failed to fetch all trucks: ${result.error}`);
        }
        return { trucks: result.trucks, count: result.total };
    }, ['all-trucks'], {
        revalidate: CACHE_CONFIG.MEDIUM_TTL,
        tags: ['food-trucks', 'all-trucks'],
    }),
    /**
     * Get trucks by location with caching
     * Cache for 5 minutes since location-based queries are time-sensitive
     */
    getTrucksByLocationCached: unstable_cache(async (lat, lng, radiusKm) =&gt; {
        console.info(`CachedFoodTruckService: Cache miss - fetching trucks near ${lat},${lng} (${radiusKm}km)`);
        const result = await FoodTruckService.getTrucksByLocation(lat, lng, radiusKm);
        if ('error' in result) {
            throw new Error(`Failed to fetch trucks by location: ${result.error}`);
        }
        return result;
    }, ['trucks-by-location'], {
        revalidate: CACHE_CONFIG.SHORT_TTL,
        tags: ['food-trucks', 'location-search'],
    }),
    /**
     * Get truck by ID with caching
     * Cache for 30 minutes since individual truck data is relatively stable
     */
    getTruckByIdCached: unstable_cache(async (id) =&gt; {
        console.info(`CachedFoodTruckService: Cache miss - fetching truck ${id} from database`);
        const result = await FoodTruckService.getTruckById(id);
        if ('error' in result) {
            return null;
        }
        return result;
    }, ['truck-by-id'], {
        revalidate: CACHE_CONFIG.MEDIUM_TTL,
        tags: ['food-trucks', 'truck-details'],
    }),
    /**
     * Search trucks with caching
     * Cache for 5 minutes since search results should be relatively fresh
     */
    searchTrucksCached: unstable_cache(async (query, filters) =&gt; {
        console.info(`CachedFoodTruckService: Cache miss - searching trucks for &quot;${query}&quot;`);
        if (supabaseAdmin == undefined) {
            throw new Error('Supabase admin client not available');
        }
        let dbQuery = supabaseAdmin
            .from('food_trucks')
            .select('*')
            .or(`name.ilike.%${query}%,description.ilike.%${query}%,cuisine_type.cs.{${query}}`);
        // Apply filters
        if (filters?.cuisine != undefined &amp;&amp; filters.cuisine !== '') {
            dbQuery = dbQuery.contains('cuisine_type', [filters.cuisine]);
        }
        const { data, error } = await dbQuery.limit(50);
        const trucks = data ?? [];
        if (error != undefined) {
            const errorMessage = error instanceof Error ? error.message : JSON.stringify(error);
            throw new Error(`Search query failed: ${errorMessage}`);
        }
        let results = trucks ?? [];
        // Apply location filter if provided
        if (filters?.lat != undefined &amp;&amp; filters?.lng != undefined &amp;&amp; filters?.radius != undefined) {
            results = results.filter((truck) =&gt; {
                if (truck.current_location?.lat == undefined ||
                    truck.current_location?.lng == undefined) {
                    return false;
                }
                const distance = calculateDistance(filters.lat, // Assert as number, as it's checked by the outer if condition
                filters.lng, // Assert as number, as it's checked by the outer if condition
                truck.current_location.lat, truck.current_location.lng);
                return distance &lt;= (filters.radius ?? 10);
            });
        }
        // Apply openNow filter if provided
        if (filters?.openNow === true) {
            const now = new Date();
            const currentDay = now.toLocaleDateString('en-US', { weekday: 'short' }).toLowerCase(); // 'mon', 'tue', etc.
            const currentTime = now.getHours() * 100 + now.getMinutes(); // HHMM format
            results = results.filter((truck) =&gt; {
                const hours = truck.operating_hours?.[currentDay];
                if (hours == undefined || hours.closed === true)
                    return false;
                const openTime = parseTimeString(hours.open ?? '');
                const closeTime = parseTimeString(hours.close ?? '');
                return currentTime &gt;= openTime &amp;&amp; currentTime &lt;= closeTime;
            });
        }
        return results;
    }, ['search-trucks'], {
        revalidate: CACHE_CONFIG.SHORT_TTL,
        tags: ['food-trucks', 'search'],
    }),
    /**
     * Get data quality statistics with caching
     * Cache for 24 hours since quality stats change slowly
     */
    getDataQualityStatsCached: unstable_cache(async () =&gt; {
        console.info('CachedFoodTruckService: Cache miss - calculating data quality stats');
        if (supabaseAdmin == undefined) {
            throw new Error('Supabase admin client not available');
        }
        const { data: trucks, error } = await supabaseAdmin
            .from('food_trucks')
            .select('data_quality_score');
        if (error) {
            throw new Error(`Quality stats query failed: ${error.message}`);
        }
        const scores = trucks == undefined
            ? []
            : trucks.map((t) =&gt; t.data_quality_score ?? 0);
        const averageScore = scores.length &gt; 0
            ? scores.reduce((sum, score) =&gt; sum + score, 0) / scores.length
            : 0;
        const distribution = {
            high: scores.filter((s) =&gt; s &gt;= 0.8).length,
            medium: scores.filter((s) =&gt; s &gt;= 0.6 &amp;&amp; s &lt; 0.8).length,
            low: scores.filter((s) =&gt; s &lt; 0.6).length,
        };
        return {
            averageScore: Math.round(averageScore * 100) / 100,
            distribution,
            totalTrucks: scores.length,
        };
    }, ['data-quality-stats'], {
        revalidate: CACHE_CONFIG.LONG_TTL,
        tags: ['food-trucks', 'data-quality'],
    }),
};
/**
 * Cache invalidation utilities
 */
export const CacheManager = {
    /**
     * Invalidate all food truck related caches
     */
    async invalidateAllFoodTruckCaches() {
        try {
            const { revalidateTag } = await import('next/cache');
            revalidateTag('food-trucks');
            console.info('CacheManager: Invalidated all food truck caches');
        }
        catch (error) {
            console.warn('CacheManager: Failed to invalidate caches:', error);
        }
    },
    /**
     * Invalidate specific truck cache
     */
    async invalidateTruckCache(truckId) {
        try {
            const { revalidateTag } = await import('next/cache');
            revalidateTag(`truck-${truckId}`);
            revalidateTag('food-trucks'); // Also invalidate general caches
            console.info(`CacheManager: Invalidated cache for truck ${truckId}`);
        }
        catch (error) {
            console.warn('CacheManager: Failed to invalidate truck cache:', error);
        }
    },
    /**
     * Invalidate search and location caches
     */
    async invalidateSearchCaches() {
        try {
            const { revalidateTag } = await import('next/cache');
            revalidateTag('search');
            revalidateTag('location-search');
            console.info('CacheManager: Invalidated search caches');
        }
        catch (error) {
            console.warn('CacheManager: Failed to invalidate search caches:', error);
        }
    },
};
/**
 * Utility functions
 */
function calculateDistance(lat1, lng1, lat2, lng2) {
    const R = 6371; // Earth's radius in kilometers
    const dLat = ((lat2 - lat1) * Math.PI) / 180;
    const dLng = ((lng2 - lng1) * Math.PI) / 180;
    const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
        Math.cos((lat1 * Math.PI) / 180) *
            Math.cos((lat2 * Math.PI) / 180) *
            Math.sin(dLng / 2) *
            Math.sin(dLng / 2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    return R * c;
}
function parseTimeString(timeStr) {
    if (timeStr == undefined || timeStr === '')
        return 0;
    const [hours, minutes] = timeStr.split(':').map(Number);
    return hours * 100 + (minutes ?? 0);
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/lib/monitoring/apiMonitor.js (Line 5:17 - Line 312:2), C:/AI/food-truck-finder-poc/dist/lib/lib/monitoring/apiMonitor.js (Line 5:27 - Line 312:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn198" onclick="toggleCodeBlock('cloneGroup198', 'expandBtn198', 'collapseBtn198')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn198" onclick="toggleCodeBlock('cloneGroup198', 'expandBtn198', 'collapseBtn198')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup198"><code class="language-javascript text-sm text-gray-800">;
// API Rate Limits Configuration
export const API_LIMITS = {
    gemini: {
        requests: { daily: 1500, hourly: 100 },
        tokens: { daily: 32_000, hourly: 2000 },
        alertThresholds: { warning: 0.8, critical: 0.95 },
    },
    firecrawl: {
        requests: { daily: 500, hourly: 50 },
        tokens: { daily: 0, hourly: 0 },
        alertThresholds: { warning: 0.8, critical: 0.95 },
    },
    tavily: {
        requests: { daily: 1000, hourly: 100 },
        tokens: { daily: 0, hourly: 0 },
        alertThresholds: { warning: 0.8, critical: 0.95 },
    },
    supabase: {
        requests: { daily: 50_000, hourly: 5000 },
        tokens: { daily: 0, hourly: 0 },
        alertThresholds: { warning: 0.9, critical: 0.98 },
    },
};
/**
 * Comprehensive API Monitoring Service
 */
export class APIMonitor {
    static alertHistory = [];
    /**
     * Check if API request can be made safely
     */
    static async canMakeRequest(service, requestCount = 1, tokenCount = 0) {
        try {
            const usage = await this.getCurrentUsage(service);
            const limits = API_LIMITS[service];
            // Check daily limits
            const newRequestCount = usage.requests.used + requestCount;
            const newTokenCount = (usage.tokens?.used ?? 0) + tokenCount;
            if (newRequestCount &gt; limits.requests.daily) {
                return {
                    allowed: false,
                    reason: `Daily request limit exceeded (${newRequestCount}/${limits.requests.daily})`,
                    waitTime: this.getTimeUntilReset('daily'),
                };
            }
            if (limits.tokens != undefined &amp;&amp; newTokenCount &gt; limits.tokens.daily) {
                return {
                    allowed: false,
                    reason: `Daily token limit exceeded (${newTokenCount}/${limits.tokens.daily})`,
                    waitTime: this.getTimeUntilReset('daily'),
                };
            }
            // Check if approaching critical threshold
            const requestPercentage = newRequestCount / limits.requests.daily;
            if (requestPercentage &gt; limits.alertThresholds.critical) {
                return {
                    allowed: false,
                    reason: `Approaching critical usage threshold (${(requestPercentage * 100).toFixed(1)}%)`,
                    waitTime: this.getTimeUntilReset('daily'),
                };
            }
            return { allowed: true };
        }
        catch (error) {
            console.error(`Error checking API limits for ${service}:`, error);
            // Fail safe - allow request but log error
            return { allowed: true };
        }
    }
    /**
     * Get current usage for a service
     */
    static async getCurrentUsage(service) {
        const todayUsage = await APIUsageService.getTodayUsage(service);
        const limits = API_LIMITS[service];
        const usage = {
            requests: {
                used: todayUsage?.requests_count ?? 0,
                limit: limits.requests.daily,
                percentage: ((todayUsage?.requests_count ?? 0) / limits.requests.daily) * 100,
            },
        };
        if (limits.tokens.daily &gt; 0) {
            usage.tokens = {
                used: todayUsage?.tokens_used ?? 0,
                limit: limits.tokens.daily,
                percentage: ((todayUsage?.tokens_used ?? 0) / limits.tokens.daily) * 100,
            };
        }
        return usage;
    }
    /**
     * Comprehensive monitoring check for all APIs
     */
    static async checkAllAPIs() {
        const alerts = [];
        const usage = {};
        const recommendations = [];
        let canMakeRequest = true;
        for (const service of Object.keys(API_LIMITS)) {
            try {
                const serviceUsage = await this.getCurrentUsage(service);
                usage[service] = serviceUsage;
                // Check for alerts
                const serviceAlerts = this.generateAlerts(service, serviceUsage);
                alerts.push(...serviceAlerts);
                // Check if any service is at critical level
                if (serviceUsage.requests.percentage &gt; API_LIMITS[service].alertThresholds.critical * 100) {
                    canMakeRequest = false;
                }
            }
            catch (error) {
                console.error(`Error monitoring ${service}:`, error);
                alerts.push({
                    service,
                    level: 'warning',
                    message: `Failed to check usage for ${service}`,
                    usage: { current: 0, limit: 0, percentage: 0 },
                    timestamp: new Date().toISOString(),
                    recommendations: ['Check API connectivity', 'Verify credentials'],
                });
            }
        }
        // Generate global recommendations
        recommendations.push(...this.generateRecommendations(usage, alerts));
        return {
            canMakeRequest,
            alerts,
            usage,
            recommendations,
        };
    }
    // Helper for token alerts
    /**
     * Generates token usage alerts based on API usage data and predefined limits.
     * @example
     * generateTokenAlerts(APIServiceInstance, usageData, apiLimits, '2023-10-21T10:20:30Z')
     * [{ service: 'exampleService', level: 'warning', message: 'Warning: exampleService token usage at 75.0%', ... }]
     * @param {APIService} service - The API service for which the alerts are being generated.
     * @param {APIUsageData} usage - Object containing the token usage statistics.
     * @param {Object} limits - Configuration object specifying API limits and alert thresholds.
     * @param {string} timestamp - The timestamp at which the alert is generated.
     * @returns {APIUsageAlert[]} List of alerts generated based on token usage percentage compared to limits.
     * @description
     *   - Generates 'warning' alerts if token usage exceeds the warning threshold.
     *   - Generates 'critical' alerts if token usage exceeds the critical threshold.
     *   - Provides recommendations for optimizing token usage when an alert is generated.
     */
    static generateTokenAlerts(service, usage, limits, timestamp) {
        const alerts = [];
        if (usage.tokens &amp;&amp; limits.tokens.daily &gt; 0) {
            const tokenPercentage = usage.tokens.percentage;
            if (tokenPercentage &gt; limits.alertThresholds.critical * 100) {
                alerts.push({
                    service,
                    level: 'critical',
                    message: `Critical: ${service} token usage at ${tokenPercentage.toFixed(1)}%`,
                    usage: {
                        current: usage.tokens.used,
                        limit: usage.tokens.limit,
                        percentage: tokenPercentage,
                    },
                    timestamp,
                    recommendations: [
                        'Reduce prompt complexity',
                        'Implement response caching',
                        'Optimize token usage patterns',
                    ],
                });
            }
            else if (tokenPercentage &gt; limits.alertThresholds.warning * 100) {
                alerts.push({
                    service,
                    level: 'warning',
                    message: `Warning: ${service} token usage at ${tokenPercentage.toFixed(1)}%`,
                    usage: {
                        current: usage.tokens.used,
                        limit: usage.tokens.limit,
                        percentage: tokenPercentage,
                    },
                    timestamp,
                    recommendations: [
                        'Monitor token consumption',
                        'Optimize prompt efficiency',
                        'Consider response caching',
                    ],
                });
            }
        }
        return alerts;
    }
    /**
     * Generates usage alerts based on the service's API usage data.
     * @example
     * generateAlerts(APIService.YOUR_SERVICE, apiUsageData)
     * returns an array of APIUsageAlert objects when usage thresholds are exceeded.
     * @param {APIService} service - The API service being monitored.
     * @param {APIUsageData} usage - The usage data containing request and token information.
     * @returns {APIUsageAlert[]} An array of alert objects representing warning or critical usage states.
     * @description
     *   - Determines alert level based on predefined thresholds in API_LIMITS.
     *   - Generates alerts for both request and token usage.
     *   - Updates alert history, maintaining only the last 100 alerts.
     */
    static generateAlerts(service, usage) {
        const alerts = [];
        const limits = API_LIMITS[service];
        const timestamp = new Date().toISOString();
        // Check request usage
        const requestPercentage = usage.requests.percentage;
        if (requestPercentage &gt; limits.alertThresholds.critical * 100) {
            alerts.push({
                service,
                level: 'critical',
                message: `Critical: ${service} request usage at ${requestPercentage.toFixed(1)}%`,
                usage: {
                    current: usage.requests.used,
                    limit: usage.requests.limit,
                    percentage: requestPercentage,
                },
                timestamp,
                recommendations: [
                    'Immediately reduce API calls',
                    'Implement request queuing',
                    'Consider upgrading API plan',
                ],
            });
        }
        else if (requestPercentage &gt; limits.alertThresholds.warning * 100) {
            alerts.push({
                service,
                level: 'warning',
                message: `Warning: ${service} request usage at ${requestPercentage.toFixed(1)}%`,
                usage: {
                    current: usage.requests.used,
                    limit: usage.requests.limit,
                    percentage: requestPercentage,
                },
                timestamp,
                recommendations: [
                    'Monitor usage closely',
                    'Optimize request patterns',
                    'Enable request caching',
                ],
            });
        }
        // Token alerts
        alerts.push(...this.generateTokenAlerts(service, usage, limits, timestamp));
        // Store alerts in history
        this.alertHistory.push(...alerts);
        // Keep only last 100 alerts
        if (this.alertHistory.length &gt; 100) {
            this.alertHistory = this.alertHistory.slice(-100);
        }
        return alerts;
    }
    /**
     * Generate optimization recommendations
     */
    static generateRecommendations(usage, alerts) {
        const recommendations = [];
        // High-level optimization recommendations
        const criticalAlerts = alerts.filter((a) =&gt; a.level === 'critical');
        const warningAlerts = alerts.filter((a) =&gt; a.level === 'warning');
        if (criticalAlerts.length &gt; 0) {
            recommendations.push('URGENT: Implement immediate API throttling', 'Enable aggressive caching for all API responses', 'Consider upgrading API plans for critical services');
        }
        if (warningAlerts.length &gt; 0) {
            recommendations.push('Implement request queuing and batching', 'Optimize API call patterns and frequency', 'Enable response caching where possible');
        }
        // Service-specific recommendations
        if (usage.gemini?.requests?.percentage &gt; 70) {
            recommendations.push('Gemini: Optimize prompt length and complexity', 'Gemini: Implement response caching for similar queries');
        }
        if (usage.firecrawl?.requests?.percentage &gt; 70) {
            recommendations.push('Firecrawl: Implement URL deduplication', 'Firecrawl: Cache crawl results for repeated URLs');
        }
        return [...new Set(recommendations)]; // Remove duplicates
    }
    /**
     * Get time until rate limit reset
     */
    static getTimeUntilReset(period) {
        const now = new Date();
        if (period === 'hourly') {
            const nextHour = new Date(now);
            nextHour.setHours(now.getHours() + 1, 0, 0, 0);
            return nextHour.getTime() - now.getTime();
        }
        const nextDay = new Date(now);
        nextDay.setDate(now.getDate() + 1);
        nextDay.setHours(0, 0, 0, 0);
        return nextDay.getTime() - now.getTime();
    }
    /**
     * Get alert history
     */
    static getAlertHistory() {
        return [...this.alertHistory];
    }
    /**
     * Clear alert history
     */
    static clearAlertHistory() {
        this.alertHistory = [];
    }
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/lib/middleware/middlewareHelpers.js (Line 1:1 - Line 176:2), C:/AI/food-truck-finder-poc/dist/lib/lib/middleware/middlewareHelpers.js (Line 1:1 - Line 176:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn200" onclick="toggleCodeBlock('cloneGroup200', 'expandBtn200', 'collapseBtn200')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn200" onclick="toggleCodeBlock('cloneGroup200', 'expandBtn200', 'collapseBtn200')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup200"><code class="language-javascript text-sm text-gray-800">import { NextResponse } from 'next/server';
import { AuditLogger } from '../../security/auditLogger';
import { createSupabaseMiddlewareClient } from '../../supabaseMiddleware';
/**
 * Logs a security event and redirects the request to a specified path.
 * @example
 * logSecurityEventAndRedirect({ req, res, logParams, redirectPath, redirectFromPath })
 * NextResponse with redirect to the target path
 * @param {Object} params - The parameters for the function.
 * @param {Request} params.req - The original request object containing the URL to clone for redirection.
 * @param {Response} params._res - The original response object (unused in function, but part of expected parameters).
 * @param {Object} params.logParams - Parameters required by the AuditLogger to log the security event.
 * @param {string} params.redirectPath - The pathname where the request should be redirected.
 * @param {string} [params.redirectFromPath] - Optional pathname indicating where the redirect originated from.
 * @returns {NextResponse} A response that performs a redirect to the specified path.
 * @description
 *   - The function uses AuditLogger to record the security event.
 *   - It clones the current URL from the request to ensure original query parameters are preserved.
 *   - Redirect path can optionally include info on where the redirect originated via a search parameter.
 */
async function logSecurityEventAndRedirect({ req, res: _res, logParams, redirectPath, redirectFromPath, }) {
    await AuditLogger.logSecurityEvent(logParams);
    const redirectUrl = req.nextUrl.clone();
    redirectUrl.pathname = redirectPath;
    if (redirectFromPath) {
        redirectUrl.searchParams.set(`redirectedFrom`, redirectFromPath);
    }
    return NextResponse.redirect(redirectUrl);
}
/**
 * Logs a security event and redirects the user to the login page.
 * @example
 * logAndRedirect({
 *   req: requestObject,
 *   res: responseObject,
 *   requestMetadata: { ip: '192.168.1.1', userAgent: 'Mozilla/5.0', url: '/dashboard' },
 *   reason: 'Session Expired',
 *   userError: new Error('User authentication failed')
 * })
 * // Redirects user to login page and logs the event
 * @param {Object} req - Express request object containing details of the incoming request.
 * @param {Object} res - Express response object used to send a response to the client.
 * @param {Object} requestMetadata - Metadata associated with the request, including IP and user agent.
 * @param {string} reason - The reason for redirect, generally describing why access was denied.
 * @param {Error} userError - Optional error object that provides additional context about the user error.
 * @returns {Promise&lt;void&gt;} Returns a promise that resolves once the security event is logged and redirect is completed.
 * @description
 *   - Utilizes a severity of 'warning' when logging security events.
 *   - Redirects users from the attempted URL to the login page.
 *   - Captures detailed information about the request including attempted URL and user agent.
 */
async function logAndRedirect({ req, res, requestMetadata, reason, userError, }) {
    return logSecurityEventAndRedirect({
        req,
        res,
        logParams: {
            event_type: 'permission_denied',
            ip_address: requestMetadata.ip,
            user_agent: requestMetadata.userAgent,
            details: {
                attempted_url: requestMetadata.url,
                reason,
                error: userError?.message,
            },
            severity: 'warning',
        },
        redirectPath: '/login',
        redirectFromPath: req.nextUrl.pathname,
    });
}
/**
 * Logs a security event and redirects to an access-denied page.
 * @example
 * logAndRedirectDenied({
 *   req: requestObject,
 *   res: responseObject,
 *   requestMetadata: metadataObject,
 *   user: userObject,
 *   profile: profileObject,
 *   profileQueryError: errorObject
 * })
 * // Redirects user and logs the event with relevant details
 * @param {Object} params - Contains necessary parameters for the function.
 * @param {Object} params.req - The HTTP request object.
 * @param {Object} params.res - The HTTP response object.
 * @param {Object} params.requestMetadata - Metadata related to the request.
 * @param {Object} params.user - User information object.
 * @param {Object} params.profile - Profile object related to the user.
 * @param {Object} params.profileQueryError - Error object if querying profile fails.
 * @returns {Promise&lt;void&gt;} Returns a promise that resolves after logging and redirecting.
 * @description
 *   - Utilizes `logSecurityEventAndRedirect` to perform logging and redirect operations.
 *   - The function assumes a structure for the user object, expecting 'id' and 'email' properties.
 *   - Redirects to '/access-denied' path by default.
 *   - Sets event severity as 'error' when logging the security event.
 */
async function logAndRedirectDenied({ req, res, requestMetadata, user, profile, profileQueryError, }) {
    return logSecurityEventAndRedirect({
        req,
        res,
        logParams: {
            event_type: 'permission_denied',
            user_id: user.id,
            user_email: user.email ?? undefined,
            ip_address: requestMetadata.ip,
            user_agent: requestMetadata.userAgent,
            details: {
                attempted_url: requestMetadata.url,
                user_role: profile?.role ?? 'none',
                reason: 'insufficient_privileges',
                error: profileQueryError?.message,
            },
            severity: 'error',
        },
        redirectPath: '/access-denied',
    });
}
/**
 * Protects admin routes by verifying user authentication and authorization.
 * @example
 * protectAdminRoutes(req, res, requestMetadata)
 * returns NextResponse or redirects depending on user authentication status.
 * @param {NextRequest} req - The incoming request object.
 * @param {NextResponse} res - The response object to send back to the client.
 * @param {RequestMetadata} requestMetadata - Metadata about the request for logging purposes.
 * @returns {NextResponse} Returns the response object or redirects to an error page.
 * @description
 *   - Fetches and verifies the user's session from Supabase.
 *   - Checks if the user is an admin based on the profile 'role' from the database.
 *   - Logs access attempts to the admin panel for auditing purposes.
 *   - Redirects to an appropriate error handler if the user isn't authenticated or authorized.
 */
export async function protectAdminRoutes(req, res, requestMetadata) {
    const supabase = createSupabaseMiddlewareClient(req, res);
    const { data, error: userError } = await supabase.auth.getUser();
    const user = data?.user;
    if (userError || !user) {
        return logAndRedirect({
            req,
            res,
            requestMetadata,
            reason: 'no_session',
            userError: userError ?? undefined,
        });
    }
    // Explicitly type the result of the Supabase query
    const { data: profile, error: profileQueryError } = (await supabase
        .from('profiles')
        .select('role')
        .eq('id', user.id)
        .single());
    if (profileQueryError || (profile &amp;&amp; profile.role !== 'admin')) {
        return logAndRedirectDenied({
            req,
            res,
            requestMetadata,
            user,
            profile: profile ?? null,
            profileQueryError: profileQueryError ?? undefined,
        });
    }
    if (req.method !== 'GET' || req.nextUrl.pathname.includes('/api/')) {
        await AuditLogger.logDataAccess({
            userId: user.id,
            userEmail: user.email ?? 'unknown',
            resourceType: 'admin_panel',
            resourceId: req.nextUrl.pathname,
            action: req.method === 'GET' ? 'read' : 'admin_access',
            request: {
                ip: requestMetadata.ip,
                userAgent: requestMetadata.userAgent,
            },
        });
    }
    return res;
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/lib/mappers/uprootedVeganMapper.js (Line 1:1 - Line 180:2), C:/AI/food-truck-finder-poc/dist/lib/lib/mappers/uprootedVeganMapper.js (Line 1:1 - Line 180:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn202" onclick="toggleCodeBlock('cloneGroup202', 'expandBtn202', 'collapseBtn202')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn202" onclick="toggleCodeBlock('cloneGroup202', 'expandBtn202', 'collapseBtn202')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup202"><code class="language-javascript text-sm text-gray-800">/**
 * Data mapper for Uprooted Vegan Cuisine onboarding
 *
 * This utility handles the transformation of Uprooted Vegan Cuisine data
 * to match our FoodTruck schema, including field mappings and defaults.
 */
/**
 * Normalizes cuisine_type to always be an array
 */
function normalizeCuisineType(cuisine_type) {
    if (typeof cuisine_type === 'string') {
        // Split on common separators and clean up
        return cuisine_type
            .split(/[,;&amp;]/)
            .map(c =&gt; c.trim())
            .filter(c =&gt; c.length &gt; 0);
    }
    return Array.isArray(cuisine_type) ? cuisine_type : [];
}
/**
 * Normalizes specialties to always be an array
 */
function normalizeSpecialties(specialties) {
    if (!specialties)
        return [];
    if (typeof specialties === 'string') {
        return specialties
            .split(/[,;&amp;]/)
            .map(s =&gt; s.trim())
            .filter(s =&gt; s.length &gt; 0);
    }
    return Array.isArray(specialties) ? specialties : [];
}
/**
 * Normalizes source URLs to always be an array
 */
function normalizeSourceUrls(source_urls) {
    if (!source_urls)
        return [];
    if (typeof source_urls === 'string') {
        return [source_urls];
    }
    return Array.isArray(source_urls) ? source_urls : [];
}
/**
 * Creates default operating hours
 */
function createDefaultOperatingHours() {
    return {
        monday: undefined,
        tuesday: undefined,
        wednesday: undefined,
        thursday: undefined,
        friday: undefined,
        saturday: undefined,
        sunday: undefined
    };
}
/**
 * Maps Uprooted Vegan Cuisine data to our FoodTruck schema
 */
export function mapUprootedVeganData(data) {
    const now = new Date().toISOString();
    // Handle location priority: exact_location &gt; current_location &gt; city_location
    const primaryLocation = data.exact_location || data.current_location || data.city_location;
    const mapped = {
        // Core fields
        name: data.name,
        description: data.description,
        cuisine_type: normalizeCuisineType(data.cuisine_type),
        price_range: data.price_range,
        specialties: normalizeSpecialties(data.specialties),
        // New fields for Uprooted Vegan support
        user_id: data.user_id,
        state: data.state,
        // Location fields
        current_location: primaryLocation ? {
            lat: primaryLocation.lat,
            lng: primaryLocation.lng,
            address: primaryLocation.address,
            timestamp: primaryLocation.timestamp || now,
        } : {
            lat: 0,
            lng: 0,
            address: undefined,
            timestamp: now,
        },
        scheduled_locations: data.scheduled_locations,
        // Menu and hours
        operating_hours: data.operating_hours || createDefaultOperatingHours(),
        menu: data.menu || [],
        // Contact information
        contact_info: data.contact_info || {},
        social_media: data.social_media || {},
        // Quality and verification
        data_quality_score: data.data_quality_score ?? 0.5, // Default to medium quality
        verification_status: data.verification_status || 'pending',
        source_urls: normalizeSourceUrls(data.source_urls),
        // Handle timestamps
        last_scraped_at: data.last_scraped_at || now,
        created_at: data.created_at || now,
        updated_at: data.updated_at || now,
        // Additional helpful defaults
        is_active: true, // Assume new entries are active
        test_run_flag: false // Not a test import
    };
    return mapped;
}
/**
 * Validates that required fields are present
 */
export function validateUprootedVeganData(data) {
    const errors = [];
    // Check required fields
    if (!data.name || data.name.trim().length === 0) {
        errors.push('name is required');
    }
    if (!data.cuisine_type ||
        (Array.isArray(data.cuisine_type) &amp;&amp; data.cuisine_type.length === 0) ||
        (typeof data.cuisine_type === 'string' &amp;&amp; data.cuisine_type.trim().length === 0)) {
        errors.push('cuisine_type is required');
    }
    // Validate state format if provided
    if (data.state &amp;&amp; (typeof data.state !== 'string' || data.state.length !== 2)) {
        errors.push('state must be a 2-character string (e.g., CA, NY, TX)');
    }
    // Validate user_id format if provided
    if (data.user_id &amp;&amp; typeof data.user_id !== 'string') {
        errors.push('user_id must be a valid UUID string');
    }
    // Validate price range if provided
    if (data.price_range &amp;&amp; !['$', '$$', '$$$', '$$$$'].includes(data.price_range)) {
        errors.push('price_range must be one of: $, $$, $$$, $$$$');
    }
    return {
        isValid: errors.length === 0,
        errors
    };
}
/**
 * Example usage and testing function
 */
export function createUprootedVeganExample() {
    return {
        name: &quot;Uprooted Vegan Cuisine&quot;,
        description: &quot;Plant-based comfort food truck serving delicious vegan alternatives&quot;,
        cuisine_type: [&quot;Vegan&quot;, &quot;American&quot;, &quot;Comfort Food&quot;],
        price_range: &quot;$$&quot;,
        specialties: [&quot;Vegan Burgers&quot;, &quot;Plant-Based Mac &amp; Cheese&quot;, &quot;Cashew-Based Desserts&quot;],
        user_id: &quot;123e4567-e89b-12d3-a456-426614174000&quot;, // Example UUID
        state: &quot;CA&quot;,
        current_location: {
            lat: 37.7749,
            lng: -122.4194,
            address: &quot;San Francisco, CA&quot;,
            timestamp: new Date().toISOString()
        },
        operating_hours: {
            monday: { open: &quot;11:00 AM&quot;, close: &quot;8:00 PM&quot; },
            tuesday: { open: &quot;11:00 AM&quot;, close: &quot;8:00 PM&quot; },
            wednesday: { open: &quot;11:00 AM&quot;, close: &quot;8:00 PM&quot; },
            thursday: { open: &quot;11:00 AM&quot;, close: &quot;8:00 PM&quot; },
            friday: { open: &quot;11:00 AM&quot;, close: &quot;9:00 PM&quot; },
            saturday: { open: &quot;10:00 AM&quot;, close: &quot;9:00 PM&quot; },
            sunday: { closed: true }
        },
        contact_info: {
            phone: &quot;(415) 555-0123&quot;,
            email: &quot;hello@uprootedvegan.com&quot;,
            website: &quot;https://uprootedvegan.com&quot;
        },
        social_media: {
            instagram: &quot;@uprootedvegan&quot;,
            facebook: &quot;UprootedVeganCuisine&quot;
        },
        verification_status: &quot;pending&quot;,
        data_quality_score: 0.8,
        source_urls: [&quot;https://uprootedvegan.com&quot;]
    };
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/lib/lib/ScraperEngine.js (Line 572:8 - Line 577:36), C:/AI/food-truck-finder-poc/dist/lib/lib/ScraperEngine.js (Line 539:8 - Line 544:32)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn208" onclick="toggleCodeBlock('cloneGroup208', 'expandBtn208', 'collapseBtn208')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn208" onclick="toggleCodeBlock('cloneGroup208', 'expandBtn208', 'collapseBtn208')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup208"><code class="language-javascript text-sm text-gray-800">;
            const response = await this.makeGeminiRequest(prompt);
            this.updateUsageCounters(1, prompt.length + response.length);
            const parsed = JSON.parse(response);
            if (parsed == undefined || typeof parsed !== 'object') {
                throw new Error('Invalid Gemini sentiment response'</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/lib/lib/firecrawl.js (Line 142:2 - Line 154:25), C:/AI/food-truck-finder-poc/dist/lib/lib/firecrawl.js (Line 77:2 - Line 89:26)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn209" onclick="toggleCodeBlock('cloneGroup209', 'expandBtn209', 'collapseBtn209')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn209" onclick="toggleCodeBlock('cloneGroup209', 'expandBtn209', 'collapseBtn209')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup209"><code class="language-javascript text-sm text-gray-800">,
                }),
            });
            const data = await response.json();
            if (!response.ok) {
                const errorData = data;
                throw new Error(errorData.error ?? `HTTP ${response.status}`);
            }
            this.setCacheResult(cacheKey, data);
            return data;
        }
        catch (error) {
            console.warn('Firecrawl crawl error:'</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/lib/lib/firecrawl.js (Line 184:2 - Line 195:26), C:/AI/food-truck-finder-poc/dist/lib/lib/firecrawl.js (Line 78:2 - Line 89:26)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn210" onclick="toggleCodeBlock('cloneGroup210', 'expandBtn210', 'collapseBtn210')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn210" onclick="toggleCodeBlock('cloneGroup210', 'expandBtn210', 'collapseBtn210')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup210"><code class="language-javascript text-sm text-gray-800">,
            });
            const data = await response.json();
            if (!response.ok) {
                const errorData = data;
                throw new Error(errorData.error ?? `HTTP ${response.status}`);
            }
            this.setCacheResult(cacheKey, data);
            return data;
        }
        catch (error) {
            console.warn('Firecrawl status error:'</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/lib/lib/discoveryEngine.js (Line 267:14 - Line 279:65), C:/AI/food-truck-finder-poc/dist/lib/lib/discoveryEngine.js (Line 204:13 - Line 216:56)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn211" onclick="toggleCodeBlock('cloneGroup211', 'expandBtn211', 'collapseBtn211')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn211" onclick="toggleCodeBlock('cloneGroup211', 'expandBtn211', 'collapseBtn211')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup211"><code class="language-javascript text-sm text-gray-800">) {
                if (typeof result === 'object' &amp;&amp; result !== null &amp;&amp; 'url' in result) {
                    const resultUrl = result.url;
                    if (resultUrl != undefined &amp;&amp;
                        typeof resultUrl === 'string' &amp;&amp;
                        (await this.isFoodTruckUrl(resultUrl))) {
                        discoveredUrls.add(resultUrl);
                    }
                }
            }
        }
    }
    // Helper method to store discovered URLs from discovery process</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/lib/lib/discoveryEngine.js (Line 501:2 - Line 507:8), C:/AI/food-truck-finder-poc/dist/lib/lib/discoveryEngine.js (Line 245:15 - Line 251:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn212" onclick="toggleCodeBlock('cloneGroup212', 'expandBtn212', 'collapseBtn212')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn212" onclick="toggleCodeBlock('cloneGroup212', 'expandBtn212', 'collapseBtn212')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup212"><code class="language-javascript text-sm text-gray-800">);
        }
        catch (error) {
            console.error(` Location search failed for ${city}:`, error);
            results.errors.push(`Location search failed for ${city}: ${error instanceof Error ? error.message : 'Unknown error'}`);
        }
        console</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/lib/lib/discoveryEngine.js (Line 602:6 - Line 617:6), C:/AI/food-truck-finder-poc/dist/lib/lib/discoveryEngine.js (Line 298:2 - Line 325:7)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn213" onclick="toggleCodeBlock('cloneGroup213', 'expandBtn213', 'collapseBtn213')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn213" onclick="toggleCodeBlock('cloneGroup213', 'expandBtn213', 'collapseBtn213')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup213"><code class="language-javascript text-sm text-gray-800">,
                });
                if (stored.isNew === true) {
                    results.urls_stored += 1;
                }
                else {
                    results.urls_duplicates += 1;
                }
            }
            catch (error) {
                console.error(` Failed to store URL ${url}:`, error);
                results.errors.push(`Failed to store URL ${url}: ${error instanceof Error ? error.message : 'Unknown error'}`);
            }
        }
    }
    delay</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/lib/gemini/usageLimits.js (Line 2:30 - Line 73:2), C:/AI/food-truck-finder-poc/dist/lib/lib/gemini/usageLimits.js (Line 2:27 - Line 73:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn218" onclick="toggleCodeBlock('cloneGroup218', 'expandBtn218', 'collapseBtn218')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn218" onclick="toggleCodeBlock('cloneGroup218', 'expandBtn218', 'collapseBtn218')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup218"><code class="language-javascript text-sm text-gray-800">;
export class GeminiUsageLimits {
    static DEFAULT_LIMITS = {
        dailyRequestLimit: 1500,
        dailyTokenLimit: 32_000,
    };
    /**
     * Checks the current usage against predefined limits and determines if further requests can be made.
     * @example
     * checkUsageLimits()
     * { canMakeRequest: true, usage: { requests: { used: 50, limit: 1000, remaining: 950 }, tokens: { used: 200, limit: 5000, remaining: 4800 } } }
     * @param {UsageLimits} limits - Object containing usage limits for requests and tokens.
     * @returns {Promise&lt;UsageCheck&gt;} Object indicating if a request can be made and the current usage statistics.
     * @description
     *   - Attempts to fetch today's usage data from the APIUsageService for 'gemini'.
     *   - If the fetch fails, defaults to allowing the request with a warning.
     *   - Maintains a buffer of 100 tokens to ensure requests are not made when limits are too close.
     */
    static async checkUsageLimits(limits = this.DEFAULT_LIMITS) {
        try {
            const usage = await APIUsageService.getTodayUsage('gemini');
            if (!usage) {
                return { canMakeRequest: true };
            }
            const requestsUsed = usage.requests_count ?? 0;
            const tokensUsed = usage.tokens_used ?? 0;
            const requestsRemaining = limits.dailyRequestLimit - requestsUsed;
            const tokensRemaining = limits.dailyTokenLimit - tokensUsed;
            return {
                canMakeRequest: requestsRemaining &gt; 0 &amp;&amp; tokensRemaining &gt; 100, // Keep 100 token buffer
                usage: {
                    requests: {
                        used: requestsUsed,
                        limit: limits.dailyRequestLimit,
                        remaining: requestsRemaining,
                    },
                    tokens: {
                        used: tokensUsed,
                        limit: limits.dailyTokenLimit,
                        remaining: tokensRemaining,
                    },
                },
            };
        }
        catch (error) {
            console.warn('Error checking Gemini usage limits:', error);
            return { canMakeRequest: false };
        }
    }
    /**
    * Checks if a request can be made with monitoring and returns whether the operation is allowed.
    * @example
    * checkWithMonitoring(100, DEFAULT_LIMITS)
    * { allowed: true }
    * @param {number} estimatedTokens - Number of estimated tokens for the request.
    * @param {UsageLimits} _limits - Usage limits configuration for requests (default provided internally).
    * @returns {Promise&lt;{ allowed: boolean; reason?: string; waitTime?: number }&gt;} Object indicating if the request is allowed and why not if denied.
    * @description
    *   - Uses an internal API monitor to check if requests can be made based on predefined limits.
    *   - Wait time is converted from milliseconds to minutes before being returned.
    */
    static async checkWithMonitoring(estimatedTokens, _limits = this.DEFAULT_LIMITS) {
        const canMakeRequest = await APIMonitor.canMakeRequest('gemini', 1, estimatedTokens);
        if (!canMakeRequest.allowed) {
            return {
                allowed: false,
                reason: `API limit reached: ${canMakeRequest.reason}. Wait time: ${Math.ceil((canMakeRequest.waitTime ?? 0) / 1000 / 60)} minutes`,
            };
        }
        return { allowed: true };
    }
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/lib/gemini/responseParser.js (Line 1:1 - Line 36:2), C:/AI/food-truck-finder-poc/dist/lib/lib/gemini/responseParser.js (Line 1:1 - Line 36:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn220" onclick="toggleCodeBlock('cloneGroup220', 'expandBtn220', 'collapseBtn220')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn220" onclick="toggleCodeBlock('cloneGroup220', 'expandBtn220', 'collapseBtn220')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup220"><code class="language-javascript text-sm text-gray-800">export const GeminiResponseParser = {
    parseJson(text) {
        // Clean up the response text
        const cleanedText = text
            .replaceAll(/```json\s*/g, '')
            .replaceAll(/```\s*/g, '')
            .replaceAll(/^\s*json\s*/g, '')
            .trim();
        return JSON.parse(cleanedText);
    },
    parseMenuData(text) {
        return this.parseJson(text);
    },
    parseLocationData(text) {
        return this.parseJson(text);
    },
    parseOperatingHours(text) {
        return this.parseJson(text);
    },
    parseSentimentAnalysis(text) {
        return this.parseJson(text);
    },
    parseEnhancedFoodTruckData(text) {
        return this.parseJson(text);
    },
    parseExtractedFoodTruckDetails(text) {
        return this.parseJson(text);
    },
    cleanMarkdownResponse(text) {
        return text
            .replaceAll(/```json\s*/g, '')
            .replaceAll(/```\s*/g, '')
            .replaceAll(/^\s*json\s*/g, '')
            .trim();
    },
};</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/lib/gemini/promptTemplates.js (Line 1:1 - Line 223:2), C:/AI/food-truck-finder-poc/dist/lib/lib/gemini/promptTemplates.js (Line 1:1 - Line 223:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn222" onclick="toggleCodeBlock('cloneGroup222', 'expandBtn222', 'collapseBtn222')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn222" onclick="toggleCodeBlock('cloneGroup222', 'expandBtn222', 'collapseBtn222')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup222"><code class="language-javascript text-sm text-gray-800">export const PromptTemplates = {
    menuProcessing: (rawMenuText) =&gt; `
Parse the following food truck menu text and return a structured JSON format.
Extract menu items with categories, names, descriptions, prices, and dietary tags.

Menu text:
${rawMenuText}

Expected JSON format:
[
  {
    &quot;category&quot;: &quot;string&quot;,
    &quot;items&quot;: [
      {
        &quot;name&quot;: &quot;string&quot;,
        &quot;description&quot;: &quot;string&quot;,
        &quot;price&quot;: number,
        &quot;dietary_tags&quot;: [&quot;string&quot;]
      }
    ]
  }
]

Rules:
- Extract actual prices as numbers (e.g., 12.99, not &quot;$12.99&quot;)
- Include dietary restrictions and special tags
- Group items into logical categories
- If no clear categories, use &quot;Main Items&quot;
- Return only the json, no additional text
  `,
    locationExtraction: (textInput) =&gt; `
Extract location information from the following text and return structured data.
Look for addresses, cross streets, landmarks, or location descriptions.

Text:
${textInput}

Expected JSON format:
{
  &quot;address&quot;: &quot;string or undefined&quot;,
  &quot;city&quot;: &quot;string or undefined&quot;, 
  &quot;state&quot;: &quot;string or undefined&quot;,
  &quot;zipCode&quot;: &quot;string or undefined&quot;,
  &quot;coordinates&quot;: {&quot;lat&quot;: number, &quot;lng&quot;: number} or undefined,
  &quot;confidence&quot;: number,
  &quot;landmarks&quot;: [&quot;string&quot;]
}

Rules:
- Set coordinates to undefined if not explicitly provided
- Confidence should be 0.0 to 1.0 based on clarity
- Include any mentioned landmarks or cross streets
- Return only the json, no additional text
  `,
    operatingHours: (hoursText) =&gt; `
Parse the following operating hours text and return standardized format.
Convert all times to 24-hour format and handle various input formats.

Hours text:
${hoursText}

Expected JSON format:
{
  &quot;monday&quot;: {&quot;open&quot;: &quot;HH:MM&quot;, &quot;close&quot;: &quot;HH:MM&quot;, &quot;closed&quot;: false},
  &quot;tuesday&quot;: {&quot;open&quot;: &quot;HH:MM&quot;, &quot;close&quot;: &quot;HH:MM&quot;, &quot;closed&quot;: false},
  &quot;wednesday&quot;: {&quot;open&quot;: &quot;HH:MM&quot;, &quot;close&quot;: &quot;HH:MM&quot;, &quot;closed&quot;: false},
  &quot;thursday&quot;: {&quot;open&quot;: &quot;HH:MM&quot;, &quot;close&quot;: &quot;HH:MM&quot;, &quot;closed&quot;: false},
  &quot;friday&quot;: {&quot;open&quot;: &quot;HH:MM&quot;, &quot;close&quot;: &quot;HH:MM&quot;, &quot;closed&quot;: false},
  &quot;saturday&quot;: {&quot;open&quot;: &quot;HH:MM&quot;, &quot;close&quot;: &quot;HH:MM&quot;, &quot;closed&quot;: false},
  &quot;sunday&quot;: {&quot;open&quot;: &quot;HH:MM&quot;, &quot;close&quot;: &quot;HH:MM&quot;, &quot;closed&quot;: false}
}

Rules:
- Use 24-hour format (e.g., &quot;14:30&quot; for 2:30 pm)
- If closed on a day, set &quot;closed&quot;: true and omit open/close times
- Handle ranges like &quot;Mon-Fri&quot; by applying to all days in range
- Default to reasonable hours if ambiguous
- Return only the json, no additional text
  `,
    sentimentAnalysis: (reviewText) =&gt; `
Analyze the sentiment of this food truck review and extract key insights.
Focus on food quality, service, value, and overall experience.

Review text:
${reviewText}

Expected JSON format:
{
  &quot;score&quot;: number,
  &quot;confidence&quot;: number,
  &quot;aspects&quot;: {
    &quot;food_quality&quot;: number,
    &quot;service&quot;: number,
    &quot;value&quot;: number,
    &quot;overall&quot;: number
  },
  &quot;summary&quot;: &quot;string&quot;,
  &quot;keywords&quot;: [&quot;string&quot;]
}

Rules:
- Score should be 0.0 (very negative) to 1.0 (very positive)
- Confidence should be 0.0 to 1.0 based on clarity of sentiment
- Include specific aspects mentioned in the review
- Summary should be 1-2 sentences max
- Return only the json, no additional text
  `,
    dataEnhancement: (rawData) =&gt; `
Enhance and standardize the following food truck data.
Fill in missing information where possible and improve data quality.

Raw data:
${JSON.stringify(rawData, undefined, 2)}

Expected JSON format:
{
  &quot;name&quot;: &quot;string&quot;,
  &quot;description&quot;: &quot;string&quot;,
  &quot;cuisine_type&quot;: &quot;string&quot;,
  &quot;price_range&quot;: &quot;$ | $$ | $$$ | $$$$&quot;,
  &quot;contact&quot;: {
    &quot;phone&quot;: &quot;string&quot;,
    &quot;email&quot;: &quot;string&quot;,
    &quot;website&quot;: &quot;string&quot;,
    &quot;social_media&quot;: {}
  },
  &quot;location&quot;: {
    &quot;address&quot;: &quot;string&quot;,
    &quot;city&quot;: &quot;string&quot;,
    &quot;state&quot;: &quot;string&quot;,
    &quot;coordinates&quot;: {&quot;lat&quot;: number, &quot;lng&quot;: number}
  },
  &quot;operating_hours&quot;: {},
  &quot;menu_categories&quot;: [&quot;string&quot;],
  &quot;specialties&quot;: [&quot;string&quot;],
  &quot;dietary_options&quot;: [&quot;string&quot;]
}

Rules:
- Preserve all original data while enhancing it
- Standardize naming conventions
- Infer cuisine type from menu items
- Estimate price range from menu prices
- Return only the json, no additional text
  `,
    foodTruckExtraction: (markdownContent, sourceUrl) =&gt; {
        const schema = `
Expected JSON schema:
{
  &quot;name&quot;: &quot;string (food truck name)&quot;,
  &quot;description&quot;: &quot;string (brief description of the food truck)&quot;,
  &quot;cuisine_type&quot;: &quot;string (type of cuisine served)&quot;,
  &quot;contact&quot;: {
    &quot;phone&quot;: &quot;string (phone number if found)&quot;,
    &quot;email&quot;: &quot;string (email if found)&quot;, 
    &quot;website&quot;: &quot;string (website URL if found)&quot;,
    &quot;social_media&quot;: {
      &quot;facebook&quot;: &quot;string (Facebook URL if found)&quot;,
      &quot;instagram&quot;: &quot;string (Instagram URL if found)&quot;,
      &quot;twitter&quot;: &quot;string (Twitter URL if found)&quot;
    }
  },
  &quot;location&quot;: {
    &quot;address&quot;: &quot;string (physical address if found)&quot;,
    &quot;city&quot;: &quot;string (city name)&quot;,
    &quot;state&quot;: &quot;string (state abbreviation)&quot;,
    &quot;coordinates&quot;: {
      &quot;lat&quot;: &quot;number (latitude if found)&quot;,
      &quot;lng&quot;: &quot;number (longitude if found)&quot;
    }
  },
  &quot;operating_hours&quot;: {
    &quot;monday&quot;: {&quot;open&quot;: &quot;string (HH:MM)&quot;, &quot;close&quot;: &quot;string (HH:MM)&quot;, &quot;closed&quot;: &quot;boolean&quot;},
    &quot;tuesday&quot;: {&quot;open&quot;: &quot;string (HH:MM)&quot;, &quot;close&quot;: &quot;string (HH:MM)&quot;, &quot;closed&quot;: &quot;boolean&quot;},
    &quot;wednesday&quot;: {&quot;open&quot;: &quot;string (HH:MM)&quot;, &quot;close&quot;: &quot;string (HH:MM)&quot;, &quot;closed&quot;: &quot;boolean&quot;},
    &quot;thursday&quot;: {&quot;open&quot;: &quot;string (HH:MM)&quot;, &quot;close&quot;: &quot;string (HH:MM)&quot;, &quot;closed&quot;: &quot;boolean&quot;},
    &quot;friday&quot;: {&quot;open&quot;: &quot;string (HH:MM)&quot;, &quot;close&quot;: &quot;string (HH:MM)&quot;, &quot;closed&quot;: &quot;boolean&quot;},
    &quot;saturday&quot;: {&quot;open&quot;: &quot;string (HH:MM)&quot;, &quot;close&quot;: &quot;string (HH:MM)&quot;, &quot;closed&quot;: &quot;boolean&quot;},
    &quot;sunday&quot;: {&quot;open&quot;: &quot;string (HH:MM)&quot;, &quot;close&quot;: &quot;string (HH:MM)&quot;, &quot;closed&quot;: &quot;boolean&quot;}
  },
  &quot;menu&quot;: [
    {
      &quot;category&quot;: &quot;string (menu category)&quot;,
      &quot;items&quot;: [
        {
          &quot;name&quot;: &quot;string (item name)&quot;,
          &quot;description&quot;: &quot;string (item description)&quot;,
          &quot;price&quot;: &quot;number (price as number, not string)&quot;,
          &quot;dietary_tags&quot;: [&quot;string (dietary restrictions/tags)&quot;]
        }
      ]
    }
  ],
  &quot;specialties&quot;: [&quot;string (signature dishes or specialties)&quot;],
  &quot;dietary_options&quot;: [&quot;string (dietary accommodations like vegan, gluten-free)&quot;],
  &quot;price_range&quot;: &quot;string ($ for under $10, $$ for $10-20, $$$ for $20-30, $$$$ for over $30)&quot;
}
`;
        const instructions = `
Instructions:
- Extract as much information as possible from the provided content
- If information is not available, use null for the field
- For operating hours, use 24-hour format (e.g., &quot;14:30&quot; for 2:30 PM)
- If a day is closed, set &quot;closed&quot;: true and omit open/close times
- For prices, extract numeric values only (e.g., 12.99, not &quot;$12.99&quot;)
- Be thorough in extracting menu items and their details
- Look for social media links and contact information carefully
- Return only the JSON object, no additional text or formatting
`;
        return `
You are an ai assistant tasked with extracting structured information about food trucks from their website content (provided in Markdown format). Your goal is to populate a json object with the following schema. Only return the json object, nothing else.

Website content:
${markdownContent}

${sourceUrl ? `Source URL: ${sourceUrl}` : ''}

${schema}

${instructions}
`;
    },
};</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/lib/gemini/geminiApiClient.js (Line 2:17 - Line 104:2), C:/AI/food-truck-finder-poc/dist/lib/lib/gemini/geminiApiClient.js (Line 2:24 - Line 104:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn224" onclick="toggleCodeBlock('cloneGroup224', 'expandBtn224', 'collapseBtn224')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn224" onclick="toggleCodeBlock('cloneGroup224', 'expandBtn224', 'collapseBtn224')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup224"><code class="language-javascript text-sm text-gray-800">;
export class GeminiApiClient {
    genAI;
    modelName;
    constructor() {
        const apiKey = process.env.GEMINI_API_KEY;
        if (apiKey == undefined || apiKey === '') {
            throw new Error('GEMINI_API_KEY environment variable is not set or is empty.');
        }
        this.genAI = new GoogleGenAI({ apiKey });
        this.modelName = 'gemini-2.0-flash-lite-001';
    }
    /**
    * Makes an API request to generate content based on the provided prompt and configuration.
    * @example
    * makeRequest('Create a poem about nature', { temperature: 0.7 })
    * Returns a promise that resolves to a GeminiResponse containing the generated text and token usage.
    * @param {string} prompt - The input prompt for content generation.
    * @param {GeminiApiConfig} config - Configuration settings for the API request, such as temperature. Defaults to an empty object.
    * @returns {Promise&lt;GeminiResponse&lt;T&gt;&gt;} A promise that resolves to a GeminiResponse with the generated content or an error message.
    * @description
    *   - The function calculates the number of tokens used for tracking purposes, even in case of an error.
    *   - The `temperature` parameter affects the randomness of the content generation, with higher values resulting in more creative outputs.
    *   - API usage is tracked asynchronously, and warnings are logged if tracking fails.
    *   - Returns an object indicating success status, the generated content or error message, and the number of tokens used.
    */
    async makeRequest(prompt, config = {}) {
        let textOutput = '';
        try {
            const sdkResponse = await this.genAI.models.generateContent({
                model: this.modelName,
                contents: [{ role: 'user', parts: [{ text: prompt }] }],
                config: { temperature: config.temperature ?? 0 },
            });
            textOutput = sdkResponse.text ?? '';
            const tokensUsed = sdkResponse.usageMetadata?.totalTokenCount ??
                Math.ceil((prompt.length + textOutput.length) / 4);
            // Track usage asynchronously
            APIUsageService.trackUsage('gemini', 1, tokensUsed).catch((error) =&gt; {
                console.warn('Failed to track API usage:', error);
            });
            return {
                success: true,
                data: textOutput,
                tokensUsed,
            };
        }
        catch (error) {
            const tokensUsed = Math.ceil((prompt.length + (error instanceof Error ? error.message.length : String(error).length)) /
                4);
            return {
                success: false,
                error: error instanceof Error ? error.message : 'Unknown error',
                tokensUsed,
            };
        }
    }
    /**
     * Executes a request using a specified prompt and attempts to parse the response using the provided parser function.
     * @example
     * makeRequestWithParsing(&quot;example prompt&quot;, (text) =&gt; JSON.parse(text))
     * { success: true, data: { key: &quot;value&quot; }, tokensUsed: 100 }
     * @param {string} prompt - The prompt used to make the API request.
     * @param {function} parser - A function to parse the response text into the desired format.
     * @param {GeminiApiConfig} config - Optional configuration settings for the Gemini API request.
     * @returns {Promise&lt;GeminiResponse&lt;T&gt;&gt;} A promise resolving to a GeminiResponse object containing either the parsed data or an error description.
     * @description
     *   - The function makes an asynchronous request using a specific prompt string and configuration.
     *   - If the response is unsuccessful, it returns the original response cast to the expected return type.
     *   - Parses the successful response data using the provided parser function.
     *   - Handles parsing errors gracefully, returning a detailed error message and logs the raw problematic response.
     */
    async makeRequestWithParsing(prompt, parser, config = {}) {
        const response = await this.makeRequest(prompt, config);
        if (!response.success) {
            return response;
        }
        try {
            if (!response.data) {
                return {
                    success: false,
                    error: 'No data received from Gemini API',
                    tokensUsed: response.tokensUsed,
                };
            }
            const parsedData = parser(response.data);
            return {
                success: true,
                data: parsedData,
                tokensUsed: response.tokensUsed,
            };
        }
        catch (parseError) {
            console.warn('Gemini json parsing error:', parseError);
            console.warn('Problematic Gemini raw response text:', response.data?.trim() ?? 'No data');
            return {
                success: false,
                error: `Failed to parse Gemini response: ${parseError instanceof Error ? parseError.message : String(parseError)}. Response text: ${response.data?.trim().slice(0, 200) ?? 'No data'}...`,
                tokensUsed: response.tokensUsed,
            };
        }
    }
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/lib/data-quality/placeholderUtils.js (Line 1:1 - Line 141:2), C:/AI/food-truck-finder-poc/dist/lib/lib/data-quality/placeholderUtils.js (Line 1:1 - Line 141:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn232" onclick="toggleCodeBlock('cloneGroup232', 'expandBtn232', 'collapseBtn232')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn232" onclick="toggleCodeBlock('cloneGroup232', 'expandBtn232', 'collapseBtn232')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup232"><code class="language-javascript text-sm text-gray-800">/**
* Returns an array of regular expressions that identify placeholder patterns.
* @example
* getPlaceholderPatterns()
* [ /undefined/i, /placeholder/i, /example\.com/i, /test\s*truck/i, /lorem\s*ipsum/i, /\bna\b/i, /\bn\/a\b/i, /^0+$/, /^null$/i ]
* @returns {RegExp[]} An array of regular expressions to match various placeholder values.
* @description
*   - Regular expressions cover common placeholder values used in data.
*   - Patterns are designed to be case insensitive to support a wider range of inputs.
*   - Contains specific patterns like 'example.com' to catch domain placeholders.
*   - Includes matches for numeric placeholders like '000...' and 'null'.
*/
export function getPlaceholderPatterns() {
    return [
        /undefined/i,
        /placeholder/i,
        /example\.com/i,
        /test\s*truck/i,
        /lorem\s*ipsum/i,
        /\bna\b/i,
        /\bn\/a\b/i,
        /^0+$/,
        /^null$/i,
    ];
}
/**
* Checks the food truck's properties for placeholder patterns and sets them to undefined if a pattern is found.
* @example
* checkForPlaceholders(foodTruckObj, [/\b(?:N\/A|TBD|Unknown)\b/, /^{.+}$/])
* {name: undefined, description: undefined}
* @param {FoodTruck} truck - The food truck object which may contain placeholder text in its properties.
* @param {RegExp[]} patterns - Array of regex patterns used to test against food truck properties.
* @returns {Partial&lt;FoodTruck&gt;} A partial food truck object with properties set to undefined if placeholders are detected.
* @description
*   - The function does not modify the original truck object; it returns a new one.
*   - Handles undefined properties seamlessly to prevent errors during regex testing.
*   - Assumes that the RegExp provided will effectively identify placeholder patterns.
*/
export function checkForPlaceholders(truck, patterns) {
    const updates = {};
    if (truck.name &amp;&amp; patterns.some((pattern) =&gt; pattern.test(truck.name ?? ''))) {
        updates.name = undefined;
    }
    if (truck.description != undefined &amp;&amp;
        patterns.some((pattern) =&gt; pattern.test(truck.description ?? ''))) {
        updates.description = undefined;
    }
    if (truck.price_range != undefined &amp;&amp;
        patterns.some((pattern) =&gt; pattern.test(truck.price_range ?? ''))) {
        updates.price_range = undefined;
    }
    return updates;
}
/**
* Processes a FoodTruck object for placeholders and returns updates.
* @example
* processTruckForPlaceholders(truck, [/pattern1/g, /pattern2/g])
* { name: 'Updated Truck Name', address: 'Updated Address' }
* @param {FoodTruck} truck - The FoodTruck object to be processed for placeholders.
* @param {Array&lt;RegExp&gt;} patterns - Array of regular expressions to identify placeholders.
* @returns {Partial&lt;FoodTruck&gt;} An object containing the updated fields of the FoodTruck.
* @description
*   - Performs checks for placeholders in basic information of the truck.
*   - Processes contact information of the FoodTruck for placeholders.
*   - Assesses and updates address details for placeholders.
*   - Combines updates from basic, contact, and address information into a single object.
*/
export function processTruckForPlaceholders(truck, patterns) {
    const basicInfoUpdates = checkForPlaceholders(truck, patterns);
    const contactInfoUpdates = processContactInfoForPlaceholders(truck, patterns);
    const addressUpdates = processAddressForPlaceholders(truck, patterns);
    const updates = {
        ...basicInfoUpdates,
        ...getContactInfoUpdates(truck, contactInfoUpdates),
        ...getLocationUpdates(truck, addressUpdates),
    };
    return updates;
}
function getContactInfoUpdates(truck, contactInfoUpdates) {
    if (Object.keys(contactInfoUpdates).length &gt; 0) {
        return { contact_info: { ...truck.contact_info, ...contactInfoUpdates } };
    }
    return {};
}
function getLocationUpdates(truck, addressUpdates) {
    if (Object.keys(addressUpdates).length &gt; 0) {
        return { current_location: { ...truck.current_location, ...addressUpdates } };
    }
    return {};
}
/**
* Filters contact information of a food truck based on specified patterns.
* @example
* processContactInfoForPlaceholders(truck, patterns)
* returns filtered contact info with some fields possibly undefined
* @param {FoodTruck} truck - The food truck object containing contact information.
* @param {RegExp[]} patterns - Array of regular expressions to match against contact info.
* @returns {Partial&lt;FoodTruck['contact_info']&gt;} Returns contact information with fields set to undefined if they match any pattern.
* @description
*   - Checks phone, website, and email properties for matches with given patterns.
*   - Sets properties to undefined if they match any pattern.
*/
function processContactInfoForPlaceholders(truck, patterns) {
    const cleanContact = {};
    if (truck.contact_info?.phone !== undefined &amp;&amp;
        patterns.some((pattern) =&gt; pattern.test(truck.contact_info.phone ?? ''))) {
        cleanContact.phone = undefined;
    }
    if (truck.contact_info?.website !== undefined &amp;&amp;
        patterns.some((pattern) =&gt; pattern.test(truck.contact_info.website ?? ''))) {
        cleanContact.website = undefined;
    }
    if (truck.contact_info?.email !== undefined &amp;&amp;
        patterns.some((pattern) =&gt; pattern.test(truck.contact_info.email ?? ''))) {
        cleanContact.email = undefined;
    }
    return cleanContact;
}
/**
 * Processes the current location of a food truck by checking against patterns and updating placeholders.
 * @example
 * const truck = { current_location: { address: '123 Fake St' } };
 * const patterns = [/Fake/];
 * processAddressForPlaceholders(truck, patterns);
 * // Returns: { address: undefined }
 * @param {FoodTruck} truck - The food truck object containing the current location data.
 * @param {RegExp[]} patterns - An array of regular expression patterns used to identify placeholders in the address.
 * @returns {Partial&lt;FoodTruck['current_location']&gt;} An object containing the updated location data with address potentially set to undefined.
 * @description
 *   - The function checks whether the address of the food truck's current location matches any of the provided RegExp patterns.
 *   - If a match is found, the address in the returned object is set to undefined.
 *   - It ensures details of the truck's location can be sanitized by placeholder detection.
 */
function processAddressForPlaceholders(truck, patterns) {
    const updatedLocation = {};
    if (truck.current_location?.address !== undefined &amp;&amp;
        patterns.some((pattern) =&gt; pattern.test(truck.current_location.address ?? ''))) {
        updatedLocation.address = undefined;
    }
    return updatedLocation;
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/lib/data-quality/duplicatePrevention.js (Line 5:17 - Line 47:8), C:/AI/food-truck-finder-poc/dist/lib/lib/data-quality/duplicatePrevention.js (Line 5:27 - Line 47:6)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn234" onclick="toggleCodeBlock('cloneGroup234', 'expandBtn234', 'collapseBtn234')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn234" onclick="toggleCodeBlock('cloneGroup234', 'expandBtn234', 'collapseBtn234')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup234"><code class="language-javascript text-sm text-gray-800">;
// Duplicate detection configuration
export const DUPLICATE_DETECTION_CONFIG = {
    // Similarity thresholds (0.0 = no match, 1.0 = exact match)
    thresholds: {
        name: 0.85, // High threshold for name matching
        location: 0.9, // Very high threshold for location matching
        phone: 1, // Exact match for phone numbers
        website: 1, // Exact match for websites
        overall: 0.8, // Overall similarity threshold
    },
    // Weight factors for different fields
    weights: {
        name: 0.4, // 40% weight for name similarity
        location: 0.3, // 30% weight for location similarity
        contact: 0.2, // 20% weight for contact info similarity
        menu: 0.1, // 10% weight for menu similarity
    },
};
/**
 * Advanced Duplicate Prevention Service
 */
export class DuplicatePreventionService {
    /**
     * Check if a food truck is a duplicate of existing trucks
     */
    static async checkForDuplicates(candidateTruck) {
        try {
            // Get all existing trucks for comparison
            const existingTrucksResult = await FoodTruckService.getAllTrucks();
            if ('error' in existingTrucksResult) {
                console.error('Error fetching existing trucks:', existingTrucksResult.error);
                return {
                    isDuplicate: false,
                    matches: [],
                    action: 'create',
                    reason: `Error fetching existing trucks: ${existingTrucksResult.error}`,
                };
            }
            const existingTrucks = existingTrucksResult.trucks;
            const matches = [];
            for (const existingTruck of existingTrucks) {
                console</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/lib/data-quality/duplicatePrevention.js (Line 48:17 - Line 127:8), C:/AI/food-truck-finder-poc/dist/lib/lib/data-quality/duplicatePrevention.js (Line 47:17 - Line 125:8)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn235" onclick="toggleCodeBlock('cloneGroup235', 'expandBtn235', 'collapseBtn235')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn235" onclick="toggleCodeBlock('cloneGroup235', 'expandBtn235', 'collapseBtn235')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup235"><code class="language-javascript text-sm text-gray-800">const similarity = this.calculateSimilarity(candidateTruck, existingTruck);
                if (similarity.overall &gt;= DUPLICATE_DETECTION_CONFIG.thresholds.overall) {
                    matches.push({
                        existingTruck,
                        similarity: similarity.overall,
                        matchedFields: similarity.matchedFields,
                        confidence: this.getConfidenceLevel(similarity.overall),
                        recommendation: this.getRecommendation(similarity),
                    });
                }
            }
            return this.processDuplicateMatches(matches, candidateTruck);
        }
        catch (error) {
            console.error('Error checking for duplicates:', error);
            return {
                isDuplicate: false,
                matches: [],
                action: 'create',
                reason: 'An unexpected error occurred during duplicate detection - proceeding with creation',
            };
        }
    }
    /**
     * Processes the matches found during duplicate detection and returns the result.
     */
    static processDuplicateMatches(matches, candidateTruck) {
        // Sort matches by similarity (highest first)
        matches.sort((a, b) =&gt; b.similarity - a.similarity);
        const bestMatch = matches.length &gt; 0 ? matches[0] : undefined;
        const isDuplicate = matches.length &gt; 0;
        return {
            isDuplicate,
            matches,
            bestMatch,
            action: this.determineAction(matches, candidateTruck),
            reason: this.generateReason(matches, candidateTruck),
        };
    }
    /**
     * Calculate similarity between two food trucks
     */
    static calculateSimilarity(candidate, existing) {
        const breakdown = {};
        const matchedFields = [];
        // Name similarity
        const nameSimilarity = this.calculateStringSimilarity(candidate.name ?? '', existing.name ?? '');
        breakdown.name = nameSimilarity;
        if (nameSimilarity &gt;= DUPLICATE_DETECTION_CONFIG.thresholds.name) {
            matchedFields.push('name');
        }
        // Location similarity
        const locationSimilarity = this.calculateLocationSimilarity(candidate.current_location, existing.current_location);
        breakdown.location = locationSimilarity;
        if (locationSimilarity &gt;= DUPLICATE_DETECTION_CONFIG.thresholds.location) {
            matchedFields.push('location');
        }
        // Contact similarity
        const contactSimilarity = this.calculateContactSimilarity(candidate.contact_info, existing.contact_info);
        breakdown.contact = contactSimilarity;
        if (contactSimilarity &gt;= DUPLICATE_DETECTION_CONFIG.thresholds.phone) {
            matchedFields.push('contact');
        }
        // Menu similarity (basic)
        const menuSimilarity = this.calculateMenuSimilarity(candidate.menu, existing.menu);
        breakdown.menu = menuSimilarity;
        if (menuSimilarity &gt; 0.7) {
            matchedFields.push('menu');
        }
        // Calculate weighted overall similarity
        const overall = nameSimilarity * DUPLICATE_DETECTION_CONFIG.weights.name +
            locationSimilarity * DUPLICATE_DETECTION_CONFIG.weights.location +
            contactSimilarity * DUPLICATE_DETECTION_CONFIG.weights.contact +
            menuSimilarity * DUPLICATE_DETECTION_CONFIG.weights.menu;
        return { overall, matchedFields, breakdown };
    }
    /**
     * Normalize food truck names for better comparison
     * Removes common suffixes, normalizes case, handles punctuation variations
     */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/lib/data-quality/duplicatePrevention.js (Line 165:12 - Line 175:12), C:/AI/food-truck-finder-poc/dist/lib/lib/data-quality/duplicatePrevention.js (Line 137:3 - Line 147:3)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn236" onclick="toggleCodeBlock('cloneGroup236', 'expandBtn236', 'collapseBtn236')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn236" onclick="toggleCodeBlock('cloneGroup236', 'expandBtn236', 'collapseBtn236')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup236"><code class="language-javascript text-sm text-gray-800">.length;
        for (let i = 0; i &lt;= len1; i += 1) {
            matrix[i] = [i];
        }
        for (let j = 0; j &lt;= len2; j += 1) {
            matrix[0][j] = j;
        }
        for (let i = 1; i &lt;= len1; i += 1) {
            // eslint-disable-next-line sonarjs/no-redundant-assignments
            for (let j = 1; j &lt;= len2; j += 1) {
                const cost = normalized1</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/lib/data-quality/duplicatePrevention.js (Line 175:12 - Line 375:2), C:/AI/food-truck-finder-poc/dist/lib/lib/data-quality/duplicatePrevention.js (Line 147:3 - Line 347:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn237" onclick="toggleCodeBlock('cloneGroup237', 'expandBtn237', 'collapseBtn237')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn237" onclick="toggleCodeBlock('cloneGroup237', 'expandBtn237', 'collapseBtn237')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup237"><code class="language-javascript text-sm text-gray-800">[j - 1] ? 0 : 1;
                matrix[i][j] = Math.min(matrix[i - 1][j] + 1, // deletion
                matrix[i][j - 1] + 1, // insertion
                matrix[i - 1][j - 1] + cost);
            }
        }
        const distance = matrix[len1][len2];
        const maxLength = Math.max(len1, len2);
        return maxLength === 0 ? 1 : 1 - distance / maxLength;
    }
    /**
     * Calculate location similarity
     */
    static calculateLocationSimilarity(loc1, loc2) {
        if (!loc1 || !loc2)
            return 0;
        let similarity = 0;
        let factors = 0;
        // Address similarity
        if (loc1.address &amp;&amp; loc2.address) {
            similarity += this.calculateStringSimilarity(loc1.address, loc2.address);
            factors += 1;
        }
        // GPS coordinate similarity (within 100 meters = high similarity)
        if (loc1.lat &amp;&amp; loc1.lng &amp;&amp; loc2.lat &amp;&amp; loc2.lng) {
            const distance = this.calculateGPSDistance(loc1.lat, loc1.lng, loc2.lat, loc2.lng);
            // Distance similarity (closer = higher similarity)
            const distanceSimilarity = distance &lt;= 0.1 ? 1 : Math.max(0, 1 - distance / 1); // 1km max
            similarity += distanceSimilarity;
            factors += 1;
        }
        return factors &gt; 0 ? similarity / factors : 0;
    }
    /**
     * Calculate GPS distance in kilometers
     */
    static calculateGPSDistance(lat1, lng1, lat2, lng2) {
        const R = 6371; // Earth's radius in kilometers
        const dLat = ((lat2 - lat1) * Math.PI) / 180;
        const dLng = ((lng2 - lng1) * Math.PI) / 180;
        const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
            Math.cos((lat1 * Math.PI) / 180) *
                Math.cos((lat2 * Math.PI) / 180) *
                Math.sin(dLng / 2) *
                Math.sin(dLng / 2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        return R * c;
    }
    /**
     * Calculate contact similarity
     */
    static calculateContactSimilarity(contact1, contact2) {
        if (!contact1 || !contact2)
            return 0;
        let matches = 0;
        let total = 0;
        // Phone number exact match
        if (contact1.phone != undefined &amp;&amp; contact2.phone != undefined) {
            const phone1 = contact1.phone.replaceAll(/\D/g, ''); // Remove non-digits
            const phone2 = contact2.phone.replaceAll(/\D/g, '');
            if (phone1 === phone2)
                matches += 1;
            total += 1;
        }
        // Website exact match
        if (contact1.website != undefined &amp;&amp; contact2.website != undefined) {
            const url1 = contact1.website
                .toLowerCase()
                .replace(/^https?:\/\//, '')
                .replace(/\/$/, '');
            const url2 = contact2.website
                .toLowerCase()
                .replace(/^https?:\/\//, '')
                .replace(/\/$/, '');
            if (url1 === url2)
                matches += 1;
            total += 1;
        }
        // Email similarity
        if (contact1.email != undefined &amp;&amp; contact2.email != undefined) {
            if (contact1.email.toLowerCase() === contact2.email.toLowerCase())
                matches += 1;
            total += 1;
        }
        return total &gt; 0 ? matches / total : 0;
    }
    /**
     * Calculate menu similarity (basic implementation)
     */
    static calculateMenuSimilarity(menu1, menu2) {
        if (!menu1 || !menu2 || menu1.length === 0 || menu2.length === 0)
            return 0;
        // Simple category name matching
        const categories1 = menu1
            .map((cat) =&gt; cat.category?.toLowerCase() ?? '')
            .filter(Boolean);
        const categories2 = menu2
            .map((cat) =&gt; cat.category?.toLowerCase() ?? '')
            .filter(Boolean);
        const commonCategories = categories1.filter((cat) =&gt; categories2.includes(cat));
        const totalCategories = new Set([...categories1, ...categories2]).size;
        return totalCategories &gt; 0 ? commonCategories.length / totalCategories : 0;
    }
    /**
     * Get confidence level based on similarity score
     */
    static getConfidenceLevel(similarity) {
        if (similarity &gt;= 0.95)
            return 'high';
        if (similarity &gt;= 0.85)
            return 'medium';
        return 'low';
    }
    /**
     * Get recommendation based on similarity analysis
     */
    static getRecommendation(similarity) {
        if (similarity.overall &gt;= 0.95)
            return 'merge';
        if (similarity.overall &gt;= 0.9)
            return 'update';
        if (similarity.overall &gt;= 0.8)
            return 'manual_review';
        return 'skip';
    }
    /**
     * Determine action based on matches
     */
    static determineAction(matches, _candidate) {
        if (matches.length === 0)
            return 'create';
        const bestMatch = matches[0];
        if (bestMatch.confidence === 'high') {
            const { recommendation } = bestMatch;
            if (recommendation === 'merge' || recommendation === 'update') {
                return recommendation;
            }
            return 'manual_review';
        }
        return 'manual_review';
    }
    /**
     * Generate human-readable reason
     */
    static generateReason(matches, _candidate) {
        if (matches.length === 0) {
            return 'No duplicates found - safe to create new truck entry';
        }
        const bestMatch = matches[0];
        const similarity = Math.round(bestMatch.similarity * 100);
        return `Found ${matches.length} potential duplicate(s). Best match: ${similarity}% similarity with &quot;${bestMatch.existingTruck.name}&quot; (matched: ${bestMatch.matchedFields.join(', ')})`;
    }
    /**
     * Merge duplicate truck data intelligently
     */
    static async mergeDuplicates(targetId, sourceId) {
        const targetResult = await FoodTruckService.getTruckById(targetId);
        const sourceResult = await FoodTruckService.getTruckById(sourceId);
        if ('error' in targetResult) {
            return {
                error: `Failed to retrieve target truck with ID ${targetId}: ${targetResult.error}`,
            };
        }
        if ('error' in sourceResult) {
            return {
                error: `Failed to retrieve source truck with ID ${sourceId}: ${sourceResult.error}`,
            };
        }
        const target = targetResult;
        const source = sourceResult;
        // Merge logic: prefer non-null, more complete data
        const mergedData = {
            name: target.name ?? source.name,
            description: target.description ?? source.description,
            cuisine_type: (target.cuisine_type?.length ?? 0) &gt; 0 ? target.cuisine_type : source.cuisine_type,
            price_range: target.price_range ?? source.price_range,
            current_location: target.current_location ?? source.current_location,
            contact_info: {
                ...source.contact_info,
                ...target.contact_info, // Target takes precedence
            },
            operating_hours: target.operating_hours ?? source.operating_hours,
            menu: (target.menu?.length ?? 0) &gt; 0 ? target.menu : source.menu,
            social_media: {
                ...source.social_media,
                ...target.social_media,
            },
            source_urls: [...new Set([...(target.source_urls ?? []), ...(source.source_urls ?? [])])],
            last_scraped_at: new Date().toISOString(),
        };
        // Update target with merged data
        const updatedTruckResult = await FoodTruckService.updateTruck(targetId, mergedData);
        if ('error' in updatedTruckResult) {
            return {
                error: `Failed to update target truck with merged data: ${updatedTruckResult.error}`,
            };
        }
        console.info(`Merged truck ${sourceId} into ${targetId}`);
        return updatedTruckResult;
    }
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/lib/data-quality/batchCleanup.js (Line 7:24 - Line 505:2), C:/AI/food-truck-finder-poc/dist/lib/lib/data-quality/batchCleanup.js (Line 7:21 - Line 505:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn240" onclick="toggleCodeBlock('cloneGroup240', 'expandBtn240', 'collapseBtn240')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn240" onclick="toggleCodeBlock('cloneGroup240', 'expandBtn240', 'collapseBtn240')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup240"><code class="language-javascript text-sm text-gray-800">;
/**
 * Automated Data Quality Cleanup Service
 */
export class BatchCleanupService {
    /**
     * Run comprehensive data cleanup operations
     */
    static async runFullCleanup(options = {}) {
        const startTime = Date.now();
        const { batchSize = 50, dryRun = false, operations = [
            'remove_placeholders',
            'normalize_phone',
            'fix_coordinates',
            'update_quality_scores',
            'merge_duplicates',
        ], } = options;
        console.info(`Starting batch cleanup (${dryRun ? 'DRY RUN' : 'LIVE'})...`);
        const result = this.initializeCleanupResult();
        try {
            const allTrucks = await FoodTruckService.getAllTrucks();
            result.totalProcessed = allTrucks.total;
            await this.processTrucksInBatches(allTrucks.trucks, {
                batchSize,
                operations,
                dryRun,
                result,
            });
            return this.finalizeCleanupResult(result, startTime);
        }
        catch (error) {
            console.error('Batch cleanup failed:', error);
            throw error;
        }
    }
    /**
    * Initializes and returns a new BatchCleanupResult object with default values.
    * @example
    * initializeCleanupResult()
    * { totalProcessed: 0, operations: [], summary: { trucksImproved: 0, duplicatesRemoved: 0, qualityScoreImprovement: 0, placeholdersRemoved: 0 }, duration: 0 }
    * @returns {BatchCleanupResult} A new BatchCleanupResult object with all properties set to initial default values.
    */
    static initializeCleanupResult() {
        return {
            totalProcessed: 0,
            operations: [],
            summary: {
                trucksImproved: 0,
                duplicatesRemoved: 0,
                qualityScoreImprovement: 0,
                placeholdersRemoved: 0,
            },
            duration: 0,
        };
    }
    static finalizeCleanupResult(result, startTime) {
        result.summary = this.calculateSummary(result.operations);
        result.duration = Date.now() - startTime;
        console.info(`Batch cleanup completed in ${result.duration}ms`);
        return result;
    }
    /**
     * Processes food trucks in batches, executing specified operations on each batch.
     * @example
     * processTrucksInBatches(truckList, { batchSize: 10, operations: ['clean'], dryRun: true, result: batchResult })
     * // It executes 'clean' operation on batches of 10 trucks without making permanent changes.
     * @param {FoodTruck[]} trucks - Array of food trucks to be processed in batches.
     * @param {object} options - Options object containing batchSize, operations, dryRun, and result.
     * @param {number} options.batchSize - Number of trucks in each batch.
     * @param {CleanupOperation['type'][]} options.operations - Array of operation types to be executed on each batch.
     * @param {boolean} options.dryRun - If true, operations are executed in simulation mode without permanent changes.
     * @param {BatchCleanupResult} options.result - Stores the results of operations performed on batches.
     * @returns {Promise&lt;void&gt;} Completes processing batches without a return value.
     * @description
     *   - Uses async function to allow non-blocking execution of operations.
     *   - Collects and stores results of batch operations separately, keeping track of each operation's outcome.
     *   - Iterates over arrays using slicing to dynamically create batches for processing.
     */
    static async processTrucksInBatches(trucks, { batchSize, operations, dryRun, result, }) {
        for (let i = 0; i &lt; trucks.length; i += batchSize) {
            const batch = trucks.slice(i, i + batchSize);
            for (const op of operations) {
                const opResult = await this.runOperation(op, batch, dryRun);
                result.operations.push(opResult);
            }
        }
    }
    /**
     * Run a specific cleanup operation
     */
    static async runOperation(type, trucks, dryRun) {
        const operation = {
            type,
            description: this.getOperationDescription(type),
            affectedCount: 0,
            successCount: 0,
            errorCount: 0,
            errors: [],
        };
        const operationRunners = {
            remove_placeholders: this.runRemovePlaceholders,
            normalize_phone: this.runNormalizePhoneNumbers,
            fix_coordinates: this.runFixCoordinates,
            update_quality_scores: this.runUpdateQualityScores,
            merge_duplicates: this.runMergeDuplicates,
        };
        try {
            const runner = operationRunners[type];
            if (runner) {
                return await runner.call(this, trucks, dryRun, operation);
            }
            operation.errors.push(`Unknown operation type: ${String(type)}`);
            return operation;
        }
        catch (error) {
            operation.errors.push(`Operation failed: ${error instanceof Error ? error.message : String(error)}`);
            return operation;
        }
    }
    static runRemovePlaceholders = async (trucks, dryRun, operation) =&gt; {
        return await this.removePlaceholders(trucks, dryRun, operation);
    };
    static runNormalizePhoneNumbers = async (trucks, dryRun, operation) =&gt; {
        return await this.normalizePhoneNumbers(trucks, dryRun, operation);
    };
    static runFixCoordinates = async (trucks, dryRun, operation) =&gt; {
        return await this.fixCoordinates(trucks, dryRun, operation);
    };
    static runUpdateQualityScores = async (trucks, dryRun, operation) =&gt; {
        return await this.updateQualityScores(trucks, dryRun, operation);
    };
    static runMergeDuplicates = async (trucks, dryRun, operation) =&gt; {
        return await this.mergeDuplicates(trucks, dryRun, operation);
    };
    /**
     * Remove placeholder and mock data
     */
    static async removePlaceholders(trucks, dryRun, operation) {
        const placeholderPatterns = getPlaceholderPatterns();
        const promises = trucks.map((truck) =&gt; this.processSingleTruckForPlaceholders(truck, placeholderPatterns, dryRun, operation));
        await Promise.all(promises);
        return operation;
    }
    static async processSingleTruckForPlaceholders(truck, patterns, dryRun, operation) {
        const updates = processTruckForPlaceholders(truck, patterns);
        if (updates &amp;&amp; Object.keys(updates).length &gt; 0) {
            await this.performUpdateOperation(truck.id, updates, dryRun, operation);
        }
    }
    /**
     * Perform an update operation on a specified food truck.
     * @example
     * performUpdateOperation('truck123', { name: 'New Name' }, true, cleanupOperation)
     * // No direct return value; operation may log errors.
     * @param {string} truckId - The unique identifier of the food truck to be updated.
     * @param {Partial&lt;FoodTruck&gt;} updates - An object containing the fields to be updated.
     * @param {boolean} dryRun - Flag indicating whether the operation should be a simulation without actual changes.
     * @param {CleanupOperation} operation - An operation object that logs errors encountered during update.
     * @returns {Promise&lt;void&gt;} A promise that resolves when the update operation is complete.
     * @description
     *   - If 'dryRun' is true, no updates are applied but actions are logged.
     *   - Errors during update are caught and logged in the 'operation.errors' array.
     */
    static async performUpdateOperation(truckId, updates, dryRun, operation) {
        operation.affectedCount += 1;
        if (dryRun) {
            operation.successCount += 1;
        }
        else {
            try {
                await FoodTruckService.updateTruck(truckId, updates);
                operation.successCount += 1;
            }
            catch (error) {
                operation.errorCount += 1;
                operation.errors.push(`Failed to update truck ${truckId}: ${error instanceof Error ? error.message : String(error)}`);
            }
        }
    }
    /**
     * Normalize phone numbers to consistent format
     */
    static async normalizePhoneNumbers(trucks, dryRun, operation) {
        const promises = trucks.map((truck) =&gt; {
            if (truck.contact_info?.phone !== undefined) {
                const originalPhone = truck.contact_info.phone;
                const normalizedPhone = this.normalizePhone(originalPhone);
                if (normalizedPhone !== undefined &amp;&amp; normalizedPhone !== originalPhone) {
                    return this.applyPhoneNormalizationUpdate(truck, normalizedPhone, dryRun, operation);
                }
            }
            return Promise.resolve();
        });
        await Promise.all(promises);
        return operation;
    }
    /**
     * Apply phone normalization update to a food truck's contact information.
     * @example
     * applyPhoneNormalizationUpdate(truckInstance, '+1234567890', false, operationInstance)
     * // Normalizes and updates phone number of given truckInstance.
     * @param {FoodTruck} truck - The food truck object whose phone number needs normalization.
     * @param {string} normalizedPhone - The normalized phone number to update to the food truck's contact information.
     * @param {boolean} dryRun - Flag indicating whether the operation is a dry run; updates are skipped if true.
     * @param {CleanupOperation} operation - Object containing cleanup operation context including a record of errors.
     * @returns {Promise&lt;void&gt;} Does not return a value, but potentially modifies the truck and operation objects.
     * @description
     *   - Executes the update operation only if `dryRun` is false.
     *   - Pushes error messages to `operation.errors` on failure during the update process.
     *   - Uses `FoodTruckService.updateTruck` for updating the contact information.
     */
    static async applyPhoneNormalizationUpdate(truck, normalizedPhone, dryRun, operation) {
        operation.affectedCount += 1;
        if (dryRun) {
            operation.successCount += 1;
        }
        else {
            try {
                await FoodTruckService.updateTruck(truck.id, {
                    contact_info: {
                        ...truck.contact_info,
                        phone: normalizedPhone,
                    },
                });
                operation.successCount += 1;
            }
            catch (error) {
                operation.errorCount += 1;
                operation.errors.push(`Failed to normalize phone for truck ${truck.id}: ${error instanceof Error ? error.message : String(error)}`);
            }
        }
    }
    /**
     * Helper to determine if coordinates need fixing and provide updates
     */
    static getFixedCoordinates(lat, lng, defaultLat, defaultLng) {
        // Fix invalid coordinates (0,0 or undefined)
        if (lat === undefined || lng === undefined || lat === 0 || lng === 0) {
            return { lat: defaultLat, lng: defaultLng };
        }
        // Fix coordinates outside reasonable bounds for Charleston area
        if (lat &lt; 32 || lat &gt; 34 || lng &gt; -79 || lng &lt; -81) {
            return { lat: defaultLat, lng: defaultLng };
        }
        return undefined;
    }
    /**
     * Fix invalid GPS coordinates
     */
    static async fixCoordinates(trucks, dryRun, operation) {
        const context = {
            defaultLat: 32.7767,
            defaultLng: -79.9311,
            dryRun,
        };
        const promises = trucks.map((truck) =&gt; this.processSingleTruckCoordinates(truck, { ...context, operation }));
        await Promise.all(promises);
        return operation;
    }
    /**
     * Processes coordinates for a single food truck, applying any necessary fixes.
     * @example
     * processSingleTruckCoordinates(truck, context)
     * // No return value, function completes silently
     * @param {FoodTruck} truck - The food truck whose coordinates are to be processed.
     * @param {CoordinateProcessContext} context - Contains configuration and operation context for processing coordinates.
     * @returns {Promise&lt;void&gt;} Returns a promise that resolves when the processing and possible updates are complete.
     * @description
     *   - Skips processing if the truck's current location is not available.
     *   - Retrieves updates for fixed coordinates based on truck's current and default locations.
     *   - Applies updates conditionally based on context settings such as `dryRun` and `operation`.
     */
    static async processSingleTruckCoordinates(truck, context) {
        if (!truck.current_location)
            return;
        const { defaultLat, defaultLng, dryRun, operation } = context;
        const { lat, lng } = truck.current_location;
        const updates = this.getFixedCoordinates(lat, lng, defaultLat, defaultLng);
        if (updates) {
            await this.applyCoordinateFixUpdate(truck, updates, dryRun, operation);
        }
    }
    /**
     * Applies coordinate updates for a food truck's current location.
     * @example
     * applyCoordinateFixUpdate(truck, { lat: 34.05, lng: -118.25 }, false, operation)
     * // Updates the coordinates of the truck's location asynchronously.
     * @param {FoodTruck} truck - The food truck object whose coordinates need correction.
     * @param {Partial&lt;FoodTruck['current_location']&gt;} updates - The latitude and longitude updates to be applied.
     * @param {boolean} dryRun - Flag to simulate the update without altering data.
     * @param {CleanupOperation} operation - The cleanup operation instance used for error tracking.
     * @returns {Promise&lt;void&gt;} Resolves when the coordinate update process is complete.
     * @description
     *   - Executes the update operation only if the dryRun flag is false.
     *   - If the update fails, logs the error details into the operation's error array.
     */
    static async applyCoordinateFixUpdate(truck, updates, dryRun, operation) {
        operation.affectedCount += 1;
        if (dryRun) {
            operation.successCount += 1;
        }
        else {
            try {
                await FoodTruckService.updateTruck(truck.id, {
                    current_location: {
                        ...truck.current_location,
                        ...updates,
                    },
                });
                operation.successCount += 1;
            }
            catch (error) {
                operation.errorCount += 1;
                operation.errors.push(`Failed to fix coordinates for truck ${truck.id}: ${error instanceof Error ? error.message : String(error)}`);
            }
        }
    }
    /**
     * Update quality scores for all trucks
     */
    static async updateQualityScores(trucks, dryRun, operation) {
        const promises = trucks.map((truck) =&gt; this.processSingleTruckForQualityScore(truck, dryRun, operation));
        await Promise.all(promises);
        return operation;
    }
    /**
    * Processes a single food truck for an updated quality score assessment.
    * @example
    * processSingleTruckForQualityScore(truckInstance, false, cleanupOperationInstance)
    * // No return value
    * @param {FoodTruck} truck - The food truck instance to assess and potentially update.
    * @param {boolean} dryRun - Specifies whether this is a dry run (no actual data updates).
    * @param {CleanupOperation} operation - The cleanup operation context for processing.
    * @returns {Promise&lt;void&gt;} No return value; operation is performed asynchronously.
    * @description
    *   - Computes the quality score using data from DataQualityService.
    *   - Updates the quality score only if the score changes significantly (&gt;5% difference).
    *   - Assumes `truck.data_quality_score` might be undefined, defaulting to 0.
    *   - Handles asynchronous processing of the update application if conditions are met.
    */
    static async processSingleTruckForQualityScore(truck, dryRun, operation) {
        const qualityAssessment = DataQualityService.calculateQualityScore(truck);
        if (qualityAssessment) {
            const newScore = qualityAssessment.score;
            const currentScore = truck.data_quality_score ?? 0;
            // Only update if score changed significantly (&gt;5% difference)
            if (typeof newScore === 'number' &amp;&amp; Math.abs(newScore - currentScore) &gt; 0.05) {
                await this.applyQualityScoreUpdate(truck, dryRun, operation);
            }
        }
    }
    /**
     * Updates the quality score of a specified food truck and handles errors during the update process.
     * @example
     * applyQualityScoreUpdate(foodTruckInstance, false, cleanupOperationInstance)
     * void
     * @param {FoodTruck} truck - The food truck for which the quality score will be updated.
     * @param {boolean} dryRun - Flag indicating whether the function should perform the update or just simulate it.
     * @param {CleanupOperation} operation - The cleanup operation containing possible error records.
     * @returns {Promise&lt;void&gt;} Resolves with no value when the update completes. Errors are recorded in the `operation` if thrown.
     * @description
     *   - Throws an error if the quality score update fails.
     *   - If `dryRun` is true, the function simulates the update without changing any data.
     *   - Errors occurring during the update are appended to the `operation.errors` array.
     */
    static async applyQualityScoreUpdate(truck, dryRun, operation) {
        operation.affectedCount += 1;
        if (dryRun) {
            operation.successCount += 1;
        }
        else {
            try {
                const updateResult = await DataQualityService.updateTruckQualityScore(truck.id);
                if ('error' in updateResult) {
                    throw new Error(updateResult.error);
                }
                operation.successCount += 1;
            }
            catch (error) {
                operation.errorCount += 1;
                operation.errors.push(`Failed to update quality score for truck ${truck.id}: ${error instanceof Error ? error.message : String(error)}`);
            }
        }
    }
    /**
     * Identify and merge duplicate trucks
     */
    static async mergeDuplicates(trucks, dryRun, operation) {
        const processedIds = new Set();
        for (const truck of trucks) {
            await this.processSingleTruckForDuplicates(truck, dryRun, { operation, processedIds });
        }
        return operation;
    }
    /**
     * Processes a single food truck to detect and handle duplicates in the dataset.
     * @example
     * processSingleTruckForDuplicates(foodTruck, true, mergeContext)
     * // No return value. Performs operations as a side effect.
     * @param {FoodTruck} truck - An instance of FoodTruck to process for duplicates.
     * @param {boolean} dryRun - Flag indicating if the operation should be executed in dry run mode.
     * @param {MergeOperationContext} context - Operational context that carries state and configurations for the merge operation.
     * @returns {Promise&lt;void&gt;} Executes a set of operations for handling duplicate records, does not return any value.
     * @description
     *   - Ensures a food truck is only processed once by maintaining a set of processed IDs.
     *   - Uses DuplicatePreventionService to assess whether the given truck is a duplicate.
     *   - Applies a merge operation if a duplicate truck is confidently identified.
     */
    static async processSingleTruckForDuplicates(truck, dryRun, context) {
        const { processedIds } = context;
        if (processedIds.has(truck.id))
            return;
        const duplicateCheck = await DuplicatePreventionService.checkForDuplicates(truck);
        if (duplicateCheck.isDuplicate &amp;&amp;
            duplicateCheck.bestMatch?.confidence === 'high' &amp;&amp;
            duplicateCheck.bestMatch.recommendation === 'merge') {
            await this.applyMergeOperation(truck, duplicateCheck.bestMatch.existingTruck, dryRun, context);
        }
        processedIds.add(truck.id);
    }
    /**
     * Applies a merge operation between two food trucks and updates the context.
     * @example
     * applyMergeOperation(truck, existingTruck, true, context)
     * // Executes a dry run of the merge operation without affecting data
     * @param {FoodTruck} truck - The food truck that is being merged.
     * @param {FoodTruck} existingTruck - The existing food truck to merge with.
     * @param {boolean} dryRun - Indicates if the merge operation should be simulated.
     * @param {MergeOperationContext} context - Context containing details and state of the merge operation.
     * @returns {Promise&lt;void&gt;} Promise representing the completion of the merge operation.
     * @description
     *   - Updates the list of processed IDs in the context upon successful merge.
     *   - Throws and records an error if the merge operation fails.
     *   - Utilizes the DuplicatePreventionService for performing the merge.
     */
    static async applyMergeOperation(truck, existingTruck, dryRun, context) {
        const { operation, processedIds } = context;
        operation.affectedCount += 1;
        if (dryRun) {
            operation.successCount += 1;
        }
        else {
            try {
                const mergeResult = await DuplicatePreventionService.mergeDuplicates(truck.id, existingTruck.id);
                if ('error' in mergeResult) {
                    throw new Error(mergeResult.error);
                }
                processedIds.add(existingTruck.id);
                operation.successCount += 1;
            }
            catch (error) {
                operation.errorCount += 1;
                operation.errors.push(`Failed to merge duplicates ${truck.id} and ${existingTruck.id}: ${error instanceof Error ? error.message : String(error)}`);
            }
        }
    }
    /**
     * Normalize phone number format
     */
    static normalizePhone(phone) {
        if (!phone)
            return undefined;
        // Remove all non-digit characters
        const digits = phone.replaceAll(/\D/g, '');
        // Handle US phone numbers
        if (digits.length === 10) {
            return `(${digits.slice(0, 3)}) ${digits.slice(3, 6)}-${digits.slice(6)}`;
        }
        if (digits.length === 11 &amp;&amp; digits.startsWith('1')) {
            return `+1 (${digits.slice(1, 4)}) ${digits.slice(4, 7)}-${digits.slice(7)}`;
        }
        // Return original if can't normalize
        return phone;
    }
    /**
     * Get operation description
     */
    static getOperationDescription(type) {
        const descriptions = {
            remove_placeholders: 'Remove placeholder and mock data values',
            normalize_phone: 'Normalize phone numbers to consistent format',
            fix_coordinates: 'Fix invalid GPS coordinates',
            update_quality_scores: 'Recalculate data quality scores',
            merge_duplicates: 'Identify and merge duplicate truck entries',
        };
        return descriptions[type] ?? 'Unknown operation';
    }
    /**
     * Calculate cleanup summary
     */
    static calculateSummary(operations) {
        return {
            trucksImproved: operations.reduce((sum, op) =&gt; sum + op.successCount, 0),
            duplicatesRemoved: operations.find((op) =&gt; op.type === 'merge_duplicates')?.successCount ?? 0,
            qualityScoreImprovement: operations.find((op) =&gt; op.type === 'update_quality_scores')?.successCount ?? 0,
            placeholdersRemoved: operations.find((op) =&gt; op.type === 'remove_placeholders')?.successCount ?? 0,
        };
    }
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/lib/auth/authHelpers.js (Line 1:17 - Line 22:2), C:/AI/food-truck-finder-poc/dist/lib/lib/auth/authHelpers.js (Line 1:27 - Line 22:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn242" onclick="toggleCodeBlock('cloneGroup242', 'expandBtn242', 'collapseBtn242')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn242" onclick="toggleCodeBlock('cloneGroup242', 'expandBtn242', 'collapseBtn242')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup242"><code class="language-javascript text-sm text-gray-800">;
export async function verifyAdminAccess(request) {
    try {
        const authHeader = request.headers.get('authorization');
        if (!authHeader)
            return false;
        const token = authHeader.replace('Bearer ', '');
        const { data, error } = await supabase.auth.getUser(token);
        const user = data?.user;
        if (error || !user)
            return false;
        const { data: profile } = await supabase
            .from('profiles')
            .select('role')
            .eq('id', user.id)
            .single();
        return profile?.role === 'admin';
    }
    catch {
        return false;
    }
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/components/ui/variants.js (Line 1:1 - Line 100:2), C:/AI/food-truck-finder-poc/dist/lib/components/ui/variants.js (Line 1:1 - Line 100:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn243" onclick="toggleCodeBlock('cloneGroup243', 'expandBtn243', 'collapseBtn243')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn243" onclick="toggleCodeBlock('cloneGroup243', 'expandBtn243', 'collapseBtn243')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup243"><code class="language-javascript text-sm text-gray-800">import { tv } from 'tailwind-variants';
export const buttonVariants = tv({
    base: 'inline-flex items-center justify-center rounded-modern text-sm font-medium transition-all duration-300 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50',
    variants: {
        variant: {
            default: 'bg-primary text-primary-foreground hover:bg-primary/90 hover:shadow-lg hover:shadow-primary/30 hover:scale-105',
            destructive: 'bg-destructive text-destructive-foreground hover:bg-destructive/90 hover:shadow-lg hover:shadow-destructive/30',
            outline: 'border border-input bg-background/50 hover:glass-strong hover:text-accent-foreground hover:neon-border',
            secondary: 'glass text-secondary-foreground hover:glass-strong hover:scale-105',
            ghost: 'hover:glass hover:text-accent-foreground hover-neon',
            link: 'text-primary underline-offset-4 hover:underline hover-neon',
            neon: 'neon-border bg-background/20 text-primary hover:neon-glow hover:bg-primary/10 hover:scale-105',
        },
        size: {
            default: 'h-10 px-4 py-2',
            sm: 'h-9 rounded-md px-3',
            lg: 'h-11 rounded-md px-8',
            icon: 'h-10 w-10',
        },
    },
    defaultVariants: {
        variant: 'default',
        size: 'default',
    },
});
export const toggleVariants = tv({
    base: 'inline-flex items-center justify-center rounded-md text-sm font-medium ring-offset-background transition-colors hover:bg-muted hover:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=on]:bg-accent data-[state=on]:text-accent-foreground [&amp;_svg]:pointer-events-none [&amp;_svg]:size-4 [&amp;_svg]:shrink-0 gap-2',
    variants: {
        variant: {
            default: 'bg-transparent',
            outline: 'border border-input bg-transparent hover:bg-accent hover:text-accent-foreground',
        },
        size: {
            default: 'h-10 px-3 min-w-10',
            sm: 'h-9 px-2.5 min-w-9',
            lg: 'h-11 px-5 min-w-11',
        },
    },
    defaultVariants: {
        variant: 'default',
        size: 'default',
    },
});
export const toastVariants = tv({
    base: 'group pointer-events-auto relative flex w-full items-center justify-between space-x-4 overflow-hidden rounded-md border p-6 pr-8 shadow-lg transition-all data-[swipe=cancel]:translate-x-0 data-[swipe=end]:translate-x-[var(--radix-toast-swipe-end-x)] data-[swipe=move]:translate-x-[var(--radix-toast-swipe-move-x)] data-[swipe=move]:transition-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[swipe=end]:animate-out data-[state=closed]:fade-out-80 data-[state=closed]:slide-out-to-right-full data-[state=open]:slide-in-from-top-full data-[state=open]:sm:slide-in-from-bottom-full',
    variants: {
        variant: {
            default: 'border bg-background text-foreground',
            destructive: 'destructive group border-destructive bg-destructive text-destructive-foreground',
        },
    },
    defaultVariants: {
        variant: 'default',
    },
});
export const alertVariants = tv({
    base: 'relative w-full rounded-lg border p-4 [&amp;&gt;svg~*]:pl-7 [&amp;&gt;svg+div]:translate-y-[-3px] [&amp;&gt;svg]:absolute [&amp;&gt;svg]:left-4 [&amp;&gt;svg]:top-4 [&amp;&gt;svg]:text-foreground',
    variants: {
        variant: {
            default: 'bg-background text-foreground',
            destructive: 'border-destructive/50 text-destructive dark:border-destructive [&amp;&gt;svg]:text-destructive',
        },
    },
    defaultVariants: {
        variant: 'default',
    },
});
export const badgeVariants = tv({
    base: 'inline-flex items-center rounded-full border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2',
    variants: {
        variant: {
            default: 'border-transparent bg-primary text-primary-foreground hover:bg-primary/80',
            secondary: 'border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80',
            destructive: 'border-transparent bg-destructive text-destructive-foreground hover:bg-destructive/80',
            outline: 'text-foreground',
            success: 'border-transparent bg-green-600 text-white hover:bg-green-700 shadow-sm shadow-green-500/20',
            open: 'border-transparent bg-gradient-to-r from-green-500 to-emerald-500 text-white hover:from-green-600 hover:to-emerald-600 shadow-lg shadow-green-500/30',
        },
    },
    defaultVariants: {
        variant: 'default',
    },
});
export const labelVariants = tv({
    base: 'text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70',
});
export const sheetVariants = tv({
    base: 'fixed z-50 gap-4 bg-background p-6 shadow-lg transition ease-in-out data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:duration-300 data-[state=open]:duration-500',
    variants: {
        side: {
            top: 'inset-x-0 top-0 border-b data-[state=closed]:slide-out-to-top data-[state=open]:slide-in-from-top',
            bottom: 'inset-x-0 bottom-0 border-t data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom',
            left: 'inset-y-0 left-0 h-full w-3/4 border-r data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left sm:max-w-sm',
            right: 'inset-y-0 right-0 h-full w-3/4  border-l data-[state=closed]:slide-out-to-right data-[state=open]:slide-in-from-right sm:max-w-sm',
        },
    },
    defaultVariants: {
        side: 'right',
    },
});</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/components/ui/table.jsx (Line 18:4 - Line 54:2), C:/AI/food-truck-finder-poc/dist/lib/components/ui/table.jsx (Line 5:4 - Line 20:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn250" onclick="toggleCodeBlock('cloneGroup250', 'expandBtn250', 'collapseBtn250')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn250" onclick="toggleCodeBlock('cloneGroup250', 'expandBtn250', 'collapseBtn250')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup250"><code class="language-javascript text-sm text-gray-800">={ref} className={cn('w-full caption-bottom text-sm', className)} {...props}/&gt;
    &lt;/div&gt;);
});
Table.displayName = 'Table';
const TableHeader = React.forwardRef((_a, ref) =&gt; {
    var { className } = _a, props = __rest(_a, [&quot;className&quot;]);
    return (&lt;thead ref={ref} className={cn('[&amp;_tr]:border-b', className)} {...props}/&gt;);
});
TableHeader.displayName = 'TableHeader';
const TableBody = React.forwardRef((_a, ref) =&gt; {
    var { className } = _a, props = __rest(_a, [&quot;className&quot;]);
    return (&lt;tbody ref={ref} className={cn('[&amp;_tr:last-child]:border-0', className)} {...props}/&gt;);
});
TableBody.displayName = 'TableBody';
const TableFooter = React.forwardRef((_a, ref) =&gt; {
    var { className } = _a, props = __rest(_a, [&quot;className&quot;]);
    return (&lt;tfoot ref={ref} className={cn('border-t bg-muted/50 font-medium [&amp;&gt;tr]:last:border-b-0', className)} {...props}/&gt;);
});
TableFooter.displayName = 'TableFooter';
const TableRow = React.forwardRef((_a, ref) =&gt; {
    var { className } = _a, props = __rest(_a, [&quot;className&quot;]);
    return (&lt;tr ref={ref} className={cn('border-b transition-colors hover:bg-muted/50 data-[state=selected]:bg-muted', className)} {...props}/&gt;);
});
TableRow.displayName = 'TableRow';
const TableHead = React.forwardRef((_a, ref) =&gt; {
    var { className } = _a, props = __rest(_a, [&quot;className&quot;]);
    return (&lt;th ref={ref} className={cn('h-12 px-4 text-left align-middle font-medium text-muted-foreground [&amp;:has([role=checkbox])]:pr-0', className)} {...props}/&gt;);
});
TableHead.displayName = 'TableHead';
const TableCell = React.forwardRef((_a, ref) =&gt; {
    var { className } = _a, props = __rest(_a, [&quot;className&quot;]);
    return (&lt;td ref={ref} className={cn('p-4 align-middle [&amp;:has([role=checkbox])]:pr-0', className)} {...props}/&gt;);
});
TableCell.displayName = 'TableCell';
const TableCaption = React.forwardRef((_a, ref) =&gt; {
    var { className } = _a, props = __rest(_a, [&quot;className&quot;]);
    return (&lt;caption ref={ref} className={cn('mt-4 text-sm text-muted-foreground', className)}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/components/ui/dataQualityCharts.jsx (Line 52:7 - Line 57:2), C:/AI/food-truck-finder-poc/dist/components/ui/chart/QualityPieChart.jsx (Line 17:7 - Line 22:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn275" onclick="toggleCodeBlock('cloneGroup275', 'expandBtn275', 'collapseBtn275')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn275" onclick="toggleCodeBlock('cloneGroup275', 'expandBtn275', 'collapseBtn275')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup275"><code class="language-javascript text-sm text-gray-800">={300}&gt;
          &lt;PieChart&gt;
            &lt;Pie data={data} cx=&quot;50%&quot; cy=&quot;50%&quot; labelLine={false} label={({ name, percentage }) =&gt; `${name !== null &amp;&amp; name !== void 0 ? name : 'Unknown'}: ${percentage !== null &amp;&amp; percentage !== void 0 ? percentage : '0'}%`} outerRadius={80} fill=&quot;#8884d8&quot; dataKey=&quot;value&quot;&gt;
              {data.map((entry, index) =&gt; (&lt;Cell key={`cell-${index}`} fill={QUALITY_COLORS[index % QUALITY_COLORS.length]}/&gt;))}
            &lt;/Pie&gt;
            &lt;Tooltip content={&lt;CustomTooltip /&gt;}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/components/ui/card.jsx (Line 16:4 - Line 41:2), C:/AI/food-truck-finder-poc/dist/lib/components/ui/card.jsx (Line 3:4 - Line 13:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn282" onclick="toggleCodeBlock('cloneGroup282', 'expandBtn282', 'collapseBtn282')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn282" onclick="toggleCodeBlock('cloneGroup282', 'expandBtn282', 'collapseBtn282')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup282"><code class="language-javascript text-sm text-gray-800">={ref} className={cn('glass rounded-modern text-card-foreground shadow-lg hover:shadow-xl transition-all duration-300', className)} {...props}/&gt;);
});
Card.displayName = 'Card';
const CardHeader = React.forwardRef((_a, ref) =&gt; {
    var { className } = _a, props = __rest(_a, [&quot;className&quot;]);
    return (&lt;div ref={ref} className={cn('flex flex-col space-y-1.5 p-6', className)} {...props}/&gt;);
});
CardHeader.displayName = 'CardHeader';
const CardTitle = React.forwardRef((_a, ref) =&gt; {
    var { className } = _a, props = __rest(_a, [&quot;className&quot;]);
    return (&lt;div ref={ref} className={cn('text-2xl font-semibold leading-none tracking-tight', className)} {...props}/&gt;);
});
CardTitle.displayName = 'CardTitle';
const CardDescription = React.forwardRef((_a, ref) =&gt; {
    var { className } = _a, props = __rest(_a, [&quot;className&quot;]);
    return (&lt;div ref={ref} className={cn('text-sm text-muted-foreground', className)} {...props}/&gt;);
});
CardDescription.displayName = 'CardDescription';
const CardContent = React.forwardRef((_a, ref) =&gt; {
    var { className } = _a, props = __rest(_a, [&quot;className&quot;]);
    return (&lt;div ref={ref} className={cn('p-6 pt-0', className)} {...props}/&gt;);
});
CardContent.displayName = 'CardContent';
const CardFooter = React.forwardRef((_a, ref) =&gt; {
    var { className } = _a, props = __rest(_a, [&quot;className&quot;]);
    return (&lt;div ref={ref} className={cn('flex items-center p-6 pt-0', className)}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/app/login/page.jsx (Line 38:6 - Line 128:2), C:/AI/food-truck-finder-poc/dist/lib/app/login/page.jsx (Line 38:6 - Line 127:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn296" onclick="toggleCodeBlock('cloneGroup296', 'expandBtn296', 'collapseBtn296')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn296" onclick="toggleCodeBlock('cloneGroup296', 'expandBtn296', 'collapseBtn296')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup296"><code class="language-javascript text-sm text-gray-800">={email} setEmail={setEmail} password={password} setPassword={setPassword} loading={loading}/&gt;
      &lt;Button type=&quot;submit&quot; disabled={loading} className=&quot;w-full&quot;&gt;
        {loading ? (&lt;Loader2 className=&quot;mr-2 size-4 animate-spin&quot;/&gt;) : (&lt;Mail className=&quot;mr-2 size-4&quot;/&gt;)}
        {loading ? 'Signing in...' : 'Sign in with Email'}
      &lt;/Button&gt;
    &lt;/form&gt;);
}
// Google login button component
/**
 * Renders a Google login button with a loading state.
 * @example
 * GoogleLoginButton({ loading: true, handleGoogleLogin: asyncFunction })
 * Renders a button either with a spinner if loading or an icon otherwise.
 * @param {Object} props - Properties to configure the Google login button.
 * @param {boolean} props.loading - Indicates whether the button should display a loading spinner.
 * @param {function} props.handleGoogleLogin - Callback function that handles the Google login process.
 * @returns {JSX.Element} A JSX button element configured for Google login interaction.
 * @description
 *   - Uses a loading spinner animation when the login process is ongoing.
 *   - Calls the `handleGoogleLogin` function and manages error handling by logging failures to console.
 *   - Configures the button to be disabled during the loading state to prevent multiple submissions.
 */
function GoogleLoginButton({ loading, handleGoogleLogin, }) {
    return (&lt;Button onClick={() =&gt; {
            handleGoogleLogin().catch((error) =&gt; {
                console.warn('Failed to handle Google login:', error);
            });
        }} disabled={loading} className=&quot;w-full&quot;&gt;
      {loading ? (&lt;Loader2 className=&quot;mr-2 size-4 animate-spin&quot;/&gt;) : (&lt;Mail className=&quot;mr-2 size-4&quot;/&gt;)}
      Google
    &lt;/Button&gt;);
}
// Login footer component
function LoginFooter() {
    return (&lt;div className=&quot;text-center text-sm text-muted-foreground&quot;&gt;
      &lt;p&gt;Admin access only&lt;/p&gt;
      &lt;p&gt;Contact your administrator if you need access&lt;/p&gt;
    &lt;/div&gt;);
}
// Divider component
/**
* Component that renders a styled divider section for login options
* @example
* LoginDivider()
* &lt;div&gt;...&lt;/div&gt;
* @returns {JSX.Element} A JSX element representing the login divider component.
* @description
*   - It uses absolute positioning to overlay a horizontal line across the container.
*   - The text &quot;Or continue with&quot; is styled to appear above the divider with a background.
*   - Ensures the text stays within the confines of the container using flexbox for centering.
*/
function LoginDivider() {
    return (&lt;div className=&quot;relative&quot;&gt;
      &lt;div className=&quot;absolute inset-0 flex items-center&quot;&gt;
        &lt;span className=&quot;w-full border-t&quot;/&gt;
      &lt;/div&gt;
      &lt;div className=&quot;relative flex justify-center text-xs uppercase&quot;&gt;
        &lt;span className=&quot;bg-background px-2 text-muted-foreground&quot;&gt;Or continue with&lt;/span&gt;
      &lt;/div&gt;
    &lt;/div&gt;);
}
/**
 * Renders the login page component which provides email or Google login options.
 * @example
 * const element = &lt;LoginPage /&gt;
 * // Returns a JSX element rendering the login page.
 * @returns {JSX.Element} JSX content displaying login options, error alerts, and associated handlers.
 * @description
 *   - Utilizes `useSearchParams` to determine redirect behavior after login.
 *   - Incorporates `useAuthHandlers` for managing the login process.
 *   - Displays an alert when authentication errors occur.
 *   - Uses `Card`, `LoginHeader`, `EmailLoginForm`, `LoginDivider`, `GoogleLoginButton`, and `LoginFooter` for structuring the page.
 */
export default function LoginPage() {
    var _a;
    const searchParams = useSearchParams();
    const redirectTo = (_a = searchParams.get('redirectedFrom')) !== null &amp;&amp; _a !== void 0 ? _a : '/admin';
    const { handleEmailLogin, handleGoogleLogin, loading, error, email, setEmail, password, setPassword, } = useAuthHandlers(redirectTo);
    return (&lt;div className=&quot;min-h-screen flex items-center justify-center bg-gradient-to-b from-background to-secondary/20 p-4&quot;&gt;
      &lt;Card className=&quot;w-full max-w-md&quot;&gt;
        &lt;LoginHeader /&gt;
        &lt;CardContent className=&quot;space-y-4&quot;&gt;
          {error != undefined &amp;&amp; error.length &gt; 0 &amp;&amp; (&lt;Alert&gt;
              &lt;AlertDescription&gt;{error}&lt;/AlertDescription&gt;
            &lt;/Alert&gt;)}

          &lt;EmailLoginForm email={email} setEmail={setEmail} password={password} setPassword={setPassword} loading={loading} handleEmailLogin={handleEmailLogin}/&gt;

          &lt;LoginDivider /&gt;

          &lt;GoogleLoginButton loading={loading} handleGoogleLogin={handleGoogleLogin}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/app/admin/page.jsx (Line 64:7 - Line 79:2), C:/AI/food-truck-finder-poc/dist/lib/app/admin/page.jsx (Line 63:7 - Line 78:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn302" onclick="toggleCodeBlock('cloneGroup302', 'expandBtn302', 'collapseBtn302')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn302" onclick="toggleCodeBlock('cloneGroup302', 'expandBtn302', 'collapseBtn302')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup302"><code class="language-javascript text-sm text-gray-800">={dataStatus}/&gt;
        &lt;div className=&quot;text-center py-10&quot;&gt;
          &lt;p className=&quot;text-lg text-gray-500&quot;&gt;Food truck data is currently unavailable. Please try again later.&lt;/p&gt;
        &lt;/div&gt;
      &lt;/div&gt;);
    }
    return (&lt;div className=&quot;flex flex-col gap-4&quot;&gt;
      &lt;h1 className=&quot;text-2xl font-bold&quot;&gt;Admin Dashboard&lt;/h1&gt;
      &lt;DataStatusIndicator status={dataStatus}/&gt;

      &lt;div className=&quot;grid gap-4 md:grid-cols-2 lg:grid-cols-4&quot;&gt;
        &lt;TotalFoodTrucksCard totalFoodTrucks={dashboardData.totalFoodTrucks} pendingVerifications={dashboardData.pendingVerifications}/&gt;
        &lt;PipelineStatusCard pendingScrapingJobsCount={dashboardData.pendingScrapingJobsCount} runningScrapingJobsCount={dashboardData.runningScrapingJobsCount} failedScrapingJobsCount={dashboardData.failedScrapingJobsCount}/&gt;
        &lt;DataQualityScoreCard dataQualityStats={dashboardData.dataQualityStats}/&gt;
        &lt;QualityDistributionCard dataQualityStats={dashboardData.dataQualityStats}/&gt;
        &lt;RecentErrorsCard failedProcessingQueueItemsCount={dashboardData.failedProcessingQueueItemsCount}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/api/trucks/handlers.js (Line 2:17 - Line 134:2), C:/AI/food-truck-finder-poc/dist/lib/lib/api/trucks/handlers.js (Line 2:27 - Line 134:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn307" onclick="toggleCodeBlock('cloneGroup307', 'expandBtn307', 'collapseBtn307')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn307" onclick="toggleCodeBlock('cloneGroup307', 'expandBtn307', 'collapseBtn307')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup307"><code class="language-javascript text-sm text-gray-800">;
export async function handleGetTruckById(id) {
    const truckResult = await FoodTruckService.getTruckById(id);
    if ('error' in truckResult) {
        return NextResponse.json({ error: truckResult.error }, { status: 500 });
    }
    return NextResponse.json({ truck: truckResult });
}
/**
 * Retrieves a list of food trucks within a specified radius.
 * @example
 * handleGetTrucksByLocation(&quot;37.7749&quot;, &quot;-122.4194&quot;, &quot;5&quot;)
 * Returns an object with the list of nearby food trucks and additional metadata.
 * @param {string} lat - Latitude of the location from which to search for food trucks.
 * @param {string} lng - Longitude of the location from which to search for food trucks.
 * @param {string} radius - The radius (in kilometers) within which to find food trucks.
 * @returns {Object} An object containing a list of nearby food trucks along with metadata related to the query.
 * @description
 *   - Converts latitude, longitude, and radius from string to float.
 *   - Invokes an asynchronous service call to fetch trucks.
 *   - Returns an error message with status 500 if an error is encountered.
 *   - Currently, assumes no pagination is needed for location-based searches.
 */
export async function handleGetTrucksByLocation(lat, lng, radius) {
    const userLat = Number.parseFloat(lat);
    const userLng = Number.parseFloat(lng);
    const radiusKm = Number.parseFloat(radius);
    const nearbyTrucks = await FoodTruckService.getTrucksByLocation(userLat, userLng, radiusKm);
    if ('error' in nearbyTrucks) {
        return NextResponse.json({ error: &quot;That didn't work, please try again later.&quot; }, { status: 500 });
    }
    return NextResponse.json({
        trucks: nearbyTrucks,
        total: nearbyTrucks.length,
        limit: nearbyTrucks.length, // Assuming no pagination for location-based
        offset: 0,
        hasMore: false,
    });
}
/**
 * Retrieves truck data with pagination support.
 * @example
 * handleGetAllTrucks(10, 0)
 * { trucks: [...], total: 100, limit: 10, offset: 0, hasMore: true, summary: {...} }
 * @param {number} limit - Number of trucks to retrieve per request.
 * @param {number} offset - Starting position of truck data to retrieve.
 * @returns {object} JSON response containing truck data, pagination information, and summary.
 * @description
 *   - Checks for errors returned by the FoodTruckService API and responds with a generic error message.
 *   - Computes an `averageQuality` score for the retrieved trucks.
 *   - Determines `hasMore` by comparing total trucks to limit and offset.
 *   - Calculates `lastUpdated` timestamp from truck data.
 */
export async function handleGetAllTrucks(limit, offset) {
    const { trucks, total, error } = await FoodTruckService.getAllTrucks(limit, offset);
    if (error != undefined &amp;&amp; error !== '') {
        return NextResponse.json({ error: &quot;That didn't work, please try again later.&quot; }, { status: 500 });
    }
    const hasTrucks = Array.isArray(trucks) &amp;&amp; trucks.length &gt; 0;
    return NextResponse.json({
        trucks,
        total,
        limit,
        offset,
        hasMore: offset + limit &lt; (total ?? 0),
        summary: {
            totalTrucks: total,
            averageQuality: hasTrucks
                ? trucks.reduce((acc, t) =&gt; acc + (t.data_quality_score ?? 0), 0) / trucks.length
                : 0,
            lastUpdated: hasTrucks ? Math.max(...trucks.map((t) =&gt; new Date(t.updated_at).getTime())) : 0,
        },
    });
}
/**
* Handles the creation of a food truck by delegating to the FoodTruckService.
* @example
* handlePostTruck({ name: 'Best Food Truck', location: 'Downtown' })
* // returns a JSON response with status 201 and a success message
* @param {unknown} truckData - Data for creating a new food truck.
* @returns {object} JSON response indicating success or failure.
* @description
*   - Utilizes FoodTruckService to create a new truck record.
*   - Handles errors, logging them and returning appropriate HTTP statuses.
*   - Converts the data into a Partial&lt;FoodTruck&gt; type before passing it to the service.
*/
export async function handlePostTruck(truckData) {
    try {
        const newTruckResult = await FoodTruckService.createTruck(truckData);
        if ('error' in newTruckResult) {
            console.error('Error creating truck:', newTruckResult.error);
            return NextResponse.json({ error: newTruckResult.error }, { status: 500 });
        }
        return NextResponse.json({
            message: 'Food truck created successfully',
            truck: newTruckResult,
        }, { status: 201 });
    }
    catch (error) {
        console.error('Error in handlePostTruck:', error);
        return NextResponse.json({ error: 'An unexpected error occurred while creating the food truck.' }, { status: 500 });
    }
}
/**
 * Updates food truck information with given updates and returns the operation status.
 * @example
 * handlePutTruck('1234', { name: 'New Food Truck Name' })
 * { message: 'Food truck updated successfully', truck: updatedTruckResult }
 * @param {string} id - The ID of the food truck to be updated.
 * @param {unknown} updates - The updates to apply to the food truck as a partial object.
 * @returns {Promise&lt;NextResponse&gt;} A response indicating success or failure of the update operation in JSON format.
 * @description
 *   - The function uses FoodTruckService.updateTruck to apply updates.
 *   - It logs errors to the console if the update operation fails.
 *   - Responds with HTTP status 500 in case of any error during the update process.
 */
export async function handlePutTruck(id, updates) {
    try {
        const updatedTruckResult = await FoodTruckService.updateTruck(id, updates);
        if ('error' in updatedTruckResult) {
            console.error('Error updating truck:', updatedTruckResult.error);
            return NextResponse.json({ error: updatedTruckResult.error }, { status: 500 });
        }
        return NextResponse.json({
            message: 'Food truck updated successfully',
            truck: updatedTruckResult,
        });
    }
    catch (error) {
        console.error('Error in handlePutTruck:', error);
        return NextResponse.json({ error: 'An unexpected error occurred while updating the food truck.' }, { status: 500 });
    }
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/api/test-integration/stageHandlers.js (Line 3:17 - Line 140:2), C:/AI/food-truck-finder-poc/dist/lib/lib/api/test-integration/stageHandlers.js (Line 3:27 - Line 140:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn308" onclick="toggleCodeBlock('cloneGroup308', 'expandBtn308', 'collapseBtn308')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn308" onclick="toggleCodeBlock('cloneGroup308', 'expandBtn308', 'collapseBtn308')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup308"><code class="language-javascript text-sm text-gray-800">;
import { mapExtractedDataToTruckSchema } from './schemaMapper';
function getErrorMessage(error, fallback) {
    if (error instanceof Error)
        return error.message;
    if (typeof error === 'string')
        return error;
    return fallback;
}
async function handleUrlScrape(url, logs) {
    logs.push(`Starting Firecrawl scrape for URL: ${url}`);
    try {
        const fcOutput = await firecrawl.scrapeFoodTruckWebsite(url);
        if (fcOutput.success === true &amp;&amp;
            fcOutput.data?.markdown !== undefined &amp;&amp;
            fcOutput.data?.markdown !== '') {
            return {
                contentToProcess: fcOutput.data.markdown,
                sourceUrlForProcessing: fcOutput.data.source_url ?? url,
                firecrawlResult: {
                    status: 'Success',
                    rawContent: fcOutput.data.markdown,
                    metadata: { name: fcOutput.data.name, source_url: fcOutput.data.source_url },
                    details: `Markdown length: ${fcOutput.data.markdown.length}`,
                },
            };
        }
        else {
            throw new Error(fcOutput.error ?? 'Firecrawl failed to return markdown.');
        }
    }
    catch (error) {
        const errorMessage = getErrorMessage(error, 'An unknown error occurred during Firecrawl scrape.');
        logs.push(`Firecrawl error: ${errorMessage}`);
        return {
            firecrawlResult: { status: 'Error', error: errorMessage },
            contentToProcess: undefined,
            sourceUrlForProcessing: url,
        };
    }
}
function handleRawTextProcessing(rawText, logs) {
    logs.push('Using raw text input for processing.');
    return {
        contentToProcess: rawText,
        sourceUrlForProcessing: 'raw_text_input',
        firecrawlResult: {
            status: 'Skipped (Raw Text Provided)',
            details: `Raw text length: ${rawText.length}`,
        },
    };
}
function determineFirecrawlStageOutput(url, rawText, logs) {
    if (url &amp;&amp; rawText === undefined) {
        return handleUrlScrape(url, logs);
    }
    else if (rawText === undefined) {
        logs.push('No URL or raw text provided.');
        throw new Error('Either a URL or raw text must be provided for testing.');
    }
    else {
        return Promise.resolve(handleRawTextProcessing(rawText, logs));
    }
}
function handleEmptyContent(logs) {
    logs.push('Content to process is empty after Firecrawl/raw text stage.');
    throw new Error('Content to process is empty.');
}
export async function handleFirecrawlStage(url, rawText, logs) {
    const stageOutput = await determineFirecrawlStageOutput(url, rawText, logs);
    if (stageOutput.contentToProcess === undefined) {
        handleEmptyContent(logs);
    }
    return stageOutput;
}
export async function handleGeminiStage(contentToProcess, sourceUrlForProcessing, logs) {
    let geminiResult;
    let extractedData;
    logs.push('Starting Gemini processing.');
    try {
        const geminiOutput = await gemini.extractFoodTruckDetailsFromMarkdown(contentToProcess, sourceUrlForProcessing);
        if (geminiOutput.success === true &amp;&amp; geminiOutput.data !== undefined) {
            extractedData = geminiOutput.data;
            geminiResult = {
                status: 'Success',
                data: geminiOutput.data,
                tokensUsed: geminiOutput.tokensUsed,
                prompt: geminiOutput.promptSent,
                details: 'Gemini extraction successful.',
            };
            logs.push('Gemini processing successful.');
        }
        else {
            throw new Error(geminiOutput.error ?? 'Gemini processing failed to return data.');
        }
    }
    catch (error) {
        const errorMessage = getErrorMessage(error, 'An unknown error occurred during Gemini processing.');
        logs.push(`Gemini error: ${errorMessage}`);
        geminiResult = { status: 'Error', error: errorMessage };
    }
    return { geminiResult, extractedData };
}
async function saveToSupabase(truckDataToSave, logs) {
    logs.push('Attempting to save to Supabase (Dry Run is FALSE).');
    const createdTruckResult = await FoodTruckService.createTruck(truckDataToSave);
    if ('error' in createdTruckResult) {
        throw new Error(`Failed to create truck in Supabase: ${createdTruckResult.error}`);
    }
    const createdTruck = createdTruckResult;
    logs.push(`Data saved to Supabase. Record ID: ${createdTruck.id}`);
    return {
        status: 'Success (Saved)',
        preparedData: truckDataToSave,
        recordId: createdTruck.id,
        details: `Truck data saved with ID: ${createdTruck.id}`,
    };
}
export async function handleSupabaseStage(extractedData, sourceUrlForProcessing, isDryRun, logs) {
    logs.push('Preparing for Supabase interaction.');
    try {
        const truckDataToSave = mapExtractedDataToTruckSchema(extractedData, sourceUrlForProcessing, isDryRun);
        if (isDryRun) {
            logs.push('Supabase interaction skipped (Dry Run).');
            return {
                status: 'Success (Dry Run)',
                preparedData: truckDataToSave,
                details: 'Dry Run: Data was prepared but not saved.',
            };
        }
        return await saveToSupabase(truckDataToSave, logs);
    }
    catch (error) {
        const errorMessage = getErrorMessage(error, 'An unknown error occurred during Supabase interaction.');
        logs.push(`Supabase interaction error: ${errorMessage}`);
        return { status: 'Error', error: errorMessage };
    }
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/api/test-integration/schemaMapper.js (Line 1:1 - Line 46:2), C:/AI/food-truck-finder-poc/dist/lib/lib/api/test-integration/schemaMapper.js (Line 1:1 - Line 46:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn310" onclick="toggleCodeBlock('cloneGroup310', 'expandBtn310', 'collapseBtn310')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn310" onclick="toggleCodeBlock('cloneGroup310', 'expandBtn310', 'collapseBtn310')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup310"><code class="language-javascript text-sm text-gray-800">export function mapExtractedDataToTruckSchema(extractedData, sourceUrl, isDryRun) {
    if (!extractedData || typeof extractedData !== 'object') {
        throw new Error('Invalid extractedData for mapping.');
    }
    const name = extractedData.name ?? 'Unknown Test Truck';
    const locationData = extractedData.current_location ?? {};
    const fullAddress = [
        locationData.address,
        locationData.city,
        locationData.state,
        locationData.zip_code,
    ]
        .filter(Boolean)
        .join(', ');
    return {
        name: name,
        description: extractedData.description ?? undefined,
        current_location: {
            lat: locationData.lat ?? 0,
            lng: locationData.lng ?? 0,
            address: fullAddress ?? locationData.raw_text ?? undefined,
            timestamp: new Date().toISOString(),
        },
        scheduled_locations: extractedData.scheduled_locations ?? undefined,
        operating_hours: extractedData.operating_hours ?? undefined,
        menu: (extractedData.menu ?? []).map((category) =&gt; ({
            name: category.name ?? 'Uncategorized',
            items: (category.items ?? []).map((item) =&gt; ({
                name: item.name ?? 'Unknown Item',
                description: item.description ?? undefined,
                price: typeof item.price === 'number' || typeof item.price === 'string' ? item.price : undefined,
                dietary_tags: item.dietary_tags ?? [],
            })),
        })),
        contact_info: extractedData.contact_info ?? undefined,
        social_media: extractedData.social_media ?? undefined,
        cuisine_type: extractedData.cuisine_type ?? [],
        price_range: extractedData.price_range ?? undefined,
        specialties: extractedData.specialties ?? [],
        data_quality_score: isDryRun ? 0.5 : 0.6, // Differentiate test/dry run
        verification_status: 'pending',
        source_urls: [sourceUrl].filter(Boolean),
        last_scraped_at: new Date().toISOString(),
        ...(isDryRun &amp;&amp; { test_run_flag: true }), // Add a flag for actual test saves if needed
    };
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/api/test-integration/pipelineRunnerHelpers.js (Line 1:1 - Line 147:2), C:/AI/food-truck-finder-poc/dist/lib/lib/api/test-integration/pipelineRunnerHelpers.js (Line 1:1 - Line 147:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn311" onclick="toggleCodeBlock('cloneGroup311', 'expandBtn311', 'collapseBtn311')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn311" onclick="toggleCodeBlock('cloneGroup311', 'expandBtn311', 'collapseBtn311')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup311"><code class="language-javascript text-sm text-gray-800">import { handleFirecrawlStage, handleGeminiStage, handleSupabaseStage } from './stageHandlers';
// Helper function to handle stage errors and return a consistent error object
function handleStageErrorAndReturn(firecrawlResult, geminiResult, supabaseResult, logs) {
    return {
        firecrawl: firecrawlResult,
        gemini: geminiResult,
        supabase: supabaseResult,
        logs,
        overallStatus: 'Error',
    };
}
// Helper function to process the Firecrawl stage
async function processFirecrawlStage(url, rawText, logs) {
    const firecrawlStageOutput = await handleFirecrawlStage(url ?? '', rawText, logs);
    const { firecrawlResult, contentToProcess, sourceUrlForProcessing } = firecrawlStageOutput;
    if (firecrawlResult.status === 'Error') {
        return undefined;
    }
    return { firecrawlResult, contentToProcess, sourceUrlForProcessing };
}
// Helper function to process the Gemini stage
async function processGeminiStage(contentToProcess, sourceUrlForProcessing, logs) {
    if (contentToProcess === undefined) {
        logs.push('Content to process is undefined before Gemini stage.');
        return undefined;
    }
    const geminiStageOutput = await handleGeminiStage(contentToProcess, sourceUrlForProcessing, logs);
    const { geminiResult, extractedData } = geminiStageOutput;
    if (geminiResult.status === 'Error' || extractedData === undefined) {
        logs.push(`Gemini stage failed or returned no data. Status: ${geminiResult.status}, Data: ${JSON.stringify(extractedData)}`);
        return undefined;
    }
    return { geminiResult, extractedData };
}
// Helper function to process the Supabase stage
async function processSupabaseStage(extractedData, sourceUrlForProcessing, isDryRun, logs) {
    const supabaseResult = await handleSupabaseStage(extractedData, sourceUrlForProcessing, isDryRun, logs);
    if (supabaseResult.status === 'Error') {
        return undefined;
    }
    return supabaseResult;
}
// Helper function to handle the result of the Gemini stage
function handleGeminiStageResult(geminiStage, firecrawlResult, logs) {
    if (geminiStage === undefined) {
        return {
            status: 'Error',
            result: handleStageErrorAndReturn(firecrawlResult, { status: 'Error', error: 'Gemini stage failed' }, undefined, logs),
        };
    }
    const { geminiResult, extractedData } = geminiStage;
    if (extractedData === undefined) {
        return {
            status: 'Error',
            result: handleStageErrorAndReturn(firecrawlResult, geminiResult, { status: 'Error', error: 'Extracted data is undefined after Gemini stage' }, logs),
        };
    }
    return { status: 'Success', geminiResult, extractedData };
}
// Type guard for PipelineRunResult
function isPipelineRunResult(obj) {
    return (typeof obj === 'object' &amp;&amp;
        obj !== null &amp;&amp;
        'overallStatus' in obj &amp;&amp;
        obj.overallStatus === 'Error');
}
// Define Gemini and Supabase stage helpers before runTestPipeline and ensure they are async if needed
async function handleGeminiStagePipeline(contentToProcess, sourceUrlForProcessing, logs, firecrawlResult) {
    const geminiStage = await processGeminiStage(contentToProcess, sourceUrlForProcessing, logs);
    const geminiStageHandled = handleGeminiStageResult(geminiStage, firecrawlResult, logs);
    if (geminiStageHandled.status === 'Error') {
        return geminiStageHandled.result;
    }
    return geminiStageHandled;
}
// Make handleSupabaseStagePipeline async and ensure it is awaited in runTestPipeline
async function handleSupabaseStagePipeline(config) {
    const { extractedData, sourceUrlForProcessing, isDryRun, logs, firecrawlResult, geminiResult } = config;
    const supabaseStage = await processSupabaseStage(extractedData, sourceUrlForProcessing, isDryRun, logs);
    if (supabaseStage === undefined) {
        return handleStageErrorAndReturn(firecrawlResult, geminiResult, { status: 'Error', error: 'Supabase stage failed' }, logs);
    }
    return supabaseStage;
}
// Helper function to handle the Firecrawl stage within the pipeline
async function executeFirecrawlStage(url, rawText, logs) {
    const firecrawlStageOutput = await processFirecrawlStage(url ?? '', rawText, logs);
    if (!firecrawlStageOutput) {
        return handleStageErrorAndReturn({ status: 'Error', error: 'Firecrawl stage failed' }, undefined, undefined, logs);
    }
    return firecrawlStageOutput;
}
// Helper function to handle the Gemini stage within the pipeline
async function executeGeminiStage(contentToProcess, sourceUrlForProcessing, logs, firecrawlResult) {
    const geminiStageHandled = await handleGeminiStagePipeline(contentToProcess, sourceUrlForProcessing, logs, firecrawlResult);
    if ('overallStatus' in geminiStageHandled) {
        return geminiStageHandled;
    }
    return geminiStageHandled;
}
// Helper function to handle the Supabase stage within the pipeline
async function executeSupabaseStage(config) {
    const supabaseStage = await handleSupabaseStagePipeline(config);
    return supabaseStage;
}
// Generic helper to execute a pipeline stage and handle its result
async function executePipelineStage(stageFunction, args) {
    const output = await stageFunction(...args);
    return output;
}
// Extracted helper function for pipeline execution
export async function executePipeline(url, rawText, isDryRun, logs) {
    const firecrawlOutput = await executePipelineStage(executeFirecrawlStage, [
        url ?? '',
        rawText,
        logs,
    ]);
    if (isPipelineRunResult(firecrawlOutput)) {
        return firecrawlOutput;
    }
    const { firecrawlResult, contentToProcess, sourceUrlForProcessing } = firecrawlOutput;
    const geminiResultObject = await executeGeminiStage(contentToProcess, sourceUrlForProcessing, logs, firecrawlResult);
    if (isPipelineRunResult(geminiResultObject)) {
        return geminiResultObject;
    }
    const { geminiResult, extractedData } = geminiResultObject;
    const supabaseOutput = await executePipelineStage(executeSupabaseStage, [
        {
            extractedData,
            sourceUrlForProcessing,
            isDryRun,
            logs,
            firecrawlResult,
            geminiResult,
        },
    ]);
    if (isPipelineRunResult(supabaseOutput)) {
        return supabaseOutput;
    }
    return {
        firecrawl: firecrawlResult,
        gemini: geminiResult,
        supabase: supabaseOutput,
        logs: [...logs, 'Test pipeline run completed successfully.'],
        overallStatus: 'Success',
    };
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/api/test-integration/helpers.js (Line 3:17 - Line 156:2), C:/AI/food-truck-finder-poc/dist/lib/lib/api/test-integration/helpers.js (Line 3:27 - Line 156:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn312" onclick="toggleCodeBlock('cloneGroup312', 'expandBtn312', 'collapseBtn312')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn312" onclick="toggleCodeBlock('cloneGroup312', 'expandBtn312', 'collapseBtn312')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup312"><code class="language-javascript text-sm text-gray-800">;
// Helper function to test Firecrawl scraping
export async function testFirecrawlScraping(testUrl) {
    console.info('Testing Firecrawl scraping...');
    const scrapeResult = await firecrawl.scrapeUrl(testUrl, {
        formats: ['markdown'],
        onlyMainContent: true,
    });
    if (!scrapeResult.success) {
        return {
            success: false,
            error: 'Firecrawl test failed',
            details: scrapeResult.error,
        };
    }
    return { success: true, result: scrapeResult };
}
// Helper function to test Gemini processing
export async function testGeminiProcessing() {
    console.info('Testing Gemini processing...');
    const testMenuText = 'Burgers: Classic Burger $12.99, Veggie Burger $11.99. Sides: Fries $4.99, Onion Rings $5.99';
    const geminiResult = await gemini.processMenuData(testMenuText);
    if (!geminiResult.success) {
        return {
            success: false,
            error: 'Gemini test failed',
            details: geminiResult.error,
        };
    }
    return { success: true, result: geminiResult };
}
async function createTestFoodTruck(testUrl, menuData) {
    const result = await FoodTruckService.createTruck({
        name: 'Test Food Truck',
        description: 'Integration test truck',
        current_location: {
            lat: 37.7749,
            lng: -122.4194,
            address: 'San Francisco, CA',
            timestamp: new Date().toISOString(),
        },
        scheduled_locations: [],
        operating_hours: {
            monday: { closed: true },
            tuesday: { closed: true },
            wednesday: { closed: true },
            thursday: { closed: true },
            friday: { closed: true },
            saturday: { closed: true },
            sunday: { closed: true },
        },
        menu: menuData,
        contact_info: { phone: '+1-555-TEST', email: undefined, website: undefined },
        social_media: {
            instagram: undefined,
            facebook: undefined,
            twitter: undefined,
            tiktok: undefined,
            yelp: undefined,
        },
        source_urls: [testUrl],
        data_quality_score: 0.8,
        verification_status: 'pending',
    });
    if ('error' in result) {
        throw new Error(`Failed to create test food truck: ${result.error}`);
    }
    return result;
}
function createTestScrapingJob(testUrl) {
    return ScrapingJobService.createJob({
        job_type: 'integration_test',
        target_url: testUrl,
        priority: 10,
        scheduled_at: new Date().toISOString(),
    });
}
function addTestToProcessingQueue(truckId) {
    return DataProcessingService.addToQueue({
        truck_id: truckId,
        processing_type: 'integration_test',
        raw_data: { test: true },
        priority: 10,
    });
}
// Helper function to test Supabase operations
export async function testSupabaseOperations(testUrl, geminiResult) {
    // Create a test food truck
    const testTruck = await createTestFoodTruck(testUrl, geminiResult.data ?? []);
    // Create a test scraping job
    const testJob = await createTestScrapingJob(testUrl);
    // Add to processing queue
    const queueItem = await addTestToProcessingQueue(testTruck.id);
    // Test geospatial query
    const nearbyTrucksResult = await FoodTruckService.getTrucksByLocation(37.7749, -122.4194, 10);
    if ('error' in nearbyTrucksResult) {
        throw new Error(`Failed to get nearby trucks: ${nearbyTrucksResult.error}`);
    }
    const nearbyTrucks = nearbyTrucksResult;
    return {
        testTruck,
        testJob,
        queueItem,
        nearbyTrucks,
    };
}
// Helper function to format test results
export function formatTestResults(scrapeResult, geminiResult, supabaseResults) {
    return {
        success: true,
        message: 'Integration test completed successfully',
        results: {
            firecrawl: {
                success: scrapeResult.result?.success ?? false,
                dataLength: scrapeResult.result?.data?.markdown?.length ?? 0,
            },
            gemini: {
                success: geminiResult.success,
                tokensUsed: geminiResult.tokensUsed,
                categoriesFound: geminiResult.data?.length ?? 0,
            },
            supabase: {
                truckCreated: supabaseResults.testTruck.id,
                jobCreated: supabaseResults.testJob.id,
                queueItemCreated: supabaseResults.queueItem.id,
                nearbyTrucksFound: supabaseResults.nearbyTrucks.length,
            },
        },
        testData: {
            truck: supabaseResults.testTruck,
            processedMenu: geminiResult.data,
            nearbyTrucks: supabaseResults.nearbyTrucks.slice(0, 3),
        },
    };
}
export async function runIntegrationTestSteps(testUrl) {
    console.info('Starting integration test...');
    // Step 1: Test Firecrawl scraping
    const firecrawlTest = await testFirecrawlScraping(testUrl);
    if (!firecrawlTest.success) {
        return firecrawlTest;
    }
    // Step 2: Test Gemini processing
    const geminiTest = await testGeminiProcessing();
    if (!geminiTest.success) {
        return geminiTest;
    }
    // Step 3: Test Supabase operations
    console.info('Testing Supabase operations...');
    const supabaseResults = await testSupabaseOperations(testUrl, geminiTest.result);
    // Step 4: Format and return results
    const results = formatTestResults(firecrawlTest, geminiTest.result, supabaseResults);
    return { success: true, results };
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/api/tavily/handlers.js (Line 1:1 - Line 115:2), C:/AI/food-truck-finder-poc/dist/lib/lib/api/tavily/handlers.js (Line 1:1 - Line 115:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn315" onclick="toggleCodeBlock('cloneGroup315', 'expandBtn315', 'collapseBtn315')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn315" onclick="toggleCodeBlock('cloneGroup315', 'expandBtn315', 'collapseBtn315')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup315"><code class="language-javascript text-sm text-gray-800">/**
 * Sends a search query to the Tavily API and retrieves results.
 * @example
 * callTavilySearchApi('your_api_key', { query: 'example search', limit: 5 })
 * Returns an object containing a list of search results including titles and URLs.
 * @param {string} apiKey - The API key used for authorization with the Tavily API.
 * @param {Record&lt;string, unknown&gt;} params - An object containing search parameters such as the query and limits.
 * @returns {Object} An object containing search results with titles, URLs, and content.
 * @description
 *   - Uses fetch API to send a POST request to Tavily's search endpoint.
 *   - Automatically includes relevant headers for JSON content type and authorization.
 *   - Provides default values for certain parameters (e.g., max_results and search_depth).
 *   - Maps and structures the results before returning them to ensure consistency in the returned format.
 */
async function callTavilySearchApi(apiKey, params) {
    const response = await fetch('https://api.tavily.com/search', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            Authorization: `Bearer ${apiKey}`,
        },
        body: JSON.stringify({
            query: params.query ?? params.q,
            max_results: params.limit ?? 10,
            search_depth: params.search_depth ?? 'advanced',
            include_answer: true,
            include_raw_content: true,
        }),
    });
    if (!response.ok) {
        const errorText = await response.text();
        console.error('Tavily API error response:', errorText);
        throw new Error(`Tavily API error: ${response.status} ${response.statusText} - ${errorText}`);
    }
    const data = (await response.json());
    return {
        results: data.results?.map((result) =&gt; ({
            title: result.title,
            url: result.url,
            content: result.content,
            raw_content: result.raw_content,
        })) ?? [],
    };
}
/**
 * Performs a search operation using Tavily API or returns mock data if API key is unavailable.
 * @example
 * performTavilySearch({ location: 'South Carolina', query: 'food trucks' })
 * { results: [{ title: 'South Carolina Food Trucks (Mock)', url: 'https://example-foodtruck1.com', ... }] }
 * @param {Record&lt;string, unknown&gt;} params - Parameters for the Tavily API search.
 * @returns {Promise&lt;any&gt;} The search results from the Tavily API or mock data.
 * @description
 *   - Utilizes the TAVILY_API_KEY from environment variables to make API requests.
 *   - Returns mock data if the API key is missing or empty.
 *   - Logs a warning if mock data is being used due to missing API key.
 *   - Throws an error if the Tavily API call fails.
 */
export async function performTavilySearch(params) {
    const apiKey = process.env.TAVILY_API_KEY;
    if (apiKey === undefined || apiKey === '') {
        console.warn('TAVILY_API_KEY not found, using mock data');
        return {
            results: [
                {
                    title: 'South Carolina Food Trucks (Mock)',
                    url: 'https://example-foodtruck1.com',
                    content: 'Check out the best food trucks in South Carolina. Visit https://carolinabbq.com for amazing BBQ on wheels.',
                    raw_content: 'Carolina BBQ Food Truck serves authentic South Carolina barbecue...',
                },
                {
                    title: 'Charleston Mobile Food Directory (Mock)',
                    url: 'https://example-directory.com',
                    content: 'Directory of Charleston area food trucks including https://charlestontacos.com and https://lowcountryeats.com',
                    raw_content: 'Complete listing of mobile food vendors in the Charleston area...',
                },
            ],
        };
    }
    try {
        return await callTavilySearchApi(apiKey, params);
    }
    catch (error) {
        console.error('Tavily API call failed:', error);
        throw error;
    }
}
/**
* Performs a mock Tavily crawl operation.
* @example
* performTavilyCrawl({ key: 'value' })
* { results: [ { url: 'https://example-crawled-truck.com', title: 'Gourmet Food Truck', content: 'Premium mobile dining experience...' } ] }
* @param {Record&lt;string, unknown&gt;} params - Parameters for the mock crawl operation.
* @returns {Object} An object containing mock crawl results.
* @description
*   - Utilizes a mock implementation for demonstration purposes.
*   - Logs the crawling parameters to the console for debugging.
*/
export function performTavilyCrawl(params) {
    console.info('Mock Tavily crawl with params:', params);
    return {
        results: [
            {
                url: 'https://example-crawled-truck.com',
                title: 'Gourmet Food Truck',
                content: 'Premium mobile dining experience...',
            },
        ],
    };
}
export function performTavilyMap(params) {
    console.info('Mock Tavily map with params:', params);
    return {
        results: ['https://foodtruckdirectory.com/truck1', 'https://foodtruckdirectory.com/truck2'],
    };
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/api/search/helpers.js (Line 3:24 - Line 37:2), C:/AI/food-truck-finder-poc/dist/lib/lib/api/search/helpers.js (Line 3:27 - Line 37:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn317" onclick="toggleCodeBlock('cloneGroup317', 'expandBtn317', 'collapseBtn317')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn317" onclick="toggleCodeBlock('cloneGroup317', 'expandBtn317', 'collapseBtn317')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup317"><code class="language-javascript text-sm text-gray-800">;
/**
 * Processes a search request and returns filtered and sorted food trucks based on query parameters.
 * @example
 * processSearchRequest(request)
 * { trucks: [/* filtered food trucks */
export async function processSearchRequest(request) {
    const { searchParams } = new URL(request.url);
    const query = searchParams.get('q');
    const cuisine = searchParams.get('cuisine');
    const openNow = searchParams.get('openNow') === 'true';
    const lat = searchParams.get('lat');
    const lng = searchParams.get('lng');
    const radius = searchParams.get('radius');
    let trucks = await getAndFilterFoodTrucks(lat, lng, radius);
    // Apply filters
    trucks = applyTextSearchFilter(trucks, query);
    trucks = applyCuisineFilter(trucks, cuisine);
    trucks = applyOpenNowFilter(trucks, openNow);
    // Sort by data quality score
    const filteredAndSortedTrucks = sortFoodTrucksByQuality(trucks);
    return NextResponse.json({
        trucks: filteredAndSortedTrucks,
        total: filteredAndSortedTrucks.length,
        filters: {
            query,
            cuisine,
            openNow,
            location: lat != undefined &amp;&amp; lng != undefined
                ? { lat: Number.parseFloat(lat), lng: Number.parseFloat(lng) }
                : undefined,
            radius: Number.parseFloat(radius ?? '10'),
        },
    });
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/api/search/filters.js (Line 1:1 - Line 67:2), C:/AI/food-truck-finder-poc/dist/lib/lib/api/search/filters.js (Line 1:1 - Line 67:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn318" onclick="toggleCodeBlock('cloneGroup318', 'expandBtn318', 'collapseBtn318')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn318" onclick="toggleCodeBlock('cloneGroup318', 'expandBtn318', 'collapseBtn318')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup318"><code class="language-javascript text-sm text-gray-800">/**
* Filters an array of FoodTruck objects based on a given search query.
* @example
* applyTextSearchFilter(foodTrucksArray, 'taco')
* // Returns an array of FoodTruck objects where the truck name, description, or menu contains 'taco'
* @param {FoodTruck[]} trucks - An array of FoodTruck objects to be filtered.
* @param {string | null} query - Search query to filter the food trucks by.
* @returns {FoodTruck[]} An array of FoodTruck objects that match the search query.
* @description
*   - If the query is null or an empty string, the original array is returned unfiltered.
*   - The search is case-insensitive.
*   - Searches through truck names, descriptions, and menu item names and descriptions.
*   - Utilizes optional chaining to handle undefined or null values in truck descriptions and menus.
*/
export function applyTextSearchFilter(trucks, query) {
    if (query != undefined &amp;&amp; query !== '') {
        return trucks.filter((truck) =&gt; truck.name.toLowerCase().includes(query.toLowerCase()) ||
            (truck.description?.toLowerCase().includes(query.toLowerCase()) ?? false) ||
            (truck.menu?.some((category) =&gt; category.items?.some((item) =&gt; item.name.toLowerCase().includes(query.toLowerCase()) ||
                (item.description?.toLowerCase().includes(query.toLowerCase()) ?? false))) ??
                false));
    }
    return trucks;
}
export function applyCuisineFilter(trucks, cuisine) {
    if (cuisine != undefined &amp;&amp; cuisine !== '') {
        return trucks.filter((truck) =&gt; truck.menu?.some((category) =&gt; category.name.toLowerCase().includes(cuisine.toLowerCase())));
    }
    return trucks;
}
/**
 * Filters a list of food trucks to only include those that are currently open.
 * @example
 * applyOpenNowFilter(trucks, true)
 * // returns list of trucks open at the current date and time
 * @param {FoodTruck[]} trucks - Array of food truck objects to be filtered.
 * @param {boolean} openNow - Flag to filter trucks that are open at the current time.
 * @returns {FoodTruck[]} Array of food trucks that are open now, or the unfiltered array if openNow is false.
 * @description
 *   - Uses the system's current date and time to determine if trucks are open.
 *   - Filters based on the truck's operating hours for the current day.
 */
export function applyOpenNowFilter(trucks, openNow) {
    if (openNow) {
        const now = new Date();
        const daysOfWeek = [
            'sunday',
            'monday',
            'tuesday',
            'wednesday',
            'thursday',
            'friday',
            'saturday',
        ];
        const currentDay = daysOfWeek[now.getDay()];
        const currentTime = now.getHours() * 100 + now.getMinutes();
        return trucks.filter((truck) =&gt; {
            const hours = truck.operating_hours?.[currentDay];
            if (!hours || hours.closed)
                return false;
            const openTime = Number.parseInt(hours.open.replace(':', ''), 10);
            const closeTime = Number.parseInt(hours.close.replace(':', ''), 10);
            return currentTime &gt;= openTime &amp;&amp; currentTime &lt;= closeTime;
        });
    }
    return trucks;
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/api/search/data.js (Line 1:34 - Line 32:2), C:/AI/food-truck-finder-poc/dist/lib/lib/api/search/data.js (Line 1:37 - Line 32:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn320" onclick="toggleCodeBlock('cloneGroup320', 'expandBtn320', 'collapseBtn320')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn320" onclick="toggleCodeBlock('cloneGroup320', 'expandBtn320', 'collapseBtn320')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup320"><code class="language-javascript text-sm text-gray-800">;
/**
* Retrieves and filters food trucks based on specified location and radius.
* @example
* getAndFilterFoodTrucks(&quot;37.7749&quot;, &quot;-122.4194&quot;, &quot;5&quot;)
* [FoodTruck, FoodTruck, FoodTruck]
* @param {string | null} lat - Latitude of the user's location.
* @param {string | null} lng - Longitude of the user's location.
* @param {string | null} radius - Search radius in kilometers.
* @returns {Promise&lt;FoodTruck[]&gt;} List of food trucks within the specified location and radius.
* @description
*   - Parses latitude, longitude, and radius from strings to floats for calculations.
*   - If latitude or longitude are not provided, fetches all cached food trucks.
*   - Defaults radius to 10 kilometers if not provided.
*/
export async function getAndFilterFoodTrucks(lat, lng, radius) {
    let trucks = [];
    if (lat != undefined &amp;&amp; lng != undefined) {
        const userLat = Number.parseFloat(lat);
        const userLng = Number.parseFloat(lng);
        const radiusKm = Number.parseFloat(radius ?? '10');
        trucks = await CachedFoodTruckService.getTrucksByLocationCached(userLat, userLng, radiusKm);
    }
    else {
        const result = await CachedFoodTruckService.getAllTrucksCached();
        trucks = result.trucks;
    }
    return trucks;
}
export function sortFoodTrucksByQuality(trucks) {
    return [...trucks].sort((a, b) =&gt; (b.data_quality_score ?? 0) - (a.data_quality_score ?? 0));
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/api/scheduler/handlers.js (Line 1:1 - Line 211:2), C:/AI/food-truck-finder-poc/dist/lib/lib/api/scheduler/handlers.js (Line 1:1 - Line 211:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn322" onclick="toggleCodeBlock('cloneGroup322', 'expandBtn322', 'collapseBtn322')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn322" onclick="toggleCodeBlock('cloneGroup322', 'expandBtn322', 'collapseBtn322')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup322"><code class="language-javascript text-sm text-gray-800">import { NextResponse } from 'next/server';
import { schedulerInstance, schedulerTasks, setSchedulerInstance } from './data';
/**
 * Retrieves the current status and summary information of scheduler tasks.
 * @example
 * handleSchedulerStatus()
 * {
 *   isRunning: true,
 *   tasks: [...],
 *   summary: {
 *     totalTasks: 5,
 *     enabledTasks: 3,
 *     runningTasks: 2,
 *     totalSuccesses: 12,
 *     totalErrors: 3
 *   }
 * }
 * @returns {Object} An object containing the runtime status and a summary of the scheduler tasks.
 * @description
 *   - Determines if the scheduler is currently running based on the presence of `schedulerInstance`.
 *   - Provides a detailed summary of the tasks, including counts of total, enabled, and running tasks.
 *   - Accumulates total successes and errors from all scheduler tasks for comprehensive reporting.
 */
export function handleSchedulerStatus() {
    return NextResponse.json({
        isRunning: schedulerInstance != undefined,
        tasks: schedulerTasks,
        summary: {
            totalTasks: schedulerTasks.length,
            enabledTasks: schedulerTasks.filter((t) =&gt; t.enabled).length,
            runningTasks: schedulerTasks.filter((t) =&gt; t.enabled &amp;&amp; t.nextRun != undefined).length,
            totalSuccesses: schedulerTasks.reduce((acc, t) =&gt; acc + t.successCount, 0),
            totalErrors: schedulerTasks.reduce((acc, t) =&gt; acc + t.errorCount, 0),
        },
    });
}
/**
* Generates a JSON response containing a list of scheduler logs
* @example
* handleSchedulerLogs()
* { logs: [...] }
* @returns {Object} A JSON object containing an array of log entries with details.
* @description
*   - Each log entry includes a timestamp, task identifier, log level, and a message.
*   - The log levels include 'info', 'error', and 'warning'.
*   - Log timestamps are derived from the current time and adjusted to simulate real-time delays.
*   - Provides insight into scheduler task execution and any issues encountered.
*/
export function handleSchedulerLogs() {
    return NextResponse.json({
        logs: [
            {
                timestamp: new Date(Date.now() - 300_000).toISOString(),
                taskId: 'location_update',
                level: 'info',
                message: 'Successfully updated locations for 12 food trucks',
            },
            {
                timestamp: new Date(Date.now() - 900_000).toISOString(),
                taskId: 'instagram_scrape',
                level: 'info',
                message: 'Scraped 3 Instagram accounts, found 8 new posts',
            },
            {
                timestamp: new Date(Date.now() - 1_800_000).toISOString(),
                taskId: 'gemini_processing',
                level: 'error',
                message: 'Rate limit exceeded, skipping AI processing',
            },
            {
                timestamp: new Date(Date.now() - 3_600_000).toISOString(),
                taskId: 'website_crawl',
                level: 'warning',
                message: 'Failed to crawl tacoparadise.com - site temporarily unavailable',
            },
        ],
    });
}
export function handleSchedulerDefault() {
    return NextResponse.json({
        message: 'Task Scheduler API',
        endpoints: [
            'GET /api/scheduler?action=status - Get scheduler status',
            'GET /api/scheduler?action=logs - Get execution logs',
            'POST /api/scheduler - Start/stop scheduler or execute task',
            'PUT /api/scheduler - Update task configuration',
        ],
    });
}
/**
* Initializes the scheduler if it's not already running
* @example
* handleStartScheduler()
* { &quot;message&quot;: &quot;Scheduler started successfully&quot;, &quot;status&quot;: &quot;running&quot; }
* @param {none}
* @returns {NextResponse} Returns a JSON response indicating the status of the scheduler.
* @description
*   - Checks if a scheduler instance already exists before proceeding.
*   - Sets the current time as the start time for the new scheduler instance.
*   - Returns a 409 status code if the scheduler is already running.
*/
export function handleStartScheduler() {
    if (schedulerInstance) {
        return NextResponse.json({ error: 'Scheduler is already running' }, { status: 409 });
    }
    setSchedulerInstance({ started: new Date().toISOString() });
    return NextResponse.json({
        message: 'Scheduler started successfully',
        status: 'running',
    });
}
/**
* Stops the scheduler if it is currently running and returns a status message.
* @example
* handleStopScheduler()
* { message: 'Scheduler stopped successfully', status: 'stopped' }
* @param {undefined} schedulerInstance - Represents the current instance of the scheduler.
* @returns {Object} JSON response object containing a message and a status of the operation.
* @description
*   - Returns an error message if the scheduler is not running.
*   - Sets the scheduler instance to undefined to signify it has been stopped.
*/
export function handleStopScheduler() {
    if (!schedulerInstance) {
        return NextResponse.json({ error: 'Scheduler is not running' }, { status: 409 });
    }
    setSchedulerInstance(undefined);
    return NextResponse.json({
        message: 'Scheduler stopped successfully',
        status: 'stopped',
    });
}
/**
 * Executes a task by its ID and returns the execution result.
 * @example
 * handleExecuteTask('12345')
 * { message: 'Task 12345 executed', task: { ... } }
 * @param {string} taskId - Unique identifier of the task to be executed.
 * @returns {NextResponse} JSON response containing the execution result and task details.
 * @description
 *   - If the task ID is undefined or an empty string, returns a 400 JSON error response.
 *   - Finds the task associated with the given ID; returns a 404 JSON error if not found.
 *   - Task execution includes simulating success or failure. Math.random is used for simulation.
 *   - Updates task properties like lastRun, lastSuccess, successCount, errorCount based on execution result.
 */
export function handleExecuteTask(taskId) {
    if (taskId == undefined || taskId === '') {
        return NextResponse.json({ error: 'Task ID is required for execution' }, { status: 400 });
    }
    const task = schedulerTasks.find((t) =&gt; t.id === taskId);
    if (!task) {
        return NextResponse.json({ error: 'Task not found' }, { status: 404 });
    }
    // Simulate task execution
    task.lastRun = new Date().toISOString();
    // Simulate success/failure
    // eslint-disable-next-line sonarjs/pseudo-random -- Math.random is acceptable for simulating task execution.
    if (Math.random() &gt; 0.1) {
        // 90% success rate
        task.lastSuccess = task.lastRun;
        task.successCount += 1;
        task.lastError = undefined;
    }
    else {
        task.errorCount += 1;
        task.lastError = 'Simulated execution error';
    }
    return NextResponse.json({
        message: `Task ${taskId} executed`,
        task: task,
    });
}
/**
 * Handles the update of a task configuration by modifying schedulerTasks.
 * @example
 * handleUpdateTask({ taskId: '123', config: { intervalMinutes: 10 } })
 * { message: 'Task configuration updated', task: { ...updatedTaskDetails } }
 * @param {PutRequestBody} body - Contains taskId and config object for updating task.
 * @returns {NextResponse} JSON response with status indicating the result of the operation.
 * @description
 *   - Checks for required taskId and existence of the task within schedulerTasks.
 *   - Modifies the task configuration using provided config object.
 *   - Updates nextRun time if intervalMinutes is specified and task is enabled.
 */
export function handleUpdateTask(body) {
    const { taskId, config } = body;
    if (!taskId) {
        return NextResponse.json({ error: 'Task ID is required' }, { status: 400 });
    }
    const taskIndex = schedulerTasks.findIndex((t) =&gt; t.id === taskId);
    if (taskIndex === -1) {
        return NextResponse.json({ error: 'Task not found' }, { status: 404 });
    }
    // Update task configuration
    schedulerTasks[taskIndex] = {
        ...schedulerTasks[taskIndex],
        ...config,
    };
    // Update next run time if interval changed
    if (config.intervalMinutes != undefined &amp;&amp;
        config.intervalMinutes &gt; 0 &amp;&amp;
        schedulerTasks[taskIndex].enabled) {
        const lastRun = new Date(schedulerTasks[taskIndex].lastRun ?? Date.now());
        const nextRun = new Date(lastRun.getTime() + config.intervalMinutes * 60 * 1000);
        schedulerTasks[taskIndex].nextRun = nextRun.toISOString();
    }
    return NextResponse.json({
        message: 'Task configuration updated',
        task: schedulerTasks[taskIndex],
    });
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/api/scheduler/data.js (Line 1:1 - Line 62:2), C:/AI/food-truck-finder-poc/dist/lib/lib/api/scheduler/data.js (Line 1:1 - Line 62:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn323" onclick="toggleCodeBlock('cloneGroup323', 'expandBtn323', 'collapseBtn323')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn323" onclick="toggleCodeBlock('cloneGroup323', 'expandBtn323', 'collapseBtn323')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup323"><code class="language-javascript text-sm text-gray-800">export let schedulerInstance;
export const schedulerTasks = [
    {
        id: 'instagram_scrape',
        name: 'Instagram Data Scraping',
        enabled: true,
        intervalMinutes: 120,
        lastRun: new Date(Date.now() - 1_800_000).toISOString(),
        lastSuccess: new Date(Date.now() - 1_800_000).toISOString(),
        successCount: 45,
        errorCount: 3,
        nextRun: new Date(Date.now() + 5_400_000).toISOString(),
    },
    {
        id: 'website_crawl',
        name: 'Website Crawling',
        enabled: true,
        intervalMinutes: 360,
        lastRun: new Date(Date.now() - 7_200_000).toISOString(),
        lastSuccess: new Date(Date.now() - 7_200_000).toISOString(),
        successCount: 23,
        errorCount: 1,
        nextRun: new Date(Date.now() + 14_400_000).toISOString(),
    },
    {
        id: 'data_quality_check',
        name: 'Data Quality Assessment',
        enabled: true,
        intervalMinutes: 720,
        lastRun: new Date(Date.now() - 21_600_000).toISOString(),
        lastSuccess: new Date(Date.now() - 21_600_000).toISOString(),
        successCount: 12,
        errorCount: 0,
        nextRun: new Date(Date.now() + 21_600_000).toISOString(),
    },
    {
        id: 'gemini_processing',
        name: 'AI Data Processing',
        enabled: false,
        intervalMinutes: 480,
        lastRun: new Date(Date.now() - 28_800_000).toISOString(),
        lastSuccess: new Date(Date.now() - 28_800_000).toISOString(),
        successCount: 8,
        errorCount: 2,
        lastError: 'Rate limit exceeded',
        nextRun: undefined,
    },
    {
        id: 'location_update',
        name: 'Real-time Location Updates',
        enabled: true,
        intervalMinutes: 30,
        lastRun: new Date(Date.now() - 900_000).toISOString(),
        lastSuccess: new Date(Date.now() - 900_000).toISOString(),
        successCount: 156,
        errorCount: 8,
        nextRun: new Date(Date.now() + 900_000).toISOString(),
    },
];
export function setSchedulerInstance(instance) {
    schedulerInstance = instance;
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/api/pipeline/handlers.js (Line 1:1 - Line 41:2), C:/AI/food-truck-finder-poc/dist/lib/api/pipeline/handlers.js (Line 1:1 - Line 41:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn325" onclick="toggleCodeBlock('cloneGroup325', 'expandBtn325', 'collapseBtn325')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn325" onclick="toggleCodeBlock('cloneGroup325', 'expandBtn325', 'collapseBtn325')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup325"><code class="language-javascript text-sm text-gray-800">import { NextResponse } from 'next/server';
import { ScrapingJobService } from '@/lib/supabase';
/**
 * Handles a legacy scraping request and creates a scraping job.
 * @example
 * handleLegacyScrapingRequest({ target_url: 'https://example.com', job_type: 'website_scrape', priority: 2 })
 * { message: 'Scraping job created (legacy mode)', job_id: '123', target_url: 'https://example.com', note: 'Consider using the new unified pipeline API with action parameter' }
 * @param {PipelineRequestBody} body - The request body containing scraping job details.
 * @returns {NextResponse} Response indicating the outcome of creating the scraping job.
 * @description
 *   - Validates the `target_url` and returns errors for missing or invalid URLs.
 *   - Defaults `job_type` to 'website_scrape' and `priority` to 1 if not provided.
 *   - Includes a suggestion note about using the new unified pipeline API.
 */
export async function handleLegacyScrapingRequest(body) {
    const { target_url, job_type = 'website_scrape', priority = 1 } = body;
    if (target_url == undefined || target_url === '') {
        return NextResponse.json({ error: 'target_url is required' }, { status: 400 });
    }
    try {
        new URL(target_url);
    }
    catch {
        return NextResponse.json({ error: 'Invalid target_url format' }, { status: 400 });
    }
    const job = await ScrapingJobService.createJob({
        target_url,
        job_type,
        priority,
        scheduled_at: new Date().toISOString(),
    });
    if (job == undefined) {
        return NextResponse.json({ error: 'Failed to create scraping job' }, { status: 500 });
    }
    return NextResponse.json({
        message: 'Scraping job created (legacy mode)',
        job_id: job.id,
        target_url,
        note: 'Consider using the new unified pipeline API with action parameter',
    });
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/api/firecrawl/handlers.js (Line 2:18 - Line 110:2), C:/AI/food-truck-finder-poc/dist/lib/lib/api/firecrawl/handlers.js (Line 2:18 - Line 110:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn326" onclick="toggleCodeBlock('cloneGroup326', 'expandBtn326', 'collapseBtn326')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn326" onclick="toggleCodeBlock('cloneGroup326', 'expandBtn326', 'collapseBtn326')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup326"><code class="language-javascript text-sm text-gray-800">;
// Helper function to handle scrape operation
/**
 * Executes a web scraping operation on the specified URL.
 * @example
 * handleScrapeOperation('https://example.com', { headers: {'User-Agent': 'Mozilla/5.0'} })
 * { success: true, data: [ &lt;scrapedContent&gt; ], error: null }
 * @param {string} url - The URL to be scraped.
 * @param {Record&lt;string, unknown&gt;} options - Additional configurations for the scraping operation.
 * @returns {object} An object containing the success status, scraped data if successful, and any error encountered.
 * @description
 *   - Utilizes 'firecrawl' library to perform the scraping.
 *   - The scrape operation targets the main content of the page only.
 *   - The resulting data is returned in both 'markdown' and 'html' formats.
 */
export async function handleScrapeOperation(url, options) {
    const scrapeResult = await firecrawl.scrapeUrl(url, {
        formats: ['markdown', 'html'],
        onlyMainContent: true,
        ...options,
    });
    return NextResponse.json({
        success: scrapeResult.success,
        data: scrapeResult.success ? [scrapeResult.data] : undefined,
        error: scrapeResult.error,
    });
}
// Helper function to poll crawl status
/**
* Polls the crawl status of a given job ID until the job is completed or a maximum number of attempts is reached.
* @example
* pollCrawlStatus('12345xyz')
* NextResponse { success: true, data: {...} }
* @param {string} jobId - The unique identifier for the crawl job.
* @returns {Promise&lt;NextResponse&gt;} A JSON response indicating the result of the crawl job: completed, failed, or timed out.
* @description
*   - Uses a polling mechanism with a fixed interval to check the job status repeatedly.
*   - Handles completed and failed job statuses with different JSON responses.
*   - Implemented timeout after 30 attempts to prevent indefinite polling.
*   - Provides appropriate HTTP status codes for each response scenario.
*/
export async function pollCrawlStatus(jobId) {
    let attempts = 0;
    const maxAttempts = 30; // 5 minutes max
    const pollInterval = 10_000; // 10 seconds
    while (attempts &lt; maxAttempts) {
        await new Promise((resolve) =&gt; { setTimeout(resolve, pollInterval); });
        const status = await firecrawl.getCrawlStatus(jobId);
        if (status.success &amp;&amp; status.status === 'completed' &amp;&amp; status.data) {
            return NextResponse.json({
                success: true,
                data: status.data,
            });
        }
        else if (status.success &amp;&amp; status.status === 'failed') {
            return NextResponse.json({
                success: false,
                error: 'Crawl job failed',
            }, { status: 500 });
        }
        attempts += 1;
    }
    // Timeout
    return NextResponse.json({
        success: false,
        error: 'Crawl job timed out',
    }, { status: 408 });
}
// Helper function to handle crawl operation
/**
* Initiates and handles the web crawling operation with specified options.
* @example
* handleCrawlOperation('http://example.com', { maxDepth: 3, limit: 50 })
* Returns the status of the crawl job operation.
* @param {string} url - The URL of the website to be crawled.
* @param {Record&lt;string, unknown&gt;} options - Options to configure the crawling operation including maxDepth, limit, includes, and excludes.
* @returns {Promise&lt;Object&gt;} A JSON response object containing the success status and error message, or initiates the crawl status polling.
* @description
*   - Uses `firecrawl` library to start a web crawling job with specific configurations.
*   - Handles crawl job initiation success and failure scenarios.
*   - Returns a JSON response on failure with error details.
*/
export async function handleCrawlOperation(url, options) {
    const crawlJob = await firecrawl.crawlWebsite(url, {
        crawlerOptions: {
            maxDepth: options.maxDepth || 2,
            limit: options.limit || 20,
            includes: options.includes,
            excludes: options.excludes,
        },
        pageOptions: {
            formats: ['markdown'],
            onlyMainContent: true,
        },
    });
    if (!crawlJob.success || crawlJob.jobId == undefined) {
        return NextResponse.json({
            success: false,
            error: crawlJob.error ?? 'Failed to start crawl job',
        }, { status: 500 });
    }
    return pollCrawlStatus(crawlJob.jobId);
}
export function handleSearchOperation() {
    return NextResponse.json({
        success: false,
        error: 'Search operation not directly supported by Firecrawl API. Use crawl on directory URLs instead.',
    }, { status: 400 });
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/utils/typeGuards.js (Line 1:1 - Line 124:2), C:/AI/food-truck-finder-poc/dist/lib/lib/utils/typeGuards.js (Line 1:1 - Line 124:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn337" onclick="toggleCodeBlock('cloneGroup337', 'expandBtn337', 'collapseBtn337')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn337" onclick="toggleCodeBlock('cloneGroup337', 'expandBtn337', 'collapseBtn337')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup337"><code class="language-javascript text-sm text-gray-800">// lib/utils/typeGuards.ts
// --- CORE UTILITY FUNCTIONS (Task 1.1.1 &amp; 1.1.2) ---
/**
 * Checks if a value is a non-null object.
 */
export function isValidObject(value) {
    return typeof value === 'object' &amp;&amp; value !== null &amp;&amp; !Array.isArray(value);
}
/**
 * Safely checks if an object has a specific property. This is a robust implementation.
 */
export function hasProperty(obj, prop) {
    return Object.prototype.hasOwnProperty.call(obj, prop);
}
/**
 * Checks if a value is a string.
 */
export function isString(value) {
    return typeof value === 'string';
}
/**
 * Checks if a value is a valid number (and not NaN).
 */
export function isNumber(value) {
    return typeof value === 'number' &amp;&amp; !Number.isNaN(value);
}
/**
 * Checks if a value is an array.
 */
export function isArray(value) {
    return Array.isArray(value);
}
/**
 * Checks if a value is an array of strings.
 */
export function isStringArray(value) {
    return Array.isArray(value) &amp;&amp; value.every(item =&gt; typeof item === 'string');
}
/**
 * Asserts that a value is of a specific type, throwing a TypeError if validation fails.
 */
export function assertType(value, validator, errorMessage) {
    if (!validator(value)) {
        throw new TypeError(errorMessage ?? `Value does not match expected type.`);
    }
}
/**
 * Safely assigns a value if it passes validation, otherwise returns a fallback.
 * Useful for providing default values for potentially invalid or missing data.
 */
export function safeAssign(value, fallback, validator) {
    return validator(value) ? value : fallback;
}
// --- APPLICATION-SPECIFIC TYPE GUARDS ---
function isPriceRange(value) {
    // Added '$$$$' to the check to fully match the PriceRange type definition.
    return isString(value) &amp;&amp; (value === '$' || value === '$$' || value === '$$$' || value === '$$$$');
}
function isLocationData(value) {
    if (!isValidObject(value))
        return false;
    return hasProperty(value, 'lat') &amp;&amp; isNumber(value.lat) &amp;&amp;
        hasProperty(value, 'lng') &amp;&amp; isNumber(value.lng);
}
function isDailyOperatingHours(value) {
    if (value === undefined)
        return true;
    if (!isValidObject(value))
        return false;
    if (hasProperty(value, 'closed') &amp;&amp; value.closed === true) {
        return true;
    }
    return hasProperty(value, 'open') &amp;&amp; isString(value.open) &amp;&amp;
        hasProperty(value, 'close') &amp;&amp; isString(value.close);
}
function isOperatingHours(value) {
    if (!isValidObject(value))
        return false;
    const days = ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday'];
    return days.every(day =&gt; hasProperty(value, day) &amp;&amp; isDailyOperatingHours(value[day]));
}
function isMenuItem(value) {
    if (!isValidObject(value))
        return false;
    return hasProperty(value, 'name') &amp;&amp; isString(value.name) &amp;&amp;
        hasProperty(value, 'dietary_tags') &amp;&amp; isArray(value.dietary_tags);
}
function isMenuCategory(value) {
    if (!isValidObject(value))
        return false;
    return hasProperty(value, 'name') &amp;&amp; isString(value.name) &amp;&amp;
        hasProperty(value, 'items') &amp;&amp; isArray(value.items) &amp;&amp;
        value.items.every(item =&gt; isMenuItem(item));
}
/**
 * Type guard for the base FoodTruckSchema.
 */
export function isFoodTruckSchema(value) {
    if (!isValidObject(value))
        return false;
    // This property is optional, so it's valid if it's missing, undefined, or matches the type.
    const isPriceRangeValid = !hasProperty(value, 'price_range') || value.price_range === undefined || isPriceRange(value.price_range);
    return hasProperty(value, 'name') &amp;&amp; isString(value.name) &amp;&amp;
        hasProperty(value, 'description') &amp;&amp; isString(value.description) &amp;&amp;
        hasProperty(value, 'current_location') &amp;&amp; isValidObject(value.current_location) &amp;&amp; isLocationData(value.current_location) &amp;&amp;
        hasProperty(value, 'operating_hours') &amp;&amp; isOperatingHours(value.operating_hours) &amp;&amp;
        hasProperty(value, 'menu') &amp;&amp; isArray(value.menu) &amp;&amp; value.menu.every(item =&gt; isMenuCategory(item)) &amp;&amp;
        hasProperty(value, 'cuisine_type') &amp;&amp; isStringArray(value.cuisine_type) &amp;&amp;
        isPriceRangeValid &amp;&amp; // Using the isPriceRange function here
        hasProperty(value, 'data_quality_score') &amp;&amp; isNumber(value.data_quality_score) &amp;&amp;
        hasProperty(value, 'verification_status') &amp;&amp; isString(value.verification_status) &amp;&amp;
        hasProperty(value, 'source_urls') &amp;&amp; isStringArray(value.source_urls) &amp;&amp;
        hasProperty(value, 'last_scraped_at') &amp;&amp; isString(value.last_scraped_at);
}
/**
 * Type guard for the full FoodTruck object (schema + ID fields).
 */
export function isFoodTruck(value) {
    if (!isValidObject(value) || !isFoodTruckSchema(value))
        return false;
    return hasProperty(value, 'id') &amp;&amp; isString(value.id) &amp;&amp;
        hasProperty(value, 'created_at') &amp;&amp; isString(value.created_at) &amp;&amp;
        hasProperty(value, 'updated_at') &amp;&amp; isString(value.updated_at);
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/utils/QualityScorer.js (Line 15:1 - Line 58:4), C:/AI/food-truck-finder-poc/dist/lib/lib/utils/QualityScorer.js (Line 15:1 - Line 58:4)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn338" onclick="toggleCodeBlock('cloneGroup338', 'expandBtn338', 'collapseBtn338')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn338" onclick="toggleCodeBlock('cloneGroup338', 'expandBtn338', 'collapseBtn338')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup338"><code class="language-javascript text-sm text-gray-800">function assessBasicInfo(truck, issues, currentScore) {
    let score = currentScore;
    if (typeof truck.name !== 'string' || truck.name.trim().length === 0) {
        score -= 0.2;
        issues.push('Missing name');
    }
    if (typeof truck.description !== 'string' || truck.description.trim().length === 0) {
        score -= 0.1;
        issues.push('Missing description');
    }
    if (!Array.isArray(truck.cuisine_type) ||
        truck.cuisine_type.length === 0 ||
        !truck.cuisine_type.every((item) =&gt; typeof item === 'string')) {
        score -= 0.1;
        issues.push('Missing or invalid cuisine type');
    }
    if (typeof truck.price_range !== 'string' || truck.price_range.trim().length === 0) {
        score -= 0.05;
        issues.push('Missing price range');
    }
    if (typeof truck.average_rating !== 'number' || Number.isNaN(truck.average_rating)) {
        score -= 0.05;
        issues.push('Missing average rating');
    }
    if (typeof truck.review_count !== 'number' || Number.isNaN(truck.review_count)) {
        score -= 0.05;
        issues.push('Missing review count');
    }
    return score;
}
/**
 * Evaluates the contact information of a food truck and modifies its score accordingly.
 * @example
 * assessContactInfo(truckInstance, [], 1.0)
 * // returns 0.88 if all arguments are missing
 * @param {FoodTruck} truck - An object representing a food truck with various contact attributes.
 * @param {string[]} issues - An array to store any identified issues with contact information.
 * @param {number} currentScore - The initial score before evaluation.
 * @returns {number} A modified score based on the presence and validity of contact details.
 * @description
 *   - Reduces the score by a small percentage for each missing contact detail.
 *   - Appends specific issue messages to the 'issues' array for each missing detail.
 *   - Scores attribute presence in descending impact order: website, phone number, email, social media handles.
 */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/utils/QualityScorer.js (Line 59:1 - Line 100:4), C:/AI/food-truck-finder-poc/dist/lib/lib/utils/QualityScorer.js (Line 59:1 - Line 100:4)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn339" onclick="toggleCodeBlock('cloneGroup339', 'expandBtn339', 'collapseBtn339')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn339" onclick="toggleCodeBlock('cloneGroup339', 'expandBtn339', 'collapseBtn339')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup339"><code class="language-javascript text-sm text-gray-800">function assessContactInfo(truck, issues, currentScore) {
    let score = currentScore;
    if (typeof truck.website !== 'string' || truck.website.trim().length === 0) {
        score -= 0.05;
        issues.push('Missing website');
    }
    if (typeof truck.phone_number !== 'string' || truck.phone_number.trim().length === 0) {
        score -= 0.05;
        issues.push('Missing phone number');
    }
    if (typeof truck.email !== 'string' || truck.email.trim().length === 0) {
        score -= 0.05;
        issues.push('Missing email');
    }
    if (typeof truck.instagram_handle !== 'string' || truck.instagram_handle.trim().length === 0) {
        score -= 0.02;
        issues.push('Missing Instagram handle');
    }
    if (typeof truck.facebook_handle !== 'string' || truck.facebook_handle.trim().length === 0) {
        score -= 0.02;
        issues.push('Missing Facebook handle');
    }
    if (typeof truck.twitter_handle !== 'string' || truck.twitter_handle.trim().length === 0) {
        score -= 0.02;
        issues.push('Missing Twitter handle');
    }
    return score;
}
/**
 * Evaluates the quality of location data for a food truck and updates the score accordingly.
 * @example
 * assessLocationData(truck, issues, currentScore)
 * // Returns a modified score based on location data analysis
 * @param {FoodTruck} truck - The food truck object containing location details.
 * @param {string[]} issues - Array to record any issues identified during evaluation.
 * @param {number} currentScore - The current scoring value before assessment.
 * @returns {number} Updated score reflecting the quality of the location data.
 * @description
 *   - Reduces the score if location data is missing or invalid.
 *   - Checks the age of the location data to determine its staleness.
 *   - Updates the issues array with specific reasons when penalizing the score.
 */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/utils/QualityScorer.js (Line 101:1 - Line 146:4), C:/AI/food-truck-finder-poc/dist/lib/lib/utils/QualityScorer.js (Line 101:1 - Line 146:4)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn340" onclick="toggleCodeBlock('cloneGroup340', 'expandBtn340', 'collapseBtn340')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn340" onclick="toggleCodeBlock('cloneGroup340', 'expandBtn340', 'collapseBtn340')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup340"><code class="language-javascript text-sm text-gray-800">function assessLocationData(truck, issues, currentScore) {
    let score = currentScore;
    if (typeof truck.current_location?.lat !== 'number' ||
        Number.isNaN(truck.current_location.lat) ||
        typeof truck.current_location?.lng !== 'number' ||
        Number.isNaN(truck.current_location.lng)) {
        score -= 0.15;
        issues.push('Missing current location data');
    }
    else {
        if (typeof truck.current_location.timestamp === 'string' &amp;&amp;
            truck.current_location.timestamp.length &gt; 0) {
            const locationAge = Date.now() - new Date(truck.current_location.timestamp).getTime();
            const daysSinceUpdate = locationAge / (1000 * 60 * 60 * 24);
            if (daysSinceUpdate &gt; 7) {
                score -= 0.1;
                issues.push('Stale location data');
            }
        }
        else {
            score -= 0.05;
            issues.push('Missing location timestamp');
        }
    }
    return score;
}
function assessScheduleData(truck, issues, currentScore) {
    let score = currentScore;
    if (!Array.isArray(truck.schedule) || truck.schedule.length === 0) {
        score -= 0.1;
        issues.push('Missing schedule data');
    }
    return score;
}
/**
 * Computes the quality score of a given food truck based on multiple criteria.
 * @example
 * calculateQualityScore(truckInstance)
 * { score: 3, issues: [&quot;Missing contact information&quot;, &quot;Incomplete schedule&quot;] }
 * @param {FoodTruck} truck - The food truck object to be assessed.
 * @returns {QualityAssessment} An object containing the computed score and a list of identified issues.
 * @description
 *   - The score starts at 1 and is adjusted based on various assessments.
 *   - The function ensures the score never drops below zero.
 *   - Issues that affect the score are collected and returned for analysis.
 */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/utils/QualityScorer.js (Line 147:1 - Line 244:2), C:/AI/food-truck-finder-poc/dist/lib/lib/utils/QualityScorer.js (Line 147:1 - Line 244:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn341" onclick="toggleCodeBlock('cloneGroup341', 'expandBtn341', 'collapseBtn341')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn341" onclick="toggleCodeBlock('cloneGroup341', 'expandBtn341', 'collapseBtn341')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup341"><code class="language-javascript text-sm text-gray-800">export function calculateQualityScore(truck) {
    let score = 1; // Start with a perfect score
    const issues = [];
    score = assessBasicInfo(truck, issues, score);
    score = assessContactInfo(truck, issues, score);
    score = assessLocationData(truck, issues, score);
    score = assessScheduleData(truck, issues, score);
    // Ensure score doesn't go below 0
    score = Math.max(0, score);
    return { score, issues };
}
export function categorizeQualityScore(score) {
    if (score &gt;= 0.8) {
        return { label: 'High', color: 'bg-green-500' };
    }
    else if (score &gt;= 0.5) {
        return { label: 'Medium', color: 'bg-yellow-500' };
    }
    return { label: 'Low', color: 'bg-red-500' };
}
export function formatQualityScore(score) {
    if (score === null || score === undefined) {
        return 'N/A';
    }
    return `${(score * 100).toFixed(0)}%`;
}
export function getQualityBadgeClasses(score) {
    if (score === null || score === undefined) {
        return 'bg-gray-500';
    }
    const category = categorizeQualityScore(score);
    return category.color;
}
export function getQualityScoreAriaLabel(score) {
    if (score === null || score === undefined) {
        return 'Data quality score not available';
    }
    const formattedScore = formatQualityScore(score);
    const category = categorizeQualityScore(score);
    return `Data quality: ${formattedScore}, Category: ${category.label}`;
}
export const DataQualityService = {
    calculateQualityScore,
    categorizeQualityScore,
    formatQualityScore,
    getQualityBadgeClasses,
    getQualityScoreAriaLabel,
    async batchUpdateQualityScores(limit = 100) {
        const { data, error } = await supabase
            .from('food_trucks')
            .select('*')
            .limit(limit)
            .overrideTypes();
        if (error) {
            console.error('Error fetching trucks for batch update:', error);
            return { updatedCount: 0, errors: [error.message] };
        }
        const trucks = data ?? [];
        const updates = trucks.map((truck) =&gt; {
            const { score } = calculateQualityScore(truck);
            return {
                id: truck.id,
                data_quality_score: score,
            };
        });
        const { error: updateError, count } = await supabase
            .from('food_trucks')
            .upsert(updates, { onConflict: 'id' })
            .select();
        if (updateError) {
            console.error('Error batch updating quality scores:', updateError);
            return { updatedCount: 0, errors: [updateError.message] };
        }
        return { updatedCount: count ?? 0, errors: [] };
    },
    async updateTruckQualityScore(truckId) {
        const { data: truck, error: fetchError } = await supabase
            .from('food_trucks')
            .select('*')
            .eq('id', truckId)
            .single()
            .overrideTypes();
        if (fetchError || truck === null) {
            console.error(`Error fetching truck ${truckId} for quality update:`, fetchError);
            return { success: false };
        }
        const { score } = calculateQualityScore(truck);
        const { error: updateError } = await supabase
            .from('food_trucks')
            .update({ data_quality_score: score })
            .eq('id', truckId);
        if (updateError) {
            console.error(`Error updating quality score for truck ${truckId}:`, updateError);
            return { success: false };
        }
        return { success: true };
    },
};</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/utils/geocoding.js (Line 1:1 - Line 102:2), C:/AI/food-truck-finder-poc/dist/lib/lib/utils/geocoding.js (Line 1:1 - Line 102:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn342" onclick="toggleCodeBlock('cloneGroup342', 'expandBtn342', 'collapseBtn342')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn342" onclick="toggleCodeBlock('cloneGroup342', 'expandBtn342', 'collapseBtn342')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup342"><code class="language-javascript text-sm text-gray-800">/**
 * Geocoding utilities using Nominatim (OpenStreetMap's free geocoding service)
 * Converts addresses to lat/lng coordinates for map display
 */
/**
 * Geocodes an address to get latitude and longitude coordinates
 * @param address - The address to geocode
 * @param city - Optional city to improve accuracy (defaults to Charleston, SC)
 * @returns Promise containing coordinates and formatted address
 */
export async function geocodeAddress(address, city = 'Charleston, SC') {
    try {
        // Clean and format the address
        const cleanAddress = address.trim();
        if (!cleanAddress) {
            throw new Error('Empty address provided');
        }
        // Construct search query - add city if not already in address
        const searchQuery = cleanAddress.toLowerCase().includes('charleston')
            ? cleanAddress
            : `${cleanAddress}, ${city}`;
        // Use Nominatim API with proper headers and rate limiting
        const url = new URL('https://nominatim.openstreetmap.org/search');
        url.searchParams.set('q', searchQuery);
        url.searchParams.set('format', 'json');
        url.searchParams.set('limit', '1');
        url.searchParams.set('countrycodes', 'us');
        url.searchParams.set('addressdetails', '1');
        console.log(' Geocoding address:', searchQuery);
        const response = await fetch(url.toString(), {
            headers: {
                'User-Agent': 'FoodTruckFinder/1.0 (https://your-domain.com)', // Required by Nominatim
            },
        });
        if (!response.ok) {
            throw new Error(`Geocoding API error: ${response.status}`);
        }
        const data = await response.json();
        if (!data || data.length === 0) {
            console.warn(' No geocoding results for:', searchQuery);
            return {
                lat: 0,
                lng: 0,
                formatted_address: address,
                success: false,
            };
        }
        const result = data[0];
        const lat = parseFloat(result.lat);
        const lng = parseFloat(result.lon);
        // Validate coordinates are reasonable for Charleston area
        if (isNaN(lat) || isNaN(lng)) {
            throw new Error('Invalid coordinates returned');
        }
        console.log(' Geocoded successfully:', {
            original: address,
            coordinates: { lat, lng },
            formatted: result.display_name,
        });
        return {
            lat,
            lng,
            formatted_address: result.display_name,
            success: true,
        };
    }
    catch (error) {
        console.error(' Geocoding failed for address:', address, error);
        return {
            lat: 0,
            lng: 0,
            formatted_address: address,
            success: false,
        };
    }
}
/**
 * Fallback coordinates for Charleston, SC when geocoding fails
 */
export const CHARLESTON_FALLBACK = {
    lat: 32.7765,
    lng: -79.9311,
};
/**
 * Geocodes multiple addresses with rate limiting to avoid overwhelming the service
 * @param addresses - Array of addresses to geocode
 * @param delayMs - Delay between requests (default 1000ms as recommended by Nominatim)
 * @returns Promise array of geocoding results
 */
export async function geocodeAddressesBatch(addresses, delayMs = 1000) {
    const results = [];
    for (let i = 0; i &lt; addresses.length; i++) {
        const address = addresses[i];
        const result = await geocodeAddress(address);
        results.push(result);
        // Rate limiting - wait between requests
        if (i &lt; addresses.length - 1) {
            await new Promise(resolve =&gt; setTimeout(resolve, delayMs));
        }
    }
    return results;
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/utils/foodTruckHelpers.js (Line 1:41 - Line 29:3), C:/AI/food-truck-finder-poc/dist/lib/lib/utils/foodTruckHelpers.js (Line 1:34 - Line 29:3)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn344" onclick="toggleCodeBlock('cloneGroup344', 'expandBtn344', 'collapseBtn344')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn344" onclick="toggleCodeBlock('cloneGroup344', 'expandBtn344', 'collapseBtn344')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup344"><code class="language-javascript text-sm text-gray-800">;
export const getCurrentDay = () =&gt; {
    const days = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];
    return days[new Date().getDay()];
};
export const formatPrice = (price) =&gt; {
    // Updated to accept string
    if (typeof price === 'string') {
        // Handle cases where price might be a string like &quot;$10-$20&quot; or &quot;Varies&quot;
        return price;
    }
    return new Intl.NumberFormat('en-US', {
        style: 'currency',
        currency: 'USD',
    }).format(price);
};
/**
* Converts operational hours to a readable format or returns 'Closed' if applicable.
* @example
* formatOperatingHours({ open: '09:00', close: '17:00', closed: false })
* '9:00 AM - 5:00 PM'
* @param {DailyOperatingHours} hours - Object containing daily opening and closing times, and closed status.
* @returns {string} Formatted operating hours string or 'Closed'.
* @description
*   - Handles conversion of military time to 12-hour format.
*   - Adjusts for typical date parsing without relying on actual date due to fixed date string.
*   - Properly responds to 'closed' status by returning 'Closed'.
*   - Locales can impact formatted output by changing time conventions.
*/</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/utils/foodTruckHelpers.js (Line 30:1 - Line 65:4), C:/AI/food-truck-finder-poc/dist/lib/lib/utils/foodTruckHelpers.js (Line 30:1 - Line 65:4)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn345" onclick="toggleCodeBlock('cloneGroup345', 'expandBtn345', 'collapseBtn345')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn345" onclick="toggleCodeBlock('cloneGroup345', 'expandBtn345', 'collapseBtn345')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup345"><code class="language-javascript text-sm text-gray-800">export const formatHours = (hours) =&gt; {
    // Updated to accept DailyOperatingHours
    if (!hours || hours.closed) {
        return 'Closed';
    }
    const open = new Date(`1970-01-01T${hours.open}Z`).toLocaleTimeString('en-US', {
        hour: 'numeric',
        minute: 'numeric',
        hour12: true,
    });
    const close = new Date(`1970-01-01T${hours.close}Z`).toLocaleTimeString('en-US', {
        hour: 'numeric',
        minute: 'numeric',
        hour12: true,
    });
    return `${open} - ${close}`;
};
export const getPopularItems = (truck) =&gt; {
    // Explicitly define return type
    // Explicitly check for nullish and boolean
    return (truck.menu
        ?.flatMap((category) =&gt; category.items)
        .filter((item) =&gt; Boolean(item &amp;&amp; item.is_popular === true)) ?? []);
};
/**
 * Calculates the price range of all items in the food truck's menu.
 * @example
 * getPriceRange(foodTruck)
 * &quot;5.00 - 12.50&quot;
 * @param {FoodTruck} truck - The food truck object containing menu details.
 * @returns {string} Returns a formatted string representing the price range or 'N/A' if no valid prices are found.
 * @description
 *   - Utilizes the optional chaining operator to safely access nested menu items.
 *   - Filters out non-numeric and undefined prices before calculating the range.
 *   - Formats the minimum and maximum prices using a helper function.
 */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/utils/foodTruckHelpers.js (Line 66:1 - Line 97:4), C:/AI/food-truck-finder-poc/dist/lib/lib/utils/foodTruckHelpers.js (Line 66:1 - Line 97:4)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn346" onclick="toggleCodeBlock('cloneGroup346', 'expandBtn346', 'collapseBtn346')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn346" onclick="toggleCodeBlock('cloneGroup346', 'expandBtn346', 'collapseBtn346')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup346"><code class="language-javascript text-sm text-gray-800">export const getPriceRange = (truck) =&gt; {
    const allItems = truck.menu?.flatMap((category) =&gt; category.items);
    if (!allItems || allItems.length === 0) {
        return 'N/A';
    }
    const numericPrices = allItems
        .map((item) =&gt; item.price)
        .filter((price) =&gt; typeof price === 'number' &amp;&amp; price != undefined); // Filter for numbers
    if (numericPrices.length === 0) {
        return 'N/A'; // No numeric prices found
    }
    const minPrice = Math.min(...numericPrices);
    const maxPrice = Math.max(...numericPrices);
    return `${formatPrice(minPrice)} - ${formatPrice(maxPrice)}`;
};
export const getTodayHours = (truck) =&gt; {
    const today = getCurrentDay();
    return truck.operating_hours?.[today];
};
// Get user's current location or default to San Francisco
/**
 * Retrieves the user's geolocation and updates the location state.
 * @example
 * getUserLocationHelper(setUserLocation)
 * // Updates user's location or defaults to San Francisco
 * @param {function} setUserLocation - Callback function to update user's location state with latitude and longitude.
 * @returns {void} Function does not return anything.
 * @description
 *   - Defaults the location to San Francisco if geolocation access is denied or not supported.
 *   - Utilizes browser's geolocation API to fetch current coordinates.
 *   - Provides a warning in the console if location access is denied.
 */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/utils/foodTruckHelpers.js (Line 98:1 - Line 136:4), C:/AI/food-truck-finder-poc/dist/lib/lib/utils/foodTruckHelpers.js (Line 98:1 - Line 136:4)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn347" onclick="toggleCodeBlock('cloneGroup347', 'expandBtn347', 'collapseBtn347')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn347" onclick="toggleCodeBlock('cloneGroup347', 'expandBtn347', 'collapseBtn347')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup347"><code class="language-javascript text-sm text-gray-800">export function getUserLocationHelper(setUserLocation) {
    if (typeof navigator !== 'undefined' &amp;&amp; navigator.geolocation != undefined) {
        // eslint-disable-next-line sonarjs/no-intrusive-permissions -- Geolocation is essential for finding nearby food trucks
        navigator.geolocation.getCurrentPosition((position) =&gt; {
            console.log(' User location accuracy:', position.coords.accuracy, 'meters');
            setUserLocation({
                lat: position.coords.latitude,
                lng: position.coords.longitude,
            });
        }, (error) =&gt; {
            console.warn('Location access denied:', error);
            // Default to Charleston, SC for this project
            setUserLocation({ lat: 32.7765, lng: -79.9311 });
        }, {
            enableHighAccuracy: true,
            timeout: 10000,
            maximumAge: 300000 // 5 minutes
        });
    }
    else {
        // Default to San Francisco if geolocation is not supported
        setUserLocation({ lat: 37.7749, lng: -122.4194 });
    }
}
// Load all food trucks from API
/**
 * Loads food truck data from the server and updates state.
 * @example
 * loadFoodTrucksHelper(setTrucks, setLoading)
 * undefined
 * @param {(trucks: FoodTruck[]) =&gt; void} setTrucks - Callback to update the state with loaded food trucks.
 * @param {(loading: boolean) =&gt; void} setLoading - Callback to update the loading state.
 * @returns {void} No return value.
 * @description
 *   - Fetches data from '/api/trucks' endpoint.
 *   - Parses the response and expects an object containing a 'trucks' array.
 *   - Logs an error message to the console if fetching or parsing fails.
 *   - Ensures loading state is updated to false in all cases.
 */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/utils/foodTruckHelpers.js (Line 137:1 - Line 168:3), C:/AI/food-truck-finder-poc/dist/lib/lib/utils/foodTruckHelpers.js (Line 137:1 - Line 168:3)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn348" onclick="toggleCodeBlock('cloneGroup348', 'expandBtn348', 'collapseBtn348')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn348" onclick="toggleCodeBlock('cloneGroup348', 'expandBtn348', 'collapseBtn348')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup348"><code class="language-javascript text-sm text-gray-800">export async function loadFoodTrucksHelper(setTrucks, setLoading) {
    try {
        console.log(' Starting to load food trucks...');
        const result = await supabaseFallback.getFoodTrucks();
        console.log(' Full result from supabaseFallback:', result);
        console.log(' Number of trucks found:', result.trucks.length);
        console.log(' Data status:', result.status);
        console.log(' Is from cache:', result.isFromCache);
        setTrucks(result.trucks);
    }
    catch (error) {
        console.error(' Failed to load food trucks:', error);
        setTrucks([]);
    }
    finally {
        setLoading(false);
    }
}
// Load nearby food trucks based on user location
/**
* Loads nearby food trucks based on user's location.
* @example
* loadNearbyTrucksHelper({ lat: 37.7749, lng: -122.4194 }, setTrucksCallback)
* // sets trucks with food truck data or an empty array
* @param {{ lat: number; lng: number } | undefined} userLocation - The location of the user used to find nearby trucks.
* @param {(trucks: FoodTruck[]) =&gt; void} setTrucks - Callback function to set the trucks data.
* @returns {void} No return value.
* @description
*   - Fetches nearby trucks from the API using latitude and longitude.
*   - Uses a fixed radius of 10 units for truck search.
*   - Handles errors by logging them to the console.
*/</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/utils/foodTruckHelpers.js (Line 169:1 - Line 192:4), C:/AI/food-truck-finder-poc/dist/lib/lib/utils/foodTruckHelpers.js (Line 169:1 - Line 192:4)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn349" onclick="toggleCodeBlock('cloneGroup349', 'expandBtn349', 'collapseBtn349')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn349" onclick="toggleCodeBlock('cloneGroup349', 'expandBtn349', 'collapseBtn349')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup349"><code class="language-javascript text-sm text-gray-800">export async function loadNearbyTrucksHelper(userLocation, setTrucks) {
    if (!userLocation)
        return;
    try {
        const { trucks } = await supabaseFallback.getFoodTrucks();
        setTrucks(trucks);
    }
    catch (error) {
        console.error('Failed to load nearby trucks:', error);
    }
}
// Filter trucks that have minimum viable data to display
/**
 * Determines if a food truck has enough essential data to be displayed to users.
 * @example
 * isViableTruck(foodTruck)
 * // returns true if truck has name and location, false otherwise
 * @param {FoodTruck} truck - The food truck object to validate.
 * @returns {boolean} Indicates whether the truck should be displayed.
 * @description
 *   - Checks for minimum required fields: name and valid location coordinates.
 *   - Ensures location has either coordinates OR a meaningful address.
 *   - Flags trucks missing essential data for admin review.
 */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/utils/foodTruckHelpers.js (Line 193:1 - Line 229:4), C:/AI/food-truck-finder-poc/dist/lib/lib/utils/foodTruckHelpers.js (Line 193:1 - Line 229:4)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn350" onclick="toggleCodeBlock('cloneGroup350', 'expandBtn350', 'collapseBtn350')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn350" onclick="toggleCodeBlock('cloneGroup350', 'expandBtn350', 'collapseBtn350')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup350"><code class="language-javascript text-sm text-gray-800">export function isViableTruck(truck) {
    // Must have a name
    if (!truck.name || truck.name.trim() === '' || truck.name === 'Unnamed Truck') {
        console.warn(' Truck missing name:', truck.id);
        return false;
    }
    // Must have location data
    if (!truck.current_location) {
        console.warn(' Truck missing location data:', truck.name);
        return false;
    }
    // Must have either coordinates OR a meaningful address
    const hasCoordinates = typeof truck.current_location.lat === 'number' &amp;&amp;
        typeof truck.current_location.lng === 'number';
    const hasAddress = truck.current_location.address &amp;&amp;
        truck.current_location.address.trim() !== '' &amp;&amp;
        truck.current_location.address !== 'Unknown';
    if (!hasCoordinates &amp;&amp; !hasAddress) {
        console.warn(' Truck missing both coordinates and address:', truck.name);
        return false;
    }
    return true;
}
// Check if a food truck is currently open
/**
 * Determines if the food truck is currently open based on its operating hours.
 * @example
 * isTruckOpen(myFoodTruck)
 * // returns true or false depending on current time and truck's operating hours
 * @param {FoodTruck} truck - The food truck object with operating hours.
 * @returns {boolean} Indicates whether the truck is open.
 * @description
 *   - Utilizes the current day's name to fetch operating hours.
 *   - Handles potential errors in parsing operating hours.
 *   - Logs errors related to parsing time and truck name.
 *   - Uses military time format (HHMM) for comparison.
 */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/utils/foodTruckHelpers.js (Line 230:1 - Line 251:2), C:/AI/food-truck-finder-poc/dist/lib/lib/utils/foodTruckHelpers.js (Line 230:1 - Line 251:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn351" onclick="toggleCodeBlock('cloneGroup351', 'expandBtn351', 'collapseBtn351')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn351" onclick="toggleCodeBlock('cloneGroup351', 'expandBtn351', 'collapseBtn351')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup351"><code class="language-javascript text-sm text-gray-800">export function isTruckOpen(truck) {
    const today = getCurrentDay();
    const hours = truck.operating_hours?.[today];
    // Ensure hours and its properties are not null/undefined before accessing
    if (hours == undefined ||
        hours.closed === true ||
        hours.open == undefined ||
        hours.close == undefined) {
        return false;
    }
    try {
        const now = new Date();
        const currentTime = now.getHours() * 100 + now.getMinutes();
        const openTime = Number.parseInt(hours.open.replace(':', ''), 10);
        const closeTime = Number.parseInt(hours.close.replace(':', ''), 10);
        return currentTime &gt;= openTime &amp;&amp; currentTime &lt;= closeTime;
    }
    catch (error) {
        console.error('Error parsing operating hours for truck', truck.name, error);
        return false;
    }
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/utils/dataQualityFormatters.js (Line 1:1 - Line 180:2), C:/AI/food-truck-finder-poc/dist/lib/lib/utils/dataQualityFormatters.js (Line 1:1 - Line 180:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn352" onclick="toggleCodeBlock('cloneGroup352', 'expandBtn352', 'collapseBtn352')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn352" onclick="toggleCodeBlock('cloneGroup352', 'expandBtn352', 'collapseBtn352')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup352"><code class="language-javascript text-sm text-gray-800">/**
 * SOTA Data Quality Formatting Utilities
 * Provides consistent formatting and categorization for data quality metrics
 */
// SOTA quality thresholds based on industry standards
export const QUALITY_THRESHOLDS = {
    high: 0.8, // 80%+ = High quality
    medium: 0.6, // 60-79% = Medium quality
    low: 0.6, // &lt;60% = Low quality
};
// SOTA color scheme for accessibility and visual hierarchy
export const QUALITY_CATEGORIES = {
    high: {
        label: 'High',
        color: '#22c55e',
        bgColor: 'bg-green-100',
        textColor: 'text-green-800',
    },
    medium: {
        label: 'Medium',
        color: '#f59e0b',
        bgColor: 'bg-yellow-100',
        textColor: 'text-yellow-800',
    },
    low: {
        label: 'Low',
        color: '#ef4444',
        bgColor: 'bg-red-100',
        textColor: 'text-red-800',
    },
};
/**
 * Formats a quality score as a percentage with proper precision
 * @param score - Quality score (0-1 range)
 * @param precision - Number of decimal places (default: 1)
 * @returns Formatted percentage string
 */
export function formatQualityScore(score, precision = 1) {
    if (score === null || score === undefined || Number.isNaN(score)) {
        return 'N/A';
    }
    // Ensure score is in 0-1 range
    const normalizedScore = Math.max(0, Math.min(1, score));
    return `${(normalizedScore * 100).toFixed(precision)}%`;
}
/**
 * Categorizes a quality score into high/medium/low categories
 * @param score - Quality score (0-1 range)
 * @returns Quality category object
 */
export function categorizeQualityScore(score) {
    if (score === null || score === undefined || Number.isNaN(score)) {
        return QUALITY_CATEGORIES.low;
    }
    if (score &gt;= QUALITY_THRESHOLDS.high) {
        return QUALITY_CATEGORIES.high;
    }
    else if (score &gt;= QUALITY_THRESHOLDS.medium) {
        return QUALITY_CATEGORIES.medium;
    }
    return QUALITY_CATEGORIES.low;
}
/**
 * Gets the appropriate CSS classes for a quality score badge
 * @param score - Quality score (0-1 range)
 * @returns CSS class string for badge styling
 */
export function getQualityBadgeClasses(score) {
    const category = categorizeQualityScore(score);
    return `${category.bgColor} ${category.textColor}`;
}
/**
 * Calculates quality score trend indicator
 * @param currentScore - Current quality score
 * @param previousScore - Previous quality score
 * @returns Trend object with direction and percentage change
 */
export function calculateQualityTrend(currentScore, previousScore) {
    if (currentScore == undefined || previousScore == undefined) {
        return {
            direction: 'unknown',
            change: 0,
            changeText: 'N/A',
        };
    }
    const change = currentScore - previousScore;
    const changePercentage = Math.abs(change * 100);
    if (Math.abs(change) &lt; 0.01) {
        // Less than 1% change
        return {
            direction: 'stable',
            change: 0,
            changeText: 'No change',
        };
    }
    return {
        direction: change &gt; 0 ? 'up' : 'down',
        change: changePercentage,
        changeText: `${change &gt; 0 ? '+' : '-'}${changePercentage.toFixed(1)}%`,
    };
}
/**
 * Generates quality improvement suggestions based on score
 * @param score - Quality score (0-1 range)
 * @returns Array of improvement suggestions
 */
export function getQualityImprovementSuggestions(score) {
    if (score == undefined || score &gt;= QUALITY_THRESHOLDS.high) {
        return ['Quality score is excellent! Continue maintaining data standards.'];
    }
    const suggestions = [];
    if (score &lt; QUALITY_THRESHOLDS.medium) {
        suggestions.push('Critical: Add missing core information (name, location, contact details)', 'Verify and update GPS coordinates for accurate location data', 'Add comprehensive menu information and pricing', 'Update operating hours and schedule information');
    }
    else {
        suggestions.push('Add missing optional fields (website, social media, ratings)', 'Enhance menu descriptions and categories', 'Update recent photos and promotional content', 'Verify contact information accuracy');
    }
    return suggestions;
}
/**
 * Formats quality statistics for display
 * @param stats - Raw quality statistics from database
 * @returns Formatted statistics object
 */
export function formatQualityStats(stats) {
    return {
        totalTrucks: stats.total_trucks,
        averageScore: formatQualityScore(stats.avg_quality_score),
        averageScoreRaw: stats.avg_quality_score,
        distribution: {
            high: {
                count: stats.high_quality_count,
                percentage: ((stats.high_quality_count / stats.total_trucks) * 100).toFixed(1),
            },
            medium: {
                count: stats.medium_quality_count,
                percentage: ((stats.medium_quality_count / stats.total_trucks) * 100).toFixed(1),
            },
            low: {
                count: stats.low_quality_count,
                percentage: ((stats.low_quality_count / stats.total_trucks) * 100).toFixed(1),
            },
        },
        verification: {
            verified: {
                count: stats.verified_count,
                percentage: ((stats.verified_count / stats.total_trucks) * 100).toFixed(1),
            },
            pending: {
                count: stats.pending_count,
                percentage: ((stats.pending_count / stats.total_trucks) * 100).toFixed(1),
            },
            flagged: {
                count: stats.flagged_count,
                percentage: ((stats.flagged_count / stats.total_trucks) * 100).toFixed(1),
            },
        },
    };
}
/**
 * Validates if a quality score is within acceptable range
 * @param score - Quality score to validate
 * @returns Boolean indicating if score is valid
 */
export function isValidQualityScore(score) {
    return typeof score === 'number' &amp;&amp; !Number.isNaN(score) &amp;&amp; score &gt;= 0 &amp;&amp; score &lt;= 1;
}
/**
 * Generates accessibility-friendly description for quality score
 * @param score - Quality score (0-1 range)
 * @returns Screen reader friendly description
 */
export function getQualityScoreAriaLabel(score) {
    if (!isValidQualityScore(score)) {
        return 'Quality score not available';
    }
    const category = categorizeQualityScore(score);
    const percentage = formatQualityScore(score);
    return `Data quality score: ${percentage}, categorized as ${category.label.toLowerCase()} quality`;
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/utils/apiHelpers.js (Line 1:1 - Line 21:2), C:/AI/food-truck-finder-poc/dist/lib/lib/utils/apiHelpers.js (Line 1:1 - Line 21:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn354" onclick="toggleCodeBlock('cloneGroup354', 'expandBtn354', 'collapseBtn354')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn354" onclick="toggleCodeBlock('cloneGroup354', 'expandBtn354', 'collapseBtn354')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup354"><code class="language-javascript text-sm text-gray-800">import { NextResponse } from 'next/server';
import { ZodError } from 'zod';
export function handleErrorResponse(error) {
    console.error('API error:', error);
    if (error instanceof ZodError) {
        return NextResponse.json({ error: error.errors }, { status: 400 });
    }
    return NextResponse.json({ error: error instanceof Error ? error.message : String(error) }, { status: 500 });
}
export function handleDeprecatedEndpoint(newEndpoint, documentation) {
    return NextResponse.json({
        status: 'DEPRECATED',
        message: `This endpoint has been consolidated into ${newEndpoint}`,
        migration: {
            newEndpoint,
            documentation,
            deprecationDate: '2024-12-09',
            removalDate: '2025-01-01',
        },
    }, { status: 410 });
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/security/rateLimiter.js (Line 1:1 - Line 237:2), C:/AI/food-truck-finder-poc/dist/lib/lib/security/rateLimiter.js (Line 1:1 - Line 237:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn355" onclick="toggleCodeBlock('cloneGroup355', 'expandBtn355', 'collapseBtn355')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn355" onclick="toggleCodeBlock('cloneGroup355', 'expandBtn355', 'collapseBtn355')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup355"><code class="language-javascript text-sm text-gray-800">/**
 * SOTA Rate Limiting Implementation
 * Prevents brute force attacks and API abuse with intelligent rate limiting
 */
import { NextResponse } from 'next/server'; // Added import for NextResponse
// In-memory rate limit store (in production, use Redis)
const rateLimitStore = new Map();
// Rate limit configurations for different endpoints
export const RATE_LIMIT_CONFIGS = {
    // Authentication endpoints - strict limits
    auth: {
        windowMs: 15 * 60 * 1000, // 15 minutes
        maxRequests: 5, // 5 attempts per 15 minutes
        blockDurationMs: 30 * 60 * 1000, // Block for 30 minutes
        skipSuccessfulRequests: true,
    },
    // API endpoints - moderate limits
    api: {
        windowMs: 60 * 1000, // 1 minute
        maxRequests: 60, // 60 requests per minute
        blockDurationMs: 5 * 60 * 1000, // Block for 5 minutes
        skipSuccessfulRequests: false,
    },
    // Admin endpoints - very strict limits
    admin: {
        windowMs: 60 * 1000, // 1 minute
        maxRequests: 20, // 20 requests per minute
        blockDurationMs: 15 * 60 * 1000, // Block for 15 minutes
        skipSuccessfulRequests: false,
    },
};
/**
 * Rate Limiter Service
 */
export class RateLimiter {
    // Extract logic from checkRateLimit to reduce function size
    static isBlocked(entry, now) {
        return Boolean(entry &amp;&amp; entry.blocked &amp;&amp; entry.blockUntil != undefined &amp;&amp; now &lt; entry.blockUntil);
    }
    static resetEntry(entry, now, config) {
        entry.count = 0;
        entry.resetTime = now + config.windowMs;
        entry.blocked = false;
        entry.blockUntil = undefined;
    }
    /**
     * Check if request should be rate limited
     */
    static checkRateLimit(identifier, type = 'api') {
        const config = RATE_LIMIT_CONFIGS[type];
        const now = Date.now();
        const key = `${type}:${identifier}`;
        this.cleanupExpiredEntries();
        let entry = rateLimitStore.get(key);
        if (!entry) {
            entry = { count: 0, resetTime: now + config.windowMs, blocked: false };
            rateLimitStore.set(key, entry);
        }
        if (this.isBlocked(entry, now)) {
            return {
                allowed: false,
                remaining: 0,
                resetTime: entry.resetTime,
                retryAfter: Math.ceil((entry.blockUntil - now) / 1000),
            };
        }
        if (now &gt;= entry.resetTime) {
            this.resetEntry(entry, now, config);
        }
        if (entry.count &gt;= config.maxRequests) {
            entry.blocked = true;
            entry.blockUntil = now + config.blockDurationMs;
            return {
                allowed: false,
                remaining: 0,
                resetTime: entry.resetTime,
                retryAfter: Math.ceil(config.blockDurationMs / 1000),
            };
        }
        entry.count += 1;
        rateLimitStore.set(key, entry);
        return {
            allowed: true,
            remaining: config.maxRequests - entry.count,
            resetTime: entry.resetTime,
        };
    }
    /**
     * Record successful request (for auth endpoints)
     */
    static recordSuccess(identifier, type = 'api') {
        const config = RATE_LIMIT_CONFIGS[type];
        if (!config.skipSuccessfulRequests)
            return;
        const key = `${type}:${identifier}`;
        const entry = rateLimitStore.get(key);
        if (entry) {
            // Reset counter on successful auth
            entry.count = 0;
            entry.blocked = false;
            entry.blockUntil = undefined;
            rateLimitStore.set(key, entry);
        }
    }
    /**
     * Get rate limit status without incrementing
     */
    static getStatus(identifier, type = 'api') {
        const config = RATE_LIMIT_CONFIGS[type];
        const now = Date.now();
        const key = `${type}:${identifier}`;
        const entry = rateLimitStore.get(key);
        if (!entry) {
            return {
                remaining: config.maxRequests,
                resetTime: now + config.windowMs,
                blocked: false,
            };
        }
        // Check if blocked
        if (entry.blocked &amp;&amp; entry.blockUntil != undefined &amp;&amp; now &lt; entry.blockUntil) {
            // Changed != undefined to != null
            return {
                remaining: 0,
                resetTime: entry.resetTime,
                blocked: true,
                retryAfter: Math.ceil((entry.blockUntil - now) / 1000),
            };
        }
        // Check if window expired
        if (now &gt;= entry.resetTime) {
            return {
                remaining: config.maxRequests,
                resetTime: now + config.windowMs,
                blocked: false,
            };
        }
        return {
            remaining: Math.max(0, config.maxRequests - entry.count),
            resetTime: entry.resetTime,
            blocked: false,
        };
    }
    /**
     * Clean up expired entries to prevent memory leaks
     */
    static cleanupExpiredEntries() {
        const now = Date.now();
        for (const [key, entry] of rateLimitStore.entries()) {
            // Remove entries that are expired and not blocked
            if (now &gt;= entry.resetTime &amp;&amp;
                (!entry.blocked || entry.blockUntil == undefined || now &gt;= entry.blockUntil)) {
                // Changed == undefined to == null
                rateLimitStore.delete(key);
            }
        }
    }
    /**
     * Clear all rate limit data for an identifier
     */
    static clearLimits(identifier, type) {
        if (type) {
            const key = `${type}:${identifier}`;
            rateLimitStore.delete(key);
        }
        else {
            // Clear all types for this identifier
            for (const limitType of Object.keys(RATE_LIMIT_CONFIGS)) {
                // Added type assertion
                const key = `${limitType}:${identifier}`;
                rateLimitStore.delete(key);
            }
        }
    }
    /**
     * Get rate limit statistics
     */
    static getStats() {
        const stats = {
            totalEntries: rateLimitStore.size,
            blockedEntries: 0,
            entriesByType: {},
        };
        for (const [key, entry] of rateLimitStore.entries()) {
            const type = key.split(':')[0];
            stats.entriesByType[type] = (stats.entriesByType[type] ?? 0) + 1;
            if (entry.blocked) {
                stats.blockedEntries += 1;
            }
        }
        return stats;
    }
}
/**
 * Utility function to get client identifier from request
 */
export function getClientIdentifier(request) {
    // Try to get IP address from various headers
    const forwarded = request.headers.get('x-forwarded-for');
    const realIp = request.headers.get('x-real-ip');
    const cfConnectingIp = request.headers.get('cf-connecting-ip');
    // Use the first available IP
    const ip = forwarded?.split(',')[0]?.trim() ?? realIp ?? cfConnectingIp ?? 'unknown';
    // Include user agent for more specific identification
    const userAgent = request.headers.get('user-agent') ?? 'unknown';
    // Create a hash of IP + User Agent for better identification
    return `${ip}:${userAgent.slice(0, 50)}`;
}
/**
 * Rate limiting middleware for API routes
 */
export function withRateLimit(handler, type = 'api') {
    return async (request) =&gt; {
        const identifier = getClientIdentifier(request);
        const result = RateLimiter.checkRateLimit(identifier, type);
        if (result.allowed === false) {
            const headers = new Headers({
                'X-RateLimit-Limit': RATE_LIMIT_CONFIGS[type].maxRequests.toString(),
                'X-RateLimit-Remaining': '0',
                'X-RateLimit-Reset': new Date(result.resetTime).toISOString(),
            });
            if (result.retryAfter) {
                headers.set('Retry-After', result.retryAfter.toString());
            }
            return new NextResponse('Too Many Requests', { status: 429, headers });
        }
        const response = await handler(request);
        // Update headers on successful requests if not skipped
        if (RATE_LIMIT_CONFIGS[type].skipSuccessfulRequests === false) {
            const status = RateLimiter.getStatus(identifier, type);
            response.headers.set('X-RateLimit-Limit', RATE_LIMIT_CONFIGS[type].maxRequests.toString());
            response.headers.set('X-RateLimit-Remaining', status.remaining.toString());
            response.headers.set('X-RateLimit-Reset', new Date(status.resetTime).toISOString());
        }
        return response;
    };
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/security/auditLogger.js (Line 13:5 - Line 39:8), C:/AI/food-truck-finder-poc/dist/lib/lib/security/auditLogger.js (Line 13:5 - Line 39:8)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn361" onclick="toggleCodeBlock('cloneGroup361', 'expandBtn361', 'collapseBtn361')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn361" onclick="toggleCodeBlock('cloneGroup361', 'expandBtn361', 'collapseBtn361')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup361"><code class="language-javascript text-sm text-gray-800">static async logAdminAction(options) {
        const { userId, userEmail, action, resourceType, resourceId, details, request } = options;
        const auditEntry = {
            user_id: userId,
            user_email: userEmail,
            action,
            resource_type: resourceType,
            resource_id: resourceId,
            details,
            ip_address: request?.ip,
            user_agent: request?.userAgent,
            session_id: request?.sessionId,
            timestamp: new Date().toISOString(),
            severity: this.determineSeverity(action, resourceType),
        };
        await this.writeAuditLog(auditEntry);
        // Log to console for immediate monitoring
        console.info('Admin Action Audit:', {
            user: userEmail,
            action,
            resource: resourceId === undefined ? resourceType : `${resourceType}:${resourceId}`,
            timestamp: auditEntry.timestamp,
        });
    }
    /**
     * Log security event
     */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/security/auditLogger.js (Line 40:5 - Line 68:8), C:/AI/food-truck-finder-poc/dist/lib/lib/security/auditLogger.js (Line 40:5 - Line 68:8)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn362" onclick="toggleCodeBlock('cloneGroup362', 'expandBtn362', 'collapseBtn362')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn362" onclick="toggleCodeBlock('cloneGroup362', 'expandBtn362', 'collapseBtn362')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup362"><code class="language-javascript text-sm text-gray-800">static async logSecurityEvent(event) {
        const logEntry = {
            event_type: event.event_type,
            user_id: event.user_id,
            user_email: event.user_email,
            ip_address: event.ip_address,
            user_agent: event.user_agent,
            details: event.details,
            severity: event.severity,
            timestamp: new Date().toISOString(),
        };
        try {
            if (supabaseAdmin) {
                await supabaseAdmin.from('security_events').insert(logEntry);
            }
        }
        catch (error) {
            console.error('Failed to log security event:', error);
        }
        // Always log security events to console
        console.info('Security Event:', logEntry);
        // Alert on critical security events
        if (event.severity === 'critical' || event.severity === 'error') {
            console.warn('SECURITY ALERT:', logEntry);
        }
    }
    /**
     * Log authentication events
     */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/security/auditLogger.js (Line 69:5 - Line 84:8), C:/AI/food-truck-finder-poc/dist/lib/lib/security/auditLogger.js (Line 69:5 - Line 84:8)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn363" onclick="toggleCodeBlock('cloneGroup363', 'expandBtn363', 'collapseBtn363')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn363" onclick="toggleCodeBlock('cloneGroup363', 'expandBtn363', 'collapseBtn363')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup363"><code class="language-javascript text-sm text-gray-800">static async logAuthEvent(options) {
        const { eventType, userEmail, userId, request, details } = options;
        const severity = eventType === 'login_failure' ? 'warning' : 'info';
        await this.logSecurityEvent({
            event_type: eventType,
            user_id: userId,
            user_email: userEmail,
            ip_address: request?.ip,
            user_agent: request?.userAgent,
            details,
            severity,
        });
    }
    /**
     * Log data access events
     */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/security/auditLogger.js (Line 85:5 - Line 103:8), C:/AI/food-truck-finder-poc/dist/lib/lib/security/auditLogger.js (Line 85:5 - Line 103:8)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn364" onclick="toggleCodeBlock('cloneGroup364', 'expandBtn364', 'collapseBtn364')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn364" onclick="toggleCodeBlock('cloneGroup364', 'expandBtn364', 'collapseBtn364')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup364"><code class="language-javascript text-sm text-gray-800">static async logDataAccess(options) {
        const { userId, userEmail, resourceType, resourceId, action = 'read', request } = options;
        await this.logSecurityEvent({
            event_type: 'data_access',
            user_id: userId,
            user_email: userEmail,
            ip_address: request?.ip,
            user_agent: request?.userAgent,
            details: {
                resource_type: resourceType,
                resource_id: resourceId,
                action,
            },
            severity: 'info',
        });
    }
    /**
     * Write audit log to database
     */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/security/auditLogger.js (Line 118:5 - Line 136:8), C:/AI/food-truck-finder-poc/dist/lib/lib/security/auditLogger.js (Line 118:5 - Line 136:8)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn365" onclick="toggleCodeBlock('cloneGroup365', 'expandBtn365', 'collapseBtn365')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn365" onclick="toggleCodeBlock('cloneGroup365', 'expandBtn365', 'collapseBtn365')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup365"><code class="language-javascript text-sm text-gray-800">static determineSeverity(action, resourceType) {
        // Critical actions
        if (action.includes('delete') || action.includes('remove')) {
            return 'critical';
        }
        // Warning actions
        if (action.includes('update') || action.includes('modify') || action.includes('change')) {
            return 'warning';
        }
        // Admin-specific actions
        if (resourceType === 'user' || resourceType === 'admin' || resourceType === 'system') {
            return 'warning';
        }
        // Default to info
        return 'info';
    }
    /**
     * Get audit logs for a specific user
     */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/security/auditLogger.js (Line 137:5 - Line 161:8), C:/AI/food-truck-finder-poc/dist/lib/lib/security/auditLogger.js (Line 137:5 - Line 161:8)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn366" onclick="toggleCodeBlock('cloneGroup366', 'expandBtn366', 'collapseBtn366')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn366" onclick="toggleCodeBlock('cloneGroup366', 'expandBtn366', 'collapseBtn366')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup366"><code class="language-javascript text-sm text-gray-800">static async getUserAuditLogs(userId, limit = 100, offset = 0) {
        try {
            if (!supabaseAdmin) {
                return [];
            }
            const { data, error } = await supabaseAdmin
                .from('audit_logs')
                .select('*')
                .eq('user_id', userId)
                .order('timestamp', { ascending: false })
                .range(offset, offset + limit - 1);
            if (error) {
                console.error('Failed to fetch user audit logs:', error);
                return [];
            }
            return data ?? [];
        }
        catch (error) {
            console.error('Error fetching user audit logs:', error);
            return [];
        }
    }
    /**
     * Get recent security events
     */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/security/auditLogger.js (Line 162:5 - Line 192:4), C:/AI/food-truck-finder-poc/dist/lib/lib/security/auditLogger.js (Line 162:5 - Line 192:4)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn367" onclick="toggleCodeBlock('cloneGroup367', 'expandBtn367', 'collapseBtn367')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn367" onclick="toggleCodeBlock('cloneGroup367', 'expandBtn367', 'collapseBtn367')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup367"><code class="language-javascript text-sm text-gray-800">static async getRecentSecurityEvents(hours = 24, severity) {
        try {
            if (!supabaseAdmin) {
                return [];
            }
            const startTime = new Date();
            startTime.setHours(startTime.getHours() - hours);
            let query = supabaseAdmin
                .from('security_events')
                .select('*')
                .gte('timestamp', startTime.toISOString())
                .order('timestamp', { ascending: false });
            if (severity) {
                query = query.eq('severity', severity);
            }
            const { data, error } = await query.limit(500);
            if (error) {
                console.error('Failed to fetch security events:', error);
                return [];
            }
            return data ?? [];
        }
        catch (error) {
            console.error('Error fetching security events:', error);
            return [];
        }
    }
}
/**
 * Security monitoring utilities
 */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/security/auditLogger.js (Line 197:5 - Line 234:2), C:/AI/food-truck-finder-poc/dist/lib/lib/security/auditLogger.js (Line 197:5 - Line 234:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn368" onclick="toggleCodeBlock('cloneGroup368', 'expandBtn368', 'collapseBtn368')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn368" onclick="toggleCodeBlock('cloneGroup368', 'expandBtn368', 'collapseBtn368')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup368"><code class="language-javascript text-sm text-gray-800">async checkSuspiciousActivity(userId) {
        const reasons = [];
        let riskLevel = 'low';
        try {
            // Check recent failed login attempts
            const recentEvents = await AuditLogger.getRecentSecurityEvents(1, 'warning');
            const failedLogins = recentEvents.filter((event) =&gt; event.event_type === 'login_failed' &amp;&amp; event.user_id === userId);
            if (failedLogins.length &gt; 5) {
                reasons.push('Multiple failed login attempts');
                riskLevel = 'high';
            }
            else if (failedLogins.length &gt; 2) {
                reasons.push('Recent failed login attempts');
                riskLevel = 'medium';
            }
            // Check for unusual access patterns
            const auditLogs = await AuditLogger.getUserAuditLogs(userId, 50);
            const recentActions = auditLogs.filter((log) =&gt; new Date(log.timestamp) &gt; new Date(Date.now() - 60 * 60 * 1000));
            if (recentActions.length &gt; 20) {
                reasons.push('High activity volume');
                riskLevel = riskLevel === 'high' ? 'high' : 'medium';
            }
            return {
                suspicious: reasons.length &gt; 0,
                reasons,
                riskLevel,
            };
        }
        catch (error) {
            console.error('Error checking suspicious activity:', error);
            return {
                suspicious: false,
                reasons: [],
                riskLevel: 'low',
            };
        }
    },
};</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/schemas/truck.js (Line 1:1 - Line 127:2), C:/AI/food-truck-finder-poc/dist/lib/lib/schemas/truck.js (Line 1:1 - Line 127:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn371" onclick="toggleCodeBlock('cloneGroup371', 'expandBtn371', 'collapseBtn371')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn371" onclick="toggleCodeBlock('cloneGroup371', 'expandBtn371', 'collapseBtn371')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup371"><code class="language-javascript text-sm text-gray-800">import { z } from 'zod';
// PriceRange Schema
export const PriceRangeSchema = z.union([
    z.literal('$'),
    z.literal('$$'),
    z.literal('$$$'),
]);
// Coordinates Schema
export const CoordinatesSchema = z.object({
    lat: z.number().optional(),
    lng: z.number().optional(),
});
// LocationData Schema
export const LocationDataSchema = z.object({
    address: z.string().optional(),
    city: z.string().optional(),
    state: z.string().optional(),
    landmarks: z.array(z.string()),
    coordinates: CoordinatesSchema,
    confidence: z.number(),
    raw_location_text: z.string().optional(),
});
// DailyOperatingHours Schema
export const DailyOperatingHoursSchema = z.union([
    z.object({
        open: z.string(),
        close: z.string(),
        closed: z.literal(false),
    }),
    z.object({
        closed: z.literal(true),
    }),
    z.undefined(),
]);
// OperatingHours Schema
export const OperatingHoursSchema = z.object({
    monday: DailyOperatingHoursSchema,
    tuesday: DailyOperatingHoursSchema,
    wednesday: DailyOperatingHoursSchema,
    thursday: DailyOperatingHoursSchema,
    friday: DailyOperatingHoursSchema,
    saturday: DailyOperatingHoursSchema,
    sunday: DailyOperatingHoursSchema,
}).catchall(DailyOperatingHoursSchema); // For the index signature [key: string]: DailyOperatingHours;
// MenuItem Schema
export const MenuItemSchema = z.object({
    name: z.string(),
    description: z.string().optional(),
    price: z.union([z.number(), z.string()]).optional(),
    dietary_tags: z.array(z.any()), // 'any[]' in interface, so 'z.any()' for now
    is_popular: z.boolean().optional(),
});
// MenuCategory Schema
export const MenuCategorySchema = z.object({
    name: z.string(),
    items: z.array(MenuItemSchema),
});
// ContactInfo Schema (from ExtractedFoodTruckDetails)
export const ContactInfoSchema = z.object({
    phone: z.string().optional(),
    email: z.string().optional(),
    website: z.string().optional(),
});
// SocialMedia Schema (from ExtractedFoodTruckDetails)
export const SocialMediaSchema = z.object({
    instagram: z.string().optional(),
    facebook: z.string().optional(),
    twitter: z.string().optional(),
    tiktok: z.string().optional(),
    yelp: z.string().optional(),
});
// ScheduledLocation Schema (from ExtractedFoodTruckDetails)
export const ScheduledLocationSchema = z.object({
    address: z.string().optional(),
    city: z.string().optional(),
    state: z.string().optional(),
    zip_code: z.string().optional(),
    lat: z.number().optional(),
    lng: z.number().optional(),
    timestamp: z.string(),
    start_time: z.string(),
    end_time: z.string(),
});
// FoodTruckSchema
export const FoodTruckSchema = z.object({
    name: z.string(),
    description: z.string().optional(),
    current_location: z.object({
        lat: z.number(),
        lng: z.number(),
        address: z.string().optional(),
        timestamp: z.string(),
    }),
    scheduled_locations: z.array(ScheduledLocationSchema).optional(),
    operating_hours: OperatingHoursSchema,
    menu: z.array(MenuCategorySchema),
    contact_info: ContactInfoSchema,
    social_media: SocialMediaSchema,
    cuisine_type: z.array(z.string()),
    price_range: PriceRangeSchema.optional(),
    specialties: z.array(z.string()),
    data_quality_score: z.number(),
    verification_status: z.union([
        z.literal('pending'),
        z.literal('verified'),
        z.literal('flagged'),
    ]),
    source_urls: z.array(z.string()),
    last_scraped_at: z.string(),
    test_run_flag: z.boolean().optional(),
    website: z.string().optional(),
    phone_number: z.string().optional(),
    email: z.string().optional(),
    instagram_handle: z.string().optional(),
    facebook_handle: z.string().optional(),
    twitter_handle: z.string().optional(),
    schedule: z.array(z.any()).optional(), // 'unknown[]' in interface, so 'z.any()' for now
    average_rating: z.number().optional(),
    review_count: z.number().optional(),
});
// Truck Schema (extends FoodTruckSchema)
export const TruckSchema = FoodTruckSchema.extend({
    id: z.string(),
    created_at: z.string(),
    updated_at: z.string(),
    is_active: z.boolean().optional(),
});</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/pipeline/scrapingProcessor.js (Line 5:24 - Line 43:4), C:/AI/food-truck-finder-poc/dist/lib/lib/pipeline/scrapingProcessor.js (Line 4:20 - Line 42:4)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn372" onclick="toggleCodeBlock('cloneGroup372', 'expandBtn372', 'collapseBtn372')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn372" onclick="toggleCodeBlock('cloneGroup372', 'expandBtn372', 'collapseBtn372')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup372"><code class="language-javascript text-sm text-gray-800">;

/**
 * Initiates web scraping for a specified food truck website.
 * @example
 * handleScraping(&quot;https://foodtruck.com&quot;, &quot;job123&quot;)
 * Returns data object with markdown content
 * @param {string} targetUrl - The URL of the food truck website to scrape.
 * @param {string} jobId - The unique identifier for the scraping job.
 * @returns {Object} An object containing the scraped data, including markdown content.
 * @description
 *   - Utilizes firecrawl library to perform web scraping.
 *   - Calls handleJobFailure if scraping is unsuccessful or markdown content is missing.
 *   - Logs the progress and success of the scraping process in the console.
 */
async function handleScraping(targetUrl, jobId) {
    console.info(`Starting scrape for ${targetUrl}`);
    const scrapeResult = await firecrawl.scrapeFoodTruckWebsite(targetUrl);
    if (!scrapeResult.success || !scrapeResult.data?.markdown) {
        const error = scrapeResult.error ?? 'Scraping failed or markdown content not found';
        await handleJobFailure(jobId, error);
        throw new Error(error);
    }
    console.info(`Scraping successful for ${targetUrl}, proceeding to Gemini extraction.`);
    return scrapeResult.data;
}

/**
 * Handles job failure by updating the job status in the database.
 * @example
 * handleJobFailure(&quot;job123&quot;, &quot;Scraping failed&quot;)
 * undefined
 * @param {string} jobId - The unique identifier for the scraping job.
 * @param {string} errorMessage - The error message to be recorded.
 * @returns {Promise&lt;void&gt;} Resolves when the job status is updated.
 * @description
 *   - Updates the job status to 'failed' with the provided error message.
 *   - Logs the error for debugging purposes.
 */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/pipeline/scrapingProcessor.js (Line 78:6 - Line 133:19), C:/AI/food-truck-finder-poc/dist/lib/lib/pipeline/scrapingProcessor.js (Line 76:2 - Line 129:6)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn373" onclick="toggleCodeBlock('cloneGroup373', 'expandBtn373', 'collapseBtn373')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn373" onclick="toggleCodeBlock('cloneGroup373', 'expandBtn373', 'collapseBtn373')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup373"><code class="language-javascript text-sm text-gray-800">;
    }
}

/**
 * Manages retry logic for a scraping job based on its current retry count.
 * @example
 * handleRetryLogic(&quot;job123&quot;)
 * undefined
 * @param {string} jobId - The unique identifier for the scraping job.
 * @returns {Promise&lt;void&gt;} Does not return a value but handles retries or logs errors.
 * @description
 *   - Utilizes ScrapingJobService to increment the retry count for the given job.
 *   - Determines whether to retry the job based on retry_count and max_retries properties.
 *   - Logs messages to inform about retry attempts or if max retries have been reached.
 *   - Catches and logs errors encountered during the retry process.
 */
async function handleRetryLogic(jobId) {
    try {
        const job = await ScrapingJobService.incrementRetryCount(jobId);
        if (job &amp;&amp; typeof job.retry_count === 'number' &amp;&amp; typeof job.max_retries === 'number') {
            if (job.retry_count &lt; job.max_retries) {
                console.info(`Retrying job ${jobId} (attempt ${job.retry_count}/${job.max_retries})`);
                setTimeout(() =&gt; {
                    void processScrapingJob(jobId);
                }, 5000);
            }
            else {
                console.warn(`Job ${jobId} reached max retries (${job.max_retries}).`);
            }
        }
        else {
            console.error(`Job ${jobId}: Could not get valid retry_count or max_retries. Won't attempt retry.`);
        }
    }
    catch (retryError) {
        console.error(`Error during retry logic for job ${jobId}:`, retryError);
    }
}

/**
 * Processes a scraping job by managing its lifecycle and data extraction.
 * @example
 * processScrapingJob('12345')
 * // Scraping job 12345 completed successfully and data processed.
 * @param {string} jobId - The unique identifier for the scraping job.
 * @returns {Promise&lt;void&gt;} Resolves when the job is completed or retried.
 * @description
 *   - Updates the scraping job status to 'running' at the beginning and 'completed' at the end of the process.
 *   - Performs data scraping and extraction using job's target URL.
 *   - Handles scenarios where a target URL is not specified, resulting in an error.
 *   - Implements retry logic in case of failure during the job processing.
 */
export async function processScrapingJob(jobId) {
    try {
        // Get job details</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/pipeline/scrapingProcessor.js (Line 220:1 - Line 235:2), C:/AI/food-truck-finder-poc/dist/lib/lib/pipeline/scrapingProcessor.js (Line 161:1 - Line 176:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn374" onclick="toggleCodeBlock('cloneGroup374', 'expandBtn374', 'collapseBtn374')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn374" onclick="toggleCodeBlock('cloneGroup374', 'expandBtn374', 'collapseBtn374')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup374"><code class="language-javascript text-sm text-gray-800">export async function createOrUpdateFoodTruck(jobId, extractedTruckData, sourceUrl) {
    try {
        const validation = await validateInputAndPrepare(jobId, extractedTruckData, sourceUrl);
        if (!validation.isValid) {
            return;
        }
        const truckData = buildTruckDataSchema(extractedTruckData, sourceUrl, validation.name);
        const truck = await handleDuplicateCheck(jobId, truckData, validation.name);
        await finalizeJobStatus(jobId, truck, sourceUrl);
    }
    catch (error) {
        const errorMessage = error instanceof Error ? error.message : 'Unknown error';
        console.error(`Job ${jobId}: Error in createOrUpdateFoodTruck from ${sourceUrl ?? 'Unknown Source'}:`, error);
        await handleJobFailure(jobId, `Food truck data processing/saving failed: ${errorMessage}`);
    }
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/pipeline/pipelineHelpers.js (Line 19:1 - Line 28:96), C:/AI/food-truck-finder-poc/dist/lib/lib/pipeline/pipelineHelpers.js (Line 18:1 - Line 26:3)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn375" onclick="toggleCodeBlock('cloneGroup375', 'expandBtn375', 'collapseBtn375')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn375" onclick="toggleCodeBlock('cloneGroup375', 'expandBtn375', 'collapseBtn375')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup375"><code class="language-javascript text-sm text-gray-800">export async function validateInputAndPrepare(jobId, extractedTruckData, sourceUrl) {
    // Basic input validation
    if (!validateTruckData(jobId, extractedTruckData)) {
        await ScrapingJobService.updateJobStatus(jobId, 'failed', {
            errors: ['Invalid extracted data received from AI processing step.'],
        });
        return { isValid: false, name: '' };
    }
    
    // CRITICAL: If name is null, undefined, empty, or &quot;Unknown Food Truck&quot;, discard the truck data</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/pipeline/pipelineHelpers.js (Line 60:1 - Line 94:4), C:/AI/food-truck-finder-poc/dist/lib/lib/pipeline/pipelineHelpers.js (Line 47:1 - Line 81:4)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn376" onclick="toggleCodeBlock('cloneGroup376', 'expandBtn376', 'collapseBtn376')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn376" onclick="toggleCodeBlock('cloneGroup376', 'expandBtn376', 'collapseBtn376')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup376"><code class="language-javascript text-sm text-gray-800">function buildOperatingHours(extractedOperatingHours) {
    if (extractedOperatingHours == undefined) {
        return {
            monday: { closed: true },
            tuesday: { closed: true },
            wednesday: { closed: true },
            thursday: { closed: true },
            friday: { closed: true },
            saturday: { closed: true },
            sunday: { closed: true },
        };
    }
    return {
        monday: extractedOperatingHours.monday ?? { closed: true },
        tuesday: extractedOperatingHours.tuesday ?? { closed: true },
        wednesday: extractedOperatingHours.wednesday ?? { closed: true },
        thursday: extractedOperatingHours.thursday ?? { closed: true },
        friday: extractedOperatingHours.friday ?? { closed: true },
        saturday: extractedOperatingHours.saturday ?? { closed: true },
        sunday: extractedOperatingHours.sunday ?? { closed: true },
    };
}
// New helper function for scheduled locations
/**
 * Transforms and sanitizes an array of scheduled food truck locations.
 * @example
 * buildScheduledLocations([{ lat: 34.05, lng: -118.25, address: &quot;123 Main St&quot;, start_time: &quot;10:00&quot;, end_time: &quot;14:00&quot; }])
 * [{ lat: 34.05, lng: -118.25, address: &quot;123 Main St&quot;, start_time: &quot;10:00&quot;, end_time: &quot;14:00&quot;, timestamp: &quot;2023-10-19T14:00:00.000Z&quot; }]
 * @param {ExtractedFoodTruckDetails['scheduled_locations']} scheduledLocations - Array of scheduled food truck location objects.
 * @returns {Array} Array of sanitized location objects.
 * @description
 *   - Ensures latitude and longitude values are numbers; defaults to 0 if not.
 *   - Adds a current timestamp to each location object in ISO format.
 *   - Uses nullish coalescing to ensure address, start_time, and end_time are either their values or undefined.
 */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/pipeline/pipelineHelpers.js (Line 95:1 - Line 123:4), C:/AI/food-truck-finder-poc/dist/lib/lib/pipeline/pipelineHelpers.js (Line 82:1 - Line 110:4)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn377" onclick="toggleCodeBlock('cloneGroup377', 'expandBtn377', 'collapseBtn377')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn377" onclick="toggleCodeBlock('cloneGroup377', 'expandBtn377', 'collapseBtn377')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup377"><code class="language-javascript text-sm text-gray-800">function buildScheduledLocations(scheduledLocations) {
    if (!Array.isArray(scheduledLocations)) {
        return;
    }
    return scheduledLocations.map((loc) =&gt; ({
        lat: typeof loc.lat === 'number' ? loc.lat : 0,
        lng: typeof loc.lng === 'number' ? loc.lng : 0,
        address: loc.address ?? undefined,
        start_time: loc.start_time ?? undefined,
        end_time: loc.end_time ?? undefined,
        timestamp: new Date().toISOString(),
    }));
}
// Helper function to build truck data schema
/**
 * Constructs a FoodTruckSchema object from extracted food truck details.
 * @example
 * buildTruckDataSchema(extractedTruckData, 'http://sourceUrl.com', 'Truck Name')
 * { name: 'Truck Name', ... }
 * @param {ExtractedFoodTruckDetails} extractedTruckData - Object containing raw data extracted from a food truck resource.
 * @param {string} sourceUrl - URL source where the truck data was extracted from.
 * @param {string} name - Name of the food truck.
 * @returns {FoodTruckSchema} Fully constructed food truck schema ready for use.
 * @description
 *   - Ensures `description` and `price_range` are kept undefined if missing or null from extracted data.
 *   - Filters any non-string values from the `cuisine_type` array.
 *   - Ensures the `source_urls` field is always an array, even if empty or undefined.
 *   - Default verification status is 'pending' and a default data quality score is set to 0.5.
 */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/pipeline/pipelineHelpers.js (Line 128:12 - Line 138:2), C:/AI/food-truck-finder-poc/dist/lib/lib/pipeline/pipelineHelpers.js (Line 115:10 - Line 125:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn378" onclick="toggleCodeBlock('cloneGroup378', 'expandBtn378', 'collapseBtn378')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn378" onclick="toggleCodeBlock('cloneGroup378', 'expandBtn378', 'collapseBtn378')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup378"><code class="language-javascript text-sm text-gray-800">, // Keep as undefined if null/missing
        current_location: currentLocation,
        scheduled_locations: buildScheduledLocations(extractedTruckData.scheduled_locations),
        operating_hours: buildOperatingHours(extractedTruckData.operating_hours),
        menu: processMenuData(extractedTruckData),
        contact_info: buildContactInfo(extractedTruckData.contact_info),
        social_media: buildSocialMedia(extractedTruckData.social_media),
        cuisine_type: Array.isArray(extractedTruckData.cuisine_type)
            ? extractedTruckData.cuisine_type.filter((c) =&gt; typeof c === 'string')
            : [],
        price_range: extractedTruckData.price_range,</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/pipeline/pipelineHelpers.js (Line 138:12 - Line 162:4), C:/AI/food-truck-finder-poc/dist/lib/lib/pipeline/pipelineHelpers.js (Line 125:10 - Line 149:4)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn379" onclick="toggleCodeBlock('cloneGroup379', 'expandBtn379', 'collapseBtn379')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn379" onclick="toggleCodeBlock('cloneGroup379', 'expandBtn379', 'collapseBtn379')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup379"><code class="language-javascript text-sm text-gray-800">, // Ensure it's one of the allowed enum values or undefined
        specialties: Array.isArray(extractedTruckData.specialties)
            ? extractedTruckData.specialties
            : [],
        data_quality_score: 0.5, // Default score - confidence_score not available in type
        verification_status: 'pending',
        source_urls: sourceUrl != undefined &amp;&amp; sourceUrl !== '' ? [sourceUrl] : [], // Ensure source_urls is always an array
        last_scraped_at: new Date().toISOString(),
    };
}
// Helper function to handle duplicate checking and resolution
/**
 * Checks for duplicates before creating a new food truck entry.
 * @example
 * handleDuplicateCheck('12345', truckDataObject, 'Awesome Food Truck')
 * // Returns a promise resolving to the created truck object or result from handling a duplicate.
 * @param {string} jobId - The unique identifier for the job process.
 * @param {FoodTruckSchema} truckData - The data schema representing the food truck details.
 * @param {string} name - The name of the food truck being processed.
 * @returns {Promise&lt;FoodTruck&gt;} Returns a promise that resolves to the created or existing food truck.
 * @description
 *   - Utilizes the DuplicatePreventionService to verify if a similar truck already exists.
 *   - If a duplicate is detected, delegates to a separate function to handle the duplicate scenario.
 *   - Logs errors encountered during the creation process.
 */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/pipeline/pipelineHelpers.js (Line 163:1 - Line 192:4), C:/AI/food-truck-finder-poc/dist/lib/lib/pipeline/pipelineHelpers.js (Line 150:1 - Line 179:4)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn380" onclick="toggleCodeBlock('cloneGroup380', 'expandBtn380', 'collapseBtn380')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn380" onclick="toggleCodeBlock('cloneGroup380', 'expandBtn380', 'collapseBtn380')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup380"><code class="language-javascript text-sm text-gray-800">export async function handleDuplicateCheck(jobId, truckData, name) {
    // Check for duplicates before creating
    console.info(`Job ${jobId}: Checking for duplicates before creating truck: ${name}`);
    const duplicateCheck = await DuplicatePreventionService.checkForDuplicates(truckData);
    if (duplicateCheck.isDuplicate &amp;&amp; duplicateCheck.bestMatch) {
        return await handleDuplicate(jobId, truckData, duplicateCheck);
    }
    // No duplicates found, create new truck
    const truck = await FoodTruckService.createTruck(truckData);
    if ('error' in truck) {
        console.error(`Job ${jobId}: Error creating new truck: ${truck.error}`);
        throw new Error(`Failed to create truck: ${truck.error}`);
    }
    return truck;
}
/**
 * Handles potential duplicate food truck entries by either merging, updating, or creating new truck data.
 * @example
 * handleDuplicate(&quot;job123&quot;, truckData, duplicateCheck)
 * // Returns the processed Food Truck object.
 * @param {string} jobId - Unique identifier for the job processing potential duplicates.
 * @param {FoodTruckSchema} truckData - Data representing the food truck to be processed.
 * @param {DuplicateCheckResult} duplicateCheck - Results from a duplicate check operation.
 * @returns {Promise&lt;FoodTruck&gt;} Returns a promise that resolves to a Food Truck object if successful.
 * @description
 *   - Uses duplicate check results to determine whether to merge, update, or create new truck data.
 *   - Logs information about the operation performed and potential duplicates found.
 *   - Contains error handling for each operation, including fallback creations in case of failures.
 *   - Provides warnings when creating new entries despite finding possible duplicates.
 */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/pipeline/pipelineHelpers.js (Line 200:9 - Line 260:3), C:/AI/food-truck-finder-poc/dist/lib/lib/pipeline/pipelineHelpers.js (Line 184:9 - Line 243:3)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn381" onclick="toggleCodeBlock('cloneGroup381', 'expandBtn381', 'collapseBtn381')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn381" onclick="toggleCodeBlock('cloneGroup381', 'expandBtn381', 'collapseBtn381')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup381"><code class="language-javascript text-sm text-gray-800">const truck = await FoodTruckService.createTruck(truckData);
        if ('error' in truck) {
            throw new Error(`Failed to create truck: ${truck.error}`);
        }
        return truck;
    }

    console.info(`Job ${jobId}: Found potential duplicate (${Math.round(bestMatch.similarity * 100)}% similarity) with truck: ${bestMatch.existingTruck.name}`);
    if (bestMatch.confidence === 'high' &amp;&amp; bestMatch.recommendation === 'merge') {
        const truck = await DuplicatePreventionService.mergeDuplicates(bestMatch.existingTruck.id, bestMatch.existingTruck.id);
        if ('error' in truck) {
            console.error(`Job ${jobId}: Error merging duplicates: ${truck.error}`);
            const newTruck = await FoodTruckService.createTruck(truckData);
            if ('error' in newTruck) {
                console.error(`Job ${jobId}: Error creating truck after merge failure: ${newTruck.error}`);
                throw new Error(`Failed to merge or create truck: ${newTruck.error}`);
            }
            return newTruck;
        }
        console.info(`Job ${jobId}: Merged data with existing truck: ${truck.name} (ID: ${truck.id})`);
        return truck;
    }
    else if (bestMatch.recommendation === 'update') {
        const truck = await FoodTruckService.updateTruck(bestMatch.existingTruck.id, truckData);
        if ('error' in truck) {
            console.error(`Job ${jobId}: Error updating existing truck: ${truck.error}`);
            const newTruck = await FoodTruckService.createTruck(truckData);
            if ('error' in newTruck) {
                console.error(`Job ${jobId}: Error creating truck after update failure: ${newTruck.error}`);
                throw new Error(`Failed to update or create truck: ${newTruck.error}`);
            }
            return newTruck;
        }
        console.info(`Job ${jobId}: Updated existing truck: ${truck.name} (ID: ${truck.id})`);
        return truck;
    }
    else {
        const truck = await FoodTruckService.createTruck(truckData);
        if ('error' in truck) {
            console.error(`Job ${jobId}: Error creating truck despite potential duplicate: ${truck.error}`);
            throw new Error(`Failed to create truck: ${truck.error}`);
        }
        console.warn(`Job ${jobId}: Created new truck despite potential duplicate (${duplicateCheck.reason ?? 'unknown reason'})`);
        return truck;
    }
}
// Helper function to finalize job status
/**
* Logs the successful creation of a food truck and updates the job status to completed.
* @example
* finalizeJobStatus('12345', { name: 'Best Food Truck', id: 'FT123' }, 'http://example.com')
* // Logs: Job 12345: Successfully created food truck: Best Food Truck (ID: FT123) from http://example.com
* @param {string} jobId - Unique identifier of the scraping job.
* @param {FoodTruck} truck - Object representing the food truck that was created.
* @param {string} sourceUrl - URL from where the data was sourced.
* @returns {Promise&lt;void&gt;} Resolves when the job status is updated.
* @description
*   - Logs the truck creation event using `console.info`.
*   - Ensures the job status is set to 'completed' with the current timestamp.
*   - Uses a default source message if sourceUrl is not provided.
*/</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/pipeline/pipelineHelpers.js (Line 261:1 - Line 304:4), C:/AI/food-truck-finder-poc/dist/lib/lib/pipeline/pipelineHelpers.js (Line 244:1 - Line 287:4)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn382" onclick="toggleCodeBlock('cloneGroup382', 'expandBtn382', 'collapseBtn382')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn382" onclick="toggleCodeBlock('cloneGroup382', 'expandBtn382', 'collapseBtn382')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup382"><code class="language-javascript text-sm text-gray-800">export async function finalizeJobStatus(jobId, truck, sourceUrl) {
    console.info(`Job ${jobId}: Successfully created food truck: ${truck.name} (ID: ${truck.id}) from ${sourceUrl ?? 'Unknown Source'}`);
    // Link truck_id back to the scraping job
    await ScrapingJobService.updateJobStatus(jobId, 'completed', {
        completed_at: new Date().toISOString(),
    });
}
// Helper function to validate input data
function validateTruckData(jobId, extractedTruckData) {
    if (extractedTruckData == undefined || typeof extractedTruckData !== 'object') {
        console.error(`Job ${jobId}: Invalid extractedTruckData, cannot create/update food truck.`);
        return false;
    }
    return true;
}
// Helper function to build location data
/**
 * Constructs location data from extracted truck details.
 * @example
 * buildLocationData({
 *   current_location: {
 *     address: &quot;123 Example St&quot;,
 *     city: &quot;Sample City&quot;,
 *     state: &quot;SC&quot;,
 *     zip_code: &quot;12345&quot;,
 *     lat: 34.05,
 *     lng: -118.25,
 *     raw_text: &quot;Raw Location Data&quot;
 *   }
 * })
 * // Returns: {
 * //   lat: 34.05,
 * //   lng: -118.25,
 * //   address: &quot;123 Example St, Sample City, SC, 12345&quot;,
 * //   timestamp: &quot;2023-09-15T14:38:00.000Z&quot;
 * // }
 * @param {ExtractedFoodTruckDetails} extractedTruckData - Details of the food truck, including its current location.
 * @returns {Object} Location data comprising latitude, longitude, formatted address, and current timestamp.
 * @description
 *   - Constructs a full address by combining address components.
 *   - Defaults latitude and longitude to 0 if not provided as numbers.
 *   - Uses raw text as address if address components are missing.
 *   - Generates an ISO 8601 timestamp for the current date and time.
 */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/pipeline/pipelineHelpers.js (Line 305:1 - Line 318:13), C:/AI/food-truck-finder-poc/dist/lib/lib/pipeline/pipelineHelpers.js (Line 288:1 - Line 301:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn383" onclick="toggleCodeBlock('cloneGroup383', 'expandBtn383', 'collapseBtn383')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn383" onclick="toggleCodeBlock('cloneGroup383', 'expandBtn383', 'collapseBtn383')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup383"><code class="language-javascript text-sm text-gray-800">function buildLocationData(extractedTruckData) {
    const locationData = extractedTruckData.current_location ?? {};
    const fullAddress = [
        locationData.address,
        locationData.city,
        locationData.state,
        locationData.zip_code,
    ]
        .filter(Boolean)
        .join(', ');
    return {
        lat: typeof locationData.lat === 'number' ? locationData.lat : 0,
        lng: typeof locationData.lng === 'number' ? locationData.lng : 0,
        address: fullAddress || locationData</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/pipeline/pipelineHelpers.js (Line 337:5 - Line 365:4), C:/AI/food-truck-finder-poc/dist/lib/lib/pipeline/pipelineHelpers.js (Line 320:10 - Line 348:4)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn384" onclick="toggleCodeBlock('cloneGroup384', 'expandBtn384', 'collapseBtn384')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn384" onclick="toggleCodeBlock('cloneGroup384', 'expandBtn384', 'collapseBtn384')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup384"><code class="language-javascript text-sm text-gray-800">,
    };
}
// Type guard for RawMenuCategory
function isRawMenuCategory(obj) {
    return (typeof obj === 'object' &amp;&amp;
        obj != undefined &amp;&amp;
        ('category' in obj || 'name' in obj || 'items' in obj));
}
// Type guard for RawMenuItem
function isRawMenuItem(obj) {
    return (typeof obj === 'object' &amp;&amp;
        obj != undefined &amp;&amp;
        ('name' in obj || 'description' in obj || 'price' in obj || 'dietary_tags' in obj));
}
// Helper function to process menu data
/**
 * Processes extracted food truck data into structured menu categories.
 * @example
 * processMenuData(sample_truck_data)
 * [ { name: 'Uncategorized', items: [{ name: 'Pizza', description: 'Cheese Pizza', price: 9.99, dietary_tags: ['vegetarian'] }] } ]
 * @param {ExtractedFoodTruckDetails} extractedTruckData - The extracted food truck data.
 * @returns {MenuCategory[]} Array of structured menu categories.
 * @description
 *   - Validates categories and items before mapping to a structured format.
 *   - Converts item price to number and handles invalid input gracefully.
 *   - Provides default values for category and item names in the case of invalid data.
 *   - Logs warnings for encountered invalid category or item data.
 */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/pipeline/pipelineHelpers.js (Line 366:1 - Line 380:13), C:/AI/food-truck-finder-poc/dist/lib/lib/pipeline/pipelineHelpers.js (Line 349:1 - Line 363:12)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn385" onclick="toggleCodeBlock('cloneGroup385', 'expandBtn385', 'collapseBtn385')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn385" onclick="toggleCodeBlock('cloneGroup385', 'expandBtn385', 'collapseBtn385')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup385"><code class="language-javascript text-sm text-gray-800">function processMenuData(extractedTruckData) {
    if (!Array.isArray(extractedTruckData.menu)) {
        return [];
    }
    return extractedTruckData.menu.map((category) =&gt; {
        if (!isRawMenuCategory(category)) {
            console.warn('Invalid category data encountered:', category);
            return { name: 'Invalid Category', items: [] };
        }
        const items = (Array.isArray(category.items) ? category.items : []).map((item) =&gt; {
            if (!isRawMenuItem(item)) {
                console.warn('Invalid item data encountered:', item);
                return {
                    name: 'Invalid Item',
                    dietary_tags</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/pipeline/pipelineHelpers.js (Line 383:6 - Line 395:2), C:/AI/food-truck-finder-poc/dist/lib/lib/pipeline/pipelineHelpers.js (Line 368:10 - Line 380:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn386" onclick="toggleCodeBlock('cloneGroup386', 'expandBtn386', 'collapseBtn386')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn386" onclick="toggleCodeBlock('cloneGroup386', 'expandBtn386', 'collapseBtn386')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup386"><code class="language-javascript text-sm text-gray-800">;
            if (typeof item.price === 'number') {
                price = item.price;
            }
            else if (typeof item.price === 'string') {
                const parsedPrice = Number.parseFloat(item.price.replaceAll(/[^\d.-]/g, ''));
                if (!Number.isNaN(parsedPrice)) {
                    price = parsedPrice;
                }
            }
            return {
                name: item.name ?? 'Unknown Item',
                description: item.description,</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/pipeline/pipelineHelpers.js (Line 395:12 - Line 405:2), C:/AI/food-truck-finder-poc/dist/lib/lib/pipeline/pipelineHelpers.js (Line 380:10 - Line 390:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn387" onclick="toggleCodeBlock('cloneGroup387', 'expandBtn387', 'collapseBtn387')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn387" onclick="toggleCodeBlock('cloneGroup387', 'expandBtn387', 'collapseBtn387')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup387"><code class="language-javascript text-sm text-gray-800">,
                price: price,
                dietary_tags: Array.isArray(item.dietary_tags) ? item.dietary_tags : [],
            };
        });
        return {
            name: category.category ?? category.name ?? 'Uncategorized',
            items: items,
        };
    });
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/performance/webVitals.js (Line 1:1 - Line 374:2), C:/AI/food-truck-finder-poc/dist/lib/lib/performance/webVitals.js (Line 1:1 - Line 374:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn388" onclick="toggleCodeBlock('cloneGroup388', 'expandBtn388', 'collapseBtn388')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn388" onclick="toggleCodeBlock('cloneGroup388', 'expandBtn388', 'collapseBtn388')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup388"><code class="language-javascript text-sm text-gray-800">/**
 * SOTA Core Web Vitals Monitoring Implementation
 * Tracks LCP, FID, CLS, FCP, and TTFB metrics for performance optimization
 */
import { getCLS, getFCP, getFID, getLCP, getTTFB } from 'web-vitals';
// Performance thresholds based on Google's Core Web Vitals standards
export const PERFORMANCE_THRESHOLDS = {
    LCP: { good: 2500, needsImprovement: 4000 }, // Largest Contentful Paint
    FID: { good: 100, needsImprovement: 300 }, // First Input Delay
    CLS: { good: 0.1, needsImprovement: 0.25 }, // Cumulative Layout Shift
    FCP: { good: 1800, needsImprovement: 3000 }, // First Contentful Paint
    TTFB: { good: 800, needsImprovement: 1800 }, // Time to First Byte
};
// In-memory storage for metrics (in production, send to analytics service)
const metricsStore = [];
/**
 * Categorizes metric value based on thresholds
 */
function getRating(name, value) {
    const thresholds = PERFORMANCE_THRESHOLDS[name];
    if (value &lt;= thresholds.good)
        return 'good';
    if (value &lt;= thresholds.needsImprovement)
        return 'needs-improvement';
    return 'poor';
}
/**
 * Processes and stores a web vital metric
 */
function handleMetric(metric) {
    // Type-safe casting with validation
    const metricName = String(metric.name);
    const metricValue = Number(metric.value);
    const performanceMetric = {
        name: metricName,
        value: metricValue,
        rating: getRating(metricName, metricValue),
        timestamp: Date.now(),
        url: globalThis.location.href,
        userAgent: navigator.userAgent,
    };
    // Store metric locally
    metricsStore.push(performanceMetric);
    // Send to analytics endpoint (non-blocking)
    sendMetricToAnalytics(performanceMetric).catch((error) =&gt; {
        console.warn('Failed to send metric to analytics:', error);
    });
    // Log performance issues
    if (performanceMetric.rating === 'poor') {
        console.warn(`Poor ${metricName} performance:`, {
            value: metricValue,
            threshold: PERFORMANCE_THRESHOLDS[metricName],
            url: performanceMetric.url,
        });
    }
}
/**
 * Sends metric data to analytics endpoint
 */
async function sendMetricToAnalytics(metric) {
    try {
        await fetch('/api/analytics/web-vitals', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(metric),
        });
    }
    catch (error) {
        // Silently fail - don't impact user experience
        console.info('Analytics endpoint unavailable:', error);
    }
}
/**
 * Initializes Core Web Vitals monitoring
 * Call this in your app's root component or _app.tsx
 */
export function initWebVitalsMonitoring() {
    try {
        // Type-safe metric handlers with explicit casting
        const safeHandleMetric = (metric) =&gt; handleMetric(metric);
        getCLS(safeHandleMetric);
        getFCP(safeHandleMetric);
        getFID(safeHandleMetric);
        getLCP(safeHandleMetric);
        getTTFB(safeHandleMetric);
    }
    catch (error) {
        console.warn('Failed to initialize web vitals monitoring:', error);
    }
}
/**
 * Gets current performance metrics summary
 */
export function getPerformanceMetrics() {
    const summary = {};
    // Initialize summary for all metrics
    for (const metricName of Object.keys(PERFORMANCE_THRESHOLDS)) {
        const name = metricName;
        const metricData = metricsStore.filter((m) =&gt; m.name === name);
        if (metricData.length === 0) {
            summary[name] = {
                latest: null,
                average: 0,
                rating: 'no-data',
                count: 0,
            };
        }
        else {
            const latest = metricData.at(-1);
            const average = metricData.reduce((sum, m) =&gt; sum + m.value, 0) / metricData.length;
            summary[name] = {
                latest: latest?.value ?? null,
                average: Math.round(average),
                rating: getRating(name, average),
                count: metricData.length,
            };
        }
    }
    return {
        metrics: [...metricsStore],
        summary,
    };
}
/**
 * Performance budget checker
 */
export function checkPerformanceBudget() {
    const { summary } = getPerformanceMetrics();
    const violations = [];
    for (const [metricName, data] of Object.entries(summary)) {
        const name = metricName;
        if (data.latest == undefined)
            continue;
        const thresholds = PERFORMANCE_THRESHOLDS[name];
        if (data.latest &gt; thresholds.needsImprovement) {
            violations.push({
                metric: name,
                value: data.latest,
                threshold: thresholds.needsImprovement,
                severity: 'critical',
            });
        }
        else if (data.latest &gt; thresholds.good) {
            violations.push({
                metric: name,
                value: data.latest,
                threshold: thresholds.good,
                severity: 'warning',
            });
        }
    }
    return {
        passed: violations.length === 0,
        violations,
    };
}
/**
 * Generates a list of suggestions to improve Largest Contentful Paint (LCP).
 * @example
 * getLCPSuggestions({ latest: 3000 })
 * Returns an array with LCP improvement suggestions when the latest LCP is 3000ms.
 * @param {Object} data - Contains performance metrics data.
 * @param {number|null} data.latest - The latest LCP measure in milliseconds.
 * @returns {PerformanceSuggestion[]} An array of performance suggestions for optimizing LCP.
 * @description
 *   - The function assumes the LCP target is less than 2500ms.
 *   - Suggestions focus on optimizing various aspects like image loading, server response, and resource preloading.
 */
function getLCPSuggestions(data) {
    return [
        {
            metric: 'LCP',
            issue: `Largest Contentful Paint is ${data.latest}ms (target: &lt;2500ms)`,
            suggestions: [
                'Optimize images with Next.js Image component',
                'Implement lazy loading for non-critical content',
                'Use CDN for static assets',
                'Optimize server response times',
                'Preload critical resources',
            ],
            priority: 'high',
        },
    ];
}
/**
 * Generates suggestions to improve First Input Delay (FID) performance.
 * @example
 * getFIDSuggestions({ latest: 150 })
 * [
 *   {
 *     metric: 'FID',
 *     issue: 'First Input Delay is 150ms (target: &lt;100ms)',
 *     suggestions: [
 *       'Reduce JavaScript bundle size',
 *       'Implement code splitting',
 *       'Use web workers for heavy computations',
 *       'Optimize third-party scripts',
 *       'Defer non-critical JavaScript',
 *     ],
 *     priority: 'high',
 *   },
 * ]
 * @param {Object} data - Contains the latest FID measurement.
 * @param {number|null} data.latest - The latest FID metric value.
 * @returns {PerformanceSuggestion[]} A list of suggestions to improve FID.
 * @description
 *   - Suggests actionable improvements if FID exceeds target threshold.
 *   - Provides solutions focusing on JS optimizations.
 */
function getFIDSuggestions(data) {
    return [
        {
            metric: 'FID',
            issue: `First Input Delay is ${data.latest}ms (target: &lt;100ms)`,
            suggestions: [
                'Reduce JavaScript bundle size',
                'Implement code splitting',
                'Use web workers for heavy computations',
                'Optimize third-party scripts',
                'Defer non-critical JavaScript',
            ],
            priority: 'high',
        },
    ];
}
/**
 * Generates performance suggestions based on Cumulative Layout Shift (CLS) data.
 * @example
 * getCLSSuggestions({ latest: 0.25 })
 * // Returns array of suggestions indicating the CLS value and recommendations on improving it.
 * @param {{ latest: number | null }} data - Object containing the latest CLS measurement.
 * @returns {PerformanceSuggestion[]} An array of performance suggestions to address CLS issues.
 * @description
 *   - Suggests best practices to reduce CLS, aiming for a value below 0.1.
 *   - Prioritizes medium concern for updates that could improve visual stability.
 *   - Incorporates practical strategies for developers focusing on layout changes.
 */
function getCLSSuggestions(data) {
    return [
        {
            metric: 'CLS',
            issue: `Cumulative Layout Shift is ${data.latest} (target: &lt;0.1)`,
            suggestions: [
                'Set explicit dimensions for images and videos',
                'Reserve space for dynamic content',
                'Use CSS aspect-ratio for responsive images',
                'Avoid inserting content above existing content',
                'Use transform animations instead of layout changes',
            ],
            priority: 'medium',
        },
    ];
}
/**
* Generates suggestions to improve the First Contentful Paint performance metric.
* @example
* getFCPSuggestions({ latest: 2000 })
* Returns an array with suggestions to optimize FCP targeting &lt;1800ms.
* @param {Object} data - Contains performance metric values.
* @param {number|null} data.latest - Latest measured FCP value in milliseconds.
* @returns {PerformanceSuggestion[]} Array of suggestions for improving FCP metric.
* @description
*   - Suggests optimizations related to the rendering path and resource loading.
*   - Provides actions with a medium priority level to improve website performance.
*/
function getFCPSuggestions(data) {
    return [
        {
            metric: 'FCP',
            issue: `First Contentful Paint is ${data.latest}ms (target: &lt;1800ms)`,
            suggestions: [
                'Optimize critical rendering path',
                'Inline critical CSS',
                'Minimize render-blocking resources',
                'Use resource hints (preload, prefetch)',
                'Optimize web fonts loading',
            ],
            priority: 'medium',
        },
    ];
}
/**
 * Generates suggestions to improve Time to First Byte (TTFB) performance based on the latest measurement.
 * @example
 * getTTFBSuggestions({ latest: 950 })
 * [
 *   {
 *     metric: 'TTFB',
 *     issue: 'Time to First Byte is 950ms (target: &lt;800ms)',
 *     suggestions: [
 *       'Optimize server response times',
 *       'Use CDN for global distribution',
 *       'Implement server-side caching',
 *       'Optimize database queries',
 *       'Use edge computing for dynamic content'
 *     ],
 *     priority: 'high'
 *   }
 * ]
 * @param {Object} data - An object containing the latest TTFB measurement.
 * @param {number|null} data.latest - The latest TTFB value in milliseconds or null if not available.
 * @returns {PerformanceSuggestion[]} An array containing performance improvement suggestions for TTFB.
 * @description
 *   - The function assumes a target TTFB of under 800ms.
 *   - Generates a high-priority performance suggestion report.
 */
function getTTFBSuggestions(data) {
    return [
        {
            metric: 'TTFB',
            issue: `Time to First Byte is ${data.latest}ms (target: &lt;800ms)`,
            suggestions: [
                'Optimize server response times',
                'Use CDN for global distribution',
                'Implement server-side caching',
                'Optimize database queries',
                'Use edge computing for dynamic content',
            ],
            priority: 'high',
        },
    ];
}
/**
 * Generates a list of performance optimization suggestions based on Web Vitals metrics.
 * @example
 * getPerformanceOptimizationSuggestions()
 * [
 *   { name: 'Optimize LCP', priority: 'high' },
 *   { name: 'Improve FID', priority: 'medium' }
 * ]
 * @returns {PerformanceSuggestion[]} An array of performance suggestions sorted by priority.
 * @description
 *   - Analyzes performance metrics including LCP, FID, CLS, FCP, and TTFB.
 *   - Generates suggestions only for metrics rated as 'poor' or 'needs-improvement'.
 *   - Prioritizes suggestions based on urgency, sorting them by priority level.
 *   - Utilizes helper functions to generate specific suggestions for each metric type.
 */
export function getPerformanceOptimizationSuggestions() {
    const { summary } = getPerformanceMetrics();
    let allSuggestions = [];
    for (const [metricName, data] of Object.entries(summary)) {
        const name = metricName;
        if (data.rating === 'poor' || data.rating === 'needs-improvement') {
            switch (name) {
                case 'LCP': {
                    allSuggestions = [...allSuggestions, ...getLCPSuggestions(data)];
                    break;
                }
                case 'FID': {
                    allSuggestions = [...allSuggestions, ...getFIDSuggestions(data)];
                    break;
                }
                case 'CLS': {
                    allSuggestions = [...allSuggestions, ...getCLSSuggestions(data)];
                    break;
                }
                case 'FCP': {
                    allSuggestions = [...allSuggestions, ...getFCPSuggestions(data)];
                    break;
                }
                case 'TTFB': {
                    allSuggestions = [...allSuggestions, ...getTTFBSuggestions(data)];
                    break;
                }
            }
        }
    }
    return allSuggestions.sort((a, b) =&gt; {
        const priorityOrder = { high: 3, medium: 2, low: 1 };
        return priorityOrder[b.priority] - priorityOrder[a.priority];
    });
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/performance/databaseCache.js (Line 24:5 - Line 38:8), C:/AI/food-truck-finder-poc/dist/lib/lib/performance/databaseCache.js (Line 24:5 - Line 38:8)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn389" onclick="toggleCodeBlock('cloneGroup389', 'expandBtn389', 'collapseBtn389')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn389" onclick="toggleCodeBlock('cloneGroup389', 'expandBtn389', 'collapseBtn389')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup389"><code class="language-javascript text-sm text-gray-800">getAllTrucksCached: unstable_cache(async () =&gt; {
        console.info('CachedFoodTruckService: Cache miss - fetching all trucks from database');
        const result = await FoodTruckService.getAllTrucks();
        if ('error' in result) {
            throw new Error(`Failed to fetch all trucks: ${result.error}`);
        }
        return { trucks: result.trucks, count: result.total };
    }, ['all-trucks'], {
        revalidate: CACHE_CONFIG.MEDIUM_TTL,
        tags: ['food-trucks', 'all-trucks'],
    }),
    /**
     * Get trucks by location with caching
     * Cache for 5 minutes since location-based queries are time-sensitive
     */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/performance/databaseCache.js (Line 39:5 - Line 53:8), C:/AI/food-truck-finder-poc/dist/lib/lib/performance/databaseCache.js (Line 39:5 - Line 53:8)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn390" onclick="toggleCodeBlock('cloneGroup390', 'expandBtn390', 'collapseBtn390')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn390" onclick="toggleCodeBlock('cloneGroup390', 'expandBtn390', 'collapseBtn390')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup390"><code class="language-javascript text-sm text-gray-800">getTrucksByLocationCached: unstable_cache(async (lat, lng, radiusKm) =&gt; {
        console.info(`CachedFoodTruckService: Cache miss - fetching trucks near ${lat},${lng} (${radiusKm}km)`);
        const result = await FoodTruckService.getTrucksByLocation(lat, lng, radiusKm);
        if ('error' in result) {
            throw new Error(`Failed to fetch trucks by location: ${result.error}`);
        }
        return result;
    }, ['trucks-by-location'], {
        revalidate: CACHE_CONFIG.SHORT_TTL,
        tags: ['food-trucks', 'location-search'],
    }),
    /**
     * Get truck by ID with caching
     * Cache for 30 minutes since individual truck data is relatively stable
     */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/performance/databaseCache.js (Line 54:5 - Line 68:8), C:/AI/food-truck-finder-poc/dist/lib/lib/performance/databaseCache.js (Line 54:5 - Line 68:8)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn391" onclick="toggleCodeBlock('cloneGroup391', 'expandBtn391', 'collapseBtn391')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn391" onclick="toggleCodeBlock('cloneGroup391', 'expandBtn391', 'collapseBtn391')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup391"><code class="language-javascript text-sm text-gray-800">getTruckByIdCached: unstable_cache(async (id) =&gt; {
        console.info(`CachedFoodTruckService: Cache miss - fetching truck ${id} from database`);
        const result = await FoodTruckService.getTruckById(id);
        if ('error' in result) {
            return null;
        }
        return result;
    }, ['truck-by-id'], {
        revalidate: CACHE_CONFIG.MEDIUM_TTL,
        tags: ['food-trucks', 'truck-details'],
    }),
    /**
     * Search trucks with caching
     * Cache for 5 minutes since search results should be relatively fresh
     */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/performance/databaseCache.js (Line 69:5 - Line 124:8), C:/AI/food-truck-finder-poc/dist/lib/lib/performance/databaseCache.js (Line 69:5 - Line 124:8)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn392" onclick="toggleCodeBlock('cloneGroup392', 'expandBtn392', 'collapseBtn392')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn392" onclick="toggleCodeBlock('cloneGroup392', 'expandBtn392', 'collapseBtn392')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup392"><code class="language-javascript text-sm text-gray-800">searchTrucksCached: unstable_cache(async (query, filters) =&gt; {
        console.info(`CachedFoodTruckService: Cache miss - searching trucks for &quot;${query}&quot;`);
        if (supabaseAdmin == undefined) {
            throw new Error('Supabase admin client not available');
        }
        let dbQuery = supabaseAdmin
            .from('food_trucks')
            .select('*')
            .or(`name.ilike.%${query}%,description.ilike.%${query}%,cuisine_type.cs.{${query}}`);
        // Apply filters
        if (filters?.cuisine != undefined &amp;&amp; filters.cuisine !== '') {
            dbQuery = dbQuery.contains('cuisine_type', [filters.cuisine]);
        }
        const { data, error } = await dbQuery.limit(50);
        const trucks = data ?? [];
        if (error != undefined) {
            const errorMessage = error instanceof Error ? error.message : JSON.stringify(error);
            throw new Error(`Search query failed: ${errorMessage}`);
        }
        let results = trucks ?? [];
        // Apply location filter if provided
        if (filters?.lat != undefined &amp;&amp; filters?.lng != undefined &amp;&amp; filters?.radius != undefined) {
            results = results.filter((truck) =&gt; {
                if (truck.current_location?.lat == undefined ||
                    truck.current_location?.lng == undefined) {
                    return false;
                }
                const distance = calculateDistance(filters.lat, // Assert as number, as it's checked by the outer if condition
                filters.lng, // Assert as number, as it's checked by the outer if condition
                truck.current_location.lat, truck.current_location.lng);
                return distance &lt;= (filters.radius ?? 10);
            });
        }
        // Apply openNow filter if provided
        if (filters?.openNow === true) {
            const now = new Date();
            const currentDay = now.toLocaleDateString('en-US', { weekday: 'short' }).toLowerCase(); // 'mon', 'tue', etc.
            const currentTime = now.getHours() * 100 + now.getMinutes(); // HHMM format
            results = results.filter((truck) =&gt; {
                const hours = truck.operating_hours?.[currentDay];
                if (hours == undefined || hours.closed === true)
                    return false;
                const openTime = parseTimeString(hours.open ?? '');
                const closeTime = parseTimeString(hours.close ?? '');
                return currentTime &gt;= openTime &amp;&amp; currentTime &lt;= closeTime;
            });
        }
        return results;
    }, ['search-trucks'], {
        revalidate: CACHE_CONFIG.SHORT_TTL,
        tags: ['food-trucks', 'search'],
    }),
    /**
     * Get data quality statistics with caching
     * Cache for 24 hours since quality stats change slowly
     */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/performance/databaseCache.js (Line 125:5 - Line 159:4), C:/AI/food-truck-finder-poc/dist/lib/lib/performance/databaseCache.js (Line 125:5 - Line 159:4)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn393" onclick="toggleCodeBlock('cloneGroup393', 'expandBtn393', 'collapseBtn393')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn393" onclick="toggleCodeBlock('cloneGroup393', 'expandBtn393', 'collapseBtn393')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup393"><code class="language-javascript text-sm text-gray-800">getDataQualityStatsCached: unstable_cache(async () =&gt; {
        console.info('CachedFoodTruckService: Cache miss - calculating data quality stats');
        if (supabaseAdmin == undefined) {
            throw new Error('Supabase admin client not available');
        }
        const { data: trucks, error } = await supabaseAdmin
            .from('food_trucks')
            .select('data_quality_score');
        if (error) {
            throw new Error(`Quality stats query failed: ${error.message}`);
        }
        const scores = trucks == undefined
            ? []
            : trucks.map((t) =&gt; t.data_quality_score ?? 0);
        const averageScore = scores.length &gt; 0
            ? scores.reduce((sum, score) =&gt; sum + score, 0) / scores.length
            : 0;
        const distribution = {
            high: scores.filter((s) =&gt; s &gt;= 0.8).length,
            medium: scores.filter((s) =&gt; s &gt;= 0.6 &amp;&amp; s &lt; 0.8).length,
            low: scores.filter((s) =&gt; s &lt; 0.6).length,
        };
        return {
            averageScore: Math.round(averageScore * 100) / 100,
            distribution,
            totalTrucks: scores.length,
        };
    }, ['data-quality-stats'], {
        revalidate: CACHE_CONFIG.LONG_TTL,
        tags: ['food-trucks', 'data-quality'],
    }),
};
/**
 * Cache invalidation utilities
 */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/performance/databaseCache.js (Line 177:5 - Line 190:8), C:/AI/food-truck-finder-poc/dist/lib/lib/performance/databaseCache.js (Line 177:5 - Line 190:8)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn394" onclick="toggleCodeBlock('cloneGroup394', 'expandBtn394', 'collapseBtn394')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn394" onclick="toggleCodeBlock('cloneGroup394', 'expandBtn394', 'collapseBtn394')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup394"><code class="language-javascript text-sm text-gray-800">async invalidateTruckCache(truckId) {
        try {
            const { revalidateTag } = await import('next/cache');
            revalidateTag(`truck-${truckId}`);
            revalidateTag('food-trucks'); // Also invalidate general caches
            console.info(`CacheManager: Invalidated cache for truck ${truckId}`);
        }
        catch (error) {
            console.warn('CacheManager: Failed to invalidate truck cache:', error);
        }
    },
    /**
     * Invalidate search and location caches
     */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/performance/databaseCache.js (Line 191:5 - Line 205:4), C:/AI/food-truck-finder-poc/dist/lib/lib/performance/databaseCache.js (Line 191:5 - Line 205:4)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn395" onclick="toggleCodeBlock('cloneGroup395', 'expandBtn395', 'collapseBtn395')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn395" onclick="toggleCodeBlock('cloneGroup395', 'expandBtn395', 'collapseBtn395')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup395"><code class="language-javascript text-sm text-gray-800">async invalidateSearchCaches() {
        try {
            const { revalidateTag } = await import('next/cache');
            revalidateTag('search');
            revalidateTag('location-search');
            console.info('CacheManager: Invalidated search caches');
        }
        catch (error) {
            console.warn('CacheManager: Failed to invalidate search caches:', error);
        }
    },
};
/**
 * Utility functions
 */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/performance/databaseCache.js (Line 206:1 - Line 223:2), C:/AI/food-truck-finder-poc/dist/lib/lib/performance/databaseCache.js (Line 206:1 - Line 223:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn396" onclick="toggleCodeBlock('cloneGroup396', 'expandBtn396', 'collapseBtn396')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn396" onclick="toggleCodeBlock('cloneGroup396', 'expandBtn396', 'collapseBtn396')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup396"><code class="language-javascript text-sm text-gray-800">function calculateDistance(lat1, lng1, lat2, lng2) {
    const R = 6371; // Earth's radius in kilometers
    const dLat = ((lat2 - lat1) * Math.PI) / 180;
    const dLng = ((lng2 - lng1) * Math.PI) / 180;
    const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
        Math.cos((lat1 * Math.PI) / 180) *
            Math.cos((lat2 * Math.PI) / 180) *
            Math.sin(dLng / 2) *
            Math.sin(dLng / 2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    return R * c;
}
function parseTimeString(timeStr) {
    if (timeStr == undefined || timeStr === '')
        return 0;
    const [hours, minutes] = timeStr.split(':').map(Number);
    return hours * 100 + (minutes ?? 0);
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/performance/bundleAnalyzer.js (Line 1:1 - Line 166:2), C:/AI/food-truck-finder-poc/dist/lib/performance/bundleAnalyzer.js (Line 1:1 - Line 166:6)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn397" onclick="toggleCodeBlock('cloneGroup397', 'expandBtn397', 'collapseBtn397')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn397" onclick="toggleCodeBlock('cloneGroup397', 'expandBtn397', 'collapseBtn397')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup397"><code class="language-javascript text-sm text-gray-800">/**
 * Bundle Size Analysis and Optimization Utilities
 * Provides insights and recommendations for bundle optimization
 */
import React from 'react';
/**
 * Bundle optimization recommendations based on analysis
 */
export function getBundleOptimizationRecommendations() {
    const recommendations = [
        // Code splitting recommendations
        'Implement dynamic imports for admin dashboard components',
        'Split authentication components into separate chunks',
        'Lazy load chart components (Recharts) only when needed',
        // Tree shaking recommendations
        'Use named imports instead of default imports for UI libraries',
        'Remove unused Lucide React icons',
        'Optimize Radix UI imports to only include used components',
        // External dependencies optimization
        'Consider replacing Recharts with a lighter charting library for simple charts',
        'Use Next.js Image component instead of external image libraries',
        'Minimize Supabase client bundle size by importing only needed functions',
        // Performance optimizations
        'Enable gzip compression in production',
        'Use Next.js bundle analyzer to identify large dependencies',
        'Implement service worker for caching static assets',
        // Modern JavaScript features
        'Use ES2020+ features for smaller bundle sizes',
        'Enable Next.js experimental optimizePackageImports',
        'Consider using SWC minification for better performance',
    ];
    return recommendations;
}
export const PERFORMANCE_BUDGETS = {
    maxBundleSize: 500, // 500KB total bundle
    maxChunkSize: 200, // 200KB per chunk
    maxInitialLoad: 300, // 300KB initial load
    maxAssetSize: 100, // 100KB per asset
};
/**
 * Check if bundle meets performance budgets
 */
export function checkPerformanceBudget(analysis) {
    const violations = [];
    // Check total bundle size
    if (analysis.totalSize != undefined &amp;&amp;
        analysis.totalSize &gt; PERFORMANCE_BUDGETS.maxBundleSize * 1024) {
        violations.push({
            metric: 'Total Bundle Size',
            actual: Math.round(analysis.totalSize / 1024),
            budget: PERFORMANCE_BUDGETS.maxBundleSize,
            severity: 'error',
        });
    }
    // Check individual chunk sizes
    if (analysis.chunks) {
        for (const chunk of analysis.chunks) {
            if (chunk.size &gt; PERFORMANCE_BUDGETS.maxChunkSize * 1024) {
                violations.push({
                    metric: `Chunk Size (${chunk.name})`,
                    actual: Math.round(chunk.size / 1024),
                    budget: PERFORMANCE_BUDGETS.maxChunkSize,
                    severity: 'warning',
                });
            }
        }
    }
    return {
        passed: violations.length === 0,
        violations,
    };
}
/**
 * Dynamic import utilities for code splitting
 */
export const DynamicImports = {
    // Admin dashboard components
    AdminDashboard: () =&gt; import('@/app/admin/page'),
    FoodTruckManagement: () =&gt; import('@/app/admin/food-trucks/page'),
    Analytics: () =&gt; import('@/app/admin/analytics/page'),
    // Chart components (heavy dependencies)
    Charts: () =&gt; import('recharts'),
    // Authentication components
    LoginPage: () =&gt; import('@/app/login/page'),
    // Map components - commented out until component exists
    // MapDisplay: () =&gt; import('@/components/MapDisplay'),
};
/**
 * Optimized imports for common libraries
 */
export const OptimizedImports = {
    // Lucide React - use standard imports (tree-shaking handled by bundler)
    icons: {
        // Use regular lucide-react imports - modern bundlers handle tree-shaking
        Menu: () =&gt; import('lucide-react').then((mod) =&gt; ({ Menu: mod.Menu })),
        Search: () =&gt; import('lucide-react').then((mod) =&gt; ({ Search: mod.Search })),
        User: () =&gt; import('lucide-react').then((mod) =&gt; ({ User: mod.User })),
        BarChart3: () =&gt; import('lucide-react').then((mod) =&gt; ({ BarChart3: mod.BarChart3 })),
        Settings: () =&gt; import('lucide-react').then((mod) =&gt; ({ Settings: mod.Settings })),
        Database: () =&gt; import('lucide-react').then((mod) =&gt; ({ Database: mod.Database })),
    },
    // Radix UI - optimized imports
    ui: {
        Button: () =&gt; import('@radix-ui/react-slot').then((mod) =&gt; ({ Slot: mod.Slot })),
        Dialog: () =&gt; import('@radix-ui/react-dialog'),
        DropdownMenu: () =&gt; import('@radix-ui/react-dropdown-menu'),
    },
};
/**
 * Performance monitoring for bundle loading
 */
export class BundlePerformanceMonitor {
    static loadTimes = new Map();
    /**
     * Track chunk load time
     */
    static trackChunkLoad(chunkName, startTime) {
        const loadTime = performance.now() - startTime;
        this.loadTimes.set(chunkName, loadTime);
        // Log slow loading chunks
        if (loadTime &gt; 1000) {
            // More than 1 second
            console.warn(`Slow chunk load detected: ${chunkName} took ${loadTime.toFixed(2)}ms`);
        }
    }
    /**
     * Get chunk load statistics
     */
    static getLoadStats() {
        return [...this.loadTimes.entries()].map(([chunk, loadTime]) =&gt; ({
            chunk,
            loadTime,
        }));
    }
    /**
     * Get average load time
     */
    static getAverageLoadTime() {
        const times = [...this.loadTimes.values()];
        return times.length &gt; 0 ? times.reduce((sum, time) =&gt; sum + time, 0) / times.length : 0;
    }
}
/**
 * Code splitting helper for React components
 */
export function createLazyComponent(importFn, fallback) {
    const LazyComponent = React.lazy(importFn);
    /**
     * Wraps a lazy loaded component with performance monitoring.
     * @example
     * WrappedComponent(props);
     * Returns a React component wrapped with a Suspense fallback and performance tracking.
     * @param {React.ComponentProps&lt;T&gt;} props - The props for the wrapped lazy component.
     * @returns {React.ReactElement} A React element that wraps the lazy component within a Suspense fallback.
     * @description
     *   - Utilizes React's Suspense to handle lazy loading of components with a fallback UI.
     *   - Tracks the performance of the component chunk loading using BundlePerformanceMonitor.
     *   - Analyzes the load-time performance by capturing the start time at component mount.
     */
    return function WrappedComponent(props) {
        const startTime = performance.now();
        React.useEffect(() =&gt; {
            BundlePerformanceMonitor.trackChunkLoad(importFn.toString().slice(0, 50), // Use function string as identifier
            startTime);
        }, []);
        return (&lt;</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/performance/bundleAnalyzer.js (Line 168:2 - Line 217:2), C:/AI/food-truck-finder-poc/dist/lib/performance/bundleAnalyzer.js (Line 167:2 - Line 216:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn398" onclick="toggleCodeBlock('cloneGroup398', 'expandBtn398', 'collapseBtn398')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn398" onclick="toggleCodeBlock('cloneGroup398', 'expandBtn398', 'collapseBtn398')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup398"><code class="language-javascript text-sm text-gray-800">);
    };
}
/**
 * Bundle size recommendations based on current setup
 */
export function getProjectSpecificRecommendations() {
    return [
        {
            category: 'Code Splitting',
            priority: 'high',
            recommendations: [
                'Split admin dashboard into separate route chunks',
                'Lazy load Recharts components only when analytics page is accessed',
                'Dynamic import authentication components',
                'Separate map components into their own chunk',
            ],
        },
        {
            category: 'Dependency Optimization',
            priority: 'medium',
            recommendations: [
                'Use tree-shaking for Lucide React icons',
                'Optimize Radix UI imports to only include used components',
                'Consider lighter alternatives to heavy dependencies',
                'Use Next.js optimizePackageImports for @radix-ui',
            ],
        },
        {
            category: 'Asset Optimization',
            priority: 'medium',
            recommendations: [
                'Optimize images with Next.js Image component',
                'Use WebP/AVIF formats for better compression',
                'Implement proper caching headers for static assets',
                'Minimize CSS bundle size with unused CSS removal',
            ],
        },
        {
            category: 'Runtime Optimization',
            priority: 'low',
            recommendations: [
                'Implement service worker for caching',
                'Use compression middleware in production',
                'Enable HTTP/2 server push for critical resources',
                'Implement resource hints (preload, prefetch)',
            ],
        },
    ];
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/monitoring/apiMonitor.js (Line 5:42 - Line 31:4), C:/AI/food-truck-finder-poc/dist/lib/lib/monitoring/apiMonitor.js (Line 5:27 - Line 31:4)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn400" onclick="toggleCodeBlock('cloneGroup400', 'expandBtn400', 'collapseBtn400')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn400" onclick="toggleCodeBlock('cloneGroup400', 'expandBtn400', 'collapseBtn400')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup400"><code class="language-javascript text-sm text-gray-800">;
// API Rate Limits Configuration
export const API_LIMITS = {
    gemini: {
        requests: { daily: 1500, hourly: 100 },
        tokens: { daily: 32_000, hourly: 2000 },
        alertThresholds: { warning: 0.8, critical: 0.95 },
    },
    firecrawl: {
        requests: { daily: 500, hourly: 50 },
        tokens: { daily: 0, hourly: 0 },
        alertThresholds: { warning: 0.8, critical: 0.95 },
    },
    tavily: {
        requests: { daily: 1000, hourly: 100 },
        tokens: { daily: 0, hourly: 0 },
        alertThresholds: { warning: 0.8, critical: 0.95 },
    },
    supabase: {
        requests: { daily: 50_000, hourly: 5000 },
        tokens: { daily: 0, hourly: 0 },
        alertThresholds: { warning: 0.9, critical: 0.98 },
    },
};
/**
 * Comprehensive API Monitoring Service
 */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/monitoring/apiMonitor.js (Line 37:5 - Line 77:8), C:/AI/food-truck-finder-poc/dist/lib/lib/monitoring/apiMonitor.js (Line 37:5 - Line 77:8)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn401" onclick="toggleCodeBlock('cloneGroup401', 'expandBtn401', 'collapseBtn401')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn401" onclick="toggleCodeBlock('cloneGroup401', 'expandBtn401', 'collapseBtn401')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup401"><code class="language-javascript text-sm text-gray-800">static async canMakeRequest(service, requestCount = 1, tokenCount = 0) {
        try {
            const usage = await this.getCurrentUsage(service);
            const limits = API_LIMITS[service];
            // Check daily limits
            const newRequestCount = usage.requests.used + requestCount;
            const newTokenCount = (usage.tokens?.used ?? 0) + tokenCount;
            if (newRequestCount &gt; limits.requests.daily) {
                return {
                    allowed: false,
                    reason: `Daily request limit exceeded (${newRequestCount}/${limits.requests.daily})`,
                    waitTime: this.getTimeUntilReset('daily'),
                };
            }
            if (limits.tokens != undefined &amp;&amp; newTokenCount &gt; limits.tokens.daily) {
                return {
                    allowed: false,
                    reason: `Daily token limit exceeded (${newTokenCount}/${limits.tokens.daily})`,
                    waitTime: this.getTimeUntilReset('daily'),
                };
            }
            // Check if approaching critical threshold
            const requestPercentage = newRequestCount / limits.requests.daily;
            if (requestPercentage &gt; limits.alertThresholds.critical) {
                return {
                    allowed: false,
                    reason: `Approaching critical usage threshold (${(requestPercentage * 100).toFixed(1)}%)`,
                    waitTime: this.getTimeUntilReset('daily'),
                };
            }
            return { allowed: true };
        }
        catch (error) {
            console.error(`Error checking API limits for ${service}:`, error);
            // Fail safe - allow request but log error
            return { allowed: true };
        }
    }
    /**
     * Get current usage for a service
     */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/monitoring/apiMonitor.js (Line 78:5 - Line 99:8), C:/AI/food-truck-finder-poc/dist/lib/lib/monitoring/apiMonitor.js (Line 78:5 - Line 99:8)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn402" onclick="toggleCodeBlock('cloneGroup402', 'expandBtn402', 'collapseBtn402')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn402" onclick="toggleCodeBlock('cloneGroup402', 'expandBtn402', 'collapseBtn402')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup402"><code class="language-javascript text-sm text-gray-800">static async getCurrentUsage(service) {
        const todayUsage = await APIUsageService.getTodayUsage(service);
        const limits = API_LIMITS[service];
        const usage = {
            requests: {
                used: todayUsage?.requests_count ?? 0,
                limit: limits.requests.daily,
                percentage: ((todayUsage?.requests_count ?? 0) / limits.requests.daily) * 100,
            },
        };
        if (limits.tokens.daily &gt; 0) {
            usage.tokens = {
                used: todayUsage?.tokens_used ?? 0,
                limit: limits.tokens.daily,
                percentage: ((todayUsage?.tokens_used ?? 0) / limits.tokens.daily) * 100,
            };
        }
        return usage;
    }
    /**
     * Comprehensive monitoring check for all APIs
     */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/monitoring/apiMonitor.js (Line 100:5 - Line 153:8), C:/AI/food-truck-finder-poc/dist/lib/lib/monitoring/apiMonitor.js (Line 100:5 - Line 153:8)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn403" onclick="toggleCodeBlock('cloneGroup403', 'expandBtn403', 'collapseBtn403')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn403" onclick="toggleCodeBlock('cloneGroup403', 'expandBtn403', 'collapseBtn403')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup403"><code class="language-javascript text-sm text-gray-800">static async checkAllAPIs() {
        const alerts = [];
        const usage = {};
        const recommendations = [];
        let canMakeRequest = true;
        for (const service of Object.keys(API_LIMITS)) {
            try {
                const serviceUsage = await this.getCurrentUsage(service);
                usage[service] = serviceUsage;
                // Check for alerts
                const serviceAlerts = this.generateAlerts(service, serviceUsage);
                alerts.push(...serviceAlerts);
                // Check if any service is at critical level
                if (serviceUsage.requests.percentage &gt; API_LIMITS[service].alertThresholds.critical * 100) {
                    canMakeRequest = false;
                }
            }
            catch (error) {
                console.error(`Error monitoring ${service}:`, error);
                alerts.push({
                    service,
                    level: 'warning',
                    message: `Failed to check usage for ${service}`,
                    usage: { current: 0, limit: 0, percentage: 0 },
                    timestamp: new Date().toISOString(),
                    recommendations: ['Check API connectivity', 'Verify credentials'],
                });
            }
        }
        // Generate global recommendations
        recommendations.push(...this.generateRecommendations(usage, alerts));
        return {
            canMakeRequest,
            alerts,
            usage,
            recommendations,
        };
    }
    // Helper for token alerts
    /**
     * Generates token usage alerts based on API usage data and predefined limits.
     * @example
     * generateTokenAlerts(APIServiceInstance, usageData, apiLimits, '2023-10-21T10:20:30Z')
     * [{ service: 'exampleService', level: 'warning', message: 'Warning: exampleService token usage at 75.0%', ... }]
     * @param {APIService} service - The API service for which the alerts are being generated.
     * @param {APIUsageData} usage - Object containing the token usage statistics.
     * @param {Object} limits - Configuration object specifying API limits and alert thresholds.
     * @param {string} timestamp - The timestamp at which the alert is generated.
     * @returns {APIUsageAlert[]} List of alerts generated based on token usage percentage compared to limits.
     * @description
     *   - Generates 'warning' alerts if token usage exceeds the warning threshold.
     *   - Generates 'critical' alerts if token usage exceeds the critical threshold.
     *   - Provides recommendations for optimizing token usage when an alert is generated.
     */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/monitoring/apiMonitor.js (Line 154:5 - Line 209:8), C:/AI/food-truck-finder-poc/dist/lib/lib/monitoring/apiMonitor.js (Line 154:5 - Line 209:8)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn404" onclick="toggleCodeBlock('cloneGroup404', 'expandBtn404', 'collapseBtn404')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn404" onclick="toggleCodeBlock('cloneGroup404', 'expandBtn404', 'collapseBtn404')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup404"><code class="language-javascript text-sm text-gray-800">static generateTokenAlerts(service, usage, limits, timestamp) {
        const alerts = [];
        if (usage.tokens &amp;&amp; limits.tokens.daily &gt; 0) {
            const tokenPercentage = usage.tokens.percentage;
            if (tokenPercentage &gt; limits.alertThresholds.critical * 100) {
                alerts.push({
                    service,
                    level: 'critical',
                    message: `Critical: ${service} token usage at ${tokenPercentage.toFixed(1)}%`,
                    usage: {
                        current: usage.tokens.used,
                        limit: usage.tokens.limit,
                        percentage: tokenPercentage,
                    },
                    timestamp,
                    recommendations: [
                        'Reduce prompt complexity',
                        'Implement response caching',
                        'Optimize token usage patterns',
                    ],
                });
            }
            else if (tokenPercentage &gt; limits.alertThresholds.warning * 100) {
                alerts.push({
                    service,
                    level: 'warning',
                    message: `Warning: ${service} token usage at ${tokenPercentage.toFixed(1)}%`,
                    usage: {
                        current: usage.tokens.used,
                        limit: usage.tokens.limit,
                        percentage: tokenPercentage,
                    },
                    timestamp,
                    recommendations: [
                        'Monitor token consumption',
                        'Optimize prompt efficiency',
                        'Consider response caching',
                    ],
                });
            }
        }
        return alerts;
    }
    /**
     * Generates usage alerts based on the service's API usage data.
     * @example
     * generateAlerts(APIService.YOUR_SERVICE, apiUsageData)
     * returns an array of APIUsageAlert objects when usage thresholds are exceeded.
     * @param {APIService} service - The API service being monitored.
     * @param {APIUsageData} usage - The usage data containing request and token information.
     * @returns {APIUsageAlert[]} An array of alert objects representing warning or critical usage states.
     * @description
     *   - Determines alert level based on predefined thresholds in API_LIMITS.
     *   - Generates alerts for both request and token usage.
     *   - Updates alert history, maintaining only the last 100 alerts.
     */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/monitoring/apiMonitor.js (Line 210:5 - Line 264:8), C:/AI/food-truck-finder-poc/dist/lib/lib/monitoring/apiMonitor.js (Line 210:5 - Line 264:8)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn405" onclick="toggleCodeBlock('cloneGroup405', 'expandBtn405', 'collapseBtn405')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn405" onclick="toggleCodeBlock('cloneGroup405', 'expandBtn405', 'collapseBtn405')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup405"><code class="language-javascript text-sm text-gray-800">static generateAlerts(service, usage) {
        const alerts = [];
        const limits = API_LIMITS[service];
        const timestamp = new Date().toISOString();
        // Check request usage
        const requestPercentage = usage.requests.percentage;
        if (requestPercentage &gt; limits.alertThresholds.critical * 100) {
            alerts.push({
                service,
                level: 'critical',
                message: `Critical: ${service} request usage at ${requestPercentage.toFixed(1)}%`,
                usage: {
                    current: usage.requests.used,
                    limit: usage.requests.limit,
                    percentage: requestPercentage,
                },
                timestamp,
                recommendations: [
                    'Immediately reduce API calls',
                    'Implement request queuing',
                    'Consider upgrading API plan',
                ],
            });
        }
        else if (requestPercentage &gt; limits.alertThresholds.warning * 100) {
            alerts.push({
                service,
                level: 'warning',
                message: `Warning: ${service} request usage at ${requestPercentage.toFixed(1)}%`,
                usage: {
                    current: usage.requests.used,
                    limit: usage.requests.limit,
                    percentage: requestPercentage,
                },
                timestamp,
                recommendations: [
                    'Monitor usage closely',
                    'Optimize request patterns',
                    'Enable request caching',
                ],
            });
        }
        // Token alerts
        alerts.push(...this.generateTokenAlerts(service, usage, limits, timestamp));
        // Store alerts in history
        this.alertHistory.push(...alerts);
        // Keep only last 100 alerts
        if (this.alertHistory.length &gt; 100) {
            this.alertHistory = this.alertHistory.slice(-100);
        }
        return alerts;
    }
    /**
     * Generate optimization recommendations
     */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/monitoring/apiMonitor.js (Line 265:5 - Line 287:8), C:/AI/food-truck-finder-poc/dist/lib/lib/monitoring/apiMonitor.js (Line 265:5 - Line 287:8)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn406" onclick="toggleCodeBlock('cloneGroup406', 'expandBtn406', 'collapseBtn406')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn406" onclick="toggleCodeBlock('cloneGroup406', 'expandBtn406', 'collapseBtn406')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup406"><code class="language-javascript text-sm text-gray-800">static generateRecommendations(usage, alerts) {
        const recommendations = [];
        // High-level optimization recommendations
        const criticalAlerts = alerts.filter((a) =&gt; a.level === 'critical');
        const warningAlerts = alerts.filter((a) =&gt; a.level === 'warning');
        if (criticalAlerts.length &gt; 0) {
            recommendations.push('URGENT: Implement immediate API throttling', 'Enable aggressive caching for all API responses', 'Consider upgrading API plans for critical services');
        }
        if (warningAlerts.length &gt; 0) {
            recommendations.push('Implement request queuing and batching', 'Optimize API call patterns and frequency', 'Enable response caching where possible');
        }
        // Service-specific recommendations
        if (usage.gemini?.requests?.percentage &gt; 70) {
            recommendations.push('Gemini: Optimize prompt length and complexity', 'Gemini: Implement response caching for similar queries');
        }
        if (usage.firecrawl?.requests?.percentage &gt; 70) {
            recommendations.push('Firecrawl: Implement URL deduplication', 'Firecrawl: Cache crawl results for repeated URLs');
        }
        return [...new Set(recommendations)]; // Remove duplicates
    }
    /**
     * Get time until rate limit reset
     */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/monitoring/apiMonitor.js (Line 288:5 - Line 302:8), C:/AI/food-truck-finder-poc/dist/lib/lib/monitoring/apiMonitor.js (Line 288:5 - Line 302:8)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn407" onclick="toggleCodeBlock('cloneGroup407', 'expandBtn407', 'collapseBtn407')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn407" onclick="toggleCodeBlock('cloneGroup407', 'expandBtn407', 'collapseBtn407')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup407"><code class="language-javascript text-sm text-gray-800">static getTimeUntilReset(period) {
        const now = new Date();
        if (period === 'hourly') {
            const nextHour = new Date(now);
            nextHour.setHours(now.getHours() + 1, 0, 0, 0);
            return nextHour.getTime() - now.getTime();
        }
        const nextDay = new Date(now);
        nextDay.setDate(now.getDate() + 1);
        nextDay.setHours(0, 0, 0, 0);
        return nextDay.getTime() - now.getTime();
    }
    /**
     * Get alert history
     */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/middleware/middlewareHelpers.js (Line 21:1 - Line 51:4), C:/AI/food-truck-finder-poc/dist/lib/lib/middleware/middlewareHelpers.js (Line 21:1 - Line 51:4)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn408" onclick="toggleCodeBlock('cloneGroup408', 'expandBtn408', 'collapseBtn408')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn408" onclick="toggleCodeBlock('cloneGroup408', 'expandBtn408', 'collapseBtn408')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup408"><code class="language-javascript text-sm text-gray-800">async function logSecurityEventAndRedirect({ req, res: _res, logParams, redirectPath, redirectFromPath, }) {
    await AuditLogger.logSecurityEvent(logParams);
    const redirectUrl = req.nextUrl.clone();
    redirectUrl.pathname = redirectPath;
    if (redirectFromPath) {
        redirectUrl.searchParams.set(`redirectedFrom`, redirectFromPath);
    }
    return NextResponse.redirect(redirectUrl);
}
/**
 * Logs a security event and redirects the user to the login page.
 * @example
 * logAndRedirect({
 *   req: requestObject,
 *   res: responseObject,
 *   requestMetadata: { ip: '192.168.1.1', userAgent: 'Mozilla/5.0', url: '/dashboard' },
 *   reason: 'Session Expired',
 *   userError: new Error('User authentication failed')
 * })
 * // Redirects user to login page and logs the event
 * @param {Object} req - Express request object containing details of the incoming request.
 * @param {Object} res - Express response object used to send a response to the client.
 * @param {Object} requestMetadata - Metadata associated with the request, including IP and user agent.
 * @param {string} reason - The reason for redirect, generally describing why access was denied.
 * @param {Error} userError - Optional error object that provides additional context about the user error.
 * @returns {Promise&lt;void&gt;} Returns a promise that resolves once the security event is logged and redirect is completed.
 * @description
 *   - Utilizes a severity of 'warning' when logging security events.
 *   - Redirects users from the attempted URL to the login page.
 *   - Captures detailed information about the request including attempted URL and user agent.
 */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/middleware/middlewareHelpers.js (Line 52:1 - Line 96:4), C:/AI/food-truck-finder-poc/dist/lib/lib/middleware/middlewareHelpers.js (Line 52:1 - Line 96:4)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn409" onclick="toggleCodeBlock('cloneGroup409', 'expandBtn409', 'collapseBtn409')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn409" onclick="toggleCodeBlock('cloneGroup409', 'expandBtn409', 'collapseBtn409')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup409"><code class="language-javascript text-sm text-gray-800">async function logAndRedirect({ req, res, requestMetadata, reason, userError, }) {
    return logSecurityEventAndRedirect({
        req,
        res,
        logParams: {
            event_type: 'permission_denied',
            ip_address: requestMetadata.ip,
            user_agent: requestMetadata.userAgent,
            details: {
                attempted_url: requestMetadata.url,
                reason,
                error: userError?.message,
            },
            severity: 'warning',
        },
        redirectPath: '/login',
        redirectFromPath: req.nextUrl.pathname,
    });
}
/**
 * Logs a security event and redirects to an access-denied page.
 * @example
 * logAndRedirectDenied({
 *   req: requestObject,
 *   res: responseObject,
 *   requestMetadata: metadataObject,
 *   user: userObject,
 *   profile: profileObject,
 *   profileQueryError: errorObject
 * })
 * // Redirects user and logs the event with relevant details
 * @param {Object} params - Contains necessary parameters for the function.
 * @param {Object} params.req - The HTTP request object.
 * @param {Object} params.res - The HTTP response object.
 * @param {Object} params.requestMetadata - Metadata related to the request.
 * @param {Object} params.user - User information object.
 * @param {Object} params.profile - Profile object related to the user.
 * @param {Object} params.profileQueryError - Error object if querying profile fails.
 * @returns {Promise&lt;void&gt;} Returns a promise that resolves after logging and redirecting.
 * @description
 *   - Utilizes `logSecurityEventAndRedirect` to perform logging and redirect operations.
 *   - The function assumes a structure for the user object, expecting 'id' and 'email' properties.
 *   - Redirects to '/access-denied' path by default.
 *   - Sets event severity as 'error' when logging the security event.
 */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/middleware/middlewareHelpers.js (Line 97:1 - Line 132:4), C:/AI/food-truck-finder-poc/dist/lib/lib/middleware/middlewareHelpers.js (Line 97:1 - Line 132:4)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn410" onclick="toggleCodeBlock('cloneGroup410', 'expandBtn410', 'collapseBtn410')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn410" onclick="toggleCodeBlock('cloneGroup410', 'expandBtn410', 'collapseBtn410')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup410"><code class="language-javascript text-sm text-gray-800">async function logAndRedirectDenied({ req, res, requestMetadata, user, profile, profileQueryError, }) {
    return logSecurityEventAndRedirect({
        req,
        res,
        logParams: {
            event_type: 'permission_denied',
            user_id: user.id,
            user_email: user.email ?? undefined,
            ip_address: requestMetadata.ip,
            user_agent: requestMetadata.userAgent,
            details: {
                attempted_url: requestMetadata.url,
                user_role: profile?.role ?? 'none',
                reason: 'insufficient_privileges',
                error: profileQueryError?.message,
            },
            severity: 'error',
        },
        redirectPath: '/access-denied',
    });
}
/**
 * Protects admin routes by verifying user authentication and authorization.
 * @example
 * protectAdminRoutes(req, res, requestMetadata)
 * returns NextResponse or redirects depending on user authentication status.
 * @param {NextRequest} req - The incoming request object.
 * @param {NextResponse} res - The response object to send back to the client.
 * @param {RequestMetadata} requestMetadata - Metadata about the request for logging purposes.
 * @returns {NextResponse} Returns the response object or redirects to an error page.
 * @description
 *   - Fetches and verifies the user's session from Supabase.
 *   - Checks if the user is an admin based on the profile 'role' from the database.
 *   - Logs access attempts to the admin panel for auditing purposes.
 *   - Redirects to an appropriate error handler if the user isn't authenticated or authorized.
 */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/middleware/middlewareHelpers.js (Line 133:1 - Line 176:2), C:/AI/food-truck-finder-poc/dist/lib/lib/middleware/middlewareHelpers.js (Line 133:1 - Line 176:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn411" onclick="toggleCodeBlock('cloneGroup411', 'expandBtn411', 'collapseBtn411')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn411" onclick="toggleCodeBlock('cloneGroup411', 'expandBtn411', 'collapseBtn411')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup411"><code class="language-javascript text-sm text-gray-800">export async function protectAdminRoutes(req, res, requestMetadata) {
    const supabase = createSupabaseMiddlewareClient(req, res);
    const { data, error: userError } = await supabase.auth.getUser();
    const user = data?.user;
    if (userError || !user) {
        return logAndRedirect({
            req,
            res,
            requestMetadata,
            reason: 'no_session',
            userError: userError ?? undefined,
        });
    }
    // Explicitly type the result of the Supabase query
    const { data: profile, error: profileQueryError } = (await supabase
        .from('profiles')
        .select('role')
        .eq('id', user.id)
        .single());
    if (profileQueryError || (profile &amp;&amp; profile.role !== 'admin')) {
        return logAndRedirectDenied({
            req,
            res,
            requestMetadata,
            user,
            profile: profile ?? null,
            profileQueryError: profileQueryError ?? undefined,
        });
    }
    if (req.method !== 'GET' || req.nextUrl.pathname.includes('/api/')) {
        await AuditLogger.logDataAccess({
            userId: user.id,
            userEmail: user.email ?? 'unknown',
            resourceType: 'admin_panel',
            resourceId: req.nextUrl.pathname,
            action: req.method === 'GET' ? 'read' : 'admin_access',
            request: {
                ip: requestMetadata.ip,
                userAgent: requestMetadata.userAgent,
            },
        });
    }
    return res;
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/mappers/uprootedVeganMapper.js (Line 1:1 - Line 180:2), C:/AI/food-truck-finder-poc/dist/lib/lib/mappers/uprootedVeganMapper.js (Line 1:1 - Line 180:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn414" onclick="toggleCodeBlock('cloneGroup414', 'expandBtn414', 'collapseBtn414')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn414" onclick="toggleCodeBlock('cloneGroup414', 'expandBtn414', 'collapseBtn414')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup414"><code class="language-javascript text-sm text-gray-800">/**
 * Data mapper for Uprooted Vegan Cuisine onboarding
 *
 * This utility handles the transformation of Uprooted Vegan Cuisine data
 * to match our FoodTruck schema, including field mappings and defaults.
 */
/**
 * Normalizes cuisine_type to always be an array
 */
function normalizeCuisineType(cuisine_type) {
    if (typeof cuisine_type === 'string') {
        // Split on common separators and clean up
        return cuisine_type
            .split(/[,;&amp;]/)
            .map(c =&gt; c.trim())
            .filter(c =&gt; c.length &gt; 0);
    }
    return Array.isArray(cuisine_type) ? cuisine_type : [];
}
/**
 * Normalizes specialties to always be an array
 */
function normalizeSpecialties(specialties) {
    if (!specialties)
        return [];
    if (typeof specialties === 'string') {
        return specialties
            .split(/[,;&amp;]/)
            .map(s =&gt; s.trim())
            .filter(s =&gt; s.length &gt; 0);
    }
    return Array.isArray(specialties) ? specialties : [];
}
/**
 * Normalizes source URLs to always be an array
 */
function normalizeSourceUrls(source_urls) {
    if (!source_urls)
        return [];
    if (typeof source_urls === 'string') {
        return [source_urls];
    }
    return Array.isArray(source_urls) ? source_urls : [];
}
/**
 * Creates default operating hours
 */
function createDefaultOperatingHours() {
    return {
        monday: undefined,
        tuesday: undefined,
        wednesday: undefined,
        thursday: undefined,
        friday: undefined,
        saturday: undefined,
        sunday: undefined
    };
}
/**
 * Maps Uprooted Vegan Cuisine data to our FoodTruck schema
 */
export function mapUprootedVeganData(data) {
    const now = new Date().toISOString();
    // Handle location priority: exact_location &gt; current_location &gt; city_location
    const primaryLocation = data.exact_location || data.current_location || data.city_location;
    const mapped = {
        // Core fields
        name: data.name,
        description: data.description,
        cuisine_type: normalizeCuisineType(data.cuisine_type),
        price_range: data.price_range,
        specialties: normalizeSpecialties(data.specialties),
        // New fields for Uprooted Vegan support
        user_id: data.user_id,
        state: data.state,
        // Location fields
        current_location: primaryLocation ? {
            lat: primaryLocation.lat,
            lng: primaryLocation.lng,
            address: primaryLocation.address,
            timestamp: primaryLocation.timestamp || now,
        } : {
            lat: 0,
            lng: 0,
            address: undefined,
            timestamp: now,
        },
        scheduled_locations: data.scheduled_locations,
        // Menu and hours
        operating_hours: data.operating_hours || createDefaultOperatingHours(),
        menu: data.menu || [],
        // Contact information
        contact_info: data.contact_info || {},
        social_media: data.social_media || {},
        // Quality and verification
        data_quality_score: data.data_quality_score ?? 0.5, // Default to medium quality
        verification_status: data.verification_status || 'pending',
        source_urls: normalizeSourceUrls(data.source_urls),
        // Handle timestamps
        last_scraped_at: data.last_scraped_at || now,
        created_at: data.created_at || now,
        updated_at: data.updated_at || now,
        // Additional helpful defaults
        is_active: true, // Assume new entries are active
        test_run_flag: false // Not a test import
    };
    return mapped;
}
/**
 * Validates that required fields are present
 */
export function validateUprootedVeganData(data) {
    const errors = [];
    // Check required fields
    if (!data.name || data.name.trim().length === 0) {
        errors.push('name is required');
    }
    if (!data.cuisine_type ||
        (Array.isArray(data.cuisine_type) &amp;&amp; data.cuisine_type.length === 0) ||
        (typeof data.cuisine_type === 'string' &amp;&amp; data.cuisine_type.trim().length === 0)) {
        errors.push('cuisine_type is required');
    }
    // Validate state format if provided
    if (data.state &amp;&amp; (typeof data.state !== 'string' || data.state.length !== 2)) {
        errors.push('state must be a 2-character string (e.g., CA, NY, TX)');
    }
    // Validate user_id format if provided
    if (data.user_id &amp;&amp; typeof data.user_id !== 'string') {
        errors.push('user_id must be a valid UUID string');
    }
    // Validate price range if provided
    if (data.price_range &amp;&amp; !['$', '$$', '$$$', '$$$$'].includes(data.price_range)) {
        errors.push('price_range must be one of: $, $$, $$$, $$$$');
    }
    return {
        isValid: errors.length === 0,
        errors
    };
}
/**
 * Example usage and testing function
 */
export function createUprootedVeganExample() {
    return {
        name: &quot;Uprooted Vegan Cuisine&quot;,
        description: &quot;Plant-based comfort food truck serving delicious vegan alternatives&quot;,
        cuisine_type: [&quot;Vegan&quot;, &quot;American&quot;, &quot;Comfort Food&quot;],
        price_range: &quot;$$&quot;,
        specialties: [&quot;Vegan Burgers&quot;, &quot;Plant-Based Mac &amp; Cheese&quot;, &quot;Cashew-Based Desserts&quot;],
        user_id: &quot;123e4567-e89b-12d3-a456-426614174000&quot;, // Example UUID
        state: &quot;CA&quot;,
        current_location: {
            lat: 37.7749,
            lng: -122.4194,
            address: &quot;San Francisco, CA&quot;,
            timestamp: new Date().toISOString()
        },
        operating_hours: {
            monday: { open: &quot;11:00 AM&quot;, close: &quot;8:00 PM&quot; },
            tuesday: { open: &quot;11:00 AM&quot;, close: &quot;8:00 PM&quot; },
            wednesday: { open: &quot;11:00 AM&quot;, close: &quot;8:00 PM&quot; },
            thursday: { open: &quot;11:00 AM&quot;, close: &quot;8:00 PM&quot; },
            friday: { open: &quot;11:00 AM&quot;, close: &quot;9:00 PM&quot; },
            saturday: { open: &quot;10:00 AM&quot;, close: &quot;9:00 PM&quot; },
            sunday: { closed: true }
        },
        contact_info: {
            phone: &quot;(415) 555-0123&quot;,
            email: &quot;hello@uprootedvegan.com&quot;,
            website: &quot;https://uprootedvegan.com&quot;
        },
        social_media: {
            instagram: &quot;@uprootedvegan&quot;,
            facebook: &quot;UprootedVeganCuisine&quot;
        },
        verification_status: &quot;pending&quot;,
        data_quality_score: 0.8,
        source_urls: [&quot;https://uprootedvegan.com&quot;]
    };
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/gemini/usageLimits.js (Line 20:5 - Line 62:7), C:/AI/food-truck-finder-poc/dist/lib/lib/gemini/usageLimits.js (Line 20:5 - Line 62:7)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn415" onclick="toggleCodeBlock('cloneGroup415', 'expandBtn415', 'collapseBtn415')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn415" onclick="toggleCodeBlock('cloneGroup415', 'expandBtn415', 'collapseBtn415')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup415"><code class="language-javascript text-sm text-gray-800">static async checkUsageLimits(limits = this.DEFAULT_LIMITS) {
        try {
            const usage = await APIUsageService.getTodayUsage('gemini');
            if (!usage) {
                return { canMakeRequest: true };
            }
            const requestsUsed = usage.requests_count ?? 0;
            const tokensUsed = usage.tokens_used ?? 0;
            const requestsRemaining = limits.dailyRequestLimit - requestsUsed;
            const tokensRemaining = limits.dailyTokenLimit - tokensUsed;
            return {
                canMakeRequest: requestsRemaining &gt; 0 &amp;&amp; tokensRemaining &gt; 100, // Keep 100 token buffer
                usage: {
                    requests: {
                        used: requestsUsed,
                        limit: limits.dailyRequestLimit,
                        remaining: requestsRemaining,
                    },
                    tokens: {
                        used: tokensUsed,
                        limit: limits.dailyTokenLimit,
                        remaining: tokensRemaining,
                    },
                },
            };
        }
        catch (error) {
            console.warn('Error checking Gemini usage limits:', error);
            return { canMakeRequest: false };
        }
    }
    /**
    * Checks if a request can be made with monitoring and returns whether the operation is allowed.
    * @example
    * checkWithMonitoring(100, DEFAULT_LIMITS)
    * { allowed: true }
    * @param {number} estimatedTokens - Number of estimated tokens for the request.
    * @param {UsageLimits} _limits - Usage limits configuration for requests (default provided internally).
    * @returns {Promise&lt;{ allowed: boolean; reason?: string; waitTime?: number }&gt;} Object indicating if the request is allowed and why not if denied.
    * @description
    *   - Uses an internal API monitor to check if requests can be made based on predefined limits.
    *   - Wait time is converted from milliseconds to minutes before being returned.
    */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/gemini/usageLimits.js (Line 63:5 - Line 73:2), C:/AI/food-truck-finder-poc/dist/lib/lib/gemini/usageLimits.js (Line 63:5 - Line 73:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn416" onclick="toggleCodeBlock('cloneGroup416', 'expandBtn416', 'collapseBtn416')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn416" onclick="toggleCodeBlock('cloneGroup416', 'expandBtn416', 'collapseBtn416')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup416"><code class="language-javascript text-sm text-gray-800">static async checkWithMonitoring(estimatedTokens, _limits = this.DEFAULT_LIMITS) {
        const canMakeRequest = await APIMonitor.canMakeRequest('gemini', 1, estimatedTokens);
        if (!canMakeRequest.allowed) {
            return {
                allowed: false,
                reason: `API limit reached: ${canMakeRequest.reason}. Wait time: ${Math.ceil((canMakeRequest.waitTime ?? 0) / 1000 / 60)} minutes`,
            };
        }
        return { allowed: true };
    }
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/gemini/geminiApiClient.js (Line 193:13 - Line 207:27), C:/AI/food-truck-finder-poc/dist/lib/lib/gemini/geminiApiClient.js (Line 75:9 - Line 87:6)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn417" onclick="toggleCodeBlock('cloneGroup417', 'expandBtn417', 'collapseBtn417')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn417" onclick="toggleCodeBlock('cloneGroup417', 'expandBtn417', 'collapseBtn417')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup417"><code class="language-javascript text-sm text-gray-800">const response = await this.makeRequest(prompt, config);
            if (!response.success) {
                return response;
            }
            
            try {
                if (!response.data) {
                    return {
                        success: false,
                        error: 'No data received from Gemini API',
                        tokensUsed: response.tokensUsed,
                    };
                }
                
                // Clean the response data</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/gemini/geminiApiClient.js (Line 225:12 - Line 230:21), C:/AI/food-truck-finder-poc/dist/lib/lib/gemini/geminiApiClient.js (Line 99:35 - Line 103:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn418" onclick="toggleCodeBlock('cloneGroup418', 'expandBtn418', 'collapseBtn418')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn418" onclick="toggleCodeBlock('cloneGroup418', 'expandBtn418', 'collapseBtn418')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup418"><code class="language-javascript text-sm text-gray-800">${parseError instanceof Error ? parseError.message : String(parseError)}. Response text: ${response.data?.trim().slice(0, 200) ?? 'No data'}...`,
                        tokensUsed: response.tokensUsed,
                    };
                }
                
                // Wait before retry</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/fallback/supabaseFallback.js (Line 1:1 - Line 297:2), C:/AI/food-truck-finder-poc/dist/lib/fallback/supabaseFallback.js (Line 1:1 - Line 297:6)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn423" onclick="toggleCodeBlock('cloneGroup423', 'expandBtn423', 'collapseBtn423')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn423" onclick="toggleCodeBlock('cloneGroup423', 'expandBtn423', 'collapseBtn423')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup423"><code class="language-javascript text-sm text-gray-800">// lib/fallback/supabaseFallback.tsx
// This creates a resilient data layer that gracefully handles Supabase outages
import { createClient } from '@supabase/supabase-js';
function isFoodTruckData(obj) {
    return (typeof obj === 'object' &amp;&amp;
        obj !== null &amp;&amp;
        'id' in obj &amp;&amp;
        'name' in obj &amp;&amp;
        'cuisine_type' in obj &amp;&amp;
        'price_range' in obj);
}
function isCachedData(obj) {
    return (typeof obj === 'object' &amp;&amp;
        obj !== null &amp;&amp;
        'trucks' in obj &amp;&amp;
        Array.isArray(obj.trucks) &amp;&amp;
        'timestamp' in obj &amp;&amp;
        'lastSuccessfulUpdate' in obj);
}
// Helper function to safely parse JSON with type validation
function safeJsonParse(jsonString, typeGuard) {
    try {
        const parsed = JSON.parse(jsonString);
        return typeGuard(parsed) ? parsed : undefined;
    }
    catch {
        return undefined;
    }
}
// Helper function to check if we're in a browser environment
function isBrowserEnvironment() {
    // Fixed: Use direct comparison with undefined instead of typeof
    return typeof globalThis !== 'undefined' &amp;&amp;
        globalThis.window != undefined &amp;&amp;
        globalThis.window === globalThis;
}
class SupabaseFallbackManager {
    CACHE_KEY = 'food-trucks-cache';
    TRUCK_CACHE_KEY_PREFIX = 'food-truck-';
    CACHE_DURATION = 24 * 60 * 60 * 1000; // 24 hours in milliseconds
    supabase;
    constructor() {
        if (process.env.NEXT_PUBLIC_SUPABASE_URL === undefined || process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY === undefined) {
            throw new Error('Supabase URL and Anon Key are required!');
        }
        this.supabase = createClient(process.env.NEXT_PUBLIC_SUPABASE_URL, process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY);
    }
    /**
     * This is your main data fetching function that handles all the fallback logic
     * Think of it as your &quot;smart&quot; data fetcher that adapts to different situations
     */
    async getFoodTrucks() {
        try {
            // First, try to get fresh data from Supabase
            const freshData = await this.fetchFromSupabase();
            if (freshData.length &gt; 0) {
                // Success! Cache this data for future fallback use
                this.cacheData(freshData);
                return {
                    trucks: freshData,
                    isFromCache: false,
                    lastUpdate: 'Just now',
                    status: 'fresh'
                };
            }
            // If we reach here, Supabase returned empty results
            // This might mean no trucks are available, or there's a data issue
            return this.handleFallbackScenario();
        }
        catch (error) {
            // Supabase is definitely having issues - engage fallback mode
            console.warn('Supabase unavailable, using fallback strategy:', error);
            return this.handleFallbackScenario();
        }
    }
    async getFoodTruckById(id) {
        const cachedTruck = this.getCachedTruck(id);
        if (cachedTruck !== null) {
            return cachedTruck;
        }
        try {
            const { data, error } = await this.supabase
                .from('food_trucks')
                .select('*')
                .eq('id', id)
                .single();
            if (error !== null) {
                throw new Error(`Supabase error: ${error.message}`);
            }
            // Fixed: Properly handle the data assignment with type checking
            if (data !== null &amp;&amp; isFoodTruckData(data)) {
                this.cacheTruck(data);
                return data;
            }
            return null;
        }
        catch (error) {
            console.warn(`Failed to fetch truck with id ${id} from Supabase, returning null.`, error);
            return null;
        }
    }
    /**
     * This handles the actual Supabase communication
     * Separated so you can easily modify your existing query logic
     */
    async fetchFromSupabase() {
        console.log(' Connecting to Supabase...');
        console.log(' Supabase URL:', process.env.NEXT_PUBLIC_SUPABASE_URL);
        console.log(' Anon key present:', !!process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY);
        try {
            // The key is to set a reasonable timeout so we don't wait forever
            const response = await this.supabase
                .from('food_trucks')
                .select('*')
                .abortSignal(AbortSignal.timeout(10000)); // 10 second timeout
            console.log(' Raw Supabase response:', response);
            console.log(' Response error:', response.error);
            console.log(' Response data type:', typeof response.data);
            console.log(' Response data length:', Array.isArray(response.data) ? response.data.length : 'Not an array');
            if (response.error !== null) {
                console.error(' Supabase query error details:', {
                    message: response.error.message,
                    details: response.error.details,
                    hint: response.error.hint,
                    code: response.error.code
                });
                throw new Error(`Supabase error: ${response.error.message}`);
            }
            // Fixed: Properly handle the data with explicit null checking
            if (response.data != undefined &amp;&amp; Array.isArray(response.data)) {
                console.log(' Found', response.data.length, 'raw records from Supabase');
                if (response.data.length &gt; 0) {
                    console.log(' Sample record:', JSON.stringify(response.data[0], null, 2));
                }
                const filteredData = response.data.filter((item) =&gt; {
                    const isValid = isFoodTruckData(item);
                    if (!isValid) {
                        console.warn(' Invalid food truck data found:', item);
                    }
                    return isValid;
                });
                console.log(' Filtered to', filteredData.length, 'valid food trucks');
                return filteredData;
            }
            console.warn(' No data returned from Supabase or data is not an array');
            return [];
        }
        catch (error) {
            console.error(' Error in fetchFromSupabase:', error);
            throw error;
        }
    }
    /**
     * This is where the magic happens - graceful degradation
     * When Supabase fails, we still provide value to users
     */
    handleFallbackScenario() {
        const cachedData = this.getCachedData();
        if (cachedData !== null) {
            const age = Date.now() - cachedData.timestamp;
            const isStale = age &gt; this.CACHE_DURATION;
            return {
                trucks: cachedData.trucks,
                isFromCache: true,
                lastUpdate: cachedData.lastSuccessfulUpdate,
                status: isStale ? 'stale' : 'cached'
            };
        }
        // No cached data available - this is the worst case scenario
        return {
            trucks: [],
            isFromCache: false,
            lastUpdate: 'Never',
            status: 'unavailable'
        };
    }
    /**
     * Stores successful data fetches for later use
     * This runs every time we successfully get data from Supabase
     */
    cacheData(trucks) {
        const cacheData = {
            trucks,
            timestamp: Date.now(),
            lastSuccessfulUpdate: new Date().toLocaleString()
        };
        try {
            // In a browser environment, use localStorage
            if (isBrowserEnvironment()) {
                globalThis.window.localStorage.setItem(this.CACHE_KEY, JSON.stringify(cacheData));
            }
            // In a server environment, you might use a file or Redis
            // For now, we'll just log that we would cache this data
            console.info(`Cached ${trucks.length} trucks at ${cacheData.lastSuccessfulUpdate}`);
        }
        catch (error) {
            // Caching failed, but that's not critical - log and continue
            console.warn('Failed to cache data:', error);
        }
    }
    cacheTruck(truck) {
        try {
            if (isBrowserEnvironment()) {
                const cacheKey = `${this.TRUCK_CACHE_KEY_PREFIX}${truck.id}`;
                globalThis.window.localStorage.setItem(cacheKey, JSON.stringify(truck));
            }
        }
        catch (error) {
            console.warn(`Failed to cache truck with id ${truck.id}:`, error);
        }
    }
    getCachedTruck(id) {
        try {
            if (isBrowserEnvironment()) {
                const cacheKey = `${this.TRUCK_CACHE_KEY_PREFIX}${id}`;
                const cached = globalThis.window.localStorage.getItem(cacheKey);
                if (cached !== null) {
                    // Fixed: Return the parsed result or null instead of undefined
                    return safeJsonParse(cached, isFoodTruckData) ?? null;
                }
            }
            return null;
        }
        catch (error) {
            console.warn(`Failed to retrieve cached truck with id ${id}:`, error);
            return null;
        }
    }
    /**
     * Retrieves cached data when Supabase is unavailable
     * This is your safety net
     */
    getCachedData() {
        try {
            if (isBrowserEnvironment()) {
                const cached = globalThis.window.localStorage.getItem(this.CACHE_KEY);
                if (cached !== null) {
                    // Fixed: Return the parsed result or null instead of undefined
                    return safeJsonParse(cached, isCachedData) ?? null;
                }
            }
            return null;
        }
        catch (error) {
            console.warn('Failed to retrieve cached data:', error);
            return null;
        }
    }
}
// Usage in your components - this replaces your direct Supabase calls
export const supabaseFallback = new SupabaseFallbackManager();
// Example React hook that uses the fallback system
import { useState, useEffect } from 'react';
export function useFoodTrucks() {
    const [trucks, setTrucks] = useState([]);
    const [loading, setLoading] = useState(true);
    const [dataStatus, setDataStatus] = useState({
        isFromCache: false,
        lastUpdate: '',
        status: 'fresh'
    });
    useEffect(() =&gt; {
        const loadTrucks = async () =&gt; {
            try {
                const result = await supabaseFallback.getFoodTrucks();
                setTrucks(result.trucks);
                setDataStatus({
                    isFromCache: result.isFromCache,
                    lastUpdate: result.lastUpdate,
                    status: result.status
                });
            }
            catch (error) {
                console.error('Failed to load trucks:', error);
                // Even this fails, we still want to show something
                setDataStatus({
                    isFromCache: false,
                    lastUpdate: 'Error',
                    status: 'unavailable'
                });
            }
            finally {
                setLoading(false);
            }
        };
        void loadTrucks(); // Use void to explicitly ignore the Promise
    }, []);
    return { trucks, loading, dataStatus };
}
// Component that displays appropriate messages based on data status
export function DataStatusIndicator({ status, }) {
    if (status.status === 'fresh') {
        // Fixed: Return null instead of undefined when no component should render
        return;
    }
    if (status.status === 'cached') {
        return (&lt;</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/data-quality/placeholderUtils.js (Line 1:1 - Line 141:2), C:/AI/food-truck-finder-poc/dist/lib/lib/data-quality/placeholderUtils.js (Line 1:1 - Line 141:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn424" onclick="toggleCodeBlock('cloneGroup424', 'expandBtn424', 'collapseBtn424')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn424" onclick="toggleCodeBlock('cloneGroup424', 'expandBtn424', 'collapseBtn424')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup424"><code class="language-javascript text-sm text-gray-800">/**
* Returns an array of regular expressions that identify placeholder patterns.
* @example
* getPlaceholderPatterns()
* [ /undefined/i, /placeholder/i, /example\.com/i, /test\s*truck/i, /lorem\s*ipsum/i, /\bna\b/i, /\bn\/a\b/i, /^0+$/, /^null$/i ]
* @returns {RegExp[]} An array of regular expressions to match various placeholder values.
* @description
*   - Regular expressions cover common placeholder values used in data.
*   - Patterns are designed to be case insensitive to support a wider range of inputs.
*   - Contains specific patterns like 'example.com' to catch domain placeholders.
*   - Includes matches for numeric placeholders like '000...' and 'null'.
*/
export function getPlaceholderPatterns() {
    return [
        /undefined/i,
        /placeholder/i,
        /example\.com/i,
        /test\s*truck/i,
        /lorem\s*ipsum/i,
        /\bna\b/i,
        /\bn\/a\b/i,
        /^0+$/,
        /^null$/i,
    ];
}
/**
* Checks the food truck's properties for placeholder patterns and sets them to undefined if a pattern is found.
* @example
* checkForPlaceholders(foodTruckObj, [/\b(?:N\/A|TBD|Unknown)\b/, /^{.+}$/])
* {name: undefined, description: undefined}
* @param {FoodTruck} truck - The food truck object which may contain placeholder text in its properties.
* @param {RegExp[]} patterns - Array of regex patterns used to test against food truck properties.
* @returns {Partial&lt;FoodTruck&gt;} A partial food truck object with properties set to undefined if placeholders are detected.
* @description
*   - The function does not modify the original truck object; it returns a new one.
*   - Handles undefined properties seamlessly to prevent errors during regex testing.
*   - Assumes that the RegExp provided will effectively identify placeholder patterns.
*/
export function checkForPlaceholders(truck, patterns) {
    const updates = {};
    if (truck.name &amp;&amp; patterns.some((pattern) =&gt; pattern.test(truck.name ?? ''))) {
        updates.name = undefined;
    }
    if (truck.description != undefined &amp;&amp;
        patterns.some((pattern) =&gt; pattern.test(truck.description ?? ''))) {
        updates.description = undefined;
    }
    if (truck.price_range != undefined &amp;&amp;
        patterns.some((pattern) =&gt; pattern.test(truck.price_range ?? ''))) {
        updates.price_range = undefined;
    }
    return updates;
}
/**
* Processes a FoodTruck object for placeholders and returns updates.
* @example
* processTruckForPlaceholders(truck, [/pattern1/g, /pattern2/g])
* { name: 'Updated Truck Name', address: 'Updated Address' }
* @param {FoodTruck} truck - The FoodTruck object to be processed for placeholders.
* @param {Array&lt;RegExp&gt;} patterns - Array of regular expressions to identify placeholders.
* @returns {Partial&lt;FoodTruck&gt;} An object containing the updated fields of the FoodTruck.
* @description
*   - Performs checks for placeholders in basic information of the truck.
*   - Processes contact information of the FoodTruck for placeholders.
*   - Assesses and updates address details for placeholders.
*   - Combines updates from basic, contact, and address information into a single object.
*/
export function processTruckForPlaceholders(truck, patterns) {
    const basicInfoUpdates = checkForPlaceholders(truck, patterns);
    const contactInfoUpdates = processContactInfoForPlaceholders(truck, patterns);
    const addressUpdates = processAddressForPlaceholders(truck, patterns);
    const updates = {
        ...basicInfoUpdates,
        ...getContactInfoUpdates(truck, contactInfoUpdates),
        ...getLocationUpdates(truck, addressUpdates),
    };
    return updates;
}
function getContactInfoUpdates(truck, contactInfoUpdates) {
    if (Object.keys(contactInfoUpdates).length &gt; 0) {
        return { contact_info: { ...truck.contact_info, ...contactInfoUpdates } };
    }
    return {};
}
function getLocationUpdates(truck, addressUpdates) {
    if (Object.keys(addressUpdates).length &gt; 0) {
        return { current_location: { ...truck.current_location, ...addressUpdates } };
    }
    return {};
}
/**
* Filters contact information of a food truck based on specified patterns.
* @example
* processContactInfoForPlaceholders(truck, patterns)
* returns filtered contact info with some fields possibly undefined
* @param {FoodTruck} truck - The food truck object containing contact information.
* @param {RegExp[]} patterns - Array of regular expressions to match against contact info.
* @returns {Partial&lt;FoodTruck['contact_info']&gt;} Returns contact information with fields set to undefined if they match any pattern.
* @description
*   - Checks phone, website, and email properties for matches with given patterns.
*   - Sets properties to undefined if they match any pattern.
*/
function processContactInfoForPlaceholders(truck, patterns) {
    const cleanContact = {};
    if (truck.contact_info?.phone !== undefined &amp;&amp;
        patterns.some((pattern) =&gt; pattern.test(truck.contact_info.phone ?? ''))) {
        cleanContact.phone = undefined;
    }
    if (truck.contact_info?.website !== undefined &amp;&amp;
        patterns.some((pattern) =&gt; pattern.test(truck.contact_info.website ?? ''))) {
        cleanContact.website = undefined;
    }
    if (truck.contact_info?.email !== undefined &amp;&amp;
        patterns.some((pattern) =&gt; pattern.test(truck.contact_info.email ?? ''))) {
        cleanContact.email = undefined;
    }
    return cleanContact;
}
/**
 * Processes the current location of a food truck by checking against patterns and updating placeholders.
 * @example
 * const truck = { current_location: { address: '123 Fake St' } };
 * const patterns = [/Fake/];
 * processAddressForPlaceholders(truck, patterns);
 * // Returns: { address: undefined }
 * @param {FoodTruck} truck - The food truck object containing the current location data.
 * @param {RegExp[]} patterns - An array of regular expression patterns used to identify placeholders in the address.
 * @returns {Partial&lt;FoodTruck['current_location']&gt;} An object containing the updated location data with address potentially set to undefined.
 * @description
 *   - The function checks whether the address of the food truck's current location matches any of the provided RegExp patterns.
 *   - If a match is found, the address in the returned object is set to undefined.
 *   - It ensures details of the truck's location can be sanitized by placeholder detection.
 */
function processAddressForPlaceholders(truck, patterns) {
    const updatedLocation = {};
    if (truck.current_location?.address !== undefined &amp;&amp;
        patterns.some((pattern) =&gt; pattern.test(truck.current_location.address ?? ''))) {
        updatedLocation.address = undefined;
    }
    return updatedLocation;
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/data-quality/duplicatePrevention.js (Line 5:43 - Line 333:7), C:/AI/food-truck-finder-poc/dist/lib/lib/data-quality/duplicatePrevention.js (Line 5:27 - Line 301:8)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn427" onclick="toggleCodeBlock('cloneGroup427', 'expandBtn427', 'collapseBtn427')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn427" onclick="toggleCodeBlock('cloneGroup427', 'expandBtn427', 'collapseBtn427')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup427"><code class="language-javascript text-sm text-gray-800">;
// Duplicate detection configuration
export const DUPLICATE_DETECTION_CONFIG = {
    // Similarity thresholds (0.0 = no match, 1.0 = exact match)
    thresholds: {
        name: 0.85, // High threshold for name matching
        location: 0.9, // Very high threshold for location matching
        phone: 1, // Exact match for phone numbers
        website: 1, // Exact match for websites
        overall: 0.8, // Overall similarity threshold
    },
    // Weight factors for different fields
    weights: {
        name: 0.4, // 40% weight for name similarity
        location: 0.3, // 30% weight for location similarity
        contact: 0.2, // 20% weight for contact info similarity
        menu: 0.1, // 10% weight for menu similarity
    },
};
/**
 * Advanced Duplicate Prevention Service
 */
export class DuplicatePreventionService {
    /**
     * Check if a food truck is a duplicate of existing trucks
     */
    static async checkForDuplicates(candidateTruck) {
        try {
            // Get all existing trucks for comparison
            const existingTrucksResult = await FoodTruckService.getAllTrucks();
            if ('error' in existingTrucksResult) {
                console.error('Error fetching existing trucks:', existingTrucksResult.error);
                return {
                    isDuplicate: false,
                    matches: [],
                    action: 'create',
                    reason: `Error fetching existing trucks: ${existingTrucksResult.error}`,
                };
            }
            const existingTrucks = existingTrucksResult.trucks;
            const matches = [];
            for (const existingTruck of existingTrucks) {
                console.log(`Checking existing truck with ID: ${existingTruck.id}`);
                const similarity = this.calculateSimilarity(candidateTruck, existingTruck);
                if (similarity.overall &gt;= DUPLICATE_DETECTION_CONFIG.thresholds.overall) {
                    matches.push({
                        existingTruck,
                        similarity: similarity.overall,
                        matchedFields: similarity.matchedFields,
                        confidence: this.getConfidenceLevel(similarity.overall),
                        recommendation: this.getRecommendation(similarity),
                    });
                }
            }
            return this.processDuplicateMatches(matches, candidateTruck);
        }
        catch (error) {
            console.error('Error checking for duplicates:', error);
            return {
                isDuplicate: false,
                matches: [],
                action: 'create',
                reason: 'An unexpected error occurred during duplicate detection - proceeding with creation',
            };
        }
    }
    /**
     * Processes the matches found during duplicate detection and returns the result.
     */
    static processDuplicateMatches(matches, candidateTruck) {
        // Sort matches by similarity (highest first)
        matches.sort((a, b) =&gt; b.similarity - a.similarity);
        const bestMatch = matches.length &gt; 0 ? matches[0] : undefined;
        const isDuplicate = matches.length &gt; 0;
        return {
            isDuplicate,
            matches,
            bestMatch,
            action: this.determineAction(matches, candidateTruck),
            reason: this.generateReason(matches, candidateTruck),
        };
    }
    /**
     * Calculate similarity between two food trucks
     */
    static calculateSimilarity(candidate, existing) {
        const breakdown = {};
        const matchedFields = [];
        // Name similarity
        const nameSimilarity = this.calculateStringSimilarity(candidate.name ?? '', existing.name ?? '');
        breakdown.name = nameSimilarity;
        if (nameSimilarity &gt;= DUPLICATE_DETECTION_CONFIG.thresholds.name) {
            matchedFields.push('name');
        }
        // Location similarity
        const locationSimilarity = this.calculateLocationSimilarity(candidate.current_location, existing.current_location);
        breakdown.location = locationSimilarity;
        if (locationSimilarity &gt;= DUPLICATE_DETECTION_CONFIG.thresholds.location) {
            matchedFields.push('location');
        }
        // Contact similarity
        const contactSimilarity = this.calculateContactSimilarity(candidate.contact_info, existing.contact_info);
        breakdown.contact = contactSimilarity;
        if (contactSimilarity &gt;= DUPLICATE_DETECTION_CONFIG.thresholds.phone) {
            matchedFields.push('contact');
        }
        // Menu similarity (basic)
        const menuSimilarity = this.calculateMenuSimilarity(candidate.menu, existing.menu);
        breakdown.menu = menuSimilarity;
        if (menuSimilarity &gt; 0.7) {
            matchedFields.push('menu');
        }
        // Calculate weighted overall similarity
        const overall = nameSimilarity * DUPLICATE_DETECTION_CONFIG.weights.name +
            locationSimilarity * DUPLICATE_DETECTION_CONFIG.weights.location +
            contactSimilarity * DUPLICATE_DETECTION_CONFIG.weights.contact +
            menuSimilarity * DUPLICATE_DETECTION_CONFIG.weights.menu;
        return { overall, matchedFields, breakdown };
    }
    /**
     * Normalize food truck names for better comparison
     * Removes common suffixes, normalizes case, handles punctuation variations
     */
    static normalizeFoodTruckName(name) {
        if (!name)
            return '';
        
        return name
            .toLowerCase()
            .trim()
            // Normalize apostrophes (handle different Unicode apostrophes)
            .replace(/[\u2018\u2019\u0060\u00B4]/g, &quot;'&quot;)
            // Remove common food truck suffixes/prefixes
            .replace(/\s*\b(food\s+truck|food\s+trailer|mobile\s+kitchen|street\s+food|food\s+cart)\b\s*/gi, '')
            // Remove extra whitespace and normalize punctuation
            .replace(/\s+/g, ' ')
            .replace(/[^\w\s&amp;'-]/g, '')
            .trim();
    }

    /**
     * Calculate string similarity using Levenshtein distance with enhanced food truck name handling
     */
    static calculateStringSimilarity(str1, str2) {
        if (!str1 || !str2)
            return 0;
        
        // Normalize food truck names for better comparison
        const normalized1 = this.normalizeFoodTruckName(str1);
        const normalized2 = this.normalizeFoodTruckName(str2);
        
        if (normalized1 === normalized2)
            return 1;
            
        // Also check if one is a substring of the other (for cases like &quot;Page's Okra Grill&quot; vs &quot;Page's Okra Grill Food Truck&quot;)
        const isSubstring = normalized1.includes(normalized2) || normalized2.includes(normalized1);
        if (isSubstring &amp;&amp; (normalized1.length &gt; 0 &amp;&amp; normalized2.length &gt; 0)) {
            const minLength = Math.min(normalized1.length, normalized2.length);
            const maxLength = Math.max(normalized1.length, normalized2.length);
            // High similarity for substring matches (0.8 to 0.95 based on length ratio)
            return 0.8 + (0.15 * (minLength / maxLength));
        }
        
        // Calculate Levenshtein distance on normalized strings
        const matrix = [];
        const len1 = normalized1.length;
        const len2 = normalized2.length;
        for (let i = 0; i &lt;= len1; i += 1) {
            matrix[i] = [i];
        }
        for (let j = 0; j &lt;= len2; j += 1) {
            matrix[0][j] = j;
        }
        for (let i = 1; i &lt;= len1; i += 1) {
            // eslint-disable-next-line sonarjs/no-redundant-assignments
            for (let j = 1; j &lt;= len2; j += 1) {
                const cost = normalized1[i - 1] === normalized2[j - 1] ? 0 : 1;
                matrix[i][j] = Math.min(matrix[i - 1][j] + 1, // deletion
                matrix[i][j - 1] + 1, // insertion
                matrix[i - 1][j - 1] + cost);
            }
        }
        const distance = matrix[len1][len2];
        const maxLength = Math.max(len1, len2);
        return maxLength === 0 ? 1 : 1 - distance / maxLength;
    }
    /**
     * Calculate location similarity
     */
    static calculateLocationSimilarity(loc1, loc2) {
        if (!loc1 || !loc2)
            return 0;
        let similarity = 0;
        let factors = 0;
        // Address similarity
        if (loc1.address &amp;&amp; loc2.address) {
            similarity += this.calculateStringSimilarity(loc1.address, loc2.address);
            factors += 1;
        }
        // GPS coordinate similarity (within 100 meters = high similarity)
        if (loc1.lat &amp;&amp; loc1.lng &amp;&amp; loc2.lat &amp;&amp; loc2.lng) {
            const distance = this.calculateGPSDistance(loc1.lat, loc1.lng, loc2.lat, loc2.lng);
            // Distance similarity (closer = higher similarity)
            const distanceSimilarity = distance &lt;= 0.1 ? 1 : Math.max(0, 1 - distance / 1); // 1km max
            similarity += distanceSimilarity;
            factors += 1;
        }
        return factors &gt; 0 ? similarity / factors : 0;
    }
    /**
     * Calculate GPS distance in kilometers
     */
    static calculateGPSDistance(lat1, lng1, lat2, lng2) {
        const R = 6371; // Earth's radius in kilometers
        const dLat = ((lat2 - lat1) * Math.PI) / 180;
        const dLng = ((lng2 - lng1) * Math.PI) / 180;
        const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
            Math.cos((lat1 * Math.PI) / 180) *
                Math.cos((lat2 * Math.PI) / 180) *
                Math.sin(dLng / 2) *
                Math.sin(dLng / 2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        return R * c;
    }
    /**
     * Calculate contact similarity
     */
    static calculateContactSimilarity(contact1, contact2) {
        if (!contact1 || !contact2)
            return 0;
        let matches = 0;
        let total = 0;
        // Phone number exact match
        if (contact1.phone != undefined &amp;&amp; contact2.phone != undefined) {
            const phone1 = contact1.phone.replaceAll(/\D/g, ''); // Remove non-digits
            const phone2 = contact2.phone.replaceAll(/\D/g, '');
            if (phone1 === phone2)
                matches += 1;
            total += 1;
        }
        // Website exact match
        if (contact1.website != undefined &amp;&amp; contact2.website != undefined) {
            const url1 = contact1.website
                .toLowerCase()
                .replace(/^https?:\/\//, '')
                .replace(/\/$/, '');
            const url2 = contact2.website
                .toLowerCase()
                .replace(/^https?:\/\//, '')
                .replace(/\/$/, '');
            if (url1 === url2)
                matches += 1;
            total += 1;
        }
        // Email similarity
        if (contact1.email != undefined &amp;&amp; contact2.email != undefined) {
            if (contact1.email.toLowerCase() === contact2.email.toLowerCase())
                matches += 1;
            total += 1;
        }
        return total &gt; 0 ? matches / total : 0;
    }
    /**
     * Calculate menu similarity (basic implementation)
     */
    static calculateMenuSimilarity(menu1, menu2) {
        if (!menu1 || !menu2 || menu1.length === 0 || menu2.length === 0)
            return 0;
        // Simple category name matching
        const categories1 = menu1
            .map((cat) =&gt; cat.category?.toLowerCase() ?? '')
            .filter(Boolean);
        const categories2 = menu2
            .map((cat) =&gt; cat.category?.toLowerCase() ?? '')
            .filter(Boolean);
        const commonCategories = categories1.filter((cat) =&gt; categories2.includes(cat));
        const totalCategories = new Set([...categories1, ...categories2]).size;
        return totalCategories &gt; 0 ? commonCategories.length / totalCategories : 0;
    }
    /**
     * Get confidence level based on similarity score
     */
    static getConfidenceLevel(similarity) {
        if (similarity &gt;= 0.95)
            return 'high';
        if (similarity &gt;= 0.85)
            return 'medium';
        return 'low';
    }
    /**
     * Get recommendation based on similarity analysis
     */
    static getRecommendation(similarity) {
        if (similarity.overall &gt;= 0.95)
            return 'merge';
        if (similarity.overall &gt;= 0.9)
            return 'update';
        if (similarity.overall &gt;= 0.8)
            return 'manual_review';
        return 'skip';
    }
    /**
     * Determine action based on matches
     */
    static determineAction(matches, _candidate) {
        if (matches.length === 0)
            return 'create';
        const bestMatch = matches[0];
        if (bestMatch.confidence === 'high') {
            const { recommendation } = bestMatch;
            if (recommendation === 'merge' || recommendation === 'update') {
                return recommendation;
            }
            return 'manual_review';
        }
        return 'manual_review';
    }
    /**
     * Generate human-readable reason
     */
    static generateReason(matches, _candidate) {
        if (matches.length === 0) {
            return 'No duplicates found - safe to create new truck entry';
        }
        const bestMatch = matches[0];
        const similarity = Math.round(bestMatch.similarity * 100);
        return `Found ${matches.length} potential duplicate(s). Best match: ${similarity}% similarity with &quot;${bestMatch.existingTruck.name}&quot; (matched: ${bestMatch.matchedFields.join(', ')})`;
    }
    static</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/data-quality/duplicatePrevention.js (Line 360:5 - Line 410:2), C:/AI/food-truck-finder-poc/dist/lib/lib/data-quality/duplicatePrevention.js (Line 298:5 - Line 347:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn428" onclick="toggleCodeBlock('cloneGroup428', 'expandBtn428', 'collapseBtn428')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn428" onclick="toggleCodeBlock('cloneGroup428', 'expandBtn428', 'collapseBtn428')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup428"><code class="language-javascript text-sm text-gray-800">}

    /**
     * Merge duplicate truck data intelligently
     */
    static async mergeDuplicates(targetId, sourceId) {
        const targetResult = await FoodTruckService.getTruckById(targetId);
        const sourceResult = await FoodTruckService.getTruckById(sourceId);
        if ('error' in targetResult) {
            return {
                error: `Failed to retrieve target truck with ID ${targetId}: ${targetResult.error}`,
            };
        }
        if ('error' in sourceResult) {
            return {
                error: `Failed to retrieve source truck with ID ${sourceId}: ${sourceResult.error}`,
            };
        }
        const target = targetResult;
        const source = sourceResult;
        // Merge logic: prefer non-null, more complete data
        const mergedData = {
            name: target.name ?? source.name,
            description: target.description ?? source.description,
            cuisine_type: (target.cuisine_type?.length ?? 0) &gt; 0 ? target.cuisine_type : source.cuisine_type,
            price_range: target.price_range ?? source.price_range,
            current_location: target.current_location ?? source.current_location,
            contact_info: {
                ...source.contact_info,
                ...target.contact_info, // Target takes precedence
            },
            operating_hours: target.operating_hours ?? source.operating_hours,
            menu: (target.menu?.length ?? 0) &gt; 0 ? target.menu : source.menu,
            social_media: {
                ...source.social_media,
                ...target.social_media,
            },
            source_urls: [...new Set([...(target.source_urls ?? []), ...(source.source_urls ?? [])])],
            last_scraped_at: new Date().toISOString(),
        };
        // Update target with merged data
        const updatedTruckResult = await FoodTruckService.updateTruck(targetId, mergedData);
        if ('error' in updatedTruckResult) {
            return {
                error: `Failed to update target truck with merged data: ${updatedTruckResult.error}`,
            };
        }
        console.info(`Merged truck ${sourceId} into ${targetId}`);
        return updatedTruckResult;
    }
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/data-quality/batchCleanup.js (Line 15:5 - Line 48:7), C:/AI/food-truck-finder-poc/dist/lib/lib/data-quality/batchCleanup.js (Line 15:5 - Line 48:7)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn429" onclick="toggleCodeBlock('cloneGroup429', 'expandBtn429', 'collapseBtn429')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn429" onclick="toggleCodeBlock('cloneGroup429', 'expandBtn429', 'collapseBtn429')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup429"><code class="language-javascript text-sm text-gray-800">static async runFullCleanup(options = {}) {
        const startTime = Date.now();
        const { batchSize = 50, dryRun = false, operations = [
            'remove_placeholders',
            'normalize_phone',
            'fix_coordinates',
            'update_quality_scores',
            'merge_duplicates',
        ], } = options;
        console.info(`Starting batch cleanup (${dryRun ? 'DRY RUN' : 'LIVE'})...`);
        const result = this.initializeCleanupResult();
        try {
            const allTrucks = await FoodTruckService.getAllTrucks();
            result.totalProcessed = allTrucks.total;
            await this.processTrucksInBatches(allTrucks.trucks, {
                batchSize,
                operations,
                dryRun,
                result,
            });
            return this.finalizeCleanupResult(result, startTime);
        }
        catch (error) {
            console.error('Batch cleanup failed:', error);
            throw error;
        }
    }
    /**
    * Initializes and returns a new BatchCleanupResult object with default values.
    * @example
    * initializeCleanupResult()
    * { totalProcessed: 0, operations: [], summary: { trucksImproved: 0, duplicatesRemoved: 0, qualityScoreImprovement: 0, placeholdersRemoved: 0 }, duration: 0 }
    * @returns {BatchCleanupResult} A new BatchCleanupResult object with all properties set to initial default values.
    */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/data-quality/batchCleanup.js (Line 49:5 - Line 84:8), C:/AI/food-truck-finder-poc/dist/lib/lib/data-quality/batchCleanup.js (Line 49:5 - Line 84:8)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn430" onclick="toggleCodeBlock('cloneGroup430', 'expandBtn430', 'collapseBtn430')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn430" onclick="toggleCodeBlock('cloneGroup430', 'expandBtn430', 'collapseBtn430')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup430"><code class="language-javascript text-sm text-gray-800">static initializeCleanupResult() {
        return {
            totalProcessed: 0,
            operations: [],
            summary: {
                trucksImproved: 0,
                duplicatesRemoved: 0,
                qualityScoreImprovement: 0,
                placeholdersRemoved: 0,
            },
            duration: 0,
        };
    }
    static finalizeCleanupResult(result, startTime) {
        result.summary = this.calculateSummary(result.operations);
        result.duration = Date.now() - startTime;
        console.info(`Batch cleanup completed in ${result.duration}ms`);
        return result;
    }
    /**
     * Processes food trucks in batches, executing specified operations on each batch.
     * @example
     * processTrucksInBatches(truckList, { batchSize: 10, operations: ['clean'], dryRun: true, result: batchResult })
     * // It executes 'clean' operation on batches of 10 trucks without making permanent changes.
     * @param {FoodTruck[]} trucks - Array of food trucks to be processed in batches.
     * @param {object} options - Options object containing batchSize, operations, dryRun, and result.
     * @param {number} options.batchSize - Number of trucks in each batch.
     * @param {CleanupOperation['type'][]} options.operations - Array of operation types to be executed on each batch.
     * @param {boolean} options.dryRun - If true, operations are executed in simulation mode without permanent changes.
     * @param {BatchCleanupResult} options.result - Stores the results of operations performed on batches.
     * @returns {Promise&lt;void&gt;} Completes processing batches without a return value.
     * @description
     *   - Uses async function to allow non-blocking execution of operations.
     *   - Collects and stores results of batch operations separately, keeping track of each operation's outcome.
     *   - Iterates over arrays using slicing to dynamically create batches for processing.
     */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/data-quality/batchCleanup.js (Line 85:5 - Line 96:8), C:/AI/food-truck-finder-poc/dist/lib/lib/data-quality/batchCleanup.js (Line 85:5 - Line 96:8)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn431" onclick="toggleCodeBlock('cloneGroup431', 'expandBtn431', 'collapseBtn431')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn431" onclick="toggleCodeBlock('cloneGroup431', 'expandBtn431', 'collapseBtn431')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup431"><code class="language-javascript text-sm text-gray-800">static async processTrucksInBatches(trucks, { batchSize, operations, dryRun, result, }) {
        for (let i = 0; i &lt; trucks.length; i += batchSize) {
            const batch = trucks.slice(i, i + batchSize);
            for (const op of operations) {
                const opResult = await this.runOperation(op, batch, dryRun);
                result.operations.push(opResult);
            }
        }
    }
    /**
     * Run a specific cleanup operation
     */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/data-quality/batchCleanup.js (Line 97:5 - Line 143:8), C:/AI/food-truck-finder-poc/dist/lib/lib/data-quality/batchCleanup.js (Line 97:5 - Line 143:8)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn432" onclick="toggleCodeBlock('cloneGroup432', 'expandBtn432', 'collapseBtn432')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn432" onclick="toggleCodeBlock('cloneGroup432', 'expandBtn432', 'collapseBtn432')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup432"><code class="language-javascript text-sm text-gray-800">static async runOperation(type, trucks, dryRun) {
        const operation = {
            type,
            description: this.getOperationDescription(type),
            affectedCount: 0,
            successCount: 0,
            errorCount: 0,
            errors: [],
        };
        const operationRunners = {
            remove_placeholders: this.runRemovePlaceholders,
            normalize_phone: this.runNormalizePhoneNumbers,
            fix_coordinates: this.runFixCoordinates,
            update_quality_scores: this.runUpdateQualityScores,
            merge_duplicates: this.runMergeDuplicates,
        };
        try {
            const runner = operationRunners[type];
            if (runner) {
                return await runner.call(this, trucks, dryRun, operation);
            }
            operation.errors.push(`Unknown operation type: ${String(type)}`);
            return operation;
        }
        catch (error) {
            operation.errors.push(`Operation failed: ${error instanceof Error ? error.message : String(error)}`);
            return operation;
        }
    }
    static runRemovePlaceholders = async (trucks, dryRun, operation) =&gt; {
        return await this.removePlaceholders(trucks, dryRun, operation);
    };
    static runNormalizePhoneNumbers = async (trucks, dryRun, operation) =&gt; {
        return await this.normalizePhoneNumbers(trucks, dryRun, operation);
    };
    static runFixCoordinates = async (trucks, dryRun, operation) =&gt; {
        return await this.fixCoordinates(trucks, dryRun, operation);
    };
    static runUpdateQualityScores = async (trucks, dryRun, operation) =&gt; {
        return await this.updateQualityScores(trucks, dryRun, operation);
    };
    static runMergeDuplicates = async (trucks, dryRun, operation) =&gt; {
        return await this.mergeDuplicates(trucks, dryRun, operation);
    };
    /**
     * Remove placeholder and mock data
     */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/data-quality/batchCleanup.js (Line 144:5 - Line 169:8), C:/AI/food-truck-finder-poc/dist/lib/lib/data-quality/batchCleanup.js (Line 144:5 - Line 169:8)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn433" onclick="toggleCodeBlock('cloneGroup433', 'expandBtn433', 'collapseBtn433')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn433" onclick="toggleCodeBlock('cloneGroup433', 'expandBtn433', 'collapseBtn433')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup433"><code class="language-javascript text-sm text-gray-800">static async removePlaceholders(trucks, dryRun, operation) {
        const placeholderPatterns = getPlaceholderPatterns();
        const promises = trucks.map((truck) =&gt; this.processSingleTruckForPlaceholders(truck, placeholderPatterns, dryRun, operation));
        await Promise.all(promises);
        return operation;
    }
    static async processSingleTruckForPlaceholders(truck, patterns, dryRun, operation) {
        const updates = processTruckForPlaceholders(truck, patterns);
        if (updates &amp;&amp; Object.keys(updates).length &gt; 0) {
            await this.performUpdateOperation(truck.id, updates, dryRun, operation);
        }
    }
    /**
     * Perform an update operation on a specified food truck.
     * @example
     * performUpdateOperation('truck123', { name: 'New Name' }, true, cleanupOperation)
     * // No direct return value; operation may log errors.
     * @param {string} truckId - The unique identifier of the food truck to be updated.
     * @param {Partial&lt;FoodTruck&gt;} updates - An object containing the fields to be updated.
     * @param {boolean} dryRun - Flag indicating whether the operation should be a simulation without actual changes.
     * @param {CleanupOperation} operation - An operation object that logs errors encountered during update.
     * @returns {Promise&lt;void&gt;} A promise that resolves when the update operation is complete.
     * @description
     *   - If 'dryRun' is true, no updates are applied but actions are logged.
     *   - Errors during update are caught and logged in the 'operation.errors' array.
     */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/data-quality/batchCleanup.js (Line 170:5 - Line 188:8), C:/AI/food-truck-finder-poc/dist/lib/lib/data-quality/batchCleanup.js (Line 170:5 - Line 188:8)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn434" onclick="toggleCodeBlock('cloneGroup434', 'expandBtn434', 'collapseBtn434')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn434" onclick="toggleCodeBlock('cloneGroup434', 'expandBtn434', 'collapseBtn434')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup434"><code class="language-javascript text-sm text-gray-800">static async performUpdateOperation(truckId, updates, dryRun, operation) {
        operation.affectedCount += 1;
        if (dryRun) {
            operation.successCount += 1;
        }
        else {
            try {
                await FoodTruckService.updateTruck(truckId, updates);
                operation.successCount += 1;
            }
            catch (error) {
                operation.errorCount += 1;
                operation.errors.push(`Failed to update truck ${truckId}: ${error instanceof Error ? error.message : String(error)}`);
            }
        }
    }
    /**
     * Normalize phone numbers to consistent format
     */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/data-quality/batchCleanup.js (Line 189:5 - Line 217:8), C:/AI/food-truck-finder-poc/dist/lib/lib/data-quality/batchCleanup.js (Line 189:5 - Line 217:8)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn435" onclick="toggleCodeBlock('cloneGroup435', 'expandBtn435', 'collapseBtn435')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn435" onclick="toggleCodeBlock('cloneGroup435', 'expandBtn435', 'collapseBtn435')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup435"><code class="language-javascript text-sm text-gray-800">static async normalizePhoneNumbers(trucks, dryRun, operation) {
        const promises = trucks.map((truck) =&gt; {
            if (truck.contact_info?.phone !== undefined) {
                const originalPhone = truck.contact_info.phone;
                const normalizedPhone = this.normalizePhone(originalPhone);
                if (normalizedPhone !== undefined &amp;&amp; normalizedPhone !== originalPhone) {
                    return this.applyPhoneNormalizationUpdate(truck, normalizedPhone, dryRun, operation);
                }
            }
            return Promise.resolve();
        });
        await Promise.all(promises);
        return operation;
    }
    /**
     * Apply phone normalization update to a food truck's contact information.
     * @example
     * applyPhoneNormalizationUpdate(truckInstance, '+1234567890', false, operationInstance)
     * // Normalizes and updates phone number of given truckInstance.
     * @param {FoodTruck} truck - The food truck object whose phone number needs normalization.
     * @param {string} normalizedPhone - The normalized phone number to update to the food truck's contact information.
     * @param {boolean} dryRun - Flag indicating whether the operation is a dry run; updates are skipped if true.
     * @param {CleanupOperation} operation - Object containing cleanup operation context including a record of errors.
     * @returns {Promise&lt;void&gt;} Does not return a value, but potentially modifies the truck and operation objects.
     * @description
     *   - Executes the update operation only if `dryRun` is false.
     *   - Pushes error messages to `operation.errors` on failure during the update process.
     *   - Uses `FoodTruckService.updateTruck` for updating the contact information.
     */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/data-quality/batchCleanup.js (Line 218:5 - Line 241:8), C:/AI/food-truck-finder-poc/dist/lib/lib/data-quality/batchCleanup.js (Line 218:5 - Line 241:8)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn436" onclick="toggleCodeBlock('cloneGroup436', 'expandBtn436', 'collapseBtn436')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn436" onclick="toggleCodeBlock('cloneGroup436', 'expandBtn436', 'collapseBtn436')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup436"><code class="language-javascript text-sm text-gray-800">static async applyPhoneNormalizationUpdate(truck, normalizedPhone, dryRun, operation) {
        operation.affectedCount += 1;
        if (dryRun) {
            operation.successCount += 1;
        }
        else {
            try {
                await FoodTruckService.updateTruck(truck.id, {
                    contact_info: {
                        ...truck.contact_info,
                        phone: normalizedPhone,
                    },
                });
                operation.successCount += 1;
            }
            catch (error) {
                operation.errorCount += 1;
                operation.errors.push(`Failed to normalize phone for truck ${truck.id}: ${error instanceof Error ? error.message : String(error)}`);
            }
        }
    }
    /**
     * Helper to determine if coordinates need fixing and provide updates
     */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/data-quality/batchCleanup.js (Line 242:5 - Line 255:8), C:/AI/food-truck-finder-poc/dist/lib/lib/data-quality/batchCleanup.js (Line 242:5 - Line 255:8)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn437" onclick="toggleCodeBlock('cloneGroup437', 'expandBtn437', 'collapseBtn437')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn437" onclick="toggleCodeBlock('cloneGroup437', 'expandBtn437', 'collapseBtn437')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup437"><code class="language-javascript text-sm text-gray-800">static getFixedCoordinates(lat, lng, defaultLat, defaultLng) {
        // Fix invalid coordinates (0,0 or undefined)
        if (lat === undefined || lng === undefined || lat === 0 || lng === 0) {
            return { lat: defaultLat, lng: defaultLng };
        }
        // Fix coordinates outside reasonable bounds for Charleston area
        if (lat &lt; 32 || lat &gt; 34 || lng &gt; -79 || lng &lt; -81) {
            return { lat: defaultLat, lng: defaultLng };
        }
        return undefined;
    }
    /**
     * Fix invalid GPS coordinates
     */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/data-quality/batchCleanup.js (Line 256:5 - Line 278:8), C:/AI/food-truck-finder-poc/dist/lib/lib/data-quality/batchCleanup.js (Line 256:5 - Line 278:8)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn438" onclick="toggleCodeBlock('cloneGroup438', 'expandBtn438', 'collapseBtn438')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn438" onclick="toggleCodeBlock('cloneGroup438', 'expandBtn438', 'collapseBtn438')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup438"><code class="language-javascript text-sm text-gray-800">static async fixCoordinates(trucks, dryRun, operation) {
        const context = {
            defaultLat: 32.7767,
            defaultLng: -79.9311,
            dryRun,
        };
        const promises = trucks.map((truck) =&gt; this.processSingleTruckCoordinates(truck, { ...context, operation }));
        await Promise.all(promises);
        return operation;
    }
    /**
     * Processes coordinates for a single food truck, applying any necessary fixes.
     * @example
     * processSingleTruckCoordinates(truck, context)
     * // No return value, function completes silently
     * @param {FoodTruck} truck - The food truck whose coordinates are to be processed.
     * @param {CoordinateProcessContext} context - Contains configuration and operation context for processing coordinates.
     * @returns {Promise&lt;void&gt;} Returns a promise that resolves when the processing and possible updates are complete.
     * @description
     *   - Skips processing if the truck's current location is not available.
     *   - Retrieves updates for fixed coordinates based on truck's current and default locations.
     *   - Applies updates conditionally based on context settings such as `dryRun` and `operation`.
     */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/data-quality/batchCleanup.js (Line 279:5 - Line 302:8), C:/AI/food-truck-finder-poc/dist/lib/lib/data-quality/batchCleanup.js (Line 279:5 - Line 302:8)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn439" onclick="toggleCodeBlock('cloneGroup439', 'expandBtn439', 'collapseBtn439')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn439" onclick="toggleCodeBlock('cloneGroup439', 'expandBtn439', 'collapseBtn439')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup439"><code class="language-javascript text-sm text-gray-800">static async processSingleTruckCoordinates(truck, context) {
        if (!truck.current_location)
            return;
        const { defaultLat, defaultLng, dryRun, operation } = context;
        const { lat, lng } = truck.current_location;
        const updates = this.getFixedCoordinates(lat, lng, defaultLat, defaultLng);
        if (updates) {
            await this.applyCoordinateFixUpdate(truck, updates, dryRun, operation);
        }
    }
    /**
     * Applies coordinate updates for a food truck's current location.
     * @example
     * applyCoordinateFixUpdate(truck, { lat: 34.05, lng: -118.25 }, false, operation)
     * // Updates the coordinates of the truck's location asynchronously.
     * @param {FoodTruck} truck - The food truck object whose coordinates need correction.
     * @param {Partial&lt;FoodTruck['current_location']&gt;} updates - The latitude and longitude updates to be applied.
     * @param {boolean} dryRun - Flag to simulate the update without altering data.
     * @param {CleanupOperation} operation - The cleanup operation instance used for error tracking.
     * @returns {Promise&lt;void&gt;} Resolves when the coordinate update process is complete.
     * @description
     *   - Executes the update operation only if the dryRun flag is false.
     *   - If the update fails, logs the error details into the operation's error array.
     */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/data-quality/batchCleanup.js (Line 303:5 - Line 326:8), C:/AI/food-truck-finder-poc/dist/lib/lib/data-quality/batchCleanup.js (Line 303:5 - Line 326:8)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn440" onclick="toggleCodeBlock('cloneGroup440', 'expandBtn440', 'collapseBtn440')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn440" onclick="toggleCodeBlock('cloneGroup440', 'expandBtn440', 'collapseBtn440')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup440"><code class="language-javascript text-sm text-gray-800">static async applyCoordinateFixUpdate(truck, updates, dryRun, operation) {
        operation.affectedCount += 1;
        if (dryRun) {
            operation.successCount += 1;
        }
        else {
            try {
                await FoodTruckService.updateTruck(truck.id, {
                    current_location: {
                        ...truck.current_location,
                        ...updates,
                    },
                });
                operation.successCount += 1;
            }
            catch (error) {
                operation.errorCount += 1;
                operation.errors.push(`Failed to fix coordinates for truck ${truck.id}: ${error instanceof Error ? error.message : String(error)}`);
            }
        }
    }
    /**
     * Update quality scores for all trucks
     */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/data-quality/batchCleanup.js (Line 347:5 - Line 371:8), C:/AI/food-truck-finder-poc/dist/lib/lib/data-quality/batchCleanup.js (Line 347:5 - Line 371:8)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn441" onclick="toggleCodeBlock('cloneGroup441', 'expandBtn441', 'collapseBtn441')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn441" onclick="toggleCodeBlock('cloneGroup441', 'expandBtn441', 'collapseBtn441')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup441"><code class="language-javascript text-sm text-gray-800">static async processSingleTruckForQualityScore(truck, dryRun, operation) {
        const qualityAssessment = DataQualityService.calculateQualityScore(truck);
        if (qualityAssessment) {
            const newScore = qualityAssessment.score;
            const currentScore = truck.data_quality_score ?? 0;
            // Only update if score changed significantly (&gt;5% difference)
            if (typeof newScore === 'number' &amp;&amp; Math.abs(newScore - currentScore) &gt; 0.05) {
                await this.applyQualityScoreUpdate(truck, dryRun, operation);
            }
        }
    }
    /**
     * Updates the quality score of a specified food truck and handles errors during the update process.
     * @example
     * applyQualityScoreUpdate(foodTruckInstance, false, cleanupOperationInstance)
     * void
     * @param {FoodTruck} truck - The food truck for which the quality score will be updated.
     * @param {boolean} dryRun - Flag indicating whether the function should perform the update or just simulate it.
     * @param {CleanupOperation} operation - The cleanup operation containing possible error records.
     * @returns {Promise&lt;void&gt;} Resolves with no value when the update completes. Errors are recorded in the `operation` if thrown.
     * @description
     *   - Throws an error if the quality score update fails.
     *   - If `dryRun` is true, the function simulates the update without changing any data.
     *   - Errors occurring during the update are appended to the `operation.errors` array.
     */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/data-quality/batchCleanup.js (Line 372:5 - Line 393:8), C:/AI/food-truck-finder-poc/dist/lib/lib/data-quality/batchCleanup.js (Line 372:5 - Line 393:8)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn442" onclick="toggleCodeBlock('cloneGroup442', 'expandBtn442', 'collapseBtn442')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn442" onclick="toggleCodeBlock('cloneGroup442', 'expandBtn442', 'collapseBtn442')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup442"><code class="language-javascript text-sm text-gray-800">static async applyQualityScoreUpdate(truck, dryRun, operation) {
        operation.affectedCount += 1;
        if (dryRun) {
            operation.successCount += 1;
        }
        else {
            try {
                const updateResult = await DataQualityService.updateTruckQualityScore(truck.id);
                if ('error' in updateResult) {
                    throw new Error(updateResult.error);
                }
                operation.successCount += 1;
            }
            catch (error) {
                operation.errorCount += 1;
                operation.errors.push(`Failed to update quality score for truck ${truck.id}: ${error instanceof Error ? error.message : String(error)}`);
            }
        }
    }
    /**
     * Identify and merge duplicate trucks
     */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/data-quality/batchCleanup.js (Line 415:5 - Line 441:8), C:/AI/food-truck-finder-poc/dist/lib/lib/data-quality/batchCleanup.js (Line 415:5 - Line 441:8)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn443" onclick="toggleCodeBlock('cloneGroup443', 'expandBtn443', 'collapseBtn443')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn443" onclick="toggleCodeBlock('cloneGroup443', 'expandBtn443', 'collapseBtn443')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup443"><code class="language-javascript text-sm text-gray-800">static async processSingleTruckForDuplicates(truck, dryRun, context) {
        const { processedIds } = context;
        if (processedIds.has(truck.id))
            return;
        const duplicateCheck = await DuplicatePreventionService.checkForDuplicates(truck);
        if (duplicateCheck.isDuplicate &amp;&amp;
            duplicateCheck.bestMatch?.confidence === 'high' &amp;&amp;
            duplicateCheck.bestMatch.recommendation === 'merge') {
            await this.applyMergeOperation(truck, duplicateCheck.bestMatch.existingTruck, dryRun, context);
        }
        processedIds.add(truck.id);
    }
    /**
     * Applies a merge operation between two food trucks and updates the context.
     * @example
     * applyMergeOperation(truck, existingTruck, true, context)
     * // Executes a dry run of the merge operation without affecting data
     * @param {FoodTruck} truck - The food truck that is being merged.
     * @param {FoodTruck} existingTruck - The existing food truck to merge with.
     * @param {boolean} dryRun - Indicates if the merge operation should be simulated.
     * @param {MergeOperationContext} context - Context containing details and state of the merge operation.
     * @returns {Promise&lt;void&gt;} Promise representing the completion of the merge operation.
     * @description
     *   - Updates the list of processed IDs in the context upon successful merge.
     *   - Throws and records an error if the merge operation fails.
     *   - Utilizes the DuplicatePreventionService for performing the merge.
     */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/data-quality/batchCleanup.js (Line 442:5 - Line 465:8), C:/AI/food-truck-finder-poc/dist/lib/lib/data-quality/batchCleanup.js (Line 442:5 - Line 465:8)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn444" onclick="toggleCodeBlock('cloneGroup444', 'expandBtn444', 'collapseBtn444')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn444" onclick="toggleCodeBlock('cloneGroup444', 'expandBtn444', 'collapseBtn444')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup444"><code class="language-javascript text-sm text-gray-800">static async applyMergeOperation(truck, existingTruck, dryRun, context) {
        const { operation, processedIds } = context;
        operation.affectedCount += 1;
        if (dryRun) {
            operation.successCount += 1;
        }
        else {
            try {
                const mergeResult = await DuplicatePreventionService.mergeDuplicates(truck.id, existingTruck.id);
                if ('error' in mergeResult) {
                    throw new Error(mergeResult.error);
                }
                processedIds.add(existingTruck.id);
                operation.successCount += 1;
            }
            catch (error) {
                operation.errorCount += 1;
                operation.errors.push(`Failed to merge duplicates ${truck.id} and ${existingTruck.id}: ${error instanceof Error ? error.message : String(error)}`);
            }
        }
    }
    /**
     * Normalize phone number format
     */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/data-quality/batchCleanup.js (Line 466:5 - Line 483:8), C:/AI/food-truck-finder-poc/dist/lib/lib/data-quality/batchCleanup.js (Line 466:5 - Line 483:8)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn445" onclick="toggleCodeBlock('cloneGroup445', 'expandBtn445', 'collapseBtn445')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn445" onclick="toggleCodeBlock('cloneGroup445', 'expandBtn445', 'collapseBtn445')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup445"><code class="language-javascript text-sm text-gray-800">static normalizePhone(phone) {
        if (!phone)
            return undefined;
        // Remove all non-digit characters
        const digits = phone.replaceAll(/\D/g, '');
        // Handle US phone numbers
        if (digits.length === 10) {
            return `(${digits.slice(0, 3)}) ${digits.slice(3, 6)}-${digits.slice(6)}`;
        }
        if (digits.length === 11 &amp;&amp; digits.startsWith('1')) {
            return `+1 (${digits.slice(1, 4)}) ${digits.slice(4, 7)}-${digits.slice(7)}`;
        }
        // Return original if can't normalize
        return phone;
    }
    /**
     * Get operation description
     */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/data-quality/batchCleanup.js (Line 497:5 - Line 505:2), C:/AI/food-truck-finder-poc/dist/lib/lib/data-quality/batchCleanup.js (Line 497:5 - Line 505:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn446" onclick="toggleCodeBlock('cloneGroup446', 'expandBtn446', 'collapseBtn446')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn446" onclick="toggleCodeBlock('cloneGroup446', 'expandBtn446', 'collapseBtn446')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup446"><code class="language-javascript text-sm text-gray-800">static calculateSummary(operations) {
        return {
            trucksImproved: operations.reduce((sum, op) =&gt; sum + op.successCount, 0),
            duplicatesRemoved: operations.find((op) =&gt; op.type === 'merge_duplicates')?.successCount ?? 0,
            qualityScoreImprovement: operations.find((op) =&gt; op.type === 'update_quality_scores')?.successCount ?? 0,
            placeholdersRemoved: operations.find((op) =&gt; op.type === 'remove_placeholders')?.successCount ?? 0,
        };
    }
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/auth/authHelpers.js (Line 1:24 - Line 22:2), C:/AI/food-truck-finder-poc/dist/lib/lib/auth/authHelpers.js (Line 1:27 - Line 22:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn447" onclick="toggleCodeBlock('cloneGroup447', 'expandBtn447', 'collapseBtn447')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn447" onclick="toggleCodeBlock('cloneGroup447', 'expandBtn447', 'collapseBtn447')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup447"><code class="language-javascript text-sm text-gray-800">;
export async function verifyAdminAccess(request) {
    try {
        const authHeader = request.headers.get('authorization');
        if (!authHeader)
            return false;
        const token = authHeader.replace('Bearer ', '');
        const { data, error } = await supabase.auth.getUser(token);
        const user = data?.user;
        if (error || !user)
            return false;
        const { data: profile } = await supabase
            .from('profiles')
            .select('role')
            .eq('id', user.id)
            .single();
        return profile?.role === 'admin';
    }
    catch {
        return false;
    }
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/utils/typeGuards.js (Line 1:1 - Line 124:2), C:/AI/food-truck-finder-poc/dist/lib/lib/utils/typeGuards.js (Line 1:1 - Line 124:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn453" onclick="toggleCodeBlock('cloneGroup453', 'expandBtn453', 'collapseBtn453')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn453" onclick="toggleCodeBlock('cloneGroup453', 'expandBtn453', 'collapseBtn453')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup453"><code class="language-javascript text-sm text-gray-800">// lib/utils/typeGuards.ts
// --- CORE UTILITY FUNCTIONS (Task 1.1.1 &amp; 1.1.2) ---
/**
 * Checks if a value is a non-null object.
 */
export function isValidObject(value) {
    return typeof value === 'object' &amp;&amp; value !== null &amp;&amp; !Array.isArray(value);
}
/**
 * Safely checks if an object has a specific property. This is a robust implementation.
 */
export function hasProperty(obj, prop) {
    return Object.prototype.hasOwnProperty.call(obj, prop);
}
/**
 * Checks if a value is a string.
 */
export function isString(value) {
    return typeof value === 'string';
}
/**
 * Checks if a value is a valid number (and not NaN).
 */
export function isNumber(value) {
    return typeof value === 'number' &amp;&amp; !Number.isNaN(value);
}
/**
 * Checks if a value is an array.
 */
export function isArray(value) {
    return Array.isArray(value);
}
/**
 * Checks if a value is an array of strings.
 */
export function isStringArray(value) {
    return Array.isArray(value) &amp;&amp; value.every(item =&gt; typeof item === 'string');
}
/**
 * Asserts that a value is of a specific type, throwing a TypeError if validation fails.
 */
export function assertType(value, validator, errorMessage) {
    if (!validator(value)) {
        throw new TypeError(errorMessage ?? `Value does not match expected type.`);
    }
}
/**
 * Safely assigns a value if it passes validation, otherwise returns a fallback.
 * Useful for providing default values for potentially invalid or missing data.
 */
export function safeAssign(value, fallback, validator) {
    return validator(value) ? value : fallback;
}
// --- APPLICATION-SPECIFIC TYPE GUARDS ---
function isPriceRange(value) {
    // Added '$$$$' to the check to fully match the PriceRange type definition.
    return isString(value) &amp;&amp; (value === '$' || value === '$$' || value === '$$$' || value === '$$$$');
}
function isLocationData(value) {
    if (!isValidObject(value))
        return false;
    return hasProperty(value, 'lat') &amp;&amp; isNumber(value.lat) &amp;&amp;
        hasProperty(value, 'lng') &amp;&amp; isNumber(value.lng);
}
function isDailyOperatingHours(value) {
    if (value === undefined)
        return true;
    if (!isValidObject(value))
        return false;
    if (hasProperty(value, 'closed') &amp;&amp; value.closed === true) {
        return true;
    }
    return hasProperty(value, 'open') &amp;&amp; isString(value.open) &amp;&amp;
        hasProperty(value, 'close') &amp;&amp; isString(value.close);
}
function isOperatingHours(value) {
    if (!isValidObject(value))
        return false;
    const days = ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday'];
    return days.every(day =&gt; hasProperty(value, day) &amp;&amp; isDailyOperatingHours(value[day]));
}
function isMenuItem(value) {
    if (!isValidObject(value))
        return false;
    return hasProperty(value, 'name') &amp;&amp; isString(value.name) &amp;&amp;
        hasProperty(value, 'dietary_tags') &amp;&amp; isArray(value.dietary_tags);
}
function isMenuCategory(value) {
    if (!isValidObject(value))
        return false;
    return hasProperty(value, 'name') &amp;&amp; isString(value.name) &amp;&amp;
        hasProperty(value, 'items') &amp;&amp; isArray(value.items) &amp;&amp;
        value.items.every(item =&gt; isMenuItem(item));
}
/**
 * Type guard for the base FoodTruckSchema.
 */
export function isFoodTruckSchema(value) {
    if (!isValidObject(value))
        return false;
    // This property is optional, so it's valid if it's missing, undefined, or matches the type.
    const isPriceRangeValid = !hasProperty(value, 'price_range') || value.price_range === undefined || isPriceRange(value.price_range);
    return hasProperty(value, 'name') &amp;&amp; isString(value.name) &amp;&amp;
        hasProperty(value, 'description') &amp;&amp; isString(value.description) &amp;&amp;
        hasProperty(value, 'current_location') &amp;&amp; isValidObject(value.current_location) &amp;&amp; isLocationData(value.current_location) &amp;&amp;
        hasProperty(value, 'operating_hours') &amp;&amp; isOperatingHours(value.operating_hours) &amp;&amp;
        hasProperty(value, 'menu') &amp;&amp; isArray(value.menu) &amp;&amp; value.menu.every(item =&gt; isMenuCategory(item)) &amp;&amp;
        hasProperty(value, 'cuisine_type') &amp;&amp; isStringArray(value.cuisine_type) &amp;&amp;
        isPriceRangeValid &amp;&amp; // Using the isPriceRange function here
        hasProperty(value, 'data_quality_score') &amp;&amp; isNumber(value.data_quality_score) &amp;&amp;
        hasProperty(value, 'verification_status') &amp;&amp; isString(value.verification_status) &amp;&amp;
        hasProperty(value, 'source_urls') &amp;&amp; isStringArray(value.source_urls) &amp;&amp;
        hasProperty(value, 'last_scraped_at') &amp;&amp; isString(value.last_scraped_at);
}
/**
 * Type guard for the full FoodTruck object (schema + ID fields).
 */
export function isFoodTruck(value) {
    if (!isValidObject(value) || !isFoodTruckSchema(value))
        return false;
    return hasProperty(value, 'id') &amp;&amp; isString(value.id) &amp;&amp;
        hasProperty(value, 'created_at') &amp;&amp; isString(value.created_at) &amp;&amp;
        hasProperty(value, 'updated_at') &amp;&amp; isString(value.updated_at);
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/utils/QualityScorer.js (Line 1:17 - Line 244:2), C:/AI/food-truck-finder-poc/dist/lib/lib/utils/QualityScorer.js (Line 1:27 - Line 244:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn455" onclick="toggleCodeBlock('cloneGroup455', 'expandBtn455', 'collapseBtn455')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn455" onclick="toggleCodeBlock('cloneGroup455', 'expandBtn455', 'collapseBtn455')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup455"><code class="language-javascript text-sm text-gray-800">;
/**
 * Assess basic information of a FoodTruck object and adjust its score based on missing attributes.
 * @example
 * assessBasicInfo({name: 'Taste', description: 'Good food', cuisine_type: ['Italian'], price_range: '$$', average_rating: 4.5, review_count: 100}, [], 1.0)
 * Returns 1.0 if the truck information is complete and correct, otherwise returns a lower score with issues noted in the issues array.
 * @param {FoodTruck} truck - Object containing details about the food truck.
 * @param {string[]} issues - Array to hold descriptions of any issues found in the truck's information.
 * @param {number} currentScore - Initial score from which deductions are made based on detected issues.
 * @returns {number} Updated score after assessing the truck's basic information.
 * @description
 *   - Reduces score for missing or invalid 'name', 'description', 'cuisine_type', 'price_range', 'average_rating', and 'review_count'.
 *   - Appends issue descriptions to the 'issues' array corresponding to each attribute that fails validation.
 */
function assessBasicInfo(truck, issues, currentScore) {
    let score = currentScore;
    if (typeof truck.name !== 'string' || truck.name.trim().length === 0) {
        score -= 0.2;
        issues.push('Missing name');
    }
    if (typeof truck.description !== 'string' || truck.description.trim().length === 0) {
        score -= 0.1;
        issues.push('Missing description');
    }
    if (!Array.isArray(truck.cuisine_type) ||
        truck.cuisine_type.length === 0 ||
        !truck.cuisine_type.every((item) =&gt; typeof item === 'string')) {
        score -= 0.1;
        issues.push('Missing or invalid cuisine type');
    }
    if (typeof truck.price_range !== 'string' || truck.price_range.trim().length === 0) {
        score -= 0.05;
        issues.push('Missing price range');
    }
    if (typeof truck.average_rating !== 'number' || Number.isNaN(truck.average_rating)) {
        score -= 0.05;
        issues.push('Missing average rating');
    }
    if (typeof truck.review_count !== 'number' || Number.isNaN(truck.review_count)) {
        score -= 0.05;
        issues.push('Missing review count');
    }
    return score;
}
/**
 * Evaluates the contact information of a food truck and modifies its score accordingly.
 * @example
 * assessContactInfo(truckInstance, [], 1.0)
 * // returns 0.88 if all arguments are missing
 * @param {FoodTruck} truck - An object representing a food truck with various contact attributes.
 * @param {string[]} issues - An array to store any identified issues with contact information.
 * @param {number} currentScore - The initial score before evaluation.
 * @returns {number} A modified score based on the presence and validity of contact details.
 * @description
 *   - Reduces the score by a small percentage for each missing contact detail.
 *   - Appends specific issue messages to the 'issues' array for each missing detail.
 *   - Scores attribute presence in descending impact order: website, phone number, email, social media handles.
 */
function assessContactInfo(truck, issues, currentScore) {
    let score = currentScore;
    if (typeof truck.website !== 'string' || truck.website.trim().length === 0) {
        score -= 0.05;
        issues.push('Missing website');
    }
    if (typeof truck.phone_number !== 'string' || truck.phone_number.trim().length === 0) {
        score -= 0.05;
        issues.push('Missing phone number');
    }
    if (typeof truck.email !== 'string' || truck.email.trim().length === 0) {
        score -= 0.05;
        issues.push('Missing email');
    }
    if (typeof truck.instagram_handle !== 'string' || truck.instagram_handle.trim().length === 0) {
        score -= 0.02;
        issues.push('Missing Instagram handle');
    }
    if (typeof truck.facebook_handle !== 'string' || truck.facebook_handle.trim().length === 0) {
        score -= 0.02;
        issues.push('Missing Facebook handle');
    }
    if (typeof truck.twitter_handle !== 'string' || truck.twitter_handle.trim().length === 0) {
        score -= 0.02;
        issues.push('Missing Twitter handle');
    }
    return score;
}
/**
 * Evaluates the quality of location data for a food truck and updates the score accordingly.
 * @example
 * assessLocationData(truck, issues, currentScore)
 * // Returns a modified score based on location data analysis
 * @param {FoodTruck} truck - The food truck object containing location details.
 * @param {string[]} issues - Array to record any issues identified during evaluation.
 * @param {number} currentScore - The current scoring value before assessment.
 * @returns {number} Updated score reflecting the quality of the location data.
 * @description
 *   - Reduces the score if location data is missing or invalid.
 *   - Checks the age of the location data to determine its staleness.
 *   - Updates the issues array with specific reasons when penalizing the score.
 */
function assessLocationData(truck, issues, currentScore) {
    let score = currentScore;
    if (typeof truck.current_location?.lat !== 'number' ||
        Number.isNaN(truck.current_location.lat) ||
        typeof truck.current_location?.lng !== 'number' ||
        Number.isNaN(truck.current_location.lng)) {
        score -= 0.15;
        issues.push('Missing current location data');
    }
    else {
        if (typeof truck.current_location.timestamp === 'string' &amp;&amp;
            truck.current_location.timestamp.length &gt; 0) {
            const locationAge = Date.now() - new Date(truck.current_location.timestamp).getTime();
            const daysSinceUpdate = locationAge / (1000 * 60 * 60 * 24);
            if (daysSinceUpdate &gt; 7) {
                score -= 0.1;
                issues.push('Stale location data');
            }
        }
        else {
            score -= 0.05;
            issues.push('Missing location timestamp');
        }
    }
    return score;
}
function assessScheduleData(truck, issues, currentScore) {
    let score = currentScore;
    if (!Array.isArray(truck.schedule) || truck.schedule.length === 0) {
        score -= 0.1;
        issues.push('Missing schedule data');
    }
    return score;
}
/**
 * Computes the quality score of a given food truck based on multiple criteria.
 * @example
 * calculateQualityScore(truckInstance)
 * { score: 3, issues: [&quot;Missing contact information&quot;, &quot;Incomplete schedule&quot;] }
 * @param {FoodTruck} truck - The food truck object to be assessed.
 * @returns {QualityAssessment} An object containing the computed score and a list of identified issues.
 * @description
 *   - The score starts at 1 and is adjusted based on various assessments.
 *   - The function ensures the score never drops below zero.
 *   - Issues that affect the score are collected and returned for analysis.
 */
export function calculateQualityScore(truck) {
    let score = 1; // Start with a perfect score
    const issues = [];
    score = assessBasicInfo(truck, issues, score);
    score = assessContactInfo(truck, issues, score);
    score = assessLocationData(truck, issues, score);
    score = assessScheduleData(truck, issues, score);
    // Ensure score doesn't go below 0
    score = Math.max(0, score);
    return { score, issues };
}
export function categorizeQualityScore(score) {
    if (score &gt;= 0.8) {
        return { label: 'High', color: 'bg-green-500' };
    }
    else if (score &gt;= 0.5) {
        return { label: 'Medium', color: 'bg-yellow-500' };
    }
    return { label: 'Low', color: 'bg-red-500' };
}
export function formatQualityScore(score) {
    if (score === null || score === undefined) {
        return 'N/A';
    }
    return `${(score * 100).toFixed(0)}%`;
}
export function getQualityBadgeClasses(score) {
    if (score === null || score === undefined) {
        return 'bg-gray-500';
    }
    const category = categorizeQualityScore(score);
    return category.color;
}
export function getQualityScoreAriaLabel(score) {
    if (score === null || score === undefined) {
        return 'Data quality score not available';
    }
    const formattedScore = formatQualityScore(score);
    const category = categorizeQualityScore(score);
    return `Data quality: ${formattedScore}, Category: ${category.label}`;
}
export const DataQualityService = {
    calculateQualityScore,
    categorizeQualityScore,
    formatQualityScore,
    getQualityBadgeClasses,
    getQualityScoreAriaLabel,
    async batchUpdateQualityScores(limit = 100) {
        const { data, error } = await supabase
            .from('food_trucks')
            .select('*')
            .limit(limit)
            .overrideTypes();
        if (error) {
            console.error('Error fetching trucks for batch update:', error);
            return { updatedCount: 0, errors: [error.message] };
        }
        const trucks = data ?? [];
        const updates = trucks.map((truck) =&gt; {
            const { score } = calculateQualityScore(truck);
            return {
                id: truck.id,
                data_quality_score: score,
            };
        });
        const { error: updateError, count } = await supabase
            .from('food_trucks')
            .upsert(updates, { onConflict: 'id' })
            .select();
        if (updateError) {
            console.error('Error batch updating quality scores:', updateError);
            return { updatedCount: 0, errors: [updateError.message] };
        }
        return { updatedCount: count ?? 0, errors: [] };
    },
    async updateTruckQualityScore(truckId) {
        const { data: truck, error: fetchError } = await supabase
            .from('food_trucks')
            .select('*')
            .eq('id', truckId)
            .single()
            .overrideTypes();
        if (fetchError || truck === null) {
            console.error(`Error fetching truck ${truckId} for quality update:`, fetchError);
            return { success: false };
        }
        const { score } = calculateQualityScore(truck);
        const { error: updateError } = await supabase
            .from('food_trucks')
            .update({ data_quality_score: score })
            .eq('id', truckId);
        if (updateError) {
            console.error(`Error updating quality score for truck ${truckId}:`, updateError);
            return { success: false };
        }
        return { success: true };
    },
};</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/utils/geocoding.js (Line 1:1 - Line 102:2), C:/AI/food-truck-finder-poc/dist/lib/lib/utils/geocoding.js (Line 1:1 - Line 102:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn457" onclick="toggleCodeBlock('cloneGroup457', 'expandBtn457', 'collapseBtn457')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn457" onclick="toggleCodeBlock('cloneGroup457', 'expandBtn457', 'collapseBtn457')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup457"><code class="language-javascript text-sm text-gray-800">/**
 * Geocoding utilities using Nominatim (OpenStreetMap's free geocoding service)
 * Converts addresses to lat/lng coordinates for map display
 */
/**
 * Geocodes an address to get latitude and longitude coordinates
 * @param address - The address to geocode
 * @param city - Optional city to improve accuracy (defaults to Charleston, SC)
 * @returns Promise containing coordinates and formatted address
 */
export async function geocodeAddress(address, city = 'Charleston, SC') {
    try {
        // Clean and format the address
        const cleanAddress = address.trim();
        if (!cleanAddress) {
            throw new Error('Empty address provided');
        }
        // Construct search query - add city if not already in address
        const searchQuery = cleanAddress.toLowerCase().includes('charleston')
            ? cleanAddress
            : `${cleanAddress}, ${city}`;
        // Use Nominatim API with proper headers and rate limiting
        const url = new URL('https://nominatim.openstreetmap.org/search');
        url.searchParams.set('q', searchQuery);
        url.searchParams.set('format', 'json');
        url.searchParams.set('limit', '1');
        url.searchParams.set('countrycodes', 'us');
        url.searchParams.set('addressdetails', '1');
        console.log(' Geocoding address:', searchQuery);
        const response = await fetch(url.toString(), {
            headers: {
                'User-Agent': 'FoodTruckFinder/1.0 (https://your-domain.com)', // Required by Nominatim
            },
        });
        if (!response.ok) {
            throw new Error(`Geocoding API error: ${response.status}`);
        }
        const data = await response.json();
        if (!data || data.length === 0) {
            console.warn(' No geocoding results for:', searchQuery);
            return {
                lat: 0,
                lng: 0,
                formatted_address: address,
                success: false,
            };
        }
        const result = data[0];
        const lat = parseFloat(result.lat);
        const lng = parseFloat(result.lon);
        // Validate coordinates are reasonable for Charleston area
        if (isNaN(lat) || isNaN(lng)) {
            throw new Error('Invalid coordinates returned');
        }
        console.log(' Geocoded successfully:', {
            original: address,
            coordinates: { lat, lng },
            formatted: result.display_name,
        });
        return {
            lat,
            lng,
            formatted_address: result.display_name,
            success: true,
        };
    }
    catch (error) {
        console.error(' Geocoding failed for address:', address, error);
        return {
            lat: 0,
            lng: 0,
            formatted_address: address,
            success: false,
        };
    }
}
/**
 * Fallback coordinates for Charleston, SC when geocoding fails
 */
export const CHARLESTON_FALLBACK = {
    lat: 32.7765,
    lng: -79.9311,
};
/**
 * Geocodes multiple addresses with rate limiting to avoid overwhelming the service
 * @param addresses - Array of addresses to geocode
 * @param delayMs - Delay between requests (default 1000ms as recommended by Nominatim)
 * @returns Promise array of geocoding results
 */
export async function geocodeAddressesBatch(addresses, delayMs = 1000) {
    const results = [];
    for (let i = 0; i &lt; addresses.length; i++) {
        const address = addresses[i];
        const result = await geocodeAddress(address);
        results.push(result);
        // Rate limiting - wait between requests
        if (i &lt; addresses.length - 1) {
            await new Promise(resolve =&gt; setTimeout(resolve, delayMs));
        }
    }
    return results;
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/utils/foodTruckHelpers.js (Line 1:34 - Line 251:2), C:/AI/food-truck-finder-poc/dist/lib/lib/utils/foodTruckHelpers.js (Line 1:34 - Line 251:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn459" onclick="toggleCodeBlock('cloneGroup459', 'expandBtn459', 'collapseBtn459')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn459" onclick="toggleCodeBlock('cloneGroup459', 'expandBtn459', 'collapseBtn459')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup459"><code class="language-javascript text-sm text-gray-800">;
export const getCurrentDay = () =&gt; {
    const days = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];
    return days[new Date().getDay()];
};
export const formatPrice = (price) =&gt; {
    // Updated to accept string
    if (typeof price === 'string') {
        // Handle cases where price might be a string like &quot;$10-$20&quot; or &quot;Varies&quot;
        return price;
    }
    return new Intl.NumberFormat('en-US', {
        style: 'currency',
        currency: 'USD',
    }).format(price);
};
/**
* Converts operational hours to a readable format or returns 'Closed' if applicable.
* @example
* formatOperatingHours({ open: '09:00', close: '17:00', closed: false })
* '9:00 AM - 5:00 PM'
* @param {DailyOperatingHours} hours - Object containing daily opening and closing times, and closed status.
* @returns {string} Formatted operating hours string or 'Closed'.
* @description
*   - Handles conversion of military time to 12-hour format.
*   - Adjusts for typical date parsing without relying on actual date due to fixed date string.
*   - Properly responds to 'closed' status by returning 'Closed'.
*   - Locales can impact formatted output by changing time conventions.
*/
export const formatHours = (hours) =&gt; {
    // Updated to accept DailyOperatingHours
    if (!hours || hours.closed) {
        return 'Closed';
    }
    const open = new Date(`1970-01-01T${hours.open}Z`).toLocaleTimeString('en-US', {
        hour: 'numeric',
        minute: 'numeric',
        hour12: true,
    });
    const close = new Date(`1970-01-01T${hours.close}Z`).toLocaleTimeString('en-US', {
        hour: 'numeric',
        minute: 'numeric',
        hour12: true,
    });
    return `${open} - ${close}`;
};
export const getPopularItems = (truck) =&gt; {
    // Explicitly define return type
    // Explicitly check for nullish and boolean
    return (truck.menu
        ?.flatMap((category) =&gt; category.items)
        .filter((item) =&gt; Boolean(item &amp;&amp; item.is_popular === true)) ?? []);
};
/**
 * Calculates the price range of all items in the food truck's menu.
 * @example
 * getPriceRange(foodTruck)
 * &quot;5.00 - 12.50&quot;
 * @param {FoodTruck} truck - The food truck object containing menu details.
 * @returns {string} Returns a formatted string representing the price range or 'N/A' if no valid prices are found.
 * @description
 *   - Utilizes the optional chaining operator to safely access nested menu items.
 *   - Filters out non-numeric and undefined prices before calculating the range.
 *   - Formats the minimum and maximum prices using a helper function.
 */
export const getPriceRange = (truck) =&gt; {
    const allItems = truck.menu?.flatMap((category) =&gt; category.items);
    if (!allItems || allItems.length === 0) {
        return 'N/A';
    }
    const numericPrices = allItems
        .map((item) =&gt; item.price)
        .filter((price) =&gt; typeof price === 'number' &amp;&amp; price != undefined); // Filter for numbers
    if (numericPrices.length === 0) {
        return 'N/A'; // No numeric prices found
    }
    const minPrice = Math.min(...numericPrices);
    const maxPrice = Math.max(...numericPrices);
    return `${formatPrice(minPrice)} - ${formatPrice(maxPrice)}`;
};
export const getTodayHours = (truck) =&gt; {
    const today = getCurrentDay();
    return truck.operating_hours?.[today];
};
// Get user's current location or default to San Francisco
/**
 * Retrieves the user's geolocation and updates the location state.
 * @example
 * getUserLocationHelper(setUserLocation)
 * // Updates user's location or defaults to San Francisco
 * @param {function} setUserLocation - Callback function to update user's location state with latitude and longitude.
 * @returns {void} Function does not return anything.
 * @description
 *   - Defaults the location to San Francisco if geolocation access is denied or not supported.
 *   - Utilizes browser's geolocation API to fetch current coordinates.
 *   - Provides a warning in the console if location access is denied.
 */
export function getUserLocationHelper(setUserLocation) {
    if (typeof navigator !== 'undefined' &amp;&amp; navigator.geolocation != undefined) {
        // eslint-disable-next-line sonarjs/no-intrusive-permissions -- Geolocation is essential for finding nearby food trucks
        navigator.geolocation.getCurrentPosition((position) =&gt; {
            console.log(' User location accuracy:', position.coords.accuracy, 'meters');
            setUserLocation({
                lat: position.coords.latitude,
                lng: position.coords.longitude,
            });
        }, (error) =&gt; {
            console.warn('Location access denied:', error);
            // Default to Charleston, SC for this project
            setUserLocation({ lat: 32.7765, lng: -79.9311 });
        }, {
            enableHighAccuracy: true,
            timeout: 10000,
            maximumAge: 300000 // 5 minutes
        });
    }
    else {
        // Default to San Francisco if geolocation is not supported
        setUserLocation({ lat: 37.7749, lng: -122.4194 });
    }
}
// Load all food trucks from API
/**
 * Loads food truck data from the server and updates state.
 * @example
 * loadFoodTrucksHelper(setTrucks, setLoading)
 * undefined
 * @param {(trucks: FoodTruck[]) =&gt; void} setTrucks - Callback to update the state with loaded food trucks.
 * @param {(loading: boolean) =&gt; void} setLoading - Callback to update the loading state.
 * @returns {void} No return value.
 * @description
 *   - Fetches data from '/api/trucks' endpoint.
 *   - Parses the response and expects an object containing a 'trucks' array.
 *   - Logs an error message to the console if fetching or parsing fails.
 *   - Ensures loading state is updated to false in all cases.
 */
export async function loadFoodTrucksHelper(setTrucks, setLoading) {
    try {
        console.log(' Starting to load food trucks...');
        const result = await supabaseFallback.getFoodTrucks();
        console.log(' Full result from supabaseFallback:', result);
        console.log(' Number of trucks found:', result.trucks.length);
        console.log(' Data status:', result.status);
        console.log(' Is from cache:', result.isFromCache);
        setTrucks(result.trucks);
    }
    catch (error) {
        console.error(' Failed to load food trucks:', error);
        setTrucks([]);
    }
    finally {
        setLoading(false);
    }
}
// Load nearby food trucks based on user location
/**
* Loads nearby food trucks based on user's location.
* @example
* loadNearbyTrucksHelper({ lat: 37.7749, lng: -122.4194 }, setTrucksCallback)
* // sets trucks with food truck data or an empty array
* @param {{ lat: number; lng: number } | undefined} userLocation - The location of the user used to find nearby trucks.
* @param {(trucks: FoodTruck[]) =&gt; void} setTrucks - Callback function to set the trucks data.
* @returns {void} No return value.
* @description
*   - Fetches nearby trucks from the API using latitude and longitude.
*   - Uses a fixed radius of 10 units for truck search.
*   - Handles errors by logging them to the console.
*/
export async function loadNearbyTrucksHelper(userLocation, setTrucks) {
    if (!userLocation)
        return;
    try {
        const { trucks } = await supabaseFallback.getFoodTrucks();
        setTrucks(trucks);
    }
    catch (error) {
        console.error('Failed to load nearby trucks:', error);
    }
}
// Filter trucks that have minimum viable data to display
/**
 * Determines if a food truck has enough essential data to be displayed to users.
 * @example
 * isViableTruck(foodTruck)
 * // returns true if truck has name and location, false otherwise
 * @param {FoodTruck} truck - The food truck object to validate.
 * @returns {boolean} Indicates whether the truck should be displayed.
 * @description
 *   - Checks for minimum required fields: name and valid location coordinates.
 *   - Ensures location has either coordinates OR a meaningful address.
 *   - Flags trucks missing essential data for admin review.
 */
export function isViableTruck(truck) {
    // Must have a name
    if (!truck.name || truck.name.trim() === '' || truck.name === 'Unnamed Truck') {
        console.warn(' Truck missing name:', truck.id);
        return false;
    }
    // Must have location data
    if (!truck.current_location) {
        console.warn(' Truck missing location data:', truck.name);
        return false;
    }
    // Must have either coordinates OR a meaningful address
    const hasCoordinates = typeof truck.current_location.lat === 'number' &amp;&amp;
        typeof truck.current_location.lng === 'number';
    const hasAddress = truck.current_location.address &amp;&amp;
        truck.current_location.address.trim() !== '' &amp;&amp;
        truck.current_location.address !== 'Unknown';
    if (!hasCoordinates &amp;&amp; !hasAddress) {
        console.warn(' Truck missing both coordinates and address:', truck.name);
        return false;
    }
    return true;
}
// Check if a food truck is currently open
/**
 * Determines if the food truck is currently open based on its operating hours.
 * @example
 * isTruckOpen(myFoodTruck)
 * // returns true or false depending on current time and truck's operating hours
 * @param {FoodTruck} truck - The food truck object with operating hours.
 * @returns {boolean} Indicates whether the truck is open.
 * @description
 *   - Utilizes the current day's name to fetch operating hours.
 *   - Handles potential errors in parsing operating hours.
 *   - Logs errors related to parsing time and truck name.
 *   - Uses military time format (HHMM) for comparison.
 */
export function isTruckOpen(truck) {
    const today = getCurrentDay();
    const hours = truck.operating_hours?.[today];
    // Ensure hours and its properties are not null/undefined before accessing
    if (hours == undefined ||
        hours.closed === true ||
        hours.open == undefined ||
        hours.close == undefined) {
        return false;
    }
    try {
        const now = new Date();
        const currentTime = now.getHours() * 100 + now.getMinutes();
        const openTime = Number.parseInt(hours.open.replace(':', ''), 10);
        const closeTime = Number.parseInt(hours.close.replace(':', ''), 10);
        return currentTime &gt;= openTime &amp;&amp; currentTime &lt;= closeTime;
    }
    catch (error) {
        console.error('Error parsing operating hours for truck', truck.name, error);
        return false;
    }
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/utils/dataQualityFormatters.js (Line 1:1 - Line 180:2), C:/AI/food-truck-finder-poc/dist/lib/lib/utils/dataQualityFormatters.js (Line 1:1 - Line 180:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn461" onclick="toggleCodeBlock('cloneGroup461', 'expandBtn461', 'collapseBtn461')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn461" onclick="toggleCodeBlock('cloneGroup461', 'expandBtn461', 'collapseBtn461')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup461"><code class="language-javascript text-sm text-gray-800">/**
 * SOTA Data Quality Formatting Utilities
 * Provides consistent formatting and categorization for data quality metrics
 */
// SOTA quality thresholds based on industry standards
export const QUALITY_THRESHOLDS = {
    high: 0.8, // 80%+ = High quality
    medium: 0.6, // 60-79% = Medium quality
    low: 0.6, // &lt;60% = Low quality
};
// SOTA color scheme for accessibility and visual hierarchy
export const QUALITY_CATEGORIES = {
    high: {
        label: 'High',
        color: '#22c55e',
        bgColor: 'bg-green-100',
        textColor: 'text-green-800',
    },
    medium: {
        label: 'Medium',
        color: '#f59e0b',
        bgColor: 'bg-yellow-100',
        textColor: 'text-yellow-800',
    },
    low: {
        label: 'Low',
        color: '#ef4444',
        bgColor: 'bg-red-100',
        textColor: 'text-red-800',
    },
};
/**
 * Formats a quality score as a percentage with proper precision
 * @param score - Quality score (0-1 range)
 * @param precision - Number of decimal places (default: 1)
 * @returns Formatted percentage string
 */
export function formatQualityScore(score, precision = 1) {
    if (score === null || score === undefined || Number.isNaN(score)) {
        return 'N/A';
    }
    // Ensure score is in 0-1 range
    const normalizedScore = Math.max(0, Math.min(1, score));
    return `${(normalizedScore * 100).toFixed(precision)}%`;
}
/**
 * Categorizes a quality score into high/medium/low categories
 * @param score - Quality score (0-1 range)
 * @returns Quality category object
 */
export function categorizeQualityScore(score) {
    if (score === null || score === undefined || Number.isNaN(score)) {
        return QUALITY_CATEGORIES.low;
    }
    if (score &gt;= QUALITY_THRESHOLDS.high) {
        return QUALITY_CATEGORIES.high;
    }
    else if (score &gt;= QUALITY_THRESHOLDS.medium) {
        return QUALITY_CATEGORIES.medium;
    }
    return QUALITY_CATEGORIES.low;
}
/**
 * Gets the appropriate CSS classes for a quality score badge
 * @param score - Quality score (0-1 range)
 * @returns CSS class string for badge styling
 */
export function getQualityBadgeClasses(score) {
    const category = categorizeQualityScore(score);
    return `${category.bgColor} ${category.textColor}`;
}
/**
 * Calculates quality score trend indicator
 * @param currentScore - Current quality score
 * @param previousScore - Previous quality score
 * @returns Trend object with direction and percentage change
 */
export function calculateQualityTrend(currentScore, previousScore) {
    if (currentScore == undefined || previousScore == undefined) {
        return {
            direction: 'unknown',
            change: 0,
            changeText: 'N/A',
        };
    }
    const change = currentScore - previousScore;
    const changePercentage = Math.abs(change * 100);
    if (Math.abs(change) &lt; 0.01) {
        // Less than 1% change
        return {
            direction: 'stable',
            change: 0,
            changeText: 'No change',
        };
    }
    return {
        direction: change &gt; 0 ? 'up' : 'down',
        change: changePercentage,
        changeText: `${change &gt; 0 ? '+' : '-'}${changePercentage.toFixed(1)}%`,
    };
}
/**
 * Generates quality improvement suggestions based on score
 * @param score - Quality score (0-1 range)
 * @returns Array of improvement suggestions
 */
export function getQualityImprovementSuggestions(score) {
    if (score == undefined || score &gt;= QUALITY_THRESHOLDS.high) {
        return ['Quality score is excellent! Continue maintaining data standards.'];
    }
    const suggestions = [];
    if (score &lt; QUALITY_THRESHOLDS.medium) {
        suggestions.push('Critical: Add missing core information (name, location, contact details)', 'Verify and update GPS coordinates for accurate location data', 'Add comprehensive menu information and pricing', 'Update operating hours and schedule information');
    }
    else {
        suggestions.push('Add missing optional fields (website, social media, ratings)', 'Enhance menu descriptions and categories', 'Update recent photos and promotional content', 'Verify contact information accuracy');
    }
    return suggestions;
}
/**
 * Formats quality statistics for display
 * @param stats - Raw quality statistics from database
 * @returns Formatted statistics object
 */
export function formatQualityStats(stats) {
    return {
        totalTrucks: stats.total_trucks,
        averageScore: formatQualityScore(stats.avg_quality_score),
        averageScoreRaw: stats.avg_quality_score,
        distribution: {
            high: {
                count: stats.high_quality_count,
                percentage: ((stats.high_quality_count / stats.total_trucks) * 100).toFixed(1),
            },
            medium: {
                count: stats.medium_quality_count,
                percentage: ((stats.medium_quality_count / stats.total_trucks) * 100).toFixed(1),
            },
            low: {
                count: stats.low_quality_count,
                percentage: ((stats.low_quality_count / stats.total_trucks) * 100).toFixed(1),
            },
        },
        verification: {
            verified: {
                count: stats.verified_count,
                percentage: ((stats.verified_count / stats.total_trucks) * 100).toFixed(1),
            },
            pending: {
                count: stats.pending_count,
                percentage: ((stats.pending_count / stats.total_trucks) * 100).toFixed(1),
            },
            flagged: {
                count: stats.flagged_count,
                percentage: ((stats.flagged_count / stats.total_trucks) * 100).toFixed(1),
            },
        },
    };
}
/**
 * Validates if a quality score is within acceptable range
 * @param score - Quality score to validate
 * @returns Boolean indicating if score is valid
 */
export function isValidQualityScore(score) {
    return typeof score === 'number' &amp;&amp; !Number.isNaN(score) &amp;&amp; score &gt;= 0 &amp;&amp; score &lt;= 1;
}
/**
 * Generates accessibility-friendly description for quality score
 * @param score - Quality score (0-1 range)
 * @returns Screen reader friendly description
 */
export function getQualityScoreAriaLabel(score) {
    if (!isValidQualityScore(score)) {
        return 'Quality score not available';
    }
    const category = categorizeQualityScore(score);
    const percentage = formatQualityScore(score);
    return `Data quality score: ${percentage}, categorized as ${category.label.toLowerCase()} quality`;
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/utils/apiHelpers.js (Line 1:1 - Line 21:2), C:/AI/food-truck-finder-poc/dist/lib/lib/utils/apiHelpers.js (Line 1:1 - Line 21:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn463" onclick="toggleCodeBlock('cloneGroup463', 'expandBtn463', 'collapseBtn463')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn463" onclick="toggleCodeBlock('cloneGroup463', 'expandBtn463', 'collapseBtn463')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup463"><code class="language-javascript text-sm text-gray-800">import { NextResponse } from 'next/server';
import { ZodError } from 'zod';
export function handleErrorResponse(error) {
    console.error('API error:', error);
    if (error instanceof ZodError) {
        return NextResponse.json({ error: error.errors }, { status: 400 });
    }
    return NextResponse.json({ error: error instanceof Error ? error.message : String(error) }, { status: 500 });
}
export function handleDeprecatedEndpoint(newEndpoint, documentation) {
    return NextResponse.json({
        status: 'DEPRECATED',
        message: `This endpoint has been consolidated into ${newEndpoint}`,
        migration: {
            newEndpoint,
            documentation,
            deprecationDate: '2024-12-09',
            removalDate: '2025-01-01',
        },
    }, { status: 410 });
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/security/rateLimiter.js (Line 1:1 - Line 237:2), C:/AI/food-truck-finder-poc/dist/lib/lib/security/rateLimiter.js (Line 1:1 - Line 237:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn464" onclick="toggleCodeBlock('cloneGroup464', 'expandBtn464', 'collapseBtn464')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn464" onclick="toggleCodeBlock('cloneGroup464', 'expandBtn464', 'collapseBtn464')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup464"><code class="language-javascript text-sm text-gray-800">/**
 * SOTA Rate Limiting Implementation
 * Prevents brute force attacks and API abuse with intelligent rate limiting
 */
import { NextResponse } from 'next/server'; // Added import for NextResponse
// In-memory rate limit store (in production, use Redis)
const rateLimitStore = new Map();
// Rate limit configurations for different endpoints
export const RATE_LIMIT_CONFIGS = {
    // Authentication endpoints - strict limits
    auth: {
        windowMs: 15 * 60 * 1000, // 15 minutes
        maxRequests: 5, // 5 attempts per 15 minutes
        blockDurationMs: 30 * 60 * 1000, // Block for 30 minutes
        skipSuccessfulRequests: true,
    },
    // API endpoints - moderate limits
    api: {
        windowMs: 60 * 1000, // 1 minute
        maxRequests: 60, // 60 requests per minute
        blockDurationMs: 5 * 60 * 1000, // Block for 5 minutes
        skipSuccessfulRequests: false,
    },
    // Admin endpoints - very strict limits
    admin: {
        windowMs: 60 * 1000, // 1 minute
        maxRequests: 20, // 20 requests per minute
        blockDurationMs: 15 * 60 * 1000, // Block for 15 minutes
        skipSuccessfulRequests: false,
    },
};
/**
 * Rate Limiter Service
 */
export class RateLimiter {
    // Extract logic from checkRateLimit to reduce function size
    static isBlocked(entry, now) {
        return Boolean(entry &amp;&amp; entry.blocked &amp;&amp; entry.blockUntil != undefined &amp;&amp; now &lt; entry.blockUntil);
    }
    static resetEntry(entry, now, config) {
        entry.count = 0;
        entry.resetTime = now + config.windowMs;
        entry.blocked = false;
        entry.blockUntil = undefined;
    }
    /**
     * Check if request should be rate limited
     */
    static checkRateLimit(identifier, type = 'api') {
        const config = RATE_LIMIT_CONFIGS[type];
        const now = Date.now();
        const key = `${type}:${identifier}`;
        this.cleanupExpiredEntries();
        let entry = rateLimitStore.get(key);
        if (!entry) {
            entry = { count: 0, resetTime: now + config.windowMs, blocked: false };
            rateLimitStore.set(key, entry);
        }
        if (this.isBlocked(entry, now)) {
            return {
                allowed: false,
                remaining: 0,
                resetTime: entry.resetTime,
                retryAfter: Math.ceil((entry.blockUntil - now) / 1000),
            };
        }
        if (now &gt;= entry.resetTime) {
            this.resetEntry(entry, now, config);
        }
        if (entry.count &gt;= config.maxRequests) {
            entry.blocked = true;
            entry.blockUntil = now + config.blockDurationMs;
            return {
                allowed: false,
                remaining: 0,
                resetTime: entry.resetTime,
                retryAfter: Math.ceil(config.blockDurationMs / 1000),
            };
        }
        entry.count += 1;
        rateLimitStore.set(key, entry);
        return {
            allowed: true,
            remaining: config.maxRequests - entry.count,
            resetTime: entry.resetTime,
        };
    }
    /**
     * Record successful request (for auth endpoints)
     */
    static recordSuccess(identifier, type = 'api') {
        const config = RATE_LIMIT_CONFIGS[type];
        if (!config.skipSuccessfulRequests)
            return;
        const key = `${type}:${identifier}`;
        const entry = rateLimitStore.get(key);
        if (entry) {
            // Reset counter on successful auth
            entry.count = 0;
            entry.blocked = false;
            entry.blockUntil = undefined;
            rateLimitStore.set(key, entry);
        }
    }
    /**
     * Get rate limit status without incrementing
     */
    static getStatus(identifier, type = 'api') {
        const config = RATE_LIMIT_CONFIGS[type];
        const now = Date.now();
        const key = `${type}:${identifier}`;
        const entry = rateLimitStore.get(key);
        if (!entry) {
            return {
                remaining: config.maxRequests,
                resetTime: now + config.windowMs,
                blocked: false,
            };
        }
        // Check if blocked
        if (entry.blocked &amp;&amp; entry.blockUntil != undefined &amp;&amp; now &lt; entry.blockUntil) {
            // Changed != undefined to != null
            return {
                remaining: 0,
                resetTime: entry.resetTime,
                blocked: true,
                retryAfter: Math.ceil((entry.blockUntil - now) / 1000),
            };
        }
        // Check if window expired
        if (now &gt;= entry.resetTime) {
            return {
                remaining: config.maxRequests,
                resetTime: now + config.windowMs,
                blocked: false,
            };
        }
        return {
            remaining: Math.max(0, config.maxRequests - entry.count),
            resetTime: entry.resetTime,
            blocked: false,
        };
    }
    /**
     * Clean up expired entries to prevent memory leaks
     */
    static cleanupExpiredEntries() {
        const now = Date.now();
        for (const [key, entry] of rateLimitStore.entries()) {
            // Remove entries that are expired and not blocked
            if (now &gt;= entry.resetTime &amp;&amp;
                (!entry.blocked || entry.blockUntil == undefined || now &gt;= entry.blockUntil)) {
                // Changed == undefined to == null
                rateLimitStore.delete(key);
            }
        }
    }
    /**
     * Clear all rate limit data for an identifier
     */
    static clearLimits(identifier, type) {
        if (type) {
            const key = `${type}:${identifier}`;
            rateLimitStore.delete(key);
        }
        else {
            // Clear all types for this identifier
            for (const limitType of Object.keys(RATE_LIMIT_CONFIGS)) {
                // Added type assertion
                const key = `${limitType}:${identifier}`;
                rateLimitStore.delete(key);
            }
        }
    }
    /**
     * Get rate limit statistics
     */
    static getStats() {
        const stats = {
            totalEntries: rateLimitStore.size,
            blockedEntries: 0,
            entriesByType: {},
        };
        for (const [key, entry] of rateLimitStore.entries()) {
            const type = key.split(':')[0];
            stats.entriesByType[type] = (stats.entriesByType[type] ?? 0) + 1;
            if (entry.blocked) {
                stats.blockedEntries += 1;
            }
        }
        return stats;
    }
}
/**
 * Utility function to get client identifier from request
 */
export function getClientIdentifier(request) {
    // Try to get IP address from various headers
    const forwarded = request.headers.get('x-forwarded-for');
    const realIp = request.headers.get('x-real-ip');
    const cfConnectingIp = request.headers.get('cf-connecting-ip');
    // Use the first available IP
    const ip = forwarded?.split(',')[0]?.trim() ?? realIp ?? cfConnectingIp ?? 'unknown';
    // Include user agent for more specific identification
    const userAgent = request.headers.get('user-agent') ?? 'unknown';
    // Create a hash of IP + User Agent for better identification
    return `${ip}:${userAgent.slice(0, 50)}`;
}
/**
 * Rate limiting middleware for API routes
 */
export function withRateLimit(handler, type = 'api') {
    return async (request) =&gt; {
        const identifier = getClientIdentifier(request);
        const result = RateLimiter.checkRateLimit(identifier, type);
        if (result.allowed === false) {
            const headers = new Headers({
                'X-RateLimit-Limit': RATE_LIMIT_CONFIGS[type].maxRequests.toString(),
                'X-RateLimit-Remaining': '0',
                'X-RateLimit-Reset': new Date(result.resetTime).toISOString(),
            });
            if (result.retryAfter) {
                headers.set('Retry-After', result.retryAfter.toString());
            }
            return new NextResponse('Too Many Requests', { status: 429, headers });
        }
        const response = await handler(request);
        // Update headers on successful requests if not skipped
        if (RATE_LIMIT_CONFIGS[type].skipSuccessfulRequests === false) {
            const status = RateLimiter.getStatus(identifier, type);
            response.headers.set('X-RateLimit-Limit', RATE_LIMIT_CONFIGS[type].maxRequests.toString());
            response.headers.set('X-RateLimit-Remaining', status.remaining.toString());
            response.headers.set('X-RateLimit-Reset', new Date(status.resetTime).toISOString());
        }
        return response;
    };
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/security/auditLogger.js (Line 5:17 - Line 234:2), C:/AI/food-truck-finder-poc/dist/lib/lib/security/auditLogger.js (Line 5:27 - Line 234:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn466" onclick="toggleCodeBlock('cloneGroup466', 'expandBtn466', 'collapseBtn466')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn466" onclick="toggleCodeBlock('cloneGroup466', 'expandBtn466', 'collapseBtn466')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup466"><code class="language-javascript text-sm text-gray-800">;
/**
 * Audit Logger Service
 */
export class AuditLogger {
    /**
     * Log admin action with full audit trail
     */
    static async logAdminAction(options) {
        const { userId, userEmail, action, resourceType, resourceId, details, request } = options;
        const auditEntry = {
            user_id: userId,
            user_email: userEmail,
            action,
            resource_type: resourceType,
            resource_id: resourceId,
            details,
            ip_address: request?.ip,
            user_agent: request?.userAgent,
            session_id: request?.sessionId,
            timestamp: new Date().toISOString(),
            severity: this.determineSeverity(action, resourceType),
        };
        await this.writeAuditLog(auditEntry);
        // Log to console for immediate monitoring
        console.info('Admin Action Audit:', {
            user: userEmail,
            action,
            resource: resourceId === undefined ? resourceType : `${resourceType}:${resourceId}`,
            timestamp: auditEntry.timestamp,
        });
    }
    /**
     * Log security event
     */
    static async logSecurityEvent(event) {
        const logEntry = {
            event_type: event.event_type,
            user_id: event.user_id,
            user_email: event.user_email,
            ip_address: event.ip_address,
            user_agent: event.user_agent,
            details: event.details,
            severity: event.severity,
            timestamp: new Date().toISOString(),
        };
        try {
            if (supabaseAdmin) {
                await supabaseAdmin.from('security_events').insert(logEntry);
            }
        }
        catch (error) {
            console.error('Failed to log security event:', error);
        }
        // Always log security events to console
        console.info('Security Event:', logEntry);
        // Alert on critical security events
        if (event.severity === 'critical' || event.severity === 'error') {
            console.warn('SECURITY ALERT:', logEntry);
        }
    }
    /**
     * Log authentication events
     */
    static async logAuthEvent(options) {
        const { eventType, userEmail, userId, request, details } = options;
        const severity = eventType === 'login_failure' ? 'warning' : 'info';
        await this.logSecurityEvent({
            event_type: eventType,
            user_id: userId,
            user_email: userEmail,
            ip_address: request?.ip,
            user_agent: request?.userAgent,
            details,
            severity,
        });
    }
    /**
     * Log data access events
     */
    static async logDataAccess(options) {
        const { userId, userEmail, resourceType, resourceId, action = 'read', request } = options;
        await this.logSecurityEvent({
            event_type: 'data_access',
            user_id: userId,
            user_email: userEmail,
            ip_address: request?.ip,
            user_agent: request?.userAgent,
            details: {
                resource_type: resourceType,
                resource_id: resourceId,
                action,
            },
            severity: 'info',
        });
    }
    /**
     * Write audit log to database
     */
    static async writeAuditLog(entry) {
        try {
            if (supabaseAdmin) {
                await supabaseAdmin.from('audit_logs').insert(entry);
            }
        }
        catch (error) {
            console.error('Failed to write audit log:', error);
            // Don't throw - audit logging should not break application flow
        }
    }
    /**
     * Determine severity based on action and resource type
     */
    static determineSeverity(action, resourceType) {
        // Critical actions
        if (action.includes('delete') || action.includes('remove')) {
            return 'critical';
        }
        // Warning actions
        if (action.includes('update') || action.includes('modify') || action.includes('change')) {
            return 'warning';
        }
        // Admin-specific actions
        if (resourceType === 'user' || resourceType === 'admin' || resourceType === 'system') {
            return 'warning';
        }
        // Default to info
        return 'info';
    }
    /**
     * Get audit logs for a specific user
     */
    static async getUserAuditLogs(userId, limit = 100, offset = 0) {
        try {
            if (!supabaseAdmin) {
                return [];
            }
            const { data, error } = await supabaseAdmin
                .from('audit_logs')
                .select('*')
                .eq('user_id', userId)
                .order('timestamp', { ascending: false })
                .range(offset, offset + limit - 1);
            if (error) {
                console.error('Failed to fetch user audit logs:', error);
                return [];
            }
            return data ?? [];
        }
        catch (error) {
            console.error('Error fetching user audit logs:', error);
            return [];
        }
    }
    /**
     * Get recent security events
     */
    static async getRecentSecurityEvents(hours = 24, severity) {
        try {
            if (!supabaseAdmin) {
                return [];
            }
            const startTime = new Date();
            startTime.setHours(startTime.getHours() - hours);
            let query = supabaseAdmin
                .from('security_events')
                .select('*')
                .gte('timestamp', startTime.toISOString())
                .order('timestamp', { ascending: false });
            if (severity) {
                query = query.eq('severity', severity);
            }
            const { data, error } = await query.limit(500);
            if (error) {
                console.error('Failed to fetch security events:', error);
                return [];
            }
            return data ?? [];
        }
        catch (error) {
            console.error('Error fetching security events:', error);
            return [];
        }
    }
}
/**
 * Security monitoring utilities
 */
export const SecurityMonitor = {
    /**
     * Check for suspicious activity patterns
     */
    async checkSuspiciousActivity(userId) {
        const reasons = [];
        let riskLevel = 'low';
        try {
            // Check recent failed login attempts
            const recentEvents = await AuditLogger.getRecentSecurityEvents(1, 'warning');
            const failedLogins = recentEvents.filter((event) =&gt; event.event_type === 'login_failed' &amp;&amp; event.user_id === userId);
            if (failedLogins.length &gt; 5) {
                reasons.push('Multiple failed login attempts');
                riskLevel = 'high';
            }
            else if (failedLogins.length &gt; 2) {
                reasons.push('Recent failed login attempts');
                riskLevel = 'medium';
            }
            // Check for unusual access patterns
            const auditLogs = await AuditLogger.getUserAuditLogs(userId, 50);
            const recentActions = auditLogs.filter((log) =&gt; new Date(log.timestamp) &gt; new Date(Date.now() - 60 * 60 * 1000));
            if (recentActions.length &gt; 20) {
                reasons.push('High activity volume');
                riskLevel = riskLevel === 'high' ? 'high' : 'medium';
            }
            return {
                suspicious: reasons.length &gt; 0,
                reasons,
                riskLevel,
            };
        }
        catch (error) {
            console.error('Error checking suspicious activity:', error);
            return {
                suspicious: false,
                reasons: [],
                riskLevel: 'low',
            };
        }
    },
};</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/schemas/truck.js (Line 1:1 - Line 127:2), C:/AI/food-truck-finder-poc/dist/lib/lib/schemas/truck.js (Line 1:1 - Line 127:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn468" onclick="toggleCodeBlock('cloneGroup468', 'expandBtn468', 'collapseBtn468')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn468" onclick="toggleCodeBlock('cloneGroup468', 'expandBtn468', 'collapseBtn468')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup468"><code class="language-javascript text-sm text-gray-800">import { z } from 'zod';
// PriceRange Schema
export const PriceRangeSchema = z.union([
    z.literal('$'),
    z.literal('$$'),
    z.literal('$$$'),
]);
// Coordinates Schema
export const CoordinatesSchema = z.object({
    lat: z.number().optional(),
    lng: z.number().optional(),
});
// LocationData Schema
export const LocationDataSchema = z.object({
    address: z.string().optional(),
    city: z.string().optional(),
    state: z.string().optional(),
    landmarks: z.array(z.string()),
    coordinates: CoordinatesSchema,
    confidence: z.number(),
    raw_location_text: z.string().optional(),
});
// DailyOperatingHours Schema
export const DailyOperatingHoursSchema = z.union([
    z.object({
        open: z.string(),
        close: z.string(),
        closed: z.literal(false),
    }),
    z.object({
        closed: z.literal(true),
    }),
    z.undefined(),
]);
// OperatingHours Schema
export const OperatingHoursSchema = z.object({
    monday: DailyOperatingHoursSchema,
    tuesday: DailyOperatingHoursSchema,
    wednesday: DailyOperatingHoursSchema,
    thursday: DailyOperatingHoursSchema,
    friday: DailyOperatingHoursSchema,
    saturday: DailyOperatingHoursSchema,
    sunday: DailyOperatingHoursSchema,
}).catchall(DailyOperatingHoursSchema); // For the index signature [key: string]: DailyOperatingHours;
// MenuItem Schema
export const MenuItemSchema = z.object({
    name: z.string(),
    description: z.string().optional(),
    price: z.union([z.number(), z.string()]).optional(),
    dietary_tags: z.array(z.any()), // 'any[]' in interface, so 'z.any()' for now
    is_popular: z.boolean().optional(),
});
// MenuCategory Schema
export const MenuCategorySchema = z.object({
    name: z.string(),
    items: z.array(MenuItemSchema),
});
// ContactInfo Schema (from ExtractedFoodTruckDetails)
export const ContactInfoSchema = z.object({
    phone: z.string().optional(),
    email: z.string().optional(),
    website: z.string().optional(),
});
// SocialMedia Schema (from ExtractedFoodTruckDetails)
export const SocialMediaSchema = z.object({
    instagram: z.string().optional(),
    facebook: z.string().optional(),
    twitter: z.string().optional(),
    tiktok: z.string().optional(),
    yelp: z.string().optional(),
});
// ScheduledLocation Schema (from ExtractedFoodTruckDetails)
export const ScheduledLocationSchema = z.object({
    address: z.string().optional(),
    city: z.string().optional(),
    state: z.string().optional(),
    zip_code: z.string().optional(),
    lat: z.number().optional(),
    lng: z.number().optional(),
    timestamp: z.string(),
    start_time: z.string(),
    end_time: z.string(),
});
// FoodTruckSchema
export const FoodTruckSchema = z.object({
    name: z.string(),
    description: z.string().optional(),
    current_location: z.object({
        lat: z.number(),
        lng: z.number(),
        address: z.string().optional(),
        timestamp: z.string(),
    }),
    scheduled_locations: z.array(ScheduledLocationSchema).optional(),
    operating_hours: OperatingHoursSchema,
    menu: z.array(MenuCategorySchema),
    contact_info: ContactInfoSchema,
    social_media: SocialMediaSchema,
    cuisine_type: z.array(z.string()),
    price_range: PriceRangeSchema.optional(),
    specialties: z.array(z.string()),
    data_quality_score: z.number(),
    verification_status: z.union([
        z.literal('pending'),
        z.literal('verified'),
        z.literal('flagged'),
    ]),
    source_urls: z.array(z.string()),
    last_scraped_at: z.string(),
    test_run_flag: z.boolean().optional(),
    website: z.string().optional(),
    phone_number: z.string().optional(),
    email: z.string().optional(),
    instagram_handle: z.string().optional(),
    facebook_handle: z.string().optional(),
    twitter_handle: z.string().optional(),
    schedule: z.array(z.any()).optional(), // 'unknown[]' in interface, so 'z.any()' for now
    average_rating: z.number().optional(),
    review_count: z.number().optional(),
});
// Truck Schema (extends FoodTruckSchema)
export const TruckSchema = FoodTruckSchema.extend({
    id: z.string(),
    created_at: z.string(),
    updated_at: z.string(),
    is_active: z.boolean().optional(),
});</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/pipeline/scrapingProcessor.js (Line 3:42 - Line 176:2), C:/AI/food-truck-finder-poc/dist/lib/lib/pipeline/scrapingProcessor.js (Line 3:45 - Line 176:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn469" onclick="toggleCodeBlock('cloneGroup469', 'expandBtn469', 'collapseBtn469')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn469" onclick="toggleCodeBlock('cloneGroup469', 'expandBtn469', 'collapseBtn469')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup469"><code class="language-javascript text-sm text-gray-800">;
import { validateInputAndPrepare, buildTruckDataSchema, handleDuplicateCheck, finalizeJobStatus, } from './pipelineHelpers';
/**
 * Initiates web scraping for a specified food truck website.
 * @example
 * handleScraping(&quot;https://foodtruck.com&quot;, &quot;job123&quot;)
 * Returns data object with markdown content
 * @param {string} targetUrl - The URL of the food truck website to scrape.
 * @param {string} jobId - The unique identifier for the scraping job.
 * @returns {Object} An object containing the scraped data, including markdown content.
 * @description
 *   - Utilizes firecrawl library to perform web scraping.
 *   - Calls handleJobFailure if scraping is unsuccessful or markdown content is missing.
 *   - Logs the progress and success of the scraping process in the console.
 */
async function handleScraping(targetUrl, jobId) {
    console.info(`Starting scrape for ${targetUrl}`);
    const scrapeResult = await firecrawl.scrapeFoodTruckWebsite(targetUrl);
    if (!scrapeResult.success || !scrapeResult.data?.markdown) {
        const error = scrapeResult.error ?? 'Scraping failed or markdown content not found';
        await handleJobFailure(jobId, error);
        throw new Error(error);
    }
    console.info(`Scraping successful for ${targetUrl}, proceeding to Gemini extraction.`);
    return scrapeResult.data;
}
/**
 * Handles the extraction of food truck details using Gemini and manages job failures.
 * @example
 * handleGeminiExtraction(&quot;sample_markdown&quot;, &quot;http://example.com&quot;, &quot;12345&quot;)
 * { name: &quot;Sample Food Truck&quot;, location: &quot;123 Main St.&quot; }
 * @param {string} markdown - The Markdown content containing food truck details.
 * @param {string} sourceUrl - The URL of the source from which details are extracted.
 * @param {string} jobId - The identifier for the job being processed.
 * @returns {Object} The extracted food truck details if successful.
 * @description
 *   - Utilizes Gemini to extract data from the provided Markdown content.
 *   - Handles failure scenarios by logging errors and updating job status.
 *   - Throws an error when extraction is unsuccessful.
 */
async function handleGeminiExtraction(markdown, sourceUrl, jobId) {
    const geminiResult = await gemini.extractFoodTruckDetailsFromMarkdown(markdown, sourceUrl);
    if (!geminiResult.success || !geminiResult.data) {
        const error = geminiResult.error ?? 'Gemini data extraction failed';
        await handleJobFailure(jobId, error);
        throw new Error(error);
    }
    console.info(`Gemini extraction successful for ${sourceUrl}.`);
    return geminiResult.data;
}
/**
* Handles the failure of a job by updating its status.
* @example
* handleJobFailure('job1234', 'Timeout error')
* // Output: Logs an error message and updates the job status.
* @param {string} jobId - The unique identifier of the job that failed.
* @param {string} error - The error message describing the reason for failure.
* @returns {Promise&lt;void&gt;} Resolves successfully once the job status is updated.
* @description
*   - Logs the error to the console for debugging purposes.
*   - Checks if the current job status is not already 'failed' before updating.
*   - Updates the job status to 'failed' if applicable, capturing any errors encountered.
*   - Manages any errors that arise during the status update attempt.
*/
async function handleJobFailure(jobId, error) {
    console.error(`Job ${jobId} failed:`, error);
    try {
        const currentJob = await ScrapingJobService.getJobsByStatus('all').then((jobs) =&gt; jobs.find((j) =&gt; j.id === jobId));
        if (currentJob &amp;&amp; currentJob.status !== 'failed') {
            await ScrapingJobService.updateJobStatus(jobId, 'failed', { errors: [error] });
        }
    }
    catch (statusUpdateError) {
        console.error(`Error updating job ${jobId} status to failed:`, statusUpdateError);
    }
}
/**
 * Manages retry logic for a scraping job based on its current retry count.
 * @example
 * handleRetryLogic(&quot;job123&quot;)
 * undefined
 * @param {string} jobId - The unique identifier for the scraping job.
 * @returns {Promise&lt;void&gt;} Does not return a value but handles retries or logs errors.
 * @description
 *   - Utilizes ScrapingJobService to increment the retry count for the given job.
 *   - Determines whether to retry the job based on retry_count and max_retries properties.
 *   - Logs messages to inform about retry attempts or if max retries have been reached.
 *   - Catches and logs errors encountered during the retry process.
 */
async function handleRetryLogic(jobId) {
    try {
        const job = await ScrapingJobService.incrementRetryCount(jobId);
        if (job &amp;&amp; typeof job.retry_count === 'number' &amp;&amp; typeof job.max_retries === 'number') {
            if (job.retry_count &lt; job.max_retries) {
                console.info(`Retrying job ${jobId} (attempt ${job.retry_count}/${job.max_retries})`);
                setTimeout(() =&gt; {
                    void processScrapingJob(jobId);
                }, 5000);
            }
            else {
                console.warn(`Job ${jobId} reached max retries (${job.max_retries}).`);
            }
        }
        else {
            console.error(`Job ${jobId}: Could not get valid retry_count or max_retries. Won't attempt retry.`);
        }
    }
    catch (retryError) {
        console.error(`Error during retry logic for job ${jobId}:`, retryError);
    }
}
/**
 * Processes a scraping job by managing its lifecycle and data extraction.
 * @example
 * processScrapingJob('12345')
 * // Scraping job 12345 completed successfully and data processed.
 * @param {string} jobId - The unique identifier for the scraping job.
 * @returns {Promise&lt;void&gt;} Resolves when the job is completed or retried.
 * @description
 *   - Updates the scraping job status to 'running' at the beginning and 'completed' at the end of the process.
 *   - Performs data scraping and extraction using job's target URL.
 *   - Handles scenarios where a target URL is not specified, resulting in an error.
 *   - Implements retry logic in case of failure during the job processing.
 */
export async function processScrapingJob(jobId) {
    try {
        const job = await ScrapingJobService.updateJobStatus(jobId, 'running');
        if (!job.target_url) {
            throw new Error('No target URL specified');
        }
        const scrapeData = await handleScraping(job.target_url, jobId);
        const extractedData = await handleGeminiExtraction(scrapeData.markdown, scrapeData.source_url ?? job.target_url, jobId);
        await ScrapingJobService.updateJobStatus(jobId, 'completed', {
            data_collected: extractedData,
            completed_at: new Date().toISOString(),
        });
        await createOrUpdateFoodTruck(jobId, extractedData, scrapeData.source_url ?? job.target_url);
        console.info(`Scraping job ${jobId} completed successfully and data processed.`);
    }
    catch {
        await handleRetryLogic(jobId);
    }
}
/**
* Creates or updates a food truck entry based on extracted data and handles job processing.
* @example
* createOrUpdateFoodTruck('123abc', extractedTruckData, 'http://example.com')
* undefined
* @param {string} jobId - Unique identifier for the job being processed.
* @param {ExtractedFoodTruckDetails} extractedTruckData - Object containing details about the food truck extracted from a source.
* @param {string} sourceUrl - The URL from which the food truck data was extracted.
* @returns {Promise&lt;void&gt;} Resolves when processing is complete; returns nothing explicitly.
* @description
*   - Validates the input data before proceeding with creation or update.
*   - Applies a duplicate check mechanism to avoid redundant entries.
*   - Finalizes the job status, ensuring proper completion or failure handling.
*   - Logs error details for troubleshooting job processing issues.
*/
export async function createOrUpdateFoodTruck(jobId, extractedTruckData, sourceUrl) {
    try {
        const validation = await validateInputAndPrepare(jobId, extractedTruckData, sourceUrl);
        if (!validation.isValid) {
            return;
        }
        const truckData = buildTruckDataSchema(extractedTruckData, sourceUrl, validation.name);
        const truck = await handleDuplicateCheck(jobId, truckData, validation.name);
        await finalizeJobStatus(jobId, truck, sourceUrl);
    }
    catch (error) {
        const errorMessage = error instanceof Error ? error.message : 'Unknown error';
        console.error(`Job ${jobId}: Error in createOrUpdateFoodTruck from ${sourceUrl ?? 'Unknown Source'}:`, error);
        await handleJobFailure(jobId, `Food truck data processing/saving failed: ${errorMessage}`);
    }
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/pipeline/pipelineHelpers.js (Line 2:38 - Line 390:2), C:/AI/food-truck-finder-poc/dist/lib/lib/pipeline/pipelineHelpers.js (Line 2:41 - Line 390:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn470" onclick="toggleCodeBlock('cloneGroup470', 'expandBtn470', 'collapseBtn470')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn470" onclick="toggleCodeBlock('cloneGroup470', 'expandBtn470', 'collapseBtn470')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup470"><code class="language-javascript text-sm text-gray-800">;
// Helper function to validate input and prepare basic data
/**
 * Validates input data and prepares food truck information.
 * @example
 * validateInputAndPrepare('job123', extractedTruckDataInstance, 'http://sourceurl.com')
 * { isValid: true, name: 'Food Truck Name' }
 * @param {string} jobId - The job identifier used for logging and job status updates.
 * @param {ExtractedFoodTruckDetails} extractedTruckData - Contains details about the food truck such as name and other attributes.
 * @param {string} sourceUrl - URL where the data was originally extracted from.
 * @returns {Promise&lt;{ isValid: boolean; name: string }&gt;} Result of validation with food truck name.
 * @description
 *   - Logs a warning if the source URL is missing, but continues process as it might not be critical.
 *   - Ensures the food truck name has a fallback value if it's missing in the extracted data.
 *   - Updates job status as 'failed' if validation does not pass.
 */
export async function validateInputAndPrepare(jobId, extractedTruckData, sourceUrl) {
    // Basic input validation
    if (!validateTruckData(jobId, extractedTruckData)) {
        await ScrapingJobService.updateJobStatus(jobId, 'failed', {
            errors: ['Invalid extracted data received from AI processing step.'],
        });
        return { isValid: false, name: '' };
    }
    if (!sourceUrl) {
        // Log a warning but proceed if sourceUrl is missing, as it might not be critical for all data.
        console.warn(`Job ${jobId}: Missing sourceUrl for food truck data, proceeding without it.`);
    }
    const name = extractedTruckData.name ?? 'Unknown Food Truck'; // Ensure name has a fallback
    console.info(`Job ${jobId}: Preparing to create/update food truck: ${name} from ${sourceUrl ?? 'Unknown Source'}`);
    return { isValid: true, name };
}
// New helper function for operating hours
/**
 * Constructs a weekly operating hours object for a food truck.
 * @example
 * buildOperatingHours({ monday: { open: '8:00', close: '17:00' } })
 * // Returns: { monday: { open: '8:00', close: '17:00' }, tuesday: { closed: true }, ... }
 * @param {ExtractedFoodTruckDetails['operating_hours']} extractedOperatingHours - The raw operating hours extracted for each day of the week.
 * @returns {Object} An object containing operating hours for each day of the week, defaulting to closed if not provided.
 * @description
 *   - Days without specified operating hours default to closed.
 *   - Ensures consistency in data structure by providing default closed status.
 *   - Uses TypeScript's 'const' assertion for type safety on closed status.
 */
function buildOperatingHours(extractedOperatingHours) {
    if (extractedOperatingHours == undefined) {
        return {
            monday: { closed: true },
            tuesday: { closed: true },
            wednesday: { closed: true },
            thursday: { closed: true },
            friday: { closed: true },
            saturday: { closed: true },
            sunday: { closed: true },
        };
    }
    return {
        monday: extractedOperatingHours.monday ?? { closed: true },
        tuesday: extractedOperatingHours.tuesday ?? { closed: true },
        wednesday: extractedOperatingHours.wednesday ?? { closed: true },
        thursday: extractedOperatingHours.thursday ?? { closed: true },
        friday: extractedOperatingHours.friday ?? { closed: true },
        saturday: extractedOperatingHours.saturday ?? { closed: true },
        sunday: extractedOperatingHours.sunday ?? { closed: true },
    };
}
// New helper function for scheduled locations
/**
 * Transforms and sanitizes an array of scheduled food truck locations.
 * @example
 * buildScheduledLocations([{ lat: 34.05, lng: -118.25, address: &quot;123 Main St&quot;, start_time: &quot;10:00&quot;, end_time: &quot;14:00&quot; }])
 * [{ lat: 34.05, lng: -118.25, address: &quot;123 Main St&quot;, start_time: &quot;10:00&quot;, end_time: &quot;14:00&quot;, timestamp: &quot;2023-10-19T14:00:00.000Z&quot; }]
 * @param {ExtractedFoodTruckDetails['scheduled_locations']} scheduledLocations - Array of scheduled food truck location objects.
 * @returns {Array} Array of sanitized location objects.
 * @description
 *   - Ensures latitude and longitude values are numbers; defaults to 0 if not.
 *   - Adds a current timestamp to each location object in ISO format.
 *   - Uses nullish coalescing to ensure address, start_time, and end_time are either their values or undefined.
 */
function buildScheduledLocations(scheduledLocations) {
    if (!Array.isArray(scheduledLocations)) {
        return;
    }
    return scheduledLocations.map((loc) =&gt; ({
        lat: typeof loc.lat === 'number' ? loc.lat : 0,
        lng: typeof loc.lng === 'number' ? loc.lng : 0,
        address: loc.address ?? undefined,
        start_time: loc.start_time ?? undefined,
        end_time: loc.end_time ?? undefined,
        timestamp: new Date().toISOString(),
    }));
}
// Helper function to build truck data schema
/**
 * Constructs a FoodTruckSchema object from extracted food truck details.
 * @example
 * buildTruckDataSchema(extractedTruckData, 'http://sourceUrl.com', 'Truck Name')
 * { name: 'Truck Name', ... }
 * @param {ExtractedFoodTruckDetails} extractedTruckData - Object containing raw data extracted from a food truck resource.
 * @param {string} sourceUrl - URL source where the truck data was extracted from.
 * @param {string} name - Name of the food truck.
 * @returns {FoodTruckSchema} Fully constructed food truck schema ready for use.
 * @description
 *   - Ensures `description` and `price_range` are kept undefined if missing or null from extracted data.
 *   - Filters any non-string values from the `cuisine_type` array.
 *   - Ensures the `source_urls` field is always an array, even if empty or undefined.
 *   - Default verification status is 'pending' and a default data quality score is set to 0.5.
 */
export function buildTruckDataSchema(extractedTruckData, sourceUrl, name) {
    const currentLocation = buildLocationData(extractedTruckData);
    return {
        name: name,
        description: extractedTruckData.description ?? undefined, // Keep as undefined if null/missing
        current_location: currentLocation,
        scheduled_locations: buildScheduledLocations(extractedTruckData.scheduled_locations),
        operating_hours: buildOperatingHours(extractedTruckData.operating_hours),
        menu: processMenuData(extractedTruckData),
        contact_info: buildContactInfo(extractedTruckData.contact_info),
        social_media: buildSocialMedia(extractedTruckData.social_media),
        cuisine_type: Array.isArray(extractedTruckData.cuisine_type)
            ? extractedTruckData.cuisine_type.filter((c) =&gt; typeof c === 'string')
            : [],
        price_range: extractedTruckData.price_range ?? undefined, // Ensure it's one of the allowed enum values or undefined
        specialties: Array.isArray(extractedTruckData.specialties)
            ? extractedTruckData.specialties
            : [],
        data_quality_score: 0.5, // Default score - confidence_score not available in type
        verification_status: 'pending',
        source_urls: sourceUrl != undefined &amp;&amp; sourceUrl !== '' ? [sourceUrl] : [], // Ensure source_urls is always an array
        last_scraped_at: new Date().toISOString(),
    };
}
// Helper function to handle duplicate checking and resolution
/**
 * Checks for duplicates before creating a new food truck entry.
 * @example
 * handleDuplicateCheck('12345', truckDataObject, 'Awesome Food Truck')
 * // Returns a promise resolving to the created truck object or result from handling a duplicate.
 * @param {string} jobId - The unique identifier for the job process.
 * @param {FoodTruckSchema} truckData - The data schema representing the food truck details.
 * @param {string} name - The name of the food truck being processed.
 * @returns {Promise&lt;FoodTruck&gt;} Returns a promise that resolves to the created or existing food truck.
 * @description
 *   - Utilizes the DuplicatePreventionService to verify if a similar truck already exists.
 *   - If a duplicate is detected, delegates to a separate function to handle the duplicate scenario.
 *   - Logs errors encountered during the creation process.
 */
export async function handleDuplicateCheck(jobId, truckData, name) {
    // Check for duplicates before creating
    console.info(`Job ${jobId}: Checking for duplicates before creating truck: ${name}`);
    const duplicateCheck = await DuplicatePreventionService.checkForDuplicates(truckData);
    if (duplicateCheck.isDuplicate &amp;&amp; duplicateCheck.bestMatch) {
        return await handleDuplicate(jobId, truckData, duplicateCheck);
    }
    // No duplicates found, create new truck
    const truck = await FoodTruckService.createTruck(truckData);
    if ('error' in truck) {
        console.error(`Job ${jobId}: Error creating new truck: ${truck.error}`);
        throw new Error(`Failed to create truck: ${truck.error}`);
    }
    return truck;
}
/**
 * Handles potential duplicate food truck entries by either merging, updating, or creating new truck data.
 * @example
 * handleDuplicate(&quot;job123&quot;, truckData, duplicateCheck)
 * // Returns the processed Food Truck object.
 * @param {string} jobId - Unique identifier for the job processing potential duplicates.
 * @param {FoodTruckSchema} truckData - Data representing the food truck to be processed.
 * @param {DuplicateCheckResult} duplicateCheck - Results from a duplicate check operation.
 * @returns {Promise&lt;FoodTruck&gt;} Returns a promise that resolves to a Food Truck object if successful.
 * @description
 *   - Uses duplicate check results to determine whether to merge, update, or create new truck data.
 *   - Logs information about the operation performed and potential duplicates found.
 *   - Contains error handling for each operation, including fallback creations in case of failures.
 *   - Provides warnings when creating new entries despite finding possible duplicates.
 */
async function handleDuplicate(jobId, truckData, duplicateCheck) {
    const { bestMatch } = duplicateCheck;
    if (!bestMatch) {
        // This should not happen if isDuplicate is true, but as a safeguard:
        const truck = await FoodTruckService.createTruck(truckData);
        if ('error' in truck) {
            throw new Error(`Failed to create truck: ${truck.error}`);
        }
        return truck;
    }
    console.info(`Job ${jobId}: Found potential duplicate (${Math.round(bestMatch.similarity * 100)}% similarity) with truck: ${bestMatch.existingTruck.name}`);
    if (bestMatch.confidence === 'high' &amp;&amp; bestMatch.recommendation === 'merge') {
        const truck = await DuplicatePreventionService.mergeDuplicates(bestMatch.existingTruck.id, bestMatch.existingTruck.id);
        if ('error' in truck) {
            console.error(`Job ${jobId}: Error merging duplicates: ${truck.error}`);
            const newTruck = await FoodTruckService.createTruck(truckData);
            if ('error' in newTruck) {
                console.error(`Job ${jobId}: Error creating truck after merge failure: ${newTruck.error}`);
                throw new Error(`Failed to merge or create truck: ${newTruck.error}`);
            }
            return newTruck;
        }
        console.info(`Job ${jobId}: Merged data with existing truck: ${truck.name} (ID: ${truck.id})`);
        return truck;
    }
    else if (bestMatch.recommendation === 'update') {
        const truck = await FoodTruckService.updateTruck(bestMatch.existingTruck.id, truckData);
        if ('error' in truck) {
            console.error(`Job ${jobId}: Error updating existing truck: ${truck.error}`);
            const newTruck = await FoodTruckService.createTruck(truckData);
            if ('error' in newTruck) {
                console.error(`Job ${jobId}: Error creating truck after update failure: ${newTruck.error}`);
                throw new Error(`Failed to update or create truck: ${newTruck.error}`);
            }
            return newTruck;
        }
        console.info(`Job ${jobId}: Updated existing truck: ${truck.name} (ID: ${truck.id})`);
        return truck;
    }
    else {
        const truck = await FoodTruckService.createTruck(truckData);
        if ('error' in truck) {
            console.error(`Job ${jobId}: Error creating truck despite potential duplicate: ${truck.error}`);
            throw new Error(`Failed to create truck: ${truck.error}`);
        }
        console.warn(`Job ${jobId}: Created new truck despite potential duplicate (${duplicateCheck.reason ?? 'unknown reason'})`);
        return truck;
    }
}
// Helper function to finalize job status
/**
* Logs the successful creation of a food truck and updates the job status to completed.
* @example
* finalizeJobStatus('12345', { name: 'Best Food Truck', id: 'FT123' }, 'http://example.com')
* // Logs: Job 12345: Successfully created food truck: Best Food Truck (ID: FT123) from http://example.com
* @param {string} jobId - Unique identifier of the scraping job.
* @param {FoodTruck} truck - Object representing the food truck that was created.
* @param {string} sourceUrl - URL from where the data was sourced.
* @returns {Promise&lt;void&gt;} Resolves when the job status is updated.
* @description
*   - Logs the truck creation event using `console.info`.
*   - Ensures the job status is set to 'completed' with the current timestamp.
*   - Uses a default source message if sourceUrl is not provided.
*/
export async function finalizeJobStatus(jobId, truck, sourceUrl) {
    console.info(`Job ${jobId}: Successfully created food truck: ${truck.name} (ID: ${truck.id}) from ${sourceUrl ?? 'Unknown Source'}`);
    // Link truck_id back to the scraping job
    await ScrapingJobService.updateJobStatus(jobId, 'completed', {
        completed_at: new Date().toISOString(),
    });
}
// Helper function to validate input data
function validateTruckData(jobId, extractedTruckData) {
    if (extractedTruckData == undefined || typeof extractedTruckData !== 'object') {
        console.error(`Job ${jobId}: Invalid extractedTruckData, cannot create/update food truck.`);
        return false;
    }
    return true;
}
// Helper function to build location data
/**
 * Constructs location data from extracted truck details.
 * @example
 * buildLocationData({
 *   current_location: {
 *     address: &quot;123 Example St&quot;,
 *     city: &quot;Sample City&quot;,
 *     state: &quot;SC&quot;,
 *     zip_code: &quot;12345&quot;,
 *     lat: 34.05,
 *     lng: -118.25,
 *     raw_text: &quot;Raw Location Data&quot;
 *   }
 * })
 * // Returns: {
 * //   lat: 34.05,
 * //   lng: -118.25,
 * //   address: &quot;123 Example St, Sample City, SC, 12345&quot;,
 * //   timestamp: &quot;2023-09-15T14:38:00.000Z&quot;
 * // }
 * @param {ExtractedFoodTruckDetails} extractedTruckData - Details of the food truck, including its current location.
 * @returns {Object} Location data comprising latitude, longitude, formatted address, and current timestamp.
 * @description
 *   - Constructs a full address by combining address components.
 *   - Defaults latitude and longitude to 0 if not provided as numbers.
 *   - Uses raw text as address if address components are missing.
 *   - Generates an ISO 8601 timestamp for the current date and time.
 */
function buildLocationData(extractedTruckData) {
    const locationData = extractedTruckData.current_location ?? {};
    const fullAddress = [
        locationData.address,
        locationData.city,
        locationData.state,
        locationData.zip_code,
    ]
        .filter(Boolean)
        .join(', ');
    return {
        lat: typeof locationData.lat === 'number' ? locationData.lat : 0,
        lng: typeof locationData.lng === 'number' ? locationData.lng : 0,
        address: fullAddress || (locationData.raw_text ?? undefined),
        timestamp: new Date().toISOString(),
    };
}
// New helper function for contact info
function buildContactInfo(contactInfo) {
    return {
        phone: contactInfo?.phone ?? undefined,
        email: contactInfo?.email ?? undefined,
        website: contactInfo?.website ?? undefined,
    };
}
// New helper function for social media
function buildSocialMedia(socialMedia) {
    return {
        instagram: socialMedia?.instagram ?? undefined,
        facebook: socialMedia?.facebook ?? undefined,
        twitter: socialMedia?.twitter ?? undefined,
        tiktok: socialMedia?.tiktok ?? undefined,
        yelp: socialMedia?.yelp ?? undefined,
    };
}
// Type guard for RawMenuCategory
function isRawMenuCategory(obj) {
    return (typeof obj === 'object' &amp;&amp;
        obj != undefined &amp;&amp;
        ('category' in obj || 'name' in obj || 'items' in obj));
}
// Type guard for RawMenuItem
function isRawMenuItem(obj) {
    return (typeof obj === 'object' &amp;&amp;
        obj != undefined &amp;&amp;
        ('name' in obj || 'description' in obj || 'price' in obj || 'dietary_tags' in obj));
}
// Helper function to process menu data
/**
 * Processes extracted food truck data into structured menu categories.
 * @example
 * processMenuData(sample_truck_data)
 * [ { name: 'Uncategorized', items: [{ name: 'Pizza', description: 'Cheese Pizza', price: 9.99, dietary_tags: ['vegetarian'] }] } ]
 * @param {ExtractedFoodTruckDetails} extractedTruckData - The extracted food truck data.
 * @returns {MenuCategory[]} Array of structured menu categories.
 * @description
 *   - Validates categories and items before mapping to a structured format.
 *   - Converts item price to number and handles invalid input gracefully.
 *   - Provides default values for category and item names in the case of invalid data.
 *   - Logs warnings for encountered invalid category or item data.
 */
function processMenuData(extractedTruckData) {
    if (!Array.isArray(extractedTruckData.menu)) {
        return [];
    }
    return extractedTruckData.menu.map((category) =&gt; {
        if (!isRawMenuCategory(category)) {
            console.warn('Invalid category data encountered:', category);
            return { name: 'Invalid Category', items: [] };
        }
        const items = (Array.isArray(category.items) ? category.items : []).map((item) =&gt; {
            if (!isRawMenuItem(item)) {
                console.warn('Invalid item data encountered:', item);
                return {
                    name: 'Invalid Item',
                    description: undefined,
                    price: undefined,
                    dietary_tags: [],
                };
            }
            let price = undefined;
            if (typeof item.price === 'number') {
                price = item.price;
            }
            else if (typeof item.price === 'string') {
                const parsedPrice = Number.parseFloat(item.price.replaceAll(/[^\d.-]/g, ''));
                if (!Number.isNaN(parsedPrice)) {
                    price = parsedPrice;
                }
            }
            return {
                name: item.name ?? 'Unknown Item',
                description: item.description ?? undefined,
                price: price,
                dietary_tags: Array.isArray(item.dietary_tags) ? item.dietary_tags : [],
            };
        });
        return {
            name: category.category ?? category.name ?? 'Uncategorized',
            items: items,
        };
    });
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/performance/webVitals.js (Line 1:1 - Line 374:2), C:/AI/food-truck-finder-poc/dist/lib/lib/performance/webVitals.js (Line 1:1 - Line 374:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn472" onclick="toggleCodeBlock('cloneGroup472', 'expandBtn472', 'collapseBtn472')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn472" onclick="toggleCodeBlock('cloneGroup472', 'expandBtn472', 'collapseBtn472')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup472"><code class="language-javascript text-sm text-gray-800">/**
 * SOTA Core Web Vitals Monitoring Implementation
 * Tracks LCP, FID, CLS, FCP, and TTFB metrics for performance optimization
 */
import { getCLS, getFCP, getFID, getLCP, getTTFB } from 'web-vitals';
// Performance thresholds based on Google's Core Web Vitals standards
export const PERFORMANCE_THRESHOLDS = {
    LCP: { good: 2500, needsImprovement: 4000 }, // Largest Contentful Paint
    FID: { good: 100, needsImprovement: 300 }, // First Input Delay
    CLS: { good: 0.1, needsImprovement: 0.25 }, // Cumulative Layout Shift
    FCP: { good: 1800, needsImprovement: 3000 }, // First Contentful Paint
    TTFB: { good: 800, needsImprovement: 1800 }, // Time to First Byte
};
// In-memory storage for metrics (in production, send to analytics service)
const metricsStore = [];
/**
 * Categorizes metric value based on thresholds
 */
function getRating(name, value) {
    const thresholds = PERFORMANCE_THRESHOLDS[name];
    if (value &lt;= thresholds.good)
        return 'good';
    if (value &lt;= thresholds.needsImprovement)
        return 'needs-improvement';
    return 'poor';
}
/**
 * Processes and stores a web vital metric
 */
function handleMetric(metric) {
    // Type-safe casting with validation
    const metricName = String(metric.name);
    const metricValue = Number(metric.value);
    const performanceMetric = {
        name: metricName,
        value: metricValue,
        rating: getRating(metricName, metricValue),
        timestamp: Date.now(),
        url: globalThis.location.href,
        userAgent: navigator.userAgent,
    };
    // Store metric locally
    metricsStore.push(performanceMetric);
    // Send to analytics endpoint (non-blocking)
    sendMetricToAnalytics(performanceMetric).catch((error) =&gt; {
        console.warn('Failed to send metric to analytics:', error);
    });
    // Log performance issues
    if (performanceMetric.rating === 'poor') {
        console.warn(`Poor ${metricName} performance:`, {
            value: metricValue,
            threshold: PERFORMANCE_THRESHOLDS[metricName],
            url: performanceMetric.url,
        });
    }
}
/**
 * Sends metric data to analytics endpoint
 */
async function sendMetricToAnalytics(metric) {
    try {
        await fetch('/api/analytics/web-vitals', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(metric),
        });
    }
    catch (error) {
        // Silently fail - don't impact user experience
        console.info('Analytics endpoint unavailable:', error);
    }
}
/**
 * Initializes Core Web Vitals monitoring
 * Call this in your app's root component or _app.tsx
 */
export function initWebVitalsMonitoring() {
    try {
        // Type-safe metric handlers with explicit casting
        const safeHandleMetric = (metric) =&gt; handleMetric(metric);
        getCLS(safeHandleMetric);
        getFCP(safeHandleMetric);
        getFID(safeHandleMetric);
        getLCP(safeHandleMetric);
        getTTFB(safeHandleMetric);
    }
    catch (error) {
        console.warn('Failed to initialize web vitals monitoring:', error);
    }
}
/**
 * Gets current performance metrics summary
 */
export function getPerformanceMetrics() {
    const summary = {};
    // Initialize summary for all metrics
    for (const metricName of Object.keys(PERFORMANCE_THRESHOLDS)) {
        const name = metricName;
        const metricData = metricsStore.filter((m) =&gt; m.name === name);
        if (metricData.length === 0) {
            summary[name] = {
                latest: null,
                average: 0,
                rating: 'no-data',
                count: 0,
            };
        }
        else {
            const latest = metricData.at(-1);
            const average = metricData.reduce((sum, m) =&gt; sum + m.value, 0) / metricData.length;
            summary[name] = {
                latest: latest?.value ?? null,
                average: Math.round(average),
                rating: getRating(name, average),
                count: metricData.length,
            };
        }
    }
    return {
        metrics: [...metricsStore],
        summary,
    };
}
/**
 * Performance budget checker
 */
export function checkPerformanceBudget() {
    const { summary } = getPerformanceMetrics();
    const violations = [];
    for (const [metricName, data] of Object.entries(summary)) {
        const name = metricName;
        if (data.latest == undefined)
            continue;
        const thresholds = PERFORMANCE_THRESHOLDS[name];
        if (data.latest &gt; thresholds.needsImprovement) {
            violations.push({
                metric: name,
                value: data.latest,
                threshold: thresholds.needsImprovement,
                severity: 'critical',
            });
        }
        else if (data.latest &gt; thresholds.good) {
            violations.push({
                metric: name,
                value: data.latest,
                threshold: thresholds.good,
                severity: 'warning',
            });
        }
    }
    return {
        passed: violations.length === 0,
        violations,
    };
}
/**
 * Generates a list of suggestions to improve Largest Contentful Paint (LCP).
 * @example
 * getLCPSuggestions({ latest: 3000 })
 * Returns an array with LCP improvement suggestions when the latest LCP is 3000ms.
 * @param {Object} data - Contains performance metrics data.
 * @param {number|null} data.latest - The latest LCP measure in milliseconds.
 * @returns {PerformanceSuggestion[]} An array of performance suggestions for optimizing LCP.
 * @description
 *   - The function assumes the LCP target is less than 2500ms.
 *   - Suggestions focus on optimizing various aspects like image loading, server response, and resource preloading.
 */
function getLCPSuggestions(data) {
    return [
        {
            metric: 'LCP',
            issue: `Largest Contentful Paint is ${data.latest}ms (target: &lt;2500ms)`,
            suggestions: [
                'Optimize images with Next.js Image component',
                'Implement lazy loading for non-critical content',
                'Use CDN for static assets',
                'Optimize server response times',
                'Preload critical resources',
            ],
            priority: 'high',
        },
    ];
}
/**
 * Generates suggestions to improve First Input Delay (FID) performance.
 * @example
 * getFIDSuggestions({ latest: 150 })
 * [
 *   {
 *     metric: 'FID',
 *     issue: 'First Input Delay is 150ms (target: &lt;100ms)',
 *     suggestions: [
 *       'Reduce JavaScript bundle size',
 *       'Implement code splitting',
 *       'Use web workers for heavy computations',
 *       'Optimize third-party scripts',
 *       'Defer non-critical JavaScript',
 *     ],
 *     priority: 'high',
 *   },
 * ]
 * @param {Object} data - Contains the latest FID measurement.
 * @param {number|null} data.latest - The latest FID metric value.
 * @returns {PerformanceSuggestion[]} A list of suggestions to improve FID.
 * @description
 *   - Suggests actionable improvements if FID exceeds target threshold.
 *   - Provides solutions focusing on JS optimizations.
 */
function getFIDSuggestions(data) {
    return [
        {
            metric: 'FID',
            issue: `First Input Delay is ${data.latest}ms (target: &lt;100ms)`,
            suggestions: [
                'Reduce JavaScript bundle size',
                'Implement code splitting',
                'Use web workers for heavy computations',
                'Optimize third-party scripts',
                'Defer non-critical JavaScript',
            ],
            priority: 'high',
        },
    ];
}
/**
 * Generates performance suggestions based on Cumulative Layout Shift (CLS) data.
 * @example
 * getCLSSuggestions({ latest: 0.25 })
 * // Returns array of suggestions indicating the CLS value and recommendations on improving it.
 * @param {{ latest: number | null }} data - Object containing the latest CLS measurement.
 * @returns {PerformanceSuggestion[]} An array of performance suggestions to address CLS issues.
 * @description
 *   - Suggests best practices to reduce CLS, aiming for a value below 0.1.
 *   - Prioritizes medium concern for updates that could improve visual stability.
 *   - Incorporates practical strategies for developers focusing on layout changes.
 */
function getCLSSuggestions(data) {
    return [
        {
            metric: 'CLS',
            issue: `Cumulative Layout Shift is ${data.latest} (target: &lt;0.1)`,
            suggestions: [
                'Set explicit dimensions for images and videos',
                'Reserve space for dynamic content',
                'Use CSS aspect-ratio for responsive images',
                'Avoid inserting content above existing content',
                'Use transform animations instead of layout changes',
            ],
            priority: 'medium',
        },
    ];
}
/**
* Generates suggestions to improve the First Contentful Paint performance metric.
* @example
* getFCPSuggestions({ latest: 2000 })
* Returns an array with suggestions to optimize FCP targeting &lt;1800ms.
* @param {Object} data - Contains performance metric values.
* @param {number|null} data.latest - Latest measured FCP value in milliseconds.
* @returns {PerformanceSuggestion[]} Array of suggestions for improving FCP metric.
* @description
*   - Suggests optimizations related to the rendering path and resource loading.
*   - Provides actions with a medium priority level to improve website performance.
*/
function getFCPSuggestions(data) {
    return [
        {
            metric: 'FCP',
            issue: `First Contentful Paint is ${data.latest}ms (target: &lt;1800ms)`,
            suggestions: [
                'Optimize critical rendering path',
                'Inline critical CSS',
                'Minimize render-blocking resources',
                'Use resource hints (preload, prefetch)',
                'Optimize web fonts loading',
            ],
            priority: 'medium',
        },
    ];
}
/**
 * Generates suggestions to improve Time to First Byte (TTFB) performance based on the latest measurement.
 * @example
 * getTTFBSuggestions({ latest: 950 })
 * [
 *   {
 *     metric: 'TTFB',
 *     issue: 'Time to First Byte is 950ms (target: &lt;800ms)',
 *     suggestions: [
 *       'Optimize server response times',
 *       'Use CDN for global distribution',
 *       'Implement server-side caching',
 *       'Optimize database queries',
 *       'Use edge computing for dynamic content'
 *     ],
 *     priority: 'high'
 *   }
 * ]
 * @param {Object} data - An object containing the latest TTFB measurement.
 * @param {number|null} data.latest - The latest TTFB value in milliseconds or null if not available.
 * @returns {PerformanceSuggestion[]} An array containing performance improvement suggestions for TTFB.
 * @description
 *   - The function assumes a target TTFB of under 800ms.
 *   - Generates a high-priority performance suggestion report.
 */
function getTTFBSuggestions(data) {
    return [
        {
            metric: 'TTFB',
            issue: `Time to First Byte is ${data.latest}ms (target: &lt;800ms)`,
            suggestions: [
                'Optimize server response times',
                'Use CDN for global distribution',
                'Implement server-side caching',
                'Optimize database queries',
                'Use edge computing for dynamic content',
            ],
            priority: 'high',
        },
    ];
}
/**
 * Generates a list of performance optimization suggestions based on Web Vitals metrics.
 * @example
 * getPerformanceOptimizationSuggestions()
 * [
 *   { name: 'Optimize LCP', priority: 'high' },
 *   { name: 'Improve FID', priority: 'medium' }
 * ]
 * @returns {PerformanceSuggestion[]} An array of performance suggestions sorted by priority.
 * @description
 *   - Analyzes performance metrics including LCP, FID, CLS, FCP, and TTFB.
 *   - Generates suggestions only for metrics rated as 'poor' or 'needs-improvement'.
 *   - Prioritizes suggestions based on urgency, sorting them by priority level.
 *   - Utilizes helper functions to generate specific suggestions for each metric type.
 */
export function getPerformanceOptimizationSuggestions() {
    const { summary } = getPerformanceMetrics();
    let allSuggestions = [];
    for (const [metricName, data] of Object.entries(summary)) {
        const name = metricName;
        if (data.rating === 'poor' || data.rating === 'needs-improvement') {
            switch (name) {
                case 'LCP': {
                    allSuggestions = [...allSuggestions, ...getLCPSuggestions(data)];
                    break;
                }
                case 'FID': {
                    allSuggestions = [...allSuggestions, ...getFIDSuggestions(data)];
                    break;
                }
                case 'CLS': {
                    allSuggestions = [...allSuggestions, ...getCLSSuggestions(data)];
                    break;
                }
                case 'FCP': {
                    allSuggestions = [...allSuggestions, ...getFCPSuggestions(data)];
                    break;
                }
                case 'TTFB': {
                    allSuggestions = [...allSuggestions, ...getTTFBSuggestions(data)];
                    break;
                }
            }
        }
    }
    return allSuggestions.sort((a, b) =&gt; {
        const priorityOrder = { high: 3, medium: 2, low: 1 };
        return priorityOrder[b.priority] - priorityOrder[a.priority];
    });
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/performance/databaseCache.js (Line 6:17 - Line 223:2), C:/AI/food-truck-finder-poc/dist/lib/lib/performance/databaseCache.js (Line 6:27 - Line 223:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn474" onclick="toggleCodeBlock('cloneGroup474', 'expandBtn474', 'collapseBtn474')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn474" onclick="toggleCodeBlock('cloneGroup474', 'expandBtn474', 'collapseBtn474')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup474"><code class="language-javascript text-sm text-gray-800">;
// Cache configuration
const CACHE_CONFIG = {
    // Short-term cache for frequently changing data
    SHORT_TTL: 60 * 5, // 5 minutes
    // Medium-term cache for semi-static data
    MEDIUM_TTL: 60 * 30, // 30 minutes
    // Long-term cache for static data
    LONG_TTL: 60 * 60 * 24, // 24 hours
};
/**
 * Cached food truck queries with optimized database access
 */
export const CachedFoodTruckService = {
    /**
     * Get all food trucks with caching
     * Cache for 30 minutes since truck data changes moderately
     */
    getAllTrucksCached: unstable_cache(async () =&gt; {
        console.info('CachedFoodTruckService: Cache miss - fetching all trucks from database');
        const result = await FoodTruckService.getAllTrucks();
        if ('error' in result) {
            throw new Error(`Failed to fetch all trucks: ${result.error}`);
        }
        return { trucks: result.trucks, count: result.total };
    }, ['all-trucks'], {
        revalidate: CACHE_CONFIG.MEDIUM_TTL,
        tags: ['food-trucks', 'all-trucks'],
    }),
    /**
     * Get trucks by location with caching
     * Cache for 5 minutes since location-based queries are time-sensitive
     */
    getTrucksByLocationCached: unstable_cache(async (lat, lng, radiusKm) =&gt; {
        console.info(`CachedFoodTruckService: Cache miss - fetching trucks near ${lat},${lng} (${radiusKm}km)`);
        const result = await FoodTruckService.getTrucksByLocation(lat, lng, radiusKm);
        if ('error' in result) {
            throw new Error(`Failed to fetch trucks by location: ${result.error}`);
        }
        return result;
    }, ['trucks-by-location'], {
        revalidate: CACHE_CONFIG.SHORT_TTL,
        tags: ['food-trucks', 'location-search'],
    }),
    /**
     * Get truck by ID with caching
     * Cache for 30 minutes since individual truck data is relatively stable
     */
    getTruckByIdCached: unstable_cache(async (id) =&gt; {
        console.info(`CachedFoodTruckService: Cache miss - fetching truck ${id} from database`);
        const result = await FoodTruckService.getTruckById(id);
        if ('error' in result) {
            return null;
        }
        return result;
    }, ['truck-by-id'], {
        revalidate: CACHE_CONFIG.MEDIUM_TTL,
        tags: ['food-trucks', 'truck-details'],
    }),
    /**
     * Search trucks with caching
     * Cache for 5 minutes since search results should be relatively fresh
     */
    searchTrucksCached: unstable_cache(async (query, filters) =&gt; {
        console.info(`CachedFoodTruckService: Cache miss - searching trucks for &quot;${query}&quot;`);
        if (supabaseAdmin == undefined) {
            throw new Error('Supabase admin client not available');
        }
        let dbQuery = supabaseAdmin
            .from('food_trucks')
            .select('*')
            .or(`name.ilike.%${query}%,description.ilike.%${query}%,cuisine_type.cs.{${query}}`);
        // Apply filters
        if (filters?.cuisine != undefined &amp;&amp; filters.cuisine !== '') {
            dbQuery = dbQuery.contains('cuisine_type', [filters.cuisine]);
        }
        const { data, error } = await dbQuery.limit(50);
        const trucks = data ?? [];
        if (error != undefined) {
            const errorMessage = error instanceof Error ? error.message : JSON.stringify(error);
            throw new Error(`Search query failed: ${errorMessage}`);
        }
        let results = trucks ?? [];
        // Apply location filter if provided
        if (filters?.lat != undefined &amp;&amp; filters?.lng != undefined &amp;&amp; filters?.radius != undefined) {
            results = results.filter((truck) =&gt; {
                if (truck.current_location?.lat == undefined ||
                    truck.current_location?.lng == undefined) {
                    return false;
                }
                const distance = calculateDistance(filters.lat, // Assert as number, as it's checked by the outer if condition
                filters.lng, // Assert as number, as it's checked by the outer if condition
                truck.current_location.lat, truck.current_location.lng);
                return distance &lt;= (filters.radius ?? 10);
            });
        }
        // Apply openNow filter if provided
        if (filters?.openNow === true) {
            const now = new Date();
            const currentDay = now.toLocaleDateString('en-US', { weekday: 'short' }).toLowerCase(); // 'mon', 'tue', etc.
            const currentTime = now.getHours() * 100 + now.getMinutes(); // HHMM format
            results = results.filter((truck) =&gt; {
                const hours = truck.operating_hours?.[currentDay];
                if (hours == undefined || hours.closed === true)
                    return false;
                const openTime = parseTimeString(hours.open ?? '');
                const closeTime = parseTimeString(hours.close ?? '');
                return currentTime &gt;= openTime &amp;&amp; currentTime &lt;= closeTime;
            });
        }
        return results;
    }, ['search-trucks'], {
        revalidate: CACHE_CONFIG.SHORT_TTL,
        tags: ['food-trucks', 'search'],
    }),
    /**
     * Get data quality statistics with caching
     * Cache for 24 hours since quality stats change slowly
     */
    getDataQualityStatsCached: unstable_cache(async () =&gt; {
        console.info('CachedFoodTruckService: Cache miss - calculating data quality stats');
        if (supabaseAdmin == undefined) {
            throw new Error('Supabase admin client not available');
        }
        const { data: trucks, error } = await supabaseAdmin
            .from('food_trucks')
            .select('data_quality_score');
        if (error) {
            throw new Error(`Quality stats query failed: ${error.message}`);
        }
        const scores = trucks == undefined
            ? []
            : trucks.map((t) =&gt; t.data_quality_score ?? 0);
        const averageScore = scores.length &gt; 0
            ? scores.reduce((sum, score) =&gt; sum + score, 0) / scores.length
            : 0;
        const distribution = {
            high: scores.filter((s) =&gt; s &gt;= 0.8).length,
            medium: scores.filter((s) =&gt; s &gt;= 0.6 &amp;&amp; s &lt; 0.8).length,
            low: scores.filter((s) =&gt; s &lt; 0.6).length,
        };
        return {
            averageScore: Math.round(averageScore * 100) / 100,
            distribution,
            totalTrucks: scores.length,
        };
    }, ['data-quality-stats'], {
        revalidate: CACHE_CONFIG.LONG_TTL,
        tags: ['food-trucks', 'data-quality'],
    }),
};
/**
 * Cache invalidation utilities
 */
export const CacheManager = {
    /**
     * Invalidate all food truck related caches
     */
    async invalidateAllFoodTruckCaches() {
        try {
            const { revalidateTag } = await import('next/cache');
            revalidateTag('food-trucks');
            console.info('CacheManager: Invalidated all food truck caches');
        }
        catch (error) {
            console.warn('CacheManager: Failed to invalidate caches:', error);
        }
    },
    /**
     * Invalidate specific truck cache
     */
    async invalidateTruckCache(truckId) {
        try {
            const { revalidateTag } = await import('next/cache');
            revalidateTag(`truck-${truckId}`);
            revalidateTag('food-trucks'); // Also invalidate general caches
            console.info(`CacheManager: Invalidated cache for truck ${truckId}`);
        }
        catch (error) {
            console.warn('CacheManager: Failed to invalidate truck cache:', error);
        }
    },
    /**
     * Invalidate search and location caches
     */
    async invalidateSearchCaches() {
        try {
            const { revalidateTag } = await import('next/cache');
            revalidateTag('search');
            revalidateTag('location-search');
            console.info('CacheManager: Invalidated search caches');
        }
        catch (error) {
            console.warn('CacheManager: Failed to invalidate search caches:', error);
        }
    },
};
/**
 * Utility functions
 */
function calculateDistance(lat1, lng1, lat2, lng2) {
    const R = 6371; // Earth's radius in kilometers
    const dLat = ((lat2 - lat1) * Math.PI) / 180;
    const dLng = ((lng2 - lng1) * Math.PI) / 180;
    const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
        Math.cos((lat1 * Math.PI) / 180) *
            Math.cos((lat2 * Math.PI) / 180) *
            Math.sin(dLng / 2) *
            Math.sin(dLng / 2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    return R * c;
}
function parseTimeString(timeStr) {
    if (timeStr == undefined || timeStr === '')
        return 0;
    const [hours, minutes] = timeStr.split(':').map(Number);
    return hours * 100 + (minutes ?? 0);
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/monitoring/apiMonitor.js (Line 5:17 - Line 312:2), C:/AI/food-truck-finder-poc/dist/lib/lib/monitoring/apiMonitor.js (Line 5:27 - Line 312:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn475" onclick="toggleCodeBlock('cloneGroup475', 'expandBtn475', 'collapseBtn475')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn475" onclick="toggleCodeBlock('cloneGroup475', 'expandBtn475', 'collapseBtn475')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup475"><code class="language-javascript text-sm text-gray-800">;
// API Rate Limits Configuration
export const API_LIMITS = {
    gemini: {
        requests: { daily: 1500, hourly: 100 },
        tokens: { daily: 32_000, hourly: 2000 },
        alertThresholds: { warning: 0.8, critical: 0.95 },
    },
    firecrawl: {
        requests: { daily: 500, hourly: 50 },
        tokens: { daily: 0, hourly: 0 },
        alertThresholds: { warning: 0.8, critical: 0.95 },
    },
    tavily: {
        requests: { daily: 1000, hourly: 100 },
        tokens: { daily: 0, hourly: 0 },
        alertThresholds: { warning: 0.8, critical: 0.95 },
    },
    supabase: {
        requests: { daily: 50_000, hourly: 5000 },
        tokens: { daily: 0, hourly: 0 },
        alertThresholds: { warning: 0.9, critical: 0.98 },
    },
};
/**
 * Comprehensive API Monitoring Service
 */
export class APIMonitor {
    static alertHistory = [];
    /**
     * Check if API request can be made safely
     */
    static async canMakeRequest(service, requestCount = 1, tokenCount = 0) {
        try {
            const usage = await this.getCurrentUsage(service);
            const limits = API_LIMITS[service];
            // Check daily limits
            const newRequestCount = usage.requests.used + requestCount;
            const newTokenCount = (usage.tokens?.used ?? 0) + tokenCount;
            if (newRequestCount &gt; limits.requests.daily) {
                return {
                    allowed: false,
                    reason: `Daily request limit exceeded (${newRequestCount}/${limits.requests.daily})`,
                    waitTime: this.getTimeUntilReset('daily'),
                };
            }
            if (limits.tokens != undefined &amp;&amp; newTokenCount &gt; limits.tokens.daily) {
                return {
                    allowed: false,
                    reason: `Daily token limit exceeded (${newTokenCount}/${limits.tokens.daily})`,
                    waitTime: this.getTimeUntilReset('daily'),
                };
            }
            // Check if approaching critical threshold
            const requestPercentage = newRequestCount / limits.requests.daily;
            if (requestPercentage &gt; limits.alertThresholds.critical) {
                return {
                    allowed: false,
                    reason: `Approaching critical usage threshold (${(requestPercentage * 100).toFixed(1)}%)`,
                    waitTime: this.getTimeUntilReset('daily'),
                };
            }
            return { allowed: true };
        }
        catch (error) {
            console.error(`Error checking API limits for ${service}:`, error);
            // Fail safe - allow request but log error
            return { allowed: true };
        }
    }
    /**
     * Get current usage for a service
     */
    static async getCurrentUsage(service) {
        const todayUsage = await APIUsageService.getTodayUsage(service);
        const limits = API_LIMITS[service];
        const usage = {
            requests: {
                used: todayUsage?.requests_count ?? 0,
                limit: limits.requests.daily,
                percentage: ((todayUsage?.requests_count ?? 0) / limits.requests.daily) * 100,
            },
        };
        if (limits.tokens.daily &gt; 0) {
            usage.tokens = {
                used: todayUsage?.tokens_used ?? 0,
                limit: limits.tokens.daily,
                percentage: ((todayUsage?.tokens_used ?? 0) / limits.tokens.daily) * 100,
            };
        }
        return usage;
    }
    /**
     * Comprehensive monitoring check for all APIs
     */
    static async checkAllAPIs() {
        const alerts = [];
        const usage = {};
        const recommendations = [];
        let canMakeRequest = true;
        for (const service of Object.keys(API_LIMITS)) {
            try {
                const serviceUsage = await this.getCurrentUsage(service);
                usage[service] = serviceUsage;
                // Check for alerts
                const serviceAlerts = this.generateAlerts(service, serviceUsage);
                alerts.push(...serviceAlerts);
                // Check if any service is at critical level
                if (serviceUsage.requests.percentage &gt; API_LIMITS[service].alertThresholds.critical * 100) {
                    canMakeRequest = false;
                }
            }
            catch (error) {
                console.error(`Error monitoring ${service}:`, error);
                alerts.push({
                    service,
                    level: 'warning',
                    message: `Failed to check usage for ${service}`,
                    usage: { current: 0, limit: 0, percentage: 0 },
                    timestamp: new Date().toISOString(),
                    recommendations: ['Check API connectivity', 'Verify credentials'],
                });
            }
        }
        // Generate global recommendations
        recommendations.push(...this.generateRecommendations(usage, alerts));
        return {
            canMakeRequest,
            alerts,
            usage,
            recommendations,
        };
    }
    // Helper for token alerts
    /**
     * Generates token usage alerts based on API usage data and predefined limits.
     * @example
     * generateTokenAlerts(APIServiceInstance, usageData, apiLimits, '2023-10-21T10:20:30Z')
     * [{ service: 'exampleService', level: 'warning', message: 'Warning: exampleService token usage at 75.0%', ... }]
     * @param {APIService} service - The API service for which the alerts are being generated.
     * @param {APIUsageData} usage - Object containing the token usage statistics.
     * @param {Object} limits - Configuration object specifying API limits and alert thresholds.
     * @param {string} timestamp - The timestamp at which the alert is generated.
     * @returns {APIUsageAlert[]} List of alerts generated based on token usage percentage compared to limits.
     * @description
     *   - Generates 'warning' alerts if token usage exceeds the warning threshold.
     *   - Generates 'critical' alerts if token usage exceeds the critical threshold.
     *   - Provides recommendations for optimizing token usage when an alert is generated.
     */
    static generateTokenAlerts(service, usage, limits, timestamp) {
        const alerts = [];
        if (usage.tokens &amp;&amp; limits.tokens.daily &gt; 0) {
            const tokenPercentage = usage.tokens.percentage;
            if (tokenPercentage &gt; limits.alertThresholds.critical * 100) {
                alerts.push({
                    service,
                    level: 'critical',
                    message: `Critical: ${service} token usage at ${tokenPercentage.toFixed(1)}%`,
                    usage: {
                        current: usage.tokens.used,
                        limit: usage.tokens.limit,
                        percentage: tokenPercentage,
                    },
                    timestamp,
                    recommendations: [
                        'Reduce prompt complexity',
                        'Implement response caching',
                        'Optimize token usage patterns',
                    ],
                });
            }
            else if (tokenPercentage &gt; limits.alertThresholds.warning * 100) {
                alerts.push({
                    service,
                    level: 'warning',
                    message: `Warning: ${service} token usage at ${tokenPercentage.toFixed(1)}%`,
                    usage: {
                        current: usage.tokens.used,
                        limit: usage.tokens.limit,
                        percentage: tokenPercentage,
                    },
                    timestamp,
                    recommendations: [
                        'Monitor token consumption',
                        'Optimize prompt efficiency',
                        'Consider response caching',
                    ],
                });
            }
        }
        return alerts;
    }
    /**
     * Generates usage alerts based on the service's API usage data.
     * @example
     * generateAlerts(APIService.YOUR_SERVICE, apiUsageData)
     * returns an array of APIUsageAlert objects when usage thresholds are exceeded.
     * @param {APIService} service - The API service being monitored.
     * @param {APIUsageData} usage - The usage data containing request and token information.
     * @returns {APIUsageAlert[]} An array of alert objects representing warning or critical usage states.
     * @description
     *   - Determines alert level based on predefined thresholds in API_LIMITS.
     *   - Generates alerts for both request and token usage.
     *   - Updates alert history, maintaining only the last 100 alerts.
     */
    static generateAlerts(service, usage) {
        const alerts = [];
        const limits = API_LIMITS[service];
        const timestamp = new Date().toISOString();
        // Check request usage
        const requestPercentage = usage.requests.percentage;
        if (requestPercentage &gt; limits.alertThresholds.critical * 100) {
            alerts.push({
                service,
                level: 'critical',
                message: `Critical: ${service} request usage at ${requestPercentage.toFixed(1)}%`,
                usage: {
                    current: usage.requests.used,
                    limit: usage.requests.limit,
                    percentage: requestPercentage,
                },
                timestamp,
                recommendations: [
                    'Immediately reduce API calls',
                    'Implement request queuing',
                    'Consider upgrading API plan',
                ],
            });
        }
        else if (requestPercentage &gt; limits.alertThresholds.warning * 100) {
            alerts.push({
                service,
                level: 'warning',
                message: `Warning: ${service} request usage at ${requestPercentage.toFixed(1)}%`,
                usage: {
                    current: usage.requests.used,
                    limit: usage.requests.limit,
                    percentage: requestPercentage,
                },
                timestamp,
                recommendations: [
                    'Monitor usage closely',
                    'Optimize request patterns',
                    'Enable request caching',
                ],
            });
        }
        // Token alerts
        alerts.push(...this.generateTokenAlerts(service, usage, limits, timestamp));
        // Store alerts in history
        this.alertHistory.push(...alerts);
        // Keep only last 100 alerts
        if (this.alertHistory.length &gt; 100) {
            this.alertHistory = this.alertHistory.slice(-100);
        }
        return alerts;
    }
    /**
     * Generate optimization recommendations
     */
    static generateRecommendations(usage, alerts) {
        const recommendations = [];
        // High-level optimization recommendations
        const criticalAlerts = alerts.filter((a) =&gt; a.level === 'critical');
        const warningAlerts = alerts.filter((a) =&gt; a.level === 'warning');
        if (criticalAlerts.length &gt; 0) {
            recommendations.push('URGENT: Implement immediate API throttling', 'Enable aggressive caching for all API responses', 'Consider upgrading API plans for critical services');
        }
        if (warningAlerts.length &gt; 0) {
            recommendations.push('Implement request queuing and batching', 'Optimize API call patterns and frequency', 'Enable response caching where possible');
        }
        // Service-specific recommendations
        if (usage.gemini?.requests?.percentage &gt; 70) {
            recommendations.push('Gemini: Optimize prompt length and complexity', 'Gemini: Implement response caching for similar queries');
        }
        if (usage.firecrawl?.requests?.percentage &gt; 70) {
            recommendations.push('Firecrawl: Implement URL deduplication', 'Firecrawl: Cache crawl results for repeated URLs');
        }
        return [...new Set(recommendations)]; // Remove duplicates
    }
    /**
     * Get time until rate limit reset
     */
    static getTimeUntilReset(period) {
        const now = new Date();
        if (period === 'hourly') {
            const nextHour = new Date(now);
            nextHour.setHours(now.getHours() + 1, 0, 0, 0);
            return nextHour.getTime() - now.getTime();
        }
        const nextDay = new Date(now);
        nextDay.setDate(now.getDate() + 1);
        nextDay.setHours(0, 0, 0, 0);
        return nextDay.getTime() - now.getTime();
    }
    /**
     * Get alert history
     */
    static getAlertHistory() {
        return [...this.alertHistory];
    }
    /**
     * Clear alert history
     */
    static clearAlertHistory() {
        this.alertHistory = [];
    }
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/middleware/middlewareHelpers.js (Line 3:27 - Line 176:2), C:/AI/food-truck-finder-poc/dist/lib/lib/middleware/middlewareHelpers.js (Line 3:27 - Line 176:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn477" onclick="toggleCodeBlock('cloneGroup477', 'expandBtn477', 'collapseBtn477')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn477" onclick="toggleCodeBlock('cloneGroup477', 'expandBtn477', 'collapseBtn477')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup477"><code class="language-javascript text-sm text-gray-800">;
/**
 * Logs a security event and redirects the request to a specified path.
 * @example
 * logSecurityEventAndRedirect({ req, res, logParams, redirectPath, redirectFromPath })
 * NextResponse with redirect to the target path
 * @param {Object} params - The parameters for the function.
 * @param {Request} params.req - The original request object containing the URL to clone for redirection.
 * @param {Response} params._res - The original response object (unused in function, but part of expected parameters).
 * @param {Object} params.logParams - Parameters required by the AuditLogger to log the security event.
 * @param {string} params.redirectPath - The pathname where the request should be redirected.
 * @param {string} [params.redirectFromPath] - Optional pathname indicating where the redirect originated from.
 * @returns {NextResponse} A response that performs a redirect to the specified path.
 * @description
 *   - The function uses AuditLogger to record the security event.
 *   - It clones the current URL from the request to ensure original query parameters are preserved.
 *   - Redirect path can optionally include info on where the redirect originated via a search parameter.
 */
async function logSecurityEventAndRedirect({ req, res: _res, logParams, redirectPath, redirectFromPath, }) {
    await AuditLogger.logSecurityEvent(logParams);
    const redirectUrl = req.nextUrl.clone();
    redirectUrl.pathname = redirectPath;
    if (redirectFromPath) {
        redirectUrl.searchParams.set(`redirectedFrom`, redirectFromPath);
    }
    return NextResponse.redirect(redirectUrl);
}
/**
 * Logs a security event and redirects the user to the login page.
 * @example
 * logAndRedirect({
 *   req: requestObject,
 *   res: responseObject,
 *   requestMetadata: { ip: '192.168.1.1', userAgent: 'Mozilla/5.0', url: '/dashboard' },
 *   reason: 'Session Expired',
 *   userError: new Error('User authentication failed')
 * })
 * // Redirects user to login page and logs the event
 * @param {Object} req - Express request object containing details of the incoming request.
 * @param {Object} res - Express response object used to send a response to the client.
 * @param {Object} requestMetadata - Metadata associated with the request, including IP and user agent.
 * @param {string} reason - The reason for redirect, generally describing why access was denied.
 * @param {Error} userError - Optional error object that provides additional context about the user error.
 * @returns {Promise&lt;void&gt;} Returns a promise that resolves once the security event is logged and redirect is completed.
 * @description
 *   - Utilizes a severity of 'warning' when logging security events.
 *   - Redirects users from the attempted URL to the login page.
 *   - Captures detailed information about the request including attempted URL and user agent.
 */
async function logAndRedirect({ req, res, requestMetadata, reason, userError, }) {
    return logSecurityEventAndRedirect({
        req,
        res,
        logParams: {
            event_type: 'permission_denied',
            ip_address: requestMetadata.ip,
            user_agent: requestMetadata.userAgent,
            details: {
                attempted_url: requestMetadata.url,
                reason,
                error: userError?.message,
            },
            severity: 'warning',
        },
        redirectPath: '/login',
        redirectFromPath: req.nextUrl.pathname,
    });
}
/**
 * Logs a security event and redirects to an access-denied page.
 * @example
 * logAndRedirectDenied({
 *   req: requestObject,
 *   res: responseObject,
 *   requestMetadata: metadataObject,
 *   user: userObject,
 *   profile: profileObject,
 *   profileQueryError: errorObject
 * })
 * // Redirects user and logs the event with relevant details
 * @param {Object} params - Contains necessary parameters for the function.
 * @param {Object} params.req - The HTTP request object.
 * @param {Object} params.res - The HTTP response object.
 * @param {Object} params.requestMetadata - Metadata related to the request.
 * @param {Object} params.user - User information object.
 * @param {Object} params.profile - Profile object related to the user.
 * @param {Object} params.profileQueryError - Error object if querying profile fails.
 * @returns {Promise&lt;void&gt;} Returns a promise that resolves after logging and redirecting.
 * @description
 *   - Utilizes `logSecurityEventAndRedirect` to perform logging and redirect operations.
 *   - The function assumes a structure for the user object, expecting 'id' and 'email' properties.
 *   - Redirects to '/access-denied' path by default.
 *   - Sets event severity as 'error' when logging the security event.
 */
async function logAndRedirectDenied({ req, res, requestMetadata, user, profile, profileQueryError, }) {
    return logSecurityEventAndRedirect({
        req,
        res,
        logParams: {
            event_type: 'permission_denied',
            user_id: user.id,
            user_email: user.email ?? undefined,
            ip_address: requestMetadata.ip,
            user_agent: requestMetadata.userAgent,
            details: {
                attempted_url: requestMetadata.url,
                user_role: profile?.role ?? 'none',
                reason: 'insufficient_privileges',
                error: profileQueryError?.message,
            },
            severity: 'error',
        },
        redirectPath: '/access-denied',
    });
}
/**
 * Protects admin routes by verifying user authentication and authorization.
 * @example
 * protectAdminRoutes(req, res, requestMetadata)
 * returns NextResponse or redirects depending on user authentication status.
 * @param {NextRequest} req - The incoming request object.
 * @param {NextResponse} res - The response object to send back to the client.
 * @param {RequestMetadata} requestMetadata - Metadata about the request for logging purposes.
 * @returns {NextResponse} Returns the response object or redirects to an error page.
 * @description
 *   - Fetches and verifies the user's session from Supabase.
 *   - Checks if the user is an admin based on the profile 'role' from the database.
 *   - Logs access attempts to the admin panel for auditing purposes.
 *   - Redirects to an appropriate error handler if the user isn't authenticated or authorized.
 */
export async function protectAdminRoutes(req, res, requestMetadata) {
    const supabase = createSupabaseMiddlewareClient(req, res);
    const { data, error: userError } = await supabase.auth.getUser();
    const user = data?.user;
    if (userError || !user) {
        return logAndRedirect({
            req,
            res,
            requestMetadata,
            reason: 'no_session',
            userError: userError ?? undefined,
        });
    }
    // Explicitly type the result of the Supabase query
    const { data: profile, error: profileQueryError } = (await supabase
        .from('profiles')
        .select('role')
        .eq('id', user.id)
        .single());
    if (profileQueryError || (profile &amp;&amp; profile.role !== 'admin')) {
        return logAndRedirectDenied({
            req,
            res,
            requestMetadata,
            user,
            profile: profile ?? null,
            profileQueryError: profileQueryError ?? undefined,
        });
    }
    if (req.method !== 'GET' || req.nextUrl.pathname.includes('/api/')) {
        await AuditLogger.logDataAccess({
            userId: user.id,
            userEmail: user.email ?? 'unknown',
            resourceType: 'admin_panel',
            resourceId: req.nextUrl.pathname,
            action: req.method === 'GET' ? 'read' : 'admin_access',
            request: {
                ip: requestMetadata.ip,
                userAgent: requestMetadata.userAgent,
            },
        });
    }
    return res;
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/mappers/uprootedVeganMapper.js (Line 1:1 - Line 180:2), C:/AI/food-truck-finder-poc/dist/lib/lib/mappers/uprootedVeganMapper.js (Line 1:1 - Line 180:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn479" onclick="toggleCodeBlock('cloneGroup479', 'expandBtn479', 'collapseBtn479')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn479" onclick="toggleCodeBlock('cloneGroup479', 'expandBtn479', 'collapseBtn479')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup479"><code class="language-javascript text-sm text-gray-800">/**
 * Data mapper for Uprooted Vegan Cuisine onboarding
 *
 * This utility handles the transformation of Uprooted Vegan Cuisine data
 * to match our FoodTruck schema, including field mappings and defaults.
 */
/**
 * Normalizes cuisine_type to always be an array
 */
function normalizeCuisineType(cuisine_type) {
    if (typeof cuisine_type === 'string') {
        // Split on common separators and clean up
        return cuisine_type
            .split(/[,;&amp;]/)
            .map(c =&gt; c.trim())
            .filter(c =&gt; c.length &gt; 0);
    }
    return Array.isArray(cuisine_type) ? cuisine_type : [];
}
/**
 * Normalizes specialties to always be an array
 */
function normalizeSpecialties(specialties) {
    if (!specialties)
        return [];
    if (typeof specialties === 'string') {
        return specialties
            .split(/[,;&amp;]/)
            .map(s =&gt; s.trim())
            .filter(s =&gt; s.length &gt; 0);
    }
    return Array.isArray(specialties) ? specialties : [];
}
/**
 * Normalizes source URLs to always be an array
 */
function normalizeSourceUrls(source_urls) {
    if (!source_urls)
        return [];
    if (typeof source_urls === 'string') {
        return [source_urls];
    }
    return Array.isArray(source_urls) ? source_urls : [];
}
/**
 * Creates default operating hours
 */
function createDefaultOperatingHours() {
    return {
        monday: undefined,
        tuesday: undefined,
        wednesday: undefined,
        thursday: undefined,
        friday: undefined,
        saturday: undefined,
        sunday: undefined
    };
}
/**
 * Maps Uprooted Vegan Cuisine data to our FoodTruck schema
 */
export function mapUprootedVeganData(data) {
    const now = new Date().toISOString();
    // Handle location priority: exact_location &gt; current_location &gt; city_location
    const primaryLocation = data.exact_location || data.current_location || data.city_location;
    const mapped = {
        // Core fields
        name: data.name,
        description: data.description,
        cuisine_type: normalizeCuisineType(data.cuisine_type),
        price_range: data.price_range,
        specialties: normalizeSpecialties(data.specialties),
        // New fields for Uprooted Vegan support
        user_id: data.user_id,
        state: data.state,
        // Location fields
        current_location: primaryLocation ? {
            lat: primaryLocation.lat,
            lng: primaryLocation.lng,
            address: primaryLocation.address,
            timestamp: primaryLocation.timestamp || now,
        } : {
            lat: 0,
            lng: 0,
            address: undefined,
            timestamp: now,
        },
        scheduled_locations: data.scheduled_locations,
        // Menu and hours
        operating_hours: data.operating_hours || createDefaultOperatingHours(),
        menu: data.menu || [],
        // Contact information
        contact_info: data.contact_info || {},
        social_media: data.social_media || {},
        // Quality and verification
        data_quality_score: data.data_quality_score ?? 0.5, // Default to medium quality
        verification_status: data.verification_status || 'pending',
        source_urls: normalizeSourceUrls(data.source_urls),
        // Handle timestamps
        last_scraped_at: data.last_scraped_at || now,
        created_at: data.created_at || now,
        updated_at: data.updated_at || now,
        // Additional helpful defaults
        is_active: true, // Assume new entries are active
        test_run_flag: false // Not a test import
    };
    return mapped;
}
/**
 * Validates that required fields are present
 */
export function validateUprootedVeganData(data) {
    const errors = [];
    // Check required fields
    if (!data.name || data.name.trim().length === 0) {
        errors.push('name is required');
    }
    if (!data.cuisine_type ||
        (Array.isArray(data.cuisine_type) &amp;&amp; data.cuisine_type.length === 0) ||
        (typeof data.cuisine_type === 'string' &amp;&amp; data.cuisine_type.trim().length === 0)) {
        errors.push('cuisine_type is required');
    }
    // Validate state format if provided
    if (data.state &amp;&amp; (typeof data.state !== 'string' || data.state.length !== 2)) {
        errors.push('state must be a 2-character string (e.g., CA, NY, TX)');
    }
    // Validate user_id format if provided
    if (data.user_id &amp;&amp; typeof data.user_id !== 'string') {
        errors.push('user_id must be a valid UUID string');
    }
    // Validate price range if provided
    if (data.price_range &amp;&amp; !['$', '$$', '$$$', '$$$$'].includes(data.price_range)) {
        errors.push('price_range must be one of: $, $$, $$$, $$$$');
    }
    return {
        isValid: errors.length === 0,
        errors
    };
}
/**
 * Example usage and testing function
 */
export function createUprootedVeganExample() {
    return {
        name: &quot;Uprooted Vegan Cuisine&quot;,
        description: &quot;Plant-based comfort food truck serving delicious vegan alternatives&quot;,
        cuisine_type: [&quot;Vegan&quot;, &quot;American&quot;, &quot;Comfort Food&quot;],
        price_range: &quot;$$&quot;,
        specialties: [&quot;Vegan Burgers&quot;, &quot;Plant-Based Mac &amp; Cheese&quot;, &quot;Cashew-Based Desserts&quot;],
        user_id: &quot;123e4567-e89b-12d3-a456-426614174000&quot;, // Example UUID
        state: &quot;CA&quot;,
        current_location: {
            lat: 37.7749,
            lng: -122.4194,
            address: &quot;San Francisco, CA&quot;,
            timestamp: new Date().toISOString()
        },
        operating_hours: {
            monday: { open: &quot;11:00 AM&quot;, close: &quot;8:00 PM&quot; },
            tuesday: { open: &quot;11:00 AM&quot;, close: &quot;8:00 PM&quot; },
            wednesday: { open: &quot;11:00 AM&quot;, close: &quot;8:00 PM&quot; },
            thursday: { open: &quot;11:00 AM&quot;, close: &quot;8:00 PM&quot; },
            friday: { open: &quot;11:00 AM&quot;, close: &quot;9:00 PM&quot; },
            saturday: { open: &quot;10:00 AM&quot;, close: &quot;9:00 PM&quot; },
            sunday: { closed: true }
        },
        contact_info: {
            phone: &quot;(415) 555-0123&quot;,
            email: &quot;hello@uprootedvegan.com&quot;,
            website: &quot;https://uprootedvegan.com&quot;
        },
        social_media: {
            instagram: &quot;@uprootedvegan&quot;,
            facebook: &quot;UprootedVeganCuisine&quot;
        },
        verification_status: &quot;pending&quot;,
        data_quality_score: 0.8,
        source_urls: [&quot;https://uprootedvegan.com&quot;]
    };
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/lib/supabaseMiddleware.js (Line 1:1 - Line 25:2), C:/AI/food-truck-finder-poc/dist/lib/lib/supabaseMiddleware.js (Line 1:1 - Line 25:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn482" onclick="toggleCodeBlock('cloneGroup482', 'expandBtn482', 'collapseBtn482')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn482" onclick="toggleCodeBlock('cloneGroup482', 'expandBtn482', 'collapseBtn482')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup482"><code class="language-javascript text-sm text-gray-800">import { createClient } from '@supabase/supabase-js';
/**
* Create a Supabase client configured for middleware
* @example
* createSupabaseMiddlewareClient(request, response)
* Supabase client instance
* @param {NextRequest} _req - The incoming Next.js request object (unused).
* @param {NextResponse} _res - The outgoing Next.js response object (unused).
* @returns {SupabaseClient} Supabase client instance configured for middleware usage.
* @description
*   - Utilizes environment variables for Supabase URL and anon key.
*   - Sets `persistSession` to false for non-persistent authentication.
*   - Adds `x-middleware-auth` header for identification in middleware.
*/
export function createSupabaseMiddlewareClient(_req, _res) {
    // Create a Supabase client configured for middleware
    return createClient(process.env.NEXT_PUBLIC_SUPABASE_URL, process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY, {
        auth: {
            persistSession: false,
        },
        global: {
            headers: { 'x-middleware-auth': 'true' },
        },
    });
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/lib/ScraperEngine.js (Line 1:17 - Line 662:2), C:/AI/food-truck-finder-poc/dist/lib/lib/ScraperEngine.js (Line 1:14 - Line 662:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn483" onclick="toggleCodeBlock('cloneGroup483', 'expandBtn483', 'collapseBtn483')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn483" onclick="toggleCodeBlock('cloneGroup483', 'expandBtn483', 'collapseBtn483')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup483"><code class="language-javascript text-sm text-gray-800">; // Import the firecrawl singleton
import * as crypto from 'node:crypto'; // Node.js crypto for secure randomness
// Core scraping engine with anti-detection measures
export class ScraperEngine {
    userAgents;
    requestDelay;
    maxRetries;
    constructor() {
        this.userAgents = [
            'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
            'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
            'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
        ];
        this.requestDelay = 2000;
        this.maxRetries = 3;
    }
    async performFallbackScrape(url) {
        try {
            const response = await fetch(url, { headers: { 'User-Agent': this.getRandomUserAgent() } });
            if (!response.ok) {
                throw new Error(`HTTP error ${response.status}: ${response.statusText} during fallback fetch.`);
            }
            const htmlContent = await response.text();
            return {
                success: true,
                data: {
                    html: htmlContent,
                    is_fallback: true,
                },
                timestamp: new Date().toISOString(),
                source: url,
                note: 'Fetched using basic fetch as Firecrawl failed.',
            };
        }
        catch (fallbackError) {
            const errMsg = fallbackError instanceof Error ? fallbackError.message : 'Unknown fallback fetch error';
            console.warn(`Fallback fetch error for ${url}:`, errMsg);
            return {
                success: false,
                error: &quot;That didn't work, please try again later.&quot;,
                timestamp: new Date().toISOString(),
                source: url,
            };
        }
    }
    async scrapeWebsite(url, _selectors) {
        try {
            const firecrawlResult = await firecrawl.scrapeUrl(url, {
                formats: ['markdown', 'html'],
                onlyMainContent: true,
            });
            if (firecrawlResult.success !== true || firecrawlResult.data == undefined) {
                throw new Error(firecrawlResult.error ?? 'Firecrawl scraping failed to return data.');
            }
            const returnedData = {};
            if (firecrawlResult.data &amp;&amp; typeof firecrawlResult.data === 'object') {
                const firecrawlData = firecrawlResult.data;
                if (typeof firecrawlData.markdown === 'string' &amp;&amp; firecrawlData.markdown !== '') {
                    returnedData.markdown = firecrawlData.markdown;
                }
                if (typeof firecrawlData.html === 'string' &amp;&amp; firecrawlData.html !== '') {
                    returnedData.html = firecrawlData.html;
                }
                if (firecrawlData.metadata != undefined &amp;&amp; typeof firecrawlData.metadata === 'object') {
                    returnedData.metadata = firecrawlData.metadata;
                }
            }
            if ((returnedData.markdown == undefined || returnedData.markdown === '') &amp;&amp;
                (returnedData.html == undefined || returnedData.html === '')) {
                throw new Error('Firecrawl returned no markdown or HTML content.');
            }
            return {
                success: true,
                data: returnedData,
                timestamp: new Date().toISOString(),
                source: url,
            };
        }
        catch (error) {
            console.warn(`Scraping error for ${url} using Firecrawl:`, error);
            console.info(`Falling back to basic fetch for ${url}`);
            return await this.performFallbackScrape(url);
        }
    }
    async scrapeSocialMedia(platform, handle) {
        try {
            await this.randomDelay();
            switch (platform) {
                case 'instagram': {
                    return await this.scrapeInstagram(handle);
                }
                case 'facebook': {
                    return await this.scrapeFacebook(handle);
                }
                case 'twitter': {
                    return await this.scrapeTwitter(handle);
                }
                default: {
                    throw new Error(`Unsupported platform: ${platform}`);
                }
            }
        }
        catch (error) {
            console.warn(`Social media scraping error for ${platform}/${handle}:`, error);
            return {
                success: false,
                error: &quot;That didn't work, please try again later.&quot;,
                timestamp: new Date().toISOString(),
                source: `social_media:${platform}:${handle}`,
            };
        }
    }
    async scrapeInstagram(handle) {
        await this.randomDelay();
        const posts = [
            {
                id: 'post_001',
                caption: 'Fresh tacos available now at Mission St!  #foodtruck #tacos',
                timestamp: new Date(Date.now() - 3_600_000).toISOString(),
                location: 'Mission St, San Francisco',
                hashtags: ['foodtruck', 'tacos', 'fresh'],
                engagement: { likes: 45, comments: 8 },
            },
        ];
        const profile = {
            followers: 1250,
            following: 340,
            posts_count: 156,
            bio: 'Best tacos in SF  Follow for daily locations!',
            contact_info: {
                email: 'contact@tacoparadise.com',
                phone: '+1-555-0456',
            },
        };
        const data = { posts, profile };
        return {
            success: true,
            data,
            timestamp: new Date().toISOString(),
            source: `instagram:${handle}`,
        };
    }
    async scrapeFacebook(handle) {
        await this.randomDelay();
        const posts = [
            {
                id: 'fb_post_001',
                content: &quot;Today we'll be at Union Square from 11 AM to 3 PM! Come try our new BBQ burger!&quot;,
                timestamp: new Date(Date.now() - 7_200_000).toISOString(),
                reactions: { likes: 23, loves: 5, shares: 3 },
                comments: 12,
            },
        ];
        const page_info = {
            likes: 890,
            followers: 1100,
            check_ins: 450,
            about: 'Gourmet food truck serving the Bay Area',
            hours: {
                monday: '11:00-15:00',
                tuesday: '11:00-15:00',
                wednesday: '11:00-15:00',
                thursday: '11:00-15:00',
                friday: '11:00-20:00',
                saturday: '12:00-20:00',
                sunday: '12:00-16:00',
            },
        };
        const data = { posts, page_info };
        return {
            success: true,
            data,
            timestamp: new Date().toISOString(),
            source: `facebook:${handle}`,
        };
    }
    async scrapeTwitter(handle) {
        await this.randomDelay();
        const tweets = [
            {
                id: 'tweet_001',
                text: 'LIVE at Dolores Park! Fresh burritos and quesadillas available now ',
                timestamp: new Date(Date.now() - 1_800_000).toISOString(),
                retweets: 8,
                likes: 34,
                replies: 5,
                location: 'Dolores Park, San Francisco',
            },
        ];
        const profile = {
            followers: 2340,
            following: 567,
            tweets_count: 1890,
            bio: ' SF Food Truck | Fresh Mexican Food | Follow for locations',
            location: 'San Francisco, CA',
            website: 'https://tacoparadise.com',
        };
        const data = { tweets, profile };
        return {
            success: true,
            data,
            timestamp: new Date().toISOString(),
            source: `twitter:${handle}`,
        };
    }
    getRandomUserAgent() {
        // Use Node.js crypto for stronger randomness if available, fallback to Math.random otherwise.
        let idx;
        if (globalThis.window?.crypto?.getRandomValues != undefined) {
            const array = globalThis.window.crypto.getRandomValues(new Uint32Array(1));
            idx = array[0] % this.userAgents.length;
        }
        else if (typeof crypto.randomInt === 'function') {
            idx = crypto.randomInt(0, this.userAgents.length);
        }
        else {
            // Fallback to Math.random for environments where crypto is not available.
            // This is acceptable for non-security-critical random number generation like user agent selection.
            // eslint-disable-next-line sonarjs/pseudo-random -- Math.random is acceptable for non-security-critical user agent selection.
            idx = Math.floor(Math.random() * this.userAgents.length);
        }
        return this.userAgents[idx];
    }
    randomDelay() {
        let randomMs;
        if (globalThis.window?.crypto?.getRandomValues != undefined) {
            const array = globalThis.window.crypto.getRandomValues(new Uint32Array(1));
            randomMs = array[0] % 1000;
        }
        else if (typeof crypto.randomInt === 'function') {
            randomMs = crypto.randomInt(0, 1000);
        }
        else {
            // Fallback to Math.random for environments where crypto is not available.
            // This is acceptable for non-security-critical random delays.
            // eslint-disable-next-line sonarjs/pseudo-random -- Math.random is acceptable for non-security-critical random delays.
            randomMs = Math.floor(Math.random() * 1000);
        }
        const delay = this.requestDelay + randomMs;
        return new Promise((resolve) =&gt; setTimeout(resolve, delay));
    }
    handleRateLimit(retryAfter) {
        console.info(`Rate limited. Waiting ${retryAfter} seconds before retry...`);
        return new Promise((resolve) =&gt; setTimeout(resolve, retryAfter * 1000));
    }
    async retryWithBackoff(operation, maxRetries = this.maxRetries) {
        let lastError;
        for (let attempt = 1; attempt &lt;= maxRetries; attempt += 1) {
            try {
                return await operation();
            }
            catch (error) {
                lastError = error;
                if (attempt === maxRetries) {
                    throw lastError instanceof Error ? lastError : new Error(String(lastError));
                }
                const backoffDelay = Math.pow(2, attempt) * 1000;
                console.info(`Attempt ${attempt} failed. Retrying in ${backoffDelay}ms...`);
                await new Promise((resolve) =&gt; setTimeout(resolve, backoffDelay));
            }
        }
        throw lastError instanceof Error ? lastError : new Error('Request failed after all retries');
    }
}
export class DataQualityAssessor {
    assessBasicInfo(truckData, issues, score) {
        if (truckData.name == undefined || truckData.name.trim().length === 0) {
            issues.push('Missing or empty truck name');
            score -= 20;
        }
        return score;
    }
    assessLocationInfo(truckData, issues, score) {
        if (truckData.location?.current == undefined) {
            issues.push('Missing current location data');
            score -= 25;
        }
        else {
            if (truckData.location.current.lat == undefined ||
                truckData.location.current.lng == undefined) {
                issues.push('Missing GPS coordinates');
                score -= 15;
            }
            if (truckData.location.current.address == undefined ||
                truckData.location.current.address === '') {
                issues.push('Missing address information');
                score -= 10;
            }
        }
        return score;
    }
    assessContactInfo(truckData, issues, score) {
        if (truckData.contact) {
            const hasPhone = typeof truckData.contact.phone === 'string' &amp;&amp; truckData.contact.phone.trim() !== '';
            const hasEmail = typeof truckData.contact.email === 'string' &amp;&amp; truckData.contact.email.trim() !== '';
            if (!hasPhone &amp;&amp; !hasEmail) {
                issues.push('No phone or email contact available');
                score -= 15;
            }
            if (hasPhone &amp;&amp; !this.isValidPhone(truckData.contact.phone)) {
                issues.push('Invalid phone number format');
                score -= 5;
            }
            if (hasEmail &amp;&amp; !this.isValidEmail(truckData.contact.email)) {
                issues.push('Invalid email format');
                score -= 5;
            }
        }
        else {
            issues.push('Missing contact information');
            score -= 20;
        }
        return score;
    }
    assessOperatingHours(truckData, issues, score) {
        if (truckData.operating_hours == undefined ||
            Object.keys(truckData.operating_hours).length === 0) {
            issues.push('Missing operating hours');
            score -= 15;
        }
        return score;
    }
    assessMenuInfo(truckData, issues, score) {
        if (truckData.menu == undefined || truckData.menu.length === 0) {
            issues.push('Missing menu information');
            score -= 10;
        }
        else {
            const menuIssues = this.validateMenuData(truckData.menu);
            issues.push(...menuIssues);
            score -= menuIssues.length * 2;
        }
        return score;
    }
    assessLastUpdated(truckData, issues, score) {
        if (truckData.last_updated != undefined &amp;&amp; truckData.last_updated !== '') {
            const lastUpdate = new Date(truckData.last_updated);
            const daysSinceUpdate = (Date.now() - lastUpdate.getTime()) / (1000 * 60 * 60 * 24);
            if (daysSinceUpdate &gt; 7) {
                issues.push('Data is more than 7 days old');
                score -= 10;
            }
            else if (daysSinceUpdate &gt; 3) {
                issues.push('Data is more than 3 days old');
                score -= 5;
            }
        }
        return score;
    }
    assessTruckData(truckData) {
        const issues = [];
        let score = 100;
        score = this.assessBasicInfo(truckData, issues, score);
        score = this.assessLocationInfo(truckData, issues, score);
        score = this.assessContactInfo(truckData, issues, score);
        score = this.assessOperatingHours(truckData, issues, score);
        score = this.assessMenuInfo(truckData, issues, score);
        score = this.assessLastUpdated(truckData, issues, score);
        return {
            score: Math.max(0, score) / 100,
            issues,
        };
    }
    validateMenuCategory(category, categoryIndex, issues) {
        if (category.category == undefined || category.category.trim().length === 0) {
            issues.push(`Menu category ${categoryIndex + 1} missing name`);
        }
    }
    validateMenuItems(category, issues) {
        if (category.items == undefined || category.items.length === 0) {
            issues.push(`Menu category &quot;${category.category ?? 'Unknown'}&quot; has no items`);
        }
        else {
            for (const [itemIndex, item] of category.items.entries()) {
                if (item.name == undefined || item.name.trim().length === 0) {
                    issues.push(`Menu item ${itemIndex + 1} in &quot;${category.category ?? 'Unknown'}&quot; missing name`);
                }
                if (typeof item.price !== 'number' || item.price &lt;= 0) {
                    issues.push(`Menu item &quot;${item.name ?? 'Unknown'}&quot; has invalid price`);
                }
            }
        }
    }
    validateMenuData(menu) {
        const issues = [];
        for (const [categoryIndex, category] of menu.entries()) {
            this.validateMenuCategory(category, categoryIndex, issues);
            this.validateMenuItems(category, issues);
        }
        return issues;
    }
    isValidPhone(phone) {
        // Regex for phone number validation. Not vulnerable to super-linear runtime due to backtracking.
        // Accepts +, digits, spaces, dashes, and parentheses. At least 10 digits.
        const phoneRegex = /^\+?[\d\s\-()]{10,}$/;
        return phoneRegex.test(phone);
    }
    isValidEmail(email) {
        // Regex for email validation optimized to avoid backtracking
        const emailRegex = /^[^\s@]+@[^\s@]+\.[a-zA-Z]{2,}$/;
        return emailRegex.test(email);
    }
}
export class GeminiDataProcessor {
    _apiKey;
    _baseUrl;
    requestCount;
    tokenCount;
    dailyLimit;
    constructor(apiKey) {
        this._apiKey = apiKey;
        this._baseUrl = 'https://generativelanguage.googleapis.com/v1beta';
        this.requestCount = 0;
        this.tokenCount = 0;
        this.dailyLimit = { requests: 1500, tokens: 32_000 };
    }
    async processMenuData(rawMenuText) {
        if (!this.canMakeRequest()) {
            throw new Error('Gemini API rate limit exceeded');
        }
        try {
            const prompt = `
        Parse the following food truck menu text and return a structured JSON format:
        
        ${rawMenuText}
        
        Return format:
        {
          &quot;categories&quot;: [
            {
              &quot;name&quot;: &quot;category_name&quot;,
              &quot;items&quot;: [
                {
                  &quot;name&quot;: &quot;item_name&quot;,
                  &quot;description&quot;: &quot;item_description&quot;,
                  &quot;price&quot;: 0.00,
                  &quot;dietary_tags&quot;: [&quot;vegetarian&quot;, &quot;vegan&quot;, &quot;gluten-free&quot;, etc.]
                }
              ]
            }
          ]
        }
        
        Only return valid JSON, no additional text.
      `;
            const response = await this.makeGeminiRequest(prompt);
            this.updateUsageCounters(1, prompt.length + response.length);
            // Ensure type safety for parsed response
            const parsed = JSON.parse(response);
            if (typeof parsed !== 'object' ||
                parsed == undefined ||
                !('categories' in parsed) ||
                !Array.isArray(parsed.categories)) {
                throw new Error('Invalid Gemini menu response: missing or malformed categories array');
            }
            return parsed;
        }
        catch (error) {
            console.error('Error processing menu data with Gemini:', error);
            throw error;
        }
    }
    async extractLocationFromText(text) {
        if (!this.canMakeRequest()) {
            throw new Error('Gemini API rate limit exceeded');
        }
        try {
            const prompt = `
        Extract location information from the following text and return structured data:
        
        &quot;${text}&quot;
        
        Return format:
        {
          &quot;address&quot;: &quot;full_address&quot;,
          &quot;city&quot;: &quot;city_name&quot;,
          &quot;state&quot;: &quot;state&quot;,
          &quot;coordinates&quot;: {
            &quot;lat&quot;: 0.0,
            &quot;lng&quot;: 0.0
          },
          &quot;confidence&quot;: 0.95
        }
        
        If coordinates cannot be determined, set them to undefined. Only return valid JSON.
      `;
            const response = await this.makeGeminiRequest(prompt);
            this.updateUsageCounters(1, prompt.length + response.length);
            const parsedResponse = JSON.parse(response);
            const validatedResponse = this.validateGeminiLocationResponse(parsedResponse);
            return validatedResponse;
        }
        catch (error) {
            console.error('Error extracting location with Gemini:', error);
            throw error;
        }
    }
    validateGeminiLocationResponse(parsedResponse) {
        if (parsedResponse == undefined ||
            typeof parsedResponse !== 'object' ||
            !('coordinates' in parsedResponse) ||
            typeof parsedResponse.coordinates !== 'object') {
            throw new Error('Invalid Gemini location response');
        }
        const coordinates = parsedResponse
            .coordinates;
        if (coordinates &amp;&amp; typeof coordinates === 'object') {
            if (typeof coordinates.lat !== 'number') {
                coordinates.lat = undefined;
            }
            if (typeof coordinates.lng !== 'number') {
                coordinates.lng = undefined;
            }
        }
        return parsedResponse;
    }
    async standardizeOperatingHours(hoursText) {
        if (!this.canMakeRequest()) {
            throw new Error('Gemini API rate limit exceeded');
        }
        try {
            const prompt = `
        Parse the following operating hours text and return standardized format:
        
        &quot;${hoursText}&quot;
        
        Return format:
        {
          &quot;monday&quot;: {&quot;open&quot;: &quot;HH:MM&quot;, &quot;close&quot;: &quot;HH:MM&quot;, &quot;closed&quot;: false},
          &quot;tuesday&quot;: {&quot;open&quot;: &quot;HH:MM&quot;, &quot;close&quot;: &quot;HH:MM&quot;, &quot;closed&quot;: false},
          &quot;wednesday&quot;: {&quot;open&quot;: &quot;HH:MM&quot;, &quot;close&quot;: &quot;HH:MM&quot;, &quot;closed&quot;: false},
          &quot;thursday&quot;: {&quot;open&quot;: &quot;HH:MM&quot;, &quot;close&quot;: &quot;HH:MM&quot;, &quot;closed&quot;: false},
          &quot;friday&quot;: {&quot;open&quot;: &quot;HH:MM&quot;, &quot;close&quot;: &quot;HH:MM&quot;, &quot;closed&quot;: false},
          &quot;saturday&quot;: {&quot;open&quot;: &quot;HH:MM&quot;, &quot;close&quot;: &quot;HH:MM&quot;, &quot;closed&quot;: false},
          &quot;sunday&quot;: {&quot;open&quot;: &quot;HH:MM&quot;, &quot;close&quot;: &quot;HH:MM&quot;, &quot;closed&quot;: false}
        }
          Use 24-hour format. If closed on a day, set &quot;closed&quot;: true and omit open/close times.
        Only return valid JSON.
      `;
            const response = await this.makeGeminiRequest(prompt);
            this.updateUsageCounters(1, prompt.length + response.length);
            const parsed = JSON.parse(response);
            if (parsed == undefined || typeof parsed !== 'object') {
                throw new Error('Invalid Gemini hours response');
            }
            return parsed;
        }
        catch (error) {
            console.error('Error standardizing hours with Gemini:', error);
            throw error;
        }
    }
    async analyzeSentiment(reviewText) {
        if (!this.canMakeRequest()) {
            throw new Error('Gemini API rate limit exceeded');
        }
        try {
            const prompt = `
        Analyze the sentiment of this food truck review and extract key insights:
        
        &quot;${reviewText}&quot;
        
        Return format:
        {
          &quot;sentiment&quot;: &quot;positive|negative|neutral&quot;,
          &quot;score&quot;: 0.85,
          &quot;key_topics&quot;: [&quot;food_quality&quot;, &quot;service&quot;, &quot;price&quot;, &quot;location&quot;],
          &quot;summary&quot;: &quot;brief_summary_of_review&quot;
        }
          Score should be between 0 (very negative) and 1 (very positive).
        Only return valid JSON.
      `;
            const response = await this.makeGeminiRequest(prompt);
            this.updateUsageCounters(1, prompt.length + response.length);
            const parsed = JSON.parse(response);
            if (parsed == undefined || typeof parsed !== 'object') {
                throw new Error('Invalid Gemini sentiment response');
            }
            return parsed;
        }
        catch (error) {
            console.error('Error analyzing sentiment with Gemini:', error);
            throw error;
        }
    }
    async makeGeminiRequest(prompt) {
        await new Promise((resolve) =&gt; setTimeout(resolve, 1000)); // Simulate API delay
        return this.getMockGeminiResponse(prompt);
    }
    getMockGeminiResponse(prompt) {
        if (prompt.includes('menu text')) {
            return JSON.stringify({
                categories: [
                    {
                        name: 'Burgers',
                        items: [
                            {
                                name: 'Classic Cheeseburger',
                                description: 'Beef patty with cheese, lettuce, tomato',
                                price: 12.99,
                                dietary_tags: [],
                            },
                        ],
                    },
                ],
            });
        }
        else if (prompt.includes('location information')) {
            return JSON.stringify({
                address: '123 Market St, San Francisco, CA 94105',
                city: 'San Francisco',
                state: 'CA',
                coordinates: {
                    lat: 37.7749,
                    lng: -122.4194,
                },
                confidence: 0.95,
            });
        }
        else if (prompt.includes('operating hours')) {
            return JSON.stringify({
                monday: { open: '11:00', close: '15:00', closed: false },
                tuesday: { open: '11:00', close: '15:00', closed: false },
                wednesday: { open: '11:00', close: '15:00', closed: false },
                thursday: { open: '11:00', close: '15:00', closed: false },
                friday: { open: '11:00', close: '20:00', closed: false },
                saturday: { open: '12:00', close: '20:00', closed: false },
                sunday: { open: '12:00', close: '16:00', closed: false },
            });
        }
        else if (prompt.includes('sentiment')) {
            return JSON.stringify({
                sentiment: 'positive',
                score: 0.85,
                key_topics: ['food_quality', 'service'],
                summary: 'Customer enjoyed the food and service',
            });
        }
        return '{&quot;processed&quot;: true}';
    }
    canMakeRequest() {
        return this.requestCount &lt; this.dailyLimit.requests &amp;&amp; this.tokenCount &lt; this.dailyLimit.tokens;
    }
    updateUsageCounters(requests, tokens) {
        this.requestCount += requests;
        this.tokenCount += tokens;
    }
    getUsageStats() {
        return {
            requests: {
                used: this.requestCount,
                limit: this.dailyLimit.requests,
                remaining: this.dailyLimit.requests - this.requestCount,
            },
            tokens: {
                used: this.tokenCount,
                limit: this.dailyLimit.tokens,
                remaining: this.dailyLimit.tokens - this.tokenCount,
            },
        };
    }
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/lib/scheduler.js (Line 1:1 - Line 356:2), C:/AI/food-truck-finder-poc/dist/lib/lib/scheduler.js (Line 1:1 - Line 356:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn485" onclick="toggleCodeBlock('cloneGroup485', 'expandBtn485', 'collapseBtn485')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn485" onclick="toggleCodeBlock('cloneGroup485', 'expandBtn485', 'collapseBtn485')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup485"><code class="language-javascript text-sm text-gray-800">// Task scheduling and automation system
export class TaskScheduler {
    tasks;
    intervals;
    isRunning;
    constructor() {
        this.tasks = new Map();
        this.intervals = new Map();
        this.isRunning = false;
    }
    start() {
        if (this.isRunning === true) {
            console.info('Scheduler is already running');
            return;
        }
        this.isRunning = true;
        console.info('Task scheduler started');
        // Start all scheduled tasks
        for (const [taskId, task] of this.tasks.entries()) {
            if (task.enabled === true) {
                this.scheduleTask(taskId, task);
            }
        }
    }
    stop() {
        if (this.isRunning !== true) {
            console.info('Scheduler is not running');
            return;
        }
        this.isRunning = false;
        // Clear all intervals
        for (const [taskId, interval] of this.intervals.entries()) {
            clearInterval(interval);
            console.info(`Stopped task: ${taskId}`);
        }
        this.intervals.clear();
        console.info('Task scheduler stopped');
    }
    addTask(task) {
        this.tasks.set(task.id, task);
        if (this.isRunning === true &amp;&amp; task.enabled === true) {
            this.scheduleTask(task.id, task);
        }
        console.info(`Added task: ${task.id}`);
    }
    removeTask(taskId) {
        const interval = this.intervals.get(taskId);
        if (interval) {
            clearInterval(interval);
            this.intervals.delete(taskId);
        }
        this.tasks.delete(taskId);
        console.info(`Removed task: ${taskId}`);
    }
    enableTask(taskId) {
        const task = this.tasks.get(taskId);
        if (!task) {
            throw new Error(`Task not found: ${taskId}`);
        }
        task.enabled = true;
        if (this.isRunning) {
            this.scheduleTask(taskId, task);
        }
        console.info(`Enabled task: ${taskId}`);
    }
    disableTask(taskId) {
        const task = this.tasks.get(taskId);
        if (!task) {
            throw new Error(`Task not found: ${taskId}`);
        }
        task.enabled = false;
        const interval = this.intervals.get(taskId);
        if (interval) {
            clearInterval(interval);
            this.intervals.delete(taskId);
        }
        console.info(`Disabled task: ${taskId}`);
    }
    scheduleTask(taskId, task) {
        // Clear existing interval if any
        const existingInterval = this.intervals.get(taskId);
        if (existingInterval) {
            clearInterval(existingInterval);
        }
        // Calculate interval in milliseconds
        const intervalMs = task.intervalMinutes * 60 * 1000;
        // Schedule the task with proper async wrapper
        const interval = setInterval(() =&gt; {
            // Use void to indicate we're not handling the promise
            void (async () =&gt; {
                try {
                    console.info(`Executing task: ${taskId}`);
                    task.lastRun = new Date().toISOString();
                    await task.execute();
                    task.successCount += 1;
                    task.lastSuccess = new Date().toISOString();
                    console.info(`Task completed successfully: ${taskId}`);
                }
                catch (error) {
                    task.errorCount += 1;
                    task.lastError = error instanceof Error ? error.message : 'Unknown error';
                    console.warn(`Task failed: ${taskId}`, error);
                    // Disable task if too many consecutive failures
                    if (task.errorCount - task.successCount &gt; 5) {
                        console.warn(`Disabling task due to repeated failures: ${taskId}`);
                        this.disableTask(taskId);
                    }
                }
            })();
        }, intervalMs);
        this.intervals.set(taskId, interval);
        console.info(`Scheduled task: ${taskId} (every ${task.intervalMinutes} minutes)`);
    }
    getTaskStatus() {
        return [...this.tasks.values()].map((task) =&gt; ({
            id: task.id,
            name: task.name,
            enabled: task.enabled,
            intervalMinutes: task.intervalMinutes,
            lastRun: task.lastRun,
            lastSuccess: task.lastSuccess,
            successCount: task.successCount,
            errorCount: task.errorCount,
            lastError: task.lastError,
            nextRun: this.calculateNextRun(task),
        }));
    }
    calculateNextRun(task) {
        if (task.enabled !== true || task.lastRun == undefined) {
            return undefined;
        }
        const lastRun = new Date(task.lastRun);
        const nextRun = new Date(lastRun.getTime() + task.intervalMinutes * 60 * 1000);
        return nextRun.toISOString();
    }
    scheduleFollowUpTasks(result) {
        // Implementation for scheduling follow-up tasks based on scraping results
        console.info('Scheduling follow-up tasks based on scraping results:', result);
        // This could include:
        // - Scheduling quality checks for newly scraped data
        // - Setting up monitoring for high-priority trucks
        // - Triggering additional scraping for related sources
    }
}
// Helper function to update truck location from social media
async function updateTruckLocationFromSocial(truck, scraperEngine) {
    if (truck.social_media.instagram_handle == undefined ||
        truck.social_media.instagram_handle === '') {
        return;
    }
    const socialResult = await scraperEngine.scrapeSocialMedia('instagram', truck.social_media.instagram_handle);
    if (socialResult.success === true &amp;&amp; socialResult.data != undefined) {
        const socialData = socialResult.data;
        const recentPosts = socialData.posts.slice(0, 3);
        for (const post of recentPosts) {
            if (post.location != undefined &amp;&amp; post.location !== '') {
                console.info(`Updated location for ${truck.name}: ${post.location}`);
                break;
            }
        }
    }
}
// Pre-configured tasks for food truck data pipeline
export function createDefaultTasks(scraperEngine, geminiProcessor, dataQualityAssessor) {
    return [
        createInstagramScrapeTask(scraperEngine),
        createWebsiteCrawlTask(scraperEngine),
        createDataQualityCheckTask(dataQualityAssessor),
        createGeminiProcessingTask(geminiProcessor),
        createLocationUpdateTask(scraperEngine),
    ];
}
/**
 * Create Instagram scraping task
 */
function createInstagramScrapeTask(scraperEngine) {
    return {
        id: 'instagram_scrape',
        name: 'Instagram Data Scraping',
        description: 'Scrape Instagram posts and profiles for food truck data',
        intervalMinutes: 120, // Every 2 hours
        enabled: true,
        successCount: 0,
        errorCount: 0,
        execute: async () =&gt; {
            const handles = ['@gourmetstreeteats', '@tacoparadisesf', '@burgermobile'];
            for (const handle of handles) {
                const result = await scraperEngine.scrapeSocialMedia('instagram', handle);
                if (result.success) {
                    console.info(`Successfully scraped ${handle}`);
                }
                else {
                    throw new Error(`Failed to scrape ${handle}: ${result.error}`);
                }
            }
        },
    };
}
/**
 * Create website crawling task
 */
function createWebsiteCrawlTask(scraperEngine) {
    return {
        id: 'website_crawl',
        name: 'Website Crawling',
        description: 'Crawl food truck websites for menu and location updates',
        intervalMinutes: 360, // Every 6 hours
        enabled: true,
        successCount: 0,
        errorCount: 0,
        execute: async () =&gt; {
            const websites = [
                'https://gourmetstreeteats.com',
                'https://tacoparadise.com',
                'https://burgermobile.net',
            ];
            const selectors = {
                name: '.truck-name',
                location: '.current-location',
                hours: '.operating-hours',
                menu: '.menu-items',
            };
            for (const url of websites) {
                const result = await scraperEngine.scrapeWebsite(url, selectors);
                if (result.success) {
                    console.info(`Successfully crawled ${url}`);
                }
                else {
                    throw new Error(`Failed to crawl ${url}: ${result.error}`);
                }
            }
        },
    };
}
/**
 * Create data quality check task
 */
function createDataQualityCheckTask(dataQualityAssessor) {
    return {
        id: 'data_quality_check',
        name: 'Data Quality Assessment',
        description: 'Assess and validate data quality for all food trucks',
        intervalMinutes: 720, // Every 12 hours
        enabled: true,
        successCount: 0,
        errorCount: 0,
        execute: async () =&gt; {
            // Placeholder: fetch trucks from database
            const trucks = [];
            await Promise.resolve(); // Added to satisfy async/await rule
            let totalScore = 0;
            let processedCount = 0;
            if (trucks.length === 0) {
                console.info('No trucks available for quality assessment');
                return;
            }
            for (const truck of trucks) {
                const assessment = dataQualityAssessor.assessTruckData(truck);
                totalScore += assessment.score;
                processedCount += 1;
                if (assessment.score &lt; 0.7) {
                    console.warn(`Low quality data for truck ${truck.id}: ${assessment.issues.join(', ')}`);
                }
            }
            const averageQuality = processedCount &gt; 0 ? totalScore / processedCount : 0;
            console.info(`Data quality assessment completed. Average score: ${averageQuality.toFixed(2)}`);
        },
    };
}
/**
 * Create Gemini processing task
 */
function createGeminiProcessingTask(geminiProcessor) {
    return {
        id: 'gemini_processing',
        name: 'AI Data Processing',
        description: 'Process raw data using Gemini AI for standardization',
        intervalMinutes: 480, // Every 8 hours
        enabled: true,
        successCount: 0,
        errorCount: 0,
        execute: async () =&gt; {
            const usage = geminiProcessor.getUsageStats();
            if (usage.requests.remaining &lt; 100) {
                console.warn('Skipping Gemini processing due to rate limits');
                return;
            }
            const pendingData = []; // Placeholder: fetch pending data from queue system
            if (pendingData.length === 0) {
                console.info('No pending data to process');
                return;
            }
            await processGeminiDataBatch(geminiProcessor, pendingData);
            console.info(`Processed ${pendingData.length} items with Gemini AI`);
        },
    };
}
/**
 * Process batch of data with Gemini
 */
async function processGeminiDataBatch(geminiProcessor, pendingData) {
    for (const data of pendingData) {
        switch (data.type) {
            case 'menu': {
                await geminiProcessor.processMenuData(data.content);
                break;
            }
            case 'location': {
                await geminiProcessor.extractLocationFromText(data.content);
                break;
            }
            case 'hours': {
                await geminiProcessor.standardizeOperatingHours(data.content);
                break;
            }
            case 'sentiment': {
                await geminiProcessor.analyzeSentiment(data.content);
                break;
            }
            case 'enhance': {
                await geminiProcessor.enhanceFoodTruckData(data.content);
                break;
            }
            default: {
                // No default
                break;
            }
        }
    }
}
/**
 * Create location update task
 */
function createLocationUpdateTask(scraperEngine) {
    return {
        id: 'location_update',
        name: 'Real-time Location Updates',
        description: 'Update current locations for active food trucks',
        intervalMinutes: 30, // Every 30 minutes
        enabled: true,
        successCount: 0,
        errorCount: 0,
        execute: async () =&gt; {
            const activeTrucks = []; // Placeholder: fetch active trucks from database
            if (activeTrucks.length === 0) {
                console.info('No active trucks to update locations for');
                return;
            }
            for (const truck of activeTrucks) {
                await updateTruckLocationFromSocial(truck, scraperEngine);
            }
        },
    };
}
// Export scheduler instance for use in cron jobs
export const scheduler = new TaskScheduler();</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/lib/pipelineManager.js (Line 6:19 - Line 284:2), C:/AI/food-truck-finder-poc/dist/lib/lib/pipelineManager.js (Line 6:16 - Line 284:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn487" onclick="toggleCodeBlock('cloneGroup487', 'expandBtn487', 'collapseBtn487')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn487" onclick="toggleCodeBlock('cloneGroup487', 'expandBtn487', 'collapseBtn487')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup487"><code class="language-javascript text-sm text-gray-800">;
/**
 * Unified Pipeline Manager
 *
 * Consolidates all pipeline operations into a single, modular system:
 * - Discovery: Find new food truck URLs using Tavily
 * - Processing: Process URLs through Firecrawl + Gemini pipeline
 * - Full: Combined discovery + processing
 * - Maintenance: Check existing trucks for stale data
 */
export class PipelineManager {
    /**
     * Run the complete pipeline based on configuration
     */
    async runPipeline(config) {
        const startTime = Date.now();
        try {
            console.info(` PipelineManager: Starting ${config.type} pipeline...`);
            const result = await this.executePipelineType(config);
            return this.createSuccessResult(config, result, startTime);
        }
        catch (error) {
            return this.createErrorResult(config, error, startTime);
        }
    }
    /**
     * Execute the specific pipeline type
     */
    async executePipelineType(config) {
        switch (config.type) {
            case 'discovery': {
                return await this.runDiscovery({
                    cities: config.params.targetCities ?? [],
                    maxUrls: config.params.maxUrls ?? 50,
                    searchTerms: ['food truck', 'food cart', 'mobile food'],
                });
            }
            case 'processing': {
                return await this.processJobs({
                    maxJobs: config.params.maxUrlsToProcess ?? 20,
                    priority: config.params.priority ?? 5,
                    retryFailedJobs: config.params.retryFailedJobs ?? false,
                });
            }
            case 'full': {
                return await this.runFullPipeline(config);
            }
            case 'maintenance': {
                return await this.runMaintenance();
            }
            default: {
                throw new Error(`Unknown pipeline type: ${String(config.type)}`);
            }
        }
    }
    /**
     * Create success result
     */
    createSuccessResult(config, result, startTime) {
        const duration = Date.now() - startTime;
        return {
            success: true,
            type: config.type,
            phase: 'completed',
            summary: {
                ...(typeof result === 'object' &amp;&amp; result !== null
                    ? result
                    : {}),
                duration,
            },
            details: result,
            timestamp: new Date().toISOString(),
        };
    }
    /**
     * Create error result
     */
    createErrorResult(config, error, startTime) {
        const duration = Date.now() - startTime;
        console.error(` PipelineManager: ${config.type} pipeline failed:`, error);
        return {
            success: false,
            type: config.type,
            phase: 'failed',
            summary: {
                errors: 1,
                duration,
            },
            details: {
                error: error instanceof Error ? error.message : 'Unknown error',
            },
            timestamp: new Date().toISOString(),
        };
    }
    /**
     * Run URL discovery using Tavily search
     */
    async runDiscovery(_params) {
        const startTime = Date.now();
        try {
            console.info(` PipelineManager: Starting discovery process...`);
            // Use the existing discovery engine's method
            const discoveryResult = await discoveryEngine.discoverNewFoodTrucks();
            const duration = Date.now() - startTime;
            return {
                success: discoveryResult.errors.length === 0,
                urlsDiscovered: discoveryResult.urls_discovered,
                urlsStored: discoveryResult.urls_stored,
                urlsDuplicate: discoveryResult.urls_duplicates,
                errors: discoveryResult.errors,
                duration,
            };
        }
        catch (error) {
            const duration = Date.now() - startTime;
            const errorMsg = error instanceof Error ? error.message : 'Unknown discovery error';
            console.error(' PipelineManager: Discovery failed:', error);
            return {
                success: false,
                urlsDiscovered: 0,
                urlsStored: 0,
                urlsDuplicate: 0,
                errors: [errorMsg],
                duration,
            };
        }
    }
    /**
     * Process existing scraping jobs
     */
    async processJobs(options) {
        const startTime = Date.now();
        try {
            console.info(` PipelineManager: Processing up to ${options.maxJobs} jobs...`);
            const pendingJobs = await ScrapingJobService.getJobsByStatus('pending');
            if (pendingJobs == undefined || pendingJobs.length === 0) {
                return this.createEmptyProcessingResult(startTime);
            }
            const jobsToProcess = pendingJobs.slice(0, options.maxJobs);
            const results = await this.processJobBatch(jobsToProcess, startTime);
            return results;
        }
        catch (error) {
            return this.createProcessingErrorResult(error, startTime);
        }
    }
    /**
     * Create empty processing result when no jobs available
     */
    createEmptyProcessingResult(startTime) {
        console.info('No pending jobs to process');
        return {
            success: true,
            jobsProcessed: 0,
            jobsSuccessful: 0,
            jobsFailed: 0,
            trucksCreated: 0,
            errors: [],
            duration: Date.now() - startTime,
        };
    }
    /**
     * Process a batch of jobs
     */
    async processJobBatch(jobsToProcess, startTime) {
        const errors = [];
        let jobsSuccessful = 0;
        let jobsFailed = 0;
        let trucksCreated = 0;
        for (const job of jobsToProcess) {
            try {
                console.info(`Processing job ${job.id} for URL: ${job.target_url}`);
                await processScrapingJob(job.id);
                const updatedJob = await ScrapingJobService.getJobsByStatus('completed').then((jobs) =&gt; jobs?.find((j) =&gt; j.id === job.id));
                if (updatedJob?.data_collected?.truck_id != undefined) {
                    trucksCreated += 1;
                }
                jobsSuccessful += 1;
            }
            catch (jobError) {
                const errorMsg = `Job ${job.id} failed: ${jobError instanceof Error ? jobError.message : 'Unknown error'}`;
                console.warn(errorMsg);
                errors.push(errorMsg);
                jobsFailed += 1;
            }
        }
        return {
            success: jobsFailed === 0,
            jobsProcessed: jobsToProcess.length,
            jobsSuccessful,
            jobsFailed,
            trucksCreated,
            errors,
            duration: Date.now() - startTime,
        };
    }
    /**
     * Create processing error result
     */
    createProcessingErrorResult(error, startTime) {
        const duration = Date.now() - startTime;
        const errorMsg = error instanceof Error ? error.message : 'Unknown processing error';
        console.error(' PipelineManager: Job processing failed:', error);
        return {
            success: false,
            jobsProcessed: 0,
            jobsSuccessful: 0,
            jobsFailed: 0,
            trucksCreated: 0,
            errors: [errorMsg],
            duration,
        };
    }
    /**
     * Run full pipeline: discovery + processing
     */
    async runFullPipeline(config) {
        const results = {
            discovery: undefined,
            processing: undefined,
        };
        // Step 1: Discovery (unless skipped)
        if (config.params.skipDiscovery !== true) {
            results.discovery = await this.runDiscovery({
                cities: config.params.targetCities ?? ['Charleston', 'Columbia', 'Greenville'],
                maxUrls: config.params.maxUrls ?? 50,
                searchTerms: ['food truck', 'food cart', 'mobile food'],
            });
        }
        // Step 2: Processing
        results.processing = await this.processJobs({
            maxJobs: config.params.maxUrlsToProcess ?? 20,
            priority: config.params.priority ?? 5,
            retryFailedJobs: config.params.retryFailedJobs ?? false,
        });
        // Combine results
        return {
            urlsDiscovered: results.discovery?.urlsDiscovered ?? 0,
            urlsStored: results.discovery?.urlsStored ?? 0,
            urlsDuplicate: results.discovery?.urlsDuplicate ?? 0,
            jobsProcessed: results.processing?.jobsProcessed ?? 0,
            trucksCreated: results.processing?.trucksCreated ?? 0,
            errors: [...(results.discovery?.errors ?? []), ...(results.processing?.errors ?? [])],
        };
    }
    /**
     * Run maintenance checks on existing trucks
     */
    async runMaintenance() {
        const startTime = Date.now();
        try {
            console.info(' PipelineManager: Running maintenance checks...');
            // Use the existing autoScraper functionality
            const result = await ensureDefaultTrucksAreScraped();
            const duration = Date.now() - startTime;
            return {
                success: result.errors.length === 0,
                trucksProcessed: result.trucksProcessed,
                newTrucksFound: result.newTrucksFound,
                errors: result.errors.map((e) =&gt; e.url + ': ' + (e.details ?? 'Unknown error')),
                duration,
            };
        }
        catch (error) {
            const duration = Date.now() - startTime;
            const errorMsg = error instanceof Error ? error.message : 'Unknown maintenance error';
            console.error(' PipelineManager: Maintenance failed:', error);
            return {
                success: false,
                trucksProcessed: 0,
                newTrucksFound: 0,
                errors: [errorMsg],
                duration,
            };
        }
    }
}
// Export singleton instance
export const pipelineManager = new PipelineManager();</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/lib/gemini.js (Line 1:16 - Line 186:2), C:/AI/food-truck-finder-poc/dist/lib/lib/gemini.js (Line 1:41 - Line 186:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn489" onclick="toggleCodeBlock('cloneGroup489', 'expandBtn489', 'collapseBtn489')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn489" onclick="toggleCodeBlock('cloneGroup489', 'expandBtn489', 'collapseBtn489')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup489"><code class="language-javascript text-sm text-gray-800">;
import { GeminiApiClient } from './gemini/geminiApiClient.js';
import { GeminiUsageLimits } from './gemini/usageLimits.js';
import { PromptTemplates } from './gemini/promptTemplates.js';
import { GeminiResponseParser } from './gemini/responseParser.js';
export class GeminiService {
    apiClient;
    dailyRequestLimit = 1500;
    dailyTokenLimit = 32_000;
    constructor() {
        this.apiClient = new GeminiApiClient();
    }
    checkUsageLimits = () =&gt; {
        return GeminiUsageLimits.checkUsageLimits({
            dailyRequestLimit: this.dailyRequestLimit,
            dailyTokenLimit: this.dailyTokenLimit,
        });
    };
    makeGeminiRequest = async (prompt, parser) =&gt; {
        return this.apiClient.makeRequestWithParsing(prompt, parser);
    };
    processMenuData = async (rawMenuText) =&gt; {
        const estimatedTokens = Math.ceil(rawMenuText.length / 4) + 500;
        const usageCheck = await GeminiUsageLimits.checkWithMonitoring(estimatedTokens);
        if (!usageCheck.allowed) {
            console.error('Gemini API usage limit error:', usageCheck.reason);
            return {
                success: false,
                error: &quot;That didn't work, please try again later.&quot;,
            };
        }
        const prompt = PromptTemplates.menuProcessing(rawMenuText);
        return this.makeGeminiRequest(prompt, (text) =&gt; {
            const parsedData = JSON.parse(text);
            return parsedData.categories;
        });
    };
    extractLocationFromText = async (textInput) =&gt; {
        const usageCheck = await this.checkUsageLimits();
        if (!usageCheck.canMakeRequest) {
            console.error('Gemini API usage limit error: Daily API limits exceeded');
            return {
                success: false,
                error: &quot;That didn't work, please try again later.&quot;,
            };
        }
        const prompt = PromptTemplates.locationExtraction(textInput);
        return this.makeGeminiRequest(prompt, (text) =&gt; GeminiResponseParser.parseLocationData(text));
    };
    standardizeOperatingHours = async (hoursText) =&gt; {
        const usageCheck = await this.checkUsageLimits();
        if (!usageCheck.canMakeRequest) {
            console.error('Gemini API usage limit error: Daily API limits exceeded');
            return {
                success: false,
                error: &quot;That didn't work, please try again later.&quot;,
            };
        }
        const prompt = PromptTemplates.operatingHours(hoursText);
        return this.makeGeminiRequest(prompt, (text) =&gt; GeminiResponseParser.parseOperatingHours(text));
    };
    analyzeSentiment = async (reviewText) =&gt; {
        const usageCheck = await this.checkUsageLimits();
        if (!usageCheck.canMakeRequest) {
            console.error('Gemini API usage limit error: Daily API limits exceeded');
            return {
                success: false,
                error: &quot;That didn't work, please try again later.&quot;,
            };
        }
        const prompt = PromptTemplates.sentimentAnalysis(reviewText);
        return this.makeGeminiRequest(prompt, (text) =&gt; GeminiResponseParser.parseSentimentAnalysis(text));
    };
    enhanceFoodTruckData = async (rawData) =&gt; {
        const usageCheck = await this.checkUsageLimits();
        if (!usageCheck.canMakeRequest) {
            console.error('Gemini API usage limit error: Daily API limits exceeded');
            return {
                success: false,
                error: &quot;That didn't work, please try again later.&quot;,
            };
        }
        const prompt = PromptTemplates.dataEnhancement(rawData);
        return this.makeGeminiRequest(prompt, (text) =&gt; GeminiResponseParser.parseEnhancedFoodTruckData(text));
    };
    batchProcess = async (items) =&gt; {
        const results = [];
        for (const item of items) {
            let result;
            switch (item.type) {
                case 'menu': {
                    result = await this.processMenuData(item.data);
                    break;
                }
                case 'location': {
                    result = await this.extractLocationFromText(item.data);
                    break;
                }
                case 'hours': {
                    result = await this.standardizeOperatingHours(item.data);
                    break;
                }
                case 'sentiment': {
                    result = await this.analyzeSentiment(item.data);
                    break;
                }
                case 'enhance': {
                    result = await this.enhanceFoodTruckData(item.data); // item.data is already unknown
                    break;
                }
                default: {
                    console.error('Unknown processing type in Gemini batchProcess:', item.type);
                    result = { success: false, error: &quot;That didn't work, please try again later.&quot; };
                    break;
                }
            }
            results.push(result);
        }
        return results;
    };
    getUsageStats = async () =&gt; {
        const usage = await APIUsageService.getTodayUsage('gemini');
        return usage ?? undefined;
    };
    extractFoodTruckDetailsFromMarkdown = async (markdownContent, sourceUrl) =&gt; {
        const usageCheck = await this.checkUsageLimits();
        if (!usageCheck.canMakeRequest) {
            console.error('Gemini API usage limit error: Daily API limits exceeded for Gemini');
            return {
                success: false,
                error: &quot;That didn't work, please try again later.&quot;,
            };
        }
        const prompt = PromptTemplates.foodTruckExtraction(markdownContent, sourceUrl);
        const response = await this.makeGeminiRequest(prompt, (text) =&gt; {
            const cleanedText = GeminiResponseParser.cleanMarkdownResponse(text);
            return GeminiResponseParser.parseExtractedFoodTruckDetails(cleanedText);
        });
        // Add promptSent to response for this specific method
        return {
            ...response,
            promptSent: prompt,
        };
    };
}
/**
* Dispatches the appropriate Gemini operation based on the provided type.
* @example
* dispatchGeminiOperation('menu', 'data')
* Returns a promise with processed menu data response
* @param {'menu' | 'location' | 'hours' | 'sentiment' | 'enhance' | 'foodTruckExtraction'} type - The type of Gemini operation to dispatch.
* @param {unknown} data - Data relevant to the specified Gemini operation type.
* @returns {Promise&lt;GeminiResponse&lt;unknown&gt;&gt;} Returns a promise that resolves to the Gemini operation's response.
* @description
*   - Operates asynchronously, ensuring the flexibility and responsiveness of Gemini processing.
*   - Utilizes type assertion to correctly handle various data types pertinent to the operation.
*   - If the operation type is unrecognized, the function returns an error response.
*/
export async function dispatchGeminiOperation(type, data) {
    switch (type) {
        case 'menu': {
            return gemini.processMenuData(data);
        }
        case 'location': {
            return gemini.extractLocationFromText(data);
        }
        case 'hours': {
            return gemini.standardizeOperatingHours(data);
        }
        case 'sentiment': {
            return gemini.analyzeSentiment(data);
        }
        case 'enhance': {
            return gemini.enhanceFoodTruckData(data);
        }
        case 'foodTruckExtraction': {
            const { markdownContent, sourceUrl } = data;
            return gemini.extractFoodTruckDetailsFromMarkdown(markdownContent, sourceUrl);
        }
        default: {
            return { success: false, error: `Unknown Gemini operation type: ${String(type)}` };
        }
    }
}
// Export singleton instance
export const gemini = new GeminiService();</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/lib/firecrawl.js (Line 1:1 - Line 407:2), C:/AI/food-truck-finder-poc/dist/lib/lib/firecrawl.js (Line 1:1 - Line 407:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn491" onclick="toggleCodeBlock('cloneGroup491', 'expandBtn491', 'collapseBtn491')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn491" onclick="toggleCodeBlock('cloneGroup491', 'expandBtn491', 'collapseBtn491')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup491"><code class="language-javascript text-sm text-gray-800">const FIRECRAWL_CACHE_TTL_MS = 1000 * 60 * 60 * 12; // 12 hours
const firecrawlCache = {};
export class FirecrawlService {
    apiKey;
    baseUrl;
    constructor() {
        this.apiKey = process.env.FIRECRAWL_API_KEY;
        this.baseUrl = 'https://api.firecrawl.dev/v0';
    }
    /**
     * Retrieves a cached result based on the given cache key if it hasn't expired.
     * @example
     * getCachedResult('uniqueCacheKey')
     * FirecrawlResponse or undefined
     * @param {string} cacheKey - The unique identifier for the cached result.
     * @returns {FirecrawlResponse | CrawlJobResponse | CrawlStatusResponse | undefined} The cached data if available and valid, otherwise undefined.
     * @description
     *   - Cleans up expired cache entries before attempting to return a cached result.
     *   - Logs a message when a cache hit occurs.
     */
    getCachedResult(cacheKey) {
        const now = Date.now();
        // Clean up expired cache
        for (const key in firecrawlCache) {
            if (Object.prototype.hasOwnProperty.call(firecrawlCache, key) &amp;&amp;
                now - firecrawlCache[key].timestamp &gt; FIRECRAWL_CACHE_TTL_MS) {
                delete firecrawlCache[key];
            }
        }
        if (firecrawlCache[cacheKey] != undefined &amp;&amp;
            now - firecrawlCache[cacheKey].timestamp &lt; FIRECRAWL_CACHE_TTL_MS) {
            console.info(`FirecrawlService: Cache hit for ${cacheKey}`);
            return firecrawlCache[cacheKey].data;
        }
        return undefined;
    }
    setCacheResult(cacheKey, data) {
        firecrawlCache[cacheKey] = { data, timestamp: Date.now() };
    }
    /**
    * Fetches and processes content from a specified URL, optionally customizing the output format and content inclusion/exclusion via provided options.
    * @example
    * scrapeUrl('https://example.com', { formats: ['html'], includeTags: ['h1', 'p'] })
    * Returns a FirecrawlResponse object containing the scraped data.
    * @param {string} url - The URL from which content will be scraped.
    * @param {Object} options - Optional parameters to customize the scraping process.
    * @param {(string[]|undefined)} options.formats - Specifies the desired output formats: 'markdown' or 'html'.
    * @param {(string[]|undefined)} options.includeTags - Tags to specifically include in the scraping results.
    * @param {(string[]|undefined)} options.excludeTags - Tags to exclude from the scraping results.
    * @param {(boolean|undefined)} options.onlyMainContent - If true, extracts only the main content from the URL.
    * @param {(number|undefined)} options.waitFor - Time in milliseconds to wait before starting the scraping process.
    * @returns {Promise&lt;FirecrawlResponse&gt;} A promise resolving to a FirecrawlResponse containing either the successful scraping results or error details.
    * @description
    *   - Utilizes caching to store and retrieve previously fetched data to minimize repeated requests.
    *   - Sends API requests with authentication headers using the instance's API key.
    *   - Handles errors gracefully, returning a descriptive error message if the scraping process fails.
    */
    async scrapeUrl(url, options = {}) {
        const cacheKey = `scrape:${url}:${JSON.stringify(options)}`;
        const cached = this.getCachedResult(cacheKey);
        if (cached) {
            return cached;
        }
        try {
            const response = await fetch(`${this.baseUrl}/scrape`, {
                method: 'POST',
                headers: {
                    Authorization: `Bearer ${this.apiKey}`,
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    url,
                    formats: options.formats ?? ['markdown'],
                    includeTags: options.includeTags,
                    excludeTags: options.excludeTags,
                    onlyMainContent: options.onlyMainContent ?? true,
                    waitFor: options.waitFor ?? 0,
                }),
            });
            const data = await response.json();
            if (!response.ok) {
                const errorData = data;
                throw new Error(errorData.error ?? `HTTP ${response.status}`);
            }
            this.setCacheResult(cacheKey, data);
            return data;
        }
        catch (error) {
            console.warn('Firecrawl scrape error:', error);
            return {
                success: false,
                error: error instanceof Error ? error.message : 'Unknown error',
            };
        }
    }
    /**
     * Initiates a web crawling process for a specified URL with given options.
     * @example
     * crawlWebsite('https://example.com', { crawlerOptions: { includes: ['.html'] }, pageOptions: { formats: ['markdown'] } })
     * // Returns a promise that resolves to a CrawlJobResponse object
     * @param {string} url - The URL of the website to be crawled.
     * @param {Object} options - Configuration options for the crawling process.
     * @param {Object} [options.crawlerOptions] - Specific options for controlling the crawler behavior.
     * @param {string[]} [options.crawlerOptions.includes] - List of patterns to include in the crawl.
     * @param {string[]} [options.crawlerOptions.excludes] - List of patterns to exclude from the crawl.
     * @param {number} [options.crawlerOptions.maxDepth] - Maximum depth the crawler should reach.
     * @param {number} [options.crawlerOptions.limit] - Limit to the number of pages to crawl.
     * @param {Object} [options.pageOptions] - Options for the page content format and selection.
     * @param {string[]} [options.pageOptions.formats] - Desired formats for the crawled page content.
     * @param {boolean} [options.pageOptions.onlyMainContent] - Whether to include only the main content of the pages.
     * @returns {Promise&lt;CrawlJobResponse&gt;} A promise that resolves with the results of the crawl job including success and potential errors.
     * @description
     *   - Performs a POST request to the Firecrawl service to crawl pages.
     *   - Uses caching to avoid redundant web crawling operations.
     *   - Handles errors gracefully, returning an appropriate error message if the fetch operation fails.
     *   - Crawls with default options which include markdown format and filtering for main content.
     */
    async crawlWebsite(url, options = {}) {
        const cacheKey = `crawl:${url}:${JSON.stringify(options)}`;
        const cached = this.getCachedResult(cacheKey);
        if (cached) {
            return cached;
        }
        try {
            const response = await fetch(`${this.baseUrl}/crawl`, {
                method: 'POST',
                headers: {
                    Authorization: `Bearer ${this.apiKey}`,
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    url,
                    crawlerOptions: {
                        maxDepth: 2,
                        limit: 10,
                        ...options.crawlerOptions,
                    },
                    pageOptions: {
                        formats: ['markdown'],
                        onlyMainContent: true,
                        ...options.pageOptions,
                    },
                }),
            });
            const data = await response.json();
            if (!response.ok) {
                const errorData = data;
                throw new Error(errorData.error ?? `HTTP ${response.status}`);
            }
            this.setCacheResult(cacheKey, data);
            return data;
        }
        catch (error) {
            console.warn('Firecrawl crawl error:', error);
            return {
                success: false,
                error: error instanceof Error ? error.message : 'Unknown error',
            };
        }
    }
    /**
     * Retrieves the crawl status for a given job by its ID.
     * @example
     * getCrawlStatus('12345')
     * { success: true, status: 'completed' }
     * @param {string} jobId - The ID of the job for which the crawl status is requested.
     * @returns {Promise&lt;CrawlStatusResponse&gt;} Resolves to a `CrawlStatusResponse` object containing the crawl status or an error.
     * @description
     *   - Attempts to retrieve the crawl status from a cache before making an HTTP request.
     *   - Fetches crawl status using an authenticated request to the API.
     *   - Caches the crawl status response data to minimize redundant network calls.
     *   - Handles errors gracefully, returning a standardized error response.
     */
    async getCrawlStatus(jobId) {
        const cacheKey = `crawlStatus:${jobId}`;
        const cached = this.getCachedResult(cacheKey);
        if (cached) {
            return cached;
        }
        try {
            const response = await fetch(`${this.baseUrl}/crawl/status/${jobId}`, {
                headers: {
                    Authorization: `Bearer ${this.apiKey}`,
                },
            });
            const data = await response.json();
            if (!response.ok) {
                const errorData = data;
                throw new Error(errorData.error ?? `HTTP ${response.status}`);
            }
            this.setCacheResult(cacheKey, data);
            return data;
        }
        catch (error) {
            console.warn('Firecrawl status error:', error);
            return {
                success: false,
                error: error instanceof Error ? error.message : 'Unknown error',
            };
        }
    }
    // Specialized methods for food truck data
    /**
     * Scrapes a food truck website and retrieves its main content in markdown format.
     * @example
     * scrapeFoodTruckWebsite('https://example.com/food-truck')
     * // Returns: Promise&lt;{ success: true, data: { markdown: '...', name: 'Example Food Truck', source_url: 'https://example.com/food-truck' } }&gt;
     * @param {string} url - The URL of the food truck website to scrape.
     * @returns {Promise&lt;{ success: boolean, data?: { markdown: string, name?: string, source_url?: string }, error?: string }&gt;} The result of the scrape operation, including markdown content and metadata if successful, or an error message if not.
     * @description
     *   - Configured to wait 2000 milliseconds to ensure all content is loaded.
     *   - Uses 'markdown' format for content extraction to maintain text structure.
     *   - Extracts metadata such as the title and source URL if available.
     */
    async scrapeFoodTruckWebsite(url) {
        const result = await this.scrapeUrl(url, {
            formats: ['markdown'],
            onlyMainContent: true,
            waitFor: 2000,
        });
        return result.success &amp;&amp; result.data?.markdown != undefined
            ? {
                success: true,
                data: {
                    markdown: result.data.markdown,
                    name: result.data.metadata?.title,
                    source_url: result.data.metadata?.sourceURL,
                },
            }
            : { success: false, error: result.error ?? 'Markdown content not found' };
    }
    extractPattern(text, pattern) {
        const match = pattern.exec(text);
        return match ? match[1].trim() : undefined;
    }
    /**
    * Extracts a menu section from a given markdown string based on specific keywords.
    * @example
    * extractMenuSection(&quot;menu: Pizza, Pasta, Salad&quot;)
    * // Returns &quot;Pizza, Pasta, Salad&quot;
    * @param {string} markdown - The markdown string to search for menu-related content.
    * @returns {string | undefined} The extracted menu section if found, otherwise undefined.
    * @description
    *   - Searches for menu-related phrases like &quot;menu&quot;, &quot;food&quot;, &quot;items&quot; up to a maximum of 50 characters.
    *   - Implements case-insensitive search patterns.
    *   - Returns the portion of the markdown line following the specific keywords.
    */
    extractMenuSection(markdown) {
        // Use simpler, more efficient regex patterns with fixed max length
        const menuPatterns = [
            /menu\s*:\s*([^\n]{1,50})/i,
            /food\s*:\s*([^\n]{1,50})/i,
            /items?\s*:\s*([^\n]{1,50})/i,
            /what we serve\s*:\s*([^\n]{1,50})/i,
            /our food\s*:\s*([^\n]{1,50})/i,
        ];
        for (const pattern of menuPatterns) {
            const match = pattern.exec(markdown);
            if (match) {
                return match[1].trim();
            }
        }
        return undefined;
    }
    /**
     * Extracts phone and email contact information from a markdown string.
     * @example
     * extractContactInfo(&quot;Contact: +123-456-7890, email: example@test.com&quot;)
     * { phone: &quot;+123-456-7890&quot;, email: &quot;example@test.com&quot; }
     * @param {string} markdown - A markdown string potentially containing contact information.
     * @returns {ContactInfo | undefined} An object containing extracted phone and email, or undefined if none are found.
     * @description
     *   - Utilizes regular expressions to identify phone numbers and email addresses within the markdown.
     *   - Returns an object only when at least one type of contact information is successfully extracted.
     */
    extractContactInfo(markdown) {
        const contact = {}; // Phone number - Use specific patterns to prevent backtracking
        const phoneRegex = /(?:phone|call|contact)(?:\s*:\s*)?([+]?\d{3,4}[.\s-]\d{3}[.\s-]\d{3,4})/i;
        const phoneMatch = phoneRegex.exec(markdown);
        if (phoneMatch) {
            contact.phone = phoneMatch[1].trim();
        } // Email - Use specific pattern to avoid backtracking
        const emailRegex = /([a-zA-Z0-9._%-]{1,64}@[a-zA-Z0-9-]{1,63}\.[a-zA-Z]{2,6})/;
        const emailMatch = emailRegex.exec(markdown);
        if (emailMatch) {
            contact.email = emailMatch[1].trim();
        }
        return Object.keys(contact).length &gt; 0 ? contact : undefined;
    }
    /**
    * Extracts social media profile names from a given markdown string.
    * @example
    * extractSocialMedia(&quot;@john_doe instagram.com/jane Facebook.com/joe&quot;)
    * { instagram: 'john_doe', facebook: 'jane', twitter: 'joe' }
    * @param {string} markdown - A string containing markdown text to parse for social media information.
    * @returns {SocialMediaInfo | undefined} An object containing social media profiles if any are found, otherwise undefined.
    * @description
    *   - Supports extracting profiles for Instagram, Facebook, and Twitter.
    *   - Uses regular expressions to match social media patterns.
    *   - Returns the trimmed username of identified social media profiles.
    *   - Returns undefined if no social media profiles are found in the input.
    */
    extractSocialMedia(markdown) {
        const social = {};
        // Instagram - Use concise character class
        const instagramRegex = /(?:instagram|@)\s*([\w.]+)/i;
        const instagramMatch = instagramRegex.exec(markdown);
        if (instagramMatch) {
            social.instagram = instagramMatch[1].trim();
        }
        // Facebook - With fixed character class
        const facebookRegex = /facebook\.com\/([\w.-]+)/i;
        const facebookMatch = facebookRegex.exec(markdown);
        if (facebookMatch) {
            social.facebook = facebookMatch[1].trim();
        }
        // Twitter - Use concise character class
        const twitterRegex = /(?:twitter|@)\s*([\w.]+)/i; // Changed \w+ to [\w.]+ to allow dots in usernames
        const twitterMatch = twitterRegex.exec(markdown);
        if (twitterMatch) {
            social.twitter = twitterMatch[1].trim();
        }
        return Object.keys(social).length &gt; 0 ? social : undefined;
    }
    /**
     * Performs web scraping on multiple URLs with batching and delay options.
     * @example
     * scrapeMultipleUrls(['http://example.com', 'http://another.com'], { batchSize: 2, delay: 1500 })
     * Returns: Promise resolving to an array containing the results of the scraped URLs.
     * @param {string[]} urls - Array of URLs to be scraped.
     * @param {Object} options - Options object for configuring the scraping process.
     * @param {number} [options.batchSize=5] - Size of each batch in which URLs are processed.
     * @param {number} [options.delay=1000] - Delay between processing each batch in milliseconds.
     * @returns {Promise&lt;Array&lt;{ url: string; result: FirecrawlResponse }&gt;&gt;} Promise resolving to an array of objects, each containing a URL and its corresponding scrape result.
     * @description
     *   - Utilizes a batch mechanism to efficiently handle large sets of URLs.
     *   - Incorporates a delay between batches to comply with potential rate limits.
     */
    async scrapeMultipleUrls(urls, options = {}) {
        const batchSize = options.batchSize ?? 5;
        const delay = options.delay ?? 1000;
        const results = [];
        for (let i = 0; i &lt; urls.length; i += batchSize) {
            const batch = urls.slice(i, i + batchSize);
            const batchPromises = batch.map(async (url) =&gt; {
                const result = await this.scrapeUrl(url);
                return { url, result };
            });
            const batchResults = await Promise.all(batchPromises);
            results.push(...batchResults);
            // Add delay between batches to respect rate limits
            if (i + batchSize &lt; urls.length) {
                await new Promise((resolve) =&gt; { setTimeout(resolve, delay); });
            }
        }
        return results;
    }
    // Rate limiting and error handling
    /**
     * Attempts to scrape content from a given URL with retries in case of failure.
     * @example
     * scrapeWithRetry('https://example.com', 3, 1000)
     * { success: true, data: {...} }
     * @param {string} url - The URL to scrape.
     * @param {number} maxRetries - Maximum number of retry attempts. Defaults to 3.
     * @param {number} backoffMs - Initial wait time before retrying in milliseconds. Defaults to 1000ms.
     * @returns {Promise&lt;FirecrawlResponse&gt;} Promise resolving to a FirecrawlResponse object indicating success or failure.
     * @description
     *   - Implements exponential backoff strategy for rate limit errors.
     *   - Logs attempt details and waiting times between retries.
     *   - Returns last error message if all retry attempts fail.
     */
    async scrapeWithRetry(url, maxRetries = 3, backoffMs = 1000) {
        let lastError;
        for (let attempt = 1; attempt &lt;= maxRetries; attempt += 1) {
            try {
                const result = await this.scrapeUrl(url);
                if (result.success) {
                    return result;
                }
                // If it's a rate limit error, wait longer
                if (result.error?.includes('rate limit') === true) {
                    const waitTime = backoffMs * 2 ** attempt;
                    console.info(`Rate limited. Waiting ${waitTime}ms before retry ${attempt}/${maxRetries}`);
                    await new Promise((resolve) =&gt; { setTimeout(resolve, waitTime); });
                    continue;
                }
                throw new Error(result.error);
            }
            catch (error) {
                lastError = error instanceof Error ? error : new Error(String(error));
                if (attempt === maxRetries) {
                    break;
                }
                const waitTime = backoffMs * 2 ** attempt;
                console.info(`Attempt ${attempt} failed. Retrying in ${waitTime}ms...`);
                await new Promise((resolve) =&gt; { setTimeout(resolve, waitTime); });
            }
        }
        return {
            success: false,
            error: lastError.message,
        };
    }
}
// Export singleton instance
export const firecrawl = new FirecrawlService();</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/lib/discoveryEngine.js (Line 3:14 - Line 723:2), C:/AI/food-truck-finder-poc/dist/lib/lib/discoveryEngine.js (Line 3:11 - Line 723:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn493" onclick="toggleCodeBlock('cloneGroup493', 'expandBtn493', 'collapseBtn493')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn493" onclick="toggleCodeBlock('cloneGroup493', 'expandBtn493', 'collapseBtn493')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup493"><code class="language-javascript text-sm text-gray-800">;
/**
* Executes a search request against the Tavily API.
* @example
* tavilySearch('example query', { limit: 5 })
* // returns array of TavilySearchResult objects
* @param {string} query - The search query string.
* @param {Record&lt;string, unknown&gt;} options - Optional configurations such as 'limit' to restrict the number of results.
* @returns {Promise&lt;TavilySearchResult[]&gt;} Promise resolving to an array of search results.
* @description
*   - Defaults to 10 results if 'limit' is not specified in options.
*   - Throws an error if the API response is not successful.
*   - Combines 'query' and other options into a request payload.
*   - Uses environment variable NEXT_PUBLIC_APP_URL for base URL, or defaults to 'http://localhost:3003'.
*/
async function tavilySearch(query, options = {}) {
    const baseUrl = process.env.NEXT_PUBLIC_APP_URL ?? 'http://localhost:3003';
    const response = await fetch(`${baseUrl}/api/tavily`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
            operation: 'search',
            params: {
                query,
                limit: options.limit ?? 10,
                ...options,
            },
        }),
    });
    if (!response.ok) {
        throw new Error(`Tavily search failed: ${response.statusText}`);
    }
    const result = (await response.json());
    return result.data?.results ?? result.results ?? [];
}
/**
* Initiates a web crawling operation asynchronously via Firecrawl API and returns the resulting data.
* @example
* firecrawlCrawl('https://example.com', { maxDepth: 3, limit: 50 })
* // Returns a Promise resolving to an array of CrawlResult objects.
* @param {string} url - The URL of the website to initiate the crawl.
* @param {Record&lt;string, unknown&gt;} options - Optional parameters to customize the crawling operation. Default values are maxDepth: 2 and limit: 20.
* @returns {Promise&lt;CrawlResult[]&gt;} Promise resolving to an array of resulting data from the crawl operation.
* @description
*   - Utilizes server URL from environment variable NEXT_PUBLIC_APP_URL or defaults to 'http://localhost:3003'.
*   - Sends a POST request to the '/api/firecrawl' endpoint with specified crawl operation settings.
*   - Throws an error if the HTTP response status is not OK indicating a failure in the crawl operation.
*/
async function firecrawlCrawl(url, options = {}) {
    const baseUrl = process.env.NEXT_PUBLIC_APP_URL ?? 'http://localhost:3003';
    const response = await fetch(`${baseUrl}/api/firecrawl`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
            operation: 'crawl',
            url,
            options: {
                maxDepth: options.maxDepth ?? 2,
                limit: options.limit ?? 20,
                ...options,
            },
        }),
    });
    if (!response.ok) {
        throw new Error(`Firecrawl crawl failed: ${response.statusText}`);
    }
    const result = (await response.json());
    return result.data ?? [];
}
export class FoodTruckDiscoveryEngine {
    searchTerms = [
        'food truck South Carolina',
        'mobile food vendor SC',
        'food truck Charleston',
        'food truck Columbia SC',
        'food truck Greenville SC',
        'street food South Carolina',
        'food truck directory SC',
    ];
    directoryUrls = [
        'https://www.foodtrucksin.com/south-carolina',
        'https://www.roaminghunger.com/sc/',
        'https://southcarolinafoodtrucks.com',
        'https://www.yelp.com/sc/food-trucks',
    ];
    // Helper method to process search results
    /**
     * Processes search results to discover and store food truck URLs.
     * @example
     * processSearchResults([{ url: 'http://example.com', content: '...' }], new Set())
     * // No return value; `discoveredUrls` will contain food truck URLs.
     * @param {TavilySearchResult[]} searchResults - An array of search result objects each possibly containing a URL and content.
     * @param {Set&lt;string&gt;} discoveredUrls - A set to store discovered food truck URLs.
     * @returns {Promise&lt;void&gt;} No return value; operates by modifying the `discoveredUrls` set.
     * @description
     *   - URLs are checked for validity as food truck URLs before being added to the set.
     *   - Extracts URLs from either the `content` or `raw_content` fields.
     *   - Uses asynchronous URL validation.
     */
    async processSearchResults(searchResults, discoveredUrls) {
        for (const result of searchResults) {
            if (result.url &amp;&amp; (await this.isFoodTruckUrl(result.url))) {
                discoveredUrls.add(result.url);
            }
            // Extract URLs from content
            if (result.content != undefined || result.raw_content != undefined) {
                const content = result.content ?? result.raw_content ?? '';
                const extractedUrls = this.extractFoodTruckUrls(content);
                for (const url of extractedUrls) {
                    if (await this.isFoodTruckUrl(url)) {
                        discoveredUrls.add(url);
                    }
                }
            }
        }
    }
    // Helper method to perform search term discovery
    /**
     * Performs search term discovery using the specified search terms.
     * @example
     * performSearchTermDiscovery(new Set(), discoveryResult)
     * No specific return value, performs actions on `discoveredUrls` and `results`.
     * @param {Set&lt;string&gt;} discoveredUrls - A set to store discovered URLs that have been processed.
     * @param {DiscoveryResult} results - An object to accumulate results and errors stemming from the discovery process.
     * @returns {Promise&lt;void&gt;} Returns a promise that resolves when search term discovery is complete.
     * @description
     *   - Utilizes a search function `tavilySearch` to find results based on search terms.
     *   - Incorporates error handling and logs errors to `results.errors`.
     *   - Implements rate limiting by delaying subsequent searches using `DISCOVERY_CONFIG.rateLimitDelayMs`.
     *   - Processes search results using the `processSearchResults` method if valid results are found.
     */
    async performSearchTermDiscovery(discoveredUrls, results) {
        for (const searchTerm of this.searchTerms) {
            try {
                console.info(` Searching for: ${searchTerm}`);
                const searchResults = await tavilySearch(searchTerm, {
                    limit: DISCOVERY_CONFIG.searchResultsLimit,
                });
                if (searchResults != undefined &amp;&amp; searchResults.length &gt; 0) {
                    await this.processSearchResults(searchResults, discoveredUrls);
                }
            }
            catch (error) {
                console.error(` Search failed for &quot;${searchTerm}&quot;:`, error);
                results.errors.push(`Search failed for &quot;${searchTerm}&quot;: ${error instanceof Error ? error.message : 'Unknown error'}`);
            }
            await this.delay(DISCOVERY_CONFIG.rateLimitDelayMs);
        }
    }
    // Helper method to perform directory crawling
    async performDirectoryCrawling(discoveredUrls, results) {
        for (const directoryUrl of this.directoryUrls) {
            await this.crawlSingleDirectory(directoryUrl, discoveredUrls, results);
            await this.delay(DISCOVERY_CONFIG.rateLimitDelayMs);
        }
    }
    // Helper method to crawl a single directory
    /**
     * Crawls a single directory and processes discovered URLs.
     * @example
     * crawlSingleDirectory('http://example.com', new Set(), resultsInstance)
     * void
     * @param {string} directoryUrl - The URL of the directory to be crawled.
     * @param {Set&lt;string&gt;} discoveredUrls - A set to store URLs discovered during the crawl.
     * @param {DiscoveryResult} results - An object to store the results and errors of the crawl process.
     * @returns {Promise&lt;void&gt;} Resolves when crawl and processing are complete.
     * @description
     *   - Uses a third-party library, `firecrawlCrawl`, for the crawling operation.
     *   - Handles errors by logging and storing error messages in the results object.
     *   - Limits the depth and number of URLs explored based on configuration.
     */
    async crawlSingleDirectory(directoryUrl, discoveredUrls, results) {
        try {
            console.info(` Crawling directory: ${directoryUrl}`);
            const crawlResults = await firecrawlCrawl(directoryUrl, {
                maxDepth: DISCOVERY_CONFIG.maxDepthCrawl,
                limit: DISCOVERY_CONFIG.maxUrlsPerRun,
            });
            await this.processCrawlResults(crawlResults, discoveredUrls);
        }
        catch (error) {
            console.error(` Crawl failed for ${directoryUrl}:`, error);
            results.errors.push(`Crawl failed for ${directoryUrl}: ${error instanceof Error ? error.message : 'Unknown error'}`);
        }
    }
    // Helper method to process crawl results
    /**
     * Processes the results from a web crawl and adds discovered URLs to a set if they meet certain criteria.
     * @example
     * processCrawlResults(crawlResults, discoveredUrls)
     * // adds qualifying URLs to the discoveredUrls set
     * @param {unknown} crawlResults - The results obtained from the crawling operation.
     * @param {Set&lt;string&gt;} discoveredUrls - A set to store URLs discovered during processing.
     * @returns {Promise&lt;void&gt;}
     * @description
     *   - Only accepts results that are valid non-empty arrays.
     *   - Checks each item to ensure it's an object containing a 'url' property.
     *   - Uses a helper function isFoodTruckUrl to decide if a URL should be added to the set.
     */
    async processCrawlResults(crawlResults, discoveredUrls) {
        if (crawlResults != undefined &amp;&amp; Array.isArray(crawlResults) &amp;&amp; crawlResults.length &gt; 0) {
            for (const result of crawlResults) {
                if (typeof result === 'object' &amp;&amp; result !== null &amp;&amp; 'url' in result) {
                    const resultUrl = result.url;
                    if (resultUrl != undefined &amp;&amp;
                        typeof resultUrl === 'string' &amp;&amp;
                        (await this.isFoodTruckUrl(resultUrl))) {
                        discoveredUrls.add(resultUrl);
                    }
                }
            }
        }
    }
    // Helper method to perform location-specific discovery
    async performLocationDiscovery(discoveredUrls, results) {
        for (const city of SC_TARGET_CITIES) {
            await this.searchSingleCity(city, discoveredUrls, results);
            await this.delay(DISCOVERY_CONFIG.rateLimitDelayMs);
        }
    }
    // Helper method to search a single city
    /**
    * Initiates a search for food trucks within a specified city in South Carolina.
    * @example
    * searchSingleCity(&quot;Charleston&quot;, discoveredUrls, results)
    * // Returns undefined but processes the data internally and updates results object.
    * @param {string} city - The name of the city where food trucks are to be searched.
    * @param {Set&lt;string&gt;} discoveredUrls - A Set to keep track of URLs that have been discovered during the search.
    * @param {DiscoveryResult} results - Object to store errors and possibly other results related to the discovery process.
    * @returns {Promise&lt;void&gt;} Resolves after processing the search results.
    * @description
    *   - Uses `tavilySearch` function to perform the location-based search with a limit of 5 results.
    *   - Handles errors by logging them and updating the results object with error messages.
    *   - Assumes South Carolina as the default state for city searches.
    */
    async searchSingleCity(city, discoveredUrls, results) {
        try {
            console.info(` Searching for food trucks in ${city}, SC`);
            const locationQuery = `food trucks in ${city} South Carolina`;
            const searchResults = await tavilySearch(locationQuery, {
                limit: 5,
            });
            await this.processLocationSearchResults(searchResults, discoveredUrls);
        }
        catch (error) {
            console.error(` Location search failed for ${city}:`, error);
            results.errors.push(`Location search failed for ${city}: ${error instanceof Error ? error.message : 'Unknown error'}`);
        }
    }
    // Helper method to process location search results
    /**
     * Processes search results to discover specific URLs and add them to a set.
     * @example
     * processLocationSearchResults(searchResults, discoveredUrls);
     * // The set discoveredUrls will be populated with food truck URLs from searchResults
     * @param {unknown} searchResults - Array of search result objects potentially containing URLs.
     * @param {Set&lt;string&gt;} discoveredUrls - Set used to collect discovered food truck URLs.
     * @returns {Promise&lt;void&gt;} Resolves when all URLs are processed and added to the set.
     * @description
     *   - Ensures the searchResults contain an array of objects with valid URL properties.
     *   - Filters URLs through isFoodTruckUrl method before adding them to discoveredUrls.
     */
    async processLocationSearchResults(searchResults, discoveredUrls) {
        if (searchResults != undefined &amp;&amp; Array.isArray(searchResults) &amp;&amp; searchResults.length &gt; 0) {
            for (const result of searchResults) {
                if (typeof result === 'object' &amp;&amp; result !== null &amp;&amp; 'url' in result) {
                    const resultUrl = result.url;
                    if (resultUrl != undefined &amp;&amp;
                        typeof resultUrl === 'string' &amp;&amp;
                        (await this.isFoodTruckUrl(resultUrl))) {
                        discoveredUrls.add(resultUrl);
                    }
                }
            }
        }
    }
    // Helper method to store discovered URLs from discovery process
    /**
     * Stores a set of discovered URLs from a discovery process into a database.
     * @example
     * storeDiscoveredUrlsFromDiscovery(new Set(['http://example.com', 'http://example.org']), discoveryResult)
     * // No return value (undefined).
     * @param {Set&lt;string&gt;} discoveredUrls - A set of URLs that have been discovered and need to be stored.
     * @param {DiscoveryResult} results - An object to track and accumulate errors encountered during storage.
     * @returns {Promise&lt;void&gt;} Resolves when all URLs are processed and stored.
     * @description
     *   - This function iterates over a set of URLs and stores each individually.
     *   - Errors encountered during the storage process are logged and appended to the provided results object.
     *   - Utilizes an asynchronous operation to store URLs and handle potential failures gracefully.
     */
    async storeDiscoveredUrlsFromDiscovery(discoveredUrls, results) {
        for (const url of discoveredUrls) {
            try {
                const stored = await this.storeDiscoveredUrl(url, 'autonomous_search', {
                    search_context: 'full_discovery',
                    discovery_timestamp: new Date().toISOString(),
                });
                if (stored.isNew === true) {
                    results.urls_stored += 1;
                }
                else {
                    results.urls_duplicates += 1;
                }
            }
            catch (error) {
                console.error(` Failed to store URL ${url}:`, error);
                results.errors.push(`Failed to store URL ${url}: ${error instanceof Error ? error.message : 'Unknown error'}`);
            }
        }
    }
    /**
    * Initiates autonomous discovery of new food truck URLs.
    * @example
    * discoverNewFoodTrucks()
    * Returns a Promise resolving to a DiscoveryResult object.
    * @param {none} No parameters required.
    * @returns {Promise&lt;DiscoveryResult&gt;} An object containing the counts of discovered, stored, and duplicate URLs and any errors encountered.
    * @description
    *   - Utilizes multiple discovery methods: search term, directory crawling, and location-specific search.
    *   - Aggregates discovered URLs in a Set to ensure uniqueness.
    *   - Logs informative messages regarding the discovery and storage process.
    *   - Handles the storage of newly discovered URLs and logs duplicates.
    */
    async discoverNewFoodTrucks() {
        console.info(' Starting autonomous food truck discovery...');
        const results = {
            urls_discovered: 0,
            urls_stored: 0,
            urls_duplicates: 0,
            errors: [],
        };
        const discoveredUrls = new Set();
        // 1. Search for food trucks using Tavily search
        await this.performSearchTermDiscovery(discoveredUrls, results);
        // 2. Crawl known food truck directory sites
        await this.performDirectoryCrawling(discoveredUrls, results);
        // 3. Location-specific discovery for SC cities
        await this.performLocationDiscovery(discoveredUrls, results);
        results.urls_discovered = discoveredUrls.size;
        console.info(` Discovered ${results.urls_discovered} potential food truck URLs`);
        // 4. Store new URLs in database
        await this.storeDiscoveredUrlsFromDiscovery(discoveredUrls, results);
        console.info(` Discovery complete: ${results.urls_stored} new URLs stored, ${results.urls_duplicates} duplicates skipped`);
        return results;
    }
    /**
     * Extracts valid URLs from a given string content.
     * @example
     * extractFoodTruckUrls(&quot;Check out these two links: https://foodtrucklink.com/menu, and https://anotherlink.com!&quot;)
     * [&quot;https://foodtrucklink.com/menu&quot;, &quot;https://anotherlink.com&quot;]
     * @param {string} content - The textual content from which URLs are extracted.
     * @returns {string[]} An array of valid URLs extracted from the content.
     * @description
     *   - Utilizes a regular expression pattern to identify potential URLs.
     *   - Performs basic URL validation using the URL constructor.
     *   - Cleans up URLs by removing trailing punctuation such as periods, commas, semicolons, etc.
     *   - Skips invalid URLs identified during the validation process.
     */
    extractFoodTruckUrls(content) {
        const urls = [];
        // Look for URL patterns in content - using a safer regex to avoid backtracking
        const urlRegex = /https?:\/\/[^\s&lt;&gt;&quot;']{1,200}/g;
        const foundUrls = content.match(urlRegex) ?? [];
        for (const url of foundUrls) {
            try {
                // Basic URL validation
                new URL(url);
                // Remove trailing punctuation - using safer regex to avoid backtracking
                const cleanUrl = url.replace(/[.,;!?]$/, '');
                urls.push(cleanUrl);
            }
            catch {
                // Invalid URL, skip
                continue;
            }
        }
        return urls;
    }
    /**
     * Checks if a given URL is related to a food truck.
     * @example
     * isFoodTruckUrl(&quot;https://bestfoodtruck.com&quot;)
     * true
     * @param {string} url - The URL to validate and check against known food truck patterns.
     * @returns {Promise&lt;boolean&gt;} True if the URL is likely related to a food truck, false otherwise.
     * @description
     *   - Uses keyword matching to detect food truck-related URLs.
     *   - Excludes common social media and review domains via blacklist.
     *   - Validates if the URL is already present in `discovered_urls` or `food_trucks` database.
     *   - Accepts common business domains not typically associated with blogs or news sites.
     */
    async isFoodTruckUrl(url) {
        try {
            // Basic URL validation
            new URL(url);
            // Food truck indicators in URL
            const foodTruckKeywords = [
                'food-truck',
                'foodtruck',
                'mobile-food',
                'street-food',
                'truck',
                'kitchen',
                'eats',
                'bbq',
                'burger',
                'taco',
                'catering',
                'mobile',
                'chef',
                'bistro',
                'cafe',
            ];
            // Blacklist - skip these domains
            const blacklistKeywords = [
                'facebook.com',
                'instagram.com',
                'twitter.com',
                'linkedin.com',
                'youtube.com',
                'yelp.com',
                'google.com',
                'maps.google.com',
                'foursquare.com',
                'tripadvisor.com',
                'zomato.com',
                'eventbrite.com',
                'meetup.com',
            ];
            const urlLower = url.toLowerCase();
            // Skip social media and review sites
            if (blacklistKeywords.some((keyword) =&gt; urlLower.includes(keyword))) {
                return false;
            }
            // Check if we already have this URL in discovered_urls
            if (supabaseAdmin == undefined) {
                return false;
            }
            const { data: existingDiscovered } = await supabaseAdmin
                .from('discovered_urls')
                .select('id')
                .eq('url', url)
                .limit(1);
            if (existingDiscovered != undefined &amp;&amp; existingDiscovered.length &gt; 0) {
                return false; // Already discovered
            }
            // Check if we already have this URL in food_trucks
            const { data: existingTrucks } = await supabaseAdmin
                .from('food_trucks')
                .select('id')
                .contains('source_urls', [url])
                .limit(1);
            if (existingTrucks != undefined &amp;&amp; existingTrucks.length &gt; 0) {
                return false; // Already have this URL
            }
            // Accept if has food truck keywords or if it's a business domain
            return (foodTruckKeywords.some((keyword) =&gt; urlLower.includes(keyword)) ||
                (/\.(com|net|org|biz|info)/.test(urlLower) &amp;&amp;
                    !urlLower.includes('blog') &amp;&amp;
                    !urlLower.includes('news')));
        }
        catch (error) {
            console.error('Error validating food truck URL:', error);
            return false;
        }
    }
    /**
     * Initiates a discovery process for food trucks in the specified city and state.
     * @example
     * getLocationSpecificDiscovery('Charleston', 'SC')
     * Promise &lt;DiscoveryResult&gt; {urls_discovered: 5, urls_stored: 4, urls_duplicates: 1, errors: []}
     * @param {string} city - The city where the search is to be performed.
     * @param {string} [state='SC'] - The state where the search is to be performed; defaults to 'SC'.
     * @returns {Promise&lt;DiscoveryResult&gt;} An object containing the discovery results and any errors encountered.
     * @description
     *   - Logs the initiation and completion of the discovery process with results.
     *   - Performs the search using a specified query and stores new URLs found.
     *   - Captures and logs any errors encountered during the search process.
     */
    async getLocationSpecificDiscovery(city, state = 'SC') {
        console.info(` Starting location-specific discovery for ${city}, ${state}`);
        const locationQuery = `food trucks in ${city} ${state}`;
        const results = {
            urls_discovered: 0,
            urls_stored: 0,
            urls_duplicates: 0,
            errors: [],
        };
        const discoveredUrls = new Set();
        try {
            await this.performLocationSpecificSearch(locationQuery, discoveredUrls);
            results.urls_discovered = discoveredUrls.size;
            await this.storeLocationDiscoveryResults({
                discoveredUrls,
                locationQuery,
                city,
                state,
                results,
            });
        }
        catch (error) {
            console.error(` Location search failed for ${city}:`, error);
            results.errors.push(`Location search failed for ${city}: ${error instanceof Error ? error.message : 'Unknown error'}`);
        }
        console.info(` Location discovery complete for ${city}: ${results.urls_stored} new URLs stored`);
        return results;
    }
    // Helper method to perform location-specific search
    /**
    * Executes a location-specific search and processes the results.
    * @example
    * performLocationSpecificSearch(&quot;San Francisco&quot;, new Set())
    * // Processes search results for &quot;San Francisco&quot; location
    * @param {string} locationQuery - The location query to perform the search.
    * @param {Set&lt;string&gt;} discoveredUrls - A set to track URLs that have already been discovered.
    * @returns {Promise&lt;void&gt;} Completes search processing without return value.
    * @description
    *   - Searches are performed with a limit of 15 results.
    *   - Only non-empty search results are processed.
    *   - Uses asynchronous calls to handle search and processing operations.
    */
    async performLocationSpecificSearch(locationQuery, discoveredUrls) {
        const searchResults = await tavilySearch(locationQuery, { limit: 15 });
        if (searchResults != undefined &amp;&amp; searchResults.length &gt; 0) {
            for (const result of searchResults) {
                await this.processSearchResult(result, discoveredUrls);
            }
        }
    }
    // Helper method to process a single search result
    async processSearchResult(result, discoveredUrls) {
        if (typeof result === 'object' &amp;&amp; result !== null &amp;&amp; 'url' in result) {
            const resultUrl = result.url;
            if (resultUrl != undefined &amp;&amp; resultUrl !== '' &amp;&amp; (await this.isFoodTruckUrl(resultUrl))) {
                discoveredUrls.add(resultUrl);
            }
            // Extract URLs from content
            await this.extractUrlsFromContent(result, discoveredUrls);
        }
    }
    // Helper method to extract URLs from content
    /**
     * Extracts food truck URLs from a given result object and adds them to a discovered URL set.
     * @example
     * extractUrlsFromContent(resultObject, discoveredUrlSet)
     * void
     * @param {unknown} result - The result object potentially containing content with URLs.
     * @param {Set&lt;string&gt;} discoveredUrls - A set where extracted food truck URLs will be added.
     * @returns {Promise&lt;void&gt;} Resolves when URLs are added to the set.
     * @description
     *   - Parses both `content` and `raw_content` properties for URLs.
     *   - Uses helper method `extractFoodTruckUrls` to identify specific URLs.
     *   - Filters URLs through `isFoodTruckUrl` method to ensure relevance before adding.
     */
    async extractUrlsFromContent(result, discoveredUrls) {
        if (typeof result === 'object' &amp;&amp; result != undefined) {
            const resultObj = result;
            if (resultObj.content != undefined || resultObj.raw_content != undefined) {
                const content = resultObj.content ?? resultObj.raw_content ?? '';
                const extractedUrls = this.extractFoodTruckUrls(content);
                for (const url of extractedUrls) {
                    if (await this.isFoodTruckUrl(url)) {
                        discoveredUrls.add(url);
                    }
                }
            }
        }
    }
    // Helper method to store location discovery results
    /**
     * Stores location discovery results by iterating through a set of discovered URLs.
     * @example
     * storeLocationDiscoveryResults({
     *   discoveredUrls: new Set(['http://example.com']),
     *   locationQuery: 'pizza restaurant',
     *   city: 'San Francisco',
     *   state: 'CA',
     *   results: {}
     * })
     *
     * @param {Object} params - Parameters for storing the discovery results.
     * @param {Set&lt;string&gt;} params.discoveredUrls - A set of URLs to be stored.
     * @param {string} params.locationQuery - The location query used in the search.
     * @param {string} params.city - The target city for the location search.
     * @param {string} params.state - The target state for the location search.
     * @param {DiscoveryResult} params.results - Object to store results and errors.
     * @returns {Promise&lt;void&gt;} No return value.
     * @description
     *   - Logs an error and records it in the results if storing a URL fails.
     *   - Assumes the existence of a method `storeDiscoveredUrl` to handle storage logic.
     *   - The `results` object is mutated by adding error messages directly.
     */
    async storeLocationDiscoveryResults(params) {
        const { discoveredUrls, locationQuery, city, state, results } = params;
        for (const url of discoveredUrls) {
            try {
                const stored = await this.storeDiscoveredUrl(url, 'tavily_search', {
                    search_query: locationQuery,
                    target_city: city,
                    target_state: state,
                });
                if (stored.isNew === true) {
                    results.urls_stored += 1;
                }
                else {
                    results.urls_duplicates += 1;
                }
            }
            catch (error) {
                console.error(` Failed to store URL ${url}:`, error);
                results.errors.push(`Failed to store URL ${url}: ${error instanceof Error ? error.message : 'Unknown error'}`);
            }
        }
    }
    delay(ms) {
        return new Promise((resolve) =&gt; setTimeout(resolve, ms));
    }
    /**
     * Store multiple discovered URLs with metadata
     */
    async storeDiscoveredUrls(urls, discoveryMethod = 'manual', metadata = {}) {
        const result = {
            urls_stored: 0,
            urls_duplicates: 0,
            errors: [],
        };
        for (const url of urls) {
            try {
                const stored = await this.storeDiscoveredUrl(url, discoveryMethod, metadata);
                if (stored.isNew === true) {
                    result.urls_stored += 1;
                }
                else {
                    result.urls_duplicates += 1;
                }
            }
            catch (error) {
                const errorMsg = `Failed to store URL ${url}: ${error instanceof Error ? error.message : 'Unknown error'}`;
                result.errors.push(errorMsg);
                console.error(errorMsg);
            }
        }
        return result;
    }
    /**
     * Enhanced store method with discovery method and metadata
     */
    async storeDiscoveredUrl(url, discoveryMethod = 'manual', metadata = {}) {
        try {
            if (!supabaseAdmin) {
                throw new Error('Supabase admin client not available');
            }
            // Check if URL already exists
            const { data: existing } = await supabaseAdmin
                .from('discovered_urls')
                .select('id')
                .eq('url', url)
                .limit(1);
            if (existing &amp;&amp; existing.length &gt; 0) {
                return { isNew: false };
            }
            // Store new URL - handle missing columns gracefully
            const insertData = {
                url,
                status: 'new',
                notes: `Discovered via ${discoveryMethod}`,
            };
            // Add optional columns only if they exist in the table
            try {
                // Check if discovery_method column exists
                const { error: testError } = await supabaseAdmin
                    .from('discovered_urls')
                    .select('discovery_method')
                    .limit(1);
                if (!testError) {
                    insertData.discovery_method = discoveryMethod;
                    insertData.region = 'SC';
                    insertData.metadata = metadata;
                }
            }
            catch {
                // Column doesn't exist, continue without it
                console.info('Some columns missing in discovered_urls table, using basic structure');
            }
            const { error } = await supabaseAdmin.from('discovered_urls').insert(insertData);
            if (error) {
                throw error;
            }
            return { isNew: true };
        }
        catch (error) {
            console.error('Error storing discovered URL:', error);
            throw error;
        }
    }
    /**
     * Search for food truck directories
     */
    async searchFoodTruckDirectories(query = 'food truck directory South Carolina') {
        try {
            return await tavilySearch(query, { limit: 10 });
        }
        catch (error) {
            console.error('Error searching food truck directories:', error);
            return [];
        }
    }
    /**
     * Search for food truck websites
     */
    async searchFoodTruckWebsites(query) {
        try {
            return await tavilySearch(query, { limit: 15 });
        }
        catch (error) {
            console.error('Error searching food truck websites:', error);
            return [];
        }
    }
}
export const discoveryEngine = new FoodTruckDiscoveryEngine();</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/lib/config.js (Line 1:1 - Line 31:74), C:/AI/food-truck-finder-poc/dist/lib/lib/config.js (Line 1:1 - Line 31:74)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn496" onclick="toggleCodeBlock('cloneGroup496', 'expandBtn496', 'collapseBtn496')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn496" onclick="toggleCodeBlock('cloneGroup496', 'expandBtn496', 'collapseBtn496')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup496"><code class="language-javascript text-sm text-gray-800">// lib/config.ts
// A list of default URLs that the application should attempt to scrape automatically
// if their data is missing or stale.
export const DEFAULT_SCRAPE_URLS = [
    'https://eatrotirolls.com/',
    // Dynamic URLs will be added from the discovered_urls table
];
// Defines how old data can be (in days) before it's considered stale and needs re-scraping.
export const DEFAULT_STALENESS_THRESHOLD_DAYS = 7; // 7 days
// South Carolina cities to target for autonomous discovery
export const SC_TARGET_CITIES = [
    'Charleston',
    'Columbia',
    'Greenville',
    'Spartanburg',
    'Rock Hill',
    'Mount Pleasant',
    'North Charleston',
    'Summerville',
    'Goose Creek',
    'Hilton Head',
];
// Discovery configuration
export const DISCOVERY_CONFIG = {
    maxUrlsPerRun: 50,
    maxDepthCrawl: 2,
    searchResultsLimit: 15,
    batchSize: 10,
    rateLimitDelayMs: 1000,
};
// You can add other global configurations here as the application grows.</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/lib/autoScraper.js (Line 5:14 - Line 428:2), C:/AI/food-truck-finder-poc/dist/lib/lib/autoScraper.js (Line 5:20 - Line 428:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn498" onclick="toggleCodeBlock('cloneGroup498', 'expandBtn498', 'collapseBtn498')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn498" onclick="toggleCodeBlock('cloneGroup498', 'expandBtn498', 'collapseBtn498')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup498"><code class="language-javascript text-sm text-gray-800">;
/*
Food Truck Scraping Strategy (wbs 2.1.2)
----------------------------------------
Goal: Extract structured data for food trucks (description, menu, prices, locations, events) from web sources.

1. Discovery:
   - Use internal API endpoints that leverage Tavily MCP tools to find food truck directories and individual truck sites.
   - Filter urls to target only likely food truck homepages or menu/schedule pages.

2. Content Extraction:
   - For each truck site, extract:
     - Description: Look for about/landing page text, business summary, or meta description.
     - Menu: Scrape menu sections, parse categories, items, prices, and dietary tags.
     - Prices: Extract explicit prices as numbers; fallback to price range if only text is available.
     - Locations: Parse current and scheduled locations, addresses, and geocoordinates if present.
     - Events: Identify event/calendar/schedule sections for upcoming appearances.

3. Data Mapping:
   - Map extracted fields to Supabase schema:
     - name, description, cuisine_type, specialties
     - menu (categories/items/prices/dietary_tags)
     - current_location, scheduled_locations, exact_location, city_location
     - events (future: event table)

4. Quality &amp; Validation:
   - Use Gemini to summarize/clean descriptions and standardize menu/locations.
   - Validate extracted data types and required fields before db insert.
   - Log and skip/flag incomplete or ambiguous records for review.

5. Ingestion:
   - Upsert into Supabase using unique identifier (e.g., website url or business name).
   - Avoid duplicates and resolve conflicts by preferring most recent or most complete data.

6. Automation:
   - Schedule regular crawls and re-scrapes.
   - Track api usage and cache results to stay within rate limits.
   - Monitor for site changes and trigger updates as needed.
*/
// Helper to trigger a scraping process for a given url
/**
 * Initiates a web scraping process for a given target URL.
 * @example
 * triggerScrapingProcess('https://example.com')
 * { success: true, jobId: '12345', message: 'Scraping job created and processing initiated for https://example.com.' }
 * @param {string} targetUrl - The URL of the website to be scraped.
 * @returns {Promise&lt;TriggerScrapingProcessResult&gt;} Result of the attempt to trigger the scraping process, including success status, job ID, and message or error.
 * @description
 *   - Creates a web scraping job with a priority of 5 and triggers its processing.
 *   - Handles errors during job creation or processing gracefully.
 *   - Uses the current timestamp to schedule the job.
 */
async function triggerScrapingProcess(targetUrl) {
    try {
        const job = await ScrapingJobService.createJob({
            job_type: 'website_auto',
            target_url: targetUrl,
            priority: 5,
            scheduled_at: new Date().toISOString(),
        });
        processScrapingJob(job.id).catch((error) =&gt; {
            console.error('Failed to process scraping job:', error);
        });
        return {
            success: true,
            jobId: job.id,
            message: `Scraping job created and processing initiated for ${targetUrl}.`,
        };
    }
    catch (error) {
        return {
            success: false,
            error: error instanceof Error ? error.message : 'Failed to create or process job',
        };
    }
}
// Helper function to process existing truck results
/**
 * Processes the result of an existing truck scraping operation.
 * @example
 * processExistingTruckResult('http://example.com', { status: 'fresh' }, { trucksProcessed: 1, newTrucksFound: 0 }, []);
 * // no return value, updates states and logs errors if any
 * @param {string} url - The URL of the truck to process.
 * @param {{ status: string; details?: string }} result - The result of the truck scraping operation, including status and optional details.
 * @param {{ trucksProcessed: number; newTrucksFound: number }} counters - Trackers for counting processed and newly found trucks.
 * @param {Array&lt;{ url: string; details?: string }&gt;} errors - A list to record any URLs that result in errors, along with optional error details.
 * @returns {Promise&lt;void&gt;} Resolves when processing is complete, performing status updates.
 * @description
 *   - Updates the status of the URL based on the result: either processing, processed, or irrelevant.
 *   - Pushes any error information to the errors array for further processing or logging.
 *   - Utilizes different status handling depending on the freshness or error state of the data.
 */
async function processExistingTruckResult(url, result, counters, errors) {
    switch (result.status) {
        case 're-scraping_triggered': {
            counters.trucksProcessed += 1;
            await updateDiscoveredUrlStatus(url, 'processing', 'Re-scraping triggered due to stale data');
            break;
        }
        case 'fresh': {
            await updateDiscoveredUrlStatus(url, 'processed', 'Data is fresh, no action needed');
            break;
        }
        case 'error': {
            errors.push({ url, details: result.details });
            await updateDiscoveredUrlStatus(url, 'irrelevant', `Error: ${result.details}`);
            break;
        }
        // No default
    }
}
// Helper function to process new truck results
/**
 * Processes the result of a new truck resource and updates the counters accordingly.
 * @example
 * processNewTruckResult('https://example.com/truck', { status: 'initial_scrape_triggered' }, { trucksProcessed: 5, newTrucksFound: 2 }, []);
 * // Updates counters and changes URL status to 'processing'.
 * @param {string} url - The URL of the new truck resource to be processed.
 * @param {Object} result - The result object containing the status and optional details of the process.
 * @param {string} result.status - The status of the truck processing result.
 * @param {string} [result.details] - Optional detailed message about the result.
 * @param {Object} counters - An object keeping count of processed trucks and newly found trucks.
 * @param {number} counters.trucksProcessed - The current count of processed trucks.
 * @param {number} counters.newTrucksFound - The count of newly found trucks.
 * @param {Array&lt;Object&gt;} errors - A list of error objects for unsuccessful processing attempts.
 * @param {string} errors.url - The URL of the truck resource that encountered an error.
 * @param {string} [errors.details] - Optional error details associated with the URL.
 * @returns {Promise&lt;void&gt;} This function returns nothing but performs asynchronous URL status updates and error logging.
 * @description
 *   - The function distinguishes between two specific statuses: 'initial_scrape_triggered' and 'error'.
 *   - For 'initial_scrape_triggered', it updates the counters and marks the URL as 'processing'.
 *   - For 'error', it logs the error details and marks the URL as 'irrelevant'.
 */
async function processNewTruckResult(url, result, counters, errors) {
    if (result.status === 'initial_scrape_triggered') {
        counters.newTrucksFound += 1;
        counters.trucksProcessed += 1;
        await updateDiscoveredUrlStatus(url, 'processing', 'Initial scraping triggered');
    }
    else if (result.status === 'error') {
        errors.push({ url, details: result.details });
        await updateDiscoveredUrlStatus(url, 'irrelevant', `Error: ${result.details}`);
    }
}
// Helper function to find existing truck for URL
/**
* Find an existing food truck based on the provided source URL.
* @example
* findExistingTruck('https://foodtruck.com/123')
* { truck: { id: 1, last_scraped_at: '2023-09-16T00:00:00Z', source_urls: ['https://foodtruck.com'] } }
* @param {string} url - The source URL used to search for an existing truck in the database.
* @returns {Promise&lt;{ truck?: FoodTruck; error?: string }&gt;} An object containing either the existing truck data or an error message.
* @description
*   - Utilizes Supabase admin client to query the 'food_trucks' database table.
*   - Warns in the console when a query error occurs during the database lookup.
*   - Limits the query results to a single truck that matches the URL criteria.
*/
async function findExistingTruck(url) {
    if (!supabaseAdmin) {
        return { error: 'Supabase admin client not available' };
    }
    const { data: existingTrucks, error: truckQueryError } = await supabaseAdmin
        .from('food_trucks')
        .select('id, last_scraped_at, source_urls')
        .or(`source_urls.cs.{&quot;${url}&quot;}`)
        .limit(1);
    if (truckQueryError) {
        console.warn(`AutoScraper: Error querying for existing truck for url ${url}:`, truckQueryError.message);
        return { error: `Supabase query error: ${truckQueryError.message}` };
    }
    const truck = existingTrucks != undefined &amp;&amp; existingTrucks.length &gt; 0
        ? existingTrucks[0]
        : undefined;
    return { truck };
}
/**
 * Initiates the autonomous scraping process and ensures default trucks data is fetched.
 * @example
 * ensureDefaultTrucksAreScraped()
 * Returns a result object containing the number of trucks processed, new trucks found, and any errors encountered.
 * @returns {Promise&lt;AutoScrapeResult&gt;} An object containing the results of the scraping process, including processed trucks count, new trucks discovered count, and encountered errors.
 * @description
 *   - Combines static default URLs with dynamically discovered URLs for scraping.
 *   - Handles both existing and new trucks, updating counters and tracking errors.
 *   - Logs process information and warnings for unexpected errors during execution.
 */
export async function ensureDefaultTrucksAreScraped() {
    console.info('AutoScraper: Starting autonomous scraping process...');
    const counters = { trucksProcessed: 0, newTrucksFound: 0 };
    const errors = [];
    // Get URLs to scrape - combine static defaults with dynamically discovered URLs
    const urlsToScrape = await getUrlsToScrape();
    console.info(`AutoScraper: Found ${urlsToScrape.length} URLs to process`);
    for (const url of urlsToScrape) {
        try {
            console.info(`AutoScraper: Checking url: ${url}`);
            const { truck, error } = await findExistingTruck(url);
            if (error != undefined) {
                errors.push({ url, details: error });
                continue;
            }
            if (truck) {
                const result = await handleExistingTruck(url, truck);
                await processExistingTruckResult(url, result, counters, errors);
            }
            else {
                const result = await handleNewTruck(url);
                await processNewTruckResult(url, result, counters, errors);
            }
        }
        catch (error) {
            console.warn(`AutoScraper: Unexpected error processing url ${url}:`, error);
            errors.push({
                url,
                details: error instanceof Error ? error.message : 'Unknown error',
            });
        }
    }
    console.info('AutoScraper: Finished autonomous scraping process.');
    return {
        trucksProcessed: counters.trucksProcessed,
        newTrucksFound: counters.newTrucksFound,
        errors,
    };
}
/**
* Handles the existing truck data by checking staleness and potentially triggering a re-scrape process.
* @example
* handleExistingTruck('https://example.com/truck', { id: '123', last_scraped_at: '2023-09-01T00:00:00Z' })
* { url: 'https://example.com/truck', status: 'fresh', details: 'Last scraped at 2023-09-01T00:00:00Z' }
* @param {string} url - The URL of the food truck to check for staleness.
* @param {FoodTruck} truck - The food truck object containing its ID and last scrape date.
* @returns {Promise&lt;{url: string; status: string; details?: string; jobId?: string}&gt;} Returns the status and additional detail about the scraping process.
* @description
*   - Only triggers the re-scraping process if the data is considered stale based on a predefined threshold.
*   - Logs information about the current state of the truck's data freshness.
*   - Utilizes an asynchronous operation to potentially trigger a re-scrape.
*   - Returns an object indicating whether action was taken or not.
*/
async function handleExistingTruck(url, truck) {
    console.info(`AutoScraper: Found existing truck for ${url} (id: ${truck.id}). Last scraped: ${truck.last_scraped_at}`);
    const lastScrapedDate = new Date(truck.last_scraped_at);
    const stalenessLimit = new Date();
    stalenessLimit.setDate(stalenessLimit.getDate() - DEFAULT_STALENESS_THRESHOLD_DAYS);
    if (lastScrapedDate &lt; stalenessLimit) {
        console.info(`AutoScraper: Data for ${url} is stale. Triggering re-scrape.`);
        const triggerResult = await triggerScrapingProcess(url);
        return {
            url,
            status: triggerResult.success ? 're-scraping_triggered' : 'error',
            details: triggerResult.error ?? triggerResult.message,
            jobId: triggerResult.jobId,
        };
    }
    console.info(`AutoScraper: Data for ${url} is fresh. No action needed.`);
    return { url, status: 'fresh', details: `Last scraped at ${truck.last_scraped_at}` };
}
/**
 * Initiates a scraping process for a new truck based on the given URL and returns the scraping status.
 * @example
 * handleNewTruck(&quot;https://example.com/truck-detail&quot;)
 * // Returns: { url: &quot;https://example.com/truck-detail&quot;, status: &quot;initial_scrape_triggered&quot;, details: &quot;Scraping initiated&quot;, jobId: &quot;12345&quot; }
 * @param {string} url - The URL of the truck details page to be scraped.
 * @returns {Promise&lt;{ url: string; status: string; details?: string; jobId?: string }&gt;} An object containing the URL, status of the scraping attempt, optional details message, and optional job ID.
 * @description
 *   - Uses an asynchronous function to trigger the scraping process.
 *   - Logs an informational message when no existing truck is found for the given URL.
 *   - Returns a status indicating whether the scrape was successfully triggered or if there was an error.
 */
async function handleNewTruck(url) {
    console.info(`AutoScraper: No existing truck found for ${url}. Triggering initial scrape.`);
    const triggerResult = await triggerScrapingProcess(url);
    return {
        url,
        status: triggerResult.success ? 'initial_scrape_triggered' : 'error',
        details: triggerResult.error ?? triggerResult.message,
        jobId: triggerResult.jobId,
    };
}
// --- Gemini API Rate Limiting &amp; Caching ---
const GEMINI_CACHE_TTL_MS = 1000 * 60 * 60 * 6; // 6 hours
const geminiCache = {};
/**
 * Makes a call to Gemini service and caches the result to optimize performance.
 * @example
 * callGeminiWithCache('getData', { id: 123 }, geminiInstance)
 * // returns the result from the Gemini service or cache
 * @param {string} type - The type of operation to perform with Gemini.
 * @param {unknown} input - The input data required for the Gemini operation.
 * @param {GeminiService} gemini - The instance of GeminiService to interact with.
 * @returns {Promise&lt;unknown&gt;} Returns a promise that resolves to the result of the Gemini operation.
 * @description
 *   - Caches the result of Gemini service calls to avoid redundant requests.
 *   - Automatically cleans up expired cache entries based on a specified TTL.
 *   - Checks Gemini usage limits before making API calls to prevent exceeding the daily cap.
 *   - Constructs a unique cache key for each request using the operation type and input.
 */
export async function callGeminiWithCache(type, input, gemini) {
    const cacheKey = `${type}:${JSON.stringify(input)}`;
    const now = Date.now();
    // Clean up expired cache
    for (const key in geminiCache) {
        if (Object.prototype.hasOwnProperty.call(geminiCache, key) &amp;&amp;
            now - geminiCache[key].timestamp &gt; GEMINI_CACHE_TTL_MS) {
            delete geminiCache[key];
        }
    }
    if (geminiCache[cacheKey] != undefined &amp;&amp;
        now - geminiCache[cacheKey].timestamp &lt; GEMINI_CACHE_TTL_MS) {
        return geminiCache[cacheKey].data;
    }
    // Check Gemini usage limits before making a call
    const usage = await gemini.checkUsageLimits();
    if (!usage.canMakeRequest) {
        throw new Error('Gemini API daily limit reached. Try again tomorrow.');
    }
    // @ts-expect-error TS(2345): Argument of type 'string' is not assignable to par... Remove this comment to see the full error message
    const result = await dispatchGeminiOperation(type, input);
    geminiCache[cacheKey] = { data: result, timestamp: now };
    return result;
}
// Helper to get URLs to scrape from both static defaults and dynamic discovery
/**
* Retrieves a list of URLs that are ready for scraping.
* @example
* getUrlsToScrape()
* // Returns a Promise that resolves to an array of URLs
* @param {void} - This function does not take any arguments.
* @returns {Promise&lt;string[]&gt;} A promise that resolves to an array of URLs to be scraped.
* @description
*   - The function returns a combination of default URLs and dynamically discovered URLs.
*   - Utilizes Supabase to fetch URLs marked with 'new' or 'processed' status.
*   - Limits results to prevent system overload, fetching a maximum of 100 URLs.
*   - Handles errors gracefully, logging warnings if the Supabase client is not available or if there is an error in fetching URLs.
*/
async function getUrlsToScrape() {
    const urls = new Set();
    // Add static default URLs
    for (const url of DEFAULT_SCRAPE_URLS)
        urls.add(url);
    // Add dynamically discovered URLs that are ready for processing
    try {
        if (!supabaseAdmin) {
            console.warn('AutoScraper: Supabase admin client not available for discovered URLs');
            return [...urls];
        }
        const { data: discoveredUrls, error } = await supabaseAdmin
            .from('discovered_urls')
            .select('url')
            .in('status', ['new', 'processed']) // Include both new and previously processed URLs
            .order('discovered_at', { ascending: false })
            .limit(100); // Limit to prevent overwhelming the system
        if (error) {
            console.warn('AutoScraper: Error fetching discovered URLs:', error.message);
        }
        else if (discoveredUrls != undefined) {
            for (const { url } of discoveredUrls)
                urls.add(url);
            console.info(`AutoScraper: Added ${discoveredUrls.length} discovered URLs to scraping queue`);
        }
    }
    catch (error) {
        console.warn('AutoScraper: Failed to fetch discovered URLs:', error);
    }
    return [...urls];
}
// Helper to update discovered URL status after processing
/**
 * Updates the status of a discovered URL in the database.
 * @example
 * updateDiscoveredUrlStatus('http://example.com', 'processed', 'Page successfully processed')
 * // Returns: void
 * @param {string} url - The URL whose status needs updating.
 * @param {'processing' | 'processed' | 'irrelevant'} status - The new status for the URL.
 * @param {string} [notes] - Optional notes regarding the URL status update.
 * @returns {Promise&lt;void&gt;} Resolves when the update operation is complete.
 * @description
 *   - Logs a warning if the Supabase admin client is not available.
 *   - Uses Supabase to update the status and logs an error if the operation fails.
 *   - Assumes the existence of a 'discovered_urls' table in the database.
 */
async function updateDiscoveredUrlStatus(url, status, notes) {
    try {
        if (!supabaseAdmin) {
            console.warn(`AutoScraper: Cannot update status for ${url} - Supabase admin client not available`);
            return;
        }
        const { error } = await supabaseAdmin
            .from('discovered_urls')
            .update({
            status,
            last_processed_at: new Date().toISOString(),
            notes: notes ?? undefined,
        })
            .eq('url', url);
        if (error != undefined) {
            console.warn(`AutoScraper: Failed to update status for ${url}:`, error.message);
        }
    }
    catch (error) {
        console.warn(`AutoScraper: Error updating discovered URL status for ${url}:`, error);
    }
}
// Note on processScrapingJob import:
// The direct import of `processScrapingJob` from `@/app/api/scrape/route.ts` can be problematic
// if `route.ts` has side effects or dependencies not suitable for a library context (like NextRequest/Response).
// A cleaner way would be to refactor `processScrapingJob` into a shared utility if it's to be called directly,
// or for `triggerScrapingProcess` to make an internal http post request to `/api/scrape`.
// For this iteration, we are attempting direct call, assuming it's manageable.
// Export autoScraper object for use in cron jobs
export const autoScraper = {
    runAutoScraping: ensureDefaultTrucksAreScraped,
    triggerScrapingProcess,
    callGeminiWithCache,
    getUrlsToScrape,
    updateDiscoveredUrlStatus,
};
// Main autonomous scraping function that combines discovery and scraping
export async function runAutonomousScraping() {
    console.info('AutoScraper: Starting fully autonomous scraping cycle...');
    // This function can be called by the autonomous scheduler
    // It uses the updated ensureDefaultTrucksAreScraped which now pulls from discovered_urls
    return await ensureDefaultTrucksAreScraped();
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/lib/activityLogger.js (Line 1:1 - Line 49:2), C:/AI/food-truck-finder-poc/dist/lib/lib/activityLogger.js (Line 1:1 - Line 49:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn500" onclick="toggleCodeBlock('cloneGroup500', 'expandBtn500', 'collapseBtn500')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn500" onclick="toggleCodeBlock('cloneGroup500', 'expandBtn500', 'collapseBtn500')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup500"><code class="language-javascript text-sm text-gray-800">/**
* Logs an activity entry with a timestamp and unique ID.
* @example
* logActivity({ action: 'user_login', username: 'johndoe' })
* undefined
* @param {ActivityLogEntry} entry - The activity entry to be logged.
* @returns {void} No return value.
* @description
*   - If `timestamp` is not provided in the entry, the current ISO timestamp is used.
*   - A unique ID is generated and added to the log entry.
*   - Logs activity data to the console in a structured format.
*   - Intended for development, but can be extended for production use with database or monitoring integration.
*/
export function logActivity(entry) {
    try {
        const logEntry = {
            ...entry,
            timestamp: entry.timestamp ?? new Date().toISOString(),
            id: generateId(),
        };
        // Log to console for development
        console.info('Activity Log:', JSON.stringify(logEntry, undefined, 2));
        // In a production environment, you would:
        // 1. Store to database
        // 2. Send to monitoring service
        // 3. Store in a queue for batch processing
        // For now, we'll just store in memory or local storage
        // This is a mock implementation
    }
    catch (error) {
        console.error('Failed to log activity:', error);
        // Don't throw - logging failures shouldn't break the main flow
    }
}
export function getActivityLogs(_type, _limit = 50) {
    try {
        // Mock implementation - in production this would query your database
        return [];
    }
    catch (error) {
        console.error('Failed to retrieve activity logs:', error);
        return [];
    }
}
function generateId() {
    // Using crypto.randomUUID() would be better for production, but Math.random() is acceptable for logging IDs
    // eslint-disable-next-line sonarjs/pseudo-random -- Math.random is acceptable for non-security-critical logging IDs.
    return Math.random().toString(36).slice(2) + Date.now().toString(36);
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/hooks/UseToast.js (Line 2:1 - Line 13:39), C:/AI/food-truck-finder-poc/dist/app/api/trucks/route.js (Line 1:1 - Line 12:7)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn502" onclick="toggleCodeBlock('cloneGroup502', 'expandBtn502', 'collapseBtn502')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn502" onclick="toggleCodeBlock('cloneGroup502', 'expandBtn502', 'collapseBtn502')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup502"><code class="language-javascript text-sm text-gray-800">var __rest = (this &amp;&amp; this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) &amp;&amp; e.indexOf(p) &lt; 0)
        t[p] = s[p];
    if (s != null &amp;&amp; typeof Object.getOwnPropertySymbols === &quot;function&quot;)
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i &lt; p.length; i++) {
            if (e.indexOf(p[i]) &lt; 0 &amp;&amp; Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
// Inspired by react-hot-toast library</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/hooks/useAuthHandlers.js (Line 25:1 - Line 56:2), C:/AI/food-truck-finder-poc/dist/lib/hooks/useAuthHandlers.js (Line 25:1 - Line 56:8)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn503" onclick="toggleCodeBlock('cloneGroup503', 'expandBtn503', 'collapseBtn503')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn503" onclick="toggleCodeBlock('cloneGroup503', 'expandBtn503', 'collapseBtn503')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup503"><code class="language-javascript text-sm text-gray-800">export function useAuthHandlers(redirectTo) {
    const [loading, setLoading] = useState(false);
    const [error, setError] = useState();
    const [email, setEmail] = useState('');
    const [password, setPassword] = useState('');
    const router = useRouter();
    const handleEmailLogin = useCallback(async (e) =&gt; {
        e.preventDefault();
        try {
            setLoading(true);
            setError(undefined);
            const { error: signInError } = await supabase.auth.signInWithPassword({
                email,
                password,
            });
            if (signInError) {
                throw signInError;
            }
            const { data: { user }, error: userError, } = await supabase.auth.getUser();
            if (userError) {
                throw userError;
            }
            if (user) {
                const { data: profile, error: profileError } = await supabase
                    .from('profiles')
                    .select('role')
                    .eq('id', user.id)
                    .single();
                if (profileError) {
                    throw profileError;
                }
                if ((</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/hooks/useAuthHandlers.js (Line 56:2 - Line 104:2), C:/AI/food-truck-finder-poc/dist/lib/hooks/useAuthHandlers.js (Line 56:2 - Line 104:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn504" onclick="toggleCodeBlock('cloneGroup504', 'expandBtn504', 'collapseBtn504')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn504" onclick="toggleCodeBlock('cloneGroup504', 'expandBtn504', 'collapseBtn504')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup504"><code class="language-javascript text-sm text-gray-800">=== 'admin') {
                    router.push(redirectTo);
                }
                else {
                    router.push('/access-denied');
                }
            }
        }
        catch (error_) {
            console.error('Login error:', error_);
            setError(error_ instanceof Error ? error_.message : 'An error occurred during login');
        }
        finally {
            setLoading(false);
        }
    }, [email, password, router, redirectTo]);
    const handleGoogleLogin = useCallback(async () =&gt; {
        try {
            setLoading(true);
            setError(undefined);
            const { error: signInError } = await supabase.auth.signInWithOAuth({
                provider: 'google',
                options: {
                    redirectTo: `${globalThis.location.origin}/auth/callback?redirectTo=${encodeURIComponent(redirectTo)}`,
                },
            });
            if (signInError) {
                throw signInError;
            }
        }
        catch (error_) {
            console.error('Login error:', error_);
            setError(error_ instanceof Error ? error_.message : 'An error occurred during login');
        }
        finally {
            setLoading(false);
        }
    }, [router, redirectTo]);
    return {
        handleEmailLogin,
        handleGoogleLogin,
        loading,
        error,
        email,
        setEmail,
        password,
        setPassword,
    };
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/gemini/usageLimits.js (Line 1:14 - Line 73:2), C:/AI/food-truck-finder-poc/dist/lib/lib/gemini/usageLimits.js (Line 1:24 - Line 73:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn505" onclick="toggleCodeBlock('cloneGroup505', 'expandBtn505', 'collapseBtn505')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn505" onclick="toggleCodeBlock('cloneGroup505', 'expandBtn505', 'collapseBtn505')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup505"><code class="language-javascript text-sm text-gray-800">;
import { APIMonitor } from '../monitoring/apiMonitor';
export class GeminiUsageLimits {
    static DEFAULT_LIMITS = {
        dailyRequestLimit: 1500,
        dailyTokenLimit: 32_000,
    };
    /**
     * Checks the current usage against predefined limits and determines if further requests can be made.
     * @example
     * checkUsageLimits()
     * { canMakeRequest: true, usage: { requests: { used: 50, limit: 1000, remaining: 950 }, tokens: { used: 200, limit: 5000, remaining: 4800 } } }
     * @param {UsageLimits} limits - Object containing usage limits for requests and tokens.
     * @returns {Promise&lt;UsageCheck&gt;} Object indicating if a request can be made and the current usage statistics.
     * @description
     *   - Attempts to fetch today's usage data from the APIUsageService for 'gemini'.
     *   - If the fetch fails, defaults to allowing the request with a warning.
     *   - Maintains a buffer of 100 tokens to ensure requests are not made when limits are too close.
     */
    static async checkUsageLimits(limits = this.DEFAULT_LIMITS) {
        try {
            const usage = await APIUsageService.getTodayUsage('gemini');
            if (!usage) {
                return { canMakeRequest: true };
            }
            const requestsUsed = usage.requests_count ?? 0;
            const tokensUsed = usage.tokens_used ?? 0;
            const requestsRemaining = limits.dailyRequestLimit - requestsUsed;
            const tokensRemaining = limits.dailyTokenLimit - tokensUsed;
            return {
                canMakeRequest: requestsRemaining &gt; 0 &amp;&amp; tokensRemaining &gt; 100, // Keep 100 token buffer
                usage: {
                    requests: {
                        used: requestsUsed,
                        limit: limits.dailyRequestLimit,
                        remaining: requestsRemaining,
                    },
                    tokens: {
                        used: tokensUsed,
                        limit: limits.dailyTokenLimit,
                        remaining: tokensRemaining,
                    },
                },
            };
        }
        catch (error) {
            console.warn('Error checking Gemini usage limits:', error);
            return { canMakeRequest: false };
        }
    }
    /**
    * Checks if a request can be made with monitoring and returns whether the operation is allowed.
    * @example
    * checkWithMonitoring(100, DEFAULT_LIMITS)
    * { allowed: true }
    * @param {number} estimatedTokens - Number of estimated tokens for the request.
    * @param {UsageLimits} _limits - Usage limits configuration for requests (default provided internally).
    * @returns {Promise&lt;{ allowed: boolean; reason?: string; waitTime?: number }&gt;} Object indicating if the request is allowed and why not if denied.
    * @description
    *   - Uses an internal API monitor to check if requests can be made based on predefined limits.
    *   - Wait time is converted from milliseconds to minutes before being returned.
    */
    static async checkWithMonitoring(estimatedTokens, _limits = this.DEFAULT_LIMITS) {
        const canMakeRequest = await APIMonitor.canMakeRequest('gemini', 1, estimatedTokens);
        if (!canMakeRequest.allowed) {
            return {
                allowed: false,
                reason: `API limit reached: ${canMakeRequest.reason}. Wait time: ${Math.ceil((canMakeRequest.waitTime ?? 0) / 1000 / 60)} minutes`,
            };
        }
        return { allowed: true };
    }
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/gemini/responseParser.js (Line 1:1 - Line 36:2), C:/AI/food-truck-finder-poc/dist/lib/lib/gemini/responseParser.js (Line 1:1 - Line 36:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn507" onclick="toggleCodeBlock('cloneGroup507', 'expandBtn507', 'collapseBtn507')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn507" onclick="toggleCodeBlock('cloneGroup507', 'expandBtn507', 'collapseBtn507')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup507"><code class="language-javascript text-sm text-gray-800">export const GeminiResponseParser = {
    parseJson(text) {
        // Clean up the response text
        const cleanedText = text
            .replaceAll(/```json\s*/g, '')
            .replaceAll(/```\s*/g, '')
            .replaceAll(/^\s*json\s*/g, '')
            .trim();
        return JSON.parse(cleanedText);
    },
    parseMenuData(text) {
        return this.parseJson(text);
    },
    parseLocationData(text) {
        return this.parseJson(text);
    },
    parseOperatingHours(text) {
        return this.parseJson(text);
    },
    parseSentimentAnalysis(text) {
        return this.parseJson(text);
    },
    parseEnhancedFoodTruckData(text) {
        return this.parseJson(text);
    },
    parseExtractedFoodTruckDetails(text) {
        return this.parseJson(text);
    },
    cleanMarkdownResponse(text) {
        return text
            .replaceAll(/```json\s*/g, '')
            .replaceAll(/```\s*/g, '')
            .replaceAll(/^\s*json\s*/g, '')
            .trim();
    },
};</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/gemini/promptTemplates.js (Line 1:1 - Line 223:2), C:/AI/food-truck-finder-poc/dist/lib/lib/gemini/promptTemplates.js (Line 1:1 - Line 223:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn509" onclick="toggleCodeBlock('cloneGroup509', 'expandBtn509', 'collapseBtn509')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn509" onclick="toggleCodeBlock('cloneGroup509', 'expandBtn509', 'collapseBtn509')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup509"><code class="language-javascript text-sm text-gray-800">export const PromptTemplates = {
    menuProcessing: (rawMenuText) =&gt; `
Parse the following food truck menu text and return a structured JSON format.
Extract menu items with categories, names, descriptions, prices, and dietary tags.

Menu text:
${rawMenuText}

Expected JSON format:
[
  {
    &quot;category&quot;: &quot;string&quot;,
    &quot;items&quot;: [
      {
        &quot;name&quot;: &quot;string&quot;,
        &quot;description&quot;: &quot;string&quot;,
        &quot;price&quot;: number,
        &quot;dietary_tags&quot;: [&quot;string&quot;]
      }
    ]
  }
]

Rules:
- Extract actual prices as numbers (e.g., 12.99, not &quot;$12.99&quot;)
- Include dietary restrictions and special tags
- Group items into logical categories
- If no clear categories, use &quot;Main Items&quot;
- Return only the json, no additional text
  `,
    locationExtraction: (textInput) =&gt; `
Extract location information from the following text and return structured data.
Look for addresses, cross streets, landmarks, or location descriptions.

Text:
${textInput}

Expected JSON format:
{
  &quot;address&quot;: &quot;string or undefined&quot;,
  &quot;city&quot;: &quot;string or undefined&quot;, 
  &quot;state&quot;: &quot;string or undefined&quot;,
  &quot;zipCode&quot;: &quot;string or undefined&quot;,
  &quot;coordinates&quot;: {&quot;lat&quot;: number, &quot;lng&quot;: number} or undefined,
  &quot;confidence&quot;: number,
  &quot;landmarks&quot;: [&quot;string&quot;]
}

Rules:
- Set coordinates to undefined if not explicitly provided
- Confidence should be 0.0 to 1.0 based on clarity
- Include any mentioned landmarks or cross streets
- Return only the json, no additional text
  `,
    operatingHours: (hoursText) =&gt; `
Parse the following operating hours text and return standardized format.
Convert all times to 24-hour format and handle various input formats.

Hours text:
${hoursText}

Expected JSON format:
{
  &quot;monday&quot;: {&quot;open&quot;: &quot;HH:MM&quot;, &quot;close&quot;: &quot;HH:MM&quot;, &quot;closed&quot;: false},
  &quot;tuesday&quot;: {&quot;open&quot;: &quot;HH:MM&quot;, &quot;close&quot;: &quot;HH:MM&quot;, &quot;closed&quot;: false},
  &quot;wednesday&quot;: {&quot;open&quot;: &quot;HH:MM&quot;, &quot;close&quot;: &quot;HH:MM&quot;, &quot;closed&quot;: false},
  &quot;thursday&quot;: {&quot;open&quot;: &quot;HH:MM&quot;, &quot;close&quot;: &quot;HH:MM&quot;, &quot;closed&quot;: false},
  &quot;friday&quot;: {&quot;open&quot;: &quot;HH:MM&quot;, &quot;close&quot;: &quot;HH:MM&quot;, &quot;closed&quot;: false},
  &quot;saturday&quot;: {&quot;open&quot;: &quot;HH:MM&quot;, &quot;close&quot;: &quot;HH:MM&quot;, &quot;closed&quot;: false},
  &quot;sunday&quot;: {&quot;open&quot;: &quot;HH:MM&quot;, &quot;close&quot;: &quot;HH:MM&quot;, &quot;closed&quot;: false}
}

Rules:
- Use 24-hour format (e.g., &quot;14:30&quot; for 2:30 pm)
- If closed on a day, set &quot;closed&quot;: true and omit open/close times
- Handle ranges like &quot;Mon-Fri&quot; by applying to all days in range
- Default to reasonable hours if ambiguous
- Return only the json, no additional text
  `,
    sentimentAnalysis: (reviewText) =&gt; `
Analyze the sentiment of this food truck review and extract key insights.
Focus on food quality, service, value, and overall experience.

Review text:
${reviewText}

Expected JSON format:
{
  &quot;score&quot;: number,
  &quot;confidence&quot;: number,
  &quot;aspects&quot;: {
    &quot;food_quality&quot;: number,
    &quot;service&quot;: number,
    &quot;value&quot;: number,
    &quot;overall&quot;: number
  },
  &quot;summary&quot;: &quot;string&quot;,
  &quot;keywords&quot;: [&quot;string&quot;]
}

Rules:
- Score should be 0.0 (very negative) to 1.0 (very positive)
- Confidence should be 0.0 to 1.0 based on clarity of sentiment
- Include specific aspects mentioned in the review
- Summary should be 1-2 sentences max
- Return only the json, no additional text
  `,
    dataEnhancement: (rawData) =&gt; `
Enhance and standardize the following food truck data.
Fill in missing information where possible and improve data quality.

Raw data:
${JSON.stringify(rawData, undefined, 2)}

Expected JSON format:
{
  &quot;name&quot;: &quot;string&quot;,
  &quot;description&quot;: &quot;string&quot;,
  &quot;cuisine_type&quot;: &quot;string&quot;,
  &quot;price_range&quot;: &quot;$ | $$ | $$$ | $$$$&quot;,
  &quot;contact&quot;: {
    &quot;phone&quot;: &quot;string&quot;,
    &quot;email&quot;: &quot;string&quot;,
    &quot;website&quot;: &quot;string&quot;,
    &quot;social_media&quot;: {}
  },
  &quot;location&quot;: {
    &quot;address&quot;: &quot;string&quot;,
    &quot;city&quot;: &quot;string&quot;,
    &quot;state&quot;: &quot;string&quot;,
    &quot;coordinates&quot;: {&quot;lat&quot;: number, &quot;lng&quot;: number}
  },
  &quot;operating_hours&quot;: {},
  &quot;menu_categories&quot;: [&quot;string&quot;],
  &quot;specialties&quot;: [&quot;string&quot;],
  &quot;dietary_options&quot;: [&quot;string&quot;]
}

Rules:
- Preserve all original data while enhancing it
- Standardize naming conventions
- Infer cuisine type from menu items
- Estimate price range from menu prices
- Return only the json, no additional text
  `,
    foodTruckExtraction: (markdownContent, sourceUrl) =&gt; {
        const schema = `
Expected JSON schema:
{
  &quot;name&quot;: &quot;string (food truck name)&quot;,
  &quot;description&quot;: &quot;string (brief description of the food truck)&quot;,
  &quot;cuisine_type&quot;: &quot;string (type of cuisine served)&quot;,
  &quot;contact&quot;: {
    &quot;phone&quot;: &quot;string (phone number if found)&quot;,
    &quot;email&quot;: &quot;string (email if found)&quot;, 
    &quot;website&quot;: &quot;string (website URL if found)&quot;,
    &quot;social_media&quot;: {
      &quot;facebook&quot;: &quot;string (Facebook URL if found)&quot;,
      &quot;instagram&quot;: &quot;string (Instagram URL if found)&quot;,
      &quot;twitter&quot;: &quot;string (Twitter URL if found)&quot;
    }
  },
  &quot;location&quot;: {
    &quot;address&quot;: &quot;string (physical address if found)&quot;,
    &quot;city&quot;: &quot;string (city name)&quot;,
    &quot;state&quot;: &quot;string (state abbreviation)&quot;,
    &quot;coordinates&quot;: {
      &quot;lat&quot;: &quot;number (latitude if found)&quot;,
      &quot;lng&quot;: &quot;number (longitude if found)&quot;
    }
  },
  &quot;operating_hours&quot;: {
    &quot;monday&quot;: {&quot;open&quot;: &quot;string (HH:MM)&quot;, &quot;close&quot;: &quot;string (HH:MM)&quot;, &quot;closed&quot;: &quot;boolean&quot;},
    &quot;tuesday&quot;: {&quot;open&quot;: &quot;string (HH:MM)&quot;, &quot;close&quot;: &quot;string (HH:MM)&quot;, &quot;closed&quot;: &quot;boolean&quot;},
    &quot;wednesday&quot;: {&quot;open&quot;: &quot;string (HH:MM)&quot;, &quot;close&quot;: &quot;string (HH:MM)&quot;, &quot;closed&quot;: &quot;boolean&quot;},
    &quot;thursday&quot;: {&quot;open&quot;: &quot;string (HH:MM)&quot;, &quot;close&quot;: &quot;string (HH:MM)&quot;, &quot;closed&quot;: &quot;boolean&quot;},
    &quot;friday&quot;: {&quot;open&quot;: &quot;string (HH:MM)&quot;, &quot;close&quot;: &quot;string (HH:MM)&quot;, &quot;closed&quot;: &quot;boolean&quot;},
    &quot;saturday&quot;: {&quot;open&quot;: &quot;string (HH:MM)&quot;, &quot;close&quot;: &quot;string (HH:MM)&quot;, &quot;closed&quot;: &quot;boolean&quot;},
    &quot;sunday&quot;: {&quot;open&quot;: &quot;string (HH:MM)&quot;, &quot;close&quot;: &quot;string (HH:MM)&quot;, &quot;closed&quot;: &quot;boolean&quot;}
  },
  &quot;menu&quot;: [
    {
      &quot;category&quot;: &quot;string (menu category)&quot;,
      &quot;items&quot;: [
        {
          &quot;name&quot;: &quot;string (item name)&quot;,
          &quot;description&quot;: &quot;string (item description)&quot;,
          &quot;price&quot;: &quot;number (price as number, not string)&quot;,
          &quot;dietary_tags&quot;: [&quot;string (dietary restrictions/tags)&quot;]
        }
      ]
    }
  ],
  &quot;specialties&quot;: [&quot;string (signature dishes or specialties)&quot;],
  &quot;dietary_options&quot;: [&quot;string (dietary accommodations like vegan, gluten-free)&quot;],
  &quot;price_range&quot;: &quot;string ($ for under $10, $$ for $10-20, $$$ for $20-30, $$$$ for over $30)&quot;
}
`;
        const instructions = `
Instructions:
- Extract as much information as possible from the provided content
- If information is not available, use null for the field
- For operating hours, use 24-hour format (e.g., &quot;14:30&quot; for 2:30 PM)
- If a day is closed, set &quot;closed&quot;: true and omit open/close times
- For prices, extract numeric values only (e.g., 12.99, not &quot;$12.99&quot;)
- Be thorough in extracting menu items and their details
- Look for social media links and contact information carefully
- Return only the JSON object, no additional text or formatting
`;
        return `
You are an ai assistant tasked with extracting structured information about food trucks from their website content (provided in Markdown format). Your goal is to populate a json object with the following schema. Only return the json object, nothing else.

Website content:
${markdownContent}

${sourceUrl ? `Source URL: ${sourceUrl}` : ''}

${schema}

${instructions}
`;
    },
};</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/gemini/geminiApiClient.js (Line 2:14 - Line 104:2), C:/AI/food-truck-finder-poc/dist/lib/lib/gemini/geminiApiClient.js (Line 2:24 - Line 104:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn511" onclick="toggleCodeBlock('cloneGroup511', 'expandBtn511', 'collapseBtn511')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn511" onclick="toggleCodeBlock('cloneGroup511', 'expandBtn511', 'collapseBtn511')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup511"><code class="language-javascript text-sm text-gray-800">;
export class GeminiApiClient {
    genAI;
    modelName;
    constructor() {
        const apiKey = process.env.GEMINI_API_KEY;
        if (apiKey == undefined || apiKey === '') {
            throw new Error('GEMINI_API_KEY environment variable is not set or is empty.');
        }
        this.genAI = new GoogleGenAI({ apiKey });
        this.modelName = 'gemini-2.0-flash-lite-001';
    }
    /**
    * Makes an API request to generate content based on the provided prompt and configuration.
    * @example
    * makeRequest('Create a poem about nature', { temperature: 0.7 })
    * Returns a promise that resolves to a GeminiResponse containing the generated text and token usage.
    * @param {string} prompt - The input prompt for content generation.
    * @param {GeminiApiConfig} config - Configuration settings for the API request, such as temperature. Defaults to an empty object.
    * @returns {Promise&lt;GeminiResponse&lt;T&gt;&gt;} A promise that resolves to a GeminiResponse with the generated content or an error message.
    * @description
    *   - The function calculates the number of tokens used for tracking purposes, even in case of an error.
    *   - The `temperature` parameter affects the randomness of the content generation, with higher values resulting in more creative outputs.
    *   - API usage is tracked asynchronously, and warnings are logged if tracking fails.
    *   - Returns an object indicating success status, the generated content or error message, and the number of tokens used.
    */
    async makeRequest(prompt, config = {}) {
        let textOutput = '';
        try {
            const sdkResponse = await this.genAI.models.generateContent({
                model: this.modelName,
                contents: [{ role: 'user', parts: [{ text: prompt }] }],
                config: { temperature: config.temperature ?? 0 },
            });
            textOutput = sdkResponse.text ?? '';
            const tokensUsed = sdkResponse.usageMetadata?.totalTokenCount ??
                Math.ceil((prompt.length + textOutput.length) / 4);
            // Track usage asynchronously
            APIUsageService.trackUsage('gemini', 1, tokensUsed).catch((error) =&gt; {
                console.warn('Failed to track API usage:', error);
            });
            return {
                success: true,
                data: textOutput,
                tokensUsed,
            };
        }
        catch (error) {
            const tokensUsed = Math.ceil((prompt.length + (error instanceof Error ? error.message.length : String(error).length)) /
                4);
            return {
                success: false,
                error: error instanceof Error ? error.message : 'Unknown error',
                tokensUsed,
            };
        }
    }
    /**
     * Executes a request using a specified prompt and attempts to parse the response using the provided parser function.
     * @example
     * makeRequestWithParsing(&quot;example prompt&quot;, (text) =&gt; JSON.parse(text))
     * { success: true, data: { key: &quot;value&quot; }, tokensUsed: 100 }
     * @param {string} prompt - The prompt used to make the API request.
     * @param {function} parser - A function to parse the response text into the desired format.
     * @param {GeminiApiConfig} config - Optional configuration settings for the Gemini API request.
     * @returns {Promise&lt;GeminiResponse&lt;T&gt;&gt;} A promise resolving to a GeminiResponse object containing either the parsed data or an error description.
     * @description
     *   - The function makes an asynchronous request using a specific prompt string and configuration.
     *   - If the response is unsuccessful, it returns the original response cast to the expected return type.
     *   - Parses the successful response data using the provided parser function.
     *   - Handles parsing errors gracefully, returning a detailed error message and logs the raw problematic response.
     */
    async makeRequestWithParsing(prompt, parser, config = {}) {
        const response = await this.makeRequest(prompt, config);
        if (!response.success) {
            return response;
        }
        try {
            if (!response.data) {
                return {
                    success: false,
                    error: 'No data received from Gemini API',
                    tokensUsed: response.tokensUsed,
                };
            }
            const parsedData = parser(response.data);
            return {
                success: true,
                data: parsedData,
                tokensUsed: response.tokensUsed,
            };
        }
        catch (parseError) {
            console.warn('Gemini json parsing error:', parseError);
            console.warn('Problematic Gemini raw response text:', response.data?.trim() ?? 'No data');
            return {
                success: false,
                error: `Failed to parse Gemini response: ${parseError instanceof Error ? parseError.message : String(parseError)}. Response text: ${response.data?.trim().slice(0, 200) ?? 'No data'}...`,
                tokensUsed: response.tokensUsed,
            };
        }
    }
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/data-quality/placeholderUtils.js (Line 1:1 - Line 141:2), C:/AI/food-truck-finder-poc/dist/lib/lib/data-quality/placeholderUtils.js (Line 1:1 - Line 141:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn513" onclick="toggleCodeBlock('cloneGroup513', 'expandBtn513', 'collapseBtn513')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn513" onclick="toggleCodeBlock('cloneGroup513', 'expandBtn513', 'collapseBtn513')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup513"><code class="language-javascript text-sm text-gray-800">/**
* Returns an array of regular expressions that identify placeholder patterns.
* @example
* getPlaceholderPatterns()
* [ /undefined/i, /placeholder/i, /example\.com/i, /test\s*truck/i, /lorem\s*ipsum/i, /\bna\b/i, /\bn\/a\b/i, /^0+$/, /^null$/i ]
* @returns {RegExp[]} An array of regular expressions to match various placeholder values.
* @description
*   - Regular expressions cover common placeholder values used in data.
*   - Patterns are designed to be case insensitive to support a wider range of inputs.
*   - Contains specific patterns like 'example.com' to catch domain placeholders.
*   - Includes matches for numeric placeholders like '000...' and 'null'.
*/
export function getPlaceholderPatterns() {
    return [
        /undefined/i,
        /placeholder/i,
        /example\.com/i,
        /test\s*truck/i,
        /lorem\s*ipsum/i,
        /\bna\b/i,
        /\bn\/a\b/i,
        /^0+$/,
        /^null$/i,
    ];
}
/**
* Checks the food truck's properties for placeholder patterns and sets them to undefined if a pattern is found.
* @example
* checkForPlaceholders(foodTruckObj, [/\b(?:N\/A|TBD|Unknown)\b/, /^{.+}$/])
* {name: undefined, description: undefined}
* @param {FoodTruck} truck - The food truck object which may contain placeholder text in its properties.
* @param {RegExp[]} patterns - Array of regex patterns used to test against food truck properties.
* @returns {Partial&lt;FoodTruck&gt;} A partial food truck object with properties set to undefined if placeholders are detected.
* @description
*   - The function does not modify the original truck object; it returns a new one.
*   - Handles undefined properties seamlessly to prevent errors during regex testing.
*   - Assumes that the RegExp provided will effectively identify placeholder patterns.
*/
export function checkForPlaceholders(truck, patterns) {
    const updates = {};
    if (truck.name &amp;&amp; patterns.some((pattern) =&gt; pattern.test(truck.name ?? ''))) {
        updates.name = undefined;
    }
    if (truck.description != undefined &amp;&amp;
        patterns.some((pattern) =&gt; pattern.test(truck.description ?? ''))) {
        updates.description = undefined;
    }
    if (truck.price_range != undefined &amp;&amp;
        patterns.some((pattern) =&gt; pattern.test(truck.price_range ?? ''))) {
        updates.price_range = undefined;
    }
    return updates;
}
/**
* Processes a FoodTruck object for placeholders and returns updates.
* @example
* processTruckForPlaceholders(truck, [/pattern1/g, /pattern2/g])
* { name: 'Updated Truck Name', address: 'Updated Address' }
* @param {FoodTruck} truck - The FoodTruck object to be processed for placeholders.
* @param {Array&lt;RegExp&gt;} patterns - Array of regular expressions to identify placeholders.
* @returns {Partial&lt;FoodTruck&gt;} An object containing the updated fields of the FoodTruck.
* @description
*   - Performs checks for placeholders in basic information of the truck.
*   - Processes contact information of the FoodTruck for placeholders.
*   - Assesses and updates address details for placeholders.
*   - Combines updates from basic, contact, and address information into a single object.
*/
export function processTruckForPlaceholders(truck, patterns) {
    const basicInfoUpdates = checkForPlaceholders(truck, patterns);
    const contactInfoUpdates = processContactInfoForPlaceholders(truck, patterns);
    const addressUpdates = processAddressForPlaceholders(truck, patterns);
    const updates = {
        ...basicInfoUpdates,
        ...getContactInfoUpdates(truck, contactInfoUpdates),
        ...getLocationUpdates(truck, addressUpdates),
    };
    return updates;
}
function getContactInfoUpdates(truck, contactInfoUpdates) {
    if (Object.keys(contactInfoUpdates).length &gt; 0) {
        return { contact_info: { ...truck.contact_info, ...contactInfoUpdates } };
    }
    return {};
}
function getLocationUpdates(truck, addressUpdates) {
    if (Object.keys(addressUpdates).length &gt; 0) {
        return { current_location: { ...truck.current_location, ...addressUpdates } };
    }
    return {};
}
/**
* Filters contact information of a food truck based on specified patterns.
* @example
* processContactInfoForPlaceholders(truck, patterns)
* returns filtered contact info with some fields possibly undefined
* @param {FoodTruck} truck - The food truck object containing contact information.
* @param {RegExp[]} patterns - Array of regular expressions to match against contact info.
* @returns {Partial&lt;FoodTruck['contact_info']&gt;} Returns contact information with fields set to undefined if they match any pattern.
* @description
*   - Checks phone, website, and email properties for matches with given patterns.
*   - Sets properties to undefined if they match any pattern.
*/
function processContactInfoForPlaceholders(truck, patterns) {
    const cleanContact = {};
    if (truck.contact_info?.phone !== undefined &amp;&amp;
        patterns.some((pattern) =&gt; pattern.test(truck.contact_info.phone ?? ''))) {
        cleanContact.phone = undefined;
    }
    if (truck.contact_info?.website !== undefined &amp;&amp;
        patterns.some((pattern) =&gt; pattern.test(truck.contact_info.website ?? ''))) {
        cleanContact.website = undefined;
    }
    if (truck.contact_info?.email !== undefined &amp;&amp;
        patterns.some((pattern) =&gt; pattern.test(truck.contact_info.email ?? ''))) {
        cleanContact.email = undefined;
    }
    return cleanContact;
}
/**
 * Processes the current location of a food truck by checking against patterns and updating placeholders.
 * @example
 * const truck = { current_location: { address: '123 Fake St' } };
 * const patterns = [/Fake/];
 * processAddressForPlaceholders(truck, patterns);
 * // Returns: { address: undefined }
 * @param {FoodTruck} truck - The food truck object containing the current location data.
 * @param {RegExp[]} patterns - An array of regular expression patterns used to identify placeholders in the address.
 * @returns {Partial&lt;FoodTruck['current_location']&gt;} An object containing the updated location data with address potentially set to undefined.
 * @description
 *   - The function checks whether the address of the food truck's current location matches any of the provided RegExp patterns.
 *   - If a match is found, the address in the returned object is set to undefined.
 *   - It ensures details of the truck's location can be sanitized by placeholder detection.
 */
function processAddressForPlaceholders(truck, patterns) {
    const updatedLocation = {};
    if (truck.current_location?.address !== undefined &amp;&amp;
        patterns.some((pattern) =&gt; pattern.test(truck.current_location.address ?? ''))) {
        updatedLocation.address = undefined;
    }
    return updatedLocation;
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/data-quality/duplicatePrevention.js (Line 5:17 - Line 347:2), C:/AI/food-truck-finder-poc/dist/lib/lib/data-quality/duplicatePrevention.js (Line 5:27 - Line 347:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn515" onclick="toggleCodeBlock('cloneGroup515', 'expandBtn515', 'collapseBtn515')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn515" onclick="toggleCodeBlock('cloneGroup515', 'expandBtn515', 'collapseBtn515')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup515"><code class="language-javascript text-sm text-gray-800">;
// Duplicate detection configuration
export const DUPLICATE_DETECTION_CONFIG = {
    // Similarity thresholds (0.0 = no match, 1.0 = exact match)
    thresholds: {
        name: 0.85, // High threshold for name matching
        location: 0.9, // Very high threshold for location matching
        phone: 1, // Exact match for phone numbers
        website: 1, // Exact match for websites
        overall: 0.8, // Overall similarity threshold
    },
    // Weight factors for different fields
    weights: {
        name: 0.4, // 40% weight for name similarity
        location: 0.3, // 30% weight for location similarity
        contact: 0.2, // 20% weight for contact info similarity
        menu: 0.1, // 10% weight for menu similarity
    },
};
/**
 * Advanced Duplicate Prevention Service
 */
export class DuplicatePreventionService {
    /**
     * Check if a food truck is a duplicate of existing trucks
     */
    static async checkForDuplicates(candidateTruck) {
        try {
            // Get all existing trucks for comparison
            const existingTrucksResult = await FoodTruckService.getAllTrucks();
            if ('error' in existingTrucksResult) {
                console.error('Error fetching existing trucks:', existingTrucksResult.error);
                return {
                    isDuplicate: false,
                    matches: [],
                    action: 'create',
                    reason: `Error fetching existing trucks: ${existingTrucksResult.error}`,
                };
            }
            const existingTrucks = existingTrucksResult.trucks;
            const matches = [];
            for (const existingTruck of existingTrucks) {
                const similarity = this.calculateSimilarity(candidateTruck, existingTruck);
                if (similarity.overall &gt;= DUPLICATE_DETECTION_CONFIG.thresholds.overall) {
                    matches.push({
                        existingTruck,
                        similarity: similarity.overall,
                        matchedFields: similarity.matchedFields,
                        confidence: this.getConfidenceLevel(similarity.overall),
                        recommendation: this.getRecommendation(similarity),
                    });
                }
            }
            return this.processDuplicateMatches(matches, candidateTruck);
        }
        catch (error) {
            console.error('Error checking for duplicates:', error);
            return {
                isDuplicate: false,
                matches: [],
                action: 'create',
                reason: 'An unexpected error occurred during duplicate detection - proceeding with creation',
            };
        }
    }
    /**
     * Processes the matches found during duplicate detection and returns the result.
     */
    static processDuplicateMatches(matches, candidateTruck) {
        // Sort matches by similarity (highest first)
        matches.sort((a, b) =&gt; b.similarity - a.similarity);
        const bestMatch = matches.length &gt; 0 ? matches[0] : undefined;
        const isDuplicate = matches.length &gt; 0;
        return {
            isDuplicate,
            matches,
            bestMatch,
            action: this.determineAction(matches, candidateTruck),
            reason: this.generateReason(matches, candidateTruck),
        };
    }
    /**
     * Calculate similarity between two food trucks
     */
    static calculateSimilarity(candidate, existing) {
        const breakdown = {};
        const matchedFields = [];
        // Name similarity
        const nameSimilarity = this.calculateStringSimilarity(candidate.name ?? '', existing.name ?? '');
        breakdown.name = nameSimilarity;
        if (nameSimilarity &gt;= DUPLICATE_DETECTION_CONFIG.thresholds.name) {
            matchedFields.push('name');
        }
        // Location similarity
        const locationSimilarity = this.calculateLocationSimilarity(candidate.current_location, existing.current_location);
        breakdown.location = locationSimilarity;
        if (locationSimilarity &gt;= DUPLICATE_DETECTION_CONFIG.thresholds.location) {
            matchedFields.push('location');
        }
        // Contact similarity
        const contactSimilarity = this.calculateContactSimilarity(candidate.contact_info, existing.contact_info);
        breakdown.contact = contactSimilarity;
        if (contactSimilarity &gt;= DUPLICATE_DETECTION_CONFIG.thresholds.phone) {
            matchedFields.push('contact');
        }
        // Menu similarity (basic)
        const menuSimilarity = this.calculateMenuSimilarity(candidate.menu, existing.menu);
        breakdown.menu = menuSimilarity;
        if (menuSimilarity &gt; 0.7) {
            matchedFields.push('menu');
        }
        // Calculate weighted overall similarity
        const overall = nameSimilarity * DUPLICATE_DETECTION_CONFIG.weights.name +
            locationSimilarity * DUPLICATE_DETECTION_CONFIG.weights.location +
            contactSimilarity * DUPLICATE_DETECTION_CONFIG.weights.contact +
            menuSimilarity * DUPLICATE_DETECTION_CONFIG.weights.menu;
        return { overall, matchedFields, breakdown };
    }
    /**
     * Calculate string similarity using Levenshtein distance
     */
    static calculateStringSimilarity(str1, str2) {
        if (!str1 || !str2)
            return 0;
        // Normalize strings
        const s1 = str1.toLowerCase().trim();
        const s2 = str2.toLowerCase().trim();
        if (s1 === s2)
            return 1;
        // Calculate Levenshtein distance
        const matrix = [];
        const len1 = s1.length;
        const len2 = s2.length;
        for (let i = 0; i &lt;= len1; i += 1) {
            matrix[i] = [i];
        }
        for (let j = 0; j &lt;= len2; j += 1) {
            matrix[0][j] = j;
        }
        for (let i = 1; i &lt;= len1; i += 1) {
            // eslint-disable-next-line sonarjs/no-redundant-assignments
            for (let j = 1; j &lt;= len2; j += 1) {
                const cost = s1[i - 1] === s2[j - 1] ? 0 : 1;
                matrix[i][j] = Math.min(matrix[i - 1][j] + 1, // deletion
                matrix[i][j - 1] + 1, // insertion
                matrix[i - 1][j - 1] + cost);
            }
        }
        const distance = matrix[len1][len2];
        const maxLength = Math.max(len1, len2);
        return maxLength === 0 ? 1 : 1 - distance / maxLength;
    }
    /**
     * Calculate location similarity
     */
    static calculateLocationSimilarity(loc1, loc2) {
        if (!loc1 || !loc2)
            return 0;
        let similarity = 0;
        let factors = 0;
        // Address similarity
        if (loc1.address &amp;&amp; loc2.address) {
            similarity += this.calculateStringSimilarity(loc1.address, loc2.address);
            factors += 1;
        }
        // GPS coordinate similarity (within 100 meters = high similarity)
        if (loc1.lat &amp;&amp; loc1.lng &amp;&amp; loc2.lat &amp;&amp; loc2.lng) {
            const distance = this.calculateGPSDistance(loc1.lat, loc1.lng, loc2.lat, loc2.lng);
            // Distance similarity (closer = higher similarity)
            const distanceSimilarity = distance &lt;= 0.1 ? 1 : Math.max(0, 1 - distance / 1); // 1km max
            similarity += distanceSimilarity;
            factors += 1;
        }
        return factors &gt; 0 ? similarity / factors : 0;
    }
    /**
     * Calculate GPS distance in kilometers
     */
    static calculateGPSDistance(lat1, lng1, lat2, lng2) {
        const R = 6371; // Earth's radius in kilometers
        const dLat = ((lat2 - lat1) * Math.PI) / 180;
        const dLng = ((lng2 - lng1) * Math.PI) / 180;
        const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
            Math.cos((lat1 * Math.PI) / 180) *
                Math.cos((lat2 * Math.PI) / 180) *
                Math.sin(dLng / 2) *
                Math.sin(dLng / 2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        return R * c;
    }
    /**
     * Calculate contact similarity
     */
    static calculateContactSimilarity(contact1, contact2) {
        if (!contact1 || !contact2)
            return 0;
        let matches = 0;
        let total = 0;
        // Phone number exact match
        if (contact1.phone != undefined &amp;&amp; contact2.phone != undefined) {
            const phone1 = contact1.phone.replaceAll(/\D/g, ''); // Remove non-digits
            const phone2 = contact2.phone.replaceAll(/\D/g, '');
            if (phone1 === phone2)
                matches += 1;
            total += 1;
        }
        // Website exact match
        if (contact1.website != undefined &amp;&amp; contact2.website != undefined) {
            const url1 = contact1.website
                .toLowerCase()
                .replace(/^https?:\/\//, '')
                .replace(/\/$/, '');
            const url2 = contact2.website
                .toLowerCase()
                .replace(/^https?:\/\//, '')
                .replace(/\/$/, '');
            if (url1 === url2)
                matches += 1;
            total += 1;
        }
        // Email similarity
        if (contact1.email != undefined &amp;&amp; contact2.email != undefined) {
            if (contact1.email.toLowerCase() === contact2.email.toLowerCase())
                matches += 1;
            total += 1;
        }
        return total &gt; 0 ? matches / total : 0;
    }
    /**
     * Calculate menu similarity (basic implementation)
     */
    static calculateMenuSimilarity(menu1, menu2) {
        if (!menu1 || !menu2 || menu1.length === 0 || menu2.length === 0)
            return 0;
        // Simple category name matching
        const categories1 = menu1
            .map((cat) =&gt; cat.category?.toLowerCase() ?? '')
            .filter(Boolean);
        const categories2 = menu2
            .map((cat) =&gt; cat.category?.toLowerCase() ?? '')
            .filter(Boolean);
        const commonCategories = categories1.filter((cat) =&gt; categories2.includes(cat));
        const totalCategories = new Set([...categories1, ...categories2]).size;
        return totalCategories &gt; 0 ? commonCategories.length / totalCategories : 0;
    }
    /**
     * Get confidence level based on similarity score
     */
    static getConfidenceLevel(similarity) {
        if (similarity &gt;= 0.95)
            return 'high';
        if (similarity &gt;= 0.85)
            return 'medium';
        return 'low';
    }
    /**
     * Get recommendation based on similarity analysis
     */
    static getRecommendation(similarity) {
        if (similarity.overall &gt;= 0.95)
            return 'merge';
        if (similarity.overall &gt;= 0.9)
            return 'update';
        if (similarity.overall &gt;= 0.8)
            return 'manual_review';
        return 'skip';
    }
    /**
     * Determine action based on matches
     */
    static determineAction(matches, _candidate) {
        if (matches.length === 0)
            return 'create';
        const bestMatch = matches[0];
        if (bestMatch.confidence === 'high') {
            const { recommendation } = bestMatch;
            if (recommendation === 'merge' || recommendation === 'update') {
                return recommendation;
            }
            return 'manual_review';
        }
        return 'manual_review';
    }
    /**
     * Generate human-readable reason
     */
    static generateReason(matches, _candidate) {
        if (matches.length === 0) {
            return 'No duplicates found - safe to create new truck entry';
        }
        const bestMatch = matches[0];
        const similarity = Math.round(bestMatch.similarity * 100);
        return `Found ${matches.length} potential duplicate(s). Best match: ${similarity}% similarity with &quot;${bestMatch.existingTruck.name}&quot; (matched: ${bestMatch.matchedFields.join(', ')})`;
    }
    /**
     * Merge duplicate truck data intelligently
     */
    static async mergeDuplicates(targetId, sourceId) {
        const targetResult = await FoodTruckService.getTruckById(targetId);
        const sourceResult = await FoodTruckService.getTruckById(sourceId);
        if ('error' in targetResult) {
            return {
                error: `Failed to retrieve target truck with ID ${targetId}: ${targetResult.error}`,
            };
        }
        if ('error' in sourceResult) {
            return {
                error: `Failed to retrieve source truck with ID ${sourceId}: ${sourceResult.error}`,
            };
        }
        const target = targetResult;
        const source = sourceResult;
        // Merge logic: prefer non-null, more complete data
        const mergedData = {
            name: target.name ?? source.name,
            description: target.description ?? source.description,
            cuisine_type: (target.cuisine_type?.length ?? 0) &gt; 0 ? target.cuisine_type : source.cuisine_type,
            price_range: target.price_range ?? source.price_range,
            current_location: target.current_location ?? source.current_location,
            contact_info: {
                ...source.contact_info,
                ...target.contact_info, // Target takes precedence
            },
            operating_hours: target.operating_hours ?? source.operating_hours,
            menu: (target.menu?.length ?? 0) &gt; 0 ? target.menu : source.menu,
            social_media: {
                ...source.social_media,
                ...target.social_media,
            },
            source_urls: [...new Set([...(target.source_urls ?? []), ...(source.source_urls ?? [])])],
            last_scraped_at: new Date().toISOString(),
        };
        // Update target with merged data
        const updatedTruckResult = await FoodTruckService.updateTruck(targetId, mergedData);
        if ('error' in updatedTruckResult) {
            return {
                error: `Failed to update target truck with merged data: ${updatedTruckResult.error}`,
            };
        }
        console.info(`Merged truck ${sourceId} into ${targetId}`);
        return updatedTruckResult;
    }
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/data-quality/batchCleanup.js (Line 5:17 - Line 505:2), C:/AI/food-truck-finder-poc/dist/lib/lib/data-quality/batchCleanup.js (Line 5:27 - Line 505:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn517" onclick="toggleCodeBlock('cloneGroup517', 'expandBtn517', 'collapseBtn517')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn517" onclick="toggleCodeBlock('cloneGroup517', 'expandBtn517', 'collapseBtn517')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup517"><code class="language-javascript text-sm text-gray-800">;
import { DuplicatePreventionService } from './duplicatePrevention';
import { getPlaceholderPatterns, processTruckForPlaceholders } from './placeholderUtils';
/**
 * Automated Data Quality Cleanup Service
 */
export class BatchCleanupService {
    /**
     * Run comprehensive data cleanup operations
     */
    static async runFullCleanup(options = {}) {
        const startTime = Date.now();
        const { batchSize = 50, dryRun = false, operations = [
            'remove_placeholders',
            'normalize_phone',
            'fix_coordinates',
            'update_quality_scores',
            'merge_duplicates',
        ], } = options;
        console.info(`Starting batch cleanup (${dryRun ? 'DRY RUN' : 'LIVE'})...`);
        const result = this.initializeCleanupResult();
        try {
            const allTrucks = await FoodTruckService.getAllTrucks();
            result.totalProcessed = allTrucks.total;
            await this.processTrucksInBatches(allTrucks.trucks, {
                batchSize,
                operations,
                dryRun,
                result,
            });
            return this.finalizeCleanupResult(result, startTime);
        }
        catch (error) {
            console.error('Batch cleanup failed:', error);
            throw error;
        }
    }
    /**
    * Initializes and returns a new BatchCleanupResult object with default values.
    * @example
    * initializeCleanupResult()
    * { totalProcessed: 0, operations: [], summary: { trucksImproved: 0, duplicatesRemoved: 0, qualityScoreImprovement: 0, placeholdersRemoved: 0 }, duration: 0 }
    * @returns {BatchCleanupResult} A new BatchCleanupResult object with all properties set to initial default values.
    */
    static initializeCleanupResult() {
        return {
            totalProcessed: 0,
            operations: [],
            summary: {
                trucksImproved: 0,
                duplicatesRemoved: 0,
                qualityScoreImprovement: 0,
                placeholdersRemoved: 0,
            },
            duration: 0,
        };
    }
    static finalizeCleanupResult(result, startTime) {
        result.summary = this.calculateSummary(result.operations);
        result.duration = Date.now() - startTime;
        console.info(`Batch cleanup completed in ${result.duration}ms`);
        return result;
    }
    /**
     * Processes food trucks in batches, executing specified operations on each batch.
     * @example
     * processTrucksInBatches(truckList, { batchSize: 10, operations: ['clean'], dryRun: true, result: batchResult })
     * // It executes 'clean' operation on batches of 10 trucks without making permanent changes.
     * @param {FoodTruck[]} trucks - Array of food trucks to be processed in batches.
     * @param {object} options - Options object containing batchSize, operations, dryRun, and result.
     * @param {number} options.batchSize - Number of trucks in each batch.
     * @param {CleanupOperation['type'][]} options.operations - Array of operation types to be executed on each batch.
     * @param {boolean} options.dryRun - If true, operations are executed in simulation mode without permanent changes.
     * @param {BatchCleanupResult} options.result - Stores the results of operations performed on batches.
     * @returns {Promise&lt;void&gt;} Completes processing batches without a return value.
     * @description
     *   - Uses async function to allow non-blocking execution of operations.
     *   - Collects and stores results of batch operations separately, keeping track of each operation's outcome.
     *   - Iterates over arrays using slicing to dynamically create batches for processing.
     */
    static async processTrucksInBatches(trucks, { batchSize, operations, dryRun, result, }) {
        for (let i = 0; i &lt; trucks.length; i += batchSize) {
            const batch = trucks.slice(i, i + batchSize);
            for (const op of operations) {
                const opResult = await this.runOperation(op, batch, dryRun);
                result.operations.push(opResult);
            }
        }
    }
    /**
     * Run a specific cleanup operation
     */
    static async runOperation(type, trucks, dryRun) {
        const operation = {
            type,
            description: this.getOperationDescription(type),
            affectedCount: 0,
            successCount: 0,
            errorCount: 0,
            errors: [],
        };
        const operationRunners = {
            remove_placeholders: this.runRemovePlaceholders,
            normalize_phone: this.runNormalizePhoneNumbers,
            fix_coordinates: this.runFixCoordinates,
            update_quality_scores: this.runUpdateQualityScores,
            merge_duplicates: this.runMergeDuplicates,
        };
        try {
            const runner = operationRunners[type];
            if (runner) {
                return await runner.call(this, trucks, dryRun, operation);
            }
            operation.errors.push(`Unknown operation type: ${String(type)}`);
            return operation;
        }
        catch (error) {
            operation.errors.push(`Operation failed: ${error instanceof Error ? error.message : String(error)}`);
            return operation;
        }
    }
    static runRemovePlaceholders = async (trucks, dryRun, operation) =&gt; {
        return await this.removePlaceholders(trucks, dryRun, operation);
    };
    static runNormalizePhoneNumbers = async (trucks, dryRun, operation) =&gt; {
        return await this.normalizePhoneNumbers(trucks, dryRun, operation);
    };
    static runFixCoordinates = async (trucks, dryRun, operation) =&gt; {
        return await this.fixCoordinates(trucks, dryRun, operation);
    };
    static runUpdateQualityScores = async (trucks, dryRun, operation) =&gt; {
        return await this.updateQualityScores(trucks, dryRun, operation);
    };
    static runMergeDuplicates = async (trucks, dryRun, operation) =&gt; {
        return await this.mergeDuplicates(trucks, dryRun, operation);
    };
    /**
     * Remove placeholder and mock data
     */
    static async removePlaceholders(trucks, dryRun, operation) {
        const placeholderPatterns = getPlaceholderPatterns();
        const promises = trucks.map((truck) =&gt; this.processSingleTruckForPlaceholders(truck, placeholderPatterns, dryRun, operation));
        await Promise.all(promises);
        return operation;
    }
    static async processSingleTruckForPlaceholders(truck, patterns, dryRun, operation) {
        const updates = processTruckForPlaceholders(truck, patterns);
        if (updates &amp;&amp; Object.keys(updates).length &gt; 0) {
            await this.performUpdateOperation(truck.id, updates, dryRun, operation);
        }
    }
    /**
     * Perform an update operation on a specified food truck.
     * @example
     * performUpdateOperation('truck123', { name: 'New Name' }, true, cleanupOperation)
     * // No direct return value; operation may log errors.
     * @param {string} truckId - The unique identifier of the food truck to be updated.
     * @param {Partial&lt;FoodTruck&gt;} updates - An object containing the fields to be updated.
     * @param {boolean} dryRun - Flag indicating whether the operation should be a simulation without actual changes.
     * @param {CleanupOperation} operation - An operation object that logs errors encountered during update.
     * @returns {Promise&lt;void&gt;} A promise that resolves when the update operation is complete.
     * @description
     *   - If 'dryRun' is true, no updates are applied but actions are logged.
     *   - Errors during update are caught and logged in the 'operation.errors' array.
     */
    static async performUpdateOperation(truckId, updates, dryRun, operation) {
        operation.affectedCount += 1;
        if (dryRun) {
            operation.successCount += 1;
        }
        else {
            try {
                await FoodTruckService.updateTruck(truckId, updates);
                operation.successCount += 1;
            }
            catch (error) {
                operation.errorCount += 1;
                operation.errors.push(`Failed to update truck ${truckId}: ${error instanceof Error ? error.message : String(error)}`);
            }
        }
    }
    /**
     * Normalize phone numbers to consistent format
     */
    static async normalizePhoneNumbers(trucks, dryRun, operation) {
        const promises = trucks.map((truck) =&gt; {
            if (truck.contact_info?.phone !== undefined) {
                const originalPhone = truck.contact_info.phone;
                const normalizedPhone = this.normalizePhone(originalPhone);
                if (normalizedPhone !== undefined &amp;&amp; normalizedPhone !== originalPhone) {
                    return this.applyPhoneNormalizationUpdate(truck, normalizedPhone, dryRun, operation);
                }
            }
            return Promise.resolve();
        });
        await Promise.all(promises);
        return operation;
    }
    /**
     * Apply phone normalization update to a food truck's contact information.
     * @example
     * applyPhoneNormalizationUpdate(truckInstance, '+1234567890', false, operationInstance)
     * // Normalizes and updates phone number of given truckInstance.
     * @param {FoodTruck} truck - The food truck object whose phone number needs normalization.
     * @param {string} normalizedPhone - The normalized phone number to update to the food truck's contact information.
     * @param {boolean} dryRun - Flag indicating whether the operation is a dry run; updates are skipped if true.
     * @param {CleanupOperation} operation - Object containing cleanup operation context including a record of errors.
     * @returns {Promise&lt;void&gt;} Does not return a value, but potentially modifies the truck and operation objects.
     * @description
     *   - Executes the update operation only if `dryRun` is false.
     *   - Pushes error messages to `operation.errors` on failure during the update process.
     *   - Uses `FoodTruckService.updateTruck` for updating the contact information.
     */
    static async applyPhoneNormalizationUpdate(truck, normalizedPhone, dryRun, operation) {
        operation.affectedCount += 1;
        if (dryRun) {
            operation.successCount += 1;
        }
        else {
            try {
                await FoodTruckService.updateTruck(truck.id, {
                    contact_info: {
                        ...truck.contact_info,
                        phone: normalizedPhone,
                    },
                });
                operation.successCount += 1;
            }
            catch (error) {
                operation.errorCount += 1;
                operation.errors.push(`Failed to normalize phone for truck ${truck.id}: ${error instanceof Error ? error.message : String(error)}`);
            }
        }
    }
    /**
     * Helper to determine if coordinates need fixing and provide updates
     */
    static getFixedCoordinates(lat, lng, defaultLat, defaultLng) {
        // Fix invalid coordinates (0,0 or undefined)
        if (lat === undefined || lng === undefined || lat === 0 || lng === 0) {
            return { lat: defaultLat, lng: defaultLng };
        }
        // Fix coordinates outside reasonable bounds for Charleston area
        if (lat &lt; 32 || lat &gt; 34 || lng &gt; -79 || lng &lt; -81) {
            return { lat: defaultLat, lng: defaultLng };
        }
        return undefined;
    }
    /**
     * Fix invalid GPS coordinates
     */
    static async fixCoordinates(trucks, dryRun, operation) {
        const context = {
            defaultLat: 32.7767,
            defaultLng: -79.9311,
            dryRun,
        };
        const promises = trucks.map((truck) =&gt; this.processSingleTruckCoordinates(truck, { ...context, operation }));
        await Promise.all(promises);
        return operation;
    }
    /**
     * Processes coordinates for a single food truck, applying any necessary fixes.
     * @example
     * processSingleTruckCoordinates(truck, context)
     * // No return value, function completes silently
     * @param {FoodTruck} truck - The food truck whose coordinates are to be processed.
     * @param {CoordinateProcessContext} context - Contains configuration and operation context for processing coordinates.
     * @returns {Promise&lt;void&gt;} Returns a promise that resolves when the processing and possible updates are complete.
     * @description
     *   - Skips processing if the truck's current location is not available.
     *   - Retrieves updates for fixed coordinates based on truck's current and default locations.
     *   - Applies updates conditionally based on context settings such as `dryRun` and `operation`.
     */
    static async processSingleTruckCoordinates(truck, context) {
        if (!truck.current_location)
            return;
        const { defaultLat, defaultLng, dryRun, operation } = context;
        const { lat, lng } = truck.current_location;
        const updates = this.getFixedCoordinates(lat, lng, defaultLat, defaultLng);
        if (updates) {
            await this.applyCoordinateFixUpdate(truck, updates, dryRun, operation);
        }
    }
    /**
     * Applies coordinate updates for a food truck's current location.
     * @example
     * applyCoordinateFixUpdate(truck, { lat: 34.05, lng: -118.25 }, false, operation)
     * // Updates the coordinates of the truck's location asynchronously.
     * @param {FoodTruck} truck - The food truck object whose coordinates need correction.
     * @param {Partial&lt;FoodTruck['current_location']&gt;} updates - The latitude and longitude updates to be applied.
     * @param {boolean} dryRun - Flag to simulate the update without altering data.
     * @param {CleanupOperation} operation - The cleanup operation instance used for error tracking.
     * @returns {Promise&lt;void&gt;} Resolves when the coordinate update process is complete.
     * @description
     *   - Executes the update operation only if the dryRun flag is false.
     *   - If the update fails, logs the error details into the operation's error array.
     */
    static async applyCoordinateFixUpdate(truck, updates, dryRun, operation) {
        operation.affectedCount += 1;
        if (dryRun) {
            operation.successCount += 1;
        }
        else {
            try {
                await FoodTruckService.updateTruck(truck.id, {
                    current_location: {
                        ...truck.current_location,
                        ...updates,
                    },
                });
                operation.successCount += 1;
            }
            catch (error) {
                operation.errorCount += 1;
                operation.errors.push(`Failed to fix coordinates for truck ${truck.id}: ${error instanceof Error ? error.message : String(error)}`);
            }
        }
    }
    /**
     * Update quality scores for all trucks
     */
    static async updateQualityScores(trucks, dryRun, operation) {
        const promises = trucks.map((truck) =&gt; this.processSingleTruckForQualityScore(truck, dryRun, operation));
        await Promise.all(promises);
        return operation;
    }
    /**
    * Processes a single food truck for an updated quality score assessment.
    * @example
    * processSingleTruckForQualityScore(truckInstance, false, cleanupOperationInstance)
    * // No return value
    * @param {FoodTruck} truck - The food truck instance to assess and potentially update.
    * @param {boolean} dryRun - Specifies whether this is a dry run (no actual data updates).
    * @param {CleanupOperation} operation - The cleanup operation context for processing.
    * @returns {Promise&lt;void&gt;} No return value; operation is performed asynchronously.
    * @description
    *   - Computes the quality score using data from DataQualityService.
    *   - Updates the quality score only if the score changes significantly (&gt;5% difference).
    *   - Assumes `truck.data_quality_score` might be undefined, defaulting to 0.
    *   - Handles asynchronous processing of the update application if conditions are met.
    */
    static async processSingleTruckForQualityScore(truck, dryRun, operation) {
        const qualityAssessment = DataQualityService.calculateQualityScore(truck);
        if (qualityAssessment) {
            const newScore = qualityAssessment.score;
            const currentScore = truck.data_quality_score ?? 0;
            // Only update if score changed significantly (&gt;5% difference)
            if (typeof newScore === 'number' &amp;&amp; Math.abs(newScore - currentScore) &gt; 0.05) {
                await this.applyQualityScoreUpdate(truck, dryRun, operation);
            }
        }
    }
    /**
     * Updates the quality score of a specified food truck and handles errors during the update process.
     * @example
     * applyQualityScoreUpdate(foodTruckInstance, false, cleanupOperationInstance)
     * void
     * @param {FoodTruck} truck - The food truck for which the quality score will be updated.
     * @param {boolean} dryRun - Flag indicating whether the function should perform the update or just simulate it.
     * @param {CleanupOperation} operation - The cleanup operation containing possible error records.
     * @returns {Promise&lt;void&gt;} Resolves with no value when the update completes. Errors are recorded in the `operation` if thrown.
     * @description
     *   - Throws an error if the quality score update fails.
     *   - If `dryRun` is true, the function simulates the update without changing any data.
     *   - Errors occurring during the update are appended to the `operation.errors` array.
     */
    static async applyQualityScoreUpdate(truck, dryRun, operation) {
        operation.affectedCount += 1;
        if (dryRun) {
            operation.successCount += 1;
        }
        else {
            try {
                const updateResult = await DataQualityService.updateTruckQualityScore(truck.id);
                if ('error' in updateResult) {
                    throw new Error(updateResult.error);
                }
                operation.successCount += 1;
            }
            catch (error) {
                operation.errorCount += 1;
                operation.errors.push(`Failed to update quality score for truck ${truck.id}: ${error instanceof Error ? error.message : String(error)}`);
            }
        }
    }
    /**
     * Identify and merge duplicate trucks
     */
    static async mergeDuplicates(trucks, dryRun, operation) {
        const processedIds = new Set();
        for (const truck of trucks) {
            await this.processSingleTruckForDuplicates(truck, dryRun, { operation, processedIds });
        }
        return operation;
    }
    /**
     * Processes a single food truck to detect and handle duplicates in the dataset.
     * @example
     * processSingleTruckForDuplicates(foodTruck, true, mergeContext)
     * // No return value. Performs operations as a side effect.
     * @param {FoodTruck} truck - An instance of FoodTruck to process for duplicates.
     * @param {boolean} dryRun - Flag indicating if the operation should be executed in dry run mode.
     * @param {MergeOperationContext} context - Operational context that carries state and configurations for the merge operation.
     * @returns {Promise&lt;void&gt;} Executes a set of operations for handling duplicate records, does not return any value.
     * @description
     *   - Ensures a food truck is only processed once by maintaining a set of processed IDs.
     *   - Uses DuplicatePreventionService to assess whether the given truck is a duplicate.
     *   - Applies a merge operation if a duplicate truck is confidently identified.
     */
    static async processSingleTruckForDuplicates(truck, dryRun, context) {
        const { processedIds } = context;
        if (processedIds.has(truck.id))
            return;
        const duplicateCheck = await DuplicatePreventionService.checkForDuplicates(truck);
        if (duplicateCheck.isDuplicate &amp;&amp;
            duplicateCheck.bestMatch?.confidence === 'high' &amp;&amp;
            duplicateCheck.bestMatch.recommendation === 'merge') {
            await this.applyMergeOperation(truck, duplicateCheck.bestMatch.existingTruck, dryRun, context);
        }
        processedIds.add(truck.id);
    }
    /**
     * Applies a merge operation between two food trucks and updates the context.
     * @example
     * applyMergeOperation(truck, existingTruck, true, context)
     * // Executes a dry run of the merge operation without affecting data
     * @param {FoodTruck} truck - The food truck that is being merged.
     * @param {FoodTruck} existingTruck - The existing food truck to merge with.
     * @param {boolean} dryRun - Indicates if the merge operation should be simulated.
     * @param {MergeOperationContext} context - Context containing details and state of the merge operation.
     * @returns {Promise&lt;void&gt;} Promise representing the completion of the merge operation.
     * @description
     *   - Updates the list of processed IDs in the context upon successful merge.
     *   - Throws and records an error if the merge operation fails.
     *   - Utilizes the DuplicatePreventionService for performing the merge.
     */
    static async applyMergeOperation(truck, existingTruck, dryRun, context) {
        const { operation, processedIds } = context;
        operation.affectedCount += 1;
        if (dryRun) {
            operation.successCount += 1;
        }
        else {
            try {
                const mergeResult = await DuplicatePreventionService.mergeDuplicates(truck.id, existingTruck.id);
                if ('error' in mergeResult) {
                    throw new Error(mergeResult.error);
                }
                processedIds.add(existingTruck.id);
                operation.successCount += 1;
            }
            catch (error) {
                operation.errorCount += 1;
                operation.errors.push(`Failed to merge duplicates ${truck.id} and ${existingTruck.id}: ${error instanceof Error ? error.message : String(error)}`);
            }
        }
    }
    /**
     * Normalize phone number format
     */
    static normalizePhone(phone) {
        if (!phone)
            return undefined;
        // Remove all non-digit characters
        const digits = phone.replaceAll(/\D/g, '');
        // Handle US phone numbers
        if (digits.length === 10) {
            return `(${digits.slice(0, 3)}) ${digits.slice(3, 6)}-${digits.slice(6)}`;
        }
        if (digits.length === 11 &amp;&amp; digits.startsWith('1')) {
            return `+1 (${digits.slice(1, 4)}) ${digits.slice(4, 7)}-${digits.slice(7)}`;
        }
        // Return original if can't normalize
        return phone;
    }
    /**
     * Get operation description
     */
    static getOperationDescription(type) {
        const descriptions = {
            remove_placeholders: 'Remove placeholder and mock data values',
            normalize_phone: 'Normalize phone numbers to consistent format',
            fix_coordinates: 'Fix invalid GPS coordinates',
            update_quality_scores: 'Recalculate data quality scores',
            merge_duplicates: 'Identify and merge duplicate truck entries',
        };
        return descriptions[type] ?? 'Unknown operation';
    }
    /**
     * Calculate cleanup summary
     */
    static calculateSummary(operations) {
        return {
            trucksImproved: operations.reduce((sum, op) =&gt; sum + op.successCount, 0),
            duplicatesRemoved: operations.find((op) =&gt; op.type === 'merge_duplicates')?.successCount ?? 0,
            qualityScoreImprovement: operations.find((op) =&gt; op.type === 'update_quality_scores')?.successCount ?? 0,
            placeholdersRemoved: operations.find((op) =&gt; op.type === 'remove_placeholders')?.successCount ?? 0,
        };
    }
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/auth/authHelpers.js (Line 1:1 - Line 22:2), C:/AI/food-truck-finder-poc/dist/lib/auth/authHelpers.js (Line 1:1 - Line 22:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn522" onclick="toggleCodeBlock('cloneGroup522', 'expandBtn522', 'collapseBtn522')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn522" onclick="toggleCodeBlock('cloneGroup522', 'expandBtn522', 'collapseBtn522')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup522"><code class="language-javascript text-sm text-gray-800">import { supabase } from '@/lib/supabase';
export async function verifyAdminAccess(request) {
    try {
        const authHeader = request.headers.get('authorization');
        if (!authHeader)
            return false;
        const token = authHeader.replace('Bearer ', '');
        const { data, error } = await supabase.auth.getUser(token);
        const user = data?.user;
        if (error || !user)
            return false;
        const { data: profile } = await supabase
            .from('profiles')
            .select('role')
            .eq('id', user.id)
            .single();
        return profile?.role === 'admin';
    }
    catch {
        return false;
    }
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/supabaseMiddleware.js (Line 1:1 - Line 25:2), C:/AI/food-truck-finder-poc/dist/lib/lib/supabaseMiddleware.js (Line 1:1 - Line 25:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn535" onclick="toggleCodeBlock('cloneGroup535', 'expandBtn535', 'collapseBtn535')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn535" onclick="toggleCodeBlock('cloneGroup535', 'expandBtn535', 'collapseBtn535')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup535"><code class="language-javascript text-sm text-gray-800">import { createClient } from '@supabase/supabase-js';
/**
* Create a Supabase client configured for middleware
* @example
* createSupabaseMiddlewareClient(request, response)
* Supabase client instance
* @param {NextRequest} _req - The incoming Next.js request object (unused).
* @param {NextResponse} _res - The outgoing Next.js response object (unused).
* @returns {SupabaseClient} Supabase client instance configured for middleware usage.
* @description
*   - Utilizes environment variables for Supabase URL and anon key.
*   - Sets `persistSession` to false for non-persistent authentication.
*   - Adds `x-middleware-auth` header for identification in middleware.
*/
export function createSupabaseMiddlewareClient(_req, _res) {
    // Create a Supabase client configured for middleware
    return createClient(process.env.NEXT_PUBLIC_SUPABASE_URL, process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY, {
        auth: {
            persistSession: false,
        },
        global: {
            headers: { 'x-middleware-auth': 'true' },
        },
    });
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/ScraperEngine.js (Line 1:1 - Line 662:2), C:/AI/food-truck-finder-poc/dist/lib/ScraperEngine.js (Line 1:1 - Line 662:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn540" onclick="toggleCodeBlock('cloneGroup540', 'expandBtn540', 'collapseBtn540')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn540" onclick="toggleCodeBlock('cloneGroup540', 'expandBtn540', 'collapseBtn540')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup540"><code class="language-javascript text-sm text-gray-800">import { firecrawl } from './firecrawl.js'; // Import the firecrawl singleton
import * as crypto from 'node:crypto'; // Node.js crypto for secure randomness
// Core scraping engine with anti-detection measures
export class ScraperEngine {
    userAgents;
    requestDelay;
    maxRetries;
    constructor() {
        this.userAgents = [
            'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
            'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
            'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
        ];
        this.requestDelay = 2000;
        this.maxRetries = 3;
    }
    async performFallbackScrape(url) {
        try {
            const response = await fetch(url, { headers: { 'User-Agent': this.getRandomUserAgent() } });
            if (!response.ok) {
                throw new Error(`HTTP error ${response.status}: ${response.statusText} during fallback fetch.`);
            }
            const htmlContent = await response.text();
            return {
                success: true,
                data: {
                    html: htmlContent,
                    is_fallback: true,
                },
                timestamp: new Date().toISOString(),
                source: url,
                note: 'Fetched using basic fetch as Firecrawl failed.',
            };
        }
        catch (fallbackError) {
            const errMsg = fallbackError instanceof Error ? fallbackError.message : 'Unknown fallback fetch error';
            console.warn(`Fallback fetch error for ${url}:`, errMsg);
            return {
                success: false,
                error: &quot;That didn't work, please try again later.&quot;,
                timestamp: new Date().toISOString(),
                source: url,
            };
        }
    }
    async scrapeWebsite(url, _selectors) {
        try {
            const firecrawlResult = await firecrawl.scrapeUrl(url, {
                formats: ['markdown', 'html'],
                onlyMainContent: true,
            });
            if (firecrawlResult.success !== true || firecrawlResult.data == undefined) {
                throw new Error(firecrawlResult.error ?? 'Firecrawl scraping failed to return data.');
            }
            const returnedData = {};
            if (firecrawlResult.data &amp;&amp; typeof firecrawlResult.data === 'object') {
                const firecrawlData = firecrawlResult.data;
                if (typeof firecrawlData.markdown === 'string' &amp;&amp; firecrawlData.markdown !== '') {
                    returnedData.markdown = firecrawlData.markdown;
                }
                if (typeof firecrawlData.html === 'string' &amp;&amp; firecrawlData.html !== '') {
                    returnedData.html = firecrawlData.html;
                }
                if (firecrawlData.metadata != undefined &amp;&amp; typeof firecrawlData.metadata === 'object') {
                    returnedData.metadata = firecrawlData.metadata;
                }
            }
            if ((returnedData.markdown == undefined || returnedData.markdown === '') &amp;&amp;
                (returnedData.html == undefined || returnedData.html === '')) {
                throw new Error('Firecrawl returned no markdown or HTML content.');
            }
            return {
                success: true,
                data: returnedData,
                timestamp: new Date().toISOString(),
                source: url,
            };
        }
        catch (error) {
            console.warn(`Scraping error for ${url} using Firecrawl:`, error);
            console.info(`Falling back to basic fetch for ${url}`);
            return await this.performFallbackScrape(url);
        }
    }
    async scrapeSocialMedia(platform, handle) {
        try {
            await this.randomDelay();
            switch (platform) {
                case 'instagram': {
                    return await this.scrapeInstagram(handle);
                }
                case 'facebook': {
                    return await this.scrapeFacebook(handle);
                }
                case 'twitter': {
                    return await this.scrapeTwitter(handle);
                }
                default: {
                    throw new Error(`Unsupported platform: ${platform}`);
                }
            }
        }
        catch (error) {
            console.warn(`Social media scraping error for ${platform}/${handle}:`, error);
            return {
                success: false,
                error: &quot;That didn't work, please try again later.&quot;,
                timestamp: new Date().toISOString(),
                source: `social_media:${platform}:${handle}`,
            };
        }
    }
    async scrapeInstagram(handle) {
        await this.randomDelay();
        const posts = [
            {
                id: 'post_001',
                caption: 'Fresh tacos available now at Mission St!  #foodtruck #tacos',
                timestamp: new Date(Date.now() - 3_600_000).toISOString(),
                location: 'Mission St, San Francisco',
                hashtags: ['foodtruck', 'tacos', 'fresh'],
                engagement: { likes: 45, comments: 8 },
            },
        ];
        const profile = {
            followers: 1250,
            following: 340,
            posts_count: 156,
            bio: 'Best tacos in SF  Follow for daily locations!',
            contact_info: {
                email: 'contact@tacoparadise.com',
                phone: '+1-555-0456',
            },
        };
        const data = { posts, profile };
        return {
            success: true,
            data,
            timestamp: new Date().toISOString(),
            source: `instagram:${handle}`,
        };
    }
    async scrapeFacebook(handle) {
        await this.randomDelay();
        const posts = [
            {
                id: 'fb_post_001',
                content: &quot;Today we'll be at Union Square from 11 AM to 3 PM! Come try our new BBQ burger!&quot;,
                timestamp: new Date(Date.now() - 7_200_000).toISOString(),
                reactions: { likes: 23, loves: 5, shares: 3 },
                comments: 12,
            },
        ];
        const page_info = {
            likes: 890,
            followers: 1100,
            check_ins: 450,
            about: 'Gourmet food truck serving the Bay Area',
            hours: {
                monday: '11:00-15:00',
                tuesday: '11:00-15:00',
                wednesday: '11:00-15:00',
                thursday: '11:00-15:00',
                friday: '11:00-20:00',
                saturday: '12:00-20:00',
                sunday: '12:00-16:00',
            },
        };
        const data = { posts, page_info };
        return {
            success: true,
            data,
            timestamp: new Date().toISOString(),
            source: `facebook:${handle}`,
        };
    }
    async scrapeTwitter(handle) {
        await this.randomDelay();
        const tweets = [
            {
                id: 'tweet_001',
                text: 'LIVE at Dolores Park! Fresh burritos and quesadillas available now ',
                timestamp: new Date(Date.now() - 1_800_000).toISOString(),
                retweets: 8,
                likes: 34,
                replies: 5,
                location: 'Dolores Park, San Francisco',
            },
        ];
        const profile = {
            followers: 2340,
            following: 567,
            tweets_count: 1890,
            bio: ' SF Food Truck | Fresh Mexican Food | Follow for locations',
            location: 'San Francisco, CA',
            website: 'https://tacoparadise.com',
        };
        const data = { tweets, profile };
        return {
            success: true,
            data,
            timestamp: new Date().toISOString(),
            source: `twitter:${handle}`,
        };
    }
    getRandomUserAgent() {
        // Use Node.js crypto for stronger randomness if available, fallback to Math.random otherwise.
        let idx;
        if (globalThis.window?.crypto?.getRandomValues != undefined) {
            const array = globalThis.window.crypto.getRandomValues(new Uint32Array(1));
            idx = array[0] % this.userAgents.length;
        }
        else if (typeof crypto.randomInt === 'function') {
            idx = crypto.randomInt(0, this.userAgents.length);
        }
        else {
            // Fallback to Math.random for environments where crypto is not available.
            // This is acceptable for non-security-critical random number generation like user agent selection.
            // eslint-disable-next-line sonarjs/pseudo-random -- Math.random is acceptable for non-security-critical user agent selection.
            idx = Math.floor(Math.random() * this.userAgents.length);
        }
        return this.userAgents[idx];
    }
    randomDelay() {
        let randomMs;
        if (globalThis.window?.crypto?.getRandomValues != undefined) {
            const array = globalThis.window.crypto.getRandomValues(new Uint32Array(1));
            randomMs = array[0] % 1000;
        }
        else if (typeof crypto.randomInt === 'function') {
            randomMs = crypto.randomInt(0, 1000);
        }
        else {
            // Fallback to Math.random for environments where crypto is not available.
            // This is acceptable for non-security-critical random delays.
            // eslint-disable-next-line sonarjs/pseudo-random -- Math.random is acceptable for non-security-critical random delays.
            randomMs = Math.floor(Math.random() * 1000);
        }
        const delay = this.requestDelay + randomMs;
        return new Promise((resolve) =&gt; setTimeout(resolve, delay));
    }
    handleRateLimit(retryAfter) {
        console.info(`Rate limited. Waiting ${retryAfter} seconds before retry...`);
        return new Promise((resolve) =&gt; setTimeout(resolve, retryAfter * 1000));
    }
    async retryWithBackoff(operation, maxRetries = this.maxRetries) {
        let lastError;
        for (let attempt = 1; attempt &lt;= maxRetries; attempt += 1) {
            try {
                return await operation();
            }
            catch (error) {
                lastError = error;
                if (attempt === maxRetries) {
                    throw lastError instanceof Error ? lastError : new Error(String(lastError));
                }
                const backoffDelay = Math.pow(2, attempt) * 1000;
                console.info(`Attempt ${attempt} failed. Retrying in ${backoffDelay}ms...`);
                await new Promise((resolve) =&gt; setTimeout(resolve, backoffDelay));
            }
        }
        throw lastError instanceof Error ? lastError : new Error('Request failed after all retries');
    }
}
export class DataQualityAssessor {
    assessBasicInfo(truckData, issues, score) {
        if (truckData.name == undefined || truckData.name.trim().length === 0) {
            issues.push('Missing or empty truck name');
            score -= 20;
        }
        return score;
    }
    assessLocationInfo(truckData, issues, score) {
        if (truckData.location?.current == undefined) {
            issues.push('Missing current location data');
            score -= 25;
        }
        else {
            if (truckData.location.current.lat == undefined ||
                truckData.location.current.lng == undefined) {
                issues.push('Missing GPS coordinates');
                score -= 15;
            }
            if (truckData.location.current.address == undefined ||
                truckData.location.current.address === '') {
                issues.push('Missing address information');
                score -= 10;
            }
        }
        return score;
    }
    assessContactInfo(truckData, issues, score) {
        if (truckData.contact) {
            const hasPhone = typeof truckData.contact.phone === 'string' &amp;&amp; truckData.contact.phone.trim() !== '';
            const hasEmail = typeof truckData.contact.email === 'string' &amp;&amp; truckData.contact.email.trim() !== '';
            if (!hasPhone &amp;&amp; !hasEmail) {
                issues.push('No phone or email contact available');
                score -= 15;
            }
            if (hasPhone &amp;&amp; !this.isValidPhone(truckData.contact.phone)) {
                issues.push('Invalid phone number format');
                score -= 5;
            }
            if (hasEmail &amp;&amp; !this.isValidEmail(truckData.contact.email)) {
                issues.push('Invalid email format');
                score -= 5;
            }
        }
        else {
            issues.push('Missing contact information');
            score -= 20;
        }
        return score;
    }
    assessOperatingHours(truckData, issues, score) {
        if (truckData.operating_hours == undefined ||
            Object.keys(truckData.operating_hours).length === 0) {
            issues.push('Missing operating hours');
            score -= 15;
        }
        return score;
    }
    assessMenuInfo(truckData, issues, score) {
        if (truckData.menu == undefined || truckData.menu.length === 0) {
            issues.push('Missing menu information');
            score -= 10;
        }
        else {
            const menuIssues = this.validateMenuData(truckData.menu);
            issues.push(...menuIssues);
            score -= menuIssues.length * 2;
        }
        return score;
    }
    assessLastUpdated(truckData, issues, score) {
        if (truckData.last_updated != undefined &amp;&amp; truckData.last_updated !== '') {
            const lastUpdate = new Date(truckData.last_updated);
            const daysSinceUpdate = (Date.now() - lastUpdate.getTime()) / (1000 * 60 * 60 * 24);
            if (daysSinceUpdate &gt; 7) {
                issues.push('Data is more than 7 days old');
                score -= 10;
            }
            else if (daysSinceUpdate &gt; 3) {
                issues.push('Data is more than 3 days old');
                score -= 5;
            }
        }
        return score;
    }
    assessTruckData(truckData) {
        const issues = [];
        let score = 100;
        score = this.assessBasicInfo(truckData, issues, score);
        score = this.assessLocationInfo(truckData, issues, score);
        score = this.assessContactInfo(truckData, issues, score);
        score = this.assessOperatingHours(truckData, issues, score);
        score = this.assessMenuInfo(truckData, issues, score);
        score = this.assessLastUpdated(truckData, issues, score);
        return {
            score: Math.max(0, score) / 100,
            issues,
        };
    }
    validateMenuCategory(category, categoryIndex, issues) {
        if (category.category == undefined || category.category.trim().length === 0) {
            issues.push(`Menu category ${categoryIndex + 1} missing name`);
        }
    }
    validateMenuItems(category, issues) {
        if (category.items == undefined || category.items.length === 0) {
            issues.push(`Menu category &quot;${category.category ?? 'Unknown'}&quot; has no items`);
        }
        else {
            for (const [itemIndex, item] of category.items.entries()) {
                if (item.name == undefined || item.name.trim().length === 0) {
                    issues.push(`Menu item ${itemIndex + 1} in &quot;${category.category ?? 'Unknown'}&quot; missing name`);
                }
                if (typeof item.price !== 'number' || item.price &lt;= 0) {
                    issues.push(`Menu item &quot;${item.name ?? 'Unknown'}&quot; has invalid price`);
                }
            }
        }
    }
    validateMenuData(menu) {
        const issues = [];
        for (const [categoryIndex, category] of menu.entries()) {
            this.validateMenuCategory(category, categoryIndex, issues);
            this.validateMenuItems(category, issues);
        }
        return issues;
    }
    isValidPhone(phone) {
        // Regex for phone number validation. Not vulnerable to super-linear runtime due to backtracking.
        // Accepts +, digits, spaces, dashes, and parentheses. At least 10 digits.
        const phoneRegex = /^\+?[\d\s\-()]{10,}$/;
        return phoneRegex.test(phone);
    }
    isValidEmail(email) {
        // Regex for email validation optimized to avoid backtracking
        const emailRegex = /^[^\s@]+@[^\s@]+\.[a-zA-Z]{2,}$/;
        return emailRegex.test(email);
    }
}
export class GeminiDataProcessor {
    _apiKey;
    _baseUrl;
    requestCount;
    tokenCount;
    dailyLimit;
    constructor(apiKey) {
        this._apiKey = apiKey;
        this._baseUrl = 'https://generativelanguage.googleapis.com/v1beta';
        this.requestCount = 0;
        this.tokenCount = 0;
        this.dailyLimit = { requests: 1500, tokens: 32_000 };
    }
    async processMenuData(rawMenuText) {
        if (!this.canMakeRequest()) {
            throw new Error('Gemini API rate limit exceeded');
        }
        try {
            const prompt = `
        Parse the following food truck menu text and return a structured JSON format:
        
        ${rawMenuText}
        
        Return format:
        {
          &quot;categories&quot;: [
            {
              &quot;name&quot;: &quot;category_name&quot;,
              &quot;items&quot;: [
                {
                  &quot;name&quot;: &quot;item_name&quot;,
                  &quot;description&quot;: &quot;item_description&quot;,
                  &quot;price&quot;: 0.00,
                  &quot;dietary_tags&quot;: [&quot;vegetarian&quot;, &quot;vegan&quot;, &quot;gluten-free&quot;, etc.]
                }
              ]
            }
          ]
        }
        
        Only return valid JSON, no additional text.
      `;
            const response = await this.makeGeminiRequest(prompt);
            this.updateUsageCounters(1, prompt.length + response.length);
            // Ensure type safety for parsed response
            const parsed = JSON.parse(response);
            if (typeof parsed !== 'object' ||
                parsed == undefined ||
                !('categories' in parsed) ||
                !Array.isArray(parsed.categories)) {
                throw new Error('Invalid Gemini menu response: missing or malformed categories array');
            }
            return parsed;
        }
        catch (error) {
            console.error('Error processing menu data with Gemini:', error);
            throw error;
        }
    }
    async extractLocationFromText(text) {
        if (!this.canMakeRequest()) {
            throw new Error('Gemini API rate limit exceeded');
        }
        try {
            const prompt = `
        Extract location information from the following text and return structured data:
        
        &quot;${text}&quot;
        
        Return format:
        {
          &quot;address&quot;: &quot;full_address&quot;,
          &quot;city&quot;: &quot;city_name&quot;,
          &quot;state&quot;: &quot;state&quot;,
          &quot;coordinates&quot;: {
            &quot;lat&quot;: 0.0,
            &quot;lng&quot;: 0.0
          },
          &quot;confidence&quot;: 0.95
        }
        
        If coordinates cannot be determined, set them to undefined. Only return valid JSON.
      `;
            const response = await this.makeGeminiRequest(prompt);
            this.updateUsageCounters(1, prompt.length + response.length);
            const parsedResponse = JSON.parse(response);
            const validatedResponse = this.validateGeminiLocationResponse(parsedResponse);
            return validatedResponse;
        }
        catch (error) {
            console.error('Error extracting location with Gemini:', error);
            throw error;
        }
    }
    validateGeminiLocationResponse(parsedResponse) {
        if (parsedResponse == undefined ||
            typeof parsedResponse !== 'object' ||
            !('coordinates' in parsedResponse) ||
            typeof parsedResponse.coordinates !== 'object') {
            throw new Error('Invalid Gemini location response');
        }
        const coordinates = parsedResponse
            .coordinates;
        if (coordinates &amp;&amp; typeof coordinates === 'object') {
            if (typeof coordinates.lat !== 'number') {
                coordinates.lat = undefined;
            }
            if (typeof coordinates.lng !== 'number') {
                coordinates.lng = undefined;
            }
        }
        return parsedResponse;
    }
    async standardizeOperatingHours(hoursText) {
        if (!this.canMakeRequest()) {
            throw new Error('Gemini API rate limit exceeded');
        }
        try {
            const prompt = `
        Parse the following operating hours text and return standardized format:
        
        &quot;${hoursText}&quot;
        
        Return format:
        {
          &quot;monday&quot;: {&quot;open&quot;: &quot;HH:MM&quot;, &quot;close&quot;: &quot;HH:MM&quot;, &quot;closed&quot;: false},
          &quot;tuesday&quot;: {&quot;open&quot;: &quot;HH:MM&quot;, &quot;close&quot;: &quot;HH:MM&quot;, &quot;closed&quot;: false},
          &quot;wednesday&quot;: {&quot;open&quot;: &quot;HH:MM&quot;, &quot;close&quot;: &quot;HH:MM&quot;, &quot;closed&quot;: false},
          &quot;thursday&quot;: {&quot;open&quot;: &quot;HH:MM&quot;, &quot;close&quot;: &quot;HH:MM&quot;, &quot;closed&quot;: false},
          &quot;friday&quot;: {&quot;open&quot;: &quot;HH:MM&quot;, &quot;close&quot;: &quot;HH:MM&quot;, &quot;closed&quot;: false},
          &quot;saturday&quot;: {&quot;open&quot;: &quot;HH:MM&quot;, &quot;close&quot;: &quot;HH:MM&quot;, &quot;closed&quot;: false},
          &quot;sunday&quot;: {&quot;open&quot;: &quot;HH:MM&quot;, &quot;close&quot;: &quot;HH:MM&quot;, &quot;closed&quot;: false}
        }
          Use 24-hour format. If closed on a day, set &quot;closed&quot;: true and omit open/close times.
        Only return valid JSON.
      `;
            const response = await this.makeGeminiRequest(prompt);
            this.updateUsageCounters(1, prompt.length + response.length);
            const parsed = JSON.parse(response);
            if (parsed == undefined || typeof parsed !== 'object') {
                throw new Error('Invalid Gemini hours response');
            }
            return parsed;
        }
        catch (error) {
            console.error('Error standardizing hours with Gemini:', error);
            throw error;
        }
    }
    async analyzeSentiment(reviewText) {
        if (!this.canMakeRequest()) {
            throw new Error('Gemini API rate limit exceeded');
        }
        try {
            const prompt = `
        Analyze the sentiment of this food truck review and extract key insights:
        
        &quot;${reviewText}&quot;
        
        Return format:
        {
          &quot;sentiment&quot;: &quot;positive|negative|neutral&quot;,
          &quot;score&quot;: 0.85,
          &quot;key_topics&quot;: [&quot;food_quality&quot;, &quot;service&quot;, &quot;price&quot;, &quot;location&quot;],
          &quot;summary&quot;: &quot;brief_summary_of_review&quot;
        }
          Score should be between 0 (very negative) and 1 (very positive).
        Only return valid JSON.
      `;
            const response = await this.makeGeminiRequest(prompt);
            this.updateUsageCounters(1, prompt.length + response.length);
            const parsed = JSON.parse(response);
            if (parsed == undefined || typeof parsed !== 'object') {
                throw new Error('Invalid Gemini sentiment response');
            }
            return parsed;
        }
        catch (error) {
            console.error('Error analyzing sentiment with Gemini:', error);
            throw error;
        }
    }
    async makeGeminiRequest(prompt) {
        await new Promise((resolve) =&gt; setTimeout(resolve, 1000)); // Simulate API delay
        return this.getMockGeminiResponse(prompt);
    }
    getMockGeminiResponse(prompt) {
        if (prompt.includes('menu text')) {
            return JSON.stringify({
                categories: [
                    {
                        name: 'Burgers',
                        items: [
                            {
                                name: 'Classic Cheeseburger',
                                description: 'Beef patty with cheese, lettuce, tomato',
                                price: 12.99,
                                dietary_tags: [],
                            },
                        ],
                    },
                ],
            });
        }
        else if (prompt.includes('location information')) {
            return JSON.stringify({
                address: '123 Market St, San Francisco, CA 94105',
                city: 'San Francisco',
                state: 'CA',
                coordinates: {
                    lat: 37.7749,
                    lng: -122.4194,
                },
                confidence: 0.95,
            });
        }
        else if (prompt.includes('operating hours')) {
            return JSON.stringify({
                monday: { open: '11:00', close: '15:00', closed: false },
                tuesday: { open: '11:00', close: '15:00', closed: false },
                wednesday: { open: '11:00', close: '15:00', closed: false },
                thursday: { open: '11:00', close: '15:00', closed: false },
                friday: { open: '11:00', close: '20:00', closed: false },
                saturday: { open: '12:00', close: '20:00', closed: false },
                sunday: { open: '12:00', close: '16:00', closed: false },
            });
        }
        else if (prompt.includes('sentiment')) {
            return JSON.stringify({
                sentiment: 'positive',
                score: 0.85,
                key_topics: ['food_quality', 'service'],
                summary: 'Customer enjoyed the food and service',
            });
        }
        return '{&quot;processed&quot;: true}';
    }
    canMakeRequest() {
        return this.requestCount &lt; this.dailyLimit.requests &amp;&amp; this.tokenCount &lt; this.dailyLimit.tokens;
    }
    updateUsageCounters(requests, tokens) {
        this.requestCount += requests;
        this.tokenCount += tokens;
    }
    getUsageStats() {
        return {
            requests: {
                used: this.requestCount,
                limit: this.dailyLimit.requests,
                remaining: this.dailyLimit.requests - this.requestCount,
            },
            tokens: {
                used: this.tokenCount,
                limit: this.dailyLimit.tokens,
                remaining: this.dailyLimit.tokens - this.tokenCount,
            },
        };
    }
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/scheduler.js (Line 1:1 - Line 356:2), C:/AI/food-truck-finder-poc/dist/lib/lib/scheduler.js (Line 1:1 - Line 356:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn544" onclick="toggleCodeBlock('cloneGroup544', 'expandBtn544', 'collapseBtn544')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn544" onclick="toggleCodeBlock('cloneGroup544', 'expandBtn544', 'collapseBtn544')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup544"><code class="language-javascript text-sm text-gray-800">// Task scheduling and automation system
export class TaskScheduler {
    tasks;
    intervals;
    isRunning;
    constructor() {
        this.tasks = new Map();
        this.intervals = new Map();
        this.isRunning = false;
    }
    start() {
        if (this.isRunning === true) {
            console.info('Scheduler is already running');
            return;
        }
        this.isRunning = true;
        console.info('Task scheduler started');
        // Start all scheduled tasks
        for (const [taskId, task] of this.tasks.entries()) {
            if (task.enabled === true) {
                this.scheduleTask(taskId, task);
            }
        }
    }
    stop() {
        if (this.isRunning !== true) {
            console.info('Scheduler is not running');
            return;
        }
        this.isRunning = false;
        // Clear all intervals
        for (const [taskId, interval] of this.intervals.entries()) {
            clearInterval(interval);
            console.info(`Stopped task: ${taskId}`);
        }
        this.intervals.clear();
        console.info('Task scheduler stopped');
    }
    addTask(task) {
        this.tasks.set(task.id, task);
        if (this.isRunning === true &amp;&amp; task.enabled === true) {
            this.scheduleTask(task.id, task);
        }
        console.info(`Added task: ${task.id}`);
    }
    removeTask(taskId) {
        const interval = this.intervals.get(taskId);
        if (interval) {
            clearInterval(interval);
            this.intervals.delete(taskId);
        }
        this.tasks.delete(taskId);
        console.info(`Removed task: ${taskId}`);
    }
    enableTask(taskId) {
        const task = this.tasks.get(taskId);
        if (!task) {
            throw new Error(`Task not found: ${taskId}`);
        }
        task.enabled = true;
        if (this.isRunning) {
            this.scheduleTask(taskId, task);
        }
        console.info(`Enabled task: ${taskId}`);
    }
    disableTask(taskId) {
        const task = this.tasks.get(taskId);
        if (!task) {
            throw new Error(`Task not found: ${taskId}`);
        }
        task.enabled = false;
        const interval = this.intervals.get(taskId);
        if (interval) {
            clearInterval(interval);
            this.intervals.delete(taskId);
        }
        console.info(`Disabled task: ${taskId}`);
    }
    scheduleTask(taskId, task) {
        // Clear existing interval if any
        const existingInterval = this.intervals.get(taskId);
        if (existingInterval) {
            clearInterval(existingInterval);
        }
        // Calculate interval in milliseconds
        const intervalMs = task.intervalMinutes * 60 * 1000;
        // Schedule the task with proper async wrapper
        const interval = setInterval(() =&gt; {
            // Use void to indicate we're not handling the promise
            void (async () =&gt; {
                try {
                    console.info(`Executing task: ${taskId}`);
                    task.lastRun = new Date().toISOString();
                    await task.execute();
                    task.successCount += 1;
                    task.lastSuccess = new Date().toISOString();
                    console.info(`Task completed successfully: ${taskId}`);
                }
                catch (error) {
                    task.errorCount += 1;
                    task.lastError = error instanceof Error ? error.message : 'Unknown error';
                    console.warn(`Task failed: ${taskId}`, error);
                    // Disable task if too many consecutive failures
                    if (task.errorCount - task.successCount &gt; 5) {
                        console.warn(`Disabling task due to repeated failures: ${taskId}`);
                        this.disableTask(taskId);
                    }
                }
            })();
        }, intervalMs);
        this.intervals.set(taskId, interval);
        console.info(`Scheduled task: ${taskId} (every ${task.intervalMinutes} minutes)`);
    }
    getTaskStatus() {
        return [...this.tasks.values()].map((task) =&gt; ({
            id: task.id,
            name: task.name,
            enabled: task.enabled,
            intervalMinutes: task.intervalMinutes,
            lastRun: task.lastRun,
            lastSuccess: task.lastSuccess,
            successCount: task.successCount,
            errorCount: task.errorCount,
            lastError: task.lastError,
            nextRun: this.calculateNextRun(task),
        }));
    }
    calculateNextRun(task) {
        if (task.enabled !== true || task.lastRun == undefined) {
            return undefined;
        }
        const lastRun = new Date(task.lastRun);
        const nextRun = new Date(lastRun.getTime() + task.intervalMinutes * 60 * 1000);
        return nextRun.toISOString();
    }
    scheduleFollowUpTasks(result) {
        // Implementation for scheduling follow-up tasks based on scraping results
        console.info('Scheduling follow-up tasks based on scraping results:', result);
        // This could include:
        // - Scheduling quality checks for newly scraped data
        // - Setting up monitoring for high-priority trucks
        // - Triggering additional scraping for related sources
    }
}
// Helper function to update truck location from social media
async function updateTruckLocationFromSocial(truck, scraperEngine) {
    if (truck.social_media.instagram_handle == undefined ||
        truck.social_media.instagram_handle === '') {
        return;
    }
    const socialResult = await scraperEngine.scrapeSocialMedia('instagram', truck.social_media.instagram_handle);
    if (socialResult.success === true &amp;&amp; socialResult.data != undefined) {
        const socialData = socialResult.data;
        const recentPosts = socialData.posts.slice(0, 3);
        for (const post of recentPosts) {
            if (post.location != undefined &amp;&amp; post.location !== '') {
                console.info(`Updated location for ${truck.name}: ${post.location}`);
                break;
            }
        }
    }
}
// Pre-configured tasks for food truck data pipeline
export function createDefaultTasks(scraperEngine, geminiProcessor, dataQualityAssessor) {
    return [
        createInstagramScrapeTask(scraperEngine),
        createWebsiteCrawlTask(scraperEngine),
        createDataQualityCheckTask(dataQualityAssessor),
        createGeminiProcessingTask(geminiProcessor),
        createLocationUpdateTask(scraperEngine),
    ];
}
/**
 * Create Instagram scraping task
 */
function createInstagramScrapeTask(scraperEngine) {
    return {
        id: 'instagram_scrape',
        name: 'Instagram Data Scraping',
        description: 'Scrape Instagram posts and profiles for food truck data',
        intervalMinutes: 120, // Every 2 hours
        enabled: true,
        successCount: 0,
        errorCount: 0,
        execute: async () =&gt; {
            const handles = ['@gourmetstreeteats', '@tacoparadisesf', '@burgermobile'];
            for (const handle of handles) {
                const result = await scraperEngine.scrapeSocialMedia('instagram', handle);
                if (result.success) {
                    console.info(`Successfully scraped ${handle}`);
                }
                else {
                    throw new Error(`Failed to scrape ${handle}: ${result.error}`);
                }
            }
        },
    };
}
/**
 * Create website crawling task
 */
function createWebsiteCrawlTask(scraperEngine) {
    return {
        id: 'website_crawl',
        name: 'Website Crawling',
        description: 'Crawl food truck websites for menu and location updates',
        intervalMinutes: 360, // Every 6 hours
        enabled: true,
        successCount: 0,
        errorCount: 0,
        execute: async () =&gt; {
            const websites = [
                'https://gourmetstreeteats.com',
                'https://tacoparadise.com',
                'https://burgermobile.net',
            ];
            const selectors = {
                name: '.truck-name',
                location: '.current-location',
                hours: '.operating-hours',
                menu: '.menu-items',
            };
            for (const url of websites) {
                const result = await scraperEngine.scrapeWebsite(url, selectors);
                if (result.success) {
                    console.info(`Successfully crawled ${url}`);
                }
                else {
                    throw new Error(`Failed to crawl ${url}: ${result.error}`);
                }
            }
        },
    };
}
/**
 * Create data quality check task
 */
function createDataQualityCheckTask(dataQualityAssessor) {
    return {
        id: 'data_quality_check',
        name: 'Data Quality Assessment',
        description: 'Assess and validate data quality for all food trucks',
        intervalMinutes: 720, // Every 12 hours
        enabled: true,
        successCount: 0,
        errorCount: 0,
        execute: async () =&gt; {
            // Placeholder: fetch trucks from database
            const trucks = [];
            await Promise.resolve(); // Added to satisfy async/await rule
            let totalScore = 0;
            let processedCount = 0;
            if (trucks.length === 0) {
                console.info('No trucks available for quality assessment');
                return;
            }
            for (const truck of trucks) {
                const assessment = dataQualityAssessor.assessTruckData(truck);
                totalScore += assessment.score;
                processedCount += 1;
                if (assessment.score &lt; 0.7) {
                    console.warn(`Low quality data for truck ${truck.id}: ${assessment.issues.join(', ')}`);
                }
            }
            const averageQuality = processedCount &gt; 0 ? totalScore / processedCount : 0;
            console.info(`Data quality assessment completed. Average score: ${averageQuality.toFixed(2)}`);
        },
    };
}
/**
 * Create Gemini processing task
 */
function createGeminiProcessingTask(geminiProcessor) {
    return {
        id: 'gemini_processing',
        name: 'AI Data Processing',
        description: 'Process raw data using Gemini AI for standardization',
        intervalMinutes: 480, // Every 8 hours
        enabled: true,
        successCount: 0,
        errorCount: 0,
        execute: async () =&gt; {
            const usage = geminiProcessor.getUsageStats();
            if (usage.requests.remaining &lt; 100) {
                console.warn('Skipping Gemini processing due to rate limits');
                return;
            }
            const pendingData = []; // Placeholder: fetch pending data from queue system
            if (pendingData.length === 0) {
                console.info('No pending data to process');
                return;
            }
            await processGeminiDataBatch(geminiProcessor, pendingData);
            console.info(`Processed ${pendingData.length} items with Gemini AI`);
        },
    };
}
/**
 * Process batch of data with Gemini
 */
async function processGeminiDataBatch(geminiProcessor, pendingData) {
    for (const data of pendingData) {
        switch (data.type) {
            case 'menu': {
                await geminiProcessor.processMenuData(data.content);
                break;
            }
            case 'location': {
                await geminiProcessor.extractLocationFromText(data.content);
                break;
            }
            case 'hours': {
                await geminiProcessor.standardizeOperatingHours(data.content);
                break;
            }
            case 'sentiment': {
                await geminiProcessor.analyzeSentiment(data.content);
                break;
            }
            case 'enhance': {
                await geminiProcessor.enhanceFoodTruckData(data.content);
                break;
            }
            default: {
                // No default
                break;
            }
        }
    }
}
/**
 * Create location update task
 */
function createLocationUpdateTask(scraperEngine) {
    return {
        id: 'location_update',
        name: 'Real-time Location Updates',
        description: 'Update current locations for active food trucks',
        intervalMinutes: 30, // Every 30 minutes
        enabled: true,
        successCount: 0,
        errorCount: 0,
        execute: async () =&gt; {
            const activeTrucks = []; // Placeholder: fetch active trucks from database
            if (activeTrucks.length === 0) {
                console.info('No active trucks to update locations for');
                return;
            }
            for (const truck of activeTrucks) {
                await updateTruckLocationFromSocial(truck, scraperEngine);
            }
        },
    };
}
// Export scheduler instance for use in cron jobs
export const scheduler = new TaskScheduler();</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/pipelineManager.js (Line 20:5 - Line 33:8), C:/AI/food-truck-finder-poc/dist/lib/lib/pipelineManager.js (Line 20:5 - Line 33:8)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn547" onclick="toggleCodeBlock('cloneGroup547', 'expandBtn547', 'collapseBtn547')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn547" onclick="toggleCodeBlock('cloneGroup547', 'expandBtn547', 'collapseBtn547')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup547"><code class="language-javascript text-sm text-gray-800">async runPipeline(config) {
        const startTime = Date.now();
        try {
            console.info(` PipelineManager: Starting ${config.type} pipeline...`);
            const result = await this.executePipelineType(config);
            return this.createSuccessResult(config, result, startTime);
        }
        catch (error) {
            return this.createErrorResult(config, error, startTime);
        }
    }
    /**
     * Execute the specific pipeline type
     */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/pipelineManager.js (Line 34:5 - Line 63:8), C:/AI/food-truck-finder-poc/dist/lib/lib/pipelineManager.js (Line 34:5 - Line 63:8)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn548" onclick="toggleCodeBlock('cloneGroup548', 'expandBtn548', 'collapseBtn548')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn548" onclick="toggleCodeBlock('cloneGroup548', 'expandBtn548', 'collapseBtn548')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup548"><code class="language-javascript text-sm text-gray-800">async executePipelineType(config) {
        switch (config.type) {
            case 'discovery': {
                return await this.runDiscovery({
                    cities: config.params.targetCities ?? [],
                    maxUrls: config.params.maxUrls ?? 50,
                    searchTerms: ['food truck', 'food cart', 'mobile food'],
                });
            }
            case 'processing': {
                return await this.processJobs({
                    maxJobs: config.params.maxUrlsToProcess ?? 20,
                    priority: config.params.priority ?? 5,
                    retryFailedJobs: config.params.retryFailedJobs ?? false,
                });
            }
            case 'full': {
                return await this.runFullPipeline(config);
            }
            case 'maintenance': {
                return await this.runMaintenance();
            }
            default: {
                throw new Error(`Unknown pipeline type: ${String(config.type)}`);
            }
        }
    }
    /**
     * Create success result
     */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/pipelineManager.js (Line 64:5 - Line 82:8), C:/AI/food-truck-finder-poc/dist/lib/lib/pipelineManager.js (Line 64:5 - Line 82:8)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn549" onclick="toggleCodeBlock('cloneGroup549', 'expandBtn549', 'collapseBtn549')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn549" onclick="toggleCodeBlock('cloneGroup549', 'expandBtn549', 'collapseBtn549')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup549"><code class="language-javascript text-sm text-gray-800">createSuccessResult(config, result, startTime) {
        const duration = Date.now() - startTime;
        return {
            success: true,
            type: config.type,
            phase: 'completed',
            summary: {
                ...(typeof result === 'object' &amp;&amp; result !== null
                    ? result
                    : {}),
                duration,
            },
            details: result,
            timestamp: new Date().toISOString(),
        };
    }
    /**
     * Create error result
     */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/pipelineManager.js (Line 83:5 - Line 102:8), C:/AI/food-truck-finder-poc/dist/lib/lib/pipelineManager.js (Line 83:5 - Line 102:8)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn550" onclick="toggleCodeBlock('cloneGroup550', 'expandBtn550', 'collapseBtn550')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn550" onclick="toggleCodeBlock('cloneGroup550', 'expandBtn550', 'collapseBtn550')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup550"><code class="language-javascript text-sm text-gray-800">createErrorResult(config, error, startTime) {
        const duration = Date.now() - startTime;
        console.error(` PipelineManager: ${config.type} pipeline failed:`, error);
        return {
            success: false,
            type: config.type,
            phase: 'failed',
            summary: {
                errors: 1,
                duration,
            },
            details: {
                error: error instanceof Error ? error.message : 'Unknown error',
            },
            timestamp: new Date().toISOString(),
        };
    }
    /**
     * Run URL discovery using Tavily search
     */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/pipelineManager.js (Line 103:5 - Line 135:8), C:/AI/food-truck-finder-poc/dist/lib/lib/pipelineManager.js (Line 103:5 - Line 135:8)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn551" onclick="toggleCodeBlock('cloneGroup551', 'expandBtn551', 'collapseBtn551')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn551" onclick="toggleCodeBlock('cloneGroup551', 'expandBtn551', 'collapseBtn551')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup551"><code class="language-javascript text-sm text-gray-800">async runDiscovery(_params) {
        const startTime = Date.now();
        try {
            console.info(` PipelineManager: Starting discovery process...`);
            // Use the existing discovery engine's method
            const discoveryResult = await discoveryEngine.discoverNewFoodTrucks();
            const duration = Date.now() - startTime;
            return {
                success: discoveryResult.errors.length === 0,
                urlsDiscovered: discoveryResult.urls_discovered,
                urlsStored: discoveryResult.urls_stored,
                urlsDuplicate: discoveryResult.urls_duplicates,
                errors: discoveryResult.errors,
                duration,
            };
        }
        catch (error) {
            const duration = Date.now() - startTime;
            const errorMsg = error instanceof Error ? error.message : 'Unknown discovery error';
            console.error(' PipelineManager: Discovery failed:', error);
            return {
                success: false,
                urlsDiscovered: 0,
                urlsStored: 0,
                urlsDuplicate: 0,
                errors: [errorMsg],
                duration,
            };
        }
    }
    /**
     * Process existing scraping jobs
     */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/pipelineManager.js (Line 136:5 - Line 154:8), C:/AI/food-truck-finder-poc/dist/lib/lib/pipelineManager.js (Line 136:5 - Line 154:8)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn552" onclick="toggleCodeBlock('cloneGroup552', 'expandBtn552', 'collapseBtn552')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn552" onclick="toggleCodeBlock('cloneGroup552', 'expandBtn552', 'collapseBtn552')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup552"><code class="language-javascript text-sm text-gray-800">async processJobs(options) {
        const startTime = Date.now();
        try {
            console.info(` PipelineManager: Processing up to ${options.maxJobs} jobs...`);
            const pendingJobs = await ScrapingJobService.getJobsByStatus('pending');
            if (pendingJobs == undefined || pendingJobs.length === 0) {
                return this.createEmptyProcessingResult(startTime);
            }
            const jobsToProcess = pendingJobs.slice(0, options.maxJobs);
            const results = await this.processJobBatch(jobsToProcess, startTime);
            return results;
        }
        catch (error) {
            return this.createProcessingErrorResult(error, startTime);
        }
    }
    /**
     * Create empty processing result when no jobs available
     */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/pipelineManager.js (Line 155:5 - Line 169:8), C:/AI/food-truck-finder-poc/dist/lib/lib/pipelineManager.js (Line 155:5 - Line 169:8)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn553" onclick="toggleCodeBlock('cloneGroup553', 'expandBtn553', 'collapseBtn553')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn553" onclick="toggleCodeBlock('cloneGroup553', 'expandBtn553', 'collapseBtn553')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup553"><code class="language-javascript text-sm text-gray-800">createEmptyProcessingResult(startTime) {
        console.info('No pending jobs to process');
        return {
            success: true,
            jobsProcessed: 0,
            jobsSuccessful: 0,
            jobsFailed: 0,
            trucksCreated: 0,
            errors: [],
            duration: Date.now() - startTime,
        };
    }
    /**
     * Process a batch of jobs
     */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/pipelineManager.js (Line 170:5 - Line 204:8), C:/AI/food-truck-finder-poc/dist/lib/lib/pipelineManager.js (Line 170:5 - Line 204:8)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn554" onclick="toggleCodeBlock('cloneGroup554', 'expandBtn554', 'collapseBtn554')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn554" onclick="toggleCodeBlock('cloneGroup554', 'expandBtn554', 'collapseBtn554')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup554"><code class="language-javascript text-sm text-gray-800">async processJobBatch(jobsToProcess, startTime) {
        const errors = [];
        let jobsSuccessful = 0;
        let jobsFailed = 0;
        let trucksCreated = 0;
        for (const job of jobsToProcess) {
            try {
                console.info(`Processing job ${job.id} for URL: ${job.target_url}`);
                await processScrapingJob(job.id);
                const updatedJob = await ScrapingJobService.getJobsByStatus('completed').then((jobs) =&gt; jobs?.find((j) =&gt; j.id === job.id));
                if (updatedJob?.data_collected?.truck_id != undefined) {
                    trucksCreated += 1;
                }
                jobsSuccessful += 1;
            }
            catch (jobError) {
                const errorMsg = `Job ${job.id} failed: ${jobError instanceof Error ? jobError.message : 'Unknown error'}`;
                console.warn(errorMsg);
                errors.push(errorMsg);
                jobsFailed += 1;
            }
        }
        return {
            success: jobsFailed === 0,
            jobsProcessed: jobsToProcess.length,
            jobsSuccessful,
            jobsFailed,
            trucksCreated,
            errors,
            duration: Date.now() - startTime,
        };
    }
    /**
     * Create processing error result
     */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/pipelineManager.js (Line 205:5 - Line 221:8), C:/AI/food-truck-finder-poc/dist/lib/lib/pipelineManager.js (Line 205:5 - Line 221:8)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn555" onclick="toggleCodeBlock('cloneGroup555', 'expandBtn555', 'collapseBtn555')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn555" onclick="toggleCodeBlock('cloneGroup555', 'expandBtn555', 'collapseBtn555')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup555"><code class="language-javascript text-sm text-gray-800">createProcessingErrorResult(error, startTime) {
        const duration = Date.now() - startTime;
        const errorMsg = error instanceof Error ? error.message : 'Unknown processing error';
        console.error(' PipelineManager: Job processing failed:', error);
        return {
            success: false,
            jobsProcessed: 0,
            jobsSuccessful: 0,
            jobsFailed: 0,
            trucksCreated: 0,
            errors: [errorMsg],
            duration,
        };
    }
    /**
     * Run full pipeline: discovery + processing
     */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/pipelineManager.js (Line 222:5 - Line 253:8), C:/AI/food-truck-finder-poc/dist/lib/lib/pipelineManager.js (Line 222:5 - Line 253:8)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn556" onclick="toggleCodeBlock('cloneGroup556', 'expandBtn556', 'collapseBtn556')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn556" onclick="toggleCodeBlock('cloneGroup556', 'expandBtn556', 'collapseBtn556')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup556"><code class="language-javascript text-sm text-gray-800">async runFullPipeline(config) {
        const results = {
            discovery: undefined,
            processing: undefined,
        };
        // Step 1: Discovery (unless skipped)
        if (config.params.skipDiscovery !== true) {
            results.discovery = await this.runDiscovery({
                cities: config.params.targetCities ?? ['Charleston', 'Columbia', 'Greenville'],
                maxUrls: config.params.maxUrls ?? 50,
                searchTerms: ['food truck', 'food cart', 'mobile food'],
            });
        }
        // Step 2: Processing
        results.processing = await this.processJobs({
            maxJobs: config.params.maxUrlsToProcess ?? 20,
            priority: config.params.priority ?? 5,
            retryFailedJobs: config.params.retryFailedJobs ?? false,
        });
        // Combine results
        return {
            urlsDiscovered: results.discovery?.urlsDiscovered ?? 0,
            urlsStored: results.discovery?.urlsStored ?? 0,
            urlsDuplicate: results.discovery?.urlsDuplicate ?? 0,
            jobsProcessed: results.processing?.jobsProcessed ?? 0,
            trucksCreated: results.processing?.trucksCreated ?? 0,
            errors: [...(results.discovery?.errors ?? []), ...(results.processing?.errors ?? [])],
        };
    }
    /**
     * Run maintenance checks on existing trucks
     */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/pipelineManager.js (Line 254:5 - Line 284:2), C:/AI/food-truck-finder-poc/dist/lib/lib/pipelineManager.js (Line 254:5 - Line 284:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn557" onclick="toggleCodeBlock('cloneGroup557', 'expandBtn557', 'collapseBtn557')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn557" onclick="toggleCodeBlock('cloneGroup557', 'expandBtn557', 'collapseBtn557')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup557"><code class="language-javascript text-sm text-gray-800">async runMaintenance() {
        const startTime = Date.now();
        try {
            console.info(' PipelineManager: Running maintenance checks...');
            // Use the existing autoScraper functionality
            const result = await ensureDefaultTrucksAreScraped();
            const duration = Date.now() - startTime;
            return {
                success: result.errors.length === 0,
                trucksProcessed: result.trucksProcessed,
                newTrucksFound: result.newTrucksFound,
                errors: result.errors.map((e) =&gt; e.url + ': ' + (e.details ?? 'Unknown error')),
                duration,
            };
        }
        catch (error) {
            const duration = Date.now() - startTime;
            const errorMsg = error instanceof Error ? error.message : 'Unknown maintenance error';
            console.error(' PipelineManager: Maintenance failed:', error);
            return {
                success: false,
                trucksProcessed: 0,
                newTrucksFound: 0,
                errors: [errorMsg],
                duration,
            };
        }
    }
}
// Export singleton instance
export const pipelineManager = new PipelineManager();</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/gemini.js (Line 21:2 - Line 37:6), C:/AI/food-truck-finder-poc/dist/lib/lib/gemini.js (Line 22:2 - Line 37:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn558" onclick="toggleCodeBlock('cloneGroup558', 'expandBtn558', 'collapseBtn558')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn558" onclick="toggleCodeBlock('cloneGroup558', 'expandBtn558', 'collapseBtn558')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup558"><code class="language-javascript text-sm text-gray-800">{
        const estimatedTokens = Math.ceil(rawMenuText.length / 4) + 500;
        const usageCheck = await GeminiUsageLimits.checkWithMonitoring(estimatedTokens);
        if (!usageCheck.allowed) {
            console.error('Gemini API usage limit error:', usageCheck.reason);
            return {
                success: false,
                error: &quot;That didn't work, please try again later.&quot;,
            };
        }
        const prompt = PromptTemplates.menuProcessing(rawMenuText);
        return this.makeGeminiRequest(prompt, (text) =&gt; {
            const parsedData = JSON.parse(text);
            return parsedData.categories;
        });
    }
    async</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/gemini.js (Line 37:2 - Line 49:6), C:/AI/food-truck-finder-poc/dist/lib/lib/gemini.js (Line 38:2 - Line 49:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn559" onclick="toggleCodeBlock('cloneGroup559', 'expandBtn559', 'collapseBtn559')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn559" onclick="toggleCodeBlock('cloneGroup559', 'expandBtn559', 'collapseBtn559')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup559"><code class="language-javascript text-sm text-gray-800">{
        const usageCheck = await this.checkUsageLimits();
        if (!usageCheck.canMakeRequest) {
            console.error('Gemini API usage limit error: Daily API limits exceeded');
            return {
                success: false,
                error: &quot;That didn't work, please try again later.&quot;,
            };
        }
        const prompt = PromptTemplates.locationExtraction(textInput);
        return this.makeGeminiRequest(prompt, (text) =&gt; GeminiResponseParser.parseLocationData(text));
    }
    async</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/gemini.js (Line 49:2 - Line 61:6), C:/AI/food-truck-finder-poc/dist/lib/lib/gemini.js (Line 50:2 - Line 61:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn560" onclick="toggleCodeBlock('cloneGroup560', 'expandBtn560', 'collapseBtn560')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn560" onclick="toggleCodeBlock('cloneGroup560', 'expandBtn560', 'collapseBtn560')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup560"><code class="language-javascript text-sm text-gray-800">{
        const usageCheck = await this.checkUsageLimits();
        if (!usageCheck.canMakeRequest) {
            console.error('Gemini API usage limit error: Daily API limits exceeded');
            return {
                success: false,
                error: &quot;That didn't work, please try again later.&quot;,
            };
        }
        const prompt = PromptTemplates.operatingHours(hoursText);
        return this.makeGeminiRequest(prompt, (text) =&gt; GeminiResponseParser.parseOperatingHours(text));
    }
    async</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/gemini.js (Line 61:2 - Line 73:6), C:/AI/food-truck-finder-poc/dist/lib/lib/gemini.js (Line 62:2 - Line 73:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn561" onclick="toggleCodeBlock('cloneGroup561', 'expandBtn561', 'collapseBtn561')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn561" onclick="toggleCodeBlock('cloneGroup561', 'expandBtn561', 'collapseBtn561')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup561"><code class="language-javascript text-sm text-gray-800">{
        const usageCheck = await this.checkUsageLimits();
        if (!usageCheck.canMakeRequest) {
            console.error('Gemini API usage limit error: Daily API limits exceeded');
            return {
                success: false,
                error: &quot;That didn't work, please try again later.&quot;,
            };
        }
        const prompt = PromptTemplates.sentimentAnalysis(reviewText);
        return this.makeGeminiRequest(prompt, (text) =&gt; GeminiResponseParser.parseSentimentAnalysis(text));
    }
    async</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/gemini.js (Line 73:2 - Line 85:6), C:/AI/food-truck-finder-poc/dist/lib/lib/gemini.js (Line 74:2 - Line 85:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn562" onclick="toggleCodeBlock('cloneGroup562', 'expandBtn562', 'collapseBtn562')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn562" onclick="toggleCodeBlock('cloneGroup562', 'expandBtn562', 'collapseBtn562')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup562"><code class="language-javascript text-sm text-gray-800">{
        const usageCheck = await this.checkUsageLimits();
        if (!usageCheck.canMakeRequest) {
            console.error('Gemini API usage limit error: Daily API limits exceeded');
            return {
                success: false,
                error: &quot;That didn't work, please try again later.&quot;,
            };
        }
        const prompt = PromptTemplates.dataEnhancement(rawData);
        return this.makeGeminiRequest(prompt, (text) =&gt; GeminiResponseParser.parseEnhancedFoodTruckData(text));
    }
    async</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/gemini.js (Line 85:2 - Line 120:6), C:/AI/food-truck-finder-poc/dist/lib/lib/gemini.js (Line 86:2 - Line 120:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn563" onclick="toggleCodeBlock('cloneGroup563', 'expandBtn563', 'collapseBtn563')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn563" onclick="toggleCodeBlock('cloneGroup563', 'expandBtn563', 'collapseBtn563')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup563"><code class="language-javascript text-sm text-gray-800">{
        const results = [];
        for (const item of items) {
            let result;
            switch (item.type) {
                case 'menu': {
                    result = await this.processMenuData(item.data);
                    break;
                }
                case 'location': {
                    result = await this.extractLocationFromText(item.data);
                    break;
                }
                case 'hours': {
                    result = await this.standardizeOperatingHours(item.data);
                    break;
                }
                case 'sentiment': {
                    result = await this.analyzeSentiment(item.data);
                    break;
                }
                case 'enhance': {
                    result = await this.enhanceFoodTruckData(item.data); // item.data is already unknown
                    break;
                }
                default: {
                    console.error('Unknown processing type in Gemini batchProcess:', item.type);
                    result = { success: false, error: &quot;That didn't work, please try again later.&quot; };
                    break;
                }
            }
            results.push(result);
        }
        return results;
    }
    async</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/gemini.js (Line 124:2 - Line 136:44), C:/AI/food-truck-finder-poc/dist/lib/lib/gemini.js (Line 125:2 - Line 135:6)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn564" onclick="toggleCodeBlock('cloneGroup564', 'expandBtn564', 'collapseBtn564')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn564" onclick="toggleCodeBlock('cloneGroup564', 'expandBtn564', 'collapseBtn564')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup564"><code class="language-javascript text-sm text-gray-800">{
        const usageCheck = await this.checkUsageLimits();
        if (!usageCheck.canMakeRequest) {
            console.error('Gemini API usage limit error: Daily API limits exceeded for Gemini');
            return {
                success: false,
                error: &quot;That didn't work, please try again later.&quot;,
            };
        }
        
        const prompt = PromptTemplates.foodTruckExtraction(markdownContent, sourceUrl);
        
        // Define JSON schema for structured output</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/gemini.js (Line 201:8 - Line 216:10), C:/AI/food-truck-finder-poc/lib/gemini.js (Line 186:7 - Line 201:8)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn565" onclick="toggleCodeBlock('cloneGroup565', 'expandBtn565', 'collapseBtn565')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn565" onclick="toggleCodeBlock('cloneGroup565', 'expandBtn565', 'collapseBtn565')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup565"><code class="language-javascript text-sm text-gray-800">: {
                            type: ['object', 'null'],
                            properties: {
                                open: {
                                    type: ['string', 'null']
                                },
                                close: {
                                    type: ['string', 'null']
                                },
                                closed: {
                                    type: 'boolean'
                                }
                            },
                            required: ['closed']
                        },
                        wednesday</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/gemini.js (Line 216:10 - Line 231:9), C:/AI/food-truck-finder-poc/lib/gemini.js (Line 186:7 - Line 201:8)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn566" onclick="toggleCodeBlock('cloneGroup566', 'expandBtn566', 'collapseBtn566')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn566" onclick="toggleCodeBlock('cloneGroup566', 'expandBtn566', 'collapseBtn566')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup566"><code class="language-javascript text-sm text-gray-800">: {
                            type: ['object', 'null'],
                            properties: {
                                open: {
                                    type: ['string', 'null']
                                },
                                close: {
                                    type: ['string', 'null']
                                },
                                closed: {
                                    type: 'boolean'
                                }
                            },
                            required: ['closed']
                        },
                        thursday</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/gemini.js (Line 231:9 - Line 246:7), C:/AI/food-truck-finder-poc/lib/gemini.js (Line 186:7 - Line 201:8)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn567" onclick="toggleCodeBlock('cloneGroup567', 'expandBtn567', 'collapseBtn567')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn567" onclick="toggleCodeBlock('cloneGroup567', 'expandBtn567', 'collapseBtn567')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup567"><code class="language-javascript text-sm text-gray-800">: {
                            type: ['object', 'null'],
                            properties: {
                                open: {
                                    type: ['string', 'null']
                                },
                                close: {
                                    type: ['string', 'null']
                                },
                                closed: {
                                    type: 'boolean'
                                }
                            },
                            required: ['closed']
                        },
                        friday</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/gemini.js (Line 246:7 - Line 261:9), C:/AI/food-truck-finder-poc/lib/gemini.js (Line 186:7 - Line 201:8)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn568" onclick="toggleCodeBlock('cloneGroup568', 'expandBtn568', 'collapseBtn568')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn568" onclick="toggleCodeBlock('cloneGroup568', 'expandBtn568', 'collapseBtn568')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup568"><code class="language-javascript text-sm text-gray-800">: {
                            type: ['object', 'null'],
                            properties: {
                                open: {
                                    type: ['string', 'null']
                                },
                                close: {
                                    type: ['string', 'null']
                                },
                                closed: {
                                    type: 'boolean'
                                }
                            },
                            required: ['closed']
                        },
                        saturday</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/gemini.js (Line 261:9 - Line 276:7), C:/AI/food-truck-finder-poc/lib/gemini.js (Line 186:7 - Line 201:8)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn569" onclick="toggleCodeBlock('cloneGroup569', 'expandBtn569', 'collapseBtn569')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn569" onclick="toggleCodeBlock('cloneGroup569', 'expandBtn569', 'collapseBtn569')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup569"><code class="language-javascript text-sm text-gray-800">: {
                            type: ['object', 'null'],
                            properties: {
                                open: {
                                    type: ['string', 'null']
                                },
                                close: {
                                    type: ['string', 'null']
                                },
                                closed: {
                                    type: 'boolean'
                                }
                            },
                            required: ['closed']
                        },
                        sunday</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/gemini.js (Line 276:7 - Line 291:2), C:/AI/food-truck-finder-poc/lib/gemini.js (Line 186:7 - Line 200:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn570" onclick="toggleCodeBlock('cloneGroup570', 'expandBtn570', 'collapseBtn570')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn570" onclick="toggleCodeBlock('cloneGroup570', 'expandBtn570', 'collapseBtn570')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup570"><code class="language-javascript text-sm text-gray-800">: {
                            type: ['object', 'null'],
                            properties: {
                                open: {
                                    type: ['string', 'null']
                                },
                                close: {
                                    type: ['string', 'null']
                                },
                                closed: {
                                    type: 'boolean'
                                }
                            },
                            required: ['closed']
                        }
                    }</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/gemini.js (Line 377:1 - Line 404:2), C:/AI/food-truck-finder-poc/dist/lib/lib/gemini.js (Line 159:1 - Line 186:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn571" onclick="toggleCodeBlock('cloneGroup571', 'expandBtn571', 'collapseBtn571')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn571" onclick="toggleCodeBlock('cloneGroup571', 'expandBtn571', 'collapseBtn571')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup571"><code class="language-javascript text-sm text-gray-800">export async function dispatchGeminiOperation(type, data) {
    switch (type) {
        case 'menu': {
            return gemini.processMenuData(data);
        }
        case 'location': {
            return gemini.extractLocationFromText(data);
        }
        case 'hours': {
            return gemini.standardizeOperatingHours(data);
        }
        case 'sentiment': {
            return gemini.analyzeSentiment(data);
        }
        case 'enhance': {
            return gemini.enhanceFoodTruckData(data);
        }
        case 'foodTruckExtraction': {
            const { markdownContent, sourceUrl } = data;
            return gemini.extractFoodTruckDetailsFromMarkdown(markdownContent, sourceUrl);
        }
        default: {
            return { success: false, error: `Unknown Gemini operation type: ${String(type)}` };
        }
    }
}
// Export singleton instance
export const gemini = new GeminiService();</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/firecrawl.js (Line 1:1 - Line 407:2), C:/AI/food-truck-finder-poc/dist/lib/lib/firecrawl.js (Line 1:1 - Line 407:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn576" onclick="toggleCodeBlock('cloneGroup576', 'expandBtn576', 'collapseBtn576')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn576" onclick="toggleCodeBlock('cloneGroup576', 'expandBtn576', 'collapseBtn576')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup576"><code class="language-javascript text-sm text-gray-800">const FIRECRAWL_CACHE_TTL_MS = 1000 * 60 * 60 * 12; // 12 hours
const firecrawlCache = {};
export class FirecrawlService {
    apiKey;
    baseUrl;
    constructor() {
        this.apiKey = process.env.FIRECRAWL_API_KEY;
        this.baseUrl = 'https://api.firecrawl.dev/v0';
    }
    /**
     * Retrieves a cached result based on the given cache key if it hasn't expired.
     * @example
     * getCachedResult('uniqueCacheKey')
     * FirecrawlResponse or undefined
     * @param {string} cacheKey - The unique identifier for the cached result.
     * @returns {FirecrawlResponse | CrawlJobResponse | CrawlStatusResponse | undefined} The cached data if available and valid, otherwise undefined.
     * @description
     *   - Cleans up expired cache entries before attempting to return a cached result.
     *   - Logs a message when a cache hit occurs.
     */
    getCachedResult(cacheKey) {
        const now = Date.now();
        // Clean up expired cache
        for (const key in firecrawlCache) {
            if (Object.prototype.hasOwnProperty.call(firecrawlCache, key) &amp;&amp;
                now - firecrawlCache[key].timestamp &gt; FIRECRAWL_CACHE_TTL_MS) {
                delete firecrawlCache[key];
            }
        }
        if (firecrawlCache[cacheKey] != undefined &amp;&amp;
            now - firecrawlCache[cacheKey].timestamp &lt; FIRECRAWL_CACHE_TTL_MS) {
            console.info(`FirecrawlService: Cache hit for ${cacheKey}`);
            return firecrawlCache[cacheKey].data;
        }
        return undefined;
    }
    setCacheResult(cacheKey, data) {
        firecrawlCache[cacheKey] = { data, timestamp: Date.now() };
    }
    /**
    * Fetches and processes content from a specified URL, optionally customizing the output format and content inclusion/exclusion via provided options.
    * @example
    * scrapeUrl('https://example.com', { formats: ['html'], includeTags: ['h1', 'p'] })
    * Returns a FirecrawlResponse object containing the scraped data.
    * @param {string} url - The URL from which content will be scraped.
    * @param {Object} options - Optional parameters to customize the scraping process.
    * @param {(string[]|undefined)} options.formats - Specifies the desired output formats: 'markdown' or 'html'.
    * @param {(string[]|undefined)} options.includeTags - Tags to specifically include in the scraping results.
    * @param {(string[]|undefined)} options.excludeTags - Tags to exclude from the scraping results.
    * @param {(boolean|undefined)} options.onlyMainContent - If true, extracts only the main content from the URL.
    * @param {(number|undefined)} options.waitFor - Time in milliseconds to wait before starting the scraping process.
    * @returns {Promise&lt;FirecrawlResponse&gt;} A promise resolving to a FirecrawlResponse containing either the successful scraping results or error details.
    * @description
    *   - Utilizes caching to store and retrieve previously fetched data to minimize repeated requests.
    *   - Sends API requests with authentication headers using the instance's API key.
    *   - Handles errors gracefully, returning a descriptive error message if the scraping process fails.
    */
    async scrapeUrl(url, options = {}) {
        const cacheKey = `scrape:${url}:${JSON.stringify(options)}`;
        const cached = this.getCachedResult(cacheKey);
        if (cached) {
            return cached;
        }
        try {
            const response = await fetch(`${this.baseUrl}/scrape`, {
                method: 'POST',
                headers: {
                    Authorization: `Bearer ${this.apiKey}`,
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    url,
                    formats: options.formats ?? ['markdown'],
                    includeTags: options.includeTags,
                    excludeTags: options.excludeTags,
                    onlyMainContent: options.onlyMainContent ?? true,
                    waitFor: options.waitFor ?? 0,
                }),
            });
            const data = await response.json();
            if (!response.ok) {
                const errorData = data;
                throw new Error(errorData.error ?? `HTTP ${response.status}`);
            }
            this.setCacheResult(cacheKey, data);
            return data;
        }
        catch (error) {
            console.warn('Firecrawl scrape error:', error);
            return {
                success: false,
                error: error instanceof Error ? error.message : 'Unknown error',
            };
        }
    }
    /**
     * Initiates a web crawling process for a specified URL with given options.
     * @example
     * crawlWebsite('https://example.com', { crawlerOptions: { includes: ['.html'] }, pageOptions: { formats: ['markdown'] } })
     * // Returns a promise that resolves to a CrawlJobResponse object
     * @param {string} url - The URL of the website to be crawled.
     * @param {Object} options - Configuration options for the crawling process.
     * @param {Object} [options.crawlerOptions] - Specific options for controlling the crawler behavior.
     * @param {string[]} [options.crawlerOptions.includes] - List of patterns to include in the crawl.
     * @param {string[]} [options.crawlerOptions.excludes] - List of patterns to exclude from the crawl.
     * @param {number} [options.crawlerOptions.maxDepth] - Maximum depth the crawler should reach.
     * @param {number} [options.crawlerOptions.limit] - Limit to the number of pages to crawl.
     * @param {Object} [options.pageOptions] - Options for the page content format and selection.
     * @param {string[]} [options.pageOptions.formats] - Desired formats for the crawled page content.
     * @param {boolean} [options.pageOptions.onlyMainContent] - Whether to include only the main content of the pages.
     * @returns {Promise&lt;CrawlJobResponse&gt;} A promise that resolves with the results of the crawl job including success and potential errors.
     * @description
     *   - Performs a POST request to the Firecrawl service to crawl pages.
     *   - Uses caching to avoid redundant web crawling operations.
     *   - Handles errors gracefully, returning an appropriate error message if the fetch operation fails.
     *   - Crawls with default options which include markdown format and filtering for main content.
     */
    async crawlWebsite(url, options = {}) {
        const cacheKey = `crawl:${url}:${JSON.stringify(options)}`;
        const cached = this.getCachedResult(cacheKey);
        if (cached) {
            return cached;
        }
        try {
            const response = await fetch(`${this.baseUrl}/crawl`, {
                method: 'POST',
                headers: {
                    Authorization: `Bearer ${this.apiKey}`,
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    url,
                    crawlerOptions: {
                        maxDepth: 2,
                        limit: 10,
                        ...options.crawlerOptions,
                    },
                    pageOptions: {
                        formats: ['markdown'],
                        onlyMainContent: true,
                        ...options.pageOptions,
                    },
                }),
            });
            const data = await response.json();
            if (!response.ok) {
                const errorData = data;
                throw new Error(errorData.error ?? `HTTP ${response.status}`);
            }
            this.setCacheResult(cacheKey, data);
            return data;
        }
        catch (error) {
            console.warn('Firecrawl crawl error:', error);
            return {
                success: false,
                error: error instanceof Error ? error.message : 'Unknown error',
            };
        }
    }
    /**
     * Retrieves the crawl status for a given job by its ID.
     * @example
     * getCrawlStatus('12345')
     * { success: true, status: 'completed' }
     * @param {string} jobId - The ID of the job for which the crawl status is requested.
     * @returns {Promise&lt;CrawlStatusResponse&gt;} Resolves to a `CrawlStatusResponse` object containing the crawl status or an error.
     * @description
     *   - Attempts to retrieve the crawl status from a cache before making an HTTP request.
     *   - Fetches crawl status using an authenticated request to the API.
     *   - Caches the crawl status response data to minimize redundant network calls.
     *   - Handles errors gracefully, returning a standardized error response.
     */
    async getCrawlStatus(jobId) {
        const cacheKey = `crawlStatus:${jobId}`;
        const cached = this.getCachedResult(cacheKey);
        if (cached) {
            return cached;
        }
        try {
            const response = await fetch(`${this.baseUrl}/crawl/status/${jobId}`, {
                headers: {
                    Authorization: `Bearer ${this.apiKey}`,
                },
            });
            const data = await response.json();
            if (!response.ok) {
                const errorData = data;
                throw new Error(errorData.error ?? `HTTP ${response.status}`);
            }
            this.setCacheResult(cacheKey, data);
            return data;
        }
        catch (error) {
            console.warn('Firecrawl status error:', error);
            return {
                success: false,
                error: error instanceof Error ? error.message : 'Unknown error',
            };
        }
    }
    // Specialized methods for food truck data
    /**
     * Scrapes a food truck website and retrieves its main content in markdown format.
     * @example
     * scrapeFoodTruckWebsite('https://example.com/food-truck')
     * // Returns: Promise&lt;{ success: true, data: { markdown: '...', name: 'Example Food Truck', source_url: 'https://example.com/food-truck' } }&gt;
     * @param {string} url - The URL of the food truck website to scrape.
     * @returns {Promise&lt;{ success: boolean, data?: { markdown: string, name?: string, source_url?: string }, error?: string }&gt;} The result of the scrape operation, including markdown content and metadata if successful, or an error message if not.
     * @description
     *   - Configured to wait 2000 milliseconds to ensure all content is loaded.
     *   - Uses 'markdown' format for content extraction to maintain text structure.
     *   - Extracts metadata such as the title and source URL if available.
     */
    async scrapeFoodTruckWebsite(url) {
        const result = await this.scrapeUrl(url, {
            formats: ['markdown'],
            onlyMainContent: true,
            waitFor: 2000,
        });
        return result.success &amp;&amp; result.data?.markdown != undefined
            ? {
                success: true,
                data: {
                    markdown: result.data.markdown,
                    name: result.data.metadata?.title,
                    source_url: result.data.metadata?.sourceURL,
                },
            }
            : { success: false, error: result.error ?? 'Markdown content not found' };
    }
    extractPattern(text, pattern) {
        const match = pattern.exec(text);
        return match ? match[1].trim() : undefined;
    }
    /**
    * Extracts a menu section from a given markdown string based on specific keywords.
    * @example
    * extractMenuSection(&quot;menu: Pizza, Pasta, Salad&quot;)
    * // Returns &quot;Pizza, Pasta, Salad&quot;
    * @param {string} markdown - The markdown string to search for menu-related content.
    * @returns {string | undefined} The extracted menu section if found, otherwise undefined.
    * @description
    *   - Searches for menu-related phrases like &quot;menu&quot;, &quot;food&quot;, &quot;items&quot; up to a maximum of 50 characters.
    *   - Implements case-insensitive search patterns.
    *   - Returns the portion of the markdown line following the specific keywords.
    */
    extractMenuSection(markdown) {
        // Use simpler, more efficient regex patterns with fixed max length
        const menuPatterns = [
            /menu\s*:\s*([^\n]{1,50})/i,
            /food\s*:\s*([^\n]{1,50})/i,
            /items?\s*:\s*([^\n]{1,50})/i,
            /what we serve\s*:\s*([^\n]{1,50})/i,
            /our food\s*:\s*([^\n]{1,50})/i,
        ];
        for (const pattern of menuPatterns) {
            const match = pattern.exec(markdown);
            if (match) {
                return match[1].trim();
            }
        }
        return undefined;
    }
    /**
     * Extracts phone and email contact information from a markdown string.
     * @example
     * extractContactInfo(&quot;Contact: +123-456-7890, email: example@test.com&quot;)
     * { phone: &quot;+123-456-7890&quot;, email: &quot;example@test.com&quot; }
     * @param {string} markdown - A markdown string potentially containing contact information.
     * @returns {ContactInfo | undefined} An object containing extracted phone and email, or undefined if none are found.
     * @description
     *   - Utilizes regular expressions to identify phone numbers and email addresses within the markdown.
     *   - Returns an object only when at least one type of contact information is successfully extracted.
     */
    extractContactInfo(markdown) {
        const contact = {}; // Phone number - Use specific patterns to prevent backtracking
        const phoneRegex = /(?:phone|call|contact)(?:\s*:\s*)?([+]?\d{3,4}[.\s-]\d{3}[.\s-]\d{3,4})/i;
        const phoneMatch = phoneRegex.exec(markdown);
        if (phoneMatch) {
            contact.phone = phoneMatch[1].trim();
        } // Email - Use specific pattern to avoid backtracking
        const emailRegex = /([a-zA-Z0-9._%-]{1,64}@[a-zA-Z0-9-]{1,63}\.[a-zA-Z]{2,6})/;
        const emailMatch = emailRegex.exec(markdown);
        if (emailMatch) {
            contact.email = emailMatch[1].trim();
        }
        return Object.keys(contact).length &gt; 0 ? contact : undefined;
    }
    /**
    * Extracts social media profile names from a given markdown string.
    * @example
    * extractSocialMedia(&quot;@john_doe instagram.com/jane Facebook.com/joe&quot;)
    * { instagram: 'john_doe', facebook: 'jane', twitter: 'joe' }
    * @param {string} markdown - A string containing markdown text to parse for social media information.
    * @returns {SocialMediaInfo | undefined} An object containing social media profiles if any are found, otherwise undefined.
    * @description
    *   - Supports extracting profiles for Instagram, Facebook, and Twitter.
    *   - Uses regular expressions to match social media patterns.
    *   - Returns the trimmed username of identified social media profiles.
    *   - Returns undefined if no social media profiles are found in the input.
    */
    extractSocialMedia(markdown) {
        const social = {};
        // Instagram - Use concise character class
        const instagramRegex = /(?:instagram|@)\s*([\w.]+)/i;
        const instagramMatch = instagramRegex.exec(markdown);
        if (instagramMatch) {
            social.instagram = instagramMatch[1].trim();
        }
        // Facebook - With fixed character class
        const facebookRegex = /facebook\.com\/([\w.-]+)/i;
        const facebookMatch = facebookRegex.exec(markdown);
        if (facebookMatch) {
            social.facebook = facebookMatch[1].trim();
        }
        // Twitter - Use concise character class
        const twitterRegex = /(?:twitter|@)\s*([\w.]+)/i; // Changed \w+ to [\w.]+ to allow dots in usernames
        const twitterMatch = twitterRegex.exec(markdown);
        if (twitterMatch) {
            social.twitter = twitterMatch[1].trim();
        }
        return Object.keys(social).length &gt; 0 ? social : undefined;
    }
    /**
     * Performs web scraping on multiple URLs with batching and delay options.
     * @example
     * scrapeMultipleUrls(['http://example.com', 'http://another.com'], { batchSize: 2, delay: 1500 })
     * Returns: Promise resolving to an array containing the results of the scraped URLs.
     * @param {string[]} urls - Array of URLs to be scraped.
     * @param {Object} options - Options object for configuring the scraping process.
     * @param {number} [options.batchSize=5] - Size of each batch in which URLs are processed.
     * @param {number} [options.delay=1000] - Delay between processing each batch in milliseconds.
     * @returns {Promise&lt;Array&lt;{ url: string; result: FirecrawlResponse }&gt;&gt;} Promise resolving to an array of objects, each containing a URL and its corresponding scrape result.
     * @description
     *   - Utilizes a batch mechanism to efficiently handle large sets of URLs.
     *   - Incorporates a delay between batches to comply with potential rate limits.
     */
    async scrapeMultipleUrls(urls, options = {}) {
        const batchSize = options.batchSize ?? 5;
        const delay = options.delay ?? 1000;
        const results = [];
        for (let i = 0; i &lt; urls.length; i += batchSize) {
            const batch = urls.slice(i, i + batchSize);
            const batchPromises = batch.map(async (url) =&gt; {
                const result = await this.scrapeUrl(url);
                return { url, result };
            });
            const batchResults = await Promise.all(batchPromises);
            results.push(...batchResults);
            // Add delay between batches to respect rate limits
            if (i + batchSize &lt; urls.length) {
                await new Promise((resolve) =&gt; { setTimeout(resolve, delay); });
            }
        }
        return results;
    }
    // Rate limiting and error handling
    /**
     * Attempts to scrape content from a given URL with retries in case of failure.
     * @example
     * scrapeWithRetry('https://example.com', 3, 1000)
     * { success: true, data: {...} }
     * @param {string} url - The URL to scrape.
     * @param {number} maxRetries - Maximum number of retry attempts. Defaults to 3.
     * @param {number} backoffMs - Initial wait time before retrying in milliseconds. Defaults to 1000ms.
     * @returns {Promise&lt;FirecrawlResponse&gt;} Promise resolving to a FirecrawlResponse object indicating success or failure.
     * @description
     *   - Implements exponential backoff strategy for rate limit errors.
     *   - Logs attempt details and waiting times between retries.
     *   - Returns last error message if all retry attempts fail.
     */
    async scrapeWithRetry(url, maxRetries = 3, backoffMs = 1000) {
        let lastError;
        for (let attempt = 1; attempt &lt;= maxRetries; attempt += 1) {
            try {
                const result = await this.scrapeUrl(url);
                if (result.success) {
                    return result;
                }
                // If it's a rate limit error, wait longer
                if (result.error?.includes('rate limit') === true) {
                    const waitTime = backoffMs * 2 ** attempt;
                    console.info(`Rate limited. Waiting ${waitTime}ms before retry ${attempt}/${maxRetries}`);
                    await new Promise((resolve) =&gt; { setTimeout(resolve, waitTime); });
                    continue;
                }
                throw new Error(result.error);
            }
            catch (error) {
                lastError = error instanceof Error ? error : new Error(String(error));
                if (attempt === maxRetries) {
                    break;
                }
                const waitTime = backoffMs * 2 ** attempt;
                console.info(`Attempt ${attempt} failed. Retrying in ${waitTime}ms...`);
                await new Promise((resolve) =&gt; { setTimeout(resolve, waitTime); });
            }
        }
        return {
            success: false,
            error: lastError.message,
        };
    }
}
// Export singleton instance
export const firecrawl = new FirecrawlService();</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/discoveryEngine.js (Line 18:1 - Line 50:3), C:/AI/food-truck-finder-poc/dist/lib/lib/discoveryEngine.js (Line 18:1 - Line 50:3)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn581" onclick="toggleCodeBlock('cloneGroup581', 'expandBtn581', 'collapseBtn581')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn581" onclick="toggleCodeBlock('cloneGroup581', 'expandBtn581', 'collapseBtn581')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup581"><code class="language-javascript text-sm text-gray-800">async function tavilySearch(query, options = {}) {
    const baseUrl = process.env.NEXT_PUBLIC_APP_URL ?? 'http://localhost:3003';
    const response = await fetch(`${baseUrl}/api/tavily`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
            operation: 'search',
            params: {
                query,
                limit: options.limit ?? 10,
                ...options,
            },
        }),
    });
    if (!response.ok) {
        throw new Error(`Tavily search failed: ${response.statusText}`);
    }
    const result = (await response.json());
    return result.data?.results ?? result.results ?? [];
}
/**
* Initiates a web crawling operation asynchronously via Firecrawl API and returns the resulting data.
* @example
* firecrawlCrawl('https://example.com', { maxDepth: 3, limit: 50 })
* // Returns a Promise resolving to an array of CrawlResult objects.
* @param {string} url - The URL of the website to initiate the crawl.
* @param {Record&lt;string, unknown&gt;} options - Optional parameters to customize the crawling operation. Default values are maxDepth: 2 and limit: 20.
* @returns {Promise&lt;CrawlResult[]&gt;} Promise resolving to an array of resulting data from the crawl operation.
* @description
*   - Utilizes server URL from environment variable NEXT_PUBLIC_APP_URL or defaults to 'http://localhost:3003'.
*   - Sends a POST request to the '/api/firecrawl' endpoint with specified crawl operation settings.
*   - Throws an error if the HTTP response status is not OK indicating a failure in the crawl operation.
*/</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/discoveryEngine.js (Line 51:1 - Line 73:12), C:/AI/food-truck-finder-poc/dist/lib/lib/discoveryEngine.js (Line 51:1 - Line 73:12)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn582" onclick="toggleCodeBlock('cloneGroup582', 'expandBtn582', 'collapseBtn582')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn582" onclick="toggleCodeBlock('cloneGroup582', 'expandBtn582', 'collapseBtn582')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup582"><code class="language-javascript text-sm text-gray-800">async function firecrawlCrawl(url, options = {}) {
    const baseUrl = process.env.NEXT_PUBLIC_APP_URL ?? 'http://localhost:3003';
    const response = await fetch(`${baseUrl}/api/firecrawl`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
            operation: 'crawl',
            url,
            options: {
                maxDepth: options.maxDepth ?? 2,
                limit: options.limit ?? 20,
                ...options,
            },
        }),
    });
    if (!response.ok) {
        throw new Error(`Firecrawl crawl failed: ${response.statusText}`);
    }
    const result = (await response.json());
    return result.data ?? [];
}
export class FoodTruckDiscoveryEngine {
    constructor</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/discoveryEngine.js (Line 104:5 - Line 135:8), C:/AI/food-truck-finder-poc/dist/lib/lib/discoveryEngine.js (Line 102:5 - Line 133:8)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn583" onclick="toggleCodeBlock('cloneGroup583', 'expandBtn583', 'collapseBtn583')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn583" onclick="toggleCodeBlock('cloneGroup583', 'expandBtn583', 'collapseBtn583')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup583"><code class="language-javascript text-sm text-gray-800">async processSearchResults(searchResults, discoveredUrls) {
        for (const result of searchResults) {
            if (result.url &amp;&amp; (await this.isFoodTruckUrl(result.url))) {
                discoveredUrls.add(result.url);
            }
            // Extract URLs from content
            if (result.content != undefined || result.raw_content != undefined) {
                const content = result.content ?? result.raw_content ?? '';
                const extractedUrls = this.extractFoodTruckUrls(content);
                for (const url of extractedUrls) {
                    if (await this.isFoodTruckUrl(url)) {
                        discoveredUrls.add(url);
                    }
                }
            }
        }
    }
    // Helper method to perform search term discovery
    /**
     * Performs search term discovery using the specified search terms.
     * @example
     * performSearchTermDiscovery(new Set(), discoveryResult)
     * No specific return value, performs actions on `discoveredUrls` and `results`.
     * @param {Set&lt;string&gt;} discoveredUrls - A set to store discovered URLs that have been processed.
     * @param {DiscoveryResult} results - An object to accumulate results and errors stemming from the discovery process.
     * @returns {Promise&lt;void&gt;} Returns a promise that resolves when search term discovery is complete.
     * @description
     *   - Utilizes a search function `tavilySearch` to find results based on search terms.
     *   - Incorporates error handling and logs errors to `results.errors`.
     *   - Implements rate limiting by delaying subsequent searches using `DISCOVERY_CONFIG.rateLimitDelayMs`.
     *   - Processes search results using the `processSearchResults` method if valid results are found.
     */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/discoveryEngine.js (Line 136:5 - Line 175:8), C:/AI/food-truck-finder-poc/dist/lib/lib/discoveryEngine.js (Line 134:5 - Line 173:8)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn584" onclick="toggleCodeBlock('cloneGroup584', 'expandBtn584', 'collapseBtn584')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn584" onclick="toggleCodeBlock('cloneGroup584', 'expandBtn584', 'collapseBtn584')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup584"><code class="language-javascript text-sm text-gray-800">async performSearchTermDiscovery(discoveredUrls, results) {
        for (const searchTerm of this.searchTerms) {
            try {
                console.info(` Searching for: ${searchTerm}`);
                const searchResults = await tavilySearch(searchTerm, {
                    limit: DISCOVERY_CONFIG.searchResultsLimit,
                });
                if (searchResults != undefined &amp;&amp; searchResults.length &gt; 0) {
                    await this.processSearchResults(searchResults, discoveredUrls);
                }
            }
            catch (error) {
                console.error(` Search failed for &quot;${searchTerm}&quot;:`, error);
                results.errors.push(`Search failed for &quot;${searchTerm}&quot;: ${error instanceof Error ? error.message : 'Unknown error'}`);
            }
            await this.delay(DISCOVERY_CONFIG.rateLimitDelayMs);
        }
    }
    // Helper method to perform directory crawling
    async performDirectoryCrawling(discoveredUrls, results) {
        for (const directoryUrl of this.directoryUrls) {
            await this.crawlSingleDirectory(directoryUrl, discoveredUrls, results);
            await this.delay(DISCOVERY_CONFIG.rateLimitDelayMs);
        }
    }
    // Helper method to crawl a single directory
    /**
     * Crawls a single directory and processes discovered URLs.
     * @example
     * crawlSingleDirectory('http://example.com', new Set(), resultsInstance)
     * void
     * @param {string} directoryUrl - The URL of the directory to be crawled.
     * @param {Set&lt;string&gt;} discoveredUrls - A set to store URLs discovered during the crawl.
     * @param {DiscoveryResult} results - An object to store the results and errors of the crawl process.
     * @returns {Promise&lt;void&gt;} Resolves when crawl and processing are complete.
     * @description
     *   - Uses a third-party library, `firecrawlCrawl`, for the crawling operation.
     *   - Handles errors by logging and storing error messages in the results object.
     *   - Limits the depth and number of URLs explored based on configuration.
     */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/discoveryEngine.js (Line 176:5 - Line 203:8), C:/AI/food-truck-finder-poc/dist/lib/lib/discoveryEngine.js (Line 174:5 - Line 201:8)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn585" onclick="toggleCodeBlock('cloneGroup585', 'expandBtn585', 'collapseBtn585')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn585" onclick="toggleCodeBlock('cloneGroup585', 'expandBtn585', 'collapseBtn585')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup585"><code class="language-javascript text-sm text-gray-800">async crawlSingleDirectory(directoryUrl, discoveredUrls, results) {
        try {
            console.info(` Crawling directory: ${directoryUrl}`);
            const crawlResults = await firecrawlCrawl(directoryUrl, {
                maxDepth: DISCOVERY_CONFIG.maxDepthCrawl,
                limit: DISCOVERY_CONFIG.maxUrlsPerRun,
            });
            await this.processCrawlResults(crawlResults, discoveredUrls);
        }
        catch (error) {
            console.error(` Crawl failed for ${directoryUrl}:`, error);
            results.errors.push(`Crawl failed for ${directoryUrl}: ${error instanceof Error ? error.message : 'Unknown error'}`);
        }
    }
    // Helper method to process crawl results
    /**
     * Processes the results from a web crawl and adds discovered URLs to a set if they meet certain criteria.
     * @example
     * processCrawlResults(crawlResults, discoveredUrls)
     * // adds qualifying URLs to the discoveredUrls set
     * @param {unknown} crawlResults - The results obtained from the crawling operation.
     * @param {Set&lt;string&gt;} discoveredUrls - A set to store URLs discovered during processing.
     * @returns {Promise&lt;void&gt;}
     * @description
     *   - Only accepts results that are valid non-empty arrays.
     *   - Checks each item to ensure it's an object containing a 'url' property.
     *   - Uses a helper function isFoodTruckUrl to decide if a URL should be added to the set.
     */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/discoveryEngine.js (Line 204:5 - Line 239:7), C:/AI/food-truck-finder-poc/dist/lib/lib/discoveryEngine.js (Line 202:5 - Line 237:7)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn586" onclick="toggleCodeBlock('cloneGroup586', 'expandBtn586', 'collapseBtn586')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn586" onclick="toggleCodeBlock('cloneGroup586', 'expandBtn586', 'collapseBtn586')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup586"><code class="language-javascript text-sm text-gray-800">async processCrawlResults(crawlResults, discoveredUrls) {
        if (crawlResults != undefined &amp;&amp; Array.isArray(crawlResults) &amp;&amp; crawlResults.length &gt; 0) {
            for (const result of crawlResults) {
                if (typeof result === 'object' &amp;&amp; result !== null &amp;&amp; 'url' in result) {
                    const resultUrl = result.url;
                    if (resultUrl != undefined &amp;&amp;
                        typeof resultUrl === 'string' &amp;&amp;
                        (await this.isFoodTruckUrl(resultUrl))) {
                        discoveredUrls.add(resultUrl);
                    }
                }
            }
        }
    }
    // Helper method to perform location-specific discovery
    async performLocationDiscovery(discoveredUrls, results) {
        for (const city of SC_TARGET_CITIES) {
            await this.searchSingleCity(city, discoveredUrls, results);
            await this.delay(DISCOVERY_CONFIG.rateLimitDelayMs);
        }
    }
    // Helper method to search a single city
    /**
    * Initiates a search for food trucks within a specified city in South Carolina.
    * @example
    * searchSingleCity(&quot;Charleston&quot;, discoveredUrls, results)
    * // Returns undefined but processes the data internally and updates results object.
    * @param {string} city - The name of the city where food trucks are to be searched.
    * @param {Set&lt;string&gt;} discoveredUrls - A Set to keep track of URLs that have been discovered during the search.
    * @param {DiscoveryResult} results - Object to store errors and possibly other results related to the discovery process.
    * @returns {Promise&lt;void&gt;} Resolves after processing the search results.
    * @description
    *   - Uses `tavilySearch` function to perform the location-based search with a limit of 5 results.
    *   - Handles errors by logging them and updating the results object with error messages.
    *   - Assumes South Carolina as the default state for city searches.
    */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/discoveryEngine.js (Line 240:5 - Line 266:8), C:/AI/food-truck-finder-poc/dist/lib/lib/discoveryEngine.js (Line 238:5 - Line 264:8)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn587" onclick="toggleCodeBlock('cloneGroup587', 'expandBtn587', 'collapseBtn587')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn587" onclick="toggleCodeBlock('cloneGroup587', 'expandBtn587', 'collapseBtn587')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup587"><code class="language-javascript text-sm text-gray-800">async searchSingleCity(city, discoveredUrls, results) {
        try {
            console.info(` Searching for food trucks in ${city}, SC`);
            const locationQuery = `food trucks in ${city} South Carolina`;
            const searchResults = await tavilySearch(locationQuery, {
                limit: 5,
            });
            await this.processLocationSearchResults(searchResults, discoveredUrls);
        }
        catch (error) {
            console.error(` Location search failed for ${city}:`, error);
            results.errors.push(`Location search failed for ${city}: ${error instanceof Error ? error.message : 'Unknown error'}`);
        }
    }
    // Helper method to process location search results
    /**
     * Processes search results to discover specific URLs and add them to a set.
     * @example
     * processLocationSearchResults(searchResults, discoveredUrls);
     * // The set discoveredUrls will be populated with food truck URLs from searchResults
     * @param {unknown} searchResults - Array of search result objects potentially containing URLs.
     * @param {Set&lt;string&gt;} discoveredUrls - Set used to collect discovered food truck URLs.
     * @returns {Promise&lt;void&gt;} Resolves when all URLs are processed and added to the set.
     * @description
     *   - Ensures the searchResults contain an array of objects with valid URL properties.
     *   - Filters URLs through isFoodTruckUrl method before adding them to discoveredUrls.
     */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/discoveryEngine.js (Line 267:5 - Line 294:8), C:/AI/food-truck-finder-poc/dist/lib/lib/discoveryEngine.js (Line 265:5 - Line 292:8)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn588" onclick="toggleCodeBlock('cloneGroup588', 'expandBtn588', 'collapseBtn588')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn588" onclick="toggleCodeBlock('cloneGroup588', 'expandBtn588', 'collapseBtn588')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup588"><code class="language-javascript text-sm text-gray-800">async processLocationSearchResults(searchResults, discoveredUrls) {
        if (searchResults != undefined &amp;&amp; Array.isArray(searchResults) &amp;&amp; searchResults.length &gt; 0) {
            for (const result of searchResults) {
                if (typeof result === 'object' &amp;&amp; result !== null &amp;&amp; 'url' in result) {
                    const resultUrl = result.url;
                    if (resultUrl != undefined &amp;&amp;
                        typeof resultUrl === 'string' &amp;&amp;
                        (await this.isFoodTruckUrl(resultUrl))) {
                        discoveredUrls.add(resultUrl);
                    }
                }
            }
        }
    }
    // Helper method to store discovered URLs from discovery process
    /**
     * Stores a set of discovered URLs from a discovery process into a database.
     * @example
     * storeDiscoveredUrlsFromDiscovery(new Set(['http://example.com', 'http://example.org']), discoveryResult)
     * // No return value (undefined).
     * @param {Set&lt;string&gt;} discoveredUrls - A set of URLs that have been discovered and need to be stored.
     * @param {DiscoveryResult} results - An object to track and accumulate errors encountered during storage.
     * @returns {Promise&lt;void&gt;} Resolves when all URLs are processed and stored.
     * @description
     *   - This function iterates over a set of URLs and stores each individually.
     *   - Errors encountered during the storage process are logged and appended to the provided results object.
     *   - Utilizes an asynchronous operation to store URLs and handle potential failures gracefully.
     */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/discoveryEngine.js (Line 295:5 - Line 327:7), C:/AI/food-truck-finder-poc/dist/lib/lib/discoveryEngine.js (Line 293:5 - Line 325:7)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn589" onclick="toggleCodeBlock('cloneGroup589', 'expandBtn589', 'collapseBtn589')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn589" onclick="toggleCodeBlock('cloneGroup589', 'expandBtn589', 'collapseBtn589')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup589"><code class="language-javascript text-sm text-gray-800">async storeDiscoveredUrlsFromDiscovery(discoveredUrls, results) {
        for (const url of discoveredUrls) {
            try {
                const stored = await this.storeDiscoveredUrl(url, 'autonomous_search', {
                    search_context: 'full_discovery',
                    discovery_timestamp: new Date().toISOString(),
                });
                if (stored.isNew === true) {
                    results.urls_stored += 1;
                }
                else {
                    results.urls_duplicates += 1;
                }
            }
            catch (error) {
                console.error(` Failed to store URL ${url}:`, error);
                results.errors.push(`Failed to store URL ${url}: ${error instanceof Error ? error.message : 'Unknown error'}`);
            }
        }
    }
    /**
    * Initiates autonomous discovery of new food truck URLs.
    * @example
    * discoverNewFoodTrucks()
    * Returns a Promise resolving to a DiscoveryResult object.
    * @param {none} No parameters required.
    * @returns {Promise&lt;DiscoveryResult&gt;} An object containing the counts of discovered, stored, and duplicate URLs and any errors encountered.
    * @description
    *   - Utilizes multiple discovery methods: search term, directory crawling, and location-specific search.
    *   - Aggregates discovered URLs in a Set to ensure uniqueness.
    *   - Logs informative messages regarding the discovery and storage process.
    *   - Handles the storage of newly discovered URLs and logs duplicates.
    */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/discoveryEngine.js (Line 328:5 - Line 362:8), C:/AI/food-truck-finder-poc/dist/lib/lib/discoveryEngine.js (Line 326:5 - Line 360:8)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn590" onclick="toggleCodeBlock('cloneGroup590', 'expandBtn590', 'collapseBtn590')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn590" onclick="toggleCodeBlock('cloneGroup590', 'expandBtn590', 'collapseBtn590')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup590"><code class="language-javascript text-sm text-gray-800">async discoverNewFoodTrucks() {
        console.info(' Starting autonomous food truck discovery...');
        const results = {
            urls_discovered: 0,
            urls_stored: 0,
            urls_duplicates: 0,
            errors: [],
        };
        const discoveredUrls = new Set();
        // 1. Search for food trucks using Tavily search
        await this.performSearchTermDiscovery(discoveredUrls, results);
        // 2. Crawl known food truck directory sites
        await this.performDirectoryCrawling(discoveredUrls, results);
        // 3. Location-specific discovery for SC cities
        await this.performLocationDiscovery(discoveredUrls, results);
        results.urls_discovered = discoveredUrls.size;
        console.info(` Discovered ${results.urls_discovered} potential food truck URLs`);
        // 4. Store new URLs in database
        await this.storeDiscoveredUrlsFromDiscovery(discoveredUrls, results);
        console.info(` Discovery complete: ${results.urls_stored} new URLs stored, ${results.urls_duplicates} duplicates skipped`);
        return results;
    }
    /**
     * Extracts valid URLs from a given string content.
     * @example
     * extractFoodTruckUrls(&quot;Check out these two links: https://foodtrucklink.com/menu, and https://anotherlink.com!&quot;)
     * [&quot;https://foodtrucklink.com/menu&quot;, &quot;https://anotherlink.com&quot;]
     * @param {string} content - The textual content from which URLs are extracted.
     * @returns {string[]} An array of valid URLs extracted from the content.
     * @description
     *   - Utilizes a regular expression pattern to identify potential URLs.
     *   - Performs basic URL validation using the URL constructor.
     *   - Cleans up URLs by removing trailing punctuation such as periods, commas, semicolons, etc.
     *   - Skips invalid URLs identified during the validation process.
     */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/discoveryEngine.js (Line 363:5 - Line 395:8), C:/AI/food-truck-finder-poc/dist/lib/lib/discoveryEngine.js (Line 361:5 - Line 393:8)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn591" onclick="toggleCodeBlock('cloneGroup591', 'expandBtn591', 'collapseBtn591')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn591" onclick="toggleCodeBlock('cloneGroup591', 'expandBtn591', 'collapseBtn591')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup591"><code class="language-javascript text-sm text-gray-800">extractFoodTruckUrls(content) {
        const urls = [];
        // Look for URL patterns in content - using a safer regex to avoid backtracking
        const urlRegex = /https?:\/\/[^\s&lt;&gt;&quot;']{1,200}/g;
        const foundUrls = content.match(urlRegex) ?? [];
        for (const url of foundUrls) {
            try {
                // Basic URL validation
                new URL(url);
                // Remove trailing punctuation - using safer regex to avoid backtracking
                const cleanUrl = url.replace(/[.,;!?]$/, '');
                urls.push(cleanUrl);
            }
            catch {
                // Invalid URL, skip
                continue;
            }
        }
        return urls;
    }
    /**
     * Checks if a given URL is related to a food truck.
     * @example
     * isFoodTruckUrl(&quot;https://bestfoodtruck.com&quot;)
     * true
     * @param {string} url - The URL to validate and check against known food truck patterns.
     * @returns {Promise&lt;boolean&gt;} True if the URL is likely related to a food truck, false otherwise.
     * @description
     *   - Uses keyword matching to detect food truck-related URLs.
     *   - Excludes common social media and review domains via blacklist.
     *   - Validates if the URL is already present in `discovered_urls` or `food_trucks` database.
     *   - Accepts common business domains not typically associated with blogs or news sites.
     */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/discoveryEngine.js (Line 396:5 - Line 483:8), C:/AI/food-truck-finder-poc/dist/lib/lib/discoveryEngine.js (Line 394:5 - Line 481:8)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn592" onclick="toggleCodeBlock('cloneGroup592', 'expandBtn592', 'collapseBtn592')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn592" onclick="toggleCodeBlock('cloneGroup592', 'expandBtn592', 'collapseBtn592')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup592"><code class="language-javascript text-sm text-gray-800">async isFoodTruckUrl(url) {
        try {
            // Basic URL validation
            new URL(url);
            // Food truck indicators in URL
            const foodTruckKeywords = [
                'food-truck',
                'foodtruck',
                'mobile-food',
                'street-food',
                'truck',
                'kitchen',
                'eats',
                'bbq',
                'burger',
                'taco',
                'catering',
                'mobile',
                'chef',
                'bistro',
                'cafe',
            ];
            // Blacklist - skip these domains
            const blacklistKeywords = [
                'facebook.com',
                'instagram.com',
                'twitter.com',
                'linkedin.com',
                'youtube.com',
                'yelp.com',
                'google.com',
                'maps.google.com',
                'foursquare.com',
                'tripadvisor.com',
                'zomato.com',
                'eventbrite.com',
                'meetup.com',
            ];
            const urlLower = url.toLowerCase();
            // Skip social media and review sites
            if (blacklistKeywords.some((keyword) =&gt; urlLower.includes(keyword))) {
                return false;
            }
            // Check if we already have this URL in discovered_urls
            if (supabaseAdmin == undefined) {
                return false;
            }
            const { data: existingDiscovered } = await supabaseAdmin
                .from('discovered_urls')
                .select('id')
                .eq('url', url)
                .limit(1);
            if (existingDiscovered != undefined &amp;&amp; existingDiscovered.length &gt; 0) {
                return false; // Already discovered
            }
            // Check if we already have this URL in food_trucks
            const { data: existingTrucks } = await supabaseAdmin
                .from('food_trucks')
                .select('id')
                .contains('source_urls', [url])
                .limit(1);
            if (existingTrucks != undefined &amp;&amp; existingTrucks.length &gt; 0) {
                return false; // Already have this URL
            }
            // Accept if has food truck keywords or if it's a business domain
            return (foodTruckKeywords.some((keyword) =&gt; urlLower.includes(keyword)) ||
                (/\.(com|net|org|biz|info)/.test(urlLower) &amp;&amp;
                    !urlLower.includes('blog') &amp;&amp;
                    !urlLower.includes('news')));
        }
        catch (error) {
            console.error('Error validating food truck URL:', error);
            return false;
        }
    }
    /**
     * Initiates a discovery process for food trucks in the specified city and state.
     * @example
     * getLocationSpecificDiscovery('Charleston', 'SC')
     * Promise &lt;DiscoveryResult&gt; {urls_discovered: 5, urls_stored: 4, urls_duplicates: 1, errors: []}
     * @param {string} city - The city where the search is to be performed.
     * @param {string} [state='SC'] - The state where the search is to be performed; defaults to 'SC'.
     * @returns {Promise&lt;DiscoveryResult&gt;} An object containing the discovery results and any errors encountered.
     * @description
     *   - Logs the initiation and completion of the discovery process with results.
     *   - Performs the search using a specified query and stores new URLs found.
     *   - Captures and logs any errors encountered during the search process.
     */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/discoveryEngine.js (Line 484:5 - Line 525:7), C:/AI/food-truck-finder-poc/dist/lib/lib/discoveryEngine.js (Line 482:5 - Line 523:7)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn593" onclick="toggleCodeBlock('cloneGroup593', 'expandBtn593', 'collapseBtn593')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn593" onclick="toggleCodeBlock('cloneGroup593', 'expandBtn593', 'collapseBtn593')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup593"><code class="language-javascript text-sm text-gray-800">async getLocationSpecificDiscovery(city, state = 'SC') {
        console.info(` Starting location-specific discovery for ${city}, ${state}`);
        const locationQuery = `food trucks in ${city} ${state}`;
        const results = {
            urls_discovered: 0,
            urls_stored: 0,
            urls_duplicates: 0,
            errors: [],
        };
        const discoveredUrls = new Set();
        try {
            await this.performLocationSpecificSearch(locationQuery, discoveredUrls);
            results.urls_discovered = discoveredUrls.size;
            await this.storeLocationDiscoveryResults({
                discoveredUrls,
                locationQuery,
                city,
                state,
                results,
            });
        }
        catch (error) {
            console.error(` Location search failed for ${city}:`, error);
            results.errors.push(`Location search failed for ${city}: ${error instanceof Error ? error.message : 'Unknown error'}`);
        }
        console.info(` Location discovery complete for ${city}: ${results.urls_stored} new URLs stored`);
        return results;
    }
    // Helper method to perform location-specific search
    /**
    * Executes a location-specific search and processes the results.
    * @example
    * performLocationSpecificSearch(&quot;San Francisco&quot;, new Set())
    * // Processes search results for &quot;San Francisco&quot; location
    * @param {string} locationQuery - The location query to perform the search.
    * @param {Set&lt;string&gt;} discoveredUrls - A set to track URLs that have already been discovered.
    * @returns {Promise&lt;void&gt;} Completes search processing without return value.
    * @description
    *   - Searches are performed with a limit of 15 results.
    *   - Only non-empty search results are processed.
    *   - Uses asynchronous calls to handle search and processing operations.
    */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/discoveryEngine.js (Line 526:5 - Line 558:8), C:/AI/food-truck-finder-poc/dist/lib/lib/discoveryEngine.js (Line 524:5 - Line 556:8)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn594" onclick="toggleCodeBlock('cloneGroup594', 'expandBtn594', 'collapseBtn594')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn594" onclick="toggleCodeBlock('cloneGroup594', 'expandBtn594', 'collapseBtn594')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup594"><code class="language-javascript text-sm text-gray-800">async performLocationSpecificSearch(locationQuery, discoveredUrls) {
        const searchResults = await tavilySearch(locationQuery, { limit: 15 });
        if (searchResults != undefined &amp;&amp; searchResults.length &gt; 0) {
            for (const result of searchResults) {
                await this.processSearchResult(result, discoveredUrls);
            }
        }
    }
    // Helper method to process a single search result
    async processSearchResult(result, discoveredUrls) {
        if (typeof result === 'object' &amp;&amp; result !== null &amp;&amp; 'url' in result) {
            const resultUrl = result.url;
            if (resultUrl != undefined &amp;&amp; resultUrl !== '' &amp;&amp; (await this.isFoodTruckUrl(resultUrl))) {
                discoveredUrls.add(resultUrl);
            }
            // Extract URLs from content
            await this.extractUrlsFromContent(result, discoveredUrls);
        }
    }
    // Helper method to extract URLs from content
    /**
     * Extracts food truck URLs from a given result object and adds them to a discovered URL set.
     * @example
     * extractUrlsFromContent(resultObject, discoveredUrlSet)
     * void
     * @param {unknown} result - The result object potentially containing content with URLs.
     * @param {Set&lt;string&gt;} discoveredUrls - A set where extracted food truck URLs will be added.
     * @returns {Promise&lt;void&gt;} Resolves when URLs are added to the set.
     * @description
     *   - Parses both `content` and `raw_content` properties for URLs.
     *   - Uses helper method `extractFoodTruckUrls` to identify specific URLs.
     *   - Filters URLs through `isFoodTruckUrl` method to ensure relevance before adding.
     */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/discoveryEngine.js (Line 559:5 - Line 596:8), C:/AI/food-truck-finder-poc/dist/lib/lib/discoveryEngine.js (Line 557:5 - Line 594:8)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn595" onclick="toggleCodeBlock('cloneGroup595', 'expandBtn595', 'collapseBtn595')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn595" onclick="toggleCodeBlock('cloneGroup595', 'expandBtn595', 'collapseBtn595')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup595"><code class="language-javascript text-sm text-gray-800">async extractUrlsFromContent(result, discoveredUrls) {
        if (typeof result === 'object' &amp;&amp; result != undefined) {
            const resultObj = result;
            if (resultObj.content != undefined || resultObj.raw_content != undefined) {
                const content = resultObj.content ?? resultObj.raw_content ?? '';
                const extractedUrls = this.extractFoodTruckUrls(content);
                for (const url of extractedUrls) {
                    if (await this.isFoodTruckUrl(url)) {
                        discoveredUrls.add(url);
                    }
                }
            }
        }
    }
    // Helper method to store location discovery results
    /**
     * Stores location discovery results by iterating through a set of discovered URLs.
     * @example
     * storeLocationDiscoveryResults({
     *   discoveredUrls: new Set(['http://example.com']),
     *   locationQuery: 'pizza restaurant',
     *   city: 'San Francisco',
     *   state: 'CA',
     *   results: {}
     * })
     *
     * @param {Object} params - Parameters for storing the discovery results.
     * @param {Set&lt;string&gt;} params.discoveredUrls - A set of URLs to be stored.
     * @param {string} params.locationQuery - The location query used in the search.
     * @param {string} params.city - The target city for the location search.
     * @param {string} params.state - The target state for the location search.
     * @param {DiscoveryResult} params.results - Object to store results and errors.
     * @returns {Promise&lt;void&gt;} No return value.
     * @description
     *   - Logs an error and records it in the results if storing a URL fails.
     *   - Assumes the existence of a method `storeDiscoveredUrl` to handle storage logic.
     *   - The `results` object is mutated by adding error messages directly.
     */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/discoveryEngine.js (Line 597:5 - Line 624:8), C:/AI/food-truck-finder-poc/dist/lib/lib/discoveryEngine.js (Line 595:5 - Line 622:8)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn596" onclick="toggleCodeBlock('cloneGroup596', 'expandBtn596', 'collapseBtn596')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn596" onclick="toggleCodeBlock('cloneGroup596', 'expandBtn596', 'collapseBtn596')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup596"><code class="language-javascript text-sm text-gray-800">async storeLocationDiscoveryResults(params) {
        const { discoveredUrls, locationQuery, city, state, results } = params;
        for (const url of discoveredUrls) {
            try {
                const stored = await this.storeDiscoveredUrl(url, 'tavily_search', {
                    search_query: locationQuery,
                    target_city: city,
                    target_state: state,
                });
                if (stored.isNew === true) {
                    results.urls_stored += 1;
                }
                else {
                    results.urls_duplicates += 1;
                }
            }
            catch (error) {
                console.error(` Failed to store URL ${url}:`, error);
                results.errors.push(`Failed to store URL ${url}: ${error instanceof Error ? error.message : 'Unknown error'}`);
            }
        }
    }
    delay(ms) {
        return new Promise((resolve) =&gt; setTimeout(resolve, ms));
    }
    /**
     * Store multiple discovered URLs with metadata
     */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/discoveryEngine.js (Line 625:5 - Line 652:8), C:/AI/food-truck-finder-poc/dist/lib/lib/discoveryEngine.js (Line 623:5 - Line 649:8)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn597" onclick="toggleCodeBlock('cloneGroup597', 'expandBtn597', 'collapseBtn597')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn597" onclick="toggleCodeBlock('cloneGroup597', 'expandBtn597', 'collapseBtn597')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup597"><code class="language-javascript text-sm text-gray-800">async storeDiscoveredUrls(urls, discoveryMethod = 'manual', metadata = {}) {
        const result = {
            urls_stored: 0,
            urls_duplicates: 0,
            errors: [],
        };
        for (const url of urls) {
            try {
                const stored = await this.storeDiscoveredUrl(url, discoveryMethod, metadata);
                if (stored.isNew === true) {
                    result.urls_stored += 1;
                }
                else {
                    result.urls_duplicates += 1;
                }
            }
            catch (error) {
                const errorMsg = `Failed to store URL ${url}: ${error instanceof Error ? error.message : 'Unknown error'}`;
                result.errors.push(errorMsg);
                console.error(errorMsg);
            }
        }
        return result;
    }
    /**
     * Enhanced store method with discovery method and metadata
     * Includes quality filtering to prevent storing obviously non-food truck URLs
     */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/discoveryEngine.js (Line 688:13 - Line 723:8), C:/AI/food-truck-finder-poc/dist/lib/lib/discoveryEngine.js (Line 669:13 - Line 700:8)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn598" onclick="toggleCodeBlock('cloneGroup598', 'expandBtn598', 'collapseBtn598')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn598" onclick="toggleCodeBlock('cloneGroup598', 'expandBtn598', 'collapseBtn598')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup598"><code class="language-javascript text-sm text-gray-800">};
            
            // Add optional columns only if they exist in the table
            try {
                // Check if discovery_method column exists
                const { error: testError } = await supabaseAdmin
                    .from('discovered_urls')
                    .select('discovery_method')
                    .limit(1);
                if (!testError) {
                    insertData.discovery_method = discoveryMethod;
                    insertData.region = 'SC';
                    insertData.metadata = metadata;
                }
            }
            catch {
                // Column doesn't exist, continue without it
                console.info('Some columns missing in discovered_urls table, using basic structure');
            }
            
            const { error } = await supabaseAdmin.from('discovered_urls').insert(insertData);
            if (error) {
                throw error;
            }
            return { isNew: true };
        }
        catch (error) {
            console.error('Error storing discovered URL:', error);
            throw error;
        }
    }
    
    /**
     * Check if a URL is obviously not related to food trucks
     * This prevents storing URLs that will never produce food truck data
     */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/discoveryEngine.js (Line 780:2 - Line 824:2), C:/AI/food-truck-finder-poc/lib/pipeline/scrapingProcessor.js (Line 290:2 - Line 334:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn599" onclick="toggleCodeBlock('cloneGroup599', 'expandBtn599', 'collapseBtn599')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn599" onclick="toggleCodeBlock('cloneGroup599', 'expandBtn599', 'collapseBtn599')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup599"><code class="language-javascript text-sm text-gray-800">updateUrlQualityScore(url, result) {
        try {
            if (!supabaseAdmin) {
                return;
            }
            
            // Get current URL record
            const { data: urlRecord, error: fetchError } = await supabaseAdmin
                .from('discovered_urls')
                .select('processing_attempts, quality_score')
                .eq('url', url)
                .limit(1);
            
            if (fetchError || !urlRecord || urlRecord.length === 0) {
                return;
            }
            
            const current = urlRecord[0];
            const currentAttempts = current.processing_attempts || 0;
            const currentScore = current.quality_score || 0.5;
            
            // Update based on result
            let newScore, newAttempts;
            if (result === 'success') {
                newScore = Math.min(1, currentScore + 0.2); // Increase quality score on success
                newAttempts = currentAttempts;
            } else {
                newScore = Math.max(0, currentScore - 0.3); // Decrease quality score on failure
                newAttempts = currentAttempts + 1;
            }
            
            // Update the record
            await supabaseAdmin
                .from('discovered_urls')
                .update({ 
                    quality_score: newScore,
                    processing_attempts: newAttempts,
                    last_processed_at: new Date().toISOString()
                })
                .eq('url', url);
            
        } catch (error) {
            console.warn(`Could not update URL quality score for ${url}:`, error);
        }
    }</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/config.js (Line 1:1 - Line 31:74), C:/AI/food-truck-finder-poc/dist/lib/lib/config.js (Line 1:1 - Line 31:74)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn600" onclick="toggleCodeBlock('cloneGroup600', 'expandBtn600', 'collapseBtn600')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn600" onclick="toggleCodeBlock('cloneGroup600', 'expandBtn600', 'collapseBtn600')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup600"><code class="language-javascript text-sm text-gray-800">// lib/config.ts
// A list of default URLs that the application should attempt to scrape automatically
// if their data is missing or stale.
export const DEFAULT_SCRAPE_URLS = [
    'https://eatrotirolls.com/',
    // Dynamic URLs will be added from the discovered_urls table
];
// Defines how old data can be (in days) before it's considered stale and needs re-scraping.
export const DEFAULT_STALENESS_THRESHOLD_DAYS = 7; // 7 days
// South Carolina cities to target for autonomous discovery
export const SC_TARGET_CITIES = [
    'Charleston',
    'Columbia',
    'Greenville',
    'Spartanburg',
    'Rock Hill',
    'Mount Pleasant',
    'North Charleston',
    'Summerville',
    'Goose Creek',
    'Hilton Head',
];
// Discovery configuration
export const DISCOVERY_CONFIG = {
    maxUrlsPerRun: 50,
    maxDepthCrawl: 2,
    searchResultsLimit: 15,
    batchSize: 10,
    rateLimitDelayMs: 1000,
};
// You can add other global configurations here as the application grows.</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/autoScraper.js (Line 98:1 - Line 138:4), C:/AI/food-truck-finder-poc/dist/lib/lib/autoScraper.js (Line 97:1 - Line 137:4)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn603" onclick="toggleCodeBlock('cloneGroup603', 'expandBtn603', 'collapseBtn603')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn603" onclick="toggleCodeBlock('cloneGroup603', 'expandBtn603', 'collapseBtn603')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup603"><code class="language-javascript text-sm text-gray-800">async function processExistingTruckResult(url, result, counters, errors) {
    switch (result.status) {
        case 're-scraping_triggered': {
            counters.trucksProcessed += 1;
            await updateDiscoveredUrlStatus(url, 'processing', 'Re-scraping triggered due to stale data');
            break;
        }
        case 'fresh': {
            await updateDiscoveredUrlStatus(url, 'processed', 'Data is fresh, no action needed');
            break;
        }
        case 'error': {
            errors.push({ url, details: result.details });
            await updateDiscoveredUrlStatus(url, 'irrelevant', `Error: ${result.details}`);
            break;
        }
        // No default
    }
}
// Helper function to process new truck results
/**
 * Processes the result of a new truck resource and updates the counters accordingly.
 * @example
 * processNewTruckResult('https://example.com/truck', { status: 'initial_scrape_triggered' }, { trucksProcessed: 5, newTrucksFound: 2 }, []);
 * // Updates counters and changes URL status to 'processing'.
 * @param {string} url - The URL of the new truck resource to be processed.
 * @param {Object} result - The result object containing the status and optional details of the process.
 * @param {string} result.status - The status of the truck processing result.
 * @param {string} [result.details] - Optional detailed message about the result.
 * @param {Object} counters - An object keeping count of processed trucks and newly found trucks.
 * @param {number} counters.trucksProcessed - The current count of processed trucks.
 * @param {number} counters.newTrucksFound - The count of newly found trucks.
 * @param {Array&lt;Object&gt;} errors - A list of error objects for unsuccessful processing attempts.
 * @param {string} errors.url - The URL of the truck resource that encountered an error.
 * @param {string} [errors.details] - Optional error details associated with the URL.
 * @returns {Promise&lt;void&gt;} This function returns nothing but performs asynchronous URL status updates and error logging.
 * @description
 *   - The function distinguishes between two specific statuses: 'initial_scrape_triggered' and 'error'.
 *   - For 'initial_scrape_triggered', it updates the counters and marks the URL as 'processing'.
 *   - For 'error', it logs the error details and marks the URL as 'irrelevant'.
 */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/autoScraper.js (Line 139:1 - Line 162:3), C:/AI/food-truck-finder-poc/dist/lib/lib/autoScraper.js (Line 138:1 - Line 161:3)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn604" onclick="toggleCodeBlock('cloneGroup604', 'expandBtn604', 'collapseBtn604')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn604" onclick="toggleCodeBlock('cloneGroup604', 'expandBtn604', 'collapseBtn604')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup604"><code class="language-javascript text-sm text-gray-800">async function processNewTruckResult(url, result, counters, errors) {
    if (result.status === 'initial_scrape_triggered') {
        counters.newTrucksFound += 1;
        counters.trucksProcessed += 1;
        await updateDiscoveredUrlStatus(url, 'processing', 'Initial scraping triggered');
    }
    else if (result.status === 'error') {
        errors.push({ url, details: result.details });
        await updateDiscoveredUrlStatus(url, 'irrelevant', `Error: ${result.details}`);
    }
}
// Helper function to find existing truck for URL
/**
* Find an existing food truck based on the provided source URL.
* @example
* findExistingTruck('https://foodtruck.com/123')
* { truck: { id: 1, last_scraped_at: '2023-09-16T00:00:00Z', source_urls: ['https://foodtruck.com'] } }
* @param {string} url - The source URL used to search for an existing truck in the database.
* @returns {Promise&lt;{ truck?: FoodTruck; error?: string }&gt;} An object containing either the existing truck data or an error message.
* @description
*   - Utilizes Supabase admin client to query the 'food_trucks' database table.
*   - Warns in the console when a query error occurs during the database lookup.
*   - Limits the query results to a single truck that matches the URL criteria.
*/</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/autoScraper.js (Line 163:1 - Line 191:4), C:/AI/food-truck-finder-poc/dist/lib/lib/autoScraper.js (Line 162:1 - Line 190:4)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn605" onclick="toggleCodeBlock('cloneGroup605', 'expandBtn605', 'collapseBtn605')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn605" onclick="toggleCodeBlock('cloneGroup605', 'expandBtn605', 'collapseBtn605')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup605"><code class="language-javascript text-sm text-gray-800">async function findExistingTruck(url) {
    if (!supabaseAdmin) {
        return { error: 'Supabase admin client not available' };
    }
    const { data: existingTrucks, error: truckQueryError } = await supabaseAdmin
        .from('food_trucks')
        .select('id, last_scraped_at, source_urls')
        .or(`source_urls.cs.{&quot;${url}&quot;}`)
        .limit(1);
    if (truckQueryError) {
        console.warn(`AutoScraper: Error querying for existing truck for url ${url}:`, truckQueryError.message);
        return { error: `Supabase query error: ${truckQueryError.message}` };
    }
    const truck = existingTrucks != undefined &amp;&amp; existingTrucks.length &gt; 0
        ? existingTrucks[0]
        : undefined;
    return { truck };
}
/**
 * Initiates the autonomous scraping process and ensures default trucks data is fetched.
 * @example
 * ensureDefaultTrucksAreScraped()
 * Returns a result object containing the number of trucks processed, new trucks found, and any errors encountered.
 * @returns {Promise&lt;AutoScrapeResult&gt;} An object containing the results of the scraping process, including processed trucks count, new trucks discovered count, and encountered errors.
 * @description
 *   - Combines static default URLs with dynamically discovered URLs for scraping.
 *   - Handles both existing and new trucks, updating counters and tracking errors.
 *   - Logs process information and warnings for unexpected errors during execution.
 */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/autoScraper.js (Line 192:1 - Line 244:3), C:/AI/food-truck-finder-poc/dist/lib/lib/autoScraper.js (Line 191:1 - Line 243:3)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn606" onclick="toggleCodeBlock('cloneGroup606', 'expandBtn606', 'collapseBtn606')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn606" onclick="toggleCodeBlock('cloneGroup606', 'expandBtn606', 'collapseBtn606')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup606"><code class="language-javascript text-sm text-gray-800">export async function ensureDefaultTrucksAreScraped() {
    console.info('AutoScraper: Starting autonomous scraping process...');
    const counters = { trucksProcessed: 0, newTrucksFound: 0 };
    const errors = [];
    // Get URLs to scrape - combine static defaults with dynamically discovered URLs
    const urlsToScrape = await getUrlsToScrape();
    console.info(`AutoScraper: Found ${urlsToScrape.length} URLs to process`);
    for (const url of urlsToScrape) {
        try {
            console.info(`AutoScraper: Checking url: ${url}`);
            const { truck, error } = await findExistingTruck(url);
            if (error != undefined) {
                errors.push({ url, details: error });
                continue;
            }
            if (truck) {
                const result = await handleExistingTruck(url, truck);
                await processExistingTruckResult(url, result, counters, errors);
            }
            else {
                const result = await handleNewTruck(url);
                await processNewTruckResult(url, result, counters, errors);
            }
        }
        catch (error) {
            console.warn(`AutoScraper: Unexpected error processing url ${url}:`, error);
            errors.push({
                url,
                details: error instanceof Error ? error.message : 'Unknown error',
            });
        }
    }
    console.info('AutoScraper: Finished autonomous scraping process.');
    return {
        trucksProcessed: counters.trucksProcessed,
        newTrucksFound: counters.newTrucksFound,
        errors,
    };
}
/**
* Handles the existing truck data by checking staleness and potentially triggering a re-scrape process.
* @example
* handleExistingTruck('https://example.com/truck', { id: '123', last_scraped_at: '2023-09-01T00:00:00Z' })
* { url: 'https://example.com/truck', status: 'fresh', details: 'Last scraped at 2023-09-01T00:00:00Z' }
* @param {string} url - The URL of the food truck to check for staleness.
* @param {FoodTruck} truck - The food truck object containing its ID and last scrape date.
* @returns {Promise&lt;{url: string; status: string; details?: string; jobId?: string}&gt;} Returns the status and additional detail about the scraping process.
* @description
*   - Only triggers the re-scraping process if the data is considered stale based on a predefined threshold.
*   - Logs information about the current state of the truck's data freshness.
*   - Utilizes an asynchronous operation to potentially trigger a re-scrape.
*   - Returns an object indicating whether action was taken or not.
*/</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/autoScraper.js (Line 245:1 - Line 274:4), C:/AI/food-truck-finder-poc/dist/lib/lib/autoScraper.js (Line 244:1 - Line 273:4)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn607" onclick="toggleCodeBlock('cloneGroup607', 'expandBtn607', 'collapseBtn607')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn607" onclick="toggleCodeBlock('cloneGroup607', 'expandBtn607', 'collapseBtn607')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup607"><code class="language-javascript text-sm text-gray-800">async function handleExistingTruck(url, truck) {
    console.info(`AutoScraper: Found existing truck for ${url} (id: ${truck.id}). Last scraped: ${truck.last_scraped_at}`);
    const lastScrapedDate = new Date(truck.last_scraped_at);
    const stalenessLimit = new Date();
    stalenessLimit.setDate(stalenessLimit.getDate() - DEFAULT_STALENESS_THRESHOLD_DAYS);
    if (lastScrapedDate &lt; stalenessLimit) {
        console.info(`AutoScraper: Data for ${url} is stale. Triggering re-scrape.`);
        const triggerResult = await triggerScrapingProcess(url);
        return {
            url,
            status: triggerResult.success ? 're-scraping_triggered' : 'error',
            details: triggerResult.error ?? triggerResult.message,
            jobId: triggerResult.jobId,
        };
    }
    console.info(`AutoScraper: Data for ${url} is fresh. No action needed.`);
    return { url, status: 'fresh', details: `Last scraped at ${truck.last_scraped_at}` };
}
/**
 * Initiates a scraping process for a new truck based on the given URL and returns the scraping status.
 * @example
 * handleNewTruck(&quot;https://example.com/truck-detail&quot;)
 * // Returns: { url: &quot;https://example.com/truck-detail&quot;, status: &quot;initial_scrape_triggered&quot;, details: &quot;Scraping initiated&quot;, jobId: &quot;12345&quot; }
 * @param {string} url - The URL of the truck details page to be scraped.
 * @returns {Promise&lt;{ url: string; status: string; details?: string; jobId?: string }&gt;} An object containing the URL, status of the scraping attempt, optional details message, and optional job ID.
 * @description
 *   - Uses an asynchronous function to trigger the scraping process.
 *   - Logs an informational message when no existing truck is found for the given URL.
 *   - Returns a status indicating whether the scrape was successfully triggered or if there was an error.
 */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/autoScraper.js (Line 275:1 - Line 302:4), C:/AI/food-truck-finder-poc/dist/lib/lib/autoScraper.js (Line 274:1 - Line 301:4)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn608" onclick="toggleCodeBlock('cloneGroup608', 'expandBtn608', 'collapseBtn608')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn608" onclick="toggleCodeBlock('cloneGroup608', 'expandBtn608', 'collapseBtn608')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup608"><code class="language-javascript text-sm text-gray-800">async function handleNewTruck(url) {
    console.info(`AutoScraper: No existing truck found for ${url}. Triggering initial scrape.`);
    const triggerResult = await triggerScrapingProcess(url);
    return {
        url,
        status: triggerResult.success ? 'initial_scrape_triggered' : 'error',
        details: triggerResult.error ?? triggerResult.message,
        jobId: triggerResult.jobId,
    };
}
// --- Gemini API Rate Limiting &amp; Caching ---
const GEMINI_CACHE_TTL_MS = 1000 * 60 * 60 * 6; // 6 hours
const geminiCache = {};
/**
 * Makes a call to Gemini service and caches the result to optimize performance.
 * @example
 * callGeminiWithCache('getData', { id: 123 }, geminiInstance)
 * // returns the result from the Gemini service or cache
 * @param {string} type - The type of operation to perform with Gemini.
 * @param {unknown} input - The input data required for the Gemini operation.
 * @param {GeminiService} gemini - The instance of GeminiService to interact with.
 * @returns {Promise&lt;unknown&gt;} Returns a promise that resolves to the result of the Gemini operation.
 * @description
 *   - Caches the result of Gemini service calls to avoid redundant requests.
 *   - Automatically cleans up expired cache entries based on a specified TTL.
 *   - Checks Gemini usage limits before making API calls to prevent exceeding the daily cap.
 *   - Constructs a unique cache key for each request using the operation type and input.
 */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/autoScraper.js (Line 303:1 - Line 340:3), C:/AI/food-truck-finder-poc/dist/lib/lib/autoScraper.js (Line 302:1 - Line 339:3)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn609" onclick="toggleCodeBlock('cloneGroup609', 'expandBtn609', 'collapseBtn609')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn609" onclick="toggleCodeBlock('cloneGroup609', 'expandBtn609', 'collapseBtn609')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup609"><code class="language-javascript text-sm text-gray-800">export async function callGeminiWithCache(type, input, gemini) {
    const cacheKey = `${type}:${JSON.stringify(input)}`;
    const now = Date.now();
    // Clean up expired cache
    for (const key in geminiCache) {
        if (Object.prototype.hasOwnProperty.call(geminiCache, key) &amp;&amp;
            now - geminiCache[key].timestamp &gt; GEMINI_CACHE_TTL_MS) {
            delete geminiCache[key];
        }
    }
    if (geminiCache[cacheKey] != undefined &amp;&amp;
        now - geminiCache[cacheKey].timestamp &lt; GEMINI_CACHE_TTL_MS) {
        return geminiCache[cacheKey].data;
    }
    // Check Gemini usage limits before making a call
    const usage = await gemini.checkUsageLimits();
    if (!usage.canMakeRequest) {
        throw new Error('Gemini API daily limit reached. Try again tomorrow.');
    }
    // @ts-expect-error TS(2345): Argument of type 'string' is not assignable to par... Remove this comment to see the full error message
    const result = await dispatchGeminiOperation(type, input);
    geminiCache[cacheKey] = { data: result, timestamp: now };
    return result;
}
// Helper to get URLs to scrape from both static defaults and dynamic discovery
/**
* Retrieves a list of URLs that are ready for scraping.
* @example
* getUrlsToScrape()
* // Returns a Promise that resolves to an array of URLs
* @param {void} - This function does not take any arguments.
* @returns {Promise&lt;string[]&gt;} A promise that resolves to an array of URLs to be scraped.
* @description
*   - The function returns a combination of default URLs and dynamically discovered URLs.
*   - Utilizes Supabase to fetch URLs marked with 'new' or 'processed' status.
*   - Limits results to prevent system overload, fetching a maximum of 100 URLs.
*   - Handles errors gracefully, logging warnings if the Supabase client is not available or if there is an error in fetching URLs.
*/</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/autoScraper.js (Line 341:1 - Line 386:4), C:/AI/food-truck-finder-poc/dist/lib/lib/autoScraper.js (Line 340:1 - Line 385:4)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn610" onclick="toggleCodeBlock('cloneGroup610', 'expandBtn610', 'collapseBtn610')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn610" onclick="toggleCodeBlock('cloneGroup610', 'expandBtn610', 'collapseBtn610')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup610"><code class="language-javascript text-sm text-gray-800">async function getUrlsToScrape() {
    const urls = new Set();
    // Add static default URLs
    for (const url of DEFAULT_SCRAPE_URLS)
        urls.add(url);
    // Add dynamically discovered URLs that are ready for processing
    try {
        if (!supabaseAdmin) {
            console.warn('AutoScraper: Supabase admin client not available for discovered URLs');
            return [...urls];
        }
        const { data: discoveredUrls, error } = await supabaseAdmin
            .from('discovered_urls')
            .select('url')
            .in('status', ['new', 'processed']) // Include both new and previously processed URLs
            .order('discovered_at', { ascending: false })
            .limit(100); // Limit to prevent overwhelming the system
        if (error) {
            console.warn('AutoScraper: Error fetching discovered URLs:', error.message);
        }
        else if (discoveredUrls != undefined) {
            for (const { url } of discoveredUrls)
                urls.add(url);
            console.info(`AutoScraper: Added ${discoveredUrls.length} discovered URLs to scraping queue`);
        }
    }
    catch (error) {
        console.warn('AutoScraper: Failed to fetch discovered URLs:', error);
    }
    return [...urls];
}
// Helper to update discovered URL status after processing
/**
 * Updates the status of a discovered URL in the database.
 * @example
 * updateDiscoveredUrlStatus('http://example.com', 'processed', 'Page successfully processed')
 * // Returns: void
 * @param {string} url - The URL whose status needs updating.
 * @param {'processing' | 'processed' | 'irrelevant'} status - The new status for the URL.
 * @param {string} [notes] - Optional notes regarding the URL status update.
 * @returns {Promise&lt;void&gt;} Resolves when the update operation is complete.
 * @description
 *   - Logs a warning if the Supabase admin client is not available.
 *   - Uses Supabase to update the status and logs an error if the operation fails.
 *   - Assumes the existence of a 'discovered_urls' table in the database.
 */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/autoScraper.js (Line 387:1 - Line 429:2), C:/AI/food-truck-finder-poc/dist/lib/lib/autoScraper.js (Line 386:1 - Line 428:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn611" onclick="toggleCodeBlock('cloneGroup611', 'expandBtn611', 'collapseBtn611')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn611" onclick="toggleCodeBlock('cloneGroup611', 'expandBtn611', 'collapseBtn611')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup611"><code class="language-javascript text-sm text-gray-800">async function updateDiscoveredUrlStatus(url, status, notes) {
    try {
        if (!supabaseAdmin) {
            console.warn(`AutoScraper: Cannot update status for ${url} - Supabase admin client not available`);
            return;
        }
        const { error } = await supabaseAdmin
            .from('discovered_urls')
            .update({
            status,
            last_processed_at: new Date().toISOString(),
            notes: notes ?? undefined,
        })
            .eq('url', url);
        if (error != undefined) {
            console.warn(`AutoScraper: Failed to update status for ${url}:`, error.message);
        }
    }
    catch (error) {
        console.warn(`AutoScraper: Error updating discovered URL status for ${url}:`, error);
    }
}
// Note on processScrapingJob import:
// The direct import of `processScrapingJob` from `@/app/api/scrape/route.ts` can be problematic
// if `route.ts` has side effects or dependencies not suitable for a library context (like NextRequest/Response).
// A cleaner way would be to refactor `processScrapingJob` into a shared utility if it's to be called directly,
// or for `triggerScrapingProcess` to make an internal http post request to `/api/scrape`.
// For this iteration, we are attempting direct call, assuming it's manageable.
// Export autoScraper object for use in cron jobs
export const autoScraper = {
    runAutoScraping: ensureDefaultTrucksAreScraped,
    triggerScrapingProcess,
    callGeminiWithCache,
    getUrlsToScrape,
    updateDiscoveredUrlStatus,
};
// Main autonomous scraping function that combines discovery and scraping
export async function runAutonomousScraping() {
    console.info('AutoScraper: Starting fully autonomous scraping cycle...');
    // This function can be called by the autonomous scheduler
    // It uses the updated ensureDefaultTrucksAreScraped which now pulls from discovered_urls
    return await ensureDefaultTrucksAreScraped();
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/activityLogger.js (Line 1:1 - Line 49:2), C:/AI/food-truck-finder-poc/dist/lib/lib/activityLogger.js (Line 1:1 - Line 49:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn612" onclick="toggleCodeBlock('cloneGroup612', 'expandBtn612', 'collapseBtn612')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn612" onclick="toggleCodeBlock('cloneGroup612', 'expandBtn612', 'collapseBtn612')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup612"><code class="language-javascript text-sm text-gray-800">/**
* Logs an activity entry with a timestamp and unique ID.
* @example
* logActivity({ action: 'user_login', username: 'johndoe' })
* undefined
* @param {ActivityLogEntry} entry - The activity entry to be logged.
* @returns {void} No return value.
* @description
*   - If `timestamp` is not provided in the entry, the current ISO timestamp is used.
*   - A unique ID is generated and added to the log entry.
*   - Logs activity data to the console in a structured format.
*   - Intended for development, but can be extended for production use with database or monitoring integration.
*/
export function logActivity(entry) {
    try {
        const logEntry = {
            ...entry,
            timestamp: entry.timestamp ?? new Date().toISOString(),
            id: generateId(),
        };
        // Log to console for development
        console.info('Activity Log:', JSON.stringify(logEntry, undefined, 2));
        // In a production environment, you would:
        // 1. Store to database
        // 2. Send to monitoring service
        // 3. Store in a queue for batch processing
        // For now, we'll just store in memory or local storage
        // This is a mock implementation
    }
    catch (error) {
        console.error('Failed to log activity:', error);
        // Don't throw - logging failures shouldn't break the main flow
    }
}
export function getActivityLogs(_type, _limit = 50) {
    try {
        // Mock implementation - in production this would query your database
        return [];
    }
    catch (error) {
        console.error('Failed to retrieve activity logs:', error);
        return [];
    }
}
function generateId() {
    // Using crypto.randomUUID() would be better for production, but Math.random() is acceptable for logging IDs
    // eslint-disable-next-line sonarjs/pseudo-random -- Math.random is acceptable for non-security-critical logging IDs.
    return Math.random().toString(36).slice(2) + Date.now().toString(36);
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/supabaseMiddleware.js (Line 1:1 - Line 25:2), C:/AI/food-truck-finder-poc/dist/lib/lib/supabaseMiddleware.js (Line 1:1 - Line 25:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn616" onclick="toggleCodeBlock('cloneGroup616', 'expandBtn616', 'collapseBtn616')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn616" onclick="toggleCodeBlock('cloneGroup616', 'expandBtn616', 'collapseBtn616')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup616"><code class="language-javascript text-sm text-gray-800">import { createClient } from '@supabase/supabase-js';
/**
* Create a Supabase client configured for middleware
* @example
* createSupabaseMiddlewareClient(request, response)
* Supabase client instance
* @param {NextRequest} _req - The incoming Next.js request object (unused).
* @param {NextResponse} _res - The outgoing Next.js response object (unused).
* @returns {SupabaseClient} Supabase client instance configured for middleware usage.
* @description
*   - Utilizes environment variables for Supabase URL and anon key.
*   - Sets `persistSession` to false for non-persistent authentication.
*   - Adds `x-middleware-auth` header for identification in middleware.
*/
export function createSupabaseMiddlewareClient(_req, _res) {
    // Create a Supabase client configured for middleware
    return createClient(process.env.NEXT_PUBLIC_SUPABASE_URL, process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY, {
        auth: {
            persistSession: false,
        },
        global: {
            headers: { 'x-middleware-auth': 'true' },
        },
    });
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/ScraperEngine.js (Line 1:1 - Line 662:2), C:/AI/food-truck-finder-poc/dist/lib/lib/ScraperEngine.js (Line 1:1 - Line 662:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn617" onclick="toggleCodeBlock('cloneGroup617', 'expandBtn617', 'collapseBtn617')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn617" onclick="toggleCodeBlock('cloneGroup617', 'expandBtn617', 'collapseBtn617')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup617"><code class="language-javascript text-sm text-gray-800">import { firecrawl } from './firecrawl'; // Import the firecrawl singleton
import * as crypto from 'node:crypto'; // Node.js crypto for secure randomness
// Core scraping engine with anti-detection measures
export class ScraperEngine {
    userAgents;
    requestDelay;
    maxRetries;
    constructor() {
        this.userAgents = [
            'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
            'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
            'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
        ];
        this.requestDelay = 2000;
        this.maxRetries = 3;
    }
    async performFallbackScrape(url) {
        try {
            const response = await fetch(url, { headers: { 'User-Agent': this.getRandomUserAgent() } });
            if (!response.ok) {
                throw new Error(`HTTP error ${response.status}: ${response.statusText} during fallback fetch.`);
            }
            const htmlContent = await response.text();
            return {
                success: true,
                data: {
                    html: htmlContent,
                    is_fallback: true,
                },
                timestamp: new Date().toISOString(),
                source: url,
                note: 'Fetched using basic fetch as Firecrawl failed.',
            };
        }
        catch (fallbackError) {
            const errMsg = fallbackError instanceof Error ? fallbackError.message : 'Unknown fallback fetch error';
            console.warn(`Fallback fetch error for ${url}:`, errMsg);
            return {
                success: false,
                error: &quot;That didn't work, please try again later.&quot;,
                timestamp: new Date().toISOString(),
                source: url,
            };
        }
    }
    async scrapeWebsite(url, _selectors) {
        try {
            const firecrawlResult = await firecrawl.scrapeUrl(url, {
                formats: ['markdown', 'html'],
                onlyMainContent: true,
            });
            if (firecrawlResult.success !== true || firecrawlResult.data == undefined) {
                throw new Error(firecrawlResult.error ?? 'Firecrawl scraping failed to return data.');
            }
            const returnedData = {};
            if (firecrawlResult.data &amp;&amp; typeof firecrawlResult.data === 'object') {
                const firecrawlData = firecrawlResult.data;
                if (typeof firecrawlData.markdown === 'string' &amp;&amp; firecrawlData.markdown !== '') {
                    returnedData.markdown = firecrawlData.markdown;
                }
                if (typeof firecrawlData.html === 'string' &amp;&amp; firecrawlData.html !== '') {
                    returnedData.html = firecrawlData.html;
                }
                if (firecrawlData.metadata != undefined &amp;&amp; typeof firecrawlData.metadata === 'object') {
                    returnedData.metadata = firecrawlData.metadata;
                }
            }
            if ((returnedData.markdown == undefined || returnedData.markdown === '') &amp;&amp;
                (returnedData.html == undefined || returnedData.html === '')) {
                throw new Error('Firecrawl returned no markdown or HTML content.');
            }
            return {
                success: true,
                data: returnedData,
                timestamp: new Date().toISOString(),
                source: url,
            };
        }
        catch (error) {
            console.warn(`Scraping error for ${url} using Firecrawl:`, error);
            console.info(`Falling back to basic fetch for ${url}`);
            return await this.performFallbackScrape(url);
        }
    }
    async scrapeSocialMedia(platform, handle) {
        try {
            await this.randomDelay();
            switch (platform) {
                case 'instagram': {
                    return await this.scrapeInstagram(handle);
                }
                case 'facebook': {
                    return await this.scrapeFacebook(handle);
                }
                case 'twitter': {
                    return await this.scrapeTwitter(handle);
                }
                default: {
                    throw new Error(`Unsupported platform: ${platform}`);
                }
            }
        }
        catch (error) {
            console.warn(`Social media scraping error for ${platform}/${handle}:`, error);
            return {
                success: false,
                error: &quot;That didn't work, please try again later.&quot;,
                timestamp: new Date().toISOString(),
                source: `social_media:${platform}:${handle}`,
            };
        }
    }
    async scrapeInstagram(handle) {
        await this.randomDelay();
        const posts = [
            {
                id: 'post_001',
                caption: 'Fresh tacos available now at Mission St!  #foodtruck #tacos',
                timestamp: new Date(Date.now() - 3_600_000).toISOString(),
                location: 'Mission St, San Francisco',
                hashtags: ['foodtruck', 'tacos', 'fresh'],
                engagement: { likes: 45, comments: 8 },
            },
        ];
        const profile = {
            followers: 1250,
            following: 340,
            posts_count: 156,
            bio: 'Best tacos in SF  Follow for daily locations!',
            contact_info: {
                email: 'contact@tacoparadise.com',
                phone: '+1-555-0456',
            },
        };
        const data = { posts, profile };
        return {
            success: true,
            data,
            timestamp: new Date().toISOString(),
            source: `instagram:${handle}`,
        };
    }
    async scrapeFacebook(handle) {
        await this.randomDelay();
        const posts = [
            {
                id: 'fb_post_001',
                content: &quot;Today we'll be at Union Square from 11 AM to 3 PM! Come try our new BBQ burger!&quot;,
                timestamp: new Date(Date.now() - 7_200_000).toISOString(),
                reactions: { likes: 23, loves: 5, shares: 3 },
                comments: 12,
            },
        ];
        const page_info = {
            likes: 890,
            followers: 1100,
            check_ins: 450,
            about: 'Gourmet food truck serving the Bay Area',
            hours: {
                monday: '11:00-15:00',
                tuesday: '11:00-15:00',
                wednesday: '11:00-15:00',
                thursday: '11:00-15:00',
                friday: '11:00-20:00',
                saturday: '12:00-20:00',
                sunday: '12:00-16:00',
            },
        };
        const data = { posts, page_info };
        return {
            success: true,
            data,
            timestamp: new Date().toISOString(),
            source: `facebook:${handle}`,
        };
    }
    async scrapeTwitter(handle) {
        await this.randomDelay();
        const tweets = [
            {
                id: 'tweet_001',
                text: 'LIVE at Dolores Park! Fresh burritos and quesadillas available now ',
                timestamp: new Date(Date.now() - 1_800_000).toISOString(),
                retweets: 8,
                likes: 34,
                replies: 5,
                location: 'Dolores Park, San Francisco',
            },
        ];
        const profile = {
            followers: 2340,
            following: 567,
            tweets_count: 1890,
            bio: ' SF Food Truck | Fresh Mexican Food | Follow for locations',
            location: 'San Francisco, CA',
            website: 'https://tacoparadise.com',
        };
        const data = { tweets, profile };
        return {
            success: true,
            data,
            timestamp: new Date().toISOString(),
            source: `twitter:${handle}`,
        };
    }
    getRandomUserAgent() {
        // Use Node.js crypto for stronger randomness if available, fallback to Math.random otherwise.
        let idx;
        if (globalThis.window?.crypto?.getRandomValues != undefined) {
            const array = globalThis.window.crypto.getRandomValues(new Uint32Array(1));
            idx = array[0] % this.userAgents.length;
        }
        else if (typeof crypto.randomInt === 'function') {
            idx = crypto.randomInt(0, this.userAgents.length);
        }
        else {
            // Fallback to Math.random for environments where crypto is not available.
            // This is acceptable for non-security-critical random number generation like user agent selection.
            // eslint-disable-next-line sonarjs/pseudo-random -- Math.random is acceptable for non-security-critical user agent selection.
            idx = Math.floor(Math.random() * this.userAgents.length);
        }
        return this.userAgents[idx];
    }
    randomDelay() {
        let randomMs;
        if (globalThis.window?.crypto?.getRandomValues != undefined) {
            const array = globalThis.window.crypto.getRandomValues(new Uint32Array(1));
            randomMs = array[0] % 1000;
        }
        else if (typeof crypto.randomInt === 'function') {
            randomMs = crypto.randomInt(0, 1000);
        }
        else {
            // Fallback to Math.random for environments where crypto is not available.
            // This is acceptable for non-security-critical random delays.
            // eslint-disable-next-line sonarjs/pseudo-random -- Math.random is acceptable for non-security-critical random delays.
            randomMs = Math.floor(Math.random() * 1000);
        }
        const delay = this.requestDelay + randomMs;
        return new Promise((resolve) =&gt; setTimeout(resolve, delay));
    }
    handleRateLimit(retryAfter) {
        console.info(`Rate limited. Waiting ${retryAfter} seconds before retry...`);
        return new Promise((resolve) =&gt; setTimeout(resolve, retryAfter * 1000));
    }
    async retryWithBackoff(operation, maxRetries = this.maxRetries) {
        let lastError;
        for (let attempt = 1; attempt &lt;= maxRetries; attempt += 1) {
            try {
                return await operation();
            }
            catch (error) {
                lastError = error;
                if (attempt === maxRetries) {
                    throw lastError instanceof Error ? lastError : new Error(String(lastError));
                }
                const backoffDelay = Math.pow(2, attempt) * 1000;
                console.info(`Attempt ${attempt} failed. Retrying in ${backoffDelay}ms...`);
                await new Promise((resolve) =&gt; setTimeout(resolve, backoffDelay));
            }
        }
        throw lastError instanceof Error ? lastError : new Error('Request failed after all retries');
    }
}
export class DataQualityAssessor {
    assessBasicInfo(truckData, issues, score) {
        if (truckData.name == undefined || truckData.name.trim().length === 0) {
            issues.push('Missing or empty truck name');
            score -= 20;
        }
        return score;
    }
    assessLocationInfo(truckData, issues, score) {
        if (truckData.location?.current == undefined) {
            issues.push('Missing current location data');
            score -= 25;
        }
        else {
            if (truckData.location.current.lat == undefined ||
                truckData.location.current.lng == undefined) {
                issues.push('Missing GPS coordinates');
                score -= 15;
            }
            if (truckData.location.current.address == undefined ||
                truckData.location.current.address === '') {
                issues.push('Missing address information');
                score -= 10;
            }
        }
        return score;
    }
    assessContactInfo(truckData, issues, score) {
        if (truckData.contact) {
            const hasPhone = typeof truckData.contact.phone === 'string' &amp;&amp; truckData.contact.phone.trim() !== '';
            const hasEmail = typeof truckData.contact.email === 'string' &amp;&amp; truckData.contact.email.trim() !== '';
            if (!hasPhone &amp;&amp; !hasEmail) {
                issues.push('No phone or email contact available');
                score -= 15;
            }
            if (hasPhone &amp;&amp; !this.isValidPhone(truckData.contact.phone)) {
                issues.push('Invalid phone number format');
                score -= 5;
            }
            if (hasEmail &amp;&amp; !this.isValidEmail(truckData.contact.email)) {
                issues.push('Invalid email format');
                score -= 5;
            }
        }
        else {
            issues.push('Missing contact information');
            score -= 20;
        }
        return score;
    }
    assessOperatingHours(truckData, issues, score) {
        if (truckData.operating_hours == undefined ||
            Object.keys(truckData.operating_hours).length === 0) {
            issues.push('Missing operating hours');
            score -= 15;
        }
        return score;
    }
    assessMenuInfo(truckData, issues, score) {
        if (truckData.menu == undefined || truckData.menu.length === 0) {
            issues.push('Missing menu information');
            score -= 10;
        }
        else {
            const menuIssues = this.validateMenuData(truckData.menu);
            issues.push(...menuIssues);
            score -= menuIssues.length * 2;
        }
        return score;
    }
    assessLastUpdated(truckData, issues, score) {
        if (truckData.last_updated != undefined &amp;&amp; truckData.last_updated !== '') {
            const lastUpdate = new Date(truckData.last_updated);
            const daysSinceUpdate = (Date.now() - lastUpdate.getTime()) / (1000 * 60 * 60 * 24);
            if (daysSinceUpdate &gt; 7) {
                issues.push('Data is more than 7 days old');
                score -= 10;
            }
            else if (daysSinceUpdate &gt; 3) {
                issues.push('Data is more than 3 days old');
                score -= 5;
            }
        }
        return score;
    }
    assessTruckData(truckData) {
        const issues = [];
        let score = 100;
        score = this.assessBasicInfo(truckData, issues, score);
        score = this.assessLocationInfo(truckData, issues, score);
        score = this.assessContactInfo(truckData, issues, score);
        score = this.assessOperatingHours(truckData, issues, score);
        score = this.assessMenuInfo(truckData, issues, score);
        score = this.assessLastUpdated(truckData, issues, score);
        return {
            score: Math.max(0, score) / 100,
            issues,
        };
    }
    validateMenuCategory(category, categoryIndex, issues) {
        if (category.category == undefined || category.category.trim().length === 0) {
            issues.push(`Menu category ${categoryIndex + 1} missing name`);
        }
    }
    validateMenuItems(category, issues) {
        if (category.items == undefined || category.items.length === 0) {
            issues.push(`Menu category &quot;${category.category ?? 'Unknown'}&quot; has no items`);
        }
        else {
            for (const [itemIndex, item] of category.items.entries()) {
                if (item.name == undefined || item.name.trim().length === 0) {
                    issues.push(`Menu item ${itemIndex + 1} in &quot;${category.category ?? 'Unknown'}&quot; missing name`);
                }
                if (typeof item.price !== 'number' || item.price &lt;= 0) {
                    issues.push(`Menu item &quot;${item.name ?? 'Unknown'}&quot; has invalid price`);
                }
            }
        }
    }
    validateMenuData(menu) {
        const issues = [];
        for (const [categoryIndex, category] of menu.entries()) {
            this.validateMenuCategory(category, categoryIndex, issues);
            this.validateMenuItems(category, issues);
        }
        return issues;
    }
    isValidPhone(phone) {
        // Regex for phone number validation. Not vulnerable to super-linear runtime due to backtracking.
        // Accepts +, digits, spaces, dashes, and parentheses. At least 10 digits.
        const phoneRegex = /^\+?[\d\s\-()]{10,}$/;
        return phoneRegex.test(phone);
    }
    isValidEmail(email) {
        // Regex for email validation optimized to avoid backtracking
        const emailRegex = /^[^\s@]+@[^\s@]+\.[a-zA-Z]{2,}$/;
        return emailRegex.test(email);
    }
}
export class GeminiDataProcessor {
    _apiKey;
    _baseUrl;
    requestCount;
    tokenCount;
    dailyLimit;
    constructor(apiKey) {
        this._apiKey = apiKey;
        this._baseUrl = 'https://generativelanguage.googleapis.com/v1beta';
        this.requestCount = 0;
        this.tokenCount = 0;
        this.dailyLimit = { requests: 1500, tokens: 32_000 };
    }
    async processMenuData(rawMenuText) {
        if (!this.canMakeRequest()) {
            throw new Error('Gemini API rate limit exceeded');
        }
        try {
            const prompt = `
        Parse the following food truck menu text and return a structured JSON format:
        
        ${rawMenuText}
        
        Return format:
        {
          &quot;categories&quot;: [
            {
              &quot;name&quot;: &quot;category_name&quot;,
              &quot;items&quot;: [
                {
                  &quot;name&quot;: &quot;item_name&quot;,
                  &quot;description&quot;: &quot;item_description&quot;,
                  &quot;price&quot;: 0.00,
                  &quot;dietary_tags&quot;: [&quot;vegetarian&quot;, &quot;vegan&quot;, &quot;gluten-free&quot;, etc.]
                }
              ]
            }
          ]
        }
        
        Only return valid JSON, no additional text.
      `;
            const response = await this.makeGeminiRequest(prompt);
            this.updateUsageCounters(1, prompt.length + response.length);
            // Ensure type safety for parsed response
            const parsed = JSON.parse(response);
            if (typeof parsed !== 'object' ||
                parsed == undefined ||
                !('categories' in parsed) ||
                !Array.isArray(parsed.categories)) {
                throw new Error('Invalid Gemini menu response: missing or malformed categories array');
            }
            return parsed;
        }
        catch (error) {
            console.error('Error processing menu data with Gemini:', error);
            throw error;
        }
    }
    async extractLocationFromText(text) {
        if (!this.canMakeRequest()) {
            throw new Error('Gemini API rate limit exceeded');
        }
        try {
            const prompt = `
        Extract location information from the following text and return structured data:
        
        &quot;${text}&quot;
        
        Return format:
        {
          &quot;address&quot;: &quot;full_address&quot;,
          &quot;city&quot;: &quot;city_name&quot;,
          &quot;state&quot;: &quot;state&quot;,
          &quot;coordinates&quot;: {
            &quot;lat&quot;: 0.0,
            &quot;lng&quot;: 0.0
          },
          &quot;confidence&quot;: 0.95
        }
        
        If coordinates cannot be determined, set them to undefined. Only return valid JSON.
      `;
            const response = await this.makeGeminiRequest(prompt);
            this.updateUsageCounters(1, prompt.length + response.length);
            const parsedResponse = JSON.parse(response);
            const validatedResponse = this.validateGeminiLocationResponse(parsedResponse);
            return validatedResponse;
        }
        catch (error) {
            console.error('Error extracting location with Gemini:', error);
            throw error;
        }
    }
    validateGeminiLocationResponse(parsedResponse) {
        if (parsedResponse == undefined ||
            typeof parsedResponse !== 'object' ||
            !('coordinates' in parsedResponse) ||
            typeof parsedResponse.coordinates !== 'object') {
            throw new Error('Invalid Gemini location response');
        }
        const coordinates = parsedResponse
            .coordinates;
        if (coordinates &amp;&amp; typeof coordinates === 'object') {
            if (typeof coordinates.lat !== 'number') {
                coordinates.lat = undefined;
            }
            if (typeof coordinates.lng !== 'number') {
                coordinates.lng = undefined;
            }
        }
        return parsedResponse;
    }
    async standardizeOperatingHours(hoursText) {
        if (!this.canMakeRequest()) {
            throw new Error('Gemini API rate limit exceeded');
        }
        try {
            const prompt = `
        Parse the following operating hours text and return standardized format:
        
        &quot;${hoursText}&quot;
        
        Return format:
        {
          &quot;monday&quot;: {&quot;open&quot;: &quot;HH:MM&quot;, &quot;close&quot;: &quot;HH:MM&quot;, &quot;closed&quot;: false},
          &quot;tuesday&quot;: {&quot;open&quot;: &quot;HH:MM&quot;, &quot;close&quot;: &quot;HH:MM&quot;, &quot;closed&quot;: false},
          &quot;wednesday&quot;: {&quot;open&quot;: &quot;HH:MM&quot;, &quot;close&quot;: &quot;HH:MM&quot;, &quot;closed&quot;: false},
          &quot;thursday&quot;: {&quot;open&quot;: &quot;HH:MM&quot;, &quot;close&quot;: &quot;HH:MM&quot;, &quot;closed&quot;: false},
          &quot;friday&quot;: {&quot;open&quot;: &quot;HH:MM&quot;, &quot;close&quot;: &quot;HH:MM&quot;, &quot;closed&quot;: false},
          &quot;saturday&quot;: {&quot;open&quot;: &quot;HH:MM&quot;, &quot;close&quot;: &quot;HH:MM&quot;, &quot;closed&quot;: false},
          &quot;sunday&quot;: {&quot;open&quot;: &quot;HH:MM&quot;, &quot;close&quot;: &quot;HH:MM&quot;, &quot;closed&quot;: false}
        }
          Use 24-hour format. If closed on a day, set &quot;closed&quot;: true and omit open/close times.
        Only return valid JSON.
      `;
            const response = await this.makeGeminiRequest(prompt);
            this.updateUsageCounters(1, prompt.length + response.length);
            const parsed = JSON.parse(response);
            if (parsed == undefined || typeof parsed !== 'object') {
                throw new Error('Invalid Gemini hours response');
            }
            return parsed;
        }
        catch (error) {
            console.error('Error standardizing hours with Gemini:', error);
            throw error;
        }
    }
    async analyzeSentiment(reviewText) {
        if (!this.canMakeRequest()) {
            throw new Error('Gemini API rate limit exceeded');
        }
        try {
            const prompt = `
        Analyze the sentiment of this food truck review and extract key insights:
        
        &quot;${reviewText}&quot;
        
        Return format:
        {
          &quot;sentiment&quot;: &quot;positive|negative|neutral&quot;,
          &quot;score&quot;: 0.85,
          &quot;key_topics&quot;: [&quot;food_quality&quot;, &quot;service&quot;, &quot;price&quot;, &quot;location&quot;],
          &quot;summary&quot;: &quot;brief_summary_of_review&quot;
        }
          Score should be between 0 (very negative) and 1 (very positive).
        Only return valid JSON.
      `;
            const response = await this.makeGeminiRequest(prompt);
            this.updateUsageCounters(1, prompt.length + response.length);
            const parsed = JSON.parse(response);
            if (parsed == undefined || typeof parsed !== 'object') {
                throw new Error('Invalid Gemini sentiment response');
            }
            return parsed;
        }
        catch (error) {
            console.error('Error analyzing sentiment with Gemini:', error);
            throw error;
        }
    }
    async makeGeminiRequest(prompt) {
        await new Promise((resolve) =&gt; setTimeout(resolve, 1000)); // Simulate API delay
        return this.getMockGeminiResponse(prompt);
    }
    getMockGeminiResponse(prompt) {
        if (prompt.includes('menu text')) {
            return JSON.stringify({
                categories: [
                    {
                        name: 'Burgers',
                        items: [
                            {
                                name: 'Classic Cheeseburger',
                                description: 'Beef patty with cheese, lettuce, tomato',
                                price: 12.99,
                                dietary_tags: [],
                            },
                        ],
                    },
                ],
            });
        }
        else if (prompt.includes('location information')) {
            return JSON.stringify({
                address: '123 Market St, San Francisco, CA 94105',
                city: 'San Francisco',
                state: 'CA',
                coordinates: {
                    lat: 37.7749,
                    lng: -122.4194,
                },
                confidence: 0.95,
            });
        }
        else if (prompt.includes('operating hours')) {
            return JSON.stringify({
                monday: { open: '11:00', close: '15:00', closed: false },
                tuesday: { open: '11:00', close: '15:00', closed: false },
                wednesday: { open: '11:00', close: '15:00', closed: false },
                thursday: { open: '11:00', close: '15:00', closed: false },
                friday: { open: '11:00', close: '20:00', closed: false },
                saturday: { open: '12:00', close: '20:00', closed: false },
                sunday: { open: '12:00', close: '16:00', closed: false },
            });
        }
        else if (prompt.includes('sentiment')) {
            return JSON.stringify({
                sentiment: 'positive',
                score: 0.85,
                key_topics: ['food_quality', 'service'],
                summary: 'Customer enjoyed the food and service',
            });
        }
        return '{&quot;processed&quot;: true}';
    }
    canMakeRequest() {
        return this.requestCount &lt; this.dailyLimit.requests &amp;&amp; this.tokenCount &lt; this.dailyLimit.tokens;
    }
    updateUsageCounters(requests, tokens) {
        this.requestCount += requests;
        this.tokenCount += tokens;
    }
    getUsageStats() {
        return {
            requests: {
                used: this.requestCount,
                limit: this.dailyLimit.requests,
                remaining: this.dailyLimit.requests - this.requestCount,
            },
            tokens: {
                used: this.tokenCount,
                limit: this.dailyLimit.tokens,
                remaining: this.dailyLimit.tokens - this.tokenCount,
            },
        };
    }
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/scheduler.js (Line 1:1 - Line 356:2), C:/AI/food-truck-finder-poc/dist/lib/lib/scheduler.js (Line 1:1 - Line 356:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn619" onclick="toggleCodeBlock('cloneGroup619', 'expandBtn619', 'collapseBtn619')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn619" onclick="toggleCodeBlock('cloneGroup619', 'expandBtn619', 'collapseBtn619')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup619"><code class="language-javascript text-sm text-gray-800">// Task scheduling and automation system
export class TaskScheduler {
    tasks;
    intervals;
    isRunning;
    constructor() {
        this.tasks = new Map();
        this.intervals = new Map();
        this.isRunning = false;
    }
    start() {
        if (this.isRunning === true) {
            console.info('Scheduler is already running');
            return;
        }
        this.isRunning = true;
        console.info('Task scheduler started');
        // Start all scheduled tasks
        for (const [taskId, task] of this.tasks.entries()) {
            if (task.enabled === true) {
                this.scheduleTask(taskId, task);
            }
        }
    }
    stop() {
        if (this.isRunning !== true) {
            console.info('Scheduler is not running');
            return;
        }
        this.isRunning = false;
        // Clear all intervals
        for (const [taskId, interval] of this.intervals.entries()) {
            clearInterval(interval);
            console.info(`Stopped task: ${taskId}`);
        }
        this.intervals.clear();
        console.info('Task scheduler stopped');
    }
    addTask(task) {
        this.tasks.set(task.id, task);
        if (this.isRunning === true &amp;&amp; task.enabled === true) {
            this.scheduleTask(task.id, task);
        }
        console.info(`Added task: ${task.id}`);
    }
    removeTask(taskId) {
        const interval = this.intervals.get(taskId);
        if (interval) {
            clearInterval(interval);
            this.intervals.delete(taskId);
        }
        this.tasks.delete(taskId);
        console.info(`Removed task: ${taskId}`);
    }
    enableTask(taskId) {
        const task = this.tasks.get(taskId);
        if (!task) {
            throw new Error(`Task not found: ${taskId}`);
        }
        task.enabled = true;
        if (this.isRunning) {
            this.scheduleTask(taskId, task);
        }
        console.info(`Enabled task: ${taskId}`);
    }
    disableTask(taskId) {
        const task = this.tasks.get(taskId);
        if (!task) {
            throw new Error(`Task not found: ${taskId}`);
        }
        task.enabled = false;
        const interval = this.intervals.get(taskId);
        if (interval) {
            clearInterval(interval);
            this.intervals.delete(taskId);
        }
        console.info(`Disabled task: ${taskId}`);
    }
    scheduleTask(taskId, task) {
        // Clear existing interval if any
        const existingInterval = this.intervals.get(taskId);
        if (existingInterval) {
            clearInterval(existingInterval);
        }
        // Calculate interval in milliseconds
        const intervalMs = task.intervalMinutes * 60 * 1000;
        // Schedule the task with proper async wrapper
        const interval = setInterval(() =&gt; {
            // Use void to indicate we're not handling the promise
            void (async () =&gt; {
                try {
                    console.info(`Executing task: ${taskId}`);
                    task.lastRun = new Date().toISOString();
                    await task.execute();
                    task.successCount += 1;
                    task.lastSuccess = new Date().toISOString();
                    console.info(`Task completed successfully: ${taskId}`);
                }
                catch (error) {
                    task.errorCount += 1;
                    task.lastError = error instanceof Error ? error.message : 'Unknown error';
                    console.warn(`Task failed: ${taskId}`, error);
                    // Disable task if too many consecutive failures
                    if (task.errorCount - task.successCount &gt; 5) {
                        console.warn(`Disabling task due to repeated failures: ${taskId}`);
                        this.disableTask(taskId);
                    }
                }
            })();
        }, intervalMs);
        this.intervals.set(taskId, interval);
        console.info(`Scheduled task: ${taskId} (every ${task.intervalMinutes} minutes)`);
    }
    getTaskStatus() {
        return [...this.tasks.values()].map((task) =&gt; ({
            id: task.id,
            name: task.name,
            enabled: task.enabled,
            intervalMinutes: task.intervalMinutes,
            lastRun: task.lastRun,
            lastSuccess: task.lastSuccess,
            successCount: task.successCount,
            errorCount: task.errorCount,
            lastError: task.lastError,
            nextRun: this.calculateNextRun(task),
        }));
    }
    calculateNextRun(task) {
        if (task.enabled !== true || task.lastRun == undefined) {
            return undefined;
        }
        const lastRun = new Date(task.lastRun);
        const nextRun = new Date(lastRun.getTime() + task.intervalMinutes * 60 * 1000);
        return nextRun.toISOString();
    }
    scheduleFollowUpTasks(result) {
        // Implementation for scheduling follow-up tasks based on scraping results
        console.info('Scheduling follow-up tasks based on scraping results:', result);
        // This could include:
        // - Scheduling quality checks for newly scraped data
        // - Setting up monitoring for high-priority trucks
        // - Triggering additional scraping for related sources
    }
}
// Helper function to update truck location from social media
async function updateTruckLocationFromSocial(truck, scraperEngine) {
    if (truck.social_media.instagram_handle == undefined ||
        truck.social_media.instagram_handle === '') {
        return;
    }
    const socialResult = await scraperEngine.scrapeSocialMedia('instagram', truck.social_media.instagram_handle);
    if (socialResult.success === true &amp;&amp; socialResult.data != undefined) {
        const socialData = socialResult.data;
        const recentPosts = socialData.posts.slice(0, 3);
        for (const post of recentPosts) {
            if (post.location != undefined &amp;&amp; post.location !== '') {
                console.info(`Updated location for ${truck.name}: ${post.location}`);
                break;
            }
        }
    }
}
// Pre-configured tasks for food truck data pipeline
export function createDefaultTasks(scraperEngine, geminiProcessor, dataQualityAssessor) {
    return [
        createInstagramScrapeTask(scraperEngine),
        createWebsiteCrawlTask(scraperEngine),
        createDataQualityCheckTask(dataQualityAssessor),
        createGeminiProcessingTask(geminiProcessor),
        createLocationUpdateTask(scraperEngine),
    ];
}
/**
 * Create Instagram scraping task
 */
function createInstagramScrapeTask(scraperEngine) {
    return {
        id: 'instagram_scrape',
        name: 'Instagram Data Scraping',
        description: 'Scrape Instagram posts and profiles for food truck data',
        intervalMinutes: 120, // Every 2 hours
        enabled: true,
        successCount: 0,
        errorCount: 0,
        execute: async () =&gt; {
            const handles = ['@gourmetstreeteats', '@tacoparadisesf', '@burgermobile'];
            for (const handle of handles) {
                const result = await scraperEngine.scrapeSocialMedia('instagram', handle);
                if (result.success) {
                    console.info(`Successfully scraped ${handle}`);
                }
                else {
                    throw new Error(`Failed to scrape ${handle}: ${result.error}`);
                }
            }
        },
    };
}
/**
 * Create website crawling task
 */
function createWebsiteCrawlTask(scraperEngine) {
    return {
        id: 'website_crawl',
        name: 'Website Crawling',
        description: 'Crawl food truck websites for menu and location updates',
        intervalMinutes: 360, // Every 6 hours
        enabled: true,
        successCount: 0,
        errorCount: 0,
        execute: async () =&gt; {
            const websites = [
                'https://gourmetstreeteats.com',
                'https://tacoparadise.com',
                'https://burgermobile.net',
            ];
            const selectors = {
                name: '.truck-name',
                location: '.current-location',
                hours: '.operating-hours',
                menu: '.menu-items',
            };
            for (const url of websites) {
                const result = await scraperEngine.scrapeWebsite(url, selectors);
                if (result.success) {
                    console.info(`Successfully crawled ${url}`);
                }
                else {
                    throw new Error(`Failed to crawl ${url}: ${result.error}`);
                }
            }
        },
    };
}
/**
 * Create data quality check task
 */
function createDataQualityCheckTask(dataQualityAssessor) {
    return {
        id: 'data_quality_check',
        name: 'Data Quality Assessment',
        description: 'Assess and validate data quality for all food trucks',
        intervalMinutes: 720, // Every 12 hours
        enabled: true,
        successCount: 0,
        errorCount: 0,
        execute: async () =&gt; {
            // Placeholder: fetch trucks from database
            const trucks = [];
            await Promise.resolve(); // Added to satisfy async/await rule
            let totalScore = 0;
            let processedCount = 0;
            if (trucks.length === 0) {
                console.info('No trucks available for quality assessment');
                return;
            }
            for (const truck of trucks) {
                const assessment = dataQualityAssessor.assessTruckData(truck);
                totalScore += assessment.score;
                processedCount += 1;
                if (assessment.score &lt; 0.7) {
                    console.warn(`Low quality data for truck ${truck.id}: ${assessment.issues.join(', ')}`);
                }
            }
            const averageQuality = processedCount &gt; 0 ? totalScore / processedCount : 0;
            console.info(`Data quality assessment completed. Average score: ${averageQuality.toFixed(2)}`);
        },
    };
}
/**
 * Create Gemini processing task
 */
function createGeminiProcessingTask(geminiProcessor) {
    return {
        id: 'gemini_processing',
        name: 'AI Data Processing',
        description: 'Process raw data using Gemini AI for standardization',
        intervalMinutes: 480, // Every 8 hours
        enabled: true,
        successCount: 0,
        errorCount: 0,
        execute: async () =&gt; {
            const usage = geminiProcessor.getUsageStats();
            if (usage.requests.remaining &lt; 100) {
                console.warn('Skipping Gemini processing due to rate limits');
                return;
            }
            const pendingData = []; // Placeholder: fetch pending data from queue system
            if (pendingData.length === 0) {
                console.info('No pending data to process');
                return;
            }
            await processGeminiDataBatch(geminiProcessor, pendingData);
            console.info(`Processed ${pendingData.length} items with Gemini AI`);
        },
    };
}
/**
 * Process batch of data with Gemini
 */
async function processGeminiDataBatch(geminiProcessor, pendingData) {
    for (const data of pendingData) {
        switch (data.type) {
            case 'menu': {
                await geminiProcessor.processMenuData(data.content);
                break;
            }
            case 'location': {
                await geminiProcessor.extractLocationFromText(data.content);
                break;
            }
            case 'hours': {
                await geminiProcessor.standardizeOperatingHours(data.content);
                break;
            }
            case 'sentiment': {
                await geminiProcessor.analyzeSentiment(data.content);
                break;
            }
            case 'enhance': {
                await geminiProcessor.enhanceFoodTruckData(data.content);
                break;
            }
            default: {
                // No default
                break;
            }
        }
    }
}
/**
 * Create location update task
 */
function createLocationUpdateTask(scraperEngine) {
    return {
        id: 'location_update',
        name: 'Real-time Location Updates',
        description: 'Update current locations for active food trucks',
        intervalMinutes: 30, // Every 30 minutes
        enabled: true,
        successCount: 0,
        errorCount: 0,
        execute: async () =&gt; {
            const activeTrucks = []; // Placeholder: fetch active trucks from database
            if (activeTrucks.length === 0) {
                console.info('No active trucks to update locations for');
                return;
            }
            for (const truck of activeTrucks) {
                await updateTruckLocationFromSocial(truck, scraperEngine);
            }
        },
    };
}
// Export scheduler instance for use in cron jobs
export const scheduler = new TaskScheduler();</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/pipelineManager.js (Line 3:13 - Line 284:2), C:/AI/food-truck-finder-poc/dist/lib/lib/pipelineManager.js (Line 3:41 - Line 284:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn621" onclick="toggleCodeBlock('cloneGroup621', 'expandBtn621', 'collapseBtn621')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn621" onclick="toggleCodeBlock('cloneGroup621', 'expandBtn621', 'collapseBtn621')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup621"><code class="language-javascript text-sm text-gray-800">;
import { discoveryEngine } from './discoveryEngine';
import { processScrapingJob } from './pipelineProcessor';
import { ensureDefaultTrucksAreScraped } from './autoScraper';
/**
 * Unified Pipeline Manager
 *
 * Consolidates all pipeline operations into a single, modular system:
 * - Discovery: Find new food truck URLs using Tavily
 * - Processing: Process URLs through Firecrawl + Gemini pipeline
 * - Full: Combined discovery + processing
 * - Maintenance: Check existing trucks for stale data
 */
export class PipelineManager {
    /**
     * Run the complete pipeline based on configuration
     */
    async runPipeline(config) {
        const startTime = Date.now();
        try {
            console.info(` PipelineManager: Starting ${config.type} pipeline...`);
            const result = await this.executePipelineType(config);
            return this.createSuccessResult(config, result, startTime);
        }
        catch (error) {
            return this.createErrorResult(config, error, startTime);
        }
    }
    /**
     * Execute the specific pipeline type
     */
    async executePipelineType(config) {
        switch (config.type) {
            case 'discovery': {
                return await this.runDiscovery({
                    cities: config.params.targetCities ?? [],
                    maxUrls: config.params.maxUrls ?? 50,
                    searchTerms: ['food truck', 'food cart', 'mobile food'],
                });
            }
            case 'processing': {
                return await this.processJobs({
                    maxJobs: config.params.maxUrlsToProcess ?? 20,
                    priority: config.params.priority ?? 5,
                    retryFailedJobs: config.params.retryFailedJobs ?? false,
                });
            }
            case 'full': {
                return await this.runFullPipeline(config);
            }
            case 'maintenance': {
                return await this.runMaintenance();
            }
            default: {
                throw new Error(`Unknown pipeline type: ${String(config.type)}`);
            }
        }
    }
    /**
     * Create success result
     */
    createSuccessResult(config, result, startTime) {
        const duration = Date.now() - startTime;
        return {
            success: true,
            type: config.type,
            phase: 'completed',
            summary: {
                ...(typeof result === 'object' &amp;&amp; result !== null
                    ? result
                    : {}),
                duration,
            },
            details: result,
            timestamp: new Date().toISOString(),
        };
    }
    /**
     * Create error result
     */
    createErrorResult(config, error, startTime) {
        const duration = Date.now() - startTime;
        console.error(` PipelineManager: ${config.type} pipeline failed:`, error);
        return {
            success: false,
            type: config.type,
            phase: 'failed',
            summary: {
                errors: 1,
                duration,
            },
            details: {
                error: error instanceof Error ? error.message : 'Unknown error',
            },
            timestamp: new Date().toISOString(),
        };
    }
    /**
     * Run URL discovery using Tavily search
     */
    async runDiscovery(_params) {
        const startTime = Date.now();
        try {
            console.info(` PipelineManager: Starting discovery process...`);
            // Use the existing discovery engine's method
            const discoveryResult = await discoveryEngine.discoverNewFoodTrucks();
            const duration = Date.now() - startTime;
            return {
                success: discoveryResult.errors.length === 0,
                urlsDiscovered: discoveryResult.urls_discovered,
                urlsStored: discoveryResult.urls_stored,
                urlsDuplicate: discoveryResult.urls_duplicates,
                errors: discoveryResult.errors,
                duration,
            };
        }
        catch (error) {
            const duration = Date.now() - startTime;
            const errorMsg = error instanceof Error ? error.message : 'Unknown discovery error';
            console.error(' PipelineManager: Discovery failed:', error);
            return {
                success: false,
                urlsDiscovered: 0,
                urlsStored: 0,
                urlsDuplicate: 0,
                errors: [errorMsg],
                duration,
            };
        }
    }
    /**
     * Process existing scraping jobs
     */
    async processJobs(options) {
        const startTime = Date.now();
        try {
            console.info(` PipelineManager: Processing up to ${options.maxJobs} jobs...`);
            const pendingJobs = await ScrapingJobService.getJobsByStatus('pending');
            if (pendingJobs == undefined || pendingJobs.length === 0) {
                return this.createEmptyProcessingResult(startTime);
            }
            const jobsToProcess = pendingJobs.slice(0, options.maxJobs);
            const results = await this.processJobBatch(jobsToProcess, startTime);
            return results;
        }
        catch (error) {
            return this.createProcessingErrorResult(error, startTime);
        }
    }
    /**
     * Create empty processing result when no jobs available
     */
    createEmptyProcessingResult(startTime) {
        console.info('No pending jobs to process');
        return {
            success: true,
            jobsProcessed: 0,
            jobsSuccessful: 0,
            jobsFailed: 0,
            trucksCreated: 0,
            errors: [],
            duration: Date.now() - startTime,
        };
    }
    /**
     * Process a batch of jobs
     */
    async processJobBatch(jobsToProcess, startTime) {
        const errors = [];
        let jobsSuccessful = 0;
        let jobsFailed = 0;
        let trucksCreated = 0;
        for (const job of jobsToProcess) {
            try {
                console.info(`Processing job ${job.id} for URL: ${job.target_url}`);
                await processScrapingJob(job.id);
                const updatedJob = await ScrapingJobService.getJobsByStatus('completed').then((jobs) =&gt; jobs?.find((j) =&gt; j.id === job.id));
                if (updatedJob?.data_collected?.truck_id != undefined) {
                    trucksCreated += 1;
                }
                jobsSuccessful += 1;
            }
            catch (jobError) {
                const errorMsg = `Job ${job.id} failed: ${jobError instanceof Error ? jobError.message : 'Unknown error'}`;
                console.warn(errorMsg);
                errors.push(errorMsg);
                jobsFailed += 1;
            }
        }
        return {
            success: jobsFailed === 0,
            jobsProcessed: jobsToProcess.length,
            jobsSuccessful,
            jobsFailed,
            trucksCreated,
            errors,
            duration: Date.now() - startTime,
        };
    }
    /**
     * Create processing error result
     */
    createProcessingErrorResult(error, startTime) {
        const duration = Date.now() - startTime;
        const errorMsg = error instanceof Error ? error.message : 'Unknown processing error';
        console.error(' PipelineManager: Job processing failed:', error);
        return {
            success: false,
            jobsProcessed: 0,
            jobsSuccessful: 0,
            jobsFailed: 0,
            trucksCreated: 0,
            errors: [errorMsg],
            duration,
        };
    }
    /**
     * Run full pipeline: discovery + processing
     */
    async runFullPipeline(config) {
        const results = {
            discovery: undefined,
            processing: undefined,
        };
        // Step 1: Discovery (unless skipped)
        if (config.params.skipDiscovery !== true) {
            results.discovery = await this.runDiscovery({
                cities: config.params.targetCities ?? ['Charleston', 'Columbia', 'Greenville'],
                maxUrls: config.params.maxUrls ?? 50,
                searchTerms: ['food truck', 'food cart', 'mobile food'],
            });
        }
        // Step 2: Processing
        results.processing = await this.processJobs({
            maxJobs: config.params.maxUrlsToProcess ?? 20,
            priority: config.params.priority ?? 5,
            retryFailedJobs: config.params.retryFailedJobs ?? false,
        });
        // Combine results
        return {
            urlsDiscovered: results.discovery?.urlsDiscovered ?? 0,
            urlsStored: results.discovery?.urlsStored ?? 0,
            urlsDuplicate: results.discovery?.urlsDuplicate ?? 0,
            jobsProcessed: results.processing?.jobsProcessed ?? 0,
            trucksCreated: results.processing?.trucksCreated ?? 0,
            errors: [...(results.discovery?.errors ?? []), ...(results.processing?.errors ?? [])],
        };
    }
    /**
     * Run maintenance checks on existing trucks
     */
    async runMaintenance() {
        const startTime = Date.now();
        try {
            console.info(' PipelineManager: Running maintenance checks...');
            // Use the existing autoScraper functionality
            const result = await ensureDefaultTrucksAreScraped();
            const duration = Date.now() - startTime;
            return {
                success: result.errors.length === 0,
                trucksProcessed: result.trucksProcessed,
                newTrucksFound: result.newTrucksFound,
                errors: result.errors.map((e) =&gt; e.url + ': ' + (e.details ?? 'Unknown error')),
                duration,
            };
        }
        catch (error) {
            const duration = Date.now() - startTime;
            const errorMsg = error instanceof Error ? error.message : 'Unknown maintenance error';
            console.error(' PipelineManager: Maintenance failed:', error);
            return {
                success: false,
                trucksProcessed: 0,
                newTrucksFound: 0,
                errors: [errorMsg],
                duration,
            };
        }
    }
}
// Export singleton instance
export const pipelineManager = new PipelineManager();</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/gemini.js (Line 5:26 - Line 186:2), C:/AI/food-truck-finder-poc/dist/lib/lib/gemini.js (Line 5:29 - Line 186:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn623" onclick="toggleCodeBlock('cloneGroup623', 'expandBtn623', 'collapseBtn623')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn623" onclick="toggleCodeBlock('cloneGroup623', 'expandBtn623', 'collapseBtn623')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup623"><code class="language-javascript text-sm text-gray-800">;
export class GeminiService {
    apiClient;
    dailyRequestLimit = 1500;
    dailyTokenLimit = 32_000;
    constructor() {
        this.apiClient = new GeminiApiClient();
    }
    checkUsageLimits = () =&gt; {
        return GeminiUsageLimits.checkUsageLimits({
            dailyRequestLimit: this.dailyRequestLimit,
            dailyTokenLimit: this.dailyTokenLimit,
        });
    };
    makeGeminiRequest = async (prompt, parser) =&gt; {
        return this.apiClient.makeRequestWithParsing(prompt, parser);
    };
    processMenuData = async (rawMenuText) =&gt; {
        const estimatedTokens = Math.ceil(rawMenuText.length / 4) + 500;
        const usageCheck = await GeminiUsageLimits.checkWithMonitoring(estimatedTokens);
        if (!usageCheck.allowed) {
            console.error('Gemini API usage limit error:', usageCheck.reason);
            return {
                success: false,
                error: &quot;That didn't work, please try again later.&quot;,
            };
        }
        const prompt = PromptTemplates.menuProcessing(rawMenuText);
        return this.makeGeminiRequest(prompt, (text) =&gt; {
            const parsedData = JSON.parse(text);
            return parsedData.categories;
        });
    };
    extractLocationFromText = async (textInput) =&gt; {
        const usageCheck = await this.checkUsageLimits();
        if (!usageCheck.canMakeRequest) {
            console.error('Gemini API usage limit error: Daily API limits exceeded');
            return {
                success: false,
                error: &quot;That didn't work, please try again later.&quot;,
            };
        }
        const prompt = PromptTemplates.locationExtraction(textInput);
        return this.makeGeminiRequest(prompt, (text) =&gt; GeminiResponseParser.parseLocationData(text));
    };
    standardizeOperatingHours = async (hoursText) =&gt; {
        const usageCheck = await this.checkUsageLimits();
        if (!usageCheck.canMakeRequest) {
            console.error('Gemini API usage limit error: Daily API limits exceeded');
            return {
                success: false,
                error: &quot;That didn't work, please try again later.&quot;,
            };
        }
        const prompt = PromptTemplates.operatingHours(hoursText);
        return this.makeGeminiRequest(prompt, (text) =&gt; GeminiResponseParser.parseOperatingHours(text));
    };
    analyzeSentiment = async (reviewText) =&gt; {
        const usageCheck = await this.checkUsageLimits();
        if (!usageCheck.canMakeRequest) {
            console.error('Gemini API usage limit error: Daily API limits exceeded');
            return {
                success: false,
                error: &quot;That didn't work, please try again later.&quot;,
            };
        }
        const prompt = PromptTemplates.sentimentAnalysis(reviewText);
        return this.makeGeminiRequest(prompt, (text) =&gt; GeminiResponseParser.parseSentimentAnalysis(text));
    };
    enhanceFoodTruckData = async (rawData) =&gt; {
        const usageCheck = await this.checkUsageLimits();
        if (!usageCheck.canMakeRequest) {
            console.error('Gemini API usage limit error: Daily API limits exceeded');
            return {
                success: false,
                error: &quot;That didn't work, please try again later.&quot;,
            };
        }
        const prompt = PromptTemplates.dataEnhancement(rawData);
        return this.makeGeminiRequest(prompt, (text) =&gt; GeminiResponseParser.parseEnhancedFoodTruckData(text));
    };
    batchProcess = async (items) =&gt; {
        const results = [];
        for (const item of items) {
            let result;
            switch (item.type) {
                case 'menu': {
                    result = await this.processMenuData(item.data);
                    break;
                }
                case 'location': {
                    result = await this.extractLocationFromText(item.data);
                    break;
                }
                case 'hours': {
                    result = await this.standardizeOperatingHours(item.data);
                    break;
                }
                case 'sentiment': {
                    result = await this.analyzeSentiment(item.data);
                    break;
                }
                case 'enhance': {
                    result = await this.enhanceFoodTruckData(item.data); // item.data is already unknown
                    break;
                }
                default: {
                    console.error('Unknown processing type in Gemini batchProcess:', item.type);
                    result = { success: false, error: &quot;That didn't work, please try again later.&quot; };
                    break;
                }
            }
            results.push(result);
        }
        return results;
    };
    getUsageStats = async () =&gt; {
        const usage = await APIUsageService.getTodayUsage('gemini');
        return usage ?? undefined;
    };
    extractFoodTruckDetailsFromMarkdown = async (markdownContent, sourceUrl) =&gt; {
        const usageCheck = await this.checkUsageLimits();
        if (!usageCheck.canMakeRequest) {
            console.error('Gemini API usage limit error: Daily API limits exceeded for Gemini');
            return {
                success: false,
                error: &quot;That didn't work, please try again later.&quot;,
            };
        }
        const prompt = PromptTemplates.foodTruckExtraction(markdownContent, sourceUrl);
        const response = await this.makeGeminiRequest(prompt, (text) =&gt; {
            const cleanedText = GeminiResponseParser.cleanMarkdownResponse(text);
            return GeminiResponseParser.parseExtractedFoodTruckDetails(cleanedText);
        });
        // Add promptSent to response for this specific method
        return {
            ...response,
            promptSent: prompt,
        };
    };
}
/**
* Dispatches the appropriate Gemini operation based on the provided type.
* @example
* dispatchGeminiOperation('menu', 'data')
* Returns a promise with processed menu data response
* @param {'menu' | 'location' | 'hours' | 'sentiment' | 'enhance' | 'foodTruckExtraction'} type - The type of Gemini operation to dispatch.
* @param {unknown} data - Data relevant to the specified Gemini operation type.
* @returns {Promise&lt;GeminiResponse&lt;unknown&gt;&gt;} Returns a promise that resolves to the Gemini operation's response.
* @description
*   - Operates asynchronously, ensuring the flexibility and responsiveness of Gemini processing.
*   - Utilizes type assertion to correctly handle various data types pertinent to the operation.
*   - If the operation type is unrecognized, the function returns an error response.
*/
export async function dispatchGeminiOperation(type, data) {
    switch (type) {
        case 'menu': {
            return gemini.processMenuData(data);
        }
        case 'location': {
            return gemini.extractLocationFromText(data);
        }
        case 'hours': {
            return gemini.standardizeOperatingHours(data);
        }
        case 'sentiment': {
            return gemini.analyzeSentiment(data);
        }
        case 'enhance': {
            return gemini.enhanceFoodTruckData(data);
        }
        case 'foodTruckExtraction': {
            const { markdownContent, sourceUrl } = data;
            return gemini.extractFoodTruckDetailsFromMarkdown(markdownContent, sourceUrl);
        }
        default: {
            return { success: false, error: `Unknown Gemini operation type: ${String(type)}` };
        }
    }
}
// Export singleton instance
export const gemini = new GeminiService();</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/firecrawl.js (Line 1:1 - Line 407:2), C:/AI/food-truck-finder-poc/dist/lib/lib/firecrawl.js (Line 1:1 - Line 407:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn625" onclick="toggleCodeBlock('cloneGroup625', 'expandBtn625', 'collapseBtn625')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn625" onclick="toggleCodeBlock('cloneGroup625', 'expandBtn625', 'collapseBtn625')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup625"><code class="language-javascript text-sm text-gray-800">const FIRECRAWL_CACHE_TTL_MS = 1000 * 60 * 60 * 12; // 12 hours
const firecrawlCache = {};
export class FirecrawlService {
    apiKey;
    baseUrl;
    constructor() {
        this.apiKey = process.env.FIRECRAWL_API_KEY;
        this.baseUrl = 'https://api.firecrawl.dev/v0';
    }
    /**
     * Retrieves a cached result based on the given cache key if it hasn't expired.
     * @example
     * getCachedResult('uniqueCacheKey')
     * FirecrawlResponse or undefined
     * @param {string} cacheKey - The unique identifier for the cached result.
     * @returns {FirecrawlResponse | CrawlJobResponse | CrawlStatusResponse | undefined} The cached data if available and valid, otherwise undefined.
     * @description
     *   - Cleans up expired cache entries before attempting to return a cached result.
     *   - Logs a message when a cache hit occurs.
     */
    getCachedResult(cacheKey) {
        const now = Date.now();
        // Clean up expired cache
        for (const key in firecrawlCache) {
            if (Object.prototype.hasOwnProperty.call(firecrawlCache, key) &amp;&amp;
                now - firecrawlCache[key].timestamp &gt; FIRECRAWL_CACHE_TTL_MS) {
                delete firecrawlCache[key];
            }
        }
        if (firecrawlCache[cacheKey] != undefined &amp;&amp;
            now - firecrawlCache[cacheKey].timestamp &lt; FIRECRAWL_CACHE_TTL_MS) {
            console.info(`FirecrawlService: Cache hit for ${cacheKey}`);
            return firecrawlCache[cacheKey].data;
        }
        return undefined;
    }
    setCacheResult(cacheKey, data) {
        firecrawlCache[cacheKey] = { data, timestamp: Date.now() };
    }
    /**
    * Fetches and processes content from a specified URL, optionally customizing the output format and content inclusion/exclusion via provided options.
    * @example
    * scrapeUrl('https://example.com', { formats: ['html'], includeTags: ['h1', 'p'] })
    * Returns a FirecrawlResponse object containing the scraped data.
    * @param {string} url - The URL from which content will be scraped.
    * @param {Object} options - Optional parameters to customize the scraping process.
    * @param {(string[]|undefined)} options.formats - Specifies the desired output formats: 'markdown' or 'html'.
    * @param {(string[]|undefined)} options.includeTags - Tags to specifically include in the scraping results.
    * @param {(string[]|undefined)} options.excludeTags - Tags to exclude from the scraping results.
    * @param {(boolean|undefined)} options.onlyMainContent - If true, extracts only the main content from the URL.
    * @param {(number|undefined)} options.waitFor - Time in milliseconds to wait before starting the scraping process.
    * @returns {Promise&lt;FirecrawlResponse&gt;} A promise resolving to a FirecrawlResponse containing either the successful scraping results or error details.
    * @description
    *   - Utilizes caching to store and retrieve previously fetched data to minimize repeated requests.
    *   - Sends API requests with authentication headers using the instance's API key.
    *   - Handles errors gracefully, returning a descriptive error message if the scraping process fails.
    */
    async scrapeUrl(url, options = {}) {
        const cacheKey = `scrape:${url}:${JSON.stringify(options)}`;
        const cached = this.getCachedResult(cacheKey);
        if (cached) {
            return cached;
        }
        try {
            const response = await fetch(`${this.baseUrl}/scrape`, {
                method: 'POST',
                headers: {
                    Authorization: `Bearer ${this.apiKey}`,
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    url,
                    formats: options.formats ?? ['markdown'],
                    includeTags: options.includeTags,
                    excludeTags: options.excludeTags,
                    onlyMainContent: options.onlyMainContent ?? true,
                    waitFor: options.waitFor ?? 0,
                }),
            });
            const data = await response.json();
            if (!response.ok) {
                const errorData = data;
                throw new Error(errorData.error ?? `HTTP ${response.status}`);
            }
            this.setCacheResult(cacheKey, data);
            return data;
        }
        catch (error) {
            console.warn('Firecrawl scrape error:', error);
            return {
                success: false,
                error: error instanceof Error ? error.message : 'Unknown error',
            };
        }
    }
    /**
     * Initiates a web crawling process for a specified URL with given options.
     * @example
     * crawlWebsite('https://example.com', { crawlerOptions: { includes: ['.html'] }, pageOptions: { formats: ['markdown'] } })
     * // Returns a promise that resolves to a CrawlJobResponse object
     * @param {string} url - The URL of the website to be crawled.
     * @param {Object} options - Configuration options for the crawling process.
     * @param {Object} [options.crawlerOptions] - Specific options for controlling the crawler behavior.
     * @param {string[]} [options.crawlerOptions.includes] - List of patterns to include in the crawl.
     * @param {string[]} [options.crawlerOptions.excludes] - List of patterns to exclude from the crawl.
     * @param {number} [options.crawlerOptions.maxDepth] - Maximum depth the crawler should reach.
     * @param {number} [options.crawlerOptions.limit] - Limit to the number of pages to crawl.
     * @param {Object} [options.pageOptions] - Options for the page content format and selection.
     * @param {string[]} [options.pageOptions.formats] - Desired formats for the crawled page content.
     * @param {boolean} [options.pageOptions.onlyMainContent] - Whether to include only the main content of the pages.
     * @returns {Promise&lt;CrawlJobResponse&gt;} A promise that resolves with the results of the crawl job including success and potential errors.
     * @description
     *   - Performs a POST request to the Firecrawl service to crawl pages.
     *   - Uses caching to avoid redundant web crawling operations.
     *   - Handles errors gracefully, returning an appropriate error message if the fetch operation fails.
     *   - Crawls with default options which include markdown format and filtering for main content.
     */
    async crawlWebsite(url, options = {}) {
        const cacheKey = `crawl:${url}:${JSON.stringify(options)}`;
        const cached = this.getCachedResult(cacheKey);
        if (cached) {
            return cached;
        }
        try {
            const response = await fetch(`${this.baseUrl}/crawl`, {
                method: 'POST',
                headers: {
                    Authorization: `Bearer ${this.apiKey}`,
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    url,
                    crawlerOptions: {
                        maxDepth: 2,
                        limit: 10,
                        ...options.crawlerOptions,
                    },
                    pageOptions: {
                        formats: ['markdown'],
                        onlyMainContent: true,
                        ...options.pageOptions,
                    },
                }),
            });
            const data = await response.json();
            if (!response.ok) {
                const errorData = data;
                throw new Error(errorData.error ?? `HTTP ${response.status}`);
            }
            this.setCacheResult(cacheKey, data);
            return data;
        }
        catch (error) {
            console.warn('Firecrawl crawl error:', error);
            return {
                success: false,
                error: error instanceof Error ? error.message : 'Unknown error',
            };
        }
    }
    /**
     * Retrieves the crawl status for a given job by its ID.
     * @example
     * getCrawlStatus('12345')
     * { success: true, status: 'completed' }
     * @param {string} jobId - The ID of the job for which the crawl status is requested.
     * @returns {Promise&lt;CrawlStatusResponse&gt;} Resolves to a `CrawlStatusResponse` object containing the crawl status or an error.
     * @description
     *   - Attempts to retrieve the crawl status from a cache before making an HTTP request.
     *   - Fetches crawl status using an authenticated request to the API.
     *   - Caches the crawl status response data to minimize redundant network calls.
     *   - Handles errors gracefully, returning a standardized error response.
     */
    async getCrawlStatus(jobId) {
        const cacheKey = `crawlStatus:${jobId}`;
        const cached = this.getCachedResult(cacheKey);
        if (cached) {
            return cached;
        }
        try {
            const response = await fetch(`${this.baseUrl}/crawl/status/${jobId}`, {
                headers: {
                    Authorization: `Bearer ${this.apiKey}`,
                },
            });
            const data = await response.json();
            if (!response.ok) {
                const errorData = data;
                throw new Error(errorData.error ?? `HTTP ${response.status}`);
            }
            this.setCacheResult(cacheKey, data);
            return data;
        }
        catch (error) {
            console.warn('Firecrawl status error:', error);
            return {
                success: false,
                error: error instanceof Error ? error.message : 'Unknown error',
            };
        }
    }
    // Specialized methods for food truck data
    /**
     * Scrapes a food truck website and retrieves its main content in markdown format.
     * @example
     * scrapeFoodTruckWebsite('https://example.com/food-truck')
     * // Returns: Promise&lt;{ success: true, data: { markdown: '...', name: 'Example Food Truck', source_url: 'https://example.com/food-truck' } }&gt;
     * @param {string} url - The URL of the food truck website to scrape.
     * @returns {Promise&lt;{ success: boolean, data?: { markdown: string, name?: string, source_url?: string }, error?: string }&gt;} The result of the scrape operation, including markdown content and metadata if successful, or an error message if not.
     * @description
     *   - Configured to wait 2000 milliseconds to ensure all content is loaded.
     *   - Uses 'markdown' format for content extraction to maintain text structure.
     *   - Extracts metadata such as the title and source URL if available.
     */
    async scrapeFoodTruckWebsite(url) {
        const result = await this.scrapeUrl(url, {
            formats: ['markdown'],
            onlyMainContent: true,
            waitFor: 2000,
        });
        return result.success &amp;&amp; result.data?.markdown != undefined
            ? {
                success: true,
                data: {
                    markdown: result.data.markdown,
                    name: result.data.metadata?.title,
                    source_url: result.data.metadata?.sourceURL,
                },
            }
            : { success: false, error: result.error ?? 'Markdown content not found' };
    }
    extractPattern(text, pattern) {
        const match = pattern.exec(text);
        return match ? match[1].trim() : undefined;
    }
    /**
    * Extracts a menu section from a given markdown string based on specific keywords.
    * @example
    * extractMenuSection(&quot;menu: Pizza, Pasta, Salad&quot;)
    * // Returns &quot;Pizza, Pasta, Salad&quot;
    * @param {string} markdown - The markdown string to search for menu-related content.
    * @returns {string | undefined} The extracted menu section if found, otherwise undefined.
    * @description
    *   - Searches for menu-related phrases like &quot;menu&quot;, &quot;food&quot;, &quot;items&quot; up to a maximum of 50 characters.
    *   - Implements case-insensitive search patterns.
    *   - Returns the portion of the markdown line following the specific keywords.
    */
    extractMenuSection(markdown) {
        // Use simpler, more efficient regex patterns with fixed max length
        const menuPatterns = [
            /menu\s*:\s*([^\n]{1,50})/i,
            /food\s*:\s*([^\n]{1,50})/i,
            /items?\s*:\s*([^\n]{1,50})/i,
            /what we serve\s*:\s*([^\n]{1,50})/i,
            /our food\s*:\s*([^\n]{1,50})/i,
        ];
        for (const pattern of menuPatterns) {
            const match = pattern.exec(markdown);
            if (match) {
                return match[1].trim();
            }
        }
        return undefined;
    }
    /**
     * Extracts phone and email contact information from a markdown string.
     * @example
     * extractContactInfo(&quot;Contact: +123-456-7890, email: example@test.com&quot;)
     * { phone: &quot;+123-456-7890&quot;, email: &quot;example@test.com&quot; }
     * @param {string} markdown - A markdown string potentially containing contact information.
     * @returns {ContactInfo | undefined} An object containing extracted phone and email, or undefined if none are found.
     * @description
     *   - Utilizes regular expressions to identify phone numbers and email addresses within the markdown.
     *   - Returns an object only when at least one type of contact information is successfully extracted.
     */
    extractContactInfo(markdown) {
        const contact = {}; // Phone number - Use specific patterns to prevent backtracking
        const phoneRegex = /(?:phone|call|contact)(?:\s*:\s*)?([+]?\d{3,4}[.\s-]\d{3}[.\s-]\d{3,4})/i;
        const phoneMatch = phoneRegex.exec(markdown);
        if (phoneMatch) {
            contact.phone = phoneMatch[1].trim();
        } // Email - Use specific pattern to avoid backtracking
        const emailRegex = /([a-zA-Z0-9._%-]{1,64}@[a-zA-Z0-9-]{1,63}\.[a-zA-Z]{2,6})/;
        const emailMatch = emailRegex.exec(markdown);
        if (emailMatch) {
            contact.email = emailMatch[1].trim();
        }
        return Object.keys(contact).length &gt; 0 ? contact : undefined;
    }
    /**
    * Extracts social media profile names from a given markdown string.
    * @example
    * extractSocialMedia(&quot;@john_doe instagram.com/jane Facebook.com/joe&quot;)
    * { instagram: 'john_doe', facebook: 'jane', twitter: 'joe' }
    * @param {string} markdown - A string containing markdown text to parse for social media information.
    * @returns {SocialMediaInfo | undefined} An object containing social media profiles if any are found, otherwise undefined.
    * @description
    *   - Supports extracting profiles for Instagram, Facebook, and Twitter.
    *   - Uses regular expressions to match social media patterns.
    *   - Returns the trimmed username of identified social media profiles.
    *   - Returns undefined if no social media profiles are found in the input.
    */
    extractSocialMedia(markdown) {
        const social = {};
        // Instagram - Use concise character class
        const instagramRegex = /(?:instagram|@)\s*([\w.]+)/i;
        const instagramMatch = instagramRegex.exec(markdown);
        if (instagramMatch) {
            social.instagram = instagramMatch[1].trim();
        }
        // Facebook - With fixed character class
        const facebookRegex = /facebook\.com\/([\w.-]+)/i;
        const facebookMatch = facebookRegex.exec(markdown);
        if (facebookMatch) {
            social.facebook = facebookMatch[1].trim();
        }
        // Twitter - Use concise character class
        const twitterRegex = /(?:twitter|@)\s*([\w.]+)/i; // Changed \w+ to [\w.]+ to allow dots in usernames
        const twitterMatch = twitterRegex.exec(markdown);
        if (twitterMatch) {
            social.twitter = twitterMatch[1].trim();
        }
        return Object.keys(social).length &gt; 0 ? social : undefined;
    }
    /**
     * Performs web scraping on multiple URLs with batching and delay options.
     * @example
     * scrapeMultipleUrls(['http://example.com', 'http://another.com'], { batchSize: 2, delay: 1500 })
     * Returns: Promise resolving to an array containing the results of the scraped URLs.
     * @param {string[]} urls - Array of URLs to be scraped.
     * @param {Object} options - Options object for configuring the scraping process.
     * @param {number} [options.batchSize=5] - Size of each batch in which URLs are processed.
     * @param {number} [options.delay=1000] - Delay between processing each batch in milliseconds.
     * @returns {Promise&lt;Array&lt;{ url: string; result: FirecrawlResponse }&gt;&gt;} Promise resolving to an array of objects, each containing a URL and its corresponding scrape result.
     * @description
     *   - Utilizes a batch mechanism to efficiently handle large sets of URLs.
     *   - Incorporates a delay between batches to comply with potential rate limits.
     */
    async scrapeMultipleUrls(urls, options = {}) {
        const batchSize = options.batchSize ?? 5;
        const delay = options.delay ?? 1000;
        const results = [];
        for (let i = 0; i &lt; urls.length; i += batchSize) {
            const batch = urls.slice(i, i + batchSize);
            const batchPromises = batch.map(async (url) =&gt; {
                const result = await this.scrapeUrl(url);
                return { url, result };
            });
            const batchResults = await Promise.all(batchPromises);
            results.push(...batchResults);
            // Add delay between batches to respect rate limits
            if (i + batchSize &lt; urls.length) {
                await new Promise((resolve) =&gt; { setTimeout(resolve, delay); });
            }
        }
        return results;
    }
    // Rate limiting and error handling
    /**
     * Attempts to scrape content from a given URL with retries in case of failure.
     * @example
     * scrapeWithRetry('https://example.com', 3, 1000)
     * { success: true, data: {...} }
     * @param {string} url - The URL to scrape.
     * @param {number} maxRetries - Maximum number of retry attempts. Defaults to 3.
     * @param {number} backoffMs - Initial wait time before retrying in milliseconds. Defaults to 1000ms.
     * @returns {Promise&lt;FirecrawlResponse&gt;} Promise resolving to a FirecrawlResponse object indicating success or failure.
     * @description
     *   - Implements exponential backoff strategy for rate limit errors.
     *   - Logs attempt details and waiting times between retries.
     *   - Returns last error message if all retry attempts fail.
     */
    async scrapeWithRetry(url, maxRetries = 3, backoffMs = 1000) {
        let lastError;
        for (let attempt = 1; attempt &lt;= maxRetries; attempt += 1) {
            try {
                const result = await this.scrapeUrl(url);
                if (result.success) {
                    return result;
                }
                // If it's a rate limit error, wait longer
                if (result.error?.includes('rate limit') === true) {
                    const waitTime = backoffMs * 2 ** attempt;
                    console.info(`Rate limited. Waiting ${waitTime}ms before retry ${attempt}/${maxRetries}`);
                    await new Promise((resolve) =&gt; { setTimeout(resolve, waitTime); });
                    continue;
                }
                throw new Error(result.error);
            }
            catch (error) {
                lastError = error instanceof Error ? error : new Error(String(error));
                if (attempt === maxRetries) {
                    break;
                }
                const waitTime = backoffMs * 2 ** attempt;
                console.info(`Attempt ${attempt} failed. Retrying in ${waitTime}ms...`);
                await new Promise((resolve) =&gt; { setTimeout(resolve, waitTime); });
            }
        }
        return {
            success: false,
            error: lastError.message,
        };
    }
}
// Export singleton instance
export const firecrawl = new FirecrawlService();</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/discoveryEngine.js (Line 2:13 - Line 723:2), C:/AI/food-truck-finder-poc/dist/lib/lib/discoveryEngine.js (Line 2:41 - Line 723:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn627" onclick="toggleCodeBlock('cloneGroup627', 'expandBtn627', 'collapseBtn627')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn627" onclick="toggleCodeBlock('cloneGroup627', 'expandBtn627', 'collapseBtn627')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup627"><code class="language-javascript text-sm text-gray-800">;
import { SC_TARGET_CITIES, DISCOVERY_CONFIG } from './config';
/**
* Executes a search request against the Tavily API.
* @example
* tavilySearch('example query', { limit: 5 })
* // returns array of TavilySearchResult objects
* @param {string} query - The search query string.
* @param {Record&lt;string, unknown&gt;} options - Optional configurations such as 'limit' to restrict the number of results.
* @returns {Promise&lt;TavilySearchResult[]&gt;} Promise resolving to an array of search results.
* @description
*   - Defaults to 10 results if 'limit' is not specified in options.
*   - Throws an error if the API response is not successful.
*   - Combines 'query' and other options into a request payload.
*   - Uses environment variable NEXT_PUBLIC_APP_URL for base URL, or defaults to 'http://localhost:3003'.
*/
async function tavilySearch(query, options = {}) {
    const baseUrl = process.env.NEXT_PUBLIC_APP_URL ?? 'http://localhost:3003';
    const response = await fetch(`${baseUrl}/api/tavily`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
            operation: 'search',
            params: {
                query,
                limit: options.limit ?? 10,
                ...options,
            },
        }),
    });
    if (!response.ok) {
        throw new Error(`Tavily search failed: ${response.statusText}`);
    }
    const result = (await response.json());
    return result.data?.results ?? result.results ?? [];
}
/**
* Initiates a web crawling operation asynchronously via Firecrawl API and returns the resulting data.
* @example
* firecrawlCrawl('https://example.com', { maxDepth: 3, limit: 50 })
* // Returns a Promise resolving to an array of CrawlResult objects.
* @param {string} url - The URL of the website to initiate the crawl.
* @param {Record&lt;string, unknown&gt;} options - Optional parameters to customize the crawling operation. Default values are maxDepth: 2 and limit: 20.
* @returns {Promise&lt;CrawlResult[]&gt;} Promise resolving to an array of resulting data from the crawl operation.
* @description
*   - Utilizes server URL from environment variable NEXT_PUBLIC_APP_URL or defaults to 'http://localhost:3003'.
*   - Sends a POST request to the '/api/firecrawl' endpoint with specified crawl operation settings.
*   - Throws an error if the HTTP response status is not OK indicating a failure in the crawl operation.
*/
async function firecrawlCrawl(url, options = {}) {
    const baseUrl = process.env.NEXT_PUBLIC_APP_URL ?? 'http://localhost:3003';
    const response = await fetch(`${baseUrl}/api/firecrawl`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
            operation: 'crawl',
            url,
            options: {
                maxDepth: options.maxDepth ?? 2,
                limit: options.limit ?? 20,
                ...options,
            },
        }),
    });
    if (!response.ok) {
        throw new Error(`Firecrawl crawl failed: ${response.statusText}`);
    }
    const result = (await response.json());
    return result.data ?? [];
}
export class FoodTruckDiscoveryEngine {
    searchTerms = [
        'food truck South Carolina',
        'mobile food vendor SC',
        'food truck Charleston',
        'food truck Columbia SC',
        'food truck Greenville SC',
        'street food South Carolina',
        'food truck directory SC',
    ];
    directoryUrls = [
        'https://www.foodtrucksin.com/south-carolina',
        'https://www.roaminghunger.com/sc/',
        'https://southcarolinafoodtrucks.com',
        'https://www.yelp.com/sc/food-trucks',
    ];
    // Helper method to process search results
    /**
     * Processes search results to discover and store food truck URLs.
     * @example
     * processSearchResults([{ url: 'http://example.com', content: '...' }], new Set())
     * // No return value; `discoveredUrls` will contain food truck URLs.
     * @param {TavilySearchResult[]} searchResults - An array of search result objects each possibly containing a URL and content.
     * @param {Set&lt;string&gt;} discoveredUrls - A set to store discovered food truck URLs.
     * @returns {Promise&lt;void&gt;} No return value; operates by modifying the `discoveredUrls` set.
     * @description
     *   - URLs are checked for validity as food truck URLs before being added to the set.
     *   - Extracts URLs from either the `content` or `raw_content` fields.
     *   - Uses asynchronous URL validation.
     */
    async processSearchResults(searchResults, discoveredUrls) {
        for (const result of searchResults) {
            if (result.url &amp;&amp; (await this.isFoodTruckUrl(result.url))) {
                discoveredUrls.add(result.url);
            }
            // Extract URLs from content
            if (result.content != undefined || result.raw_content != undefined) {
                const content = result.content ?? result.raw_content ?? '';
                const extractedUrls = this.extractFoodTruckUrls(content);
                for (const url of extractedUrls) {
                    if (await this.isFoodTruckUrl(url)) {
                        discoveredUrls.add(url);
                    }
                }
            }
        }
    }
    // Helper method to perform search term discovery
    /**
     * Performs search term discovery using the specified search terms.
     * @example
     * performSearchTermDiscovery(new Set(), discoveryResult)
     * No specific return value, performs actions on `discoveredUrls` and `results`.
     * @param {Set&lt;string&gt;} discoveredUrls - A set to store discovered URLs that have been processed.
     * @param {DiscoveryResult} results - An object to accumulate results and errors stemming from the discovery process.
     * @returns {Promise&lt;void&gt;} Returns a promise that resolves when search term discovery is complete.
     * @description
     *   - Utilizes a search function `tavilySearch` to find results based on search terms.
     *   - Incorporates error handling and logs errors to `results.errors`.
     *   - Implements rate limiting by delaying subsequent searches using `DISCOVERY_CONFIG.rateLimitDelayMs`.
     *   - Processes search results using the `processSearchResults` method if valid results are found.
     */
    async performSearchTermDiscovery(discoveredUrls, results) {
        for (const searchTerm of this.searchTerms) {
            try {
                console.info(` Searching for: ${searchTerm}`);
                const searchResults = await tavilySearch(searchTerm, {
                    limit: DISCOVERY_CONFIG.searchResultsLimit,
                });
                if (searchResults != undefined &amp;&amp; searchResults.length &gt; 0) {
                    await this.processSearchResults(searchResults, discoveredUrls);
                }
            }
            catch (error) {
                console.error(` Search failed for &quot;${searchTerm}&quot;:`, error);
                results.errors.push(`Search failed for &quot;${searchTerm}&quot;: ${error instanceof Error ? error.message : 'Unknown error'}`);
            }
            await this.delay(DISCOVERY_CONFIG.rateLimitDelayMs);
        }
    }
    // Helper method to perform directory crawling
    async performDirectoryCrawling(discoveredUrls, results) {
        for (const directoryUrl of this.directoryUrls) {
            await this.crawlSingleDirectory(directoryUrl, discoveredUrls, results);
            await this.delay(DISCOVERY_CONFIG.rateLimitDelayMs);
        }
    }
    // Helper method to crawl a single directory
    /**
     * Crawls a single directory and processes discovered URLs.
     * @example
     * crawlSingleDirectory('http://example.com', new Set(), resultsInstance)
     * void
     * @param {string} directoryUrl - The URL of the directory to be crawled.
     * @param {Set&lt;string&gt;} discoveredUrls - A set to store URLs discovered during the crawl.
     * @param {DiscoveryResult} results - An object to store the results and errors of the crawl process.
     * @returns {Promise&lt;void&gt;} Resolves when crawl and processing are complete.
     * @description
     *   - Uses a third-party library, `firecrawlCrawl`, for the crawling operation.
     *   - Handles errors by logging and storing error messages in the results object.
     *   - Limits the depth and number of URLs explored based on configuration.
     */
    async crawlSingleDirectory(directoryUrl, discoveredUrls, results) {
        try {
            console.info(` Crawling directory: ${directoryUrl}`);
            const crawlResults = await firecrawlCrawl(directoryUrl, {
                maxDepth: DISCOVERY_CONFIG.maxDepthCrawl,
                limit: DISCOVERY_CONFIG.maxUrlsPerRun,
            });
            await this.processCrawlResults(crawlResults, discoveredUrls);
        }
        catch (error) {
            console.error(` Crawl failed for ${directoryUrl}:`, error);
            results.errors.push(`Crawl failed for ${directoryUrl}: ${error instanceof Error ? error.message : 'Unknown error'}`);
        }
    }
    // Helper method to process crawl results
    /**
     * Processes the results from a web crawl and adds discovered URLs to a set if they meet certain criteria.
     * @example
     * processCrawlResults(crawlResults, discoveredUrls)
     * // adds qualifying URLs to the discoveredUrls set
     * @param {unknown} crawlResults - The results obtained from the crawling operation.
     * @param {Set&lt;string&gt;} discoveredUrls - A set to store URLs discovered during processing.
     * @returns {Promise&lt;void&gt;}
     * @description
     *   - Only accepts results that are valid non-empty arrays.
     *   - Checks each item to ensure it's an object containing a 'url' property.
     *   - Uses a helper function isFoodTruckUrl to decide if a URL should be added to the set.
     */
    async processCrawlResults(crawlResults, discoveredUrls) {
        if (crawlResults != undefined &amp;&amp; Array.isArray(crawlResults) &amp;&amp; crawlResults.length &gt; 0) {
            for (const result of crawlResults) {
                if (typeof result === 'object' &amp;&amp; result !== null &amp;&amp; 'url' in result) {
                    const resultUrl = result.url;
                    if (resultUrl != undefined &amp;&amp;
                        typeof resultUrl === 'string' &amp;&amp;
                        (await this.isFoodTruckUrl(resultUrl))) {
                        discoveredUrls.add(resultUrl);
                    }
                }
            }
        }
    }
    // Helper method to perform location-specific discovery
    async performLocationDiscovery(discoveredUrls, results) {
        for (const city of SC_TARGET_CITIES) {
            await this.searchSingleCity(city, discoveredUrls, results);
            await this.delay(DISCOVERY_CONFIG.rateLimitDelayMs);
        }
    }
    // Helper method to search a single city
    /**
    * Initiates a search for food trucks within a specified city in South Carolina.
    * @example
    * searchSingleCity(&quot;Charleston&quot;, discoveredUrls, results)
    * // Returns undefined but processes the data internally and updates results object.
    * @param {string} city - The name of the city where food trucks are to be searched.
    * @param {Set&lt;string&gt;} discoveredUrls - A Set to keep track of URLs that have been discovered during the search.
    * @param {DiscoveryResult} results - Object to store errors and possibly other results related to the discovery process.
    * @returns {Promise&lt;void&gt;} Resolves after processing the search results.
    * @description
    *   - Uses `tavilySearch` function to perform the location-based search with a limit of 5 results.
    *   - Handles errors by logging them and updating the results object with error messages.
    *   - Assumes South Carolina as the default state for city searches.
    */
    async searchSingleCity(city, discoveredUrls, results) {
        try {
            console.info(` Searching for food trucks in ${city}, SC`);
            const locationQuery = `food trucks in ${city} South Carolina`;
            const searchResults = await tavilySearch(locationQuery, {
                limit: 5,
            });
            await this.processLocationSearchResults(searchResults, discoveredUrls);
        }
        catch (error) {
            console.error(` Location search failed for ${city}:`, error);
            results.errors.push(`Location search failed for ${city}: ${error instanceof Error ? error.message : 'Unknown error'}`);
        }
    }
    // Helper method to process location search results
    /**
     * Processes search results to discover specific URLs and add them to a set.
     * @example
     * processLocationSearchResults(searchResults, discoveredUrls);
     * // The set discoveredUrls will be populated with food truck URLs from searchResults
     * @param {unknown} searchResults - Array of search result objects potentially containing URLs.
     * @param {Set&lt;string&gt;} discoveredUrls - Set used to collect discovered food truck URLs.
     * @returns {Promise&lt;void&gt;} Resolves when all URLs are processed and added to the set.
     * @description
     *   - Ensures the searchResults contain an array of objects with valid URL properties.
     *   - Filters URLs through isFoodTruckUrl method before adding them to discoveredUrls.
     */
    async processLocationSearchResults(searchResults, discoveredUrls) {
        if (searchResults != undefined &amp;&amp; Array.isArray(searchResults) &amp;&amp; searchResults.length &gt; 0) {
            for (const result of searchResults) {
                if (typeof result === 'object' &amp;&amp; result !== null &amp;&amp; 'url' in result) {
                    const resultUrl = result.url;
                    if (resultUrl != undefined &amp;&amp;
                        typeof resultUrl === 'string' &amp;&amp;
                        (await this.isFoodTruckUrl(resultUrl))) {
                        discoveredUrls.add(resultUrl);
                    }
                }
            }
        }
    }
    // Helper method to store discovered URLs from discovery process
    /**
     * Stores a set of discovered URLs from a discovery process into a database.
     * @example
     * storeDiscoveredUrlsFromDiscovery(new Set(['http://example.com', 'http://example.org']), discoveryResult)
     * // No return value (undefined).
     * @param {Set&lt;string&gt;} discoveredUrls - A set of URLs that have been discovered and need to be stored.
     * @param {DiscoveryResult} results - An object to track and accumulate errors encountered during storage.
     * @returns {Promise&lt;void&gt;} Resolves when all URLs are processed and stored.
     * @description
     *   - This function iterates over a set of URLs and stores each individually.
     *   - Errors encountered during the storage process are logged and appended to the provided results object.
     *   - Utilizes an asynchronous operation to store URLs and handle potential failures gracefully.
     */
    async storeDiscoveredUrlsFromDiscovery(discoveredUrls, results) {
        for (const url of discoveredUrls) {
            try {
                const stored = await this.storeDiscoveredUrl(url, 'autonomous_search', {
                    search_context: 'full_discovery',
                    discovery_timestamp: new Date().toISOString(),
                });
                if (stored.isNew === true) {
                    results.urls_stored += 1;
                }
                else {
                    results.urls_duplicates += 1;
                }
            }
            catch (error) {
                console.error(` Failed to store URL ${url}:`, error);
                results.errors.push(`Failed to store URL ${url}: ${error instanceof Error ? error.message : 'Unknown error'}`);
            }
        }
    }
    /**
    * Initiates autonomous discovery of new food truck URLs.
    * @example
    * discoverNewFoodTrucks()
    * Returns a Promise resolving to a DiscoveryResult object.
    * @param {none} No parameters required.
    * @returns {Promise&lt;DiscoveryResult&gt;} An object containing the counts of discovered, stored, and duplicate URLs and any errors encountered.
    * @description
    *   - Utilizes multiple discovery methods: search term, directory crawling, and location-specific search.
    *   - Aggregates discovered URLs in a Set to ensure uniqueness.
    *   - Logs informative messages regarding the discovery and storage process.
    *   - Handles the storage of newly discovered URLs and logs duplicates.
    */
    async discoverNewFoodTrucks() {
        console.info(' Starting autonomous food truck discovery...');
        const results = {
            urls_discovered: 0,
            urls_stored: 0,
            urls_duplicates: 0,
            errors: [],
        };
        const discoveredUrls = new Set();
        // 1. Search for food trucks using Tavily search
        await this.performSearchTermDiscovery(discoveredUrls, results);
        // 2. Crawl known food truck directory sites
        await this.performDirectoryCrawling(discoveredUrls, results);
        // 3. Location-specific discovery for SC cities
        await this.performLocationDiscovery(discoveredUrls, results);
        results.urls_discovered = discoveredUrls.size;
        console.info(` Discovered ${results.urls_discovered} potential food truck URLs`);
        // 4. Store new URLs in database
        await this.storeDiscoveredUrlsFromDiscovery(discoveredUrls, results);
        console.info(` Discovery complete: ${results.urls_stored} new URLs stored, ${results.urls_duplicates} duplicates skipped`);
        return results;
    }
    /**
     * Extracts valid URLs from a given string content.
     * @example
     * extractFoodTruckUrls(&quot;Check out these two links: https://foodtrucklink.com/menu, and https://anotherlink.com!&quot;)
     * [&quot;https://foodtrucklink.com/menu&quot;, &quot;https://anotherlink.com&quot;]
     * @param {string} content - The textual content from which URLs are extracted.
     * @returns {string[]} An array of valid URLs extracted from the content.
     * @description
     *   - Utilizes a regular expression pattern to identify potential URLs.
     *   - Performs basic URL validation using the URL constructor.
     *   - Cleans up URLs by removing trailing punctuation such as periods, commas, semicolons, etc.
     *   - Skips invalid URLs identified during the validation process.
     */
    extractFoodTruckUrls(content) {
        const urls = [];
        // Look for URL patterns in content - using a safer regex to avoid backtracking
        const urlRegex = /https?:\/\/[^\s&lt;&gt;&quot;']{1,200}/g;
        const foundUrls = content.match(urlRegex) ?? [];
        for (const url of foundUrls) {
            try {
                // Basic URL validation
                new URL(url);
                // Remove trailing punctuation - using safer regex to avoid backtracking
                const cleanUrl = url.replace(/[.,;!?]$/, '');
                urls.push(cleanUrl);
            }
            catch {
                // Invalid URL, skip
                continue;
            }
        }
        return urls;
    }
    /**
     * Checks if a given URL is related to a food truck.
     * @example
     * isFoodTruckUrl(&quot;https://bestfoodtruck.com&quot;)
     * true
     * @param {string} url - The URL to validate and check against known food truck patterns.
     * @returns {Promise&lt;boolean&gt;} True if the URL is likely related to a food truck, false otherwise.
     * @description
     *   - Uses keyword matching to detect food truck-related URLs.
     *   - Excludes common social media and review domains via blacklist.
     *   - Validates if the URL is already present in `discovered_urls` or `food_trucks` database.
     *   - Accepts common business domains not typically associated with blogs or news sites.
     */
    async isFoodTruckUrl(url) {
        try {
            // Basic URL validation
            new URL(url);
            // Food truck indicators in URL
            const foodTruckKeywords = [
                'food-truck',
                'foodtruck',
                'mobile-food',
                'street-food',
                'truck',
                'kitchen',
                'eats',
                'bbq',
                'burger',
                'taco',
                'catering',
                'mobile',
                'chef',
                'bistro',
                'cafe',
            ];
            // Blacklist - skip these domains
            const blacklistKeywords = [
                'facebook.com',
                'instagram.com',
                'twitter.com',
                'linkedin.com',
                'youtube.com',
                'yelp.com',
                'google.com',
                'maps.google.com',
                'foursquare.com',
                'tripadvisor.com',
                'zomato.com',
                'eventbrite.com',
                'meetup.com',
            ];
            const urlLower = url.toLowerCase();
            // Skip social media and review sites
            if (blacklistKeywords.some((keyword) =&gt; urlLower.includes(keyword))) {
                return false;
            }
            // Check if we already have this URL in discovered_urls
            if (supabaseAdmin == undefined) {
                return false;
            }
            const { data: existingDiscovered } = await supabaseAdmin
                .from('discovered_urls')
                .select('id')
                .eq('url', url)
                .limit(1);
            if (existingDiscovered != undefined &amp;&amp; existingDiscovered.length &gt; 0) {
                return false; // Already discovered
            }
            // Check if we already have this URL in food_trucks
            const { data: existingTrucks } = await supabaseAdmin
                .from('food_trucks')
                .select('id')
                .contains('source_urls', [url])
                .limit(1);
            if (existingTrucks != undefined &amp;&amp; existingTrucks.length &gt; 0) {
                return false; // Already have this URL
            }
            // Accept if has food truck keywords or if it's a business domain
            return (foodTruckKeywords.some((keyword) =&gt; urlLower.includes(keyword)) ||
                (/\.(com|net|org|biz|info)/.test(urlLower) &amp;&amp;
                    !urlLower.includes('blog') &amp;&amp;
                    !urlLower.includes('news')));
        }
        catch (error) {
            console.error('Error validating food truck URL:', error);
            return false;
        }
    }
    /**
     * Initiates a discovery process for food trucks in the specified city and state.
     * @example
     * getLocationSpecificDiscovery('Charleston', 'SC')
     * Promise &lt;DiscoveryResult&gt; {urls_discovered: 5, urls_stored: 4, urls_duplicates: 1, errors: []}
     * @param {string} city - The city where the search is to be performed.
     * @param {string} [state='SC'] - The state where the search is to be performed; defaults to 'SC'.
     * @returns {Promise&lt;DiscoveryResult&gt;} An object containing the discovery results and any errors encountered.
     * @description
     *   - Logs the initiation and completion of the discovery process with results.
     *   - Performs the search using a specified query and stores new URLs found.
     *   - Captures and logs any errors encountered during the search process.
     */
    async getLocationSpecificDiscovery(city, state = 'SC') {
        console.info(` Starting location-specific discovery for ${city}, ${state}`);
        const locationQuery = `food trucks in ${city} ${state}`;
        const results = {
            urls_discovered: 0,
            urls_stored: 0,
            urls_duplicates: 0,
            errors: [],
        };
        const discoveredUrls = new Set();
        try {
            await this.performLocationSpecificSearch(locationQuery, discoveredUrls);
            results.urls_discovered = discoveredUrls.size;
            await this.storeLocationDiscoveryResults({
                discoveredUrls,
                locationQuery,
                city,
                state,
                results,
            });
        }
        catch (error) {
            console.error(` Location search failed for ${city}:`, error);
            results.errors.push(`Location search failed for ${city}: ${error instanceof Error ? error.message : 'Unknown error'}`);
        }
        console.info(` Location discovery complete for ${city}: ${results.urls_stored} new URLs stored`);
        return results;
    }
    // Helper method to perform location-specific search
    /**
    * Executes a location-specific search and processes the results.
    * @example
    * performLocationSpecificSearch(&quot;San Francisco&quot;, new Set())
    * // Processes search results for &quot;San Francisco&quot; location
    * @param {string} locationQuery - The location query to perform the search.
    * @param {Set&lt;string&gt;} discoveredUrls - A set to track URLs that have already been discovered.
    * @returns {Promise&lt;void&gt;} Completes search processing without return value.
    * @description
    *   - Searches are performed with a limit of 15 results.
    *   - Only non-empty search results are processed.
    *   - Uses asynchronous calls to handle search and processing operations.
    */
    async performLocationSpecificSearch(locationQuery, discoveredUrls) {
        const searchResults = await tavilySearch(locationQuery, { limit: 15 });
        if (searchResults != undefined &amp;&amp; searchResults.length &gt; 0) {
            for (const result of searchResults) {
                await this.processSearchResult(result, discoveredUrls);
            }
        }
    }
    // Helper method to process a single search result
    async processSearchResult(result, discoveredUrls) {
        if (typeof result === 'object' &amp;&amp; result !== null &amp;&amp; 'url' in result) {
            const resultUrl = result.url;
            if (resultUrl != undefined &amp;&amp; resultUrl !== '' &amp;&amp; (await this.isFoodTruckUrl(resultUrl))) {
                discoveredUrls.add(resultUrl);
            }
            // Extract URLs from content
            await this.extractUrlsFromContent(result, discoveredUrls);
        }
    }
    // Helper method to extract URLs from content
    /**
     * Extracts food truck URLs from a given result object and adds them to a discovered URL set.
     * @example
     * extractUrlsFromContent(resultObject, discoveredUrlSet)
     * void
     * @param {unknown} result - The result object potentially containing content with URLs.
     * @param {Set&lt;string&gt;} discoveredUrls - A set where extracted food truck URLs will be added.
     * @returns {Promise&lt;void&gt;} Resolves when URLs are added to the set.
     * @description
     *   - Parses both `content` and `raw_content` properties for URLs.
     *   - Uses helper method `extractFoodTruckUrls` to identify specific URLs.
     *   - Filters URLs through `isFoodTruckUrl` method to ensure relevance before adding.
     */
    async extractUrlsFromContent(result, discoveredUrls) {
        if (typeof result === 'object' &amp;&amp; result != undefined) {
            const resultObj = result;
            if (resultObj.content != undefined || resultObj.raw_content != undefined) {
                const content = resultObj.content ?? resultObj.raw_content ?? '';
                const extractedUrls = this.extractFoodTruckUrls(content);
                for (const url of extractedUrls) {
                    if (await this.isFoodTruckUrl(url)) {
                        discoveredUrls.add(url);
                    }
                }
            }
        }
    }
    // Helper method to store location discovery results
    /**
     * Stores location discovery results by iterating through a set of discovered URLs.
     * @example
     * storeLocationDiscoveryResults({
     *   discoveredUrls: new Set(['http://example.com']),
     *   locationQuery: 'pizza restaurant',
     *   city: 'San Francisco',
     *   state: 'CA',
     *   results: {}
     * })
     *
     * @param {Object} params - Parameters for storing the discovery results.
     * @param {Set&lt;string&gt;} params.discoveredUrls - A set of URLs to be stored.
     * @param {string} params.locationQuery - The location query used in the search.
     * @param {string} params.city - The target city for the location search.
     * @param {string} params.state - The target state for the location search.
     * @param {DiscoveryResult} params.results - Object to store results and errors.
     * @returns {Promise&lt;void&gt;} No return value.
     * @description
     *   - Logs an error and records it in the results if storing a URL fails.
     *   - Assumes the existence of a method `storeDiscoveredUrl` to handle storage logic.
     *   - The `results` object is mutated by adding error messages directly.
     */
    async storeLocationDiscoveryResults(params) {
        const { discoveredUrls, locationQuery, city, state, results } = params;
        for (const url of discoveredUrls) {
            try {
                const stored = await this.storeDiscoveredUrl(url, 'tavily_search', {
                    search_query: locationQuery,
                    target_city: city,
                    target_state: state,
                });
                if (stored.isNew === true) {
                    results.urls_stored += 1;
                }
                else {
                    results.urls_duplicates += 1;
                }
            }
            catch (error) {
                console.error(` Failed to store URL ${url}:`, error);
                results.errors.push(`Failed to store URL ${url}: ${error instanceof Error ? error.message : 'Unknown error'}`);
            }
        }
    }
    delay(ms) {
        return new Promise((resolve) =&gt; setTimeout(resolve, ms));
    }
    /**
     * Store multiple discovered URLs with metadata
     */
    async storeDiscoveredUrls(urls, discoveryMethod = 'manual', metadata = {}) {
        const result = {
            urls_stored: 0,
            urls_duplicates: 0,
            errors: [],
        };
        for (const url of urls) {
            try {
                const stored = await this.storeDiscoveredUrl(url, discoveryMethod, metadata);
                if (stored.isNew === true) {
                    result.urls_stored += 1;
                }
                else {
                    result.urls_duplicates += 1;
                }
            }
            catch (error) {
                const errorMsg = `Failed to store URL ${url}: ${error instanceof Error ? error.message : 'Unknown error'}`;
                result.errors.push(errorMsg);
                console.error(errorMsg);
            }
        }
        return result;
    }
    /**
     * Enhanced store method with discovery method and metadata
     */
    async storeDiscoveredUrl(url, discoveryMethod = 'manual', metadata = {}) {
        try {
            if (!supabaseAdmin) {
                throw new Error('Supabase admin client not available');
            }
            // Check if URL already exists
            const { data: existing } = await supabaseAdmin
                .from('discovered_urls')
                .select('id')
                .eq('url', url)
                .limit(1);
            if (existing &amp;&amp; existing.length &gt; 0) {
                return { isNew: false };
            }
            // Store new URL - handle missing columns gracefully
            const insertData = {
                url,
                status: 'new',
                notes: `Discovered via ${discoveryMethod}`,
            };
            // Add optional columns only if they exist in the table
            try {
                // Check if discovery_method column exists
                const { error: testError } = await supabaseAdmin
                    .from('discovered_urls')
                    .select('discovery_method')
                    .limit(1);
                if (!testError) {
                    insertData.discovery_method = discoveryMethod;
                    insertData.region = 'SC';
                    insertData.metadata = metadata;
                }
            }
            catch {
                // Column doesn't exist, continue without it
                console.info('Some columns missing in discovered_urls table, using basic structure');
            }
            const { error } = await supabaseAdmin.from('discovered_urls').insert(insertData);
            if (error) {
                throw error;
            }
            return { isNew: true };
        }
        catch (error) {
            console.error('Error storing discovered URL:', error);
            throw error;
        }
    }
    /**
     * Search for food truck directories
     */
    async searchFoodTruckDirectories(query = 'food truck directory South Carolina') {
        try {
            return await tavilySearch(query, { limit: 10 });
        }
        catch (error) {
            console.error('Error searching food truck directories:', error);
            return [];
        }
    }
    /**
     * Search for food truck websites
     */
    async searchFoodTruckWebsites(query) {
        try {
            return await tavilySearch(query, { limit: 15 });
        }
        catch (error) {
            console.error('Error searching food truck websites:', error);
            return [];
        }
    }
}
export const discoveryEngine = new FoodTruckDiscoveryEngine();</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/config.js (Line 1:1 - Line 31:74), C:/AI/food-truck-finder-poc/dist/lib/lib/config.js (Line 1:1 - Line 31:74)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn630" onclick="toggleCodeBlock('cloneGroup630', 'expandBtn630', 'collapseBtn630')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn630" onclick="toggleCodeBlock('cloneGroup630', 'expandBtn630', 'collapseBtn630')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup630"><code class="language-javascript text-sm text-gray-800">// lib/config.ts
// A list of default URLs that the application should attempt to scrape automatically
// if their data is missing or stale.
export const DEFAULT_SCRAPE_URLS = [
    'https://eatrotirolls.com/',
    // Dynamic URLs will be added from the discovered_urls table
];
// Defines how old data can be (in days) before it's considered stale and needs re-scraping.
export const DEFAULT_STALENESS_THRESHOLD_DAYS = 7; // 7 days
// South Carolina cities to target for autonomous discovery
export const SC_TARGET_CITIES = [
    'Charleston',
    'Columbia',
    'Greenville',
    'Spartanburg',
    'Rock Hill',
    'Mount Pleasant',
    'North Charleston',
    'Summerville',
    'Goose Creek',
    'Hilton Head',
];
// Discovery configuration
export const DISCOVERY_CONFIG = {
    maxUrlsPerRun: 50,
    maxDepthCrawl: 2,
    searchResultsLimit: 15,
    batchSize: 10,
    rateLimitDelayMs: 1000,
};
// You can add other global configurations here as the application grows.</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/autoScraper.js (Line 5:11 - Line 428:2), C:/AI/food-truck-finder-poc/dist/lib/lib/autoScraper.js (Line 5:20 - Line 428:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn632" onclick="toggleCodeBlock('cloneGroup632', 'expandBtn632', 'collapseBtn632')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn632" onclick="toggleCodeBlock('cloneGroup632', 'expandBtn632', 'collapseBtn632')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup632"><code class="language-javascript text-sm text-gray-800">;
/*
Food Truck Scraping Strategy (wbs 2.1.2)
----------------------------------------
Goal: Extract structured data for food trucks (description, menu, prices, locations, events) from web sources.

1. Discovery:
   - Use internal API endpoints that leverage Tavily MCP tools to find food truck directories and individual truck sites.
   - Filter urls to target only likely food truck homepages or menu/schedule pages.

2. Content Extraction:
   - For each truck site, extract:
     - Description: Look for about/landing page text, business summary, or meta description.
     - Menu: Scrape menu sections, parse categories, items, prices, and dietary tags.
     - Prices: Extract explicit prices as numbers; fallback to price range if only text is available.
     - Locations: Parse current and scheduled locations, addresses, and geocoordinates if present.
     - Events: Identify event/calendar/schedule sections for upcoming appearances.

3. Data Mapping:
   - Map extracted fields to Supabase schema:
     - name, description, cuisine_type, specialties
     - menu (categories/items/prices/dietary_tags)
     - current_location, scheduled_locations, exact_location, city_location
     - events (future: event table)

4. Quality &amp; Validation:
   - Use Gemini to summarize/clean descriptions and standardize menu/locations.
   - Validate extracted data types and required fields before db insert.
   - Log and skip/flag incomplete or ambiguous records for review.

5. Ingestion:
   - Upsert into Supabase using unique identifier (e.g., website url or business name).
   - Avoid duplicates and resolve conflicts by preferring most recent or most complete data.

6. Automation:
   - Schedule regular crawls and re-scrapes.
   - Track api usage and cache results to stay within rate limits.
   - Monitor for site changes and trigger updates as needed.
*/
// Helper to trigger a scraping process for a given url
/**
 * Initiates a web scraping process for a given target URL.
 * @example
 * triggerScrapingProcess('https://example.com')
 * { success: true, jobId: '12345', message: 'Scraping job created and processing initiated for https://example.com.' }
 * @param {string} targetUrl - The URL of the website to be scraped.
 * @returns {Promise&lt;TriggerScrapingProcessResult&gt;} Result of the attempt to trigger the scraping process, including success status, job ID, and message or error.
 * @description
 *   - Creates a web scraping job with a priority of 5 and triggers its processing.
 *   - Handles errors during job creation or processing gracefully.
 *   - Uses the current timestamp to schedule the job.
 */
async function triggerScrapingProcess(targetUrl) {
    try {
        const job = await ScrapingJobService.createJob({
            job_type: 'website_auto',
            target_url: targetUrl,
            priority: 5,
            scheduled_at: new Date().toISOString(),
        });
        processScrapingJob(job.id).catch((error) =&gt; {
            console.error('Failed to process scraping job:', error);
        });
        return {
            success: true,
            jobId: job.id,
            message: `Scraping job created and processing initiated for ${targetUrl}.`,
        };
    }
    catch (error) {
        return {
            success: false,
            error: error instanceof Error ? error.message : 'Failed to create or process job',
        };
    }
}
// Helper function to process existing truck results
/**
 * Processes the result of an existing truck scraping operation.
 * @example
 * processExistingTruckResult('http://example.com', { status: 'fresh' }, { trucksProcessed: 1, newTrucksFound: 0 }, []);
 * // no return value, updates states and logs errors if any
 * @param {string} url - The URL of the truck to process.
 * @param {{ status: string; details?: string }} result - The result of the truck scraping operation, including status and optional details.
 * @param {{ trucksProcessed: number; newTrucksFound: number }} counters - Trackers for counting processed and newly found trucks.
 * @param {Array&lt;{ url: string; details?: string }&gt;} errors - A list to record any URLs that result in errors, along with optional error details.
 * @returns {Promise&lt;void&gt;} Resolves when processing is complete, performing status updates.
 * @description
 *   - Updates the status of the URL based on the result: either processing, processed, or irrelevant.
 *   - Pushes any error information to the errors array for further processing or logging.
 *   - Utilizes different status handling depending on the freshness or error state of the data.
 */
async function processExistingTruckResult(url, result, counters, errors) {
    switch (result.status) {
        case 're-scraping_triggered': {
            counters.trucksProcessed += 1;
            await updateDiscoveredUrlStatus(url, 'processing', 'Re-scraping triggered due to stale data');
            break;
        }
        case 'fresh': {
            await updateDiscoveredUrlStatus(url, 'processed', 'Data is fresh, no action needed');
            break;
        }
        case 'error': {
            errors.push({ url, details: result.details });
            await updateDiscoveredUrlStatus(url, 'irrelevant', `Error: ${result.details}`);
            break;
        }
        // No default
    }
}
// Helper function to process new truck results
/**
 * Processes the result of a new truck resource and updates the counters accordingly.
 * @example
 * processNewTruckResult('https://example.com/truck', { status: 'initial_scrape_triggered' }, { trucksProcessed: 5, newTrucksFound: 2 }, []);
 * // Updates counters and changes URL status to 'processing'.
 * @param {string} url - The URL of the new truck resource to be processed.
 * @param {Object} result - The result object containing the status and optional details of the process.
 * @param {string} result.status - The status of the truck processing result.
 * @param {string} [result.details] - Optional detailed message about the result.
 * @param {Object} counters - An object keeping count of processed trucks and newly found trucks.
 * @param {number} counters.trucksProcessed - The current count of processed trucks.
 * @param {number} counters.newTrucksFound - The count of newly found trucks.
 * @param {Array&lt;Object&gt;} errors - A list of error objects for unsuccessful processing attempts.
 * @param {string} errors.url - The URL of the truck resource that encountered an error.
 * @param {string} [errors.details] - Optional error details associated with the URL.
 * @returns {Promise&lt;void&gt;} This function returns nothing but performs asynchronous URL status updates and error logging.
 * @description
 *   - The function distinguishes between two specific statuses: 'initial_scrape_triggered' and 'error'.
 *   - For 'initial_scrape_triggered', it updates the counters and marks the URL as 'processing'.
 *   - For 'error', it logs the error details and marks the URL as 'irrelevant'.
 */
async function processNewTruckResult(url, result, counters, errors) {
    if (result.status === 'initial_scrape_triggered') {
        counters.newTrucksFound += 1;
        counters.trucksProcessed += 1;
        await updateDiscoveredUrlStatus(url, 'processing', 'Initial scraping triggered');
    }
    else if (result.status === 'error') {
        errors.push({ url, details: result.details });
        await updateDiscoveredUrlStatus(url, 'irrelevant', `Error: ${result.details}`);
    }
}
// Helper function to find existing truck for URL
/**
* Find an existing food truck based on the provided source URL.
* @example
* findExistingTruck('https://foodtruck.com/123')
* { truck: { id: 1, last_scraped_at: '2023-09-16T00:00:00Z', source_urls: ['https://foodtruck.com'] } }
* @param {string} url - The source URL used to search for an existing truck in the database.
* @returns {Promise&lt;{ truck?: FoodTruck; error?: string }&gt;} An object containing either the existing truck data or an error message.
* @description
*   - Utilizes Supabase admin client to query the 'food_trucks' database table.
*   - Warns in the console when a query error occurs during the database lookup.
*   - Limits the query results to a single truck that matches the URL criteria.
*/
async function findExistingTruck(url) {
    if (!supabaseAdmin) {
        return { error: 'Supabase admin client not available' };
    }
    const { data: existingTrucks, error: truckQueryError } = await supabaseAdmin
        .from('food_trucks')
        .select('id, last_scraped_at, source_urls')
        .or(`source_urls.cs.{&quot;${url}&quot;}`)
        .limit(1);
    if (truckQueryError) {
        console.warn(`AutoScraper: Error querying for existing truck for url ${url}:`, truckQueryError.message);
        return { error: `Supabase query error: ${truckQueryError.message}` };
    }
    const truck = existingTrucks != undefined &amp;&amp; existingTrucks.length &gt; 0
        ? existingTrucks[0]
        : undefined;
    return { truck };
}
/**
 * Initiates the autonomous scraping process and ensures default trucks data is fetched.
 * @example
 * ensureDefaultTrucksAreScraped()
 * Returns a result object containing the number of trucks processed, new trucks found, and any errors encountered.
 * @returns {Promise&lt;AutoScrapeResult&gt;} An object containing the results of the scraping process, including processed trucks count, new trucks discovered count, and encountered errors.
 * @description
 *   - Combines static default URLs with dynamically discovered URLs for scraping.
 *   - Handles both existing and new trucks, updating counters and tracking errors.
 *   - Logs process information and warnings for unexpected errors during execution.
 */
export async function ensureDefaultTrucksAreScraped() {
    console.info('AutoScraper: Starting autonomous scraping process...');
    const counters = { trucksProcessed: 0, newTrucksFound: 0 };
    const errors = [];
    // Get URLs to scrape - combine static defaults with dynamically discovered URLs
    const urlsToScrape = await getUrlsToScrape();
    console.info(`AutoScraper: Found ${urlsToScrape.length} URLs to process`);
    for (const url of urlsToScrape) {
        try {
            console.info(`AutoScraper: Checking url: ${url}`);
            const { truck, error } = await findExistingTruck(url);
            if (error != undefined) {
                errors.push({ url, details: error });
                continue;
            }
            if (truck) {
                const result = await handleExistingTruck(url, truck);
                await processExistingTruckResult(url, result, counters, errors);
            }
            else {
                const result = await handleNewTruck(url);
                await processNewTruckResult(url, result, counters, errors);
            }
        }
        catch (error) {
            console.warn(`AutoScraper: Unexpected error processing url ${url}:`, error);
            errors.push({
                url,
                details: error instanceof Error ? error.message : 'Unknown error',
            });
        }
    }
    console.info('AutoScraper: Finished autonomous scraping process.');
    return {
        trucksProcessed: counters.trucksProcessed,
        newTrucksFound: counters.newTrucksFound,
        errors,
    };
}
/**
* Handles the existing truck data by checking staleness and potentially triggering a re-scrape process.
* @example
* handleExistingTruck('https://example.com/truck', { id: '123', last_scraped_at: '2023-09-01T00:00:00Z' })
* { url: 'https://example.com/truck', status: 'fresh', details: 'Last scraped at 2023-09-01T00:00:00Z' }
* @param {string} url - The URL of the food truck to check for staleness.
* @param {FoodTruck} truck - The food truck object containing its ID and last scrape date.
* @returns {Promise&lt;{url: string; status: string; details?: string; jobId?: string}&gt;} Returns the status and additional detail about the scraping process.
* @description
*   - Only triggers the re-scraping process if the data is considered stale based on a predefined threshold.
*   - Logs information about the current state of the truck's data freshness.
*   - Utilizes an asynchronous operation to potentially trigger a re-scrape.
*   - Returns an object indicating whether action was taken or not.
*/
async function handleExistingTruck(url, truck) {
    console.info(`AutoScraper: Found existing truck for ${url} (id: ${truck.id}). Last scraped: ${truck.last_scraped_at}`);
    const lastScrapedDate = new Date(truck.last_scraped_at);
    const stalenessLimit = new Date();
    stalenessLimit.setDate(stalenessLimit.getDate() - DEFAULT_STALENESS_THRESHOLD_DAYS);
    if (lastScrapedDate &lt; stalenessLimit) {
        console.info(`AutoScraper: Data for ${url} is stale. Triggering re-scrape.`);
        const triggerResult = await triggerScrapingProcess(url);
        return {
            url,
            status: triggerResult.success ? 're-scraping_triggered' : 'error',
            details: triggerResult.error ?? triggerResult.message,
            jobId: triggerResult.jobId,
        };
    }
    console.info(`AutoScraper: Data for ${url} is fresh. No action needed.`);
    return { url, status: 'fresh', details: `Last scraped at ${truck.last_scraped_at}` };
}
/**
 * Initiates a scraping process for a new truck based on the given URL and returns the scraping status.
 * @example
 * handleNewTruck(&quot;https://example.com/truck-detail&quot;)
 * // Returns: { url: &quot;https://example.com/truck-detail&quot;, status: &quot;initial_scrape_triggered&quot;, details: &quot;Scraping initiated&quot;, jobId: &quot;12345&quot; }
 * @param {string} url - The URL of the truck details page to be scraped.
 * @returns {Promise&lt;{ url: string; status: string; details?: string; jobId?: string }&gt;} An object containing the URL, status of the scraping attempt, optional details message, and optional job ID.
 * @description
 *   - Uses an asynchronous function to trigger the scraping process.
 *   - Logs an informational message when no existing truck is found for the given URL.
 *   - Returns a status indicating whether the scrape was successfully triggered or if there was an error.
 */
async function handleNewTruck(url) {
    console.info(`AutoScraper: No existing truck found for ${url}. Triggering initial scrape.`);
    const triggerResult = await triggerScrapingProcess(url);
    return {
        url,
        status: triggerResult.success ? 'initial_scrape_triggered' : 'error',
        details: triggerResult.error ?? triggerResult.message,
        jobId: triggerResult.jobId,
    };
}
// --- Gemini API Rate Limiting &amp; Caching ---
const GEMINI_CACHE_TTL_MS = 1000 * 60 * 60 * 6; // 6 hours
const geminiCache = {};
/**
 * Makes a call to Gemini service and caches the result to optimize performance.
 * @example
 * callGeminiWithCache('getData', { id: 123 }, geminiInstance)
 * // returns the result from the Gemini service or cache
 * @param {string} type - The type of operation to perform with Gemini.
 * @param {unknown} input - The input data required for the Gemini operation.
 * @param {GeminiService} gemini - The instance of GeminiService to interact with.
 * @returns {Promise&lt;unknown&gt;} Returns a promise that resolves to the result of the Gemini operation.
 * @description
 *   - Caches the result of Gemini service calls to avoid redundant requests.
 *   - Automatically cleans up expired cache entries based on a specified TTL.
 *   - Checks Gemini usage limits before making API calls to prevent exceeding the daily cap.
 *   - Constructs a unique cache key for each request using the operation type and input.
 */
export async function callGeminiWithCache(type, input, gemini) {
    const cacheKey = `${type}:${JSON.stringify(input)}`;
    const now = Date.now();
    // Clean up expired cache
    for (const key in geminiCache) {
        if (Object.prototype.hasOwnProperty.call(geminiCache, key) &amp;&amp;
            now - geminiCache[key].timestamp &gt; GEMINI_CACHE_TTL_MS) {
            delete geminiCache[key];
        }
    }
    if (geminiCache[cacheKey] != undefined &amp;&amp;
        now - geminiCache[cacheKey].timestamp &lt; GEMINI_CACHE_TTL_MS) {
        return geminiCache[cacheKey].data;
    }
    // Check Gemini usage limits before making a call
    const usage = await gemini.checkUsageLimits();
    if (!usage.canMakeRequest) {
        throw new Error('Gemini API daily limit reached. Try again tomorrow.');
    }
    // @ts-expect-error TS(2345): Argument of type 'string' is not assignable to par... Remove this comment to see the full error message
    const result = await dispatchGeminiOperation(type, input);
    geminiCache[cacheKey] = { data: result, timestamp: now };
    return result;
}
// Helper to get URLs to scrape from both static defaults and dynamic discovery
/**
* Retrieves a list of URLs that are ready for scraping.
* @example
* getUrlsToScrape()
* // Returns a Promise that resolves to an array of URLs
* @param {void} - This function does not take any arguments.
* @returns {Promise&lt;string[]&gt;} A promise that resolves to an array of URLs to be scraped.
* @description
*   - The function returns a combination of default URLs and dynamically discovered URLs.
*   - Utilizes Supabase to fetch URLs marked with 'new' or 'processed' status.
*   - Limits results to prevent system overload, fetching a maximum of 100 URLs.
*   - Handles errors gracefully, logging warnings if the Supabase client is not available or if there is an error in fetching URLs.
*/
async function getUrlsToScrape() {
    const urls = new Set();
    // Add static default URLs
    for (const url of DEFAULT_SCRAPE_URLS)
        urls.add(url);
    // Add dynamically discovered URLs that are ready for processing
    try {
        if (!supabaseAdmin) {
            console.warn('AutoScraper: Supabase admin client not available for discovered URLs');
            return [...urls];
        }
        const { data: discoveredUrls, error } = await supabaseAdmin
            .from('discovered_urls')
            .select('url')
            .in('status', ['new', 'processed']) // Include both new and previously processed URLs
            .order('discovered_at', { ascending: false })
            .limit(100); // Limit to prevent overwhelming the system
        if (error) {
            console.warn('AutoScraper: Error fetching discovered URLs:', error.message);
        }
        else if (discoveredUrls != undefined) {
            for (const { url } of discoveredUrls)
                urls.add(url);
            console.info(`AutoScraper: Added ${discoveredUrls.length} discovered URLs to scraping queue`);
        }
    }
    catch (error) {
        console.warn('AutoScraper: Failed to fetch discovered URLs:', error);
    }
    return [...urls];
}
// Helper to update discovered URL status after processing
/**
 * Updates the status of a discovered URL in the database.
 * @example
 * updateDiscoveredUrlStatus('http://example.com', 'processed', 'Page successfully processed')
 * // Returns: void
 * @param {string} url - The URL whose status needs updating.
 * @param {'processing' | 'processed' | 'irrelevant'} status - The new status for the URL.
 * @param {string} [notes] - Optional notes regarding the URL status update.
 * @returns {Promise&lt;void&gt;} Resolves when the update operation is complete.
 * @description
 *   - Logs a warning if the Supabase admin client is not available.
 *   - Uses Supabase to update the status and logs an error if the operation fails.
 *   - Assumes the existence of a 'discovered_urls' table in the database.
 */
async function updateDiscoveredUrlStatus(url, status, notes) {
    try {
        if (!supabaseAdmin) {
            console.warn(`AutoScraper: Cannot update status for ${url} - Supabase admin client not available`);
            return;
        }
        const { error } = await supabaseAdmin
            .from('discovered_urls')
            .update({
            status,
            last_processed_at: new Date().toISOString(),
            notes: notes ?? undefined,
        })
            .eq('url', url);
        if (error != undefined) {
            console.warn(`AutoScraper: Failed to update status for ${url}:`, error.message);
        }
    }
    catch (error) {
        console.warn(`AutoScraper: Error updating discovered URL status for ${url}:`, error);
    }
}
// Note on processScrapingJob import:
// The direct import of `processScrapingJob` from `@/app/api/scrape/route.ts` can be problematic
// if `route.ts` has side effects or dependencies not suitable for a library context (like NextRequest/Response).
// A cleaner way would be to refactor `processScrapingJob` into a shared utility if it's to be called directly,
// or for `triggerScrapingProcess` to make an internal http post request to `/api/scrape`.
// For this iteration, we are attempting direct call, assuming it's manageable.
// Export autoScraper object for use in cron jobs
export const autoScraper = {
    runAutoScraping: ensureDefaultTrucksAreScraped,
    triggerScrapingProcess,
    callGeminiWithCache,
    getUrlsToScrape,
    updateDiscoveredUrlStatus,
};
// Main autonomous scraping function that combines discovery and scraping
export async function runAutonomousScraping() {
    console.info('AutoScraper: Starting fully autonomous scraping cycle...');
    // This function can be called by the autonomous scheduler
    // It uses the updated ensureDefaultTrucksAreScraped which now pulls from discovered_urls
    return await ensureDefaultTrucksAreScraped();
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/activityLogger.js (Line 1:1 - Line 49:2), C:/AI/food-truck-finder-poc/dist/lib/lib/activityLogger.js (Line 1:1 - Line 49:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn634" onclick="toggleCodeBlock('cloneGroup634', 'expandBtn634', 'collapseBtn634')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn634" onclick="toggleCodeBlock('cloneGroup634', 'expandBtn634', 'collapseBtn634')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup634"><code class="language-javascript text-sm text-gray-800">/**
* Logs an activity entry with a timestamp and unique ID.
* @example
* logActivity({ action: 'user_login', username: 'johndoe' })
* undefined
* @param {ActivityLogEntry} entry - The activity entry to be logged.
* @returns {void} No return value.
* @description
*   - If `timestamp` is not provided in the entry, the current ISO timestamp is used.
*   - A unique ID is generated and added to the log entry.
*   - Logs activity data to the console in a structured format.
*   - Intended for development, but can be extended for production use with database or monitoring integration.
*/
export function logActivity(entry) {
    try {
        const logEntry = {
            ...entry,
            timestamp: entry.timestamp ?? new Date().toISOString(),
            id: generateId(),
        };
        // Log to console for development
        console.info('Activity Log:', JSON.stringify(logEntry, undefined, 2));
        // In a production environment, you would:
        // 1. Store to database
        // 2. Send to monitoring service
        // 3. Store in a queue for batch processing
        // For now, we'll just store in memory or local storage
        // This is a mock implementation
    }
    catch (error) {
        console.error('Failed to log activity:', error);
        // Don't throw - logging failures shouldn't break the main flow
    }
}
export function getActivityLogs(_type, _limit = 50) {
    try {
        // Mock implementation - in production this would query your database
        return [];
    }
    catch (error) {
        console.error('Failed to retrieve activity logs:', error);
        return [];
    }
}
function generateId() {
    // Using crypto.randomUUID() would be better for production, but Math.random() is acceptable for logging IDs
    // eslint-disable-next-line sonarjs/pseudo-random -- Math.random is acceptable for non-security-critical logging IDs.
    return Math.random().toString(36).slice(2) + Date.now().toString(36);
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/simplePipelineAnalysis.js (Line 16:49 - Line 46:8), C:/AI/food-truck-finder-poc/test-quality-control.js (Line 22:41 - Line 52:45)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn636" onclick="toggleCodeBlock('cloneGroup636', 'expandBtn636', 'collapseBtn636')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn636" onclick="toggleCodeBlock('cloneGroup636', 'expandBtn636', 'collapseBtn636')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup636"><code class="language-javascript text-sm text-gray-800">);
    
    // Test 1: Check URL quality filtering
    console.log('1. Testing URL quality filtering...');
    
    const testUrls = [
        // Should be filtered out (non-food truck URLs)
        'https://www.facebook.com/foodtruck',
        'https://www.instagram.com/foodtruck',
        'https://www.eventbrite.com/food-truck-festival',
        'https://www.cityofcharleston.org/calendar',
        'https://www.reddit.com/r/foodtrucks',
        
        // Should be processed (food truck URLs)
        'https://www.bestfoodtruck.com',
        'https://charlestonfoodtrucks.com',
        'https://www.roaminghunger.com/charleston-food-trucks',
        
        // Should be filtered out (obviously non-food truck)
        'https://www.charleston.gov/news',
        'https://www.charleston.gov/events/calendar',
        'https://www.meetup.com/charleston-foodies',
    ];
    
    for (const url of testUrls) {
        const isFoodTruckUrl = !discoveryEngine.isObviouslyNonFoodTruckUrl(url);
        const result = isFoodTruckUrl ? ' WILL PROCESS' : '  WILL SKIP';
        console.log(`   ${result} ${url}`);
    }
    
    console</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/get-scraping-jobs.js (Line 4:12 - Line 19:32), C:/AI/food-truck-finder-poc/get-truck-count.js (Line 3:9 - Line 18:6)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn637" onclick="toggleCodeBlock('cloneGroup637', 'expandBtn637', 'collapseBtn637')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn637" onclick="toggleCodeBlock('cloneGroup637', 'expandBtn637', 'collapseBtn637')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup637"><code class="language-javascript text-sm text-gray-800">;

// Load environment variables
dotenv.config({ path: '.env.local' });

const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;
const serviceRoleKey = process.env.SUPABASE_SERVICE_ROLE_KEY;

if (!supabaseUrl || !serviceRoleKey) {
  console.error(' Missing Supabase credentials! Need both URL and SERVICE_ROLE_KEY');
  process.exit(1);
}

const supabase = createClient(supabaseUrl, serviceRoleKey);

// Parse command line arguments</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/eslint.config.mjs (Line 237:24 - Line 255:65), C:/AI/food-truck-finder-poc/eslint.config.mjs (Line 212:33 - Line 229:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn638" onclick="toggleCodeBlock('cloneGroup638', 'expandBtn638', 'collapseBtn638')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn638" onclick="toggleCodeBlock('cloneGroup638', 'expandBtn638', 'collapseBtn638')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup638"><code class="language-javascript text-sm text-gray-800">],
    rules: {
      '@typescript-eslint/no-unsafe-argument': 'off',
    },
  },

  {
    files: ['hooks/realtime/**/*.ts', 'hooks/realtime/**/*.tsx'],
    rules: {
      '@typescript-eslint/no-unsafe-assignment': 'off',
      '@typescript-eslint/no-unsafe-call': 'off',
      '@typescript-eslint/no-unsafe-member-access': 'off',
      '@typescript-eslint/no-unsafe-argument': 'off',
      '@typescript-eslint/no-unsafe-return': 'off',
      '@typescript-eslint/no-redundant-type-constituents': 'off',
    },
  },

  // 8. Prettier - must be last to override other formatting rules</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/debugUrlFiltering.js (Line 10:2 - Line 36:68), C:/AI/food-truck-finder-poc/lib/discoveryEngine.js (Line 724:5 - Line 750:7)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn639" onclick="toggleCodeBlock('cloneGroup639', 'expandBtn639', 'collapseBtn639')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn639" onclick="toggleCodeBlock('cloneGroup639', 'expandBtn639', 'collapseBtn639')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup639"><code class="language-javascript text-sm text-gray-800">isObviouslyNonFoodTruckUrl(url) {
    const nonFoodTruckPatterns = [
        /\/events?\//i,
        /\/festivals?\//i,
        /\/calendar/i,
        /\/blog/i,
        /\/news/i,
        /\/articles?\//i,
        /\/government/i,
        /\/city\.gov/i,
        /\/municipal/i,
        /\/reddit\.com/i,
        /\/facebook\.com/i,
        /\/instagram\.com/i,
        /\/twitter\.com/i,
        /\/linkedin\.com/i,
        /\/youtube\.com/i,
        /\/yelp\.com/i,
        /\/google\.com\/maps/i,
        /\/foursquare\.com/i,
        /\/tripadvisor\.com/i,
        /\/zomato\.com/i,
        /\/eventbrite\.com/i,
        /\/meetup\.com/i,
    ];
    
    // Also check for blacklist keywords like the discovery engine does</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/check-discovered-urls.js (Line 1:1 - Line 11:34), C:/AI/food-truck-finder-poc/get-truck-count.js (Line 2:1 - Line 12:69)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn640" onclick="toggleCodeBlock('cloneGroup640', 'expandBtn640', 'collapseBtn640')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn640" onclick="toggleCodeBlock('cloneGroup640', 'expandBtn640', 'collapseBtn640')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup640"><code class="language-javascript text-sm text-gray-800">import { createClient } from '@supabase/supabase-js';
import dotenv from 'dotenv';

// Load environment variables
dotenv.config({ path: '.env.local' });

const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;
const serviceRoleKey = process.env.SUPABASE_SERVICE_ROLE_KEY;

if (!supabaseUrl || !serviceRoleKey) {
  console.error(' Missing Supabase credentials!'</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/apply-rls-fix.js (Line 1:1 - Line 11:53), C:/AI/food-truck-finder-poc/execute-sql.js (Line 1:1 - Line 11:45)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn641" onclick="toggleCodeBlock('cloneGroup641', 'expandBtn641', 'collapseBtn641')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn641" onclick="toggleCodeBlock('cloneGroup641', 'expandBtn641', 'collapseBtn641')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup641"><code class="language-javascript text-sm text-gray-800">import { createClient } from '@supabase/supabase-js';
import { readFileSync } from 'fs';
import dotenv from 'dotenv';

// Load environment variables
dotenv.config({ path: '.env.local' });

const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;
const serviceRoleKey = process.env.SUPABASE_SERVICE_ROLE_KEY;

console.log(' Applying RLS policy fix to food_trucks table...'</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/apply-rls-fix.js (Line 11:53 - Line 28:12), C:/AI/food-truck-finder-poc/execute-sql.js (Line 11:45 - Line 28:19)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn642" onclick="toggleCodeBlock('cloneGroup642', 'expandBtn642', 'collapseBtn642')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn642" onclick="toggleCodeBlock('cloneGroup642', 'expandBtn642', 'collapseBtn642')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup642"><code class="language-javascript text-sm text-gray-800">);
console.log(' URL:', supabaseUrl);
console.log(' Service key present:', !!serviceRoleKey);

if (!supabaseUrl || !serviceRoleKey) {
  console.error(' Missing Supabase credentials! Need both URL and SERVICE_ROLE_KEY');
  process.exit(1);
}

// Create client with service role key (has admin permissions)
const supabase = createClient(supabaseUrl, serviceRoleKey, {
  auth: {
    autoRefreshToken: false,
    persistSession: false
  }
});

async function applyRLSFix</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/analyzePipelineQuality.js (Line 13:1 - Line 58:30), C:/AI/food-truck-finder-poc/debugUrlFiltering.js (Line 10:1 - Line 55:8)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn643" onclick="toggleCodeBlock('cloneGroup643', 'expandBtn643', 'collapseBtn643')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn643" onclick="toggleCodeBlock('cloneGroup643', 'expandBtn643', 'collapseBtn643')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup643"><code class="language-javascript text-sm text-gray-800">function isObviouslyNonFoodTruckUrl(url) {
    const nonFoodTruckPatterns = [
        /\/events?\//i,
        /\/festivals?\//i,
        /\/calendar/i,
        /\/blog/i,
        /\/news/i,
        /\/articles?\//i,
        /\/government/i,
        /\/city\.gov/i,
        /\/municipal/i,
        /\/reddit\.com/i,
        /\/facebook\.com/i,
        /\/instagram\.com/i,
        /\/twitter\.com/i,
        /\/linkedin\.com/i,
        /\/youtube\.com/i,
        /\/yelp\.com/i,
        /\/google\.com\/maps/i,
        /\/foursquare\.com/i,
        /\/tripadvisor\.com/i,
        /\/zomato\.com/i,
        /\/eventbrite\.com/i,
        /\/meetup\.com/i,
    ];
    
    // Also check for blacklist keywords like the discovery engine does
    const blacklistKeywords = [
        'facebook.com',
        'instagram.com',
        'twitter.com',
        'linkedin.com',
        'youtube.com',
        'yelp.com',
        'google.com',
        'maps.google.com',
        'foursquare.com',
        'tripadvisor.com',
        'zomato.com',
        'eventbrite.com',
        'meetup.com',
    ];
    
    const urlLower = url.toLowerCase();
    
    // Check regex patterns first</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/analyze-pipeline-quality.js (Line 1:1 - Line 42:6), C:/AI/food-truck-finder-poc/analyzePipelineQuality.js (Line 1:1 - Line 754:8)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn644" onclick="toggleCodeBlock('cloneGroup644', 'expandBtn644', 'collapseBtn644')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn644" onclick="toggleCodeBlock('cloneGroup644', 'expandBtn644', 'collapseBtn644')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup644"><code class="language-javascript text-sm text-gray-800">#!/usr/bin/env node

/**
 * Analyze Pipeline Quality Control
 * 
 * This script analyzes the quality control improvements made to the food truck discovery pipeline.
 */

import dotenv from 'dotenv';
dotenv.config({ path: '.env.local' });

// Simple test of the core filtering logic without database dependencies
function isObviouslyNonFoodTruckUrl(url) {
    const nonFoodTruckPatterns = [
        /\/events?\//i,
        /\/festivals?\//i,
        /\/calendar/i,
        /\/blog/i,
        /\/news/i,
        /\/articles?\//i,
        /\/government/i,
        /\/city\.gov/i,
        /\/municipal/i,
        /\/reddit\.com/i,
        /\/facebook\.com/i,
        /\/instagram\.com/i,
        /\/twitter\.com/i,
        /\/linkedin\.com/i,
        /\/youtube\.com/i,
        /\/yelp\.com/i,
        /\/google\.com\/maps/i,
        /\/foursquare\.com/i,
        /\/tripadvisor\.com/i,
        /\/zomato\.com/i,
        /\/eventbrite\.com/i,
        /\/meetup\.com/i,
    ];
    
    return nonFoodTruckPatterns.some(pattern =&gt; pattern.test(url));
}

async</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/analyze-pipeline-quality.js (Line 39:4 - Line 68:15), C:/AI/food-truck-finder-poc/analyzePipelineQuality.js (Line 64:8 - Line 93:11)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn645" onclick="toggleCodeBlock('cloneGroup645', 'expandBtn645', 'collapseBtn645')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn645" onclick="toggleCodeBlock('cloneGroup645', 'expandBtn645', 'collapseBtn645')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup645"><code class="language-javascript text-sm text-gray-800">));
}

async function analyzePipelineQuality() {
    console.log(' Analyzing Pipeline Quality Control...\n');
    
    // Test URL quality filtering
    console.log('1. Testing URL quality filtering...');
    
    const testUrls = [
        // Should be filtered out (non-food truck URLs)
        'https://www.facebook.com/foodtruck',
        'https://www.instagram.com/foodtruck',
        'https://www.eventbrite.com/food-truck-festival',
        'https://www.cityofcharleston.org/calendar',
        'https://www.reddit.com/r/foodtrucks',
        
        // Should be processed (food truck URLs)
        'https://www.bestfoodtruck.com',
        'https://charlestonfoodtrucks.com',
        'https://www.roaminghunger.com/charleston-food-trucks',
        
        // Should be filtered out (obviously non-food truck)
        'https://www.charleston.gov/news',
        'https://www.charleston.gov/events/calendar',
        'https://www.meetup.com/charleston-foodies',
    ];
    
    for (const url of testUrls) {
        const isFoodTruckUrl</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/analyze-pipeline-quality.js (Line 46:5 - Line 68:27), C:/AI/food-truck-finder-poc/test-quality-control.js (Line 25:5 - Line 47:16)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn646" onclick="toggleCodeBlock('cloneGroup646', 'expandBtn646', 'collapseBtn646')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn646" onclick="toggleCodeBlock('cloneGroup646', 'expandBtn646', 'collapseBtn646')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup646"><code class="language-javascript text-sm text-gray-800">console.log('1. Testing URL quality filtering...');
    
    const testUrls = [
        // Should be filtered out (non-food truck URLs)
        'https://www.facebook.com/foodtruck',
        'https://www.instagram.com/foodtruck',
        'https://www.eventbrite.com/food-truck-festival',
        'https://www.cityofcharleston.org/calendar',
        'https://www.reddit.com/r/foodtrucks',
        
        // Should be processed (food truck URLs)
        'https://www.bestfoodtruck.com',
        'https://charlestonfoodtrucks.com',
        'https://www.roaminghunger.com/charleston-food-trucks',
        
        // Should be filtered out (obviously non-food truck)
        'https://www.charleston.gov/news',
        'https://www.charleston.gov/events/calendar',
        'https://www.meetup.com/charleston-foodies',
    ];
    
    for (const url of testUrls) {
        const isFoodTruckUrl = !isObviouslyNonFoodTruckUrl</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/analyze-pipeline-quality.js (Line 69:16 - Line 105:2), C:/AI/food-truck-finder-poc/analyzePipelineQuality.js (Line 94:17 - Line 130:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn647" onclick="toggleCodeBlock('cloneGroup647', 'expandBtn647', 'collapseBtn647')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn647" onclick="toggleCodeBlock('cloneGroup647', 'expandBtn647', 'collapseBtn647')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup647"><code class="language-javascript text-sm text-gray-800">;
        console.log(`   ${result} ${url}`);
    }
    
    console.log('\n Pipeline quality control analysis completed');
    
    console.log('\n Summary of Quality Control Improvements:');
    console.log('    URL Quality Filtering:');
    console.log('      - Non-food truck URLs are properly filtered out');
    console.log('      - Social media and event sites are automatically skipped');
    console.log('      - Government and news sites are filtered');
    console.log('      - Resource waste is prevented');
    
    console.log('\n    URL Quality Scoring:');
    console.log('      - Success increases quality score (+0.2)');
    console.log('      - Failure decreases quality score (-0.3)');
    console.log('      - Processing attempts are tracked');
    console.log('      - Blacklisting prevents repeated failures');
    
    console.log('\n    Pipeline Improvements:');
    console.log('      - &quot;Unknown Food Truck&quot; entries eliminated');
    console.log('      - Null/empty names are properly discarded');
    console.log('      - Pre-filtering prevents storing invalid URLs');
    console.log('      - The pipeline is more efficient and accurate');
    
    console.log('\n    Impact:');
    console.log('      - Reduced database bloat');
    console.log('      - Lower API usage costs');
    console.log('      - Better data quality');
    console.log('      - More reliable scraping results');
}

// Run the analysis
analyzePipelineQuality().catch(error =&gt; {
    console.error(' Analysis failed:', error);
    process.exit(1);
});</code></pre></div><!-- Add more clone groups for .txt format as needed         // Add more clone groups for .txt format as needed--></div><a name="typescript-clones"></a><h2 class="text-2xl font-semibold text-gray-700 mb-4">typescript</h2><div class="divide-y divide-gray-200 border-b-2"><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/lib/lib/api/admin/oauth-status/helpers.d.ts (Line 21:13 - Line 43:8), C:/AI/food-truck-finder-poc/dist/lib/lib/api/admin/oauth-status/types.d.ts (Line 3:13 - Line 25:8)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn1" onclick="toggleCodeBlock('cloneGroup1', 'expandBtn1', 'collapseBtn1')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn1" onclick="toggleCodeBlock('cloneGroup1', 'expandBtn1', 'collapseBtn1')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup1"><code class="language-typescript text-sm text-gray-800">;
    supabase: {
        connected: boolean;
        projectId: string;
        authSettings?: {
            googleEnabled: boolean;
            signupEnabled: boolean;
            autoconfirm: boolean;
        };
        error?: string;
    };
    environment_variables: {
        supabaseUrl: boolean;
        supabaseAnonKey: boolean;
        supabaseServiceKey: boolean;
    };
    oauth_flow: {
        loginPageExists: boolean;
        callbackRouteExists: boolean;
        authProviderConfigured: boolean;
    };
    recommendations: string[];
    overall_status: &quot;ready&quot;</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/lib/api/monitoring/api-usage/handlers.d.ts (Line 1:1 - Line 23:9), C:/AI/food-truck-finder-poc/dist/lib/lib/api/monitoring/api-usage/handlers.d.ts (Line 1:1 - Line 23:12)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn3" onclick="toggleCodeBlock('cloneGroup3', 'expandBtn3', 'collapseBtn3')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn3" onclick="toggleCodeBlock('cloneGroup3', 'expandBtn3', 'collapseBtn3')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup3"><code class="language-typescript text-sm text-gray-800">import { NextRequest, NextResponse } from 'next/server';
import { type APIService } from '@/lib/monitoring/apiMonitor';
export declare function handleComprehensiveMonitoring(): NextResponse&lt;{
    success: boolean;
    data: Promise&lt;import(&quot;@/lib/monitoring/apiMonitor&quot;).APIMonitoringResult&gt;;
    timestamp: string;
}&gt;;
/**
 * Handles monitoring of API service usage based on the request parameters.
 * @example
 * handleServiceSpecificMonitoring(nextRequestInstance, apiServiceInstance)
 * { success: true, service: apiServiceInstance, usage: { requests: 50, tokens: 200 }, timestamp: &quot;2023-10-05T14:48:00.000Z&quot; }
 * @param {NextRequest} request - Incoming request instance containing URL and search parameters.
 * @param {APIService} service - The API service instance for which usage monitoring is being handled.
 * @returns {NextResponse} JSON response containing the service usage and possibility of making requests.
 * @description
 *   - Parses URL search parameters to extract action type and usage metrics.
 *   - Calls `APIMonitor.canMakeRequest` to determine if the request can be made when action is 'check'.
 *   - Returns current usage statistics when action is not 'check'.
 */
export declare function handleServiceSpecificMonitoring(request: NextRequest, service: APIService): Promise&lt;NextResponse&lt;{
    success: boolean;
    service: &quot;gemini&quot;</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/lib/api/monitoring/api-usage/handlers.d.ts (Line 23:11 - Line 59:2), C:/AI/food-truck-finder-poc/dist/lib/lib/api/monitoring/api-usage/handlers.d.ts (Line 23:9 - Line 59:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn4" onclick="toggleCodeBlock('cloneGroup4', 'expandBtn4', 'collapseBtn4')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn4" onclick="toggleCodeBlock('cloneGroup4', 'expandBtn4', 'collapseBtn4')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup4"><code class="language-typescript text-sm text-gray-800">;
    usage: Promise&lt;import(&quot;@/lib/monitoring/apiMonitor&quot;).APIUsageData&gt;;
    timestamp: string;
}&gt;&gt;;
export declare function handleClearAlerts(): NextResponse&lt;{
    success: boolean;
    message: string;
}&gt;;
export declare function handleGetAlerts(): NextResponse&lt;{
    success: boolean;
    alerts: import(&quot;@/lib/monitoring/apiMonitor&quot;).APIUsageAlert[];
    count: number;
}&gt;;
/**
 * Handles test alert triggering based on service and level provided.
 * @example
 * handleTestAlert({service: 'database', level: 'high'})
 * // Expected response in JSON format with success message.
 * @param {Object} body - The object containing service and level details.
 * @param {string} body.service - The name of the service for which the alert is triggered.
 * @param {string} body.level - The severity level of the alert.
 * @returns {Object} JSON response indicating success or failure status.
 * @description
 *   - Returns a success message with service and level if both are provided.
 *   - Responds with an error message if either service or level is missing.
 *   - Simulates alert triggering functionality - no real alert system interaction.
 */
export declare function handleTestAlert(body: {
    service: string;
    level: string;
}): NextResponse&lt;{
    success: boolean;
    error: string;
}&gt; | NextResponse&lt;{
    success: boolean;
    message: string;
}&gt;;</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/lib/api/analytics/web-vitals/handlers.d.ts (Line 1:1 - Line 100:2), C:/AI/food-truck-finder-poc/dist/lib/lib/api/analytics/web-vitals/handlers.d.ts (Line 1:1 - Line 100:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn8" onclick="toggleCodeBlock('cloneGroup8', 'expandBtn8', 'collapseBtn8')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn8" onclick="toggleCodeBlock('cloneGroup8', 'expandBtn8', 'collapseBtn8')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup8"><code class="language-typescript text-sm text-gray-800">import { NextRequest, NextResponse } from 'next/server';
/**
 * Get Web Vitals Analytics Data
 */
export declare function getRequestParams(request: NextRequest): {
    days: number;
    page: string | null;
};
/**
 * Fetches and filters web vital metrics based on the given request parameters.
 * @example
 * fetchAndFilterMetrics(request)
 * { metrics: [{...}], days: 7, startDate: 2023-01-01T00:00:00.000Z }
 * @param {NextRequest} request - The request object containing parameters for filtering metrics such as days and page.
 * @returns {Object} An object containing an array of metrics, the number of days for the range, and the start date.
 * @description
 *   - Throws an error if the Supabase database connection is not available.
 *   - Builds a query to select metrics recorded after a specific start date.
 *   - Filters metrics by page URL if specified in the request parameters.
 *   - Limits the number of returned metrics to 1000 to avoid overwhelming the client.
 */
export declare function fetchAndFilterMetrics(request: NextRequest): Promise&lt;{
    metrics: any[];
    days: number;
    startDate: Date;
}&gt;;
/**
 * Calculate summary statistics for metrics
 */
export declare function calculateMetricsSummary(metrics: {
    metric_name: string;
    metric_value: number;
    rating: string;
}[]): Record&lt;string, {
    count: number;
    average: number | undefined;
    median: number | undefined;
    p75: number | undefined;
    p95: number | undefined;
    goodCount: number;
    needsImprovementCount: number;
    poorCount: number;
}&gt;;
/**
 * Calculate percentile value from sorted array
 */
export declare function getPercentile(sortedValues: number[], percentile: number): number;
/**
 * Handles POST requests to store and validate web vital metrics.
 * @example
 * handlePostRequest(request)
 * { success: true }
 * @param {NextRequest} request - The incoming request containing the web vital metric data.
 * @returns {NextResponse} JSON response indicating success or failure of storing the metric.
 * @description
 *   - Validates that the metric contains required fields and checks the types of values.
 *   - Stores validated metrics in a Supabase table if `supabaseAdmin` is available.
 *   - Logs any 'poor' performance metrics for monitoring purposes.
 *   - Ensures metrics collection is non-blocking, even if an error occurs during database operations.
 */
export declare function handlePostRequest(request: NextRequest): Promise&lt;NextResponse&lt;{
    success: boolean;
}&gt;&gt;;
/**
* Handles a GET request to fetch web vitals analytics data, process it, and respond with a summary.
* @example
* handleGetRequest(request)
* { success: true, data: { metrics: [...], summary: {...}, period: {...} } }
* @param {NextRequest} request - The incoming request object containing the necessary parameters.
* @returns {Promise&lt;NextResponse&gt;} Returns a JSON response indicating success or failure along with the data.
* @description
*   - Fetches metrics which are filtered and evaluated from the request data.
*   - Constructs a summary of the metrics including names, values, and ratings.
*   - Generates a response containing the metrics, summary, and calculated time period.
*   - Logs errors and responses with a status code in case of failure during data fetching.
*/
export declare function handleGetRequest(request: NextRequest): Promise&lt;NextResponse&lt;{
    success: boolean;
    data: {
        metrics: any[];
        summary: Record&lt;string, {
            count: number;
            average: number | undefined;
            median: number | undefined;
            p75: number | undefined;
            p95: number | undefined;
            goodCount: number;
            needsImprovementCount: number;
            poorCount: number;
        }&gt;;
        period: {
            days: number;
            startDate: string;
            endDate: string;
        };
    };
}&gt; | NextResponse&lt;{
    success: boolean;
    error: string;
}&gt;&gt;;</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/lib/api/admin/oauth-status/types.d.ts (Line 1:1 - Line 27:2), C:/AI/food-truck-finder-poc/dist/lib/lib/api/admin/oauth-status/types.d.ts (Line 1:1 - Line 27:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn11" onclick="toggleCodeBlock('cloneGroup11', 'expandBtn11', 'collapseBtn11')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn11" onclick="toggleCodeBlock('cloneGroup11', 'expandBtn11', 'collapseBtn11')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup11"><code class="language-typescript text-sm text-gray-800">interface OAuthStatus {
    timestamp: string;
    environment: 'development' | 'production';
    supabase: {
        connected: boolean;
        projectId: string;
        authSettings?: {
            googleEnabled: boolean;
            signupEnabled: boolean;
            autoconfirm: boolean;
        };
        error?: string;
    };
    environment_variables: {
        supabaseUrl: boolean;
        supabaseAnonKey: boolean;
        supabaseServiceKey: boolean;
    };
    oauth_flow: {
        loginPageExists: boolean;
        callbackRouteExists: boolean;
        authProviderConfigured: boolean;
    };
    recommendations: string[];
    overall_status: 'ready' | 'partial' | 'not_configured' | 'error';
}
export type { OAuthStatus };</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/lib/api/admin/oauth-status/helpers.d.ts (Line 1:1 - Line 73:2), C:/AI/food-truck-finder-poc/dist/lib/lib/api/admin/oauth-status/helpers.d.ts (Line 1:1 - Line 73:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn13" onclick="toggleCodeBlock('cloneGroup13', 'expandBtn13', 'collapseBtn13')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn13" onclick="toggleCodeBlock('cloneGroup13', 'expandBtn13', 'collapseBtn13')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup13"><code class="language-typescript text-sm text-gray-800">import { NextRequest, NextResponse } from 'next/server';
/**
 * Handles a GET request to retrieve OAuth configuration status.
 * @example
 * handleGetRequest(request)
 * Returns a JSON response with OAuth status details and legacy format.
 * @param {NextRequest} _request - The incoming request object.
 * @returns {NextResponse} JSON response indicating the current OAuth status.
 * @description
 *   - Retrieves the current OAuth configuration status from the server.
 *   - Adapts the response to include both modern and legacy format details.
 *   - Provides a step-by-step legacy configuration guide if OAuth is not ready.
 */
export declare function handleGetRequest(_request: NextRequest): Promise&lt;NextResponse&lt;{
    legacy_format: {
        oauth_status: &quot;error&quot; | &quot;ready&quot; | &quot;partial&quot; | &quot;not_configured&quot;;
        message: string;
        configuration_steps: string[] | undefined;
    };
    timestamp: string;
    environment: &quot;development&quot; | &quot;production&quot;;
    supabase: {
        connected: boolean;
        projectId: string;
        authSettings?: {
            googleEnabled: boolean;
            signupEnabled: boolean;
            autoconfirm: boolean;
        };
        error?: string;
    };
    environment_variables: {
        supabaseUrl: boolean;
        supabaseAnonKey: boolean;
        supabaseServiceKey: boolean;
    };
    oauth_flow: {
        loginPageExists: boolean;
        callbackRouteExists: boolean;
        authProviderConfigured: boolean;
    };
    recommendations: string[];
    overall_status: &quot;ready&quot; | &quot;partial&quot; | &quot;not_configured&quot; | &quot;error&quot;;
    success: boolean;
}&gt;&gt;;
/**
 * Handles a post request to generate an OAuth test URL based on the environment.
 * @example
 * handlePostRequest()
 * {
 *   success: true,
 *   message: 'OAuth test URL generated',
 *   test_url: 'http://localhost:3000/...',
 *   environment: 'development',
 *   instructions: [ ... ],
 *   manual_test_steps: [ ... ],
 *   automation_commands: [ ... ]
 * }
 * @returns {object} An object containing success status, message, the test URL, the environment, instructions, manual test steps, and automation commands.
 * @description
 *   - Determines the base URL depending on whether the environment is production or development.
 *   - Utilizes `generateOAuthTestUrl` to construct the OAuth test URL.
 *   - Responds with JSON containing test instructions and automation commands for verifying OAuth functionality.
 */
export declare function handlePostRequest(): NextResponse&lt;{
    success: boolean;
    message: string;
    test_url: string;
    environment: string;
    instructions: string[];
    manual_test_steps: string[];
    automation_commands: string[];
}&gt;;</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/lib/api/admin/data-cleanup/handlers.d.ts (Line 1:1 - Line 118:2), C:/AI/food-truck-finder-poc/dist/lib/lib/api/admin/data-cleanup/handlers.d.ts (Line 1:1 - Line 118:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn16" onclick="toggleCodeBlock('cloneGroup16', 'expandBtn16', 'collapseBtn16')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn16" onclick="toggleCodeBlock('cloneGroup16', 'expandBtn16', 'collapseBtn16')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup16"><code class="language-typescript text-sm text-gray-800">import { NextRequest, NextResponse } from 'next/server';
import type { DataCleanupRequestBody } from '@/lib/types';
/**
 * Handles different types of data cleanup requests and returns appropriate responses.
 * @example
 * handlePostRequest({ action: 'full-cleanup', options: {} })
 * returns a promise resolving to a NextResponse with cleanup result
 * @param {DataCleanupRequestBody} body - Object containing an action type and optional parameters for the cleanup process.
 * @returns {Promise&lt;NextResponse&gt;} Resolves to a NextResponse object indicating success or failure with details about the performed action.
 * @description
 *   - Handles specific actions: 'full-cleanup', 'check-duplicates', 'merge-duplicates', 'dry-run'.
 *   - Defaults to returning an error response for unknown actions.
 *   - Provides flexibility in defining options for each specific cleanup action.
 *   - Integrates with Next.js response mechanism for API endpoints.
 */
export declare function handlePostRequest(body: DataCleanupRequestBody): Promise&lt;NextResponse&gt;;
/**
 * Processes a GET request and performs actions based on query parameters.
 * @example
 * handleGetRequest(request)
 * Promise&lt;NextResponse&gt;
 * @param {NextRequest} request - Incoming Next.js request object containing the URL and search parameters.
 * @returns {Promise&lt;NextResponse&gt;} Promise resolving to a NextResponse object.
 * @description
 *   - It extracts the `action` parameter from the request URL's query string.
 *   - Based on the action parameter value, it delegates the request to specific handlers like `handleGetStatus`, `handleGetPreview`, or `handleGetDefault`.
 *   - Handles asynchronous operations within the action cases when necessary (e.g., `preview`).
 *   - Ensures proper response handling while maintaining the server-side asynchronous flow.
 */
export declare function handleGetRequest(request: NextRequest): Promise&lt;NextResponse&gt;;
/**
* Executes a full data cleanup operation based on provided options.
* @example
* handleFullCleanup({ batchSize: 100, dryRun: true, operations: ['removeDuplicates', 'optimizeData'] })
* Returns a JSON response confirming the success of the cleanup.
* @param {Object} options - Configuration for the cleanup operation.
* @returns {Promise&lt;Object&gt;} A JSON response with the cleanup result summary.
* @description
*   - Default batch size for cleanup is set to 50 if not specified.
*   - Supports a dry-run mode for testing cleanup without making changes.
*   - Utilizes operations parameter to specify types of cleanup tasks.
*   - Provides detailed summary in the response message.
*/
export declare function handleFullCleanup(options: DataCleanupRequestBody['options']): Promise&lt;NextResponse&gt;;
/**
 * Handles the duplicate check functionality for truck data.
 * @example
 * handleCheckDuplicates({ options: { truckData: [...] } })
 * Returns a promise with a JSON response indicating success or failure of duplicate check.
 * @param {DataCleanupRequestBody['options']} options - The request body containing truck data to be checked.
 * @returns {Promise&lt;NextResponse&gt;} A promise that resolves to a NextResponse object containing the result of the duplicate check.
 * @description
 *   - Utilizes the Duplicate Prevention Service to verify the presence of duplicates.
 *   - Expects `truckData` within the provided options for processing.
 *   - Returns an error JSON response with status 400 if `truckData` is not supplied.
 */
export declare function handleCheckDuplicates(options: DataCleanupRequestBody['options']): Promise&lt;NextResponse&gt;;
/**
* Handles the merge operation for duplicate truck entries.
* @example
* handleMergeDuplicates({ targetId: '123', sourceId: '456' })
* Returns a NextResponse indicating the success or failure of the merge operation.
* @param {DataCleanupRequestBody['options']} options - Options containing targetId and sourceId for the merge operation.
* @returns {Promise&lt;NextResponse&gt;} Returns a NextResponse object indicating the merge result.
* @description
*   - Utilizes DuplicatePreventionService to merge duplicate entries.
*   - Sends an error response with status 400 if targetId or sourceId is missing.
*/
export declare function handleMergeDuplicates(options: DataCleanupRequestBody['options']): Promise&lt;NextResponse&gt;;
/**
 * Executes a dry run of the data cleanup process without making changes to the database.
 * @example
 * handleDryRun({ operations: ['deleteUnused', 'optimizeData'] })
 * Promise resolves to NextResponse with details of the dry run.
 * @param {DataCleanupRequestBody['options']} options - Cleanup options including operations to simulate.
 * @returns {Promise&lt;NextResponse&gt;} A response object indicating the success of the dry run and its results.
 * @description
 *   - Utilizes the BatchCleanupService to simulate cleanup operations.
 *   - Ensures no changes are made to the database during the dry run.
 *   - Provides details of simulated operations in the response result.
 */
export declare function handleDryRun(options: DataCleanupRequestBody['options']): Promise&lt;NextResponse&gt;;
/**
* Returns the current status with details on available operations, default batch size, and dry-run support.
* @example
* handleGetStatus()
* returns a JSON response with success status and operational details
* @returns {NextResponse} JSON response containing operation details.
* @description
*   - Lists available operations such as 'remove_placeholders', 'normalize_phone', and more.
*   - Provides default batch size set to 50.
*   - Indicates support for dry-run operations.
*/
export declare function handleGetStatus(): NextResponse;
/**
 * Generates a preview of the batch cleanup process.
 * @example
 * handleGetPreview()
 * Promise&lt;NextResponse&gt;
 * @returns {Promise&lt;NextResponse&gt;} Returns a JSON response containing the cleanup preview.
 * @description
 *   - Utilizes the BatchCleanupService to execute a dry run with a specified batch size.
 *   - Extracts summary information including estimated improvements and duplicates removed.
 *   - Structures the operations in a detailed format for review.
 */
export declare function handleGetPreview(): Promise&lt;NextResponse&gt;;
/**
* Provides a JSON response containing available endpoints and actions related to data cleanup.
* @example
* handleGetDefault()
* Returns a JSON response with success status, endpoints, and actions.
* @returns {NextResponse} Returns a JSON response with structure defining success, endpoints, and actions related to data cleanup.
* @description
*   - The function targets administrative cleanup operations within the system.
*   - Provides metadata for functionalities aimed at data cleanup processes.
*   - Intended to support endpoint consumption and decision-making for administrative tasks.
*/
export declare function handleGetDefault(): NextResponse;</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/lib/api/admin/automated-cleanup/handlers.d.ts (Line 1:1 - Line 63:2), C:/AI/food-truck-finder-poc/dist/lib/lib/api/admin/automated-cleanup/handlers.d.ts (Line 1:1 - Line 63:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn18" onclick="toggleCodeBlock('cloneGroup18', 'expandBtn18', 'collapseBtn18')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn18" onclick="toggleCodeBlock('cloneGroup18', 'expandBtn18', 'collapseBtn18')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup18"><code class="language-typescript text-sm text-gray-800">import { NextResponse } from 'next/server';
interface RunScheduledOptions {
    scheduleId: string;
}
interface RunImmediateOptions {
    operations?: string[];
    batchSize?: number;
    dryRun?: boolean;
}
interface ScheduleCleanupOptions {
    name: string;
    operations: string[];
    schedule: string;
    enabled?: boolean;
}
interface UpdateScheduleOptions {
    scheduleId: string;
    updates: Record&lt;string, unknown&gt;;
}
interface DeleteScheduleOptions {
    scheduleId: string;
}
export declare function handlePostRequest(body: {
    action: string;
    options?: Record&lt;string, unknown&gt;;
}): Promise&lt;NextResponse&lt;unknown&gt;&gt;;
export declare function handleGetStatus(): Promise&lt;NextResponse&gt;;
export declare function handleGetSchedules(): Promise&lt;NextResponse&gt;;
export declare function handleGetHistory(searchParams: URLSearchParams): Promise&lt;NextResponse&gt;;
export declare function handleGetPreview(searchParams: URLSearchParams): Promise&lt;NextResponse&gt;;
/**
 * Handles the retrieval of default cleanup status and returns a JSON response.
 * @example
 * handleGetDefault().then(response =&gt; console.log(response));
 * // { success: true, status: ..., endpoints: [...] }
 * @param {none} {none} - No arguments are required for this function.
 * @returns {Promise&lt;NextResponse&gt;} A promise that resolves to a NextResponse JSON object containing cleanup status and endpoints.
 * @description
 *   - Utilizes the getCleanupStatus function to fetch the current cleanup status.
 *   - Constructs a response object detailing available cleanup-related endpoints.
 *   - Follow API endpoint descriptions to properly utilize cleanup functionalities.
 */
export declare function handleGetDefault(): Promise&lt;NextResponse&gt;;
export declare function handleRunScheduled(options: RunScheduledOptions): Promise&lt;NextResponse&gt;;
/**
* Executes a batch cleanup operation immediately based on provided options.
* @example
* handleRunImmediate({ dryRun: true, batchSize: 100 })
* Returns: { success: true, action: 'run_immediate', result: {...}, message: 'Dry run completed successfully' }
* @param {Object} options - Configuration options for the cleanup operation.
* @returns {Promise&lt;NextResponse&gt;} A promise that resolves to the NextResponse object containing the cleanup result.
* @description
*   - The `operations` parameter defaults to a set of predefined cleanup tasks if not specified.
*   - If `dryRun` is true, the function simulates the cleanup without making any modifications.
*   - Utilizes `BatchCleanupService` for executing the cleanup logic.
*   - Operation results are logged with `logCleanupOperation` for tracking purposes.
*/
export declare function handleRunImmediate(options: RunImmediateOptions): Promise&lt;NextResponse&gt;;
export declare function handleScheduleCleanup(options: ScheduleCleanupOptions): Promise&lt;NextResponse&gt;;
export declare function handleUpdateSchedule(options: UpdateScheduleOptions): Promise&lt;NextResponse&gt;;
export declare function handleDeleteSchedule(options: DeleteScheduleOptions): Promise&lt;NextResponse&gt;;
export declare function handleAnalyzeDuplicates(options: Record&lt;string, unknown&gt;): Promise&lt;NextResponse&gt;;
export {};</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/api/cron/auto-scrape/handlers.ts (Line 71:8 - Line 81:2), C:/AI/food-truck-finder-poc/lib/api/cron/auto-scrape/improvedHandler.ts (Line 118:6 - Line 129:7)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn24" onclick="toggleCodeBlock('cloneGroup24', 'expandBtn24', 'collapseBtn24')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn24" onclick="toggleCodeBlock('cloneGroup24', 'expandBtn24', 'collapseBtn24')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup24"><code class="language-typescript text-sm text-gray-800">) {
  console.error('Auto-scraping cron job failed:', error);
  logActivity({
    type: 'cron_job',
    action: 'auto_scrape_failed',
    details: {
      timestamp: new Date().toISOString(),
      error: error instanceof Error ? error.message : 'Unknown error',
    },
  });
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/api/admin/oauth-status/types.ts (Line 1:1 - Line 28:2), C:/AI/food-truck-finder-poc/dist/lib/lib/api/admin/oauth-status/types.d.ts (Line 1:1 - Line 27:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn42" onclick="toggleCodeBlock('cloneGroup42', 'expandBtn42', 'collapseBtn42')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn42" onclick="toggleCodeBlock('cloneGroup42', 'expandBtn42', 'collapseBtn42')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup42"><code class="language-typescript text-sm text-gray-800">interface OAuthStatus {
  timestamp: string;
  environment: 'development' | 'production';
  supabase: {
    connected: boolean;
    projectId: string;
    authSettings?: {
      googleEnabled: boolean;
      signupEnabled: boolean;
      autoconfirm: boolean;
    };
    error?: string;
  };
  environment_variables: {
    supabaseUrl: boolean;
    supabaseAnonKey: boolean;
    supabaseServiceKey: boolean;
  };
  oauth_flow: {
    loginPageExists: boolean;
    callbackRouteExists: boolean;
    authProviderConfigured: boolean;
  };
  recommendations: string[];
  overall_status: 'ready' | 'partial' | 'not_configured' | 'error';
}

export type { OAuthStatus };</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/api/admin/automated-cleanup/handlers.ts (Line 24:1 - Line 50:10), C:/AI/food-truck-finder-poc/dist/lib/lib/api/admin/automated-cleanup/handlers.d.ts (Line 2:1 - Line 23:7)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn64" onclick="toggleCodeBlock('cloneGroup64', 'expandBtn64', 'collapseBtn64')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn64" onclick="toggleCodeBlock('cloneGroup64', 'expandBtn64', 'collapseBtn64')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup64"><code class="language-typescript text-sm text-gray-800">interface RunScheduledOptions {
  scheduleId: string;
}

interface RunImmediateOptions {
  operations?: string[];
  batchSize?: number;
  dryRun?: boolean;
}

interface ScheduleCleanupOptions {
  name: string;
  operations: string[];
  schedule: string;
  enabled?: boolean;
}

interface UpdateScheduleOptions {
  scheduleId: string;
  updates: Record&lt;string, unknown&gt;;
}

interface DeleteScheduleOptions {
  scheduleId: string;
}

interface</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/lib/components/ui/variants.d.ts (Line 17:2 - Line 33:7), C:/AI/food-truck-finder-poc/dist/lib/components/ui/variants.d.ts (Line 1:2 - Line 17:254)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn78" onclick="toggleCodeBlock('cloneGroup78', 'expandBtn78', 'collapseBtn78')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn78" onclick="toggleCodeBlock('cloneGroup78', 'expandBtn78', 'collapseBtn78')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup78"><code class="language-typescript text-sm text-gray-800">{
    variant: {
        default: string;
        destructive: string;
        outline: string;
        secondary: string;
        ghost: string;
        link: string;
        neon: string;
    };
    size: {
        default: string;
        sm: string;
        lg: string;
        icon: string;
    };
}, undefined, import</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/lib/components/ui/variants.d.ts (Line 33:2 - Line 49:8), C:/AI/food-truck-finder-poc/dist/lib/components/ui/variants.d.ts (Line 1:2 - Line 17:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn79" onclick="toggleCodeBlock('cloneGroup79', 'expandBtn79', 'collapseBtn79')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn79" onclick="toggleCodeBlock('cloneGroup79', 'expandBtn79', 'collapseBtn79')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup79"><code class="language-typescript text-sm text-gray-800">import(&quot;tailwind-variants&quot;).TVReturnType&lt;{
    variant: {
        default: string;
        destructive: string;
        outline: string;
        secondary: string;
        ghost: string;
        link: string;
        neon: string;
    };
    size: {
        default: string;
        sm: string;
        lg: string;
        icon: string;
    };
}, undefined, &quot;inline-flex items-center justify-center rounded-modern text-sm font-medium transition-all duration-300 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50&quot;, unknown</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/lib/api/trucks/handlers.d.ts (Line 1:1 - Line 95:2), C:/AI/food-truck-finder-poc/dist/lib/lib/api/trucks/handlers.d.ts (Line 1:1 - Line 95:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn81" onclick="toggleCodeBlock('cloneGroup81', 'expandBtn81', 'collapseBtn81')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn81" onclick="toggleCodeBlock('cloneGroup81', 'expandBtn81', 'collapseBtn81')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup81"><code class="language-typescript text-sm text-gray-800">import { NextResponse } from 'next/server';
export declare function handleGetTruckById(id: string): Promise&lt;NextResponse&lt;{
    error: string;
}&gt; | NextResponse&lt;{
    truck: import(&quot;@/lib/supabase&quot;).FoodTruck;
}&gt;&gt;;
/**
 * Retrieves a list of food trucks within a specified radius.
 * @example
 * handleGetTrucksByLocation(&quot;37.7749&quot;, &quot;-122.4194&quot;, &quot;5&quot;)
 * Returns an object with the list of nearby food trucks and additional metadata.
 * @param {string} lat - Latitude of the location from which to search for food trucks.
 * @param {string} lng - Longitude of the location from which to search for food trucks.
 * @param {string} radius - The radius (in kilometers) within which to find food trucks.
 * @returns {Object} An object containing a list of nearby food trucks along with metadata related to the query.
 * @description
 *   - Converts latitude, longitude, and radius from string to float.
 *   - Invokes an asynchronous service call to fetch trucks.
 *   - Returns an error message with status 500 if an error is encountered.
 *   - Currently, assumes no pagination is needed for location-based searches.
 */
export declare function handleGetTrucksByLocation(lat: string, lng: string, radius: string): Promise&lt;NextResponse&lt;{
    error: string;
}&gt; | NextResponse&lt;{
    trucks: import(&quot;@/lib/supabase&quot;).FoodTruck[];
    total: number;
    limit: number;
    offset: number;
    hasMore: boolean;
}&gt;&gt;;
/**
 * Retrieves truck data with pagination support.
 * @example
 * handleGetAllTrucks(10, 0)
 * { trucks: [...], total: 100, limit: 10, offset: 0, hasMore: true, summary: {...} }
 * @param {number} limit - Number of trucks to retrieve per request.
 * @param {number} offset - Starting position of truck data to retrieve.
 * @returns {object} JSON response containing truck data, pagination information, and summary.
 * @description
 *   - Checks for errors returned by the FoodTruckService API and responds with a generic error message.
 *   - Computes an `averageQuality` score for the retrieved trucks.
 *   - Determines `hasMore` by comparing total trucks to limit and offset.
 *   - Calculates `lastUpdated` timestamp from truck data.
 */
export declare function handleGetAllTrucks(limit: number, offset: number): Promise&lt;NextResponse&lt;{
    error: string;
}&gt; | NextResponse&lt;{
    trucks: import(&quot;@/lib/supabase&quot;).FoodTruck[];
    total: number;
    limit: number;
    offset: number;
    hasMore: boolean;
    summary: {
        totalTrucks: number;
        averageQuality: number;
        lastUpdated: number;
    };
}&gt;&gt;;
/**
* Handles the creation of a food truck by delegating to the FoodTruckService.
* @example
* handlePostTruck({ name: 'Best Food Truck', location: 'Downtown' })
* // returns a JSON response with status 201 and a success message
* @param {unknown} truckData - Data for creating a new food truck.
* @returns {object} JSON response indicating success or failure.
* @description
*   - Utilizes FoodTruckService to create a new truck record.
*   - Handles errors, logging them and returning appropriate HTTP statuses.
*   - Converts the data into a Partial&lt;FoodTruck&gt; type before passing it to the service.
*/
export declare function handlePostTruck(truckData: unknown): Promise&lt;NextResponse&lt;{
    error: string;
}&gt; | NextResponse&lt;{
    message: string;
    truck: import(&quot;@/lib/supabase&quot;).FoodTruck;
}&gt;&gt;;
/**
 * Updates food truck information with given updates and returns the operation status.
 * @example
 * handlePutTruck('1234', { name: 'New Food Truck Name' })
 * { message: 'Food truck updated successfully', truck: updatedTruckResult }
 * @param {string} id - The ID of the food truck to be updated.
 * @param {unknown} updates - The updates to apply to the food truck as a partial object.
 * @returns {Promise&lt;NextResponse&gt;} A response indicating success or failure of the update operation in JSON format.
 * @description
 *   - The function uses FoodTruckService.updateTruck to apply updates.
 *   - It logs errors to the console if the update operation fails.
 *   - Responds with HTTP status 500 in case of any error during the update process.
 */
export declare function handlePutTruck(id: string, updates: unknown): Promise&lt;NextResponse&lt;{
    error: string;
}&gt; | NextResponse&lt;{
    message: string;
    truck: import(&quot;@/lib/supabase&quot;).FoodTruck;
}&gt;&gt;;</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/lib/api/test-integration/stageHandlers.d.ts (Line 1:1 - Line 11:2), C:/AI/food-truck-finder-poc/dist/lib/lib/api/test-integration/stageHandlers.d.ts (Line 1:1 - Line 11:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn83" onclick="toggleCodeBlock('cloneGroup83', 'expandBtn83', 'collapseBtn83')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn83" onclick="toggleCodeBlock('cloneGroup83', 'expandBtn83', 'collapseBtn83')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup83"><code class="language-typescript text-sm text-gray-800">import { type ExtractedFoodTruckDetails, type StageResult } from '@/lib/types';
export declare function handleFirecrawlStage(url: string, rawText: string | undefined, logs: string[]): Promise&lt;{
    firecrawlResult: StageResult;
    contentToProcess: string | undefined;
    sourceUrlForProcessing: string;
}&gt;;
export declare function handleGeminiStage(contentToProcess: string, sourceUrlForProcessing: string, logs: string[]): Promise&lt;{
    geminiResult: StageResult;
    extractedData: ExtractedFoodTruckDetails | undefined;
}&gt;;
export declare function handleSupabaseStage(extractedData: ExtractedFoodTruckDetails, sourceUrlForProcessing: string, isDryRun: boolean, logs: string[]): Promise&lt;StageResult&gt;;</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/lib/api/test-integration/helpers.d.ts (Line 1:1 - Line 66:2), C:/AI/food-truck-finder-poc/dist/lib/lib/api/test-integration/helpers.d.ts (Line 1:1 - Line 66:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn87" onclick="toggleCodeBlock('cloneGroup87', 'expandBtn87', 'collapseBtn87')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn87" onclick="toggleCodeBlock('cloneGroup87', 'expandBtn87', 'collapseBtn87')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup87"><code class="language-typescript text-sm text-gray-800">import { type FirecrawlResponse } from '@/lib/firecrawl';
import { type FoodTruck, type ScrapingJob, type DataProcessingQueue } from '@/lib/supabase';
import type { GeminiResponse, MenuCategory } from '@/lib/types';
interface FirecrawlTestResult {
    success: boolean;
    result?: FirecrawlResponse;
    error?: string;
    details?: unknown;
}
export declare function testFirecrawlScraping(testUrl: string): Promise&lt;FirecrawlTestResult&gt;;
export declare function testGeminiProcessing(): Promise&lt;{
    success: boolean;
    error: string;
    details: string | undefined;
    result?: undefined;
} | {
    success: boolean;
    result: GeminiResponse&lt;MenuCategory[]&gt;;
    error?: undefined;
    details?: undefined;
}&gt;;
type GeminiProcessMenuDataResult = MenuCategory[];
interface SupabaseTestResults {
    testTruck: FoodTruck;
    testJob: ScrapingJob;
    queueItem: DataProcessingQueue;
    nearbyTrucks: FoodTruck[];
}
interface FormattedTestResults {
    success: boolean;
    message: string;
    results: {
        firecrawl: {
            success: boolean;
            dataLength: number;
        };
        gemini: {
            success: boolean;
            tokensUsed: number | undefined;
            categoriesFound: number;
        };
        supabase: {
            truckCreated: string;
            jobCreated: string;
            queueItemCreated: string;
            nearbyTrucksFound: number;
        };
    };
    testData: {
        truck: FoodTruck;
        processedMenu: MenuCategory[] | undefined;
        nearbyTrucks: FoodTruck[];
    };
}
export declare function testSupabaseOperations(testUrl: string, geminiResult: GeminiResponse&lt;GeminiProcessMenuDataResult&gt;): Promise&lt;SupabaseTestResults&gt;;
export declare function formatTestResults(scrapeResult: FirecrawlTestResult, geminiResult: GeminiResponse&lt;GeminiProcessMenuDataResult&gt;, supabaseResults: SupabaseTestResults): FormattedTestResults;
export declare function runIntegrationTestSteps(testUrl: string): Promise&lt;FirecrawlTestResult | {
    success: boolean;
    result: GeminiResponse&lt;MenuCategory[]&gt;;
    error?: undefined;
    details?: undefined;
} | {
    success: boolean;
    results: FormattedTestResults;
}&gt;;
export {};</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/lib/api/tavily/handlers.d.ts (Line 1:1 - Line 42:2), C:/AI/food-truck-finder-poc/dist/lib/lib/api/tavily/handlers.d.ts (Line 1:1 - Line 42:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn89" onclick="toggleCodeBlock('cloneGroup89', 'expandBtn89', 'collapseBtn89')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn89" onclick="toggleCodeBlock('cloneGroup89', 'expandBtn89', 'collapseBtn89')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup89"><code class="language-typescript text-sm text-gray-800">/**
 * Performs a search operation using Tavily API or returns mock data if API key is unavailable.
 * @example
 * performTavilySearch({ location: 'South Carolina', query: 'food trucks' })
 * { results: [{ title: 'South Carolina Food Trucks (Mock)', url: 'https://example-foodtruck1.com', ... }] }
 * @param {Record&lt;string, unknown&gt;} params - Parameters for the Tavily API search.
 * @returns {Promise&lt;any&gt;} The search results from the Tavily API or mock data.
 * @description
 *   - Utilizes the TAVILY_API_KEY from environment variables to make API requests.
 *   - Returns mock data if the API key is missing or empty.
 *   - Logs a warning if mock data is being used due to missing API key.
 *   - Throws an error if the Tavily API call fails.
 */
export declare function performTavilySearch(params: Record&lt;string, unknown&gt;): Promise&lt;{
    results: {
        title: string;
        url: string;
        content: string;
        raw_content: string;
    }[];
}&gt;;
/**
* Performs a mock Tavily crawl operation.
* @example
* performTavilyCrawl({ key: 'value' })
* { results: [ { url: 'https://example-crawled-truck.com', title: 'Gourmet Food Truck', content: 'Premium mobile dining experience...' } ] }
* @param {Record&lt;string, unknown&gt;} params - Parameters for the mock crawl operation.
* @returns {Object} An object containing mock crawl results.
* @description
*   - Utilizes a mock implementation for demonstration purposes.
*   - Logs the crawling parameters to the console for debugging.
*/
export declare function performTavilyCrawl(params: Record&lt;string, unknown&gt;): {
    results: {
        url: string;
        title: string;
        content: string;
    }[];
};
export declare function performTavilyMap(params: Record&lt;string, unknown&gt;): {
    results: string[];
};</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/lib/api/search/helpers.d.ts (Line 15:2 - Line 28:2), C:/AI/food-truck-finder-poc/dist/lib/lib/api/search/helpers.d.ts (Line 8:12 - Line 21:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn91" onclick="toggleCodeBlock('cloneGroup91', 'expandBtn91', 'collapseBtn91')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn91" onclick="toggleCodeBlock('cloneGroup91', 'expandBtn91', 'collapseBtn91')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup91"><code class="language-typescript text-sm text-gray-800">): Promise&lt;NextResponse&lt;{
    trucks: FoodTruck[];
    total: number;
    filters: {
        query: string | null;
        cuisine: string | null;
        openNow: boolean;
        location: {
            lat: number;
            lng: number;
        } | undefined;
        radius: number;
    };
}&gt;&gt;;</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/lib/api/search/filters.d.ts (Line 1:1 - Line 29:2), C:/AI/food-truck-finder-poc/dist/lib/lib/api/search/filters.d.ts (Line 2:1 - Line 30:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn93" onclick="toggleCodeBlock('cloneGroup93', 'expandBtn93', 'collapseBtn93')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn93" onclick="toggleCodeBlock('cloneGroup93', 'expandBtn93', 'collapseBtn93')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup93"><code class="language-typescript text-sm text-gray-800">/**
* Filters an array of FoodTruck objects based on a given search query.
* @example
* applyTextSearchFilter(foodTrucksArray, 'taco')
* // Returns an array of FoodTruck objects where the truck name, description, or menu contains 'taco'
* @param {FoodTruck[]} trucks - An array of FoodTruck objects to be filtered.
* @param {string | null} query - Search query to filter the food trucks by.
* @returns {FoodTruck[]} An array of FoodTruck objects that match the search query.
* @description
*   - If the query is null or an empty string, the original array is returned unfiltered.
*   - The search is case-insensitive.
*   - Searches through truck names, descriptions, and menu item names and descriptions.
*   - Utilizes optional chaining to handle undefined or null values in truck descriptions and menus.
*/
export declare function applyTextSearchFilter(trucks: FoodTruck[], query: string | null): FoodTruck[];
export declare function applyCuisineFilter(trucks: FoodTruck[], cuisine: string | null): FoodTruck[];
/**
 * Filters a list of food trucks to only include those that are currently open.
 * @example
 * applyOpenNowFilter(trucks, true)
 * // returns list of trucks open at the current date and time
 * @param {FoodTruck[]} trucks - Array of food truck objects to be filtered.
 * @param {boolean} openNow - Flag to filter trucks that are open at the current time.
 * @returns {FoodTruck[]} Array of food trucks that are open now, or the unfiltered array if openNow is false.
 * @description
 *   - Uses the system's current date and time to determine if trucks are open.
 *   - Filters based on the truck's operating hours for the current day.
 */
export declare function applyOpenNowFilter(trucks: FoodTruck[], openNow: boolean): FoodTruck[];</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/lib/api/search/data.d.ts (Line 1:1 - Line 17:2), C:/AI/food-truck-finder-poc/dist/lib/lib/api/search/data.d.ts (Line 1:1 - Line 17:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn95" onclick="toggleCodeBlock('cloneGroup95', 'expandBtn95', 'collapseBtn95')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn95" onclick="toggleCodeBlock('cloneGroup95', 'expandBtn95', 'collapseBtn95')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup95"><code class="language-typescript text-sm text-gray-800">import type { FoodTruck } from '@/lib/types.js';
/**
* Retrieves and filters food trucks based on specified location and radius.
* @example
* getAndFilterFoodTrucks(&quot;37.7749&quot;, &quot;-122.4194&quot;, &quot;5&quot;)
* [FoodTruck, FoodTruck, FoodTruck]
* @param {string | null} lat - Latitude of the user's location.
* @param {string | null} lng - Longitude of the user's location.
* @param {string | null} radius - Search radius in kilometers.
* @returns {Promise&lt;FoodTruck[]&gt;} List of food trucks within the specified location and radius.
* @description
*   - Parses latitude, longitude, and radius from strings to floats for calculations.
*   - If latitude or longitude are not provided, fetches all cached food trucks.
*   - Defaults radius to 10 kilometers if not provided.
*/
export declare function getAndFilterFoodTrucks(lat: string | null, lng: string | null, radius: string | null): Promise&lt;FoodTruck[]&gt;;
export declare function sortFoodTrucksByQuality(trucks: FoodTruck[]): FoodTruck[];</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/lib/api/scheduler/types.d.ts (Line 1:1 - Line 20:2), C:/AI/food-truck-finder-poc/dist/lib/lib/api/scheduler/types.d.ts (Line 1:1 - Line 20:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn96" onclick="toggleCodeBlock('cloneGroup96', 'expandBtn96', 'collapseBtn96')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn96" onclick="toggleCodeBlock('cloneGroup96', 'expandBtn96', 'collapseBtn96')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup96"><code class="language-typescript text-sm text-gray-800">export interface SchedulerTask {
    id: string;
    name: string;
    enabled: boolean;
    intervalMinutes: number;
    lastRun: string;
    lastSuccess: string;
    successCount: number;
    errorCount: number;
    nextRun: string | undefined;
    lastError?: string;
}
export interface PostRequestBody {
    action: 'start' | 'stop' | 'execute';
    taskId?: string;
}
export interface PutRequestBody {
    taskId: string;
    config: Partial&lt;SchedulerTask&gt;;
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/lib/api/scheduler/handlers.d.ts (Line 26:13 - Line 111:13), C:/AI/food-truck-finder-poc/dist/lib/lib/api/scheduler/handlers.d.ts (Line 26:10 - Line 111:10)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn98" onclick="toggleCodeBlock('cloneGroup98', 'expandBtn98', 'collapseBtn98')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn98" onclick="toggleCodeBlock('cloneGroup98', 'expandBtn98', 'collapseBtn98')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup98"><code class="language-typescript text-sm text-gray-800">).SchedulerTask[];
    summary: {
        totalTasks: number;
        enabledTasks: number;
        runningTasks: number;
        totalSuccesses: number;
        totalErrors: number;
    };
}&gt;;
/**
* Generates a JSON response containing a list of scheduler logs
* @example
* handleSchedulerLogs()
* { logs: [...] }
* @returns {Object} A JSON object containing an array of log entries with details.
* @description
*   - Each log entry includes a timestamp, task identifier, log level, and a message.
*   - The log levels include 'info', 'error', and 'warning'.
*   - Log timestamps are derived from the current time and adjusted to simulate real-time delays.
*   - Provides insight into scheduler task execution and any issues encountered.
*/
export declare function handleSchedulerLogs(): NextResponse&lt;{
    logs: {
        timestamp: string;
        taskId: string;
        level: string;
        message: string;
    }[];
}&gt;;
export declare function handleSchedulerDefault(): NextResponse&lt;{
    message: string;
    endpoints: string[];
}&gt;;
/**
* Initializes the scheduler if it's not already running
* @example
* handleStartScheduler()
* { &quot;message&quot;: &quot;Scheduler started successfully&quot;, &quot;status&quot;: &quot;running&quot; }
* @param {none}
* @returns {NextResponse} Returns a JSON response indicating the status of the scheduler.
* @description
*   - Checks if a scheduler instance already exists before proceeding.
*   - Sets the current time as the start time for the new scheduler instance.
*   - Returns a 409 status code if the scheduler is already running.
*/
export declare function handleStartScheduler(): NextResponse&lt;{
    error: string;
}&gt; | NextResponse&lt;{
    message: string;
    status: string;
}&gt;;
/**
* Stops the scheduler if it is currently running and returns a status message.
* @example
* handleStopScheduler()
* { message: 'Scheduler stopped successfully', status: 'stopped' }
* @param {undefined} schedulerInstance - Represents the current instance of the scheduler.
* @returns {Object} JSON response object containing a message and a status of the operation.
* @description
*   - Returns an error message if the scheduler is not running.
*   - Sets the scheduler instance to undefined to signify it has been stopped.
*/
export declare function handleStopScheduler(): NextResponse&lt;{
    error: string;
}&gt; | NextResponse&lt;{
    message: string;
    status: string;
}&gt;;
/**
 * Executes a task by its ID and returns the execution result.
 * @example
 * handleExecuteTask('12345')
 * { message: 'Task 12345 executed', task: { ... } }
 * @param {string} taskId - Unique identifier of the task to be executed.
 * @returns {NextResponse} JSON response containing the execution result and task details.
 * @description
 *   - If the task ID is undefined or an empty string, returns a 400 JSON error response.
 *   - Finds the task associated with the given ID; returns a 404 JSON error if not found.
 *   - Task execution includes simulating success or failure. Math.random is used for simulation.
 *   - Updates task properties like lastRun, lastSuccess, successCount, errorCount based on execution result.
 */
export declare function handleExecuteTask(taskId: string): NextResponse&lt;{
    error: string;
}&gt; | NextResponse&lt;{
    message: string;
    task: import(&quot;./types.js&quot;</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/lib/api/pipeline/types.d.ts (Line 1:1 - Line 14:2), C:/AI/food-truck-finder-poc/dist/lib/lib/api/pipeline/types.d.ts (Line 1:1 - Line 14:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn100" onclick="toggleCodeBlock('cloneGroup100', 'expandBtn100', 'collapseBtn100')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn100" onclick="toggleCodeBlock('cloneGroup100', 'expandBtn100', 'collapseBtn100')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup100"><code class="language-typescript text-sm text-gray-800">export interface PipelineRequestBody {
    action?: 'discovery' | 'processing' | 'full' | 'maintenance';
    target_url?: string;
    config?: {
        maxUrls?: number;
        maxUrlsToProcess?: number;
        targetCities?: string[];
        priority?: number;
        skipDiscovery?: boolean;
        retryFailedJobs?: boolean;
    };
    job_type?: string;
    priority?: number;
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/api/analytics/web-vitals/handlers.d.ts (Line 23:4 - Line 61:4), C:/AI/food-truck-finder-poc/dist/lib/lib/api/analytics/web-vitals/handlers.d.ts (Line 23:2 - Line 61:13)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn129" onclick="toggleCodeBlock('cloneGroup129', 'expandBtn129', 'collapseBtn129')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn129" onclick="toggleCodeBlock('cloneGroup129', 'expandBtn129', 'collapseBtn129')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup129"><code class="language-typescript text-sm text-gray-800">;
    days: number;
    startDate: Date;
}&gt;;
/**
 * Calculate summary statistics for metrics
 */
export declare function calculateMetricsSummary(metrics: {
    metric_name: string;
    metric_value: number;
    rating: string;
}[]): Record&lt;string, {
    count: number;
    average: number | undefined;
    median: number | undefined;
    p75: number | undefined;
    p95: number | undefined;
    goodCount: number;
    needsImprovementCount: number;
    poorCount: number;
}&gt;;
/**
 * Calculate percentile value from sorted array
 */
export declare function getPercentile(sortedValues: number[], percentile: number): number;
/**
 * Handles POST requests to store and validate web vital metrics.
 * @example
 * handlePostRequest(request)
 * { success: true }
 * @param {NextRequest} request - The incoming request containing the web vital metric data.
 * @returns {NextResponse} JSON response indicating success or failure of storing the metric.
 * @description
 *   - Validates that the metric contains required fields and checks the types of values.
 *   - Stores validated metrics in a Supabase table if `supabaseAdmin` is available.
 *   - Logs any 'poor' performance metrics for monitoring purposes.
 *   - Ensures metrics collection is non-blocking, even if an error occurs during database operations.
 */
export declare function handlePostRequest(request: NextRequest): Promise&lt;any</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/api/admin/oauth-status/types.d.ts (Line 1:1 - Line 27:2), C:/AI/food-truck-finder-poc/dist/lib/lib/api/admin/oauth-status/types.d.ts (Line 1:1 - Line 27:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn132" onclick="toggleCodeBlock('cloneGroup132', 'expandBtn132', 'collapseBtn132')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn132" onclick="toggleCodeBlock('cloneGroup132', 'expandBtn132', 'collapseBtn132')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup132"><code class="language-typescript text-sm text-gray-800">interface OAuthStatus {
    timestamp: string;
    environment: 'development' | 'production';
    supabase: {
        connected: boolean;
        projectId: string;
        authSettings?: {
            googleEnabled: boolean;
            signupEnabled: boolean;
            autoconfirm: boolean;
        };
        error?: string;
    };
    environment_variables: {
        supabaseUrl: boolean;
        supabaseAnonKey: boolean;
        supabaseServiceKey: boolean;
    };
    oauth_flow: {
        loginPageExists: boolean;
        callbackRouteExists: boolean;
        authProviderConfigured: boolean;
    };
    recommendations: string[];
    overall_status: 'ready' | 'partial' | 'not_configured' | 'error';
}
export type { OAuthStatus };</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/api/admin/data-cleanup/handlers.d.ts (Line 13:1 - Line 128:2), C:/AI/food-truck-finder-poc/dist/lib/lib/api/admin/data-cleanup/handlers.d.ts (Line 3:1 - Line 118:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn136" onclick="toggleCodeBlock('cloneGroup136', 'expandBtn136', 'collapseBtn136')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn136" onclick="toggleCodeBlock('cloneGroup136', 'expandBtn136', 'collapseBtn136')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup136"><code class="language-typescript text-sm text-gray-800">/**
 * Handles different types of data cleanup requests and returns appropriate responses.
 * @example
 * handlePostRequest({ action: 'full-cleanup', options: {} })
 * returns a promise resolving to a NextResponse with cleanup result
 * @param {DataCleanupRequestBody} body - Object containing an action type and optional parameters for the cleanup process.
 * @returns {Promise&lt;NextResponse&gt;} Resolves to a NextResponse object indicating success or failure with details about the performed action.
 * @description
 *   - Handles specific actions: 'full-cleanup', 'check-duplicates', 'merge-duplicates', 'dry-run'.
 *   - Defaults to returning an error response for unknown actions.
 *   - Provides flexibility in defining options for each specific cleanup action.
 *   - Integrates with Next.js response mechanism for API endpoints.
 */
export declare function handlePostRequest(body: DataCleanupRequestBody): Promise&lt;NextResponse&gt;;
/**
 * Processes a GET request and performs actions based on query parameters.
 * @example
 * handleGetRequest(request)
 * Promise&lt;NextResponse&gt;
 * @param {NextRequest} request - Incoming Next.js request object containing the URL and search parameters.
 * @returns {Promise&lt;NextResponse&gt;} Promise resolving to a NextResponse object.
 * @description
 *   - It extracts the `action` parameter from the request URL's query string.
 *   - Based on the action parameter value, it delegates the request to specific handlers like `handleGetStatus`, `handleGetPreview`, or `handleGetDefault`.
 *   - Handles asynchronous operations within the action cases when necessary (e.g., `preview`).
 *   - Ensures proper response handling while maintaining the server-side asynchronous flow.
 */
export declare function handleGetRequest(request: NextRequest): Promise&lt;NextResponse&gt;;
/**
* Executes a full data cleanup operation based on provided options.
* @example
* handleFullCleanup({ batchSize: 100, dryRun: true, operations: ['removeDuplicates', 'optimizeData'] })
* Returns a JSON response confirming the success of the cleanup.
* @param {Object} options - Configuration for the cleanup operation.
* @returns {Promise&lt;Object&gt;} A JSON response with the cleanup result summary.
* @description
*   - Default batch size for cleanup is set to 50 if not specified.
*   - Supports a dry-run mode for testing cleanup without making changes.
*   - Utilizes operations parameter to specify types of cleanup tasks.
*   - Provides detailed summary in the response message.
*/
export declare function handleFullCleanup(options: DataCleanupRequestBody['options']): Promise&lt;NextResponse&gt;;
/**
 * Handles the duplicate check functionality for truck data.
 * @example
 * handleCheckDuplicates({ options: { truckData: [...] } })
 * Returns a promise with a JSON response indicating success or failure of duplicate check.
 * @param {DataCleanupRequestBody['options']} options - The request body containing truck data to be checked.
 * @returns {Promise&lt;NextResponse&gt;} A promise that resolves to a NextResponse object containing the result of the duplicate check.
 * @description
 *   - Utilizes the Duplicate Prevention Service to verify the presence of duplicates.
 *   - Expects `truckData` within the provided options for processing.
 *   - Returns an error JSON response with status 400 if `truckData` is not supplied.
 */
export declare function handleCheckDuplicates(options: DataCleanupRequestBody['options']): Promise&lt;NextResponse&gt;;
/**
* Handles the merge operation for duplicate truck entries.
* @example
* handleMergeDuplicates({ targetId: '123', sourceId: '456' })
* Returns a NextResponse indicating the success or failure of the merge operation.
* @param {DataCleanupRequestBody['options']} options - Options containing targetId and sourceId for the merge operation.
* @returns {Promise&lt;NextResponse&gt;} Returns a NextResponse object indicating the merge result.
* @description
*   - Utilizes DuplicatePreventionService to merge duplicate entries.
*   - Sends an error response with status 400 if targetId or sourceId is missing.
*/
export declare function handleMergeDuplicates(options: DataCleanupRequestBody['options']): Promise&lt;NextResponse&gt;;
/**
 * Executes a dry run of the data cleanup process without making changes to the database.
 * @example
 * handleDryRun({ operations: ['deleteUnused', 'optimizeData'] })
 * Promise resolves to NextResponse with details of the dry run.
 * @param {DataCleanupRequestBody['options']} options - Cleanup options including operations to simulate.
 * @returns {Promise&lt;NextResponse&gt;} A response object indicating the success of the dry run and its results.
 * @description
 *   - Utilizes the BatchCleanupService to simulate cleanup operations.
 *   - Ensures no changes are made to the database during the dry run.
 *   - Provides details of simulated operations in the response result.
 */
export declare function handleDryRun(options: DataCleanupRequestBody['options']): Promise&lt;NextResponse&gt;;
/**
* Returns the current status with details on available operations, default batch size, and dry-run support.
* @example
* handleGetStatus()
* returns a JSON response with success status and operational details
* @returns {NextResponse} JSON response containing operation details.
* @description
*   - Lists available operations such as 'remove_placeholders', 'normalize_phone', and more.
*   - Provides default batch size set to 50.
*   - Indicates support for dry-run operations.
*/
export declare function handleGetStatus(): NextResponse;
/**
 * Generates a preview of the batch cleanup process.
 * @example
 * handleGetPreview()
 * Promise&lt;NextResponse&gt;
 * @returns {Promise&lt;NextResponse&gt;} Returns a JSON response containing the cleanup preview.
 * @description
 *   - Utilizes the BatchCleanupService to execute a dry run with a specified batch size.
 *   - Extracts summary information including estimated improvements and duplicates removed.
 *   - Structures the operations in a detailed format for review.
 */
export declare function handleGetPreview(): Promise&lt;NextResponse&gt;;
/**
* Provides a JSON response containing available endpoints and actions related to data cleanup.
* @example
* handleGetDefault()
* Returns a JSON response with success status, endpoints, and actions.
* @returns {NextResponse} Returns a JSON response with structure defining success, endpoints, and actions related to data cleanup.
* @description
*   - The function targets administrative cleanup operations within the system.
*   - Provides metadata for functionalities aimed at data cleanup processes.
*   - Intended to support endpoint consumption and decision-making for administrative tasks.
*/
export declare function handleGetDefault(): NextResponse;</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/api/admin/automated-cleanup/handlers.d.ts (Line 1:1 - Line 26:4), C:/AI/food-truck-finder-poc/dist/lib/lib/api/admin/automated-cleanup/handlers.d.ts (Line 1:1 - Line 26:13)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn138" onclick="toggleCodeBlock('cloneGroup138', 'expandBtn138', 'collapseBtn138')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn138" onclick="toggleCodeBlock('cloneGroup138', 'expandBtn138', 'collapseBtn138')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup138"><code class="language-typescript text-sm text-gray-800">import { NextResponse } from 'next/server';
interface RunScheduledOptions {
    scheduleId: string;
}
interface RunImmediateOptions {
    operations?: string[];
    batchSize?: number;
    dryRun?: boolean;
}
interface ScheduleCleanupOptions {
    name: string;
    operations: string[];
    schedule: string;
    enabled?: boolean;
}
interface UpdateScheduleOptions {
    scheduleId: string;
    updates: Record&lt;string, unknown&gt;;
}
interface DeleteScheduleOptions {
    scheduleId: string;
}
export declare function handlePostRequest(body: {
    action: string;
    options?: Record&lt;string, unknown&gt;;
}): Promise&lt;any</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/api/admin/automated-cleanup/handlers.d.ts (Line 26:2 - Line 63:2), C:/AI/food-truck-finder-poc/dist/lib/lib/api/admin/automated-cleanup/handlers.d.ts (Line 26:3 - Line 63:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn139" onclick="toggleCodeBlock('cloneGroup139', 'expandBtn139', 'collapseBtn139')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn139" onclick="toggleCodeBlock('cloneGroup139', 'expandBtn139', 'collapseBtn139')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup139"><code class="language-typescript text-sm text-gray-800">;
export declare function handleGetStatus(): Promise&lt;NextResponse&gt;;
export declare function handleGetSchedules(): Promise&lt;NextResponse&gt;;
export declare function handleGetHistory(searchParams: URLSearchParams): Promise&lt;NextResponse&gt;;
export declare function handleGetPreview(searchParams: URLSearchParams): Promise&lt;NextResponse&gt;;
/**
 * Handles the retrieval of default cleanup status and returns a JSON response.
 * @example
 * handleGetDefault().then(response =&gt; console.log(response));
 * // { success: true, status: ..., endpoints: [...] }
 * @param {none} {none} - No arguments are required for this function.
 * @returns {Promise&lt;NextResponse&gt;} A promise that resolves to a NextResponse JSON object containing cleanup status and endpoints.
 * @description
 *   - Utilizes the getCleanupStatus function to fetch the current cleanup status.
 *   - Constructs a response object detailing available cleanup-related endpoints.
 *   - Follow API endpoint descriptions to properly utilize cleanup functionalities.
 */
export declare function handleGetDefault(): Promise&lt;NextResponse&gt;;
export declare function handleRunScheduled(options: RunScheduledOptions): Promise&lt;NextResponse&gt;;
/**
* Executes a batch cleanup operation immediately based on provided options.
* @example
* handleRunImmediate({ dryRun: true, batchSize: 100 })
* Returns: { success: true, action: 'run_immediate', result: {...}, message: 'Dry run completed successfully' }
* @param {Object} options - Configuration options for the cleanup operation.
* @returns {Promise&lt;NextResponse&gt;} A promise that resolves to the NextResponse object containing the cleanup result.
* @description
*   - The `operations` parameter defaults to a set of predefined cleanup tasks if not specified.
*   - If `dryRun` is true, the function simulates the cleanup without making any modifications.
*   - Utilizes `BatchCleanupService` for executing the cleanup logic.
*   - Operation results are logged with `logCleanupOperation` for tracking purposes.
*/
export declare function handleRunImmediate(options: RunImmediateOptions): Promise&lt;NextResponse&gt;;
export declare function handleScheduleCleanup(options: ScheduleCleanupOptions): Promise&lt;NextResponse&gt;;
export declare function handleUpdateSchedule(options: UpdateScheduleOptions): Promise&lt;NextResponse&gt;;
export declare function handleDeleteSchedule(options: DeleteScheduleOptions): Promise&lt;NextResponse&gt;;
export declare function handleAnalyzeDuplicates(options: Record&lt;string, unknown&gt;): Promise&lt;NextResponse&gt;;
export {};</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/app/api/admin/realtime-events/route.ts (Line 41:30 - Line 54:2), C:/AI/food-truck-finder-poc/app/api/admin/realtime-events/route.ts (Line 17:29 - Line 30:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn140" onclick="toggleCodeBlock('cloneGroup140', 'expandBtn140', 'collapseBtn140')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn140" onclick="toggleCodeBlock('cloneGroup140', 'expandBtn140', 'collapseBtn140')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup140"><code class="language-typescript text-sm text-gray-800">, error);
    return new Response(
      JSON.stringify({
        success: false,
        error: 'Internal server error',
        details: error instanceof Error ? error.message : 'Unknown error',
      }),
      {
        status: 500,
        headers: { 'Content-Type': 'application/json' },
      },
    );
  }
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/api/test-integration/helpers.ts (Line 59:1 - Line 95:6), C:/AI/food-truck-finder-poc/dist/lib/lib/api/test-integration/helpers.d.ts (Line 22:1 - Line 55:7)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn149" onclick="toggleCodeBlock('cloneGroup149', 'expandBtn149', 'collapseBtn149')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn149" onclick="toggleCodeBlock('cloneGroup149', 'expandBtn149', 'collapseBtn149')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup149"><code class="language-typescript text-sm text-gray-800">type GeminiProcessMenuDataResult = MenuCategory[];

interface SupabaseTestResults {
  testTruck: FoodTruck;
  testJob: ScrapingJob;
  queueItem: DataProcessingQueue;
  nearbyTrucks: FoodTruck[];
}

interface FormattedTestResults {
  success: boolean;
  message: string;
  results: {
    firecrawl: {
      success: boolean;
      dataLength: number;
    };
    gemini: {
      success: boolean;
      tokensUsed: number | undefined;
      categoriesFound: number;
    };
    supabase: {
      truckCreated: string;
      jobCreated: string;
      queueItemCreated: string;
      nearbyTrucksFound: number;
    };
  };
  testData: {
    truck: FoodTruck;
    processedMenu: MenuCategory[] | undefined;
    nearbyTrucks: FoodTruck[];
  };
}

async</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/api/search/helpers.ts (Line 15:2 - Line 22:2), C:/AI/food-truck-finder-poc/dist/lib/api/search/helpers.d.ts (Line 8:2 - Line 15:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn152" onclick="toggleCodeBlock('cloneGroup152', 'expandBtn152', 'collapseBtn152')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn152" onclick="toggleCodeBlock('cloneGroup152', 'expandBtn152', 'collapseBtn152')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup152"><code class="language-typescript text-sm text-gray-800">function processSearchRequest({ query, cuisine, openNow, lat, lng, radius }: {
  query: string | null;
  cuisine: string | null;
  openNow: boolean;
  lat: string | null;
  lng: string | null;
  radius: string | null;
}) {</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/api/scheduler/types.ts (Line 1:1 - Line 22:2), C:/AI/food-truck-finder-poc/dist/lib/lib/api/scheduler/types.d.ts (Line 1:1 - Line 20:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn156" onclick="toggleCodeBlock('cloneGroup156', 'expandBtn156', 'collapseBtn156')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn156" onclick="toggleCodeBlock('cloneGroup156', 'expandBtn156', 'collapseBtn156')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup156"><code class="language-typescript text-sm text-gray-800">export interface SchedulerTask {
  id: string;
  name: string;
  enabled: boolean;
  intervalMinutes: number;
  lastRun: string;
  lastSuccess: string;
  successCount: number;
  errorCount: number;
  nextRun: string | undefined;
  lastError?: string;
}

export interface PostRequestBody {
  action: 'start' | 'stop' | 'execute';
  taskId?: string;
}

export interface PutRequestBody {
  taskId: string;
  config: Partial&lt;SchedulerTask&gt;;
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/api/pipeline/types.ts (Line 1:1 - Line 12:18), C:/AI/food-truck-finder-poc/dist/lib/lib/api/pipeline/types.d.ts (Line 1:1 - Line 12:9)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn164" onclick="toggleCodeBlock('cloneGroup164', 'expandBtn164', 'collapseBtn164')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn164" onclick="toggleCodeBlock('cloneGroup164', 'expandBtn164', 'collapseBtn164')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup164"><code class="language-typescript text-sm text-gray-800">export interface PipelineRequestBody {
  action?: 'discovery' | 'processing' | 'full' | 'maintenance';
  target_url?: string;
  config?: {
    maxUrls?: number;
    maxUrlsToProcess?: number;
    targetCities?: string[];
    priority?: number;
    skipDiscovery?: boolean;
    retryFailedJobs?: boolean;
  };
  // Legacy support</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/lib/utils/typeGuards.d.ts (Line 1:14 - Line 42:2), C:/AI/food-truck-finder-poc/dist/lib/lib/utils/typeGuards.d.ts (Line 1:11 - Line 42:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn170" onclick="toggleCodeBlock('cloneGroup170', 'expandBtn170', 'collapseBtn170')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn170" onclick="toggleCodeBlock('cloneGroup170', 'expandBtn170', 'collapseBtn170')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup170"><code class="language-typescript text-sm text-gray-800">;
/**
 * Checks if a value is a non-null object.
 */
export declare function isValidObject(value: unknown): value is Record&lt;string, unknown&gt;;
/**
 * Safely checks if an object has a specific property. This is a robust implementation.
 */
export declare function hasProperty&lt;T extends object&gt;(obj: T, prop: PropertyKey): prop is keyof T;
/**
 * Checks if a value is a string.
 */
export declare function isString(value: unknown): value is string;
/**
 * Checks if a value is a valid number (and not NaN).
 */
export declare function isNumber(value: unknown): value is number;
/**
 * Checks if a value is an array.
 */
export declare function isArray(value: unknown): value is unknown[];
/**
 * Checks if a value is an array of strings.
 */
export declare function isStringArray(value: unknown): value is string[];
/**
 * Asserts that a value is of a specific type, throwing a TypeError if validation fails.
 */
export declare function assertType&lt;T&gt;(value: unknown, validator: (v: unknown) =&gt; v is T, errorMessage?: string): asserts value is T;
/**
 * Safely assigns a value if it passes validation, otherwise returns a fallback.
 * Useful for providing default values for potentially invalid or missing data.
 */
export declare function safeAssign&lt;T&gt;(value: unknown, fallback: T, validator: (v: unknown) =&gt; v is T): T;
/**
 * Type guard for the base FoodTruckSchema.
 */
export declare function isFoodTruckSchema(value: unknown): value is FoodTruckSchema;
/**
 * Type guard for the full FoodTruck object (schema + ID fields).
 */
export declare function isFoodTruck(value: unknown): value is FoodTruck;</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/lib/utils/QualityScorer.d.ts (Line 1:1 - Line 40:2), C:/AI/food-truck-finder-poc/dist/lib/lib/utils/QualityScorer.d.ts (Line 1:1 - Line 40:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn172" onclick="toggleCodeBlock('cloneGroup172', 'expandBtn172', 'collapseBtn172')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn172" onclick="toggleCodeBlock('cloneGroup172', 'expandBtn172', 'collapseBtn172')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup172"><code class="language-typescript text-sm text-gray-800">import type { FoodTruck } from '@/lib/supabase';
export interface QualityAssessment {
    score: number;
    issues: string[];
}
export type QualityCategory = {
    label: string;
    color: string;
};
/**
 * Computes the quality score of a given food truck based on multiple criteria.
 * @example
 * calculateQualityScore(truckInstance)
 * { score: 3, issues: [&quot;Missing contact information&quot;, &quot;Incomplete schedule&quot;] }
 * @param {FoodTruck} truck - The food truck object to be assessed.
 * @returns {QualityAssessment} An object containing the computed score and a list of identified issues.
 * @description
 *   - The score starts at 1 and is adjusted based on various assessments.
 *   - The function ensures the score never drops below zero.
 *   - Issues that affect the score are collected and returned for analysis.
 */
export declare function calculateQualityScore(truck: FoodTruck): QualityAssessment;
export declare function categorizeQualityScore(score: number): QualityCategory;
export declare function formatQualityScore(score: number | null | undefined): string;
export declare function getQualityBadgeClasses(score: number | null | undefined): string;
export declare function getQualityScoreAriaLabel(score: number | null | undefined): string;
export declare const DataQualityService: {
    calculateQualityScore: typeof calculateQualityScore;
    categorizeQualityScore: typeof categorizeQualityScore;
    formatQualityScore: typeof formatQualityScore;
    getQualityBadgeClasses: typeof getQualityBadgeClasses;
    getQualityScoreAriaLabel: typeof getQualityScoreAriaLabel;
    batchUpdateQualityScores(limit?: number): Promise&lt;{
        updatedCount: number;
        errors: string[];
    }&gt;;
    updateTruckQualityScore(truckId: string): Promise&lt;{
        success: boolean;
    }&gt;;
};</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/lib/utils/geocoding.d.ts (Line 1:1 - Line 32:2), C:/AI/food-truck-finder-poc/dist/lib/lib/utils/geocoding.d.ts (Line 1:1 - Line 32:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn174" onclick="toggleCodeBlock('cloneGroup174', 'expandBtn174', 'collapseBtn174')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn174" onclick="toggleCodeBlock('cloneGroup174', 'expandBtn174', 'collapseBtn174')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup174"><code class="language-typescript text-sm text-gray-800">/**
 * Geocoding utilities using Nominatim (OpenStreetMap's free geocoding service)
 * Converts addresses to lat/lng coordinates for map display
 */
interface GeocodeResult {
    lat: number;
    lng: number;
    formatted_address: string;
    success: boolean;
}
/**
 * Geocodes an address to get latitude and longitude coordinates
 * @param address - The address to geocode
 * @param city - Optional city to improve accuracy (defaults to Charleston, SC)
 * @returns Promise containing coordinates and formatted address
 */
export declare function geocodeAddress(address: string, city?: string): Promise&lt;GeocodeResult&gt;;
/**
 * Fallback coordinates for Charleston, SC when geocoding fails
 */
export declare const CHARLESTON_FALLBACK: {
    lat: number;
    lng: number;
};
/**
 * Geocodes multiple addresses with rate limiting to avoid overwhelming the service
 * @param addresses - Array of addresses to geocode
 * @param delayMs - Delay between requests (default 1000ms as recommended by Nominatim)
 * @returns Promise array of geocoding results
 */
export declare function geocodeAddressesBatch(addresses: string[], delayMs?: number): Promise&lt;GeocodeResult[]&gt;;
export {};</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/lib/utils/foodTruckHelpers.d.ts (Line 1:1 - Line 31:4), C:/AI/food-truck-finder-poc/dist/lib/lib/utils/foodTruckHelpers.d.ts (Line 2:1 - Line 32:20)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn176" onclick="toggleCodeBlock('cloneGroup176', 'expandBtn176', 'collapseBtn176')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn176" onclick="toggleCodeBlock('cloneGroup176', 'expandBtn176', 'collapseBtn176')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup176"><code class="language-typescript text-sm text-gray-800">export declare const getCurrentDay: () =&gt; string;
export declare const formatPrice: (price: number | string) =&gt; string;
/**
* Converts operational hours to a readable format or returns 'Closed' if applicable.
* @example
* formatOperatingHours({ open: '09:00', close: '17:00', closed: false })
* '9:00 AM - 5:00 PM'
* @param {DailyOperatingHours} hours - Object containing daily opening and closing times, and closed status.
* @returns {string} Formatted operating hours string or 'Closed'.
* @description
*   - Handles conversion of military time to 12-hour format.
*   - Adjusts for typical date parsing without relying on actual date due to fixed date string.
*   - Properly responds to 'closed' status by returning 'Closed'.
*   - Locales can impact formatted output by changing time conventions.
*/
export declare const formatHours: (hours: DailyOperatingHours) =&gt; string;
export declare const getPopularItems: (truck: FoodTruck) =&gt; MenuItem[];
/**
 * Calculates the price range of all items in the food truck's menu.
 * @example
 * getPriceRange(foodTruck)
 * &quot;5.00 - 12.50&quot;
 * @param {FoodTruck} truck - The food truck object containing menu details.
 * @returns {string} Returns a formatted string representing the price range or 'N/A' if no valid prices are found.
 * @description
 *   - Utilizes the optional chaining operator to safely access nested menu items.
 *   - Filters out non-numeric and undefined prices before calculating the range.
 *   - Formats the minimum and maximum prices using a helper function.
 */
export declare const getPriceRange: (truck: FoodTruck) =&gt; string;
export declare const getTodayHours: (truck: FoodTruck) =&gt; any</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/lib/utils/foodTruckHelpers.d.ts (Line 31:4 - Line 106:2), C:/AI/food-truck-finder-poc/dist/lib/lib/utils/foodTruckHelpers.d.ts (Line 32:20 - Line 107:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn177" onclick="toggleCodeBlock('cloneGroup177', 'expandBtn177', 'collapseBtn177')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn177" onclick="toggleCodeBlock('cloneGroup177', 'expandBtn177', 'collapseBtn177')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup177"><code class="language-typescript text-sm text-gray-800">;
/**
 * Retrieves the user's geolocation and updates the location state.
 * @example
 * getUserLocationHelper(setUserLocation)
 * // Updates user's location or defaults to San Francisco
 * @param {function} setUserLocation - Callback function to update user's location state with latitude and longitude.
 * @returns {void} Function does not return anything.
 * @description
 *   - Defaults the location to San Francisco if geolocation access is denied or not supported.
 *   - Utilizes browser's geolocation API to fetch current coordinates.
 *   - Provides a warning in the console if location access is denied.
 */
export declare function getUserLocationHelper(setUserLocation: (location: {
    lat: number;
    lng: number;
}) =&gt; void): void;
/**
 * Loads food truck data from the server and updates state.
 * @example
 * loadFoodTrucksHelper(setTrucks, setLoading)
 * undefined
 * @param {(trucks: FoodTruck[]) =&gt; void} setTrucks - Callback to update the state with loaded food trucks.
 * @param {(loading: boolean) =&gt; void} setLoading - Callback to update the loading state.
 * @returns {void} No return value.
 * @description
 *   - Fetches data from '/api/trucks' endpoint.
 *   - Parses the response and expects an object containing a 'trucks' array.
 *   - Logs an error message to the console if fetching or parsing fails.
 *   - Ensures loading state is updated to false in all cases.
 */
export declare function loadFoodTrucksHelper(setTrucks: (trucks: FoodTruck[]) =&gt; void, setLoading: (loading: boolean) =&gt; void): Promise&lt;void&gt;;
/**
* Loads nearby food trucks based on user's location.
* @example
* loadNearbyTrucksHelper({ lat: 37.7749, lng: -122.4194 }, setTrucksCallback)
* // sets trucks with food truck data or an empty array
* @param {{ lat: number; lng: number } | undefined} userLocation - The location of the user used to find nearby trucks.
* @param {(trucks: FoodTruck[]) =&gt; void} setTrucks - Callback function to set the trucks data.
* @returns {void} No return value.
* @description
*   - Fetches nearby trucks from the API using latitude and longitude.
*   - Uses a fixed radius of 10 units for truck search.
*   - Handles errors by logging them to the console.
*/
export declare function loadNearbyTrucksHelper(userLocation: {
    lat: number;
    lng: number;
} | undefined, setTrucks: (trucks: FoodTruck[]) =&gt; void): Promise&lt;void&gt;;
/**
 * Determines if a food truck has enough essential data to be displayed to users.
 * @example
 * isViableTruck(foodTruck)
 * // returns true if truck has name and location, false otherwise
 * @param {FoodTruck} truck - The food truck object to validate.
 * @returns {boolean} Indicates whether the truck should be displayed.
 * @description
 *   - Checks for minimum required fields: name and valid location coordinates.
 *   - Ensures location has either coordinates OR a meaningful address.
 *   - Flags trucks missing essential data for admin review.
 */
export declare function isViableTruck(truck: FoodTruck): boolean;
/**
 * Determines if the food truck is currently open based on its operating hours.
 * @example
 * isTruckOpen(myFoodTruck)
 * // returns true or false depending on current time and truck's operating hours
 * @param {FoodTruck} truck - The food truck object with operating hours.
 * @returns {boolean} Indicates whether the truck is open.
 * @description
 *   - Utilizes the current day's name to fetch operating hours.
 *   - Handles potential errors in parsing operating hours.
 *   - Logs errors related to parsing time and truck name.
 *   - Uses military time format (HHMM) for comparison.
 */
export declare function isTruckOpen(truck: FoodTruck): boolean;</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/lib/utils/dataQualityFormatters.d.ts (Line 1:1 - Line 112:2), C:/AI/food-truck-finder-poc/dist/lib/lib/utils/dataQualityFormatters.d.ts (Line 1:1 - Line 112:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn179" onclick="toggleCodeBlock('cloneGroup179', 'expandBtn179', 'collapseBtn179')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn179" onclick="toggleCodeBlock('cloneGroup179', 'expandBtn179', 'collapseBtn179')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup179"><code class="language-typescript text-sm text-gray-800">/**
 * SOTA Data Quality Formatting Utilities
 * Provides consistent formatting and categorization for data quality metrics
 */
export interface QualityThresholds {
    high: number;
    medium: number;
    low: number;
}
export interface QualityCategory {
    label: 'High' | 'Medium' | 'Low';
    color: string;
    bgColor: string;
    textColor: string;
}
export declare const QUALITY_THRESHOLDS: QualityThresholds;
export declare const QUALITY_CATEGORIES: Record&lt;string, QualityCategory&gt;;
/**
 * Formats a quality score as a percentage with proper precision
 * @param score - Quality score (0-1 range)
 * @param precision - Number of decimal places (default: 1)
 * @returns Formatted percentage string
 */
export declare function formatQualityScore(score: number | null | undefined, precision?: number): string;
/**
 * Categorizes a quality score into high/medium/low categories
 * @param score - Quality score (0-1 range)
 * @returns Quality category object
 */
export declare function categorizeQualityScore(score: number | null | undefined): QualityCategory;
/**
 * Gets the appropriate CSS classes for a quality score badge
 * @param score - Quality score (0-1 range)
 * @returns CSS class string for badge styling
 */
export declare function getQualityBadgeClasses(score: number | null | undefined): string;
/**
 * Calculates quality score trend indicator
 * @param currentScore - Current quality score
 * @param previousScore - Previous quality score
 * @returns Trend object with direction and percentage change
 */
export declare function calculateQualityTrend(currentScore: number | null | undefined, previousScore: number | null | undefined): {
    direction: 'up' | 'down' | 'stable' | 'unknown';
    change: number;
    changeText: string;
};
/**
 * Generates quality improvement suggestions based on score
 * @param score - Quality score (0-1 range)
 * @returns Array of improvement suggestions
 */
export declare function getQualityImprovementSuggestions(score: number | null | undefined): string[];
/**
 * Formats quality statistics for display
 * @param stats - Raw quality statistics from database
 * @returns Formatted statistics object
 */
export declare function formatQualityStats(stats: {
    total_trucks: number;
    avg_quality_score: number;
    high_quality_count: number;
    medium_quality_count: number;
    low_quality_count: number;
    verified_count: number;
    pending_count: number;
    flagged_count: number;
}): {
    totalTrucks: number;
    averageScore: string;
    averageScoreRaw: number;
    distribution: {
        high: {
            count: number;
            percentage: string;
        };
        medium: {
            count: number;
            percentage: string;
        };
        low: {
            count: number;
            percentage: string;
        };
    };
    verification: {
        verified: {
            count: number;
            percentage: string;
        };
        pending: {
            count: number;
            percentage: string;
        };
        flagged: {
            count: number;
            percentage: string;
        };
    };
};
/**
 * Validates if a quality score is within acceptable range
 * @param score - Quality score to validate
 * @returns Boolean indicating if score is valid
 */
export declare function isValidQualityScore(score: number | null | undefined): boolean;
/**
 * Generates accessibility-friendly description for quality score
 * @param score - Quality score (0-1 range)
 * @returns Screen reader friendly description
 */
export declare function getQualityScoreAriaLabel(score: number | null | undefined): string;</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/lib/security/rateLimiter.d.ts (Line 1:1 - Line 78:2), C:/AI/food-truck-finder-poc/dist/lib/lib/security/rateLimiter.d.ts (Line 1:1 - Line 78:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn182" onclick="toggleCodeBlock('cloneGroup182', 'expandBtn182', 'collapseBtn182')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn182" onclick="toggleCodeBlock('cloneGroup182', 'expandBtn182', 'collapseBtn182')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup182"><code class="language-typescript text-sm text-gray-800">/**
 * SOTA Rate Limiting Implementation
 * Prevents brute force attacks and API abuse with intelligent rate limiting
 */
export declare const RATE_LIMIT_CONFIGS: {
    readonly auth: {
        readonly windowMs: number;
        readonly maxRequests: 5;
        readonly blockDurationMs: number;
        readonly skipSuccessfulRequests: true;
    };
    readonly api: {
        readonly windowMs: number;
        readonly maxRequests: 60;
        readonly blockDurationMs: number;
        readonly skipSuccessfulRequests: false;
    };
    readonly admin: {
        readonly windowMs: number;
        readonly maxRequests: 20;
        readonly blockDurationMs: number;
        readonly skipSuccessfulRequests: false;
    };
};
export type RateLimitType = keyof typeof RATE_LIMIT_CONFIGS;
/**
 * Rate Limiter Service
 */
export declare class RateLimiter {
    private static isBlocked;
    private static resetEntry;
    /**
     * Check if request should be rate limited
     */
    static checkRateLimit(identifier: string, type?: RateLimitType): {
        allowed: boolean;
        remaining: number;
        resetTime: number;
        retryAfter?: number;
    };
    /**
     * Record successful request (for auth endpoints)
     */
    static recordSuccess(identifier: string, type?: RateLimitType): void;
    /**
     * Get rate limit status without incrementing
     */
    static getStatus(identifier: string, type?: RateLimitType): {
        remaining: number;
        resetTime: number;
        blocked: boolean;
        retryAfter?: number;
    };
    /**
     * Clean up expired entries to prevent memory leaks
     */
    private static cleanupExpiredEntries;
    /**
     * Clear all rate limit data for an identifier
     */
    static clearLimits(identifier: string, type?: RateLimitType): void;
    /**
     * Get rate limit statistics
     */
    static getStats(): {
        totalEntries: number;
        blockedEntries: number;
        entriesByType: Record&lt;string, number&gt;;
    };
}
/**
 * Utility function to get client identifier from request
 */
export declare function getClientIdentifier(request: Request): string;
/**
 * Rate limiting middleware for API routes
 */
export declare function withRateLimit(handler: (request: Request) =&gt; Promise&lt;Response&gt;, type?: RateLimitType): (request: Request) =&gt; Promise&lt;Response&gt;;</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/lib/security/auditLogger.d.ts (Line 1:1 - Line 109:2), C:/AI/food-truck-finder-poc/dist/lib/lib/security/auditLogger.d.ts (Line 1:1 - Line 109:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn184" onclick="toggleCodeBlock('cloneGroup184', 'expandBtn184', 'collapseBtn184')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn184" onclick="toggleCodeBlock('cloneGroup184', 'expandBtn184', 'collapseBtn184')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup184"><code class="language-typescript text-sm text-gray-800">/**
 * SOTA Security Audit Logging System
 * Implements comprehensive audit logging for admin actions and security events
 */
type SeverityLevel = 'info' | 'warning' | 'error' | 'critical';
export interface AuditLogEntry {
    user_id: string;
    user_email: string;
    action: string;
    resource_type: string;
    resource_id?: string;
    details?: Record&lt;string, unknown&gt;;
    ip_address?: string;
    user_agent?: string;
    session_id?: string;
    timestamp: string;
    severity: SeverityLevel;
}
export interface SecurityEvent {
    event_type: 'login_attempt' | 'login_success' | 'login_failure' | 'logout' | 'permission_denied' | 'data_access' | 'data_modification' | 'admin_action';
    user_id?: string;
    user_email?: string;
    ip_address?: string;
    user_agent?: string;
    details?: Record&lt;string, unknown&gt;;
    severity: SeverityLevel;
}
/**
 * Audit Logger Service
 */
export declare class AuditLogger {
    /**
     * Log admin action with full audit trail
     */
    static logAdminAction(options: {
        userId: string;
        userEmail: string;
        action: string;
        resourceType: string;
        resourceId?: string;
        details?: Record&lt;string, unknown&gt;;
        request?: {
            ip?: string;
            userAgent?: string;
            sessionId?: string;
        };
    }): Promise&lt;void&gt;;
    /**
     * Log security event
     */
    static logSecurityEvent(event: SecurityEvent): Promise&lt;void&gt;;
    /**
     * Log authentication events
     */
    static logAuthEvent(options: {
        eventType: 'login_attempt' | 'login_success' | 'login_failure' | 'logout';
        userEmail?: string;
        userId?: string;
        request?: {
            ip?: string;
            userAgent?: string;
        };
        details?: Record&lt;string, unknown&gt;;
    }): Promise&lt;void&gt;;
    /**
     * Log data access events
     */
    static logDataAccess(options: {
        userId: string;
        userEmail: string;
        resourceType: string;
        resourceId?: string;
        action?: 'read' | 'search' | 'export' | 'admin_access';
        request?: {
            ip?: string;
            userAgent?: string;
        };
    }): Promise&lt;void&gt;;
    /**
     * Write audit log to database
     */
    private static writeAuditLog;
    /**
     * Determine severity based on action and resource type
     */
    private static determineSeverity;
    /**
     * Get audit logs for a specific user
     */
    static getUserAuditLogs(userId: string, limit?: number, offset?: number): Promise&lt;AuditLogEntry[]&gt;;
    /**
     * Get recent security events
     */
    static getRecentSecurityEvents(hours?: number, severity?: SeverityLevel): Promise&lt;Record&lt;string, unknown&gt;[]&gt;;
}
/**
 * Security monitoring utilities
 */
export declare const SecurityMonitor: {
    /**
     * Check for suspicious activity patterns
     */
    checkSuspiciousActivity(userId: string): Promise&lt;{
        suspicious: boolean;
        reasons: string[];
        riskLevel: &quot;low&quot; | &quot;medium&quot; | &quot;high&quot;;
    }&gt;;
};
export {};</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/lib/pipeline/pipelineHelpers.d.ts (Line 2:17 - Line 66:2), C:/AI/food-truck-finder-poc/dist/lib/lib/pipeline/pipelineHelpers.d.ts (Line 2:14 - Line 66:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn189" onclick="toggleCodeBlock('cloneGroup189', 'expandBtn189', 'collapseBtn189')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn189" onclick="toggleCodeBlock('cloneGroup189', 'expandBtn189', 'collapseBtn189')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup189"><code class="language-typescript text-sm text-gray-800">;
/**
 * Validates input data and prepares food truck information.
 * @example
 * validateInputAndPrepare('job123', extractedTruckDataInstance, 'http://sourceurl.com')
 * { isValid: true, name: 'Food Truck Name' }
 * @param {string} jobId - The job identifier used for logging and job status updates.
 * @param {ExtractedFoodTruckDetails} extractedTruckData - Contains details about the food truck such as name and other attributes.
 * @param {string} sourceUrl - URL where the data was originally extracted from.
 * @returns {Promise&lt;{ isValid: boolean; name: string }&gt;} Result of validation with food truck name.
 * @description
 *   - Logs a warning if the source URL is missing, but continues process as it might not be critical.
 *   - Ensures the food truck name has a fallback value if it's missing in the extracted data.
 *   - Updates job status as 'failed' if validation does not pass.
 */
export declare function validateInputAndPrepare(jobId: string, extractedTruckData: ExtractedFoodTruckDetails, sourceUrl: string): Promise&lt;{
    isValid: boolean;
    name: string;
}&gt;;
/**
 * Constructs a FoodTruckSchema object from extracted food truck details.
 * @example
 * buildTruckDataSchema(extractedTruckData, 'http://sourceUrl.com', 'Truck Name')
 * { name: 'Truck Name', ... }
 * @param {ExtractedFoodTruckDetails} extractedTruckData - Object containing raw data extracted from a food truck resource.
 * @param {string} sourceUrl - URL source where the truck data was extracted from.
 * @param {string} name - Name of the food truck.
 * @returns {FoodTruckSchema} Fully constructed food truck schema ready for use.
 * @description
 *   - Ensures `description` and `price_range` are kept undefined if missing or null from extracted data.
 *   - Filters any non-string values from the `cuisine_type` array.
 *   - Ensures the `source_urls` field is always an array, even if empty or undefined.
 *   - Default verification status is 'pending' and a default data quality score is set to 0.5.
 */
export declare function buildTruckDataSchema(extractedTruckData: ExtractedFoodTruckDetails, sourceUrl: string, name: string): FoodTruckSchema;
/**
 * Checks for duplicates before creating a new food truck entry.
 * @example
 * handleDuplicateCheck('12345', truckDataObject, 'Awesome Food Truck')
 * // Returns a promise resolving to the created truck object or result from handling a duplicate.
 * @param {string} jobId - The unique identifier for the job process.
 * @param {FoodTruckSchema} truckData - The data schema representing the food truck details.
 * @param {string} name - The name of the food truck being processed.
 * @returns {Promise&lt;FoodTruck&gt;} Returns a promise that resolves to the created or existing food truck.
 * @description
 *   - Utilizes the DuplicatePreventionService to verify if a similar truck already exists.
 *   - If a duplicate is detected, delegates to a separate function to handle the duplicate scenario.
 *   - Logs errors encountered during the creation process.
 */
export declare function handleDuplicateCheck(jobId: string, truckData: FoodTruckSchema, name: string): Promise&lt;FoodTruck&gt;;
/**
* Logs the successful creation of a food truck and updates the job status to completed.
* @example
* finalizeJobStatus('12345', { name: 'Best Food Truck', id: 'FT123' }, 'http://example.com')
* // Logs: Job 12345: Successfully created food truck: Best Food Truck (ID: FT123) from http://example.com
* @param {string} jobId - Unique identifier of the scraping job.
* @param {FoodTruck} truck - Object representing the food truck that was created.
* @param {string} sourceUrl - URL from where the data was sourced.
* @returns {Promise&lt;void&gt;} Resolves when the job status is updated.
* @description
*   - Logs the truck creation event using `console.info`.
*   - Ensures the job status is set to 'completed' with the current timestamp.
*   - Uses a default source message if sourceUrl is not provided.
*/
export declare function finalizeJobStatus(jobId: string, truck: FoodTruck, sourceUrl: string): Promise&lt;void&gt;;</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/lib/performance/webVitals.d.ts (Line 1:1 - Line 90:2), C:/AI/food-truck-finder-poc/dist/lib/lib/performance/webVitals.d.ts (Line 1:1 - Line 90:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn191" onclick="toggleCodeBlock('cloneGroup191', 'expandBtn191', 'collapseBtn191')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn191" onclick="toggleCodeBlock('cloneGroup191', 'expandBtn191', 'collapseBtn191')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup191"><code class="language-typescript text-sm text-gray-800">/**
 * SOTA Core Web Vitals Monitoring Implementation
 * Tracks LCP, FID, CLS, FCP, and TTFB metrics for performance optimization
 */
export declare const PERFORMANCE_THRESHOLDS: {
    readonly LCP: {
        readonly good: 2500;
        readonly needsImprovement: 4000;
    };
    readonly FID: {
        readonly good: 100;
        readonly needsImprovement: 300;
    };
    readonly CLS: {
        readonly good: 0.1;
        readonly needsImprovement: 0.25;
    };
    readonly FCP: {
        readonly good: 1800;
        readonly needsImprovement: 3000;
    };
    readonly TTFB: {
        readonly good: 800;
        readonly needsImprovement: 1800;
    };
};
export type MetricName = keyof typeof PERFORMANCE_THRESHOLDS;
export interface PerformanceMetric {
    name: MetricName;
    value: number;
    rating: 'good' | 'needs-improvement' | 'poor';
    timestamp: number;
    url: string;
    userAgent: string;
}
/**
 * Initializes Core Web Vitals monitoring
 * Call this in your app's root component or _app.tsx
 */
export declare function initWebVitalsMonitoring(): void;
/**
 * Gets current performance metrics summary
 */
export declare function getPerformanceMetrics(): {
    metrics: PerformanceMetric[];
    summary: Record&lt;MetricName, {
        latest: number | null;
        average: number;
        rating: 'good' | 'needs-improvement' | 'poor' | 'no-data';
        count: number;
    }&gt;;
};
/**
 * Performance budget checker
 */
export declare function checkPerformanceBudget(): {
    passed: boolean;
    violations: Array&lt;{
        metric: MetricName;
        value: number;
        threshold: number;
        severity: 'warning' | 'critical';
    }&gt;;
};
/**
 * Performance optimization suggestions based on metrics
 */
type PerformanceSuggestion = {
    metric: MetricName;
    issue: string;
    suggestions: string[];
    priority: 'high' | 'medium' | 'low';
};
/**
 * Generates a list of performance optimization suggestions based on Web Vitals metrics.
 * @example
 * getPerformanceOptimizationSuggestions()
 * [
 *   { name: 'Optimize LCP', priority: 'high' },
 *   { name: 'Improve FID', priority: 'medium' }
 * ]
 * @returns {PerformanceSuggestion[]} An array of performance suggestions sorted by priority.
 * @description
 *   - Analyzes performance metrics including LCP, FID, CLS, FCP, and TTFB.
 *   - Generates suggestions only for metrics rated as 'poor' or 'needs-improvement'.
 *   - Prioritizes suggestions based on urgency, sorting them by priority level.
 *   - Utilizes helper functions to generate specific suggestions for each metric type.
 */
export declare function getPerformanceOptimizationSuggestions(): PerformanceSuggestion[];
export {};</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/lib/performance/databaseCache.d.ts (Line 1:1 - Line 65:2), C:/AI/food-truck-finder-poc/dist/lib/lib/performance/databaseCache.d.ts (Line 1:1 - Line 65:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn193" onclick="toggleCodeBlock('cloneGroup193', 'expandBtn193', 'collapseBtn193')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn193" onclick="toggleCodeBlock('cloneGroup193', 'expandBtn193', 'collapseBtn193')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup193"><code class="language-typescript text-sm text-gray-800">/**
 * SOTA Database Query Optimization and Caching
 * Implements Next.js unstable_cache for optimal performance
 */
import type { FoodTruck } from '@/lib/types';
/**
 * Cached food truck queries with optimized database access
 */
export declare const CachedFoodTruckService: {
    /**
     * Get all food trucks with caching
     * Cache for 30 minutes since truck data changes moderately
     */
    getAllTrucksCached: () =&gt; Promise&lt;{
        trucks: FoodTruck[];
        count: number;
    }&gt;;
    /**
     * Get trucks by location with caching
     * Cache for 5 minutes since location-based queries are time-sensitive
     */
    getTrucksByLocationCached: (lat: number, lng: number, radiusKm: number) =&gt; Promise&lt;FoodTruck[]&gt;;
    /**
     * Get truck by ID with caching
     * Cache for 30 minutes since individual truck data is relatively stable
     */
    getTruckByIdCached: (id: string) =&gt; Promise&lt;FoodTruck | null&gt;;
    /**
     * Search trucks with caching
     * Cache for 5 minutes since search results should be relatively fresh
     */
    searchTrucksCached: (query: string, filters?: {
        cuisine?: string;
        openNow?: boolean;
        lat?: number;
        lng?: number;
        radius?: number;
    }) =&gt; Promise&lt;FoodTruck[]&gt;;
    /**
     * Get data quality statistics with caching
     * Cache for 24 hours since quality stats change slowly
     */
    getDataQualityStatsCached: () =&gt; Promise&lt;{
        averageScore: number;
        distribution: Record&lt;string, number&gt;;
        totalTrucks: number;
    }&gt;;
};
/**
 * Cache invalidation utilities
 */
export declare const CacheManager: {
    /**
     * Invalidate all food truck related caches
     */
    invalidateAllFoodTruckCaches(): Promise&lt;void&gt;;
    /**
     * Invalidate specific truck cache
     */
    invalidateTruckCache(truckId: string): Promise&lt;void&gt;;
    /**
     * Invalidate search and location caches
     */
    invalidateSearchCaches(): Promise&lt;void&gt;;
};</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/lib/performance/bundleAnalyzer.d.ts (Line 1:1 - Line 47:4), C:/AI/food-truck-finder-poc/dist/lib/lib/performance/bundleAnalyzer.d.ts (Line 1:1 - Line 45:7)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn196" onclick="toggleCodeBlock('cloneGroup196', 'expandBtn196', 'collapseBtn196')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn196" onclick="toggleCodeBlock('cloneGroup196', 'expandBtn196', 'collapseBtn196')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup196"><code class="language-typescript text-sm text-gray-800">/**
 * Bundle Size Analysis and Optimization Utilities
 * Provides insights and recommendations for bundle optimization
 */
import React from 'react';
export interface BundleAnalysis {
    totalSize: number;
    gzippedSize: number;
    chunks: Array&lt;{
        name: string;
        size: number;
        modules: string[];
    }&gt;;
    recommendations: string[];
}
/**
 * Bundle optimization recommendations based on analysis
 */
export declare function getBundleOptimizationRecommendations(): string[];
/**
 * Critical performance metrics for bundle optimization
 */
export interface PerformanceBudget {
    maxBundleSize: number;
    maxChunkSize: number;
    maxInitialLoad: number;
    maxAssetSize: number;
}
export declare const PERFORMANCE_BUDGETS: PerformanceBudget;
/**
 * Check if bundle meets performance budgets
 */
export declare function checkPerformanceBudget(analysis: Partial&lt;BundleAnalysis&gt;): {
    passed: boolean;
    violations: Array&lt;{
        metric: string;
        actual: number;
        budget: number;
        severity: 'warning' | 'error';
    }&gt;;
};
/**
 * Dynamic import utilities for code splitting
 */
/**
 * Optimized imports for common libraries
 */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/lib/performance/bundleAnalyzer.d.ts (Line 45:1 - Line 111:2), C:/AI/food-truck-finder-poc/dist/lib/lib/performance/bundleAnalyzer.d.ts (Line 48:1 - Line 114:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn197" onclick="toggleCodeBlock('cloneGroup197', 'expandBtn197', 'collapseBtn197')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn197" onclick="toggleCodeBlock('cloneGroup197', 'expandBtn197', 'collapseBtn197')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup197"><code class="language-typescript text-sm text-gray-800">/**
 * Optimized imports for common libraries
 */
export declare const OptimizedImports: {
    icons: {
        Menu: () =&gt; Promise&lt;{
            Menu: React.ForwardRefExoticComponent&lt;Omit&lt;import(&quot;lucide-react&quot;).LucideProps, &quot;ref&quot;&gt; &amp; React.RefAttributes&lt;SVGSVGElement&gt;&gt;;
        }&gt;;
        Search: () =&gt; Promise&lt;{
            Search: React.ForwardRefExoticComponent&lt;Omit&lt;import(&quot;lucide-react&quot;).LucideProps, &quot;ref&quot;&gt; &amp; React.RefAttributes&lt;SVGSVGElement&gt;&gt;;
        }&gt;;
        User: () =&gt; Promise&lt;{
            User: React.ForwardRefExoticComponent&lt;Omit&lt;import(&quot;lucide-react&quot;).LucideProps, &quot;ref&quot;&gt; &amp; React.RefAttributes&lt;SVGSVGElement&gt;&gt;;
        }&gt;;
        BarChart3: () =&gt; Promise&lt;{
            BarChart3: React.ForwardRefExoticComponent&lt;Omit&lt;import(&quot;lucide-react&quot;).LucideProps, &quot;ref&quot;&gt; &amp; React.RefAttributes&lt;SVGSVGElement&gt;&gt;;
        }&gt;;
        Settings: () =&gt; Promise&lt;{
            Settings: React.ForwardRefExoticComponent&lt;Omit&lt;import(&quot;lucide-react&quot;).LucideProps, &quot;ref&quot;&gt; &amp; React.RefAttributes&lt;SVGSVGElement&gt;&gt;;
        }&gt;;
        Database: () =&gt; Promise&lt;{
            Database: React.ForwardRefExoticComponent&lt;Omit&lt;import(&quot;lucide-react&quot;).LucideProps, &quot;ref&quot;&gt; &amp; React.RefAttributes&lt;SVGSVGElement&gt;&gt;;
        }&gt;;
    };
    ui: {
        Button: () =&gt; Promise&lt;{
            Slot: React.ForwardRefExoticComponent&lt;import(&quot;@radix-ui/react-slot&quot;).SlotProps &amp; React.RefAttributes&lt;HTMLElement&gt;&gt;;
        }&gt;;
        Dialog: () =&gt; Promise&lt;typeof import(&quot;@radix-ui/react-dialog&quot;)&gt;;
        DropdownMenu: () =&gt; Promise&lt;typeof import(&quot;@radix-ui/react-dropdown-menu&quot;)&gt;;
    };
};
/**
 * Performance monitoring for bundle loading
 */
export declare class BundlePerformanceMonitor {
    private static loadTimes;
    /**
     * Track chunk load time
     */
    static trackChunkLoad(chunkName: string, startTime: number): void;
    /**
     * Get chunk load statistics
     */
    static getLoadStats(): Array&lt;{
        chunk: string;
        loadTime: number;
    }&gt;;
    /**
     * Get average load time
     */
    static getAverageLoadTime(): number;
}
/**
 * Code splitting helper for React components
 */
export declare function createLazyComponent&lt;T extends React.ComponentType&lt;any&gt;&gt;(importFn: () =&gt; Promise&lt;{
    default: T;
}&gt;, fallback?: React.ComponentType): (props: React.ComponentProps&lt;T&gt;) =&gt; React.JSX.Element;
/**
 * Bundle size recommendations based on current setup
 */
export declare function getProjectSpecificRecommendations(): Array&lt;{
    category: string;
    recommendations: string[];
    priority: 'high' | 'medium' | 'low';
}&gt;;</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/lib/monitoring/apiMonitor.d.ts (Line 1:1 - Line 162:2), C:/AI/food-truck-finder-poc/dist/lib/lib/monitoring/apiMonitor.d.ts (Line 1:1 - Line 162:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn199" onclick="toggleCodeBlock('cloneGroup199', 'expandBtn199', 'collapseBtn199')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn199" onclick="toggleCodeBlock('cloneGroup199', 'expandBtn199', 'collapseBtn199')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup199"><code class="language-typescript text-sm text-gray-800">/**
 * SOTA API Usage Monitoring and Alerting System
 * Implements proactive monitoring, alerting, and throttling for all external APIs
 */
export declare const API_LIMITS: {
    readonly gemini: {
        readonly requests: {
            readonly daily: 1500;
            readonly hourly: 100;
        };
        readonly tokens: {
            readonly daily: 32000;
            readonly hourly: 2000;
        };
        readonly alertThresholds: {
            readonly warning: 0.8;
            readonly critical: 0.95;
        };
    };
    readonly firecrawl: {
        readonly requests: {
            readonly daily: 500;
            readonly hourly: 50;
        };
        readonly tokens: {
            readonly daily: 0;
            readonly hourly: 0;
        };
        readonly alertThresholds: {
            readonly warning: 0.8;
            readonly critical: 0.95;
        };
    };
    readonly tavily: {
        readonly requests: {
            readonly daily: 1000;
            readonly hourly: 100;
        };
        readonly tokens: {
            readonly daily: 0;
            readonly hourly: 0;
        };
        readonly alertThresholds: {
            readonly warning: 0.8;
            readonly critical: 0.95;
        };
    };
    readonly supabase: {
        readonly requests: {
            readonly daily: 50000;
            readonly hourly: 5000;
        };
        readonly tokens: {
            readonly daily: 0;
            readonly hourly: 0;
        };
        readonly alertThresholds: {
            readonly warning: 0.9;
            readonly critical: 0.98;
        };
    };
};
export type APIService = keyof typeof API_LIMITS;
export type AlertLevel = 'info' | 'warning' | 'critical';
export interface APIUsageAlert {
    service: APIService;
    level: AlertLevel;
    message: string;
    usage: {
        current: number;
        limit: number;
        percentage: number;
    };
    timestamp: string;
    recommendations: string[];
}
export interface APIUsageData {
    requests: {
        used: number;
        limit: number;
        percentage: number;
    };
    tokens?: {
        used: number;
        limit: number;
        percentage: number;
    };
}
export interface APIMonitoringResult {
    canMakeRequest: boolean;
    alerts: APIUsageAlert[];
    usage: Record&lt;APIService, APIUsageData&gt;;
    recommendations: string[];
}
/**
 * Comprehensive API Monitoring Service
 */
export declare class APIMonitor {
    private static alertHistory;
    /**
     * Check if API request can be made safely
     */
    static canMakeRequest(service: APIService, requestCount?: number, tokenCount?: number): Promise&lt;{
        allowed: boolean;
        reason?: string;
        waitTime?: number;
    }&gt;;
    /**
     * Get current usage for a service
     */
    static getCurrentUsage(service: APIService): Promise&lt;APIUsageData&gt;;
    /**
     * Comprehensive monitoring check for all APIs
     */
    static checkAllAPIs(): Promise&lt;APIMonitoringResult&gt;;
    /**
     * Generates token usage alerts based on API usage data and predefined limits.
     * @example
     * generateTokenAlerts(APIServiceInstance, usageData, apiLimits, '2023-10-21T10:20:30Z')
     * [{ service: 'exampleService', level: 'warning', message: 'Warning: exampleService token usage at 75.0%', ... }]
     * @param {APIService} service - The API service for which the alerts are being generated.
     * @param {APIUsageData} usage - Object containing the token usage statistics.
     * @param {Object} limits - Configuration object specifying API limits and alert thresholds.
     * @param {string} timestamp - The timestamp at which the alert is generated.
     * @returns {APIUsageAlert[]} List of alerts generated based on token usage percentage compared to limits.
     * @description
     *   - Generates 'warning' alerts if token usage exceeds the warning threshold.
     *   - Generates 'critical' alerts if token usage exceeds the critical threshold.
     *   - Provides recommendations for optimizing token usage when an alert is generated.
     */
    private static generateTokenAlerts;
    /**
     * Generates usage alerts based on the service's API usage data.
     * @example
     * generateAlerts(APIService.YOUR_SERVICE, apiUsageData)
     * returns an array of APIUsageAlert objects when usage thresholds are exceeded.
     * @param {APIService} service - The API service being monitored.
     * @param {APIUsageData} usage - The usage data containing request and token information.
     * @returns {APIUsageAlert[]} An array of alert objects representing warning or critical usage states.
     * @description
     *   - Determines alert level based on predefined thresholds in API_LIMITS.
     *   - Generates alerts for both request and token usage.
     *   - Updates alert history, maintaining only the last 100 alerts.
     */
    private static generateAlerts;
    /**
     * Generate optimization recommendations
     */
    private static generateRecommendations;
    /**
     * Get time until rate limit reset
     */
    private static getTimeUntilReset;
    /**
     * Get alert history
     */
    static getAlertHistory(): APIUsageAlert[];
    /**
     * Clear alert history
     */
    static clearAlertHistory(): void;
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/lib/middleware/middlewareHelpers.d.ts (Line 1:1 - Line 24:2), C:/AI/food-truck-finder-poc/dist/lib/lib/middleware/middlewareHelpers.d.ts (Line 1:1 - Line 24:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn201" onclick="toggleCodeBlock('cloneGroup201', 'expandBtn201', 'collapseBtn201')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn201" onclick="toggleCodeBlock('cloneGroup201', 'expandBtn201', 'collapseBtn201')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup201"><code class="language-typescript text-sm text-gray-800">import { NextRequest, NextResponse } from 'next/server';
interface RequestMetadata {
    ip: string;
    userAgent: string;
    url: string;
    method: string;
}
/**
 * Protects admin routes by verifying user authentication and authorization.
 * @example
 * protectAdminRoutes(req, res, requestMetadata)
 * returns NextResponse or redirects depending on user authentication status.
 * @param {NextRequest} req - The incoming request object.
 * @param {NextResponse} res - The response object to send back to the client.
 * @param {RequestMetadata} requestMetadata - Metadata about the request for logging purposes.
 * @returns {NextResponse} Returns the response object or redirects to an error page.
 * @description
 *   - Fetches and verifies the user's session from Supabase.
 *   - Checks if the user is an admin based on the profile 'role' from the database.
 *   - Logs access attempts to the admin panel for auditing purposes.
 *   - Redirects to an appropriate error handler if the user isn't authenticated or authorized.
 */
export declare function protectAdminRoutes(req: NextRequest, res: NextResponse, requestMetadata: RequestMetadata): Promise&lt;NextResponse&lt;unknown&gt;&gt;;
export {};</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/lib/mappers/uprootedVeganMapper.d.ts (Line 7:14 - Line 80:2), C:/AI/food-truck-finder-poc/dist/lib/lib/mappers/uprootedVeganMapper.d.ts (Line 7:11 - Line 80:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn203" onclick="toggleCodeBlock('cloneGroup203', 'expandBtn203', 'collapseBtn203')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn203" onclick="toggleCodeBlock('cloneGroup203', 'expandBtn203', 'collapseBtn203')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup203"><code class="language-typescript text-sm text-gray-800">;
export interface UprootedVeganData {
    name: string;
    description?: string;
    cuisine_type: string | string[];
    price_range?: '$' | '$$' | '$$$' | '$$$$';
    specialties?: string | string[];
    user_id?: string;
    state?: string;
    exact_location?: {
        lat: number;
        lng: number;
        address?: string;
        timestamp?: string;
    };
    city_location?: {
        lat: number;
        lng: number;
        address?: string;
        timestamp?: string;
    };
    current_location?: {
        lat: number;
        lng: number;
        address?: string;
        timestamp?: string;
    };
    scheduled_locations?: {
        address?: string;
        city?: string;
        state?: string;
        zip_code?: string;
        lat?: number;
        lng?: number;
        timestamp: string;
        start_time: string;
        end_time: string;
    }[];
    operating_hours?: OperatingHours | Record&lt;string, any&gt;;
    menu?: MenuCategory[] | any[];
    contact_info?: {
        phone?: string;
        email?: string;
        website?: string;
    };
    social_media?: {
        instagram?: string;
        facebook?: string;
        twitter?: string;
        tiktok?: string;
        yelp?: string;
    };
    data_quality_score?: number;
    verification_status?: 'pending' | 'verified' | 'flagged';
    source_urls?: string | string[];
    last_scraped_at?: string;
    created_at?: string;
    updated_at?: string;
}
/**
 * Maps Uprooted Vegan Cuisine data to our FoodTruck schema
 */
export declare function mapUprootedVeganData(data: UprootedVeganData): Partial&lt;FoodTruck&gt;;
/**
 * Validates that required fields are present
 */
export declare function validateUprootedVeganData(data: UprootedVeganData): {
    isValid: boolean;
    errors: string[];
};
/**
 * Example usage and testing function
 */
export declare function createUprootedVeganExample(): UprootedVeganData;</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/lib/lib/types.d.ts (Line 57:10 - Line 70:2), C:/AI/food-truck-finder-poc/dist/lib/lib/mappers/uprootedVeganMapper.d.ts (Line 32:7 - Line 45:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn204" onclick="toggleCodeBlock('cloneGroup204', 'expandBtn204', 'collapseBtn204')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn204" onclick="toggleCodeBlock('cloneGroup204', 'expandBtn204', 'collapseBtn204')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup204"><code class="language-typescript text-sm text-gray-800">;
    };
    scheduled_locations?: {
        address?: string;
        city?: string;
        state?: string;
        zip_code?: string;
        lat?: number;
        lng?: number;
        timestamp: string;
        start_time: string;
        end_time: string;
    }[];
    operating_hours:</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/lib/lib/types.d.ts (Line 100:22 - Line 115:13), C:/AI/food-truck-finder-poc/dist/lib/lib/types.d.ts (Line 69:2 - Line 84:11)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn205" onclick="toggleCodeBlock('cloneGroup205', 'expandBtn205', 'collapseBtn205')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn205" onclick="toggleCodeBlock('cloneGroup205', 'expandBtn205', 'collapseBtn205')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup205"><code class="language-typescript text-sm text-gray-800">];
    operating_hours: OperatingHours;
    menu: MenuCategory[];
    contact_info: {
        phone?: string;
        email?: string;
        website?: string;
    };
    social_media: {
        instagram?: string;
        facebook?: string;
        twitter?: string;
        tiktok?: string;
        yelp?: string;
    };
    cuisine_type</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/lib/lib/types.d.ts (Line 201:2 - Line 219:7), C:/AI/food-truck-finder-poc/lib/api/admin/realtime-events/handlers.ts (Line 12:1 - Line 43:3)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn206" onclick="toggleCodeBlock('cloneGroup206', 'expandBtn206', 'collapseBtn206')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn206" onclick="toggleCodeBlock('cloneGroup206', 'expandBtn206', 'collapseBtn206')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup206"><code class="language-typescript text-sm text-gray-800">interface RealtimeMetrics {
    scrapingJobs: {
        active: number;
        completed: number;
        failed: number;
        pending: number;
    };
    dataQuality: {
        averageScore: number;
        totalTrucks: number;
        recentChanges: number;
    };
    systemHealth: {
        status: 'healthy' | 'warning' | 'error';
        uptime: number;
        lastUpdate: string;
    };
}
export</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/lib/lib/types.d.ts (Line 333:1 - Line 344:7), C:/AI/food-truck-finder-poc/dist/api/admin/data-cleanup/handlers.d.ts (Line 2:1 - Line 25:4)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn207" onclick="toggleCodeBlock('cloneGroup207', 'expandBtn207', 'collapseBtn207')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn207" onclick="toggleCodeBlock('cloneGroup207', 'expandBtn207', 'collapseBtn207')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup207"><code class="language-typescript text-sm text-gray-800">export interface DataCleanupRequestBody {
    action: string;
    options?: {
        batchSize?: number;
        dryRun?: boolean;
        operations?: string[];
        truckData?: Record&lt;string, unknown&gt;;
        targetId?: string;
        sourceId?: string;
    };
}
export</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/lib/lib/database.types.d.ts (Line 72:2 - Line 93:2), C:/AI/food-truck-finder-poc/dist/lib/lib/database.types.d.ts (Line 45:17 - Line 66:7)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn214" onclick="toggleCodeBlock('cloneGroup214', 'expandBtn214', 'collapseBtn214')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn214" onclick="toggleCodeBlock('cloneGroup214', 'expandBtn214', 'collapseBtn214')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup214"><code class="language-typescript text-sm text-gray-800">: Json;
                    scheduled_locations?: Json | undefined;
                    operating_hours?: Json | undefined;
                    menu?: Json | undefined;
                    contact_info?: Json | undefined;
                    social_media?: Json | undefined;
                    cuisine_type?: string[] | undefined;
                    price_range?: string | undefined;
                    specialties?: string[] | undefined;
                    data_quality_score?: number | undefined;
                    verification_status?: 'pending' | 'verified' | 'flagged' | 'rejected';
                    source_urls?: string[] | undefined;
                    last_scraped_at?: string | undefined;
                    exact_location?: Json | undefined;
                    city_location?: Json | undefined;
                    user_id?: string | undefined;
                    average_rating?: number | undefined;
                    review_count?: number | undefined;
                    last_updated_at?: string | undefined;
                    is_active?: boolean | undefined;
                };
            }</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/lib/lib/database.types.d.ts (Line 131:2 - Line 146:2), C:/AI/food-truck-finder-poc/dist/lib/lib/database.types.d.ts (Line 114:9 - Line 129:7)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn215" onclick="toggleCodeBlock('cloneGroup215', 'expandBtn215', 'collapseBtn215')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn215" onclick="toggleCodeBlock('cloneGroup215', 'expandBtn215', 'collapseBtn215')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup215"><code class="language-typescript text-sm text-gray-800">: string;
                    target_url?: string | undefined;
                    target_handle?: string | undefined;
                    platform?: string | undefined;
                    status?: 'pending' | 'running' | 'completed' | 'failed';
                    priority?: number;
                    scheduled_at?: string;
                    started_at?: string | undefined;
                    completed_at?: string | undefined;
                    data_collected?: Json | undefined;
                    errors?: string[] | undefined;
                    retry_count?: number;
                    max_retries?: number;
                    created_at?: string;
                };
            }</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/lib/lib/database.types.d.ts (Line 181:2 - Line 190:2), C:/AI/food-truck-finder-poc/dist/lib/lib/database.types.d.ts (Line 167:11 - Line 176:7)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn216" onclick="toggleCodeBlock('cloneGroup216', 'expandBtn216', 'collapseBtn216')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn216" onclick="toggleCodeBlock('cloneGroup216', 'expandBtn216', 'collapseBtn216')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup216"><code class="language-typescript text-sm text-gray-800">: string;
                    start_time?: string | undefined;
                    end_time?: string | undefined;
                    location_address?: string | undefined;
                    location_lat?: number | undefined;
                    location_lng?: number | undefined;
                    created_at?: string;
                    updated_at?: string;
                };
            }</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/lib/lib/database.types.d.ts (Line 224:2 - Line 237:2), C:/AI/food-truck-finder-poc/dist/lib/lib/database.types.d.ts (Line 209:4 - Line 222:7)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn217" onclick="toggleCodeBlock('cloneGroup217', 'expandBtn217', 'collapseBtn217')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn217" onclick="toggleCodeBlock('cloneGroup217', 'expandBtn217', 'collapseBtn217')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup217"><code class="language-typescript text-sm text-gray-800">: string;
                    source_directory_url?: string | undefined;
                    region?: string | undefined;
                    status?: 'new' | 'processing' | 'processed' | 'irrelevant' | 'failed';
                    discovery_method?: 'manual' | 'autonomous_search' | 'tavily_search' | 'firecrawl_crawl' | 'directory_crawl';
                    discovered_at?: string;
                    last_processed_at?: string | undefined;
                    processing_attempts?: number;
                    notes?: string | undefined;
                    metadata?: Json | undefined;
                    created_at?: string;
                    updated_at?: string;
                };
            }</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/lib/gemini/usageLimits.d.ts (Line 1:1 - Line 52:2), C:/AI/food-truck-finder-poc/dist/lib/lib/gemini/usageLimits.d.ts (Line 1:1 - Line 52:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn219" onclick="toggleCodeBlock('cloneGroup219', 'expandBtn219', 'collapseBtn219')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn219" onclick="toggleCodeBlock('cloneGroup219', 'expandBtn219', 'collapseBtn219')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup219"><code class="language-typescript text-sm text-gray-800">export interface UsageLimits {
    dailyRequestLimit: number;
    dailyTokenLimit: number;
}
export interface UsageCheck {
    canMakeRequest: boolean;
    usage?: {
        requests: {
            used: number;
            limit: number;
            remaining: number;
        };
        tokens: {
            used: number;
            limit: number;
            remaining: number;
        };
    };
}
export declare class GeminiUsageLimits {
    private static readonly DEFAULT_LIMITS;
    /**
     * Checks the current usage against predefined limits and determines if further requests can be made.
     * @example
     * checkUsageLimits()
     * { canMakeRequest: true, usage: { requests: { used: 50, limit: 1000, remaining: 950 }, tokens: { used: 200, limit: 5000, remaining: 4800 } } }
     * @param {UsageLimits} limits - Object containing usage limits for requests and tokens.
     * @returns {Promise&lt;UsageCheck&gt;} Object indicating if a request can be made and the current usage statistics.
     * @description
     *   - Attempts to fetch today's usage data from the APIUsageService for 'gemini'.
     *   - If the fetch fails, defaults to allowing the request with a warning.
     *   - Maintains a buffer of 100 tokens to ensure requests are not made when limits are too close.
     */
    static checkUsageLimits(limits?: UsageLimits): Promise&lt;UsageCheck&gt;;
    /**
    * Checks if a request can be made with monitoring and returns whether the operation is allowed.
    * @example
    * checkWithMonitoring(100, DEFAULT_LIMITS)
    * { allowed: true }
    * @param {number} estimatedTokens - Number of estimated tokens for the request.
    * @param {UsageLimits} _limits - Usage limits configuration for requests (default provided internally).
    * @returns {Promise&lt;{ allowed: boolean; reason?: string; waitTime?: number }&gt;} Object indicating if the request is allowed and why not if denied.
    * @description
    *   - Uses an internal API monitor to check if requests can be made based on predefined limits.
    *   - Wait time is converted from milliseconds to minutes before being returned.
    */
    static checkWithMonitoring(estimatedTokens: number, _limits?: UsageLimits): Promise&lt;{
        allowed: boolean;
        reason?: string;
        waitTime?: number;
    }&gt;;
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/lib/gemini/responseParser.d.ts (Line 1:1 - Line 11:2), C:/AI/food-truck-finder-poc/dist/lib/lib/gemini/responseParser.d.ts (Line 1:1 - Line 11:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn221" onclick="toggleCodeBlock('cloneGroup221', 'expandBtn221', 'collapseBtn221')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn221" onclick="toggleCodeBlock('cloneGroup221', 'expandBtn221', 'collapseBtn221')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup221"><code class="language-typescript text-sm text-gray-800">import { type MenuCategory, type LocationData, type OperatingHours, type SentimentAnalysisResult, type EnhancedFoodTruckData, type ExtractedFoodTruckDetails } from '../types';
export declare const GeminiResponseParser: {
    parseJson&lt;T&gt;(text: string): T;
    parseMenuData(text: string): MenuCategory[];
    parseLocationData(text: string): LocationData;
    parseOperatingHours(text: string): OperatingHours;
    parseSentimentAnalysis(text: string): SentimentAnalysisResult;
    parseEnhancedFoodTruckData(text: string): EnhancedFoodTruckData;
    parseExtractedFoodTruckDetails(text: string): ExtractedFoodTruckDetails;
    cleanMarkdownResponse(text: string): string;
};</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/lib/gemini/promptTemplates.d.ts (Line 1:1 - Line 8:2), C:/AI/food-truck-finder-poc/dist/lib/lib/gemini/promptTemplates.d.ts (Line 1:1 - Line 8:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn223" onclick="toggleCodeBlock('cloneGroup223', 'expandBtn223', 'collapseBtn223')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn223" onclick="toggleCodeBlock('cloneGroup223', 'expandBtn223', 'collapseBtn223')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup223"><code class="language-typescript text-sm text-gray-800">export declare const PromptTemplates: {
    menuProcessing: (rawMenuText: string) =&gt; string;
    locationExtraction: (textInput: string) =&gt; string;
    operatingHours: (hoursText: string) =&gt; string;
    sentimentAnalysis: (reviewText: string) =&gt; string;
    dataEnhancement: (rawData: unknown) =&gt; string;
    foodTruckExtraction: (markdownContent: string, sourceUrl?: string) =&gt; string;
};</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/lib/gemini/geminiApiClient.d.ts (Line 1:14 - Line 41:2), C:/AI/food-truck-finder-poc/dist/lib/lib/gemini/geminiApiClient.d.ts (Line 1:11 - Line 41:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn225" onclick="toggleCodeBlock('cloneGroup225', 'expandBtn225', 'collapseBtn225')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn225" onclick="toggleCodeBlock('cloneGroup225', 'expandBtn225', 'collapseBtn225')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup225"><code class="language-typescript text-sm text-gray-800">;
export interface GeminiApiConfig {
    temperature?: number;
    maxTokens?: number;
}
export declare class GeminiApiClient {
    private genAI;
    private modelName;
    constructor();
    /**
    * Makes an API request to generate content based on the provided prompt and configuration.
    * @example
    * makeRequest('Create a poem about nature', { temperature: 0.7 })
    * Returns a promise that resolves to a GeminiResponse containing the generated text and token usage.
    * @param {string} prompt - The input prompt for content generation.
    * @param {GeminiApiConfig} config - Configuration settings for the API request, such as temperature. Defaults to an empty object.
    * @returns {Promise&lt;GeminiResponse&lt;T&gt;&gt;} A promise that resolves to a GeminiResponse with the generated content or an error message.
    * @description
    *   - The function calculates the number of tokens used for tracking purposes, even in case of an error.
    *   - The `temperature` parameter affects the randomness of the content generation, with higher values resulting in more creative outputs.
    *   - API usage is tracked asynchronously, and warnings are logged if tracking fails.
    *   - Returns an object indicating success status, the generated content or error message, and the number of tokens used.
    */
    makeRequest&lt;T&gt;(prompt: string, config?: GeminiApiConfig): Promise&lt;GeminiResponse&lt;T&gt;&gt;;
    /**
     * Executes a request using a specified prompt and attempts to parse the response using the provided parser function.
     * @example
     * makeRequestWithParsing(&quot;example prompt&quot;, (text) =&gt; JSON.parse(text))
     * { success: true, data: { key: &quot;value&quot; }, tokensUsed: 100 }
     * @param {string} prompt - The prompt used to make the API request.
     * @param {function} parser - A function to parse the response text into the desired format.
     * @param {GeminiApiConfig} config - Optional configuration settings for the Gemini API request.
     * @returns {Promise&lt;GeminiResponse&lt;T&gt;&gt;} A promise resolving to a GeminiResponse object containing either the parsed data or an error description.
     * @description
     *   - The function makes an asynchronous request using a specific prompt string and configuration.
     *   - If the response is unsuccessful, it returns the original response cast to the expected return type.
     *   - Parses the successful response data using the provided parser function.
     *   - Handles parsing errors gracefully, returning a detailed error message and logs the raw problematic response.
     */
    makeRequestWithParsing&lt;T&gt;(prompt: string, parser: (text: string) =&gt; T, config?: GeminiApiConfig): Promise&lt;GeminiResponse&lt;T&gt;&gt;;
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/lib/fallback/supabaseFallback.d.ts (Line 1:1 - Line 59:2), C:/AI/food-truck-finder-poc/dist/lib/lib/fallback/supabaseFallback.d.ts (Line 2:1 - Line 60:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn231" onclick="toggleCodeBlock('cloneGroup231', 'expandBtn231', 'collapseBtn231')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn231" onclick="toggleCodeBlock('cloneGroup231', 'expandBtn231', 'collapseBtn231')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup231"><code class="language-typescript text-sm text-gray-800">type FallbackResult = {
    readonly trucks: FoodTruck[];
    readonly isFromCache: boolean;
    readonly lastUpdate: string;
    readonly status: 'fresh' | 'cached' | 'stale' | 'unavailable';
};
declare class SupabaseFallbackManager {
    private readonly CACHE_KEY;
    private readonly TRUCK_CACHE_KEY_PREFIX;
    private readonly CACHE_DURATION;
    private readonly supabase;
    constructor();
    /**
     * This is your main data fetching function that handles all the fallback logic
     * Think of it as your &quot;smart&quot; data fetcher that adapts to different situations
     */
    getFoodTrucks(): Promise&lt;FallbackResult&gt;;
    getFoodTruckById(id: string): Promise&lt;FoodTruck | null&gt;;
    /**
     * This handles the actual Supabase communication
     * Separated so you can easily modify your existing query logic
     */
    private fetchFromSupabase;
    /**
     * This is where the magic happens - graceful degradation
     * When Supabase fails, we still provide value to users
     */
    private handleFallbackScenario;
    /**
     * Stores successful data fetches for later use
     * This runs every time we successfully get data from Supabase
     */
    private cacheData;
    private cacheTruck;
    private getCachedTruck;
    /**
     * Retrieves cached data when Supabase is unavailable
     * This is your safety net
     */
    private getCachedData;
}
export declare const supabaseFallback: SupabaseFallbackManager;
export declare function useFoodTrucks(): {
    trucks: FoodTruck[];
    loading: boolean;
    dataStatus: {
        readonly isFromCache: boolean;
        readonly lastUpdate: string;
        readonly status: &quot;fresh&quot; | &quot;cached&quot; | &quot;stale&quot; | &quot;unavailable&quot;;
    };
};
export declare function DataStatusIndicator({ status, }: {
    readonly status: {
        isFromCache: boolean;
        lastUpdate: string;
        status: 'fresh' | 'cached' | 'stale' | 'unavailable';
    };
}): import(&quot;react&quot;).JSX.Element | undefined;
export {};</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/lib/data-quality/placeholderUtils.d.ts (Line 1:1 - Line 43:2), C:/AI/food-truck-finder-poc/dist/lib/lib/data-quality/placeholderUtils.d.ts (Line 1:1 - Line 43:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn233" onclick="toggleCodeBlock('cloneGroup233', 'expandBtn233', 'collapseBtn233')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn233" onclick="toggleCodeBlock('cloneGroup233', 'expandBtn233', 'collapseBtn233')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup233"><code class="language-typescript text-sm text-gray-800">import type { FoodTruck } from '@/lib/supabase';
/**
* Returns an array of regular expressions that identify placeholder patterns.
* @example
* getPlaceholderPatterns()
* [ /undefined/i, /placeholder/i, /example\.com/i, /test\s*truck/i, /lorem\s*ipsum/i, /\bna\b/i, /\bn\/a\b/i, /^0+$/, /^null$/i ]
* @returns {RegExp[]} An array of regular expressions to match various placeholder values.
* @description
*   - Regular expressions cover common placeholder values used in data.
*   - Patterns are designed to be case insensitive to support a wider range of inputs.
*   - Contains specific patterns like 'example.com' to catch domain placeholders.
*   - Includes matches for numeric placeholders like '000...' and 'null'.
*/
export declare function getPlaceholderPatterns(): RegExp[];
/**
* Checks the food truck's properties for placeholder patterns and sets them to undefined if a pattern is found.
* @example
* checkForPlaceholders(foodTruckObj, [/\b(?:N\/A|TBD|Unknown)\b/, /^{.+}$/])
* {name: undefined, description: undefined}
* @param {FoodTruck} truck - The food truck object which may contain placeholder text in its properties.
* @param {RegExp[]} patterns - Array of regex patterns used to test against food truck properties.
* @returns {Partial&lt;FoodTruck&gt;} A partial food truck object with properties set to undefined if placeholders are detected.
* @description
*   - The function does not modify the original truck object; it returns a new one.
*   - Handles undefined properties seamlessly to prevent errors during regex testing.
*   - Assumes that the RegExp provided will effectively identify placeholder patterns.
*/
export declare function checkForPlaceholders(truck: FoodTruck, patterns: RegExp[]): Partial&lt;FoodTruck&gt;;
/**
* Processes a FoodTruck object for placeholders and returns updates.
* @example
* processTruckForPlaceholders(truck, [/pattern1/g, /pattern2/g])
* { name: 'Updated Truck Name', address: 'Updated Address' }
* @param {FoodTruck} truck - The FoodTruck object to be processed for placeholders.
* @param {Array&lt;RegExp&gt;} patterns - Array of regular expressions to identify placeholders.
* @returns {Partial&lt;FoodTruck&gt;} An object containing the updated fields of the FoodTruck.
* @description
*   - Performs checks for placeholders in basic information of the truck.
*   - Processes contact information of the FoodTruck for placeholders.
*   - Assesses and updates address details for placeholders.
*   - Combines updates from basic, contact, and address information into a single object.
*/
export declare function processTruckForPlaceholders(truck: FoodTruck, patterns: RegExp[]): Partial&lt;FoodTruck&gt;;</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/lib/data-quality/duplicatePrevention.d.ts (Line 5:17 - Line 54:8), C:/AI/food-truck-finder-poc/dist/lib/lib/data-quality/duplicatePrevention.d.ts (Line 5:17 - Line 53:8)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn238" onclick="toggleCodeBlock('cloneGroup238', 'expandBtn238', 'collapseBtn238')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn238" onclick="toggleCodeBlock('cloneGroup238', 'expandBtn238', 'collapseBtn238')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup238"><code class="language-typescript text-sm text-gray-800">;
export declare const DUPLICATE_DETECTION_CONFIG: {
    readonly thresholds: {
        readonly name: 0.85;
        readonly location: 0.9;
        readonly phone: 1;
        readonly website: 1;
        readonly overall: 0.8;
    };
    readonly weights: {
        readonly name: 0.4;
        readonly location: 0.3;
        readonly contact: 0.2;
        readonly menu: 0.1;
    };
};
export interface DuplicateMatch {
    existingTruck: FoodTruck;
    similarity: number;
    matchedFields: string[];
    confidence: 'high' | 'medium' | 'low';
    recommendation: 'merge' | 'update' | 'skip' | 'manual_review';
}
export interface DuplicateDetectionResult {
    isDuplicate: boolean;
    matches: DuplicateMatch[];
    bestMatch?: DuplicateMatch;
    action: 'create' | 'update' | 'merge' | 'manual_review';
    reason: string;
}
/**
 * Advanced Duplicate Prevention Service
 */
export declare class DuplicatePreventionService {
    /**
     * Check if a food truck is a duplicate of existing trucks
     */
    static checkForDuplicates(candidateTruck: Partial&lt;FoodTruck&gt;): Promise&lt;DuplicateDetectionResult&gt;;
    /**
     * Processes the matches found during duplicate detection and returns the result.
     */
    private static processDuplicateMatches;
    /**
     * Calculate similarity between two food trucks
     */
    private static calculateSimilarity;
    /**
     * Normalize food truck names for better comparison
     * Removes common suffixes, normalizes case, handles punctuation variations
     */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/lib/data-quality/duplicatePrevention.d.ts (Line 59:5 - Line 98:2), C:/AI/food-truck-finder-poc/dist/lib/lib/data-quality/duplicatePrevention.d.ts (Line 54:5 - Line 93:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn239" onclick="toggleCodeBlock('cloneGroup239', 'expandBtn239', 'collapseBtn239')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn239" onclick="toggleCodeBlock('cloneGroup239', 'expandBtn239', 'collapseBtn239')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup239"><code class="language-typescript text-sm text-gray-800">private static calculateStringSimilarity;
    /**
     * Calculate location similarity
     */
    private static calculateLocationSimilarity;
    /**
     * Calculate GPS distance in kilometers
     */
    private static calculateGPSDistance;
    /**
     * Calculate contact similarity
     */
    private static calculateContactSimilarity;
    /**
     * Calculate menu similarity (basic implementation)
     */
    private static calculateMenuSimilarity;
    /**
     * Get confidence level based on similarity score
     */
    private static getConfidenceLevel;
    /**
     * Get recommendation based on similarity analysis
     */
    private static getRecommendation;
    /**
     * Determine action based on matches
     */
    private static determineAction;
    /**
     * Generate human-readable reason
     */
    private static generateReason;
    /**
     * Merge duplicate truck data intelligently
     */
    static mergeDuplicates(targetId: string, sourceId: string): Promise&lt;FoodTruck | {
        error: string;
    }&gt;;
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/lib/data-quality/batchCleanup.d.ts (Line 1:1 - Line 214:2), C:/AI/food-truck-finder-poc/dist/lib/lib/data-quality/batchCleanup.d.ts (Line 1:1 - Line 214:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn241" onclick="toggleCodeBlock('cloneGroup241', 'expandBtn241', 'collapseBtn241')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn241" onclick="toggleCodeBlock('cloneGroup241', 'expandBtn241', 'collapseBtn241')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup241"><code class="language-typescript text-sm text-gray-800">/**
 * SOTA Batch Data Cleanup System
 * Implements automated data quality improvements and cleanup operations
 */
import type { CleanupOperation, CleanupOperationType, BatchCleanupResult } from '@/lib/types';
export type { CleanupOperation, CleanupOperationType, BatchCleanupResult };
/**
 * Automated Data Quality Cleanup Service
 */
export declare class BatchCleanupService {
    /**
     * Run comprehensive data cleanup operations
     */
    static runFullCleanup(options?: {
        batchSize?: number;
        dryRun?: boolean;
        operations?: CleanupOperation['type'][];
    }): Promise&lt;BatchCleanupResult&gt;;
    /**
    * Initializes and returns a new BatchCleanupResult object with default values.
    * @example
    * initializeCleanupResult()
    * { totalProcessed: 0, operations: [], summary: { trucksImproved: 0, duplicatesRemoved: 0, qualityScoreImprovement: 0, placeholdersRemoved: 0 }, duration: 0 }
    * @returns {BatchCleanupResult} A new BatchCleanupResult object with all properties set to initial default values.
    */
    private static initializeCleanupResult;
    private static finalizeCleanupResult;
    /**
     * Processes food trucks in batches, executing specified operations on each batch.
     * @example
     * processTrucksInBatches(truckList, { batchSize: 10, operations: ['clean'], dryRun: true, result: batchResult })
     * // It executes 'clean' operation on batches of 10 trucks without making permanent changes.
     * @param {FoodTruck[]} trucks - Array of food trucks to be processed in batches.
     * @param {object} options - Options object containing batchSize, operations, dryRun, and result.
     * @param {number} options.batchSize - Number of trucks in each batch.
     * @param {CleanupOperation['type'][]} options.operations - Array of operation types to be executed on each batch.
     * @param {boolean} options.dryRun - If true, operations are executed in simulation mode without permanent changes.
     * @param {BatchCleanupResult} options.result - Stores the results of operations performed on batches.
     * @returns {Promise&lt;void&gt;} Completes processing batches without a return value.
     * @description
     *   - Uses async function to allow non-blocking execution of operations.
     *   - Collects and stores results of batch operations separately, keeping track of each operation's outcome.
     *   - Iterates over arrays using slicing to dynamically create batches for processing.
     */
    private static processTrucksInBatches;
    /**
     * Run a specific cleanup operation
     */
    private static runOperation;
    private static runRemovePlaceholders;
    private static runNormalizePhoneNumbers;
    private static runFixCoordinates;
    private static runUpdateQualityScores;
    private static runMergeDuplicates;
    /**
     * Remove placeholder and mock data
     */
    private static removePlaceholders;
    private static processSingleTruckForPlaceholders;
    /**
     * Perform an update operation on a specified food truck.
     * @example
     * performUpdateOperation('truck123', { name: 'New Name' }, true, cleanupOperation)
     * // No direct return value; operation may log errors.
     * @param {string} truckId - The unique identifier of the food truck to be updated.
     * @param {Partial&lt;FoodTruck&gt;} updates - An object containing the fields to be updated.
     * @param {boolean} dryRun - Flag indicating whether the operation should be a simulation without actual changes.
     * @param {CleanupOperation} operation - An operation object that logs errors encountered during update.
     * @returns {Promise&lt;void&gt;} A promise that resolves when the update operation is complete.
     * @description
     *   - If 'dryRun' is true, no updates are applied but actions are logged.
     *   - Errors during update are caught and logged in the 'operation.errors' array.
     */
    private static performUpdateOperation;
    /**
     * Normalize phone numbers to consistent format
     */
    private static normalizePhoneNumbers;
    /**
     * Apply phone normalization update to a food truck's contact information.
     * @example
     * applyPhoneNormalizationUpdate(truckInstance, '+1234567890', false, operationInstance)
     * // Normalizes and updates phone number of given truckInstance.
     * @param {FoodTruck} truck - The food truck object whose phone number needs normalization.
     * @param {string} normalizedPhone - The normalized phone number to update to the food truck's contact information.
     * @param {boolean} dryRun - Flag indicating whether the operation is a dry run; updates are skipped if true.
     * @param {CleanupOperation} operation - Object containing cleanup operation context including a record of errors.
     * @returns {Promise&lt;void&gt;} Does not return a value, but potentially modifies the truck and operation objects.
     * @description
     *   - Executes the update operation only if `dryRun` is false.
     *   - Pushes error messages to `operation.errors` on failure during the update process.
     *   - Uses `FoodTruckService.updateTruck` for updating the contact information.
     */
    private static applyPhoneNormalizationUpdate;
    /**
     * Helper to determine if coordinates need fixing and provide updates
     */
    private static getFixedCoordinates;
    /**
     * Fix invalid GPS coordinates
     */
    private static fixCoordinates;
    /**
     * Processes coordinates for a single food truck, applying any necessary fixes.
     * @example
     * processSingleTruckCoordinates(truck, context)
     * // No return value, function completes silently
     * @param {FoodTruck} truck - The food truck whose coordinates are to be processed.
     * @param {CoordinateProcessContext} context - Contains configuration and operation context for processing coordinates.
     * @returns {Promise&lt;void&gt;} Returns a promise that resolves when the processing and possible updates are complete.
     * @description
     *   - Skips processing if the truck's current location is not available.
     *   - Retrieves updates for fixed coordinates based on truck's current and default locations.
     *   - Applies updates conditionally based on context settings such as `dryRun` and `operation`.
     */
    private static processSingleTruckCoordinates;
    /**
     * Applies coordinate updates for a food truck's current location.
     * @example
     * applyCoordinateFixUpdate(truck, { lat: 34.05, lng: -118.25 }, false, operation)
     * // Updates the coordinates of the truck's location asynchronously.
     * @param {FoodTruck} truck - The food truck object whose coordinates need correction.
     * @param {Partial&lt;FoodTruck['current_location']&gt;} updates - The latitude and longitude updates to be applied.
     * @param {boolean} dryRun - Flag to simulate the update without altering data.
     * @param {CleanupOperation} operation - The cleanup operation instance used for error tracking.
     * @returns {Promise&lt;void&gt;} Resolves when the coordinate update process is complete.
     * @description
     *   - Executes the update operation only if the dryRun flag is false.
     *   - If the update fails, logs the error details into the operation's error array.
     */
    private static applyCoordinateFixUpdate;
    /**
     * Update quality scores for all trucks
     */
    private static updateQualityScores;
    /**
    * Processes a single food truck for an updated quality score assessment.
    * @example
    * processSingleTruckForQualityScore(truckInstance, false, cleanupOperationInstance)
    * // No return value
    * @param {FoodTruck} truck - The food truck instance to assess and potentially update.
    * @param {boolean} dryRun - Specifies whether this is a dry run (no actual data updates).
    * @param {CleanupOperation} operation - The cleanup operation context for processing.
    * @returns {Promise&lt;void&gt;} No return value; operation is performed asynchronously.
    * @description
    *   - Computes the quality score using data from DataQualityService.
    *   - Updates the quality score only if the score changes significantly (&gt;5% difference).
    *   - Assumes `truck.data_quality_score` might be undefined, defaulting to 0.
    *   - Handles asynchronous processing of the update application if conditions are met.
    */
    private static processSingleTruckForQualityScore;
    /**
     * Updates the quality score of a specified food truck and handles errors during the update process.
     * @example
     * applyQualityScoreUpdate(foodTruckInstance, false, cleanupOperationInstance)
     * void
     * @param {FoodTruck} truck - The food truck for which the quality score will be updated.
     * @param {boolean} dryRun - Flag indicating whether the function should perform the update or just simulate it.
     * @param {CleanupOperation} operation - The cleanup operation containing possible error records.
     * @returns {Promise&lt;void&gt;} Resolves with no value when the update completes. Errors are recorded in the `operation` if thrown.
     * @description
     *   - Throws an error if the quality score update fails.
     *   - If `dryRun` is true, the function simulates the update without changing any data.
     *   - Errors occurring during the update are appended to the `operation.errors` array.
     */
    private static applyQualityScoreUpdate;
    /**
     * Identify and merge duplicate trucks
     */
    private static mergeDuplicates;
    /**
     * Processes a single food truck to detect and handle duplicates in the dataset.
     * @example
     * processSingleTruckForDuplicates(foodTruck, true, mergeContext)
     * // No return value. Performs operations as a side effect.
     * @param {FoodTruck} truck - An instance of FoodTruck to process for duplicates.
     * @param {boolean} dryRun - Flag indicating if the operation should be executed in dry run mode.
     * @param {MergeOperationContext} context - Operational context that carries state and configurations for the merge operation.
     * @returns {Promise&lt;void&gt;} Executes a set of operations for handling duplicate records, does not return any value.
     * @description
     *   - Ensures a food truck is only processed once by maintaining a set of processed IDs.
     *   - Uses DuplicatePreventionService to assess whether the given truck is a duplicate.
     *   - Applies a merge operation if a duplicate truck is confidently identified.
     */
    private static processSingleTruckForDuplicates;
    /**
     * Applies a merge operation between two food trucks and updates the context.
     * @example
     * applyMergeOperation(truck, existingTruck, true, context)
     * // Executes a dry run of the merge operation without affecting data
     * @param {FoodTruck} truck - The food truck that is being merged.
     * @param {FoodTruck} existingTruck - The existing food truck to merge with.
     * @param {boolean} dryRun - Indicates if the merge operation should be simulated.
     * @param {MergeOperationContext} context - Context containing details and state of the merge operation.
     * @returns {Promise&lt;void&gt;} Promise representing the completion of the merge operation.
     * @description
     *   - Updates the list of processed IDs in the context upon successful merge.
     *   - Throws and records an error if the merge operation fails.
     *   - Utilizes the DuplicatePreventionService for performing the merge.
     */
    private static applyMergeOperation;
    /**
     * Normalize phone number format
     */
    private static normalizePhone;
    /**
     * Get operation description
     */
    private static getOperationDescription;
    /**
     * Calculate cleanup summary
     */
    private static calculateSummary;
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/api/test-integration/stageHandlers.d.ts (Line 1:1 - Line 11:2), C:/AI/food-truck-finder-poc/dist/lib/lib/api/test-integration/stageHandlers.d.ts (Line 1:1 - Line 11:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn309" onclick="toggleCodeBlock('cloneGroup309', 'expandBtn309', 'collapseBtn309')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn309" onclick="toggleCodeBlock('cloneGroup309', 'expandBtn309', 'collapseBtn309')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup309"><code class="language-typescript text-sm text-gray-800">import { type ExtractedFoodTruckDetails, type StageResult } from '@/lib/types';
export declare function handleFirecrawlStage(url: string, rawText: string | undefined, logs: string[]): Promise&lt;{
    firecrawlResult: StageResult;
    contentToProcess: string | undefined;
    sourceUrlForProcessing: string;
}&gt;;
export declare function handleGeminiStage(contentToProcess: string, sourceUrlForProcessing: string, logs: string[]): Promise&lt;{
    geminiResult: StageResult;
    extractedData: ExtractedFoodTruckDetails | undefined;
}&gt;;
export declare function handleSupabaseStage(extractedData: ExtractedFoodTruckDetails, sourceUrlForProcessing: string, isDryRun: boolean, logs: string[]): Promise&lt;StageResult&gt;;</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/api/test-integration/helpers.d.ts (Line 1:1 - Line 14:4), C:/AI/food-truck-finder-poc/dist/lib/lib/api/test-integration/helpers.d.ts (Line 1:1 - Line 14:7)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn313" onclick="toggleCodeBlock('cloneGroup313', 'expandBtn313', 'collapseBtn313')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn313" onclick="toggleCodeBlock('cloneGroup313', 'expandBtn313', 'collapseBtn313')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup313"><code class="language-typescript text-sm text-gray-800">import { type FirecrawlResponse } from '@/lib/firecrawl';
import { type FoodTruck, type ScrapingJob, type DataProcessingQueue } from '@/lib/supabase';
import type { GeminiResponse, MenuCategory } from '@/lib/types';
interface FirecrawlTestResult {
    success: boolean;
    result?: FirecrawlResponse;
    error?: string;
    details?: unknown;
}
export declare function testFirecrawlScraping(testUrl: string): Promise&lt;FirecrawlTestResult&gt;;
export declare function testGeminiProcessing(): Promise&lt;{
    success: boolean;
    error: string;
    details: any</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/api/test-integration/helpers.d.ts (Line 18:4 - Line 59:6), C:/AI/food-truck-finder-poc/dist/lib/lib/api/test-integration/helpers.d.ts (Line 18:2 - Line 59:7)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn314" onclick="toggleCodeBlock('cloneGroup314', 'expandBtn314', 'collapseBtn314')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn314" onclick="toggleCodeBlock('cloneGroup314', 'expandBtn314', 'collapseBtn314')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup314"><code class="language-typescript text-sm text-gray-800">;
    error?: undefined;
    details?: undefined;
}&gt;;
type GeminiProcessMenuDataResult = MenuCategory[];
interface SupabaseTestResults {
    testTruck: FoodTruck;
    testJob: ScrapingJob;
    queueItem: DataProcessingQueue;
    nearbyTrucks: FoodTruck[];
}
interface FormattedTestResults {
    success: boolean;
    message: string;
    results: {
        firecrawl: {
            success: boolean;
            dataLength: number;
        };
        gemini: {
            success: boolean;
            tokensUsed: number | undefined;
            categoriesFound: number;
        };
        supabase: {
            truckCreated: string;
            jobCreated: string;
            queueItemCreated: string;
            nearbyTrucksFound: number;
        };
    };
    testData: {
        truck: FoodTruck;
        processedMenu: MenuCategory[] | undefined;
        nearbyTrucks: FoodTruck[];
    };
}
export declare function testSupabaseOperations(testUrl: string, geminiResult: GeminiResponse&lt;GeminiProcessMenuDataResult&gt;): Promise&lt;SupabaseTestResults&gt;;
export declare function formatTestResults(scrapeResult: FirecrawlTestResult, geminiResult: GeminiResponse&lt;GeminiProcessMenuDataResult&gt;, supabaseResults: SupabaseTestResults): FormattedTestResults;
export declare function runIntegrationTestSteps(testUrl: string): Promise&lt;FirecrawlTestResult | {
    success: boolean;
    error</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/api/tavily/handlers.d.ts (Line 19:4 - Line 42:2), C:/AI/food-truck-finder-poc/dist/lib/lib/api/tavily/handlers.d.ts (Line 19:7 - Line 42:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn316" onclick="toggleCodeBlock('cloneGroup316', 'expandBtn316', 'collapseBtn316')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn316" onclick="toggleCodeBlock('cloneGroup316', 'expandBtn316', 'collapseBtn316')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup316"><code class="language-typescript text-sm text-gray-800">;
    }[];
}&gt;;
/**
* Performs a mock Tavily crawl operation.
* @example
* performTavilyCrawl({ key: 'value' })
* { results: [ { url: 'https://example-crawled-truck.com', title: 'Gourmet Food Truck', content: 'Premium mobile dining experience...' } ] }
* @param {Record&lt;string, unknown&gt;} params - Parameters for the mock crawl operation.
* @returns {Object} An object containing mock crawl results.
* @description
*   - Utilizes a mock implementation for demonstration purposes.
*   - Logs the crawling parameters to the console for debugging.
*/
export declare function performTavilyCrawl(params: Record&lt;string, unknown&gt;): {
    results: {
        url: string;
        title: string;
        content: string;
    }[];
};
export declare function performTavilyMap(params: Record&lt;string, unknown&gt;): {
    results: string[];
};</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/api/search/filters.d.ts (Line 1:1 - Line 30:2), C:/AI/food-truck-finder-poc/dist/lib/lib/api/search/filters.d.ts (Line 1:1 - Line 30:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn319" onclick="toggleCodeBlock('cloneGroup319', 'expandBtn319', 'collapseBtn319')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn319" onclick="toggleCodeBlock('cloneGroup319', 'expandBtn319', 'collapseBtn319')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup319"><code class="language-typescript text-sm text-gray-800">import type { FoodTruck } from '@/lib/types';
/**
* Filters an array of FoodTruck objects based on a given search query.
* @example
* applyTextSearchFilter(foodTrucksArray, 'taco')
* // Returns an array of FoodTruck objects where the truck name, description, or menu contains 'taco'
* @param {FoodTruck[]} trucks - An array of FoodTruck objects to be filtered.
* @param {string | null} query - Search query to filter the food trucks by.
* @returns {FoodTruck[]} An array of FoodTruck objects that match the search query.
* @description
*   - If the query is null or an empty string, the original array is returned unfiltered.
*   - The search is case-insensitive.
*   - Searches through truck names, descriptions, and menu item names and descriptions.
*   - Utilizes optional chaining to handle undefined or null values in truck descriptions and menus.
*/
export declare function applyTextSearchFilter(trucks: FoodTruck[], query: string | null): FoodTruck[];
export declare function applyCuisineFilter(trucks: FoodTruck[], cuisine: string | null): FoodTruck[];
/**
 * Filters a list of food trucks to only include those that are currently open.
 * @example
 * applyOpenNowFilter(trucks, true)
 * // returns list of trucks open at the current date and time
 * @param {FoodTruck[]} trucks - Array of food truck objects to be filtered.
 * @param {boolean} openNow - Flag to filter trucks that are open at the current time.
 * @returns {FoodTruck[]} Array of food trucks that are open now, or the unfiltered array if openNow is false.
 * @description
 *   - Uses the system's current date and time to determine if trucks are open.
 *   - Filters based on the truck's operating hours for the current day.
 */
export declare function applyOpenNowFilter(trucks: FoodTruck[], openNow: boolean): FoodTruck[];</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/api/scheduler/types.d.ts (Line 1:1 - Line 20:2), C:/AI/food-truck-finder-poc/dist/lib/lib/api/scheduler/types.d.ts (Line 1:1 - Line 20:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn321" onclick="toggleCodeBlock('cloneGroup321', 'expandBtn321', 'collapseBtn321')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn321" onclick="toggleCodeBlock('cloneGroup321', 'expandBtn321', 'collapseBtn321')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup321"><code class="language-typescript text-sm text-gray-800">export interface SchedulerTask {
    id: string;
    name: string;
    enabled: boolean;
    intervalMinutes: number;
    lastRun: string;
    lastSuccess: string;
    successCount: number;
    errorCount: number;
    nextRun: string | undefined;
    lastError?: string;
}
export interface PostRequestBody {
    action: 'start' | 'stop' | 'execute';
    taskId?: string;
}
export interface PutRequestBody {
    taskId: string;
    config: Partial&lt;SchedulerTask&gt;;
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/api/pipeline/types.d.ts (Line 1:1 - Line 14:2), C:/AI/food-truck-finder-poc/dist/lib/lib/api/pipeline/types.d.ts (Line 1:1 - Line 14:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn324" onclick="toggleCodeBlock('cloneGroup324', 'expandBtn324', 'collapseBtn324')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn324" onclick="toggleCodeBlock('cloneGroup324', 'expandBtn324', 'collapseBtn324')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup324"><code class="language-typescript text-sm text-gray-800">export interface PipelineRequestBody {
    action?: 'discovery' | 'processing' | 'full' | 'maintenance';
    target_url?: string;
    config?: {
        maxUrls?: number;
        maxUrlsToProcess?: number;
        targetCities?: string[];
        priority?: number;
        skipDiscovery?: boolean;
        retryFailedJobs?: boolean;
    };
    job_type?: string;
    priority?: number;
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/api/firecrawl/handlers.d.ts (Line 1:1 - Line 44:2), C:/AI/food-truck-finder-poc/dist/lib/api/firecrawl/handlers.d.ts (Line 1:1 - Line 44:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn327" onclick="toggleCodeBlock('cloneGroup327', 'expandBtn327', 'collapseBtn327')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn327" onclick="toggleCodeBlock('cloneGroup327', 'expandBtn327', 'collapseBtn327')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup327"><code class="language-typescript text-sm text-gray-800">import { NextResponse } from 'next/server';
/**
 * Executes a web scraping operation on the specified URL.
 * @example
 * handleScrapeOperation('https://example.com', { headers: {'User-Agent': 'Mozilla/5.0'} })
 * { success: true, data: [ &lt;scrapedContent&gt; ], error: null }
 * @param {string} url - The URL to be scraped.
 * @param {Record&lt;string, unknown&gt;} options - Additional configurations for the scraping operation.
 * @returns {object} An object containing the success status, scraped data if successful, and any error encountered.
 * @description
 *   - Utilizes 'firecrawl' library to perform the scraping.
 *   - The scrape operation targets the main content of the page only.
 *   - The resulting data is returned in both 'markdown' and 'html' formats.
 */
export declare function handleScrapeOperation(url: string, options: Record&lt;string, unknown&gt;): Promise&lt;any&gt;;
/**
* Polls the crawl status of a given job ID until the job is completed or a maximum number of attempts is reached.
* @example
* pollCrawlStatus('12345xyz')
* NextResponse { success: true, data: {...} }
* @param {string} jobId - The unique identifier for the crawl job.
* @returns {Promise&lt;NextResponse&gt;} A JSON response indicating the result of the crawl job: completed, failed, or timed out.
* @description
*   - Uses a polling mechanism with a fixed interval to check the job status repeatedly.
*   - Handles completed and failed job statuses with different JSON responses.
*   - Implemented timeout after 30 attempts to prevent indefinite polling.
*   - Provides appropriate HTTP status codes for each response scenario.
*/
export declare function pollCrawlStatus(jobId: string): Promise&lt;NextResponse&gt;;
/**
* Initiates and handles the web crawling operation with specified options.
* @example
* handleCrawlOperation('http://example.com', { maxDepth: 3, limit: 50 })
* Returns the status of the crawl job operation.
* @param {string} url - The URL of the website to be crawled.
* @param {Record&lt;string, unknown&gt;} options - Options to configure the crawling operation including maxDepth, limit, includes, and excludes.
* @returns {Promise&lt;Object&gt;} A JSON response object containing the success status and error message, or initiates the crawl status polling.
* @description
*   - Uses `firecrawl` library to start a web crawling job with specific configurations.
*   - Handles crawl job initiation success and failure scenarios.
*   - Returns a JSON response on failure with error details.
*/
export declare function handleCrawlOperation(url: string, options: Record&lt;string, unknown&gt;): Promise&lt;any&gt;;
export declare function handleSearchOperation(): any;</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/app/api/trucks/route.ts (Line 110:2 - Line 118:2), C:/AI/food-truck-finder-poc/lib/api/test-integration/helpers.ts (Line 106:2 - Line 114:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn329" onclick="toggleCodeBlock('cloneGroup329', 'expandBtn329', 'collapseBtn329')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn329" onclick="toggleCodeBlock('cloneGroup329', 'expandBtn329', 'collapseBtn329')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup329"><code class="language-typescript text-sm text-gray-800">{
      monday: { closed: true },
      tuesday: { closed: true },
      wednesday: { closed: true },
      thursday: { closed: true },
      friday: { closed: true },
      saturday: { closed: true },
      sunday: { closed: true },
    })</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/app/api/trucks/route.ts (Line 170:29 - Line 179:2), C:/AI/food-truck-finder-poc/app/api/trucks/route.ts (Line 152:29 - Line 161:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn330" onclick="toggleCodeBlock('cloneGroup330', 'expandBtn330', 'collapseBtn330')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn330" onclick="toggleCodeBlock('cloneGroup330', 'expandBtn330', 'collapseBtn330')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup330"><code class="language-typescript text-sm text-gray-800">, error);
    if (error instanceof z.ZodError) {
      return NextResponse.json({ error: error.errors }, { status: 400 });
    }
    return NextResponse.json(
      { error: error instanceof Error ? error.message : String(error) },
      { status: 500 },
    );
  }
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/app/api/process-jobs/route.ts (Line 12:5 - Line 19:6), C:/AI/food-truck-finder-poc/lib/api/cron/auto-scrape/improvedHandler.ts (Line 25:5 - Line 32:12)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn331" onclick="toggleCodeBlock('cloneGroup331', 'expandBtn331', 'collapseBtn331')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn331" onclick="toggleCodeBlock('cloneGroup331', 'expandBtn331', 'collapseBtn331')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup331"><code class="language-typescript text-sm text-gray-800">const authHeader = request.headers.get('authorization');
    const cronSecret = process.env.CRON_SECRET;

    if (!cronSecret || authHeader !== `Bearer ${cronSecret}`) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/app/api/autonomous-discovery/route.ts (Line 20:47 - Line 42:2), C:/AI/food-truck-finder-poc/app/api/enhanced-pipeline/route.ts (Line 21:62 - Line 43:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn332" onclick="toggleCodeBlock('cloneGroup332', 'expandBtn332', 'collapseBtn332')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn332" onclick="toggleCodeBlock('cloneGroup332', 'expandBtn332', 'collapseBtn332')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup332"><code class="language-typescript text-sm text-gray-800">,
        },
      },
    },
    { status: 410 },
  ); // 410 Gone - Resource no longer available
}

export function GET() {
  return NextResponse.json(
    {
      status: 'DEPRECATED',
      message: 'This endpoint has been consolidated into /api/pipeline',
      migration: {
        newEndpoint: '/api/pipeline',
        documentation: 'See /api/pipeline for current API documentation',
        deprecationDate: '2024-12-09',
        removalDate: '2025-01-01',
      },
    },
    { status: 410 },
  );
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/utils/foodTruckHelpers.ts (Line 277:2 - Line 282:6), C:/AI/food-truck-finder-poc/lib/api/search/filters.ts (Line 76:6 - Line 81:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn343" onclick="toggleCodeBlock('cloneGroup343', 'expandBtn343', 'collapseBtn343')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn343" onclick="toggleCodeBlock('cloneGroup343', 'expandBtn343', 'collapseBtn343')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup343"><code class="language-typescript text-sm text-gray-800">;
    const openTime = Number.parseInt(hours.open.replace(':', ''), 10);
    const closeTime = Number.parseInt(hours.close.replace(':', ''), 10);

    return currentTime &gt;= openTime &amp;&amp; currentTime &lt;= closeTime;
  } catch</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/utils/apiHelpers.ts (Line 6:2 - Line 15:7), C:/AI/food-truck-finder-poc/app/api/trucks/route.ts (Line 153:2 - Line 161:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn353" onclick="toggleCodeBlock('cloneGroup353', 'expandBtn353', 'collapseBtn353')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn353" onclick="toggleCodeBlock('cloneGroup353', 'expandBtn353', 'collapseBtn353')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup353"><code class="language-typescript text-sm text-gray-800">ZodError) {
    return NextResponse.json({ error: error.errors }, { status: 400 });
  }
  return NextResponse.json(
    { error: error instanceof Error ? error.message : String(error) },
    { status: 500 },
  );
}

export</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/security/auditLogger.ts (Line 9:1 - Line 27:2), C:/AI/food-truck-finder-poc/dist/lib/lib/security/auditLogger.d.ts (Line 5:1 - Line 20:16)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn356" onclick="toggleCodeBlock('cloneGroup356', 'expandBtn356', 'collapseBtn356')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn356" onclick="toggleCodeBlock('cloneGroup356', 'expandBtn356', 'collapseBtn356')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup356"><code class="language-typescript text-sm text-gray-800">type SeverityLevel = 'info' | 'warning' | 'error' | 'critical';

export interface AuditLogEntry {
  user_id: string;
  user_email: string;
  action: string;
  resource_type: string;
  resource_id?: string;
  details?: Record&lt;string, unknown&gt;;
  ip_address?: string;
  user_agent?: string;
  session_id?: string;
  timestamp: string;
  severity: SeverityLevel;
}

export interface SecurityEvent {
  event_type:
    |</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/security/auditLogger.ts (Line 27:2 - Line 45:4), C:/AI/food-truck-finder-poc/dist/lib/lib/security/auditLogger.d.ts (Line 20:2 - Line 30:4)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn357" onclick="toggleCodeBlock('cloneGroup357', 'expandBtn357', 'collapseBtn357')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn357" onclick="toggleCodeBlock('cloneGroup357', 'expandBtn357', 'collapseBtn357')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup357"><code class="language-typescript text-sm text-gray-800">'login_attempt'
    | 'login_success'
    | 'login_failure'
    | 'logout'
    | 'permission_denied'
    | 'data_access'
    | 'data_modification'
    | 'admin_action';
  user_id?: string;
  user_email?: string;
  ip_address?: string;
  user_agent?: string;
  details?: Record&lt;string, unknown&gt;;
  severity: SeverityLevel;
}

/**
 * Audit Logger Service
 */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/security/auditLogger.ts (Line 50:2 - Line 62:2), C:/AI/food-truck-finder-poc/dist/lib/lib/security/auditLogger.d.ts (Line 35:2 - Line 47:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn358" onclick="toggleCodeBlock('cloneGroup358', 'expandBtn358', 'collapseBtn358')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn358" onclick="toggleCodeBlock('cloneGroup358', 'expandBtn358', 'collapseBtn358')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup358"><code class="language-typescript text-sm text-gray-800">logAdminAction(options: {
    userId: string;
    userEmail: string;
    action: string;
    resourceType: string;
    resourceId?: string;
    details?: Record&lt;string, unknown&gt;;
    request?: {
      ip?: string;
      userAgent?: string;
      sessionId?: string;
    };
  }): Promise&lt;void&gt; {</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/security/auditLogger.ts (Line 124:2 - Line 133:2), C:/AI/food-truck-finder-poc/dist/lib/lib/security/auditLogger.d.ts (Line 55:2 - Line 64:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn359" onclick="toggleCodeBlock('cloneGroup359', 'expandBtn359', 'collapseBtn359')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn359" onclick="toggleCodeBlock('cloneGroup359', 'expandBtn359', 'collapseBtn359')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup359"><code class="language-typescript text-sm text-gray-800">logAuthEvent(options: {
    eventType: 'login_attempt' | 'login_success' | 'login_failure' | 'logout';
    userEmail?: string;
    userId?: string;
    request?: {
      ip?: string;
      userAgent?: string;
    };
    details?: Record&lt;string, unknown&gt;;
  }): Promise&lt;void&gt; {</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/security/auditLogger.ts (Line 151:2 - Line 161:2), C:/AI/food-truck-finder-poc/dist/lib/lib/security/auditLogger.d.ts (Line 68:2 - Line 78:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn360" onclick="toggleCodeBlock('cloneGroup360', 'expandBtn360', 'collapseBtn360')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn360" onclick="toggleCodeBlock('cloneGroup360', 'expandBtn360', 'collapseBtn360')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup360"><code class="language-typescript text-sm text-gray-800">logDataAccess(options: {
    userId: string;
    userEmail: string;
    resourceType: string;
    resourceId?: string;
    action?: 'read' | 'search' | 'export' | 'admin_access';
    request?: {
      ip?: string;
      userAgent?: string;
    };
  }): Promise&lt;void&gt; {</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/schemas/truck.ts (Line 74:2 - Line 80:2), C:/AI/food-truck-finder-poc/app/api/trucks/route.ts (Line 127:2 - Line 135:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn369" onclick="toggleCodeBlock('cloneGroup369', 'expandBtn369', 'collapseBtn369')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn369" onclick="toggleCodeBlock('cloneGroup369', 'expandBtn369', 'collapseBtn369')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup369"><code class="language-typescript text-sm text-gray-800">z.object({
  instagram: z.string().optional(),
  facebook: z.string().optional(),
  twitter: z.string().optional(),
  tiktok: z.string().optional(),
  yelp: z.string().optional(),
});</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/schemas/truck.ts (Line 83:2 - Line 90:2), C:/AI/food-truck-finder-poc/app/api/trucks/route.ts (Line 64:7 - Line 71:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn370" onclick="toggleCodeBlock('cloneGroup370', 'expandBtn370', 'collapseBtn370')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn370" onclick="toggleCodeBlock('cloneGroup370', 'expandBtn370', 'collapseBtn370')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup370"><code class="language-typescript text-sm text-gray-800">z.object({
  address: z.string().optional(),
  city: z.string().optional(),
  state: z.string().optional(),
  zip_code: z.string().optional(),
  lat: z.number().optional(),
  lng: z.number().optional(),
  timestamp: z.string(),</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/monitoring/apiMonitor.ts (Line 30:6 - Line 49:2), C:/AI/food-truck-finder-poc/dist/lib/lib/monitoring/apiMonitor.d.ts (Line 62:2 - Line 81:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn399" onclick="toggleCodeBlock('cloneGroup399', 'expandBtn399', 'collapseBtn399')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn399" onclick="toggleCodeBlock('cloneGroup399', 'expandBtn399', 'collapseBtn399')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup399"><code class="language-typescript text-sm text-gray-800">;

export type APIService = keyof typeof API_LIMITS;
export type AlertLevel = 'info' | 'warning' | 'critical';

export interface APIUsageAlert {
  service: APIService;
  level: AlertLevel;
  message: string;
  usage: {
    current: number;
    limit: number;
    percentage: number;
  };
  timestamp: string;
  recommendations: string[];
}

export interface APIUsageData {
  requests: { used: number; limit: number; percentage: number }</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/mappers/uprootedVeganMapper.ts (Line 23:3 - Line 42:19), C:/AI/food-truck-finder-poc/dist/lib/lib/mappers/uprootedVeganMapper.d.ts (Line 16:5 - Line 34:20)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn412" onclick="toggleCodeBlock('cloneGroup412', 'expandBtn412', 'collapseBtn412')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn412" onclick="toggleCodeBlock('cloneGroup412', 'expandBtn412', 'collapseBtn412')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup412"><code class="language-typescript text-sm text-gray-800">exact_location?: {
    lat: number;
    lng: number;
    address?: string;
    timestamp?: string;
  };
  city_location?: {
    lat: number;
    lng: number;
    address?: string;
    timestamp?: string;
  };
  current_location?: {
    lat: number;
    lng: number;
    address?: string;
    timestamp?: string;
  };
  
  // Schedule fields</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/mappers/uprootedVeganMapper.ts (Line 43:3 - Line 55:18), C:/AI/food-truck-finder-poc/dist/lib/lib/mappers/uprootedVeganMapper.d.ts (Line 34:5 - Line 45:16)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn413" onclick="toggleCodeBlock('cloneGroup413', 'expandBtn413', 'collapseBtn413')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn413" onclick="toggleCodeBlock('cloneGroup413', 'expandBtn413', 'collapseBtn413')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup413"><code class="language-typescript text-sm text-gray-800">scheduled_locations?: {
    address?: string;
    city?: string;
    state?: string;
    zip_code?: string;
    lat?: number;
    lng?: number;
    timestamp: string;
    start_time: string;
    end_time: string;
  }[];
  
  // Menu and hours</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/data-quality/duplicatePrevention.ts (Line 26:6 - Line 46:4), C:/AI/food-truck-finder-poc/dist/lib/lib/data-quality/duplicatePrevention.d.ts (Line 20:2 - Line 37:4)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn425" onclick="toggleCodeBlock('cloneGroup425', 'expandBtn425', 'collapseBtn425')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn425" onclick="toggleCodeBlock('cloneGroup425', 'expandBtn425', 'collapseBtn425')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup425"><code class="language-typescript text-sm text-gray-800">;

export interface DuplicateMatch {
  existingTruck: FoodTruck;
  similarity: number;
  matchedFields: string[];
  confidence: 'high' | 'medium' | 'low';
  recommendation: 'merge' | 'update' | 'skip' | 'manual_review';
}

export interface DuplicateDetectionResult {
  isDuplicate: boolean;
  matches: DuplicateMatch[];
  bestMatch?: DuplicateMatch;
  action: 'create' | 'update' | 'merge' | 'manual_review';
  reason: string;
}

/**
 * Advanced Duplicate Prevention Service
 */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/data-quality/duplicatePrevention.ts (Line 289:3 - Line 305:6), C:/AI/food-truck-finder-poc/lib/performance/databaseCache.ts (Line 276:7 - Line 290:9)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn426" onclick="toggleCodeBlock('cloneGroup426', 'expandBtn426', 'collapseBtn426')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn426" onclick="toggleCodeBlock('cloneGroup426', 'expandBtn426', 'collapseBtn426')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup426"><code class="language-typescript text-sm text-gray-800">): number {
    const R = 6371; // Earth's radius in kilometers
    const dLat = ((lat2 - lat1) * Math.PI) / 180;
    const dLng = ((lng2 - lng1) * Math.PI) / 180;
    const a =
      Math.sin(dLat / 2) * Math.sin(dLat / 2) +
      Math.cos((lat1 * Math.PI) / 180) *
        Math.cos((lat2 * Math.PI) / 180) *
        Math.sin(dLng / 2) *
        Math.sin(dLng / 2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    return R * c;
  }

  /**
   * Calculate contact similarity
   */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/hooks/realtime/setupEventSourceListeners.ts (Line 2:34 - Line 23:10), C:/AI/food-truck-finder-poc/lib/api/admin/realtime-events/handlers.ts (Line 9:13 - Line 43:3)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn448" onclick="toggleCodeBlock('cloneGroup448', 'expandBtn448', 'collapseBtn448')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn448" onclick="toggleCodeBlock('cloneGroup448', 'expandBtn448', 'collapseBtn448')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup448"><code class="language-typescript text-sm text-gray-800">;

interface RealtimeMetrics {
  scrapingJobs: {
    active: number;
    completed: number;
    failed: number;
    pending: number;
  };
  dataQuality: {
    averageScore: number;
    totalTrucks: number;
    recentChanges: number;
  };
  systemHealth: {
    status: 'healthy' | 'warning' | 'error';
    uptime: number;
    lastUpdate: string;
  };
}

interface</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/hooks/realtime/setupEventSourceListeners.ts (Line 24:3 - Line 30:10), C:/AI/food-truck-finder-poc/hooks/realtime/useConnectionManagement.ts (Line 19:3 - Line 41:4)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn449" onclick="toggleCodeBlock('cloneGroup449', 'expandBtn449', 'collapseBtn449')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn449" onclick="toggleCodeBlock('cloneGroup449', 'expandBtn449', 'collapseBtn449')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup449"><code class="language-typescript text-sm text-gray-800">setIsConnected: (connected: boolean) =&gt; void;
  setIsConnecting: (connecting: boolean) =&gt; void;
  setConnectionError: (error: string | undefined) =&gt; void;
  setConnectionAttempts: (attempts: number | ((prev: number) =&gt; number)) =&gt; void;
}

interface</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/hooks/realtime/setupEventSourceListeners.ts (Line 155:5 - Line 165:9), C:/AI/food-truck-finder-poc/hooks/realtime/useConnectionManagement.ts (Line 15:8 - Line 41:4)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn450" onclick="toggleCodeBlock('cloneGroup450', 'expandBtn450', 'collapseBtn450')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn450" onclick="toggleCodeBlock('cloneGroup450', 'expandBtn450', 'collapseBtn450')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup450"><code class="language-typescript text-sm text-gray-800">;
  setLastEventTime: React.Dispatch&lt;React.SetStateAction&lt;Date | undefined&gt;&gt;;
  setLatestMetrics: React.Dispatch&lt;React.SetStateAction&lt;RealtimeMetrics | undefined&gt;&gt;;
  setRecentEvents: React.Dispatch&lt;React.SetStateAction&lt;RealtimeEvent[]&gt;&gt;;
  setIsConnected: (connected: boolean) =&gt; void;
  setIsConnecting: (connecting: boolean) =&gt; void;
  setConnectionError: (error: string | undefined) =&gt; void;
  setConnectionAttempts: (attempts: number | ((prev: number) =&gt; number)) =&gt; void;
}

function</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/hooks/realtime/createEventSourceConnection.ts (Line 1:2 - Line 21:7), C:/AI/food-truck-finder-poc/hooks/realtime/setupEventSourceListeners.ts (Line 1:2 - Line 43:3)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn451" onclick="toggleCodeBlock('cloneGroup451', 'expandBtn451', 'collapseBtn451')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn451" onclick="toggleCodeBlock('cloneGroup451', 'expandBtn451', 'collapseBtn451')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup451"><code class="language-typescript text-sm text-gray-800">React from 'react';
import type { RealtimeEvent } from '../useRealtimeAdminEvents.types';
interface RealtimeMetrics {
  scrapingJobs: {
    active: number;
    completed: number;
    failed: number;
    pending: number;
  };
  dataQuality: {
    averageScore: number;
    totalTrucks: number;
    recentChanges: number;
  };
  systemHealth: {
    status: 'healthy' | 'warning' | 'error';
    uptime: number;
    lastUpdate: string;
  };
}
import</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/hooks/realtime/createEventSourceConnection.ts (Line 138:5 - Line 147:16), C:/AI/food-truck-finder-poc/hooks/realtime/setupEventSourceListeners.ts (Line 154:2 - Line 23:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn452" onclick="toggleCodeBlock('cloneGroup452', 'expandBtn452', 'collapseBtn452')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn452" onclick="toggleCodeBlock('cloneGroup452', 'expandBtn452', 'collapseBtn452')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup452"><code class="language-typescript text-sm text-gray-800">;
  connect: () =&gt; void;
  setLastEventTime: React.Dispatch&lt;React.SetStateAction&lt;Date | undefined&gt;&gt;;
  setLatestMetrics: React.Dispatch&lt;React.SetStateAction&lt;RealtimeMetrics | undefined&gt;&gt;;
  setRecentEvents: React.Dispatch&lt;React.SetStateAction&lt;RealtimeEvent[]&gt;&gt;;
  setIsConnected: (connected: boolean) =&gt; void;
  setIsConnecting: (connecting: boolean) =&gt; void;
  setConnectionError: (error: string | undefined) =&gt; void;
  setConnectionAttempts: (attempts: number | ((prev: number) =&gt; number)) =&gt; void;
  connectionState</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/utils/typeGuards.d.ts (Line 1:1 - Line 42:2), C:/AI/food-truck-finder-poc/dist/lib/lib/utils/typeGuards.d.ts (Line 1:1 - Line 42:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn454" onclick="toggleCodeBlock('cloneGroup454', 'expandBtn454', 'collapseBtn454')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn454" onclick="toggleCodeBlock('cloneGroup454', 'expandBtn454', 'collapseBtn454')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup454"><code class="language-typescript text-sm text-gray-800">import type { FoodTruck, FoodTruckSchema } from '../types';
/**
 * Checks if a value is a non-null object.
 */
export declare function isValidObject(value: unknown): value is Record&lt;string, unknown&gt;;
/**
 * Safely checks if an object has a specific property. This is a robust implementation.
 */
export declare function hasProperty&lt;T extends object&gt;(obj: T, prop: PropertyKey): prop is keyof T;
/**
 * Checks if a value is a string.
 */
export declare function isString(value: unknown): value is string;
/**
 * Checks if a value is a valid number (and not NaN).
 */
export declare function isNumber(value: unknown): value is number;
/**
 * Checks if a value is an array.
 */
export declare function isArray(value: unknown): value is unknown[];
/**
 * Checks if a value is an array of strings.
 */
export declare function isStringArray(value: unknown): value is string[];
/**
 * Asserts that a value is of a specific type, throwing a TypeError if validation fails.
 */
export declare function assertType&lt;T&gt;(value: unknown, validator: (v: unknown) =&gt; v is T, errorMessage?: string): asserts value is T;
/**
 * Safely assigns a value if it passes validation, otherwise returns a fallback.
 * Useful for providing default values for potentially invalid or missing data.
 */
export declare function safeAssign&lt;T&gt;(value: unknown, fallback: T, validator: (v: unknown) =&gt; v is T): T;
/**
 * Type guard for the base FoodTruckSchema.
 */
export declare function isFoodTruckSchema(value: unknown): value is FoodTruckSchema;
/**
 * Type guard for the full FoodTruck object (schema + ID fields).
 */
export declare function isFoodTruck(value: unknown): value is FoodTruck;</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/utils/QualityScorer.d.ts (Line 1:1 - Line 40:2), C:/AI/food-truck-finder-poc/dist/lib/lib/utils/QualityScorer.d.ts (Line 1:1 - Line 40:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn456" onclick="toggleCodeBlock('cloneGroup456', 'expandBtn456', 'collapseBtn456')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn456" onclick="toggleCodeBlock('cloneGroup456', 'expandBtn456', 'collapseBtn456')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup456"><code class="language-typescript text-sm text-gray-800">import type { FoodTruck } from '@/lib/supabase';
export interface QualityAssessment {
    score: number;
    issues: string[];
}
export type QualityCategory = {
    label: string;
    color: string;
};
/**
 * Computes the quality score of a given food truck based on multiple criteria.
 * @example
 * calculateQualityScore(truckInstance)
 * { score: 3, issues: [&quot;Missing contact information&quot;, &quot;Incomplete schedule&quot;] }
 * @param {FoodTruck} truck - The food truck object to be assessed.
 * @returns {QualityAssessment} An object containing the computed score and a list of identified issues.
 * @description
 *   - The score starts at 1 and is adjusted based on various assessments.
 *   - The function ensures the score never drops below zero.
 *   - Issues that affect the score are collected and returned for analysis.
 */
export declare function calculateQualityScore(truck: FoodTruck): QualityAssessment;
export declare function categorizeQualityScore(score: number): QualityCategory;
export declare function formatQualityScore(score: number | null | undefined): string;
export declare function getQualityBadgeClasses(score: number | null | undefined): string;
export declare function getQualityScoreAriaLabel(score: number | null | undefined): string;
export declare const DataQualityService: {
    calculateQualityScore: typeof calculateQualityScore;
    categorizeQualityScore: typeof categorizeQualityScore;
    formatQualityScore: typeof formatQualityScore;
    getQualityBadgeClasses: typeof getQualityBadgeClasses;
    getQualityScoreAriaLabel: typeof getQualityScoreAriaLabel;
    batchUpdateQualityScores(limit?: number): Promise&lt;{
        updatedCount: number;
        errors: string[];
    }&gt;;
    updateTruckQualityScore(truckId: string): Promise&lt;{
        success: boolean;
    }&gt;;
};</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/utils/geocoding.d.ts (Line 1:1 - Line 32:2), C:/AI/food-truck-finder-poc/dist/lib/lib/utils/geocoding.d.ts (Line 1:1 - Line 32:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn458" onclick="toggleCodeBlock('cloneGroup458', 'expandBtn458', 'collapseBtn458')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn458" onclick="toggleCodeBlock('cloneGroup458', 'expandBtn458', 'collapseBtn458')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup458"><code class="language-typescript text-sm text-gray-800">/**
 * Geocoding utilities using Nominatim (OpenStreetMap's free geocoding service)
 * Converts addresses to lat/lng coordinates for map display
 */
interface GeocodeResult {
    lat: number;
    lng: number;
    formatted_address: string;
    success: boolean;
}
/**
 * Geocodes an address to get latitude and longitude coordinates
 * @param address - The address to geocode
 * @param city - Optional city to improve accuracy (defaults to Charleston, SC)
 * @returns Promise containing coordinates and formatted address
 */
export declare function geocodeAddress(address: string, city?: string): Promise&lt;GeocodeResult&gt;;
/**
 * Fallback coordinates for Charleston, SC when geocoding fails
 */
export declare const CHARLESTON_FALLBACK: {
    lat: number;
    lng: number;
};
/**
 * Geocodes multiple addresses with rate limiting to avoid overwhelming the service
 * @param addresses - Array of addresses to geocode
 * @param delayMs - Delay between requests (default 1000ms as recommended by Nominatim)
 * @returns Promise array of geocoding results
 */
export declare function geocodeAddressesBatch(addresses: string[], delayMs?: number): Promise&lt;GeocodeResult[]&gt;;
export {};</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/utils/foodTruckHelpers.d.ts (Line 1:1 - Line 107:2), C:/AI/food-truck-finder-poc/dist/lib/lib/utils/foodTruckHelpers.d.ts (Line 1:1 - Line 107:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn460" onclick="toggleCodeBlock('cloneGroup460', 'expandBtn460', 'collapseBtn460')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn460" onclick="toggleCodeBlock('cloneGroup460', 'expandBtn460', 'collapseBtn460')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup460"><code class="language-typescript text-sm text-gray-800">import type { FoodTruck, DailyOperatingHours, MenuItem } from '@/lib/types';
export declare const getCurrentDay: () =&gt; string;
export declare const formatPrice: (price: number | string) =&gt; string;
/**
* Converts operational hours to a readable format or returns 'Closed' if applicable.
* @example
* formatOperatingHours({ open: '09:00', close: '17:00', closed: false })
* '9:00 AM - 5:00 PM'
* @param {DailyOperatingHours} hours - Object containing daily opening and closing times, and closed status.
* @returns {string} Formatted operating hours string or 'Closed'.
* @description
*   - Handles conversion of military time to 12-hour format.
*   - Adjusts for typical date parsing without relying on actual date due to fixed date string.
*   - Properly responds to 'closed' status by returning 'Closed'.
*   - Locales can impact formatted output by changing time conventions.
*/
export declare const formatHours: (hours: DailyOperatingHours) =&gt; string;
export declare const getPopularItems: (truck: FoodTruck) =&gt; MenuItem[];
/**
 * Calculates the price range of all items in the food truck's menu.
 * @example
 * getPriceRange(foodTruck)
 * &quot;5.00 - 12.50&quot;
 * @param {FoodTruck} truck - The food truck object containing menu details.
 * @returns {string} Returns a formatted string representing the price range or 'N/A' if no valid prices are found.
 * @description
 *   - Utilizes the optional chaining operator to safely access nested menu items.
 *   - Filters out non-numeric and undefined prices before calculating the range.
 *   - Formats the minimum and maximum prices using a helper function.
 */
export declare const getPriceRange: (truck: FoodTruck) =&gt; string;
export declare const getTodayHours: (truck: FoodTruck) =&gt; any;
/**
 * Retrieves the user's geolocation and updates the location state.
 * @example
 * getUserLocationHelper(setUserLocation)
 * // Updates user's location or defaults to San Francisco
 * @param {function} setUserLocation - Callback function to update user's location state with latitude and longitude.
 * @returns {void} Function does not return anything.
 * @description
 *   - Defaults the location to San Francisco if geolocation access is denied or not supported.
 *   - Utilizes browser's geolocation API to fetch current coordinates.
 *   - Provides a warning in the console if location access is denied.
 */
export declare function getUserLocationHelper(setUserLocation: (location: {
    lat: number;
    lng: number;
}) =&gt; void): void;
/**
 * Loads food truck data from the server and updates state.
 * @example
 * loadFoodTrucksHelper(setTrucks, setLoading)
 * undefined
 * @param {(trucks: FoodTruck[]) =&gt; void} setTrucks - Callback to update the state with loaded food trucks.
 * @param {(loading: boolean) =&gt; void} setLoading - Callback to update the loading state.
 * @returns {void} No return value.
 * @description
 *   - Fetches data from '/api/trucks' endpoint.
 *   - Parses the response and expects an object containing a 'trucks' array.
 *   - Logs an error message to the console if fetching or parsing fails.
 *   - Ensures loading state is updated to false in all cases.
 */
export declare function loadFoodTrucksHelper(setTrucks: (trucks: FoodTruck[]) =&gt; void, setLoading: (loading: boolean) =&gt; void): Promise&lt;void&gt;;
/**
* Loads nearby food trucks based on user's location.
* @example
* loadNearbyTrucksHelper({ lat: 37.7749, lng: -122.4194 }, setTrucksCallback)
* // sets trucks with food truck data or an empty array
* @param {{ lat: number; lng: number } | undefined} userLocation - The location of the user used to find nearby trucks.
* @param {(trucks: FoodTruck[]) =&gt; void} setTrucks - Callback function to set the trucks data.
* @returns {void} No return value.
* @description
*   - Fetches nearby trucks from the API using latitude and longitude.
*   - Uses a fixed radius of 10 units for truck search.
*   - Handles errors by logging them to the console.
*/
export declare function loadNearbyTrucksHelper(userLocation: {
    lat: number;
    lng: number;
} | undefined, setTrucks: (trucks: FoodTruck[]) =&gt; void): Promise&lt;void&gt;;
/**
 * Determines if a food truck has enough essential data to be displayed to users.
 * @example
 * isViableTruck(foodTruck)
 * // returns true if truck has name and location, false otherwise
 * @param {FoodTruck} truck - The food truck object to validate.
 * @returns {boolean} Indicates whether the truck should be displayed.
 * @description
 *   - Checks for minimum required fields: name and valid location coordinates.
 *   - Ensures location has either coordinates OR a meaningful address.
 *   - Flags trucks missing essential data for admin review.
 */
export declare function isViableTruck(truck: FoodTruck): boolean;
/**
 * Determines if the food truck is currently open based on its operating hours.
 * @example
 * isTruckOpen(myFoodTruck)
 * // returns true or false depending on current time and truck's operating hours
 * @param {FoodTruck} truck - The food truck object with operating hours.
 * @returns {boolean} Indicates whether the truck is open.
 * @description
 *   - Utilizes the current day's name to fetch operating hours.
 *   - Handles potential errors in parsing operating hours.
 *   - Logs errors related to parsing time and truck name.
 *   - Uses military time format (HHMM) for comparison.
 */
export declare function isTruckOpen(truck: FoodTruck): boolean;</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/utils/dataQualityFormatters.d.ts (Line 1:1 - Line 112:2), C:/AI/food-truck-finder-poc/dist/lib/lib/utils/dataQualityFormatters.d.ts (Line 1:1 - Line 112:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn462" onclick="toggleCodeBlock('cloneGroup462', 'expandBtn462', 'collapseBtn462')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn462" onclick="toggleCodeBlock('cloneGroup462', 'expandBtn462', 'collapseBtn462')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup462"><code class="language-typescript text-sm text-gray-800">/**
 * SOTA Data Quality Formatting Utilities
 * Provides consistent formatting and categorization for data quality metrics
 */
export interface QualityThresholds {
    high: number;
    medium: number;
    low: number;
}
export interface QualityCategory {
    label: 'High' | 'Medium' | 'Low';
    color: string;
    bgColor: string;
    textColor: string;
}
export declare const QUALITY_THRESHOLDS: QualityThresholds;
export declare const QUALITY_CATEGORIES: Record&lt;string, QualityCategory&gt;;
/**
 * Formats a quality score as a percentage with proper precision
 * @param score - Quality score (0-1 range)
 * @param precision - Number of decimal places (default: 1)
 * @returns Formatted percentage string
 */
export declare function formatQualityScore(score: number | null | undefined, precision?: number): string;
/**
 * Categorizes a quality score into high/medium/low categories
 * @param score - Quality score (0-1 range)
 * @returns Quality category object
 */
export declare function categorizeQualityScore(score: number | null | undefined): QualityCategory;
/**
 * Gets the appropriate CSS classes for a quality score badge
 * @param score - Quality score (0-1 range)
 * @returns CSS class string for badge styling
 */
export declare function getQualityBadgeClasses(score: number | null | undefined): string;
/**
 * Calculates quality score trend indicator
 * @param currentScore - Current quality score
 * @param previousScore - Previous quality score
 * @returns Trend object with direction and percentage change
 */
export declare function calculateQualityTrend(currentScore: number | null | undefined, previousScore: number | null | undefined): {
    direction: 'up' | 'down' | 'stable' | 'unknown';
    change: number;
    changeText: string;
};
/**
 * Generates quality improvement suggestions based on score
 * @param score - Quality score (0-1 range)
 * @returns Array of improvement suggestions
 */
export declare function getQualityImprovementSuggestions(score: number | null | undefined): string[];
/**
 * Formats quality statistics for display
 * @param stats - Raw quality statistics from database
 * @returns Formatted statistics object
 */
export declare function formatQualityStats(stats: {
    total_trucks: number;
    avg_quality_score: number;
    high_quality_count: number;
    medium_quality_count: number;
    low_quality_count: number;
    verified_count: number;
    pending_count: number;
    flagged_count: number;
}): {
    totalTrucks: number;
    averageScore: string;
    averageScoreRaw: number;
    distribution: {
        high: {
            count: number;
            percentage: string;
        };
        medium: {
            count: number;
            percentage: string;
        };
        low: {
            count: number;
            percentage: string;
        };
    };
    verification: {
        verified: {
            count: number;
            percentage: string;
        };
        pending: {
            count: number;
            percentage: string;
        };
        flagged: {
            count: number;
            percentage: string;
        };
    };
};
/**
 * Validates if a quality score is within acceptable range
 * @param score - Quality score to validate
 * @returns Boolean indicating if score is valid
 */
export declare function isValidQualityScore(score: number | null | undefined): boolean;
/**
 * Generates accessibility-friendly description for quality score
 * @param score - Quality score (0-1 range)
 * @returns Screen reader friendly description
 */
export declare function getQualityScoreAriaLabel(score: number | null | undefined): string;</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/security/rateLimiter.d.ts (Line 1:1 - Line 78:2), C:/AI/food-truck-finder-poc/dist/lib/lib/security/rateLimiter.d.ts (Line 1:1 - Line 78:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn465" onclick="toggleCodeBlock('cloneGroup465', 'expandBtn465', 'collapseBtn465')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn465" onclick="toggleCodeBlock('cloneGroup465', 'expandBtn465', 'collapseBtn465')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup465"><code class="language-typescript text-sm text-gray-800">/**
 * SOTA Rate Limiting Implementation
 * Prevents brute force attacks and API abuse with intelligent rate limiting
 */
export declare const RATE_LIMIT_CONFIGS: {
    readonly auth: {
        readonly windowMs: number;
        readonly maxRequests: 5;
        readonly blockDurationMs: number;
        readonly skipSuccessfulRequests: true;
    };
    readonly api: {
        readonly windowMs: number;
        readonly maxRequests: 60;
        readonly blockDurationMs: number;
        readonly skipSuccessfulRequests: false;
    };
    readonly admin: {
        readonly windowMs: number;
        readonly maxRequests: 20;
        readonly blockDurationMs: number;
        readonly skipSuccessfulRequests: false;
    };
};
export type RateLimitType = keyof typeof RATE_LIMIT_CONFIGS;
/**
 * Rate Limiter Service
 */
export declare class RateLimiter {
    private static isBlocked;
    private static resetEntry;
    /**
     * Check if request should be rate limited
     */
    static checkRateLimit(identifier: string, type?: RateLimitType): {
        allowed: boolean;
        remaining: number;
        resetTime: number;
        retryAfter?: number;
    };
    /**
     * Record successful request (for auth endpoints)
     */
    static recordSuccess(identifier: string, type?: RateLimitType): void;
    /**
     * Get rate limit status without incrementing
     */
    static getStatus(identifier: string, type?: RateLimitType): {
        remaining: number;
        resetTime: number;
        blocked: boolean;
        retryAfter?: number;
    };
    /**
     * Clean up expired entries to prevent memory leaks
     */
    private static cleanupExpiredEntries;
    /**
     * Clear all rate limit data for an identifier
     */
    static clearLimits(identifier: string, type?: RateLimitType): void;
    /**
     * Get rate limit statistics
     */
    static getStats(): {
        totalEntries: number;
        blockedEntries: number;
        entriesByType: Record&lt;string, number&gt;;
    };
}
/**
 * Utility function to get client identifier from request
 */
export declare function getClientIdentifier(request: Request): string;
/**
 * Rate limiting middleware for API routes
 */
export declare function withRateLimit(handler: (request: Request) =&gt; Promise&lt;Response&gt;, type?: RateLimitType): (request: Request) =&gt; Promise&lt;Response&gt;;</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/security/auditLogger.d.ts (Line 1:1 - Line 109:2), C:/AI/food-truck-finder-poc/dist/lib/lib/security/auditLogger.d.ts (Line 1:1 - Line 109:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn467" onclick="toggleCodeBlock('cloneGroup467', 'expandBtn467', 'collapseBtn467')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn467" onclick="toggleCodeBlock('cloneGroup467', 'expandBtn467', 'collapseBtn467')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup467"><code class="language-typescript text-sm text-gray-800">/**
 * SOTA Security Audit Logging System
 * Implements comprehensive audit logging for admin actions and security events
 */
type SeverityLevel = 'info' | 'warning' | 'error' | 'critical';
export interface AuditLogEntry {
    user_id: string;
    user_email: string;
    action: string;
    resource_type: string;
    resource_id?: string;
    details?: Record&lt;string, unknown&gt;;
    ip_address?: string;
    user_agent?: string;
    session_id?: string;
    timestamp: string;
    severity: SeverityLevel;
}
export interface SecurityEvent {
    event_type: 'login_attempt' | 'login_success' | 'login_failure' | 'logout' | 'permission_denied' | 'data_access' | 'data_modification' | 'admin_action';
    user_id?: string;
    user_email?: string;
    ip_address?: string;
    user_agent?: string;
    details?: Record&lt;string, unknown&gt;;
    severity: SeverityLevel;
}
/**
 * Audit Logger Service
 */
export declare class AuditLogger {
    /**
     * Log admin action with full audit trail
     */
    static logAdminAction(options: {
        userId: string;
        userEmail: string;
        action: string;
        resourceType: string;
        resourceId?: string;
        details?: Record&lt;string, unknown&gt;;
        request?: {
            ip?: string;
            userAgent?: string;
            sessionId?: string;
        };
    }): Promise&lt;void&gt;;
    /**
     * Log security event
     */
    static logSecurityEvent(event: SecurityEvent): Promise&lt;void&gt;;
    /**
     * Log authentication events
     */
    static logAuthEvent(options: {
        eventType: 'login_attempt' | 'login_success' | 'login_failure' | 'logout';
        userEmail?: string;
        userId?: string;
        request?: {
            ip?: string;
            userAgent?: string;
        };
        details?: Record&lt;string, unknown&gt;;
    }): Promise&lt;void&gt;;
    /**
     * Log data access events
     */
    static logDataAccess(options: {
        userId: string;
        userEmail: string;
        resourceType: string;
        resourceId?: string;
        action?: 'read' | 'search' | 'export' | 'admin_access';
        request?: {
            ip?: string;
            userAgent?: string;
        };
    }): Promise&lt;void&gt;;
    /**
     * Write audit log to database
     */
    private static writeAuditLog;
    /**
     * Determine severity based on action and resource type
     */
    private static determineSeverity;
    /**
     * Get audit logs for a specific user
     */
    static getUserAuditLogs(userId: string, limit?: number, offset?: number): Promise&lt;AuditLogEntry[]&gt;;
    /**
     * Get recent security events
     */
    static getRecentSecurityEvents(hours?: number, severity?: SeverityLevel): Promise&lt;Record&lt;string, unknown&gt;[]&gt;;
}
/**
 * Security monitoring utilities
 */
export declare const SecurityMonitor: {
    /**
     * Check for suspicious activity patterns
     */
    checkSuspiciousActivity(userId: string): Promise&lt;{
        suspicious: boolean;
        reasons: string[];
        riskLevel: &quot;low&quot; | &quot;medium&quot; | &quot;high&quot;;
    }&gt;;
};
export {};</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/pipeline/pipelineHelpers.d.ts (Line 1:1 - Line 66:2), C:/AI/food-truck-finder-poc/dist/lib/lib/pipeline/pipelineHelpers.d.ts (Line 1:1 - Line 66:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn471" onclick="toggleCodeBlock('cloneGroup471', 'expandBtn471', 'collapseBtn471')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn471" onclick="toggleCodeBlock('cloneGroup471', 'expandBtn471', 'collapseBtn471')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup471"><code class="language-typescript text-sm text-gray-800">import type { ExtractedFoodTruckDetails, FoodTruckSchema } from '../types';
import { type FoodTruck } from '../supabase';
/**
 * Validates input data and prepares food truck information.
 * @example
 * validateInputAndPrepare('job123', extractedTruckDataInstance, 'http://sourceurl.com')
 * { isValid: true, name: 'Food Truck Name' }
 * @param {string} jobId - The job identifier used for logging and job status updates.
 * @param {ExtractedFoodTruckDetails} extractedTruckData - Contains details about the food truck such as name and other attributes.
 * @param {string} sourceUrl - URL where the data was originally extracted from.
 * @returns {Promise&lt;{ isValid: boolean; name: string }&gt;} Result of validation with food truck name.
 * @description
 *   - Logs a warning if the source URL is missing, but continues process as it might not be critical.
 *   - Ensures the food truck name has a fallback value if it's missing in the extracted data.
 *   - Updates job status as 'failed' if validation does not pass.
 */
export declare function validateInputAndPrepare(jobId: string, extractedTruckData: ExtractedFoodTruckDetails, sourceUrl: string): Promise&lt;{
    isValid: boolean;
    name: string;
}&gt;;
/**
 * Constructs a FoodTruckSchema object from extracted food truck details.
 * @example
 * buildTruckDataSchema(extractedTruckData, 'http://sourceUrl.com', 'Truck Name')
 * { name: 'Truck Name', ... }
 * @param {ExtractedFoodTruckDetails} extractedTruckData - Object containing raw data extracted from a food truck resource.
 * @param {string} sourceUrl - URL source where the truck data was extracted from.
 * @param {string} name - Name of the food truck.
 * @returns {FoodTruckSchema} Fully constructed food truck schema ready for use.
 * @description
 *   - Ensures `description` and `price_range` are kept undefined if missing or null from extracted data.
 *   - Filters any non-string values from the `cuisine_type` array.
 *   - Ensures the `source_urls` field is always an array, even if empty or undefined.
 *   - Default verification status is 'pending' and a default data quality score is set to 0.5.
 */
export declare function buildTruckDataSchema(extractedTruckData: ExtractedFoodTruckDetails, sourceUrl: string, name: string): FoodTruckSchema;
/**
 * Checks for duplicates before creating a new food truck entry.
 * @example
 * handleDuplicateCheck('12345', truckDataObject, 'Awesome Food Truck')
 * // Returns a promise resolving to the created truck object or result from handling a duplicate.
 * @param {string} jobId - The unique identifier for the job process.
 * @param {FoodTruckSchema} truckData - The data schema representing the food truck details.
 * @param {string} name - The name of the food truck being processed.
 * @returns {Promise&lt;FoodTruck&gt;} Returns a promise that resolves to the created or existing food truck.
 * @description
 *   - Utilizes the DuplicatePreventionService to verify if a similar truck already exists.
 *   - If a duplicate is detected, delegates to a separate function to handle the duplicate scenario.
 *   - Logs errors encountered during the creation process.
 */
export declare function handleDuplicateCheck(jobId: string, truckData: FoodTruckSchema, name: string): Promise&lt;FoodTruck&gt;;
/**
* Logs the successful creation of a food truck and updates the job status to completed.
* @example
* finalizeJobStatus('12345', { name: 'Best Food Truck', id: 'FT123' }, 'http://example.com')
* // Logs: Job 12345: Successfully created food truck: Best Food Truck (ID: FT123) from http://example.com
* @param {string} jobId - Unique identifier of the scraping job.
* @param {FoodTruck} truck - Object representing the food truck that was created.
* @param {string} sourceUrl - URL from where the data was sourced.
* @returns {Promise&lt;void&gt;} Resolves when the job status is updated.
* @description
*   - Logs the truck creation event using `console.info`.
*   - Ensures the job status is set to 'completed' with the current timestamp.
*   - Uses a default source message if sourceUrl is not provided.
*/
export declare function finalizeJobStatus(jobId: string, truck: FoodTruck, sourceUrl: string): Promise&lt;void&gt;;</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/performance/webVitals.d.ts (Line 1:1 - Line 90:2), C:/AI/food-truck-finder-poc/dist/lib/lib/performance/webVitals.d.ts (Line 1:1 - Line 90:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn473" onclick="toggleCodeBlock('cloneGroup473', 'expandBtn473', 'collapseBtn473')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn473" onclick="toggleCodeBlock('cloneGroup473', 'expandBtn473', 'collapseBtn473')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup473"><code class="language-typescript text-sm text-gray-800">/**
 * SOTA Core Web Vitals Monitoring Implementation
 * Tracks LCP, FID, CLS, FCP, and TTFB metrics for performance optimization
 */
export declare const PERFORMANCE_THRESHOLDS: {
    readonly LCP: {
        readonly good: 2500;
        readonly needsImprovement: 4000;
    };
    readonly FID: {
        readonly good: 100;
        readonly needsImprovement: 300;
    };
    readonly CLS: {
        readonly good: 0.1;
        readonly needsImprovement: 0.25;
    };
    readonly FCP: {
        readonly good: 1800;
        readonly needsImprovement: 3000;
    };
    readonly TTFB: {
        readonly good: 800;
        readonly needsImprovement: 1800;
    };
};
export type MetricName = keyof typeof PERFORMANCE_THRESHOLDS;
export interface PerformanceMetric {
    name: MetricName;
    value: number;
    rating: 'good' | 'needs-improvement' | 'poor';
    timestamp: number;
    url: string;
    userAgent: string;
}
/**
 * Initializes Core Web Vitals monitoring
 * Call this in your app's root component or _app.tsx
 */
export declare function initWebVitalsMonitoring(): void;
/**
 * Gets current performance metrics summary
 */
export declare function getPerformanceMetrics(): {
    metrics: PerformanceMetric[];
    summary: Record&lt;MetricName, {
        latest: number | null;
        average: number;
        rating: 'good' | 'needs-improvement' | 'poor' | 'no-data';
        count: number;
    }&gt;;
};
/**
 * Performance budget checker
 */
export declare function checkPerformanceBudget(): {
    passed: boolean;
    violations: Array&lt;{
        metric: MetricName;
        value: number;
        threshold: number;
        severity: 'warning' | 'critical';
    }&gt;;
};
/**
 * Performance optimization suggestions based on metrics
 */
type PerformanceSuggestion = {
    metric: MetricName;
    issue: string;
    suggestions: string[];
    priority: 'high' | 'medium' | 'low';
};
/**
 * Generates a list of performance optimization suggestions based on Web Vitals metrics.
 * @example
 * getPerformanceOptimizationSuggestions()
 * [
 *   { name: 'Optimize LCP', priority: 'high' },
 *   { name: 'Improve FID', priority: 'medium' }
 * ]
 * @returns {PerformanceSuggestion[]} An array of performance suggestions sorted by priority.
 * @description
 *   - Analyzes performance metrics including LCP, FID, CLS, FCP, and TTFB.
 *   - Generates suggestions only for metrics rated as 'poor' or 'needs-improvement'.
 *   - Prioritizes suggestions based on urgency, sorting them by priority level.
 *   - Utilizes helper functions to generate specific suggestions for each metric type.
 */
export declare function getPerformanceOptimizationSuggestions(): PerformanceSuggestion[];
export {};</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/monitoring/apiMonitor.d.ts (Line 1:1 - Line 162:2), C:/AI/food-truck-finder-poc/dist/lib/lib/monitoring/apiMonitor.d.ts (Line 1:1 - Line 162:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn476" onclick="toggleCodeBlock('cloneGroup476', 'expandBtn476', 'collapseBtn476')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn476" onclick="toggleCodeBlock('cloneGroup476', 'expandBtn476', 'collapseBtn476')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup476"><code class="language-typescript text-sm text-gray-800">/**
 * SOTA API Usage Monitoring and Alerting System
 * Implements proactive monitoring, alerting, and throttling for all external APIs
 */
export declare const API_LIMITS: {
    readonly gemini: {
        readonly requests: {
            readonly daily: 1500;
            readonly hourly: 100;
        };
        readonly tokens: {
            readonly daily: 32000;
            readonly hourly: 2000;
        };
        readonly alertThresholds: {
            readonly warning: 0.8;
            readonly critical: 0.95;
        };
    };
    readonly firecrawl: {
        readonly requests: {
            readonly daily: 500;
            readonly hourly: 50;
        };
        readonly tokens: {
            readonly daily: 0;
            readonly hourly: 0;
        };
        readonly alertThresholds: {
            readonly warning: 0.8;
            readonly critical: 0.95;
        };
    };
    readonly tavily: {
        readonly requests: {
            readonly daily: 1000;
            readonly hourly: 100;
        };
        readonly tokens: {
            readonly daily: 0;
            readonly hourly: 0;
        };
        readonly alertThresholds: {
            readonly warning: 0.8;
            readonly critical: 0.95;
        };
    };
    readonly supabase: {
        readonly requests: {
            readonly daily: 50000;
            readonly hourly: 5000;
        };
        readonly tokens: {
            readonly daily: 0;
            readonly hourly: 0;
        };
        readonly alertThresholds: {
            readonly warning: 0.9;
            readonly critical: 0.98;
        };
    };
};
export type APIService = keyof typeof API_LIMITS;
export type AlertLevel = 'info' | 'warning' | 'critical';
export interface APIUsageAlert {
    service: APIService;
    level: AlertLevel;
    message: string;
    usage: {
        current: number;
        limit: number;
        percentage: number;
    };
    timestamp: string;
    recommendations: string[];
}
export interface APIUsageData {
    requests: {
        used: number;
        limit: number;
        percentage: number;
    };
    tokens?: {
        used: number;
        limit: number;
        percentage: number;
    };
}
export interface APIMonitoringResult {
    canMakeRequest: boolean;
    alerts: APIUsageAlert[];
    usage: Record&lt;APIService, APIUsageData&gt;;
    recommendations: string[];
}
/**
 * Comprehensive API Monitoring Service
 */
export declare class APIMonitor {
    private static alertHistory;
    /**
     * Check if API request can be made safely
     */
    static canMakeRequest(service: APIService, requestCount?: number, tokenCount?: number): Promise&lt;{
        allowed: boolean;
        reason?: string;
        waitTime?: number;
    }&gt;;
    /**
     * Get current usage for a service
     */
    static getCurrentUsage(service: APIService): Promise&lt;APIUsageData&gt;;
    /**
     * Comprehensive monitoring check for all APIs
     */
    static checkAllAPIs(): Promise&lt;APIMonitoringResult&gt;;
    /**
     * Generates token usage alerts based on API usage data and predefined limits.
     * @example
     * generateTokenAlerts(APIServiceInstance, usageData, apiLimits, '2023-10-21T10:20:30Z')
     * [{ service: 'exampleService', level: 'warning', message: 'Warning: exampleService token usage at 75.0%', ... }]
     * @param {APIService} service - The API service for which the alerts are being generated.
     * @param {APIUsageData} usage - Object containing the token usage statistics.
     * @param {Object} limits - Configuration object specifying API limits and alert thresholds.
     * @param {string} timestamp - The timestamp at which the alert is generated.
     * @returns {APIUsageAlert[]} List of alerts generated based on token usage percentage compared to limits.
     * @description
     *   - Generates 'warning' alerts if token usage exceeds the warning threshold.
     *   - Generates 'critical' alerts if token usage exceeds the critical threshold.
     *   - Provides recommendations for optimizing token usage when an alert is generated.
     */
    private static generateTokenAlerts;
    /**
     * Generates usage alerts based on the service's API usage data.
     * @example
     * generateAlerts(APIService.YOUR_SERVICE, apiUsageData)
     * returns an array of APIUsageAlert objects when usage thresholds are exceeded.
     * @param {APIService} service - The API service being monitored.
     * @param {APIUsageData} usage - The usage data containing request and token information.
     * @returns {APIUsageAlert[]} An array of alert objects representing warning or critical usage states.
     * @description
     *   - Determines alert level based on predefined thresholds in API_LIMITS.
     *   - Generates alerts for both request and token usage.
     *   - Updates alert history, maintaining only the last 100 alerts.
     */
    private static generateAlerts;
    /**
     * Generate optimization recommendations
     */
    private static generateRecommendations;
    /**
     * Get time until rate limit reset
     */
    private static getTimeUntilReset;
    /**
     * Get alert history
     */
    static getAlertHistory(): APIUsageAlert[];
    /**
     * Clear alert history
     */
    static clearAlertHistory(): void;
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/middleware/middlewareHelpers.d.ts (Line 1:1 - Line 23:4), C:/AI/food-truck-finder-poc/dist/lib/lib/middleware/middlewareHelpers.d.ts (Line 1:1 - Line 23:13)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn478" onclick="toggleCodeBlock('cloneGroup478', 'expandBtn478', 'collapseBtn478')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn478" onclick="toggleCodeBlock('cloneGroup478', 'expandBtn478', 'collapseBtn478')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup478"><code class="language-typescript text-sm text-gray-800">import { NextRequest, NextResponse } from 'next/server';
interface RequestMetadata {
    ip: string;
    userAgent: string;
    url: string;
    method: string;
}
/**
 * Protects admin routes by verifying user authentication and authorization.
 * @example
 * protectAdminRoutes(req, res, requestMetadata)
 * returns NextResponse or redirects depending on user authentication status.
 * @param {NextRequest} req - The incoming request object.
 * @param {NextResponse} res - The response object to send back to the client.
 * @param {RequestMetadata} requestMetadata - Metadata about the request for logging purposes.
 * @returns {NextResponse} Returns the response object or redirects to an error page.
 * @description
 *   - Fetches and verifies the user's session from Supabase.
 *   - Checks if the user is an admin based on the profile 'role' from the database.
 *   - Logs access attempts to the admin panel for auditing purposes.
 *   - Redirects to an appropriate error handler if the user isn't authenticated or authorized.
 */
export declare function protectAdminRoutes(req: NextRequest, res: NextResponse, requestMetadata: RequestMetadata): Promise&lt;any</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/mappers/uprootedVeganMapper.d.ts (Line 1:1 - Line 80:2), C:/AI/food-truck-finder-poc/dist/lib/lib/mappers/uprootedVeganMapper.d.ts (Line 1:1 - Line 80:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn480" onclick="toggleCodeBlock('cloneGroup480', 'expandBtn480', 'collapseBtn480')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn480" onclick="toggleCodeBlock('cloneGroup480', 'expandBtn480', 'collapseBtn480')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup480"><code class="language-typescript text-sm text-gray-800">/**
 * Data mapper for Uprooted Vegan Cuisine onboarding
 *
 * This utility handles the transformation of Uprooted Vegan Cuisine data
 * to match our FoodTruck schema, including field mappings and defaults.
 */
import type { FoodTruck, MenuCategory, OperatingHours } from '../types';
export interface UprootedVeganData {
    name: string;
    description?: string;
    cuisine_type: string | string[];
    price_range?: '$' | '$$' | '$$$' | '$$$$';
    specialties?: string | string[];
    user_id?: string;
    state?: string;
    exact_location?: {
        lat: number;
        lng: number;
        address?: string;
        timestamp?: string;
    };
    city_location?: {
        lat: number;
        lng: number;
        address?: string;
        timestamp?: string;
    };
    current_location?: {
        lat: number;
        lng: number;
        address?: string;
        timestamp?: string;
    };
    scheduled_locations?: {
        address?: string;
        city?: string;
        state?: string;
        zip_code?: string;
        lat?: number;
        lng?: number;
        timestamp: string;
        start_time: string;
        end_time: string;
    }[];
    operating_hours?: OperatingHours | Record&lt;string, any&gt;;
    menu?: MenuCategory[] | any[];
    contact_info?: {
        phone?: string;
        email?: string;
        website?: string;
    };
    social_media?: {
        instagram?: string;
        facebook?: string;
        twitter?: string;
        tiktok?: string;
        yelp?: string;
    };
    data_quality_score?: number;
    verification_status?: 'pending' | 'verified' | 'flagged';
    source_urls?: string | string[];
    last_scraped_at?: string;
    created_at?: string;
    updated_at?: string;
}
/**
 * Maps Uprooted Vegan Cuisine data to our FoodTruck schema
 */
export declare function mapUprootedVeganData(data: UprootedVeganData): Partial&lt;FoodTruck&gt;;
/**
 * Validates that required fields are present
 */
export declare function validateUprootedVeganData(data: UprootedVeganData): {
    isValid: boolean;
    errors: string[];
};
/**
 * Example usage and testing function
 */
export declare function createUprootedVeganExample(): UprootedVeganData;</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/lib/types.d.ts (Line 1:1 - Line 403:2), C:/AI/food-truck-finder-poc/dist/lib/lib/types.d.ts (Line 1:1 - Line 403:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn481" onclick="toggleCodeBlock('cloneGroup481', 'expandBtn481', 'collapseBtn481')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn481" onclick="toggleCodeBlock('cloneGroup481', 'expandBtn481', 'collapseBtn481')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup481"><code class="language-typescript text-sm text-gray-800">import { ReactElement } from 'react';
export type PriceRange = '$' | '$$' | '$$$' | '$$$$' | undefined;
export type DailyOperatingHours = {
    open: string;
    close: string;
    closed?: boolean;
} | {
    closed: true;
} | undefined;
export interface OperatingHours {
    monday: DailyOperatingHours;
    tuesday: DailyOperatingHours;
    wednesday: DailyOperatingHours;
    thursday: DailyOperatingHours;
    friday: DailyOperatingHours;
    saturday: DailyOperatingHours;
    sunday: DailyOperatingHours;
    [key: string]: DailyOperatingHours;
}
export interface MenuCategory {
    name: string;
    items: MenuItem[];
}
export interface MenuItem {
    name: string;
    description: string | undefined;
    price: number | string | undefined;
    dietary_tags: string[];
    is_popular?: boolean;
}
export interface UserCoordinates {
    lat: number;
    lng: number;
}
export interface LocationData {
    address: string | undefined;
    city: string | undefined;
    state: string | undefined;
    landmarks: string[];
    coordinates: UserCoordinates;
    confidence: number;
    raw_location_text: string | undefined;
}
export interface ExtractedFoodTruckDetails {
    name: string | undefined;
    description: string | undefined;
    cuisine_type: string[];
    price_range: PriceRange | undefined;
    specialties: string[];
    current_location: {
        address: string | undefined;
        city: string | undefined;
        state: string | undefined;
        zip_code: string | undefined;
        lat?: number;
        lng?: number;
        raw_text: string | undefined;
    };
    scheduled_locations?: {
        address?: string;
        city?: string;
        state?: string;
        zip_code?: string;
        lat?: number;
        lng?: number;
        timestamp: string;
        start_time: string;
        end_time: string;
    }[];
    operating_hours: OperatingHours;
    menu: MenuCategory[];
    contact_info: {
        phone?: string;
        email?: string;
        website?: string;
    };
    social_media: {
        instagram?: string;
        facebook?: string;
        twitter?: string;
        tiktok?: string;
        yelp?: string;
    };
    source_url: string;
}
export interface FirecrawlOutputData {
    markdown: string;
    name?: string;
    source_url?: string;
}
export interface FoodTruckSchema {
    name: string;
    description: string | undefined;
    current_location: {
        lat: number;
        lng: number;
        address: string | undefined;
        timestamp: string;
    };
    scheduled_locations: ExtractedFoodTruckDetails['scheduled_locations'];
    operating_hours: OperatingHours;
    menu: MenuCategory[];
    contact_info: {
        phone?: string;
        email?: string;
        website?: string;
    };
    social_media: {
        instagram?: string;
        facebook?: string;
        twitter?: string;
        tiktok?: string;
        yelp?: string;
    };
    cuisine_type: string[];
    price_range: PriceRange | undefined;
    specialties: string[];
    data_quality_score: number;
    verification_status: 'pending' | 'verified' | 'flagged';
    source_urls: string[];
    last_scraped_at: string;
    test_run_flag?: boolean;
    website?: string;
    phone_number?: string;
    email?: string;
    instagram_handle?: string;
    facebook_handle?: string;
    twitter_handle?: string;
    schedule?: unknown[];
    average_rating?: number;
    review_count?: number;
}
export interface FoodTruck extends FoodTruckSchema {
    id: string;
    created_at: string;
    updated_at: string;
    last_updated_at?: string;
    user_id?: string;
    state?: string;
    is_active?: boolean;
    image_url?: string;
    average_rating?: number;
    review_count?: number;
    exact_location?: any;
    city_location?: any;
}
export interface GeminiResponse&lt;T = unknown&gt; {
    success: boolean;
    data?: T;
    tokensUsed?: number;
    error?: string;
    promptSent?: string;
}
export interface StageResult {
    status: string;
    data?: FirecrawlOutputData | ExtractedFoodTruckDetails | FoodTruckSchema;
    error?: string;
    details?: string;
    prompt?: string;
    tokensUsed?: number;
    metadata?: {
        name?: string;
        source_url?: string;
    };
    rawContent?: string;
    preparedData?: FoodTruckSchema;
    recordId?: string;
}
export interface TestPipelineResults {
    firecrawl?: StageResult;
    gemini?: StageResult;
    supabase?: StageResult;
    overallStatus?: string;
    logs?: string[];
    error?: string;
}
export interface PipelineRunResult {
    firecrawl?: StageResult;
    gemini?: StageResult;
    supabase?: StageResult;
    logs: string[];
    overallStatus: 'Success' | 'Error';
}
export interface ScrapingJob {
    id: string;
    job_type: string;
    target_url?: string;
    target_handle?: string;
    platform?: string;
    status: 'pending' | 'running' | 'completed' | 'failed';
    priority: number;
    scheduled_at: string;
    started_at?: string;
    completed_at?: string;
    data_collected?: Record&lt;string, unknown&gt;;
    errors?: string[];
    retry_count: number;
    max_retries: number;
    created_at: string;
}
export interface RealtimeMetrics {
    scrapingJobs: {
        active: number;
        completed: number;
        failed: number;
        pending: number;
    };
    dataQuality: {
        averageScore: number;
        totalTrucks: number;
        recentChanges: number;
    };
    systemHealth: {
        status: 'healthy' | 'warning' | 'error';
        uptime: number;
        lastUpdate: string;
    };
}
export interface TruckRating {
    id: number;
    title: string;
    score: number;
}
export interface PipelineEvent {
    type: string;
    payload: Record&lt;string, unknown&gt;;
    timestamp: string;
}
export interface SentimentAnalysisResult {
    sentiment: 'positive' | 'negative' | 'neutral';
    score: number;
    confidence: number;
    key_topics: string[];
    positive_aspects: string[];
    negative_aspects: string[];
    summary: string;
    recommended: boolean;
}
export interface EnhancedFoodTruckData {
    name: string | undefined;
    description: string | undefined;
    cuisine_type: string[];
    price_range: PriceRange;
    specialties: string[];
    dietary_options: string[];
    enhanced_menu: {
        categories: MenuCategory[];
    };
    standardized_hours: OperatingHours;
    cleaned_contact: {
        phone: string | undefined;
        email: string | undefined;
        website: string | undefined;
    };
    data_quality_improvements: string[];
    confidence_score: number;
}
export interface DataProcessingQueue {
    id: string;
    truck_id?: string;
    processing_type: string;
    raw_data: Record&lt;string, unknown&gt;;
    processed_data?: Record&lt;string, unknown&gt;;
    gemini_tokens_used: number;
    status: 'pending' | 'processing' | 'completed' | 'failed';
    priority: number;
    created_at: string;
    processed_at?: string;
}
export interface ApiUsage {
    id: string;
    service_name: string;
    usage_date: string;
    requests_count: number;
    tokens_used: number;
}
export interface QualityCategory {
    name: string;
    score: number;
    issues: string[];
}
export interface SystemAlert {
    id: string;
    type: string;
    message: string;
    timestamp: string;
    severity: 'low' | 'medium' | 'high' | 'critical';
}
export interface RealtimeAdminEvent {
    type: string;
    payload: Record&lt;string, unknown&gt;;
    timestamp: string;
}
export interface FoodTruckWithRatings extends FoodTruck {
    ratings?: TruckRating[];
}
export interface SecurityEvent {
    event_type: string;
    severity: 'low' | 'medium' | 'high' | 'critical';
    timestamp: string;
    details: Record&lt;string, unknown&gt;;
}
export interface APIService {
    name: string;
    endpoint: string;
    status: 'active' | 'inactive';
}
export interface Database {
    public: {
        tables: Record&lt;string, unknown&gt;;
    };
}
export type CleanupOperationType = 'normalize_phone' | 'fix_coordinates' | 'remove_placeholders' | 'update_quality_scores' | 'merge_duplicates';
export interface CleanupOperation {
    type: CleanupOperationType;
    description: string;
    affectedCount: number;
    successCount: number;
    errorCount: number;
    errors: string[];
}
export interface BatchCleanupResult {
    totalProcessed: number;
    operations: CleanupOperation[];
    summary: {
        trucksImproved: number;
        duplicatesRemoved: number;
        qualityScoreImprovement: number;
        placeholdersRemoved: number;
    };
    duration: number;
}
export interface DataCleanupRequestBody {
    action: string;
    options?: {
        batchSize?: number;
        dryRun?: boolean;
        operations?: string[];
        truckData?: Record&lt;string, unknown&gt;;
        targetId?: string;
        sourceId?: string;
    };
}
export interface FirecrawlRequestBody {
    url: string;
    extractorOptions?: Record&lt;string, unknown&gt;;
}
export interface TavilyRequestBody {
    query: string;
    searchDepth?: 'basic' | 'advanced';
    includeImages?: boolean;
    includeAnswer?: boolean;
    maxResults?: number;
}
export interface PostRequestBody {
    action: string;
    data?: Record&lt;string, unknown&gt;;
}
export interface PutRequestBody {
    id: string;
    updates: Record&lt;string, unknown&gt;;
}
export interface ButtonProps {
    variant?: 'default' | 'destructive' | 'outline' | 'secondary' | 'ghost' | 'link';
    size?: 'default' | 'sm' | 'lg' | 'icon';
    asChild?: boolean;
}
export interface ToasterToast {
    id: string;
    title?: string;
    description?: string;
    action?: ReactElement;
    variant?: 'default' | 'destructive';
}
export interface ToastComponentProps {
    toast: ToasterToast;
}
export interface ToastActionElement {
    altText: string;
    element: ReactElement;
}
export interface CleanupResult {
    success: boolean;
    totalProcessed: number;
    operations: CleanupOperation[];
    summary: {
        trucksImproved: number;
        duplicatesRemoved: number;
        qualityScoreImprovement: number;
        placeholdersRemoved: number;
    };
    duration: number;
    error?: string;
}
export interface RequestBody {
    action: string;
    options?: Record&lt;string, unknown&gt;;
}
export interface FirecrawlResponse {
    success: boolean;
    data?: Record&lt;string, unknown&gt;;
    error?: string;
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/lib/ScraperEngine.d.ts (Line 1:1 - Line 246:2), C:/AI/food-truck-finder-poc/dist/lib/lib/ScraperEngine.d.ts (Line 1:1 - Line 246:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn484" onclick="toggleCodeBlock('cloneGroup484', 'expandBtn484', 'collapseBtn484')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn484" onclick="toggleCodeBlock('cloneGroup484', 'expandBtn484', 'collapseBtn484')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup484"><code class="language-typescript text-sm text-gray-800">interface InstagramPost {
    id: string;
    caption: string;
    timestamp: string;
    location: string;
    hashtags: string[];
    engagement: {
        likes: number;
        comments: number;
    };
}
interface InstagramProfile {
    followers: number;
    following: number;
    posts_count: number;
    bio: string;
    contact_info: {
        email: string;
        phone: string;
    };
}
interface FacebookPost {
    id: string;
    content: string;
    timestamp: string;
    reactions: {
        likes: number;
        loves: number;
        shares: number;
    };
    comments: number;
}
interface FacebookPageInfo {
    likes: number;
    followers: number;
    check_ins: number;
    about: string;
    hours: Record&lt;string, string&gt;;
}
interface TwitterTweet {
    id: string;
    text: string;
    timestamp: string;
    retweets: number;
    likes: number;
    replies: number;
    location: string;
}
interface TwitterProfile {
    followers: number;
    following: number;
    tweets_count: number;
    bio: string;
    location: string;
    website: string;
}
interface InstagramData {
    posts: InstagramPost[];
    profile: InstagramProfile;
}
interface FacebookData {
    posts: FacebookPost[];
    page_info: FacebookPageInfo;
}
interface TwitterData {
    tweets: TwitterTweet[];
    profile: TwitterProfile;
}
export interface WebsiteScrapeData {
    markdown?: string;
    html?: string;
    metadata?: Record&lt;string, unknown&gt;;
    is_fallback?: boolean;
}
export interface ExtractedHTMLData {
    name?: string;
    location?: string;
    phone?: string;
    hours?: string;
    menu?: {
        item: string;
        price: string;
    }[];
}
interface ScrapeResult {
    success: boolean;
    error?: string;
    data?: InstagramData | FacebookData | TwitterData | WebsiteScrapeData | ExtractedHTMLData;
    timestamp: string;
    source: string;
    note?: string;
}
export declare class ScraperEngine {
    private userAgents;
    private requestDelay;
    private maxRetries;
    constructor();
    private performFallbackScrape;
    scrapeWebsite(url: string, _selectors?: Record&lt;string, string&gt;): Promise&lt;ScrapeResult&gt;;
    scrapeSocialMedia(platform: string, handle: string): Promise&lt;ScrapeResult&gt;;
    private scrapeInstagram;
    private scrapeFacebook;
    private scrapeTwitter;
    private getRandomUserAgent;
    private randomDelay;
    handleRateLimit(retryAfter: number): Promise&lt;void&gt;;
    retryWithBackoff&lt;T&gt;(operation: () =&gt; Promise&lt;T&gt;, maxRetries?: number): Promise&lt;T&gt;;
}
interface LocationData {
    current?: {
        lat?: number;
        lng?: number;
        address?: string;
    };
}
interface ContactInfo {
    phone?: string;
    email?: string;
}
interface OperatingHours {
    [key: string]: {
        open: string;
        close: string;
        closed: boolean;
    };
}
interface MenuItem {
    name: string;
    description?: string;
    price: number;
    dietary_tags?: string[];
}
interface MenuCategory {
    category: string;
    items: MenuItem[];
}
interface TruckData {
    name: string;
    location: LocationData;
    contact?: ContactInfo;
    operating_hours?: OperatingHours;
    menu?: MenuCategory[];
    last_updated?: string;
}
export declare class DataQualityAssessor {
    private assessBasicInfo;
    private assessLocationInfo;
    private assessContactInfo;
    private assessOperatingHours;
    private assessMenuInfo;
    private assessLastUpdated;
    assessTruckData(truckData: TruckData): {
        score: number;
        issues: string[];
    };
    private validateMenuCategory;
    private validateMenuItems;
    private validateMenuData;
    private isValidPhone;
    private isValidEmail;
}
interface GeminiLocationData {
    address: string;
    city: string;
    state: string;
    coordinates: {
        lat?: number;
        lng?: number;
    };
    confidence: number;
}
interface GeminiOperatingHours {
    monday: {
        open: string;
        close: string;
        closed: boolean;
    };
    tuesday: {
        open: string;
        close: string;
        closed: boolean;
    };
    wednesday: {
        open: string;
        close: string;
        closed: boolean;
    };
    thursday: {
        open: string;
        close: string;
        closed: boolean;
    };
    friday: {
        open: string;
        close: string;
        closed: boolean;
    };
    saturday: {
        open: string;
        close: string;
        closed: boolean;
    };
    sunday: {
        open: string;
        close: string;
        closed: boolean;
    };
}
interface GeminiSentimentAnalysis {
    sentiment: 'positive' | 'negative' | 'neutral';
    score: number;
    key_topics: string[];
    summary: string;
}
export declare class GeminiDataProcessor {
    private _apiKey;
    private _baseUrl;
    private requestCount;
    private tokenCount;
    private dailyLimit;
    constructor(apiKey: string);
    processMenuData(rawMenuText: string): Promise&lt;{
        categories: MenuCategory[];
    }&gt;;
    extractLocationFromText(text: string): Promise&lt;GeminiLocationData&gt;;
    private validateGeminiLocationResponse;
    standardizeOperatingHours(hoursText: string): Promise&lt;GeminiOperatingHours&gt;;
    analyzeSentiment(reviewText: string): Promise&lt;GeminiSentimentAnalysis&gt;;
    private makeGeminiRequest;
    private getMockGeminiResponse;
    private canMakeRequest;
    private updateUsageCounters;
    getUsageStats(): {
        requests: {
            used: number;
            limit: number;
            remaining: number;
        };
        tokens: {
            used: number;
            limit: number;
            remaining: number;
        };
    };
}
export {};</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/lib/scheduler.d.ts (Line 1:1 - Line 97:2), C:/AI/food-truck-finder-poc/dist/lib/lib/scheduler.d.ts (Line 1:1 - Line 97:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn486" onclick="toggleCodeBlock('cloneGroup486', 'expandBtn486', 'collapseBtn486')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn486" onclick="toggleCodeBlock('cloneGroup486', 'expandBtn486', 'collapseBtn486')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup486"><code class="language-typescript text-sm text-gray-800">export declare class TaskScheduler {
    private tasks;
    private intervals;
    private isRunning;
    constructor();
    start(): void;
    stop(): void;
    addTask(task: ScheduledTask): void;
    removeTask(taskId: string): void;
    enableTask(taskId: string): void;
    disableTask(taskId: string): void;
    private scheduleTask;
    getTaskStatus(): TaskStatus[];
    private calculateNextRun;
    scheduleFollowUpTasks(result: unknown): void;
}
interface ScheduledTask {
    id: string;
    name: string;
    description: string;
    intervalMinutes: number;
    enabled: boolean;
    execute: () =&gt; Promise&lt;void&gt;;
    lastRun?: string;
    lastSuccess?: string;
    successCount: number;
    errorCount: number;
    lastError?: string;
}
interface TaskStatus {
    id: string;
    name: string;
    enabled: boolean;
    intervalMinutes: number;
    lastRun?: string;
    lastSuccess?: string;
    successCount: number;
    errorCount: number;
    lastError?: string;
    nextRun?: string;
}
interface ScraperEngine {
    scrapeSocialMedia: (platform: string, handle: string) =&gt; Promise&lt;{
        success: boolean;
        error?: string;
        data?: unknown;
    }&gt;;
    scrapeWebsite: (url: string, selectors: Record&lt;string, string&gt;) =&gt; Promise&lt;{
        success: boolean;
        error?: string;
        data?: unknown;
    }&gt;;
}
interface GeminiProcessor {
    getUsageStats: () =&gt; {
        requests: {
            remaining: number;
        };
    };
    processMenuData: (content: string) =&gt; Promise&lt;unknown&gt;;
    extractLocationFromText: (content: string) =&gt; Promise&lt;unknown&gt;;
    standardizeOperatingHours: (content: string) =&gt; Promise&lt;unknown&gt;;
    analyzeSentiment: (content: string) =&gt; Promise&lt;unknown&gt;;
    enhanceFoodTruckData: (data: unknown) =&gt; Promise&lt;unknown&gt;;
}
interface DataQualityAssessor {
    assessTruckData: (truck: FoodTruck) =&gt; {
        score: number;
        issues: string[];
    };
}
interface FoodTruck {
    id: string;
    name: string;
    contact_info: {
        phone?: string;
        email?: string;
        website?: string;
    };
    social_media: {
        instagram_handle?: string;
        facebook_handle?: string;
        twitter_handle?: string;
    };
    cuisine_type: string;
    price_range?: string;
    specialties: string[];
    menu: unknown;
    current_location: {
        lat?: number;
        lng?: number;
        address?: string;
    };
}
export declare function createDefaultTasks(scraperEngine: ScraperEngine, geminiProcessor: GeminiProcessor, dataQualityAssessor: DataQualityAssessor): ScheduledTask[];
export declare const scheduler: TaskScheduler;
export {};</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/lib/pipelineManager.d.ts (Line 1:1 - Line 116:2), C:/AI/food-truck-finder-poc/dist/lib/lib/pipelineManager.d.ts (Line 1:1 - Line 116:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn488" onclick="toggleCodeBlock('cloneGroup488', 'expandBtn488', 'collapseBtn488')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn488" onclick="toggleCodeBlock('cloneGroup488', 'expandBtn488', 'collapseBtn488')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup488"><code class="language-typescript text-sm text-gray-800">export interface PipelineConfig {
    type: 'discovery' | 'processing' | 'full' | 'maintenance';
    params: {
        maxUrls?: number;
        maxUrlsToProcess?: number;
        targetCities?: string[];
        priority?: number;
        skipDiscovery?: boolean;
        retryFailedJobs?: boolean;
    };
}
export interface DiscoveryParams {
    cities: string[];
    maxUrls: number;
    searchTerms?: string[];
}
export interface ProcessingOptions {
    maxJobs: number;
    priority: number;
    retryFailedJobs: boolean;
}
export interface PipelineResult {
    success: boolean;
    type: string;
    phase: string;
    summary: {
        urlsDiscovered?: number;
        urlsProcessed?: number;
        jobsCreated?: number;
        trucksCreated?: number;
        errors?: number;
        duration: number;
    };
    details: unknown;
    timestamp: string;
}
export interface DiscoveryResult {
    success: boolean;
    urlsDiscovered: number;
    urlsStored: number;
    urlsDuplicate: number;
    errors: string[];
    duration: number;
}
export interface ProcessingResult {
    success: boolean;
    jobsProcessed: number;
    jobsSuccessful: number;
    jobsFailed: number;
    trucksCreated: number;
    errors: string[];
    duration: number;
}
export interface MaintenanceResult {
    success: boolean;
    trucksProcessed: number;
    newTrucksFound: number;
    errors: string[];
    duration: number;
}
/**
 * Unified Pipeline Manager
 *
 * Consolidates all pipeline operations into a single, modular system:
 * - Discovery: Find new food truck URLs using Tavily
 * - Processing: Process URLs through Firecrawl + Gemini pipeline
 * - Full: Combined discovery + processing
 * - Maintenance: Check existing trucks for stale data
 */
export declare class PipelineManager {
    /**
     * Run the complete pipeline based on configuration
     */
    runPipeline(config: PipelineConfig): Promise&lt;PipelineResult&gt;;
    /**
     * Execute the specific pipeline type
     */
    private executePipelineType;
    /**
     * Create success result
     */
    private createSuccessResult;
    /**
     * Create error result
     */
    private createErrorResult;
    /**
     * Run URL discovery using Tavily search
     */
    runDiscovery(_params: DiscoveryParams): Promise&lt;DiscoveryResult&gt;;
    /**
     * Process existing scraping jobs
     */
    processJobs(options: ProcessingOptions): Promise&lt;ProcessingResult&gt;;
    /**
     * Create empty processing result when no jobs available
     */
    private createEmptyProcessingResult;
    /**
     * Process a batch of jobs
     */
    private processJobBatch;
    /**
     * Create processing error result
     */
    private createProcessingErrorResult;
    /**
     * Run full pipeline: discovery + processing
     */
    private runFullPipeline;
    /**
     * Run maintenance checks on existing trucks
     */
    runMaintenance(): Promise&lt;MaintenanceResult&gt;;
}
export declare const pipelineManager: PipelineManager;</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/lib/gemini.d.ts (Line 7:26 - Line 38:2), C:/AI/food-truck-finder-poc/dist/lib/lib/gemini.d.ts (Line 7:23 - Line 38:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn490" onclick="toggleCodeBlock('cloneGroup490', 'expandBtn490', 'collapseBtn490')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn490" onclick="toggleCodeBlock('cloneGroup490', 'expandBtn490', 'collapseBtn490')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup490"><code class="language-typescript text-sm text-gray-800">).UsageCheck&gt;;
    private makeGeminiRequest;
    processMenuData: (rawMenuText: string) =&gt; Promise&lt;GeminiResponse&lt;MenuCategory[]&gt;&gt;;
    extractLocationFromText: (textInput: string) =&gt; Promise&lt;GeminiResponse&lt;LocationData&gt;&gt;;
    standardizeOperatingHours: (hoursText: string) =&gt; Promise&lt;GeminiResponse&lt;OperatingHours&gt;&gt;;
    analyzeSentiment: (reviewText: string) =&gt; Promise&lt;GeminiResponse&lt;SentimentAnalysisResult&gt;&gt;;
    enhanceFoodTruckData: (rawData: unknown) =&gt; Promise&lt;GeminiResponse&lt;EnhancedFoodTruckData&gt;&gt;;
    batchProcess: (items: Array&lt;{
        type: string;
        data: unknown;
    }&gt;) =&gt; Promise&lt;Array&lt;GeminiResponse&lt;unknown&gt;&gt;&gt;;
    getUsageStats: () =&gt; Promise&lt;{
        requests_count: number;
        tokens_used: number;
    } | undefined&gt;;
    extractFoodTruckDetailsFromMarkdown: (markdownContent: string, sourceUrl?: string) =&gt; Promise&lt;GeminiResponse&lt;ExtractedFoodTruckDetails&gt;&gt;;
}
/**
* Dispatches the appropriate Gemini operation based on the provided type.
* @example
* dispatchGeminiOperation('menu', 'data')
* Returns a promise with processed menu data response
* @param {'menu' | 'location' | 'hours' | 'sentiment' | 'enhance' | 'foodTruckExtraction'} type - The type of Gemini operation to dispatch.
* @param {unknown} data - Data relevant to the specified Gemini operation type.
* @returns {Promise&lt;GeminiResponse&lt;unknown&gt;&gt;} Returns a promise that resolves to the Gemini operation's response.
* @description
*   - Operates asynchronously, ensuring the flexibility and responsiveness of Gemini processing.
*   - Utilizes type assertion to correctly handle various data types pertinent to the operation.
*   - If the operation type is unrecognized, the function returns an error response.
*/
export declare function dispatchGeminiOperation(type: 'menu' | 'location' | 'hours' | 'sentiment' | 'enhance' | 'foodTruckExtraction', data: unknown): Promise&lt;GeminiResponse&lt;unknown&gt;&gt;;
export declare const gemini: GeminiService;</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/lib/firecrawl.d.ts (Line 1:1 - Line 226:2), C:/AI/food-truck-finder-poc/dist/lib/lib/firecrawl.d.ts (Line 1:1 - Line 226:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn492" onclick="toggleCodeBlock('cloneGroup492', 'expandBtn492', 'collapseBtn492')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn492" onclick="toggleCodeBlock('cloneGroup492', 'expandBtn492', 'collapseBtn492')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup492"><code class="language-typescript text-sm text-gray-800">export interface FirecrawlResponse {
    success: boolean;
    data?: {
        markdown?: string;
        html?: string;
        metadata?: {
            title?: string;
            description?: string;
            language?: string;
            sourceURL?: string;
        };
        links?: string[];
    };
    error?: string;
}
interface CrawlJobResponse {
    success: boolean;
    jobId?: string;
    error?: string;
}
interface ScrapedMetadata {
    title?: string;
    description?: string;
    language?: string;
    sourceURL?: string;
}
interface CrawlStatusResponse {
    success: boolean;
    status?: 'scraping' | 'completed' | 'failed';
    data?: Array&lt;{
        markdown?: string;
        html?: string;
        metadata?: ScrapedMetadata;
    }&gt;;
    error?: string;
}
export declare class FirecrawlService {
    private apiKey;
    private baseUrl;
    constructor();
    /**
     * Retrieves a cached result based on the given cache key if it hasn't expired.
     * @example
     * getCachedResult('uniqueCacheKey')
     * FirecrawlResponse or undefined
     * @param {string} cacheKey - The unique identifier for the cached result.
     * @returns {FirecrawlResponse | CrawlJobResponse | CrawlStatusResponse | undefined} The cached data if available and valid, otherwise undefined.
     * @description
     *   - Cleans up expired cache entries before attempting to return a cached result.
     *   - Logs a message when a cache hit occurs.
     */
    private getCachedResult;
    private setCacheResult;
    /**
    * Fetches and processes content from a specified URL, optionally customizing the output format and content inclusion/exclusion via provided options.
    * @example
    * scrapeUrl('https://example.com', { formats: ['html'], includeTags: ['h1', 'p'] })
    * Returns a FirecrawlResponse object containing the scraped data.
    * @param {string} url - The URL from which content will be scraped.
    * @param {Object} options - Optional parameters to customize the scraping process.
    * @param {(string[]|undefined)} options.formats - Specifies the desired output formats: 'markdown' or 'html'.
    * @param {(string[]|undefined)} options.includeTags - Tags to specifically include in the scraping results.
    * @param {(string[]|undefined)} options.excludeTags - Tags to exclude from the scraping results.
    * @param {(boolean|undefined)} options.onlyMainContent - If true, extracts only the main content from the URL.
    * @param {(number|undefined)} options.waitFor - Time in milliseconds to wait before starting the scraping process.
    * @returns {Promise&lt;FirecrawlResponse&gt;} A promise resolving to a FirecrawlResponse containing either the successful scraping results or error details.
    * @description
    *   - Utilizes caching to store and retrieve previously fetched data to minimize repeated requests.
    *   - Sends API requests with authentication headers using the instance's API key.
    *   - Handles errors gracefully, returning a descriptive error message if the scraping process fails.
    */
    scrapeUrl(url: string, options?: {
        formats?: ('markdown' | 'html')[];
        includeTags?: string[];
        excludeTags?: string[];
        onlyMainContent?: boolean;
        waitFor?: number;
    }): Promise&lt;FirecrawlResponse&gt;;
    /**
     * Initiates a web crawling process for a specified URL with given options.
     * @example
     * crawlWebsite('https://example.com', { crawlerOptions: { includes: ['.html'] }, pageOptions: { formats: ['markdown'] } })
     * // Returns a promise that resolves to a CrawlJobResponse object
     * @param {string} url - The URL of the website to be crawled.
     * @param {Object} options - Configuration options for the crawling process.
     * @param {Object} [options.crawlerOptions] - Specific options for controlling the crawler behavior.
     * @param {string[]} [options.crawlerOptions.includes] - List of patterns to include in the crawl.
     * @param {string[]} [options.crawlerOptions.excludes] - List of patterns to exclude from the crawl.
     * @param {number} [options.crawlerOptions.maxDepth] - Maximum depth the crawler should reach.
     * @param {number} [options.crawlerOptions.limit] - Limit to the number of pages to crawl.
     * @param {Object} [options.pageOptions] - Options for the page content format and selection.
     * @param {string[]} [options.pageOptions.formats] - Desired formats for the crawled page content.
     * @param {boolean} [options.pageOptions.onlyMainContent] - Whether to include only the main content of the pages.
     * @returns {Promise&lt;CrawlJobResponse&gt;} A promise that resolves with the results of the crawl job including success and potential errors.
     * @description
     *   - Performs a POST request to the Firecrawl service to crawl pages.
     *   - Uses caching to avoid redundant web crawling operations.
     *   - Handles errors gracefully, returning an appropriate error message if the fetch operation fails.
     *   - Crawls with default options which include markdown format and filtering for main content.
     */
    crawlWebsite(url: string, options?: {
        crawlerOptions?: {
            includes?: string[];
            excludes?: string[];
            maxDepth?: number;
            limit?: number;
        };
        pageOptions?: {
            formats?: ('markdown' | 'html')[];
            onlyMainContent?: boolean;
        };
    }): Promise&lt;CrawlJobResponse&gt;;
    /**
     * Retrieves the crawl status for a given job by its ID.
     * @example
     * getCrawlStatus('12345')
     * { success: true, status: 'completed' }
     * @param {string} jobId - The ID of the job for which the crawl status is requested.
     * @returns {Promise&lt;CrawlStatusResponse&gt;} Resolves to a `CrawlStatusResponse` object containing the crawl status or an error.
     * @description
     *   - Attempts to retrieve the crawl status from a cache before making an HTTP request.
     *   - Fetches crawl status using an authenticated request to the API.
     *   - Caches the crawl status response data to minimize redundant network calls.
     *   - Handles errors gracefully, returning a standardized error response.
     */
    getCrawlStatus(jobId: string): Promise&lt;CrawlStatusResponse&gt;;
    /**
     * Scrapes a food truck website and retrieves its main content in markdown format.
     * @example
     * scrapeFoodTruckWebsite('https://example.com/food-truck')
     * // Returns: Promise&lt;{ success: true, data: { markdown: '...', name: 'Example Food Truck', source_url: 'https://example.com/food-truck' } }&gt;
     * @param {string} url - The URL of the food truck website to scrape.
     * @returns {Promise&lt;{ success: boolean, data?: { markdown: string, name?: string, source_url?: string }, error?: string }&gt;} The result of the scrape operation, including markdown content and metadata if successful, or an error message if not.
     * @description
     *   - Configured to wait 2000 milliseconds to ensure all content is loaded.
     *   - Uses 'markdown' format for content extraction to maintain text structure.
     *   - Extracts metadata such as the title and source URL if available.
     */
    scrapeFoodTruckWebsite(url: string): Promise&lt;{
        success: boolean;
        data?: {
            markdown: string;
            name?: string;
            source_url?: string;
        };
        error?: string;
    }&gt;;
    private extractPattern;
    /**
    * Extracts a menu section from a given markdown string based on specific keywords.
    * @example
    * extractMenuSection(&quot;menu: Pizza, Pasta, Salad&quot;)
    * // Returns &quot;Pizza, Pasta, Salad&quot;
    * @param {string} markdown - The markdown string to search for menu-related content.
    * @returns {string | undefined} The extracted menu section if found, otherwise undefined.
    * @description
    *   - Searches for menu-related phrases like &quot;menu&quot;, &quot;food&quot;, &quot;items&quot; up to a maximum of 50 characters.
    *   - Implements case-insensitive search patterns.
    *   - Returns the portion of the markdown line following the specific keywords.
    */
    private extractMenuSection;
    /**
     * Extracts phone and email contact information from a markdown string.
     * @example
     * extractContactInfo(&quot;Contact: +123-456-7890, email: example@test.com&quot;)
     * { phone: &quot;+123-456-7890&quot;, email: &quot;example@test.com&quot; }
     * @param {string} markdown - A markdown string potentially containing contact information.
     * @returns {ContactInfo | undefined} An object containing extracted phone and email, or undefined if none are found.
     * @description
     *   - Utilizes regular expressions to identify phone numbers and email addresses within the markdown.
     *   - Returns an object only when at least one type of contact information is successfully extracted.
     */
    private extractContactInfo;
    /**
    * Extracts social media profile names from a given markdown string.
    * @example
    * extractSocialMedia(&quot;@john_doe instagram.com/jane Facebook.com/joe&quot;)
    * { instagram: 'john_doe', facebook: 'jane', twitter: 'joe' }
    * @param {string} markdown - A string containing markdown text to parse for social media information.
    * @returns {SocialMediaInfo | undefined} An object containing social media profiles if any are found, otherwise undefined.
    * @description
    *   - Supports extracting profiles for Instagram, Facebook, and Twitter.
    *   - Uses regular expressions to match social media patterns.
    *   - Returns the trimmed username of identified social media profiles.
    *   - Returns undefined if no social media profiles are found in the input.
    */
    private extractSocialMedia;
    /**
     * Performs web scraping on multiple URLs with batching and delay options.
     * @example
     * scrapeMultipleUrls(['http://example.com', 'http://another.com'], { batchSize: 2, delay: 1500 })
     * Returns: Promise resolving to an array containing the results of the scraped URLs.
     * @param {string[]} urls - Array of URLs to be scraped.
     * @param {Object} options - Options object for configuring the scraping process.
     * @param {number} [options.batchSize=5] - Size of each batch in which URLs are processed.
     * @param {number} [options.delay=1000] - Delay between processing each batch in milliseconds.
     * @returns {Promise&lt;Array&lt;{ url: string; result: FirecrawlResponse }&gt;&gt;} Promise resolving to an array of objects, each containing a URL and its corresponding scrape result.
     * @description
     *   - Utilizes a batch mechanism to efficiently handle large sets of URLs.
     *   - Incorporates a delay between batches to comply with potential rate limits.
     */
    scrapeMultipleUrls(urls: string[], options?: {
        batchSize?: number;
        delay?: number;
    }): Promise&lt;Array&lt;{
        url: string;
        result: FirecrawlResponse;
    }&gt;&gt;;
    /**
     * Attempts to scrape content from a given URL with retries in case of failure.
     * @example
     * scrapeWithRetry('https://example.com', 3, 1000)
     * { success: true, data: {...} }
     * @param {string} url - The URL to scrape.
     * @param {number} maxRetries - Maximum number of retry attempts. Defaults to 3.
     * @param {number} backoffMs - Initial wait time before retrying in milliseconds. Defaults to 1000ms.
     * @returns {Promise&lt;FirecrawlResponse&gt;} Promise resolving to a FirecrawlResponse object indicating success or failure.
     * @description
     *   - Implements exponential backoff strategy for rate limit errors.
     *   - Logs attempt details and waiting times between retries.
     *   - Returns last error message if all retry attempts fail.
     */
    scrapeWithRetry(url: string, maxRetries?: number, backoffMs?: number): Promise&lt;FirecrawlResponse&gt;;
}
export declare const firecrawl: FirecrawlService;
export {};</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/lib/discoveryEngine.d.ts (Line 1:1 - Line 272:2), C:/AI/food-truck-finder-poc/dist/lib/lib/discoveryEngine.d.ts (Line 1:1 - Line 272:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn494" onclick="toggleCodeBlock('cloneGroup494', 'expandBtn494', 'collapseBtn494')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn494" onclick="toggleCodeBlock('cloneGroup494', 'expandBtn494', 'collapseBtn494')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup494"><code class="language-typescript text-sm text-gray-800">export interface DiscoveredUrl {
    url: string;
    source_directory_url?: string;
    region?: string;
    status: 'new' | 'processing' | 'processed' | 'irrelevant';
    notes?: string;
}
export interface DiscoveryResult {
    urls_discovered: number;
    urls_stored: number;
    urls_duplicates: number;
    errors: string[];
}
/**
 * Autonomous Discovery Engine
 *
 * This engine discovers new food truck websites across South Carolina using Tavily for search
 * and Firecrawl for crawling. It operates autonomously without human intervention, finding and
 * validating new URLs to add to the discovered_urls table for subsequent scraping.
 *
 * Strategy:
 * 1. Search for food trucks in each SC city using Tavily search
 * 2. Find food truck directories and event listings using Firecrawl crawling
 * 3. Extract individual food truck website URLs from discovered content
 * 4. Validate and filter URLs to avoid false positives
 * 5. Store new URLs in discovered_urls table for processing
 *
 * NOTE: Uses Tavily for search operations and Firecrawl for crawling/scraping
 */
interface TavilySearchResult {
    url: string;
    content?: string;
    raw_content?: string;
}
export declare class FoodTruckDiscoveryEngine {
    private readonly searchTerms;
    private readonly directoryUrls;
    /**
     * Processes search results to discover and store food truck URLs.
     * @example
     * processSearchResults([{ url: 'http://example.com', content: '...' }], new Set())
     * // No return value; `discoveredUrls` will contain food truck URLs.
     * @param {TavilySearchResult[]} searchResults - An array of search result objects each possibly containing a URL and content.
     * @param {Set&lt;string&gt;} discoveredUrls - A set to store discovered food truck URLs.
     * @returns {Promise&lt;void&gt;} No return value; operates by modifying the `discoveredUrls` set.
     * @description
     *   - URLs are checked for validity as food truck URLs before being added to the set.
     *   - Extracts URLs from either the `content` or `raw_content` fields.
     *   - Uses asynchronous URL validation.
     */
    private processSearchResults;
    /**
     * Performs search term discovery using the specified search terms.
     * @example
     * performSearchTermDiscovery(new Set(), discoveryResult)
     * No specific return value, performs actions on `discoveredUrls` and `results`.
     * @param {Set&lt;string&gt;} discoveredUrls - A set to store discovered URLs that have been processed.
     * @param {DiscoveryResult} results - An object to accumulate results and errors stemming from the discovery process.
     * @returns {Promise&lt;void&gt;} Returns a promise that resolves when search term discovery is complete.
     * @description
     *   - Utilizes a search function `tavilySearch` to find results based on search terms.
     *   - Incorporates error handling and logs errors to `results.errors`.
     *   - Implements rate limiting by delaying subsequent searches using `DISCOVERY_CONFIG.rateLimitDelayMs`.
     *   - Processes search results using the `processSearchResults` method if valid results are found.
     */
    private performSearchTermDiscovery;
    private performDirectoryCrawling;
    /**
     * Crawls a single directory and processes discovered URLs.
     * @example
     * crawlSingleDirectory('http://example.com', new Set(), resultsInstance)
     * void
     * @param {string} directoryUrl - The URL of the directory to be crawled.
     * @param {Set&lt;string&gt;} discoveredUrls - A set to store URLs discovered during the crawl.
     * @param {DiscoveryResult} results - An object to store the results and errors of the crawl process.
     * @returns {Promise&lt;void&gt;} Resolves when crawl and processing are complete.
     * @description
     *   - Uses a third-party library, `firecrawlCrawl`, for the crawling operation.
     *   - Handles errors by logging and storing error messages in the results object.
     *   - Limits the depth and number of URLs explored based on configuration.
     */
    private crawlSingleDirectory;
    /**
     * Processes the results from a web crawl and adds discovered URLs to a set if they meet certain criteria.
     * @example
     * processCrawlResults(crawlResults, discoveredUrls)
     * // adds qualifying URLs to the discoveredUrls set
     * @param {unknown} crawlResults - The results obtained from the crawling operation.
     * @param {Set&lt;string&gt;} discoveredUrls - A set to store URLs discovered during processing.
     * @returns {Promise&lt;void&gt;}
     * @description
     *   - Only accepts results that are valid non-empty arrays.
     *   - Checks each item to ensure it's an object containing a 'url' property.
     *   - Uses a helper function isFoodTruckUrl to decide if a URL should be added to the set.
     */
    private processCrawlResults;
    private performLocationDiscovery;
    /**
    * Initiates a search for food trucks within a specified city in South Carolina.
    * @example
    * searchSingleCity(&quot;Charleston&quot;, discoveredUrls, results)
    * // Returns undefined but processes the data internally and updates results object.
    * @param {string} city - The name of the city where food trucks are to be searched.
    * @param {Set&lt;string&gt;} discoveredUrls - A Set to keep track of URLs that have been discovered during the search.
    * @param {DiscoveryResult} results - Object to store errors and possibly other results related to the discovery process.
    * @returns {Promise&lt;void&gt;} Resolves after processing the search results.
    * @description
    *   - Uses `tavilySearch` function to perform the location-based search with a limit of 5 results.
    *   - Handles errors by logging them and updating the results object with error messages.
    *   - Assumes South Carolina as the default state for city searches.
    */
    private searchSingleCity;
    /**
     * Processes search results to discover specific URLs and add them to a set.
     * @example
     * processLocationSearchResults(searchResults, discoveredUrls);
     * // The set discoveredUrls will be populated with food truck URLs from searchResults
     * @param {unknown} searchResults - Array of search result objects potentially containing URLs.
     * @param {Set&lt;string&gt;} discoveredUrls - Set used to collect discovered food truck URLs.
     * @returns {Promise&lt;void&gt;} Resolves when all URLs are processed and added to the set.
     * @description
     *   - Ensures the searchResults contain an array of objects with valid URL properties.
     *   - Filters URLs through isFoodTruckUrl method before adding them to discoveredUrls.
     */
    private processLocationSearchResults;
    /**
     * Stores a set of discovered URLs from a discovery process into a database.
     * @example
     * storeDiscoveredUrlsFromDiscovery(new Set(['http://example.com', 'http://example.org']), discoveryResult)
     * // No return value (undefined).
     * @param {Set&lt;string&gt;} discoveredUrls - A set of URLs that have been discovered and need to be stored.
     * @param {DiscoveryResult} results - An object to track and accumulate errors encountered during storage.
     * @returns {Promise&lt;void&gt;} Resolves when all URLs are processed and stored.
     * @description
     *   - This function iterates over a set of URLs and stores each individually.
     *   - Errors encountered during the storage process are logged and appended to the provided results object.
     *   - Utilizes an asynchronous operation to store URLs and handle potential failures gracefully.
     */
    private storeDiscoveredUrlsFromDiscovery;
    /**
    * Initiates autonomous discovery of new food truck URLs.
    * @example
    * discoverNewFoodTrucks()
    * Returns a Promise resolving to a DiscoveryResult object.
    * @param {none} No parameters required.
    * @returns {Promise&lt;DiscoveryResult&gt;} An object containing the counts of discovered, stored, and duplicate URLs and any errors encountered.
    * @description
    *   - Utilizes multiple discovery methods: search term, directory crawling, and location-specific search.
    *   - Aggregates discovered URLs in a Set to ensure uniqueness.
    *   - Logs informative messages regarding the discovery and storage process.
    *   - Handles the storage of newly discovered URLs and logs duplicates.
    */
    discoverNewFoodTrucks(): Promise&lt;DiscoveryResult&gt;;
    /**
     * Extracts valid URLs from a given string content.
     * @example
     * extractFoodTruckUrls(&quot;Check out these two links: https://foodtrucklink.com/menu, and https://anotherlink.com!&quot;)
     * [&quot;https://foodtrucklink.com/menu&quot;, &quot;https://anotherlink.com&quot;]
     * @param {string} content - The textual content from which URLs are extracted.
     * @returns {string[]} An array of valid URLs extracted from the content.
     * @description
     *   - Utilizes a regular expression pattern to identify potential URLs.
     *   - Performs basic URL validation using the URL constructor.
     *   - Cleans up URLs by removing trailing punctuation such as periods, commas, semicolons, etc.
     *   - Skips invalid URLs identified during the validation process.
     */
    private extractFoodTruckUrls;
    /**
     * Checks if a given URL is related to a food truck.
     * @example
     * isFoodTruckUrl(&quot;https://bestfoodtruck.com&quot;)
     * true
     * @param {string} url - The URL to validate and check against known food truck patterns.
     * @returns {Promise&lt;boolean&gt;} True if the URL is likely related to a food truck, false otherwise.
     * @description
     *   - Uses keyword matching to detect food truck-related URLs.
     *   - Excludes common social media and review domains via blacklist.
     *   - Validates if the URL is already present in `discovered_urls` or `food_trucks` database.
     *   - Accepts common business domains not typically associated with blogs or news sites.
     */
    private isFoodTruckUrl;
    /**
     * Initiates a discovery process for food trucks in the specified city and state.
     * @example
     * getLocationSpecificDiscovery('Charleston', 'SC')
     * Promise &lt;DiscoveryResult&gt; {urls_discovered: 5, urls_stored: 4, urls_duplicates: 1, errors: []}
     * @param {string} city - The city where the search is to be performed.
     * @param {string} [state='SC'] - The state where the search is to be performed; defaults to 'SC'.
     * @returns {Promise&lt;DiscoveryResult&gt;} An object containing the discovery results and any errors encountered.
     * @description
     *   - Logs the initiation and completion of the discovery process with results.
     *   - Performs the search using a specified query and stores new URLs found.
     *   - Captures and logs any errors encountered during the search process.
     */
    getLocationSpecificDiscovery(city: string, state?: string): Promise&lt;DiscoveryResult&gt;;
    /**
    * Executes a location-specific search and processes the results.
    * @example
    * performLocationSpecificSearch(&quot;San Francisco&quot;, new Set())
    * // Processes search results for &quot;San Francisco&quot; location
    * @param {string} locationQuery - The location query to perform the search.
    * @param {Set&lt;string&gt;} discoveredUrls - A set to track URLs that have already been discovered.
    * @returns {Promise&lt;void&gt;} Completes search processing without return value.
    * @description
    *   - Searches are performed with a limit of 15 results.
    *   - Only non-empty search results are processed.
    *   - Uses asynchronous calls to handle search and processing operations.
    */
    private performLocationSpecificSearch;
    private processSearchResult;
    /**
     * Extracts food truck URLs from a given result object and adds them to a discovered URL set.
     * @example
     * extractUrlsFromContent(resultObject, discoveredUrlSet)
     * void
     * @param {unknown} result - The result object potentially containing content with URLs.
     * @param {Set&lt;string&gt;} discoveredUrls - A set where extracted food truck URLs will be added.
     * @returns {Promise&lt;void&gt;} Resolves when URLs are added to the set.
     * @description
     *   - Parses both `content` and `raw_content` properties for URLs.
     *   - Uses helper method `extractFoodTruckUrls` to identify specific URLs.
     *   - Filters URLs through `isFoodTruckUrl` method to ensure relevance before adding.
     */
    private extractUrlsFromContent;
    /**
     * Stores location discovery results by iterating through a set of discovered URLs.
     * @example
     * storeLocationDiscoveryResults({
     *   discoveredUrls: new Set(['http://example.com']),
     *   locationQuery: 'pizza restaurant',
     *   city: 'San Francisco',
     *   state: 'CA',
     *   results: {}
     * })
     *
     * @param {Object} params - Parameters for storing the discovery results.
     * @param {Set&lt;string&gt;} params.discoveredUrls - A set of URLs to be stored.
     * @param {string} params.locationQuery - The location query used in the search.
     * @param {string} params.city - The target city for the location search.
     * @param {string} params.state - The target state for the location search.
     * @param {DiscoveryResult} params.results - Object to store results and errors.
     * @returns {Promise&lt;void&gt;} No return value.
     * @description
     *   - Logs an error and records it in the results if storing a URL fails.
     *   - Assumes the existence of a method `storeDiscoveredUrl` to handle storage logic.
     *   - The `results` object is mutated by adding error messages directly.
     */
    private storeLocationDiscoveryResults;
    private delay;
    /**
     * Store multiple discovered URLs with metadata
     */
    storeDiscoveredUrls(urls: string[], discoveryMethod?: string, metadata?: Record&lt;string, unknown&gt;): Promise&lt;{
        urls_stored: number;
        urls_duplicates: number;
        errors: string[];
    }&gt;;
    /**
     * Enhanced store method with discovery method and metadata
     */
    private storeDiscoveredUrl;
    /**
     * Search for food truck directories
     */
    searchFoodTruckDirectories(query?: string): Promise&lt;TavilySearchResult[]&gt;;
    /**
     * Search for food truck websites
     */
    searchFoodTruckWebsites(query: string): Promise&lt;TavilySearchResult[]&gt;;
}
export declare const discoveryEngine: FoodTruckDiscoveryEngine;
export {};</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/lib/database.types.d.ts (Line 1:1 - Line 278:2), C:/AI/food-truck-finder-poc/dist/lib/lib/database.types.d.ts (Line 1:1 - Line 278:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn495" onclick="toggleCodeBlock('cloneGroup495', 'expandBtn495', 'collapseBtn495')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn495" onclick="toggleCodeBlock('cloneGroup495', 'expandBtn495', 'collapseBtn495')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup495"><code class="language-typescript text-sm text-gray-800">/**
 * Database Types for Food Truck Finder Application
 * Auto-generated from Supabase schema
 */
export type Json = string | number | boolean | undefined | {
    [key: string]: Json | undefined;
} | Json[];
export interface Database {
    public: {
        Tables: {
            food_trucks: {
                Row: {
                    id: string;
                    created_at: string;
                    updated_at: string;
                    name: string;
                    description: string | undefined;
                    current_location: Json;
                    scheduled_locations: Json | undefined;
                    operating_hours: Json | undefined;
                    menu: Json | undefined;
                    contact_info: Json | undefined;
                    social_media: Json | undefined;
                    cuisine_type: string[] | undefined;
                    price_range: string | undefined;
                    specialties: string[] | undefined;
                    data_quality_score: number | undefined;
                    verification_status: 'pending' | 'verified' | 'flagged' | 'rejected';
                    source_urls: string[] | undefined;
                    last_scraped_at: string | undefined;
                    exact_location: Json | undefined;
                    city_location: Json | undefined;
                    user_id: string | undefined;
                    average_rating: number | undefined;
                    review_count: number | undefined;
                    last_updated_at: string | undefined;
                    is_active: boolean | undefined;
                };
                Insert: {
                    id?: string;
                    created_at?: string;
                    updated_at?: string;
                    name: string;
                    description?: string | undefined;
                    current_location: Json;
                    scheduled_locations?: Json | undefined;
                    operating_hours?: Json | undefined;
                    menu?: Json | undefined;
                    contact_info?: Json | undefined;
                    social_media?: Json | undefined;
                    cuisine_type?: string[] | undefined;
                    price_range?: string | undefined;
                    specialties?: string[] | undefined;
                    data_quality_score?: number | undefined;
                    verification_status?: 'pending' | 'verified' | 'flagged' | 'rejected';
                    source_urls?: string[] | undefined;
                    last_scraped_at?: string | undefined;
                    exact_location?: Json | undefined;
                    city_location?: Json | undefined;
                    user_id?: string | undefined;
                    average_rating?: number | undefined;
                    review_count?: number | undefined;
                    last_updated_at?: string | undefined;
                    is_active?: boolean | undefined;
                };
                Update: {
                    id?: string;
                    created_at?: string;
                    updated_at?: string;
                    name?: string;
                    description?: string | undefined;
                    current_location?: Json;
                    scheduled_locations?: Json | undefined;
                    operating_hours?: Json | undefined;
                    menu?: Json | undefined;
                    contact_info?: Json | undefined;
                    social_media?: Json | undefined;
                    cuisine_type?: string[] | undefined;
                    price_range?: string | undefined;
                    specialties?: string[] | undefined;
                    data_quality_score?: number | undefined;
                    verification_status?: 'pending' | 'verified' | 'flagged' | 'rejected';
                    source_urls?: string[] | undefined;
                    last_scraped_at?: string | undefined;
                    exact_location?: Json | undefined;
                    city_location?: Json | undefined;
                    user_id?: string | undefined;
                    average_rating?: number | undefined;
                    review_count?: number | undefined;
                    last_updated_at?: string | undefined;
                    is_active?: boolean | undefined;
                };
            };
            scraping_jobs: {
                Row: {
                    id: string;
                    job_type: string;
                    target_url: string | undefined;
                    target_handle: string | undefined;
                    platform: string | undefined;
                    status: 'pending' | 'running' | 'completed' | 'failed';
                    priority: number;
                    scheduled_at: string;
                    started_at: string | undefined;
                    completed_at: string | undefined;
                    data_collected: Json | undefined;
                    errors: string[] | undefined;
                    retry_count: number;
                    max_retries: number;
                    created_at: string;
                };
                Insert: {
                    id?: string;
                    job_type: string;
                    target_url?: string | undefined;
                    target_handle?: string | undefined;
                    platform?: string | undefined;
                    status?: 'pending' | 'running' | 'completed' | 'failed';
                    priority?: number;
                    scheduled_at?: string;
                    started_at?: string | undefined;
                    completed_at?: string | undefined;
                    data_collected?: Json | undefined;
                    errors?: string[] | undefined;
                    retry_count?: number;
                    max_retries?: number;
                    created_at?: string;
                };
                Update: {
                    id?: string;
                    job_type?: string;
                    target_url?: string | undefined;
                    target_handle?: string | undefined;
                    platform?: string | undefined;
                    status?: 'pending' | 'running' | 'completed' | 'failed';
                    priority?: number;
                    scheduled_at?: string;
                    started_at?: string | undefined;
                    completed_at?: string | undefined;
                    data_collected?: Json | undefined;
                    errors?: string[] | undefined;
                    retry_count?: number;
                    max_retries?: number;
                    created_at?: string;
                };
            };
            events: {
                Row: {
                    id: string;
                    food_truck_id: string | undefined;
                    title: string;
                    description: string | undefined;
                    event_date: string;
                    start_time: string | undefined;
                    end_time: string | undefined;
                    location_address: string | undefined;
                    location_lat: number | undefined;
                    location_lng: number | undefined;
                    created_at: string;
                    updated_at: string;
                };
                Insert: {
                    id?: string;
                    food_truck_id?: string | undefined;
                    title: string;
                    description?: string | undefined;
                    event_date: string;
                    start_time?: string | undefined;
                    end_time?: string | undefined;
                    location_address?: string | undefined;
                    location_lat?: number | undefined;
                    location_lng?: number | undefined;
                    created_at?: string;
                    updated_at?: string;
                };
                Update: {
                    id?: string;
                    food_truck_id?: string | undefined;
                    title?: string;
                    description?: string | undefined;
                    event_date?: string;
                    start_time?: string | undefined;
                    end_time?: string | undefined;
                    location_address?: string | undefined;
                    location_lat?: number | undefined;
                    location_lng?: number | undefined;
                    created_at?: string;
                    updated_at?: string;
                };
            };
            discovered_urls: {
                Row: {
                    id: string;
                    url: string;
                    source_directory_url: string | undefined;
                    region: string | undefined;
                    status: 'new' | 'processing' | 'processed' | 'irrelevant' | 'failed';
                    discovery_method: 'manual' | 'autonomous_search' | 'tavily_search' | 'firecrawl_crawl' | 'directory_crawl';
                    discovered_at: string;
                    last_processed_at: string | undefined;
                    processing_attempts: number;
                    notes: string | undefined;
                    metadata: Json | undefined;
                    created_at: string;
                    updated_at: string;
                };
                Insert: {
                    id?: string;
                    url: string;
                    source_directory_url?: string | undefined;
                    region?: string | undefined;
                    status?: 'new' | 'processing' | 'processed' | 'irrelevant' | 'failed';
                    discovery_method?: 'manual' | 'autonomous_search' | 'tavily_search' | 'firecrawl_crawl' | 'directory_crawl';
                    discovered_at?: string;
                    last_processed_at?: string | undefined;
                    processing_attempts?: number;
                    notes?: string | undefined;
                    metadata?: Json | undefined;
                    created_at?: string;
                    updated_at?: string;
                };
                Update: {
                    id?: string;
                    url?: string;
                    source_directory_url?: string | undefined;
                    region?: string | undefined;
                    status?: 'new' | 'processing' | 'processed' | 'irrelevant' | 'failed';
                    discovery_method?: 'manual' | 'autonomous_search' | 'tavily_search' | 'firecrawl_crawl' | 'directory_crawl';
                    discovered_at?: string;
                    last_processed_at?: string | undefined;
                    processing_attempts?: number;
                    notes?: string | undefined;
                    metadata?: Json | undefined;
                    created_at?: string;
                    updated_at?: string;
                };
            };
            profiles: {
                Row: {
                    id: string;
                    user_id: string;
                    username: string | undefined;
                    full_name: string | undefined;
                    avatar_url: string | undefined;
                    updated_at: string;
                };
                Insert: {
                    id?: string;
                    user_id: string;
                    username?: string | undefined;
                    full_name?: string | undefined;
                    avatar_url?: string | undefined;
                    updated_at?: string;
                };
                Update: {
                    id?: string;
                    user_id?: string;
                    username?: string | undefined;
                    full_name?: string | undefined;
                    avatar_url?: string | undefined;
                    updated_at?: string;
                };
            };
        };
        Views: {
            [_ in never]: never;
        };
        Functions: {
            [_ in never]: never;
        };
        Enums: {
            [_ in never]: never;
        };
        CompositeTypes: {
            [_ in never]: never;
        };
    };
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/lib/config.d.ts (Line 1:1 - Line 10:2), C:/AI/food-truck-finder-poc/dist/lib/lib/config.d.ts (Line 1:1 - Line 10:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn497" onclick="toggleCodeBlock('cloneGroup497', 'expandBtn497', 'collapseBtn497')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn497" onclick="toggleCodeBlock('cloneGroup497', 'expandBtn497', 'collapseBtn497')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup497"><code class="language-typescript text-sm text-gray-800">export declare const DEFAULT_SCRAPE_URLS: string[];
export declare const DEFAULT_STALENESS_THRESHOLD_DAYS: number;
export declare const SC_TARGET_CITIES: string[];
export declare const DISCOVERY_CONFIG: {
    maxUrlsPerRun: number;
    maxDepthCrawl: number;
    searchResultsLimit: number;
    batchSize: number;
    rateLimitDelayMs: number;
};</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/lib/autoScraper.d.ts (Line 1:1 - Line 139:2), C:/AI/food-truck-finder-poc/dist/lib/lib/autoScraper.d.ts (Line 1:1 - Line 139:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn499" onclick="toggleCodeBlock('cloneGroup499', 'expandBtn499', 'collapseBtn499')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn499" onclick="toggleCodeBlock('cloneGroup499', 'expandBtn499', 'collapseBtn499')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup499"><code class="language-typescript text-sm text-gray-800">interface TriggerScrapingProcessResult {
    success: boolean;
    jobId?: string;
    message?: string;
    error?: string;
}
export interface AutoScrapeResult {
    trucksProcessed: number;
    newTrucksFound: number;
    errors: Array&lt;{
        url: string;
        details?: string;
    }&gt;;
}
interface GeminiUsageLimits {
    canMakeRequest: boolean;
}
interface ProcessedMenuData {
    menu: Array&lt;{
        category: string;
        items: Array&lt;{
            name: string;
            description?: string;
            price?: number;
            dietary_tags?: string[];
        }&gt;;
    }&gt;;
}
interface ExtractedLocationData {
    location: {
        address?: string;
        city?: string;
        state?: string;
        zip?: string;
        coordinates?: {
            latitude: number;
            longitude: number;
        };
    };
}
interface StandardizedOperatingHours {
    hours: Record&lt;string, string&gt;;
}
interface SentimentAnalysisResult {
    overall_sentiment: 'positive' | 'negative' | 'neutral';
    score: number;
}
interface EnhancedFoodTruckData {
    description: string;
    cuisine_type: string[];
    specialties: string[];
}
interface GeminiService {
    checkUsageLimits(): Promise&lt;GeminiUsageLimits&gt;;
    processMenuData(input: unknown): Promise&lt;ProcessedMenuData&gt;;
    extractLocationFromText(input: unknown): Promise&lt;ExtractedLocationData&gt;;
    standardizeOperatingHours(input: unknown): Promise&lt;StandardizedOperatingHours&gt;;
    analyzeSentiment(input: unknown): Promise&lt;SentimentAnalysisResult&gt;;
    enhanceFoodTruckData(input: unknown): Promise&lt;EnhancedFoodTruckData&gt;;
}
/**
 * Initiates a web scraping process for a given target URL.
 * @example
 * triggerScrapingProcess('https://example.com')
 * { success: true, jobId: '12345', message: 'Scraping job created and processing initiated for https://example.com.' }
 * @param {string} targetUrl - The URL of the website to be scraped.
 * @returns {Promise&lt;TriggerScrapingProcessResult&gt;} Result of the attempt to trigger the scraping process, including success status, job ID, and message or error.
 * @description
 *   - Creates a web scraping job with a priority of 5 and triggers its processing.
 *   - Handles errors during job creation or processing gracefully.
 *   - Uses the current timestamp to schedule the job.
 */
declare function triggerScrapingProcess(targetUrl: string): Promise&lt;TriggerScrapingProcessResult&gt;;
/**
 * Initiates the autonomous scraping process and ensures default trucks data is fetched.
 * @example
 * ensureDefaultTrucksAreScraped()
 * Returns a result object containing the number of trucks processed, new trucks found, and any errors encountered.
 * @returns {Promise&lt;AutoScrapeResult&gt;} An object containing the results of the scraping process, including processed trucks count, new trucks discovered count, and encountered errors.
 * @description
 *   - Combines static default URLs with dynamically discovered URLs for scraping.
 *   - Handles both existing and new trucks, updating counters and tracking errors.
 *   - Logs process information and warnings for unexpected errors during execution.
 */
export declare function ensureDefaultTrucksAreScraped(): Promise&lt;AutoScrapeResult&gt;;
/**
 * Makes a call to Gemini service and caches the result to optimize performance.
 * @example
 * callGeminiWithCache('getData', { id: 123 }, geminiInstance)
 * // returns the result from the Gemini service or cache
 * @param {string} type - The type of operation to perform with Gemini.
 * @param {unknown} input - The input data required for the Gemini operation.
 * @param {GeminiService} gemini - The instance of GeminiService to interact with.
 * @returns {Promise&lt;unknown&gt;} Returns a promise that resolves to the result of the Gemini operation.
 * @description
 *   - Caches the result of Gemini service calls to avoid redundant requests.
 *   - Automatically cleans up expired cache entries based on a specified TTL.
 *   - Checks Gemini usage limits before making API calls to prevent exceeding the daily cap.
 *   - Constructs a unique cache key for each request using the operation type and input.
 */
export declare function callGeminiWithCache(type: string, input: unknown, gemini: GeminiService): Promise&lt;unknown&gt;;
/**
* Retrieves a list of URLs that are ready for scraping.
* @example
* getUrlsToScrape()
* // Returns a Promise that resolves to an array of URLs
* @param {void} - This function does not take any arguments.
* @returns {Promise&lt;string[]&gt;} A promise that resolves to an array of URLs to be scraped.
* @description
*   - The function returns a combination of default URLs and dynamically discovered URLs.
*   - Utilizes Supabase to fetch URLs marked with 'new' or 'processed' status.
*   - Limits results to prevent system overload, fetching a maximum of 100 URLs.
*   - Handles errors gracefully, logging warnings if the Supabase client is not available or if there is an error in fetching URLs.
*/
declare function getUrlsToScrape(): Promise&lt;string[]&gt;;
/**
 * Updates the status of a discovered URL in the database.
 * @example
 * updateDiscoveredUrlStatus('http://example.com', 'processed', 'Page successfully processed')
 * // Returns: void
 * @param {string} url - The URL whose status needs updating.
 * @param {'processing' | 'processed' | 'irrelevant'} status - The new status for the URL.
 * @param {string} [notes] - Optional notes regarding the URL status update.
 * @returns {Promise&lt;void&gt;} Resolves when the update operation is complete.
 * @description
 *   - Logs a warning if the Supabase admin client is not available.
 *   - Uses Supabase to update the status and logs an error if the operation fails.
 *   - Assumes the existence of a 'discovered_urls' table in the database.
 */
declare function updateDiscoveredUrlStatus(url: string, status: 'processing' | 'processed' | 'irrelevant', notes?: string): Promise&lt;void&gt;;
export declare const autoScraper: {
    runAutoScraping: typeof ensureDefaultTrucksAreScraped;
    triggerScrapingProcess: typeof triggerScrapingProcess;
    callGeminiWithCache: typeof callGeminiWithCache;
    getUrlsToScrape: typeof getUrlsToScrape;
    updateDiscoveredUrlStatus: typeof updateDiscoveredUrlStatus;
};
export declare function runAutonomousScraping(): Promise&lt;AutoScrapeResult&gt;;
export {};</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/lib/activityLogger.d.ts (Line 1:1 - Line 22:2), C:/AI/food-truck-finder-poc/dist/lib/lib/activityLogger.d.ts (Line 1:1 - Line 22:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn501" onclick="toggleCodeBlock('cloneGroup501', 'expandBtn501', 'collapseBtn501')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn501" onclick="toggleCodeBlock('cloneGroup501', 'expandBtn501', 'collapseBtn501')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup501"><code class="language-typescript text-sm text-gray-800">interface ActivityLogEntry {
    type: 'cron_job' | 'manual_scrape' | 'system_event' | 'user_action';
    action: string;
    details: Record&lt;string, unknown&gt;;
    timestamp?: string;
}
/**
* Logs an activity entry with a timestamp and unique ID.
* @example
* logActivity({ action: 'user_login', username: 'johndoe' })
* undefined
* @param {ActivityLogEntry} entry - The activity entry to be logged.
* @returns {void} No return value.
* @description
*   - If `timestamp` is not provided in the entry, the current ISO timestamp is used.
*   - A unique ID is generated and added to the log entry.
*   - Logs activity data to the console in a structured format.
*   - Intended for development, but can be extended for production use with database or monitoring integration.
*/
export declare function logActivity(entry: ActivityLogEntry): void;
export declare function getActivityLogs(_type?: string, _limit?: number): ActivityLogEntry[];
export {};</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/gemini/usageLimits.d.ts (Line 1:1 - Line 52:2), C:/AI/food-truck-finder-poc/dist/lib/lib/gemini/usageLimits.d.ts (Line 1:1 - Line 52:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn506" onclick="toggleCodeBlock('cloneGroup506', 'expandBtn506', 'collapseBtn506')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn506" onclick="toggleCodeBlock('cloneGroup506', 'expandBtn506', 'collapseBtn506')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup506"><code class="language-typescript text-sm text-gray-800">export interface UsageLimits {
    dailyRequestLimit: number;
    dailyTokenLimit: number;
}
export interface UsageCheck {
    canMakeRequest: boolean;
    usage?: {
        requests: {
            used: number;
            limit: number;
            remaining: number;
        };
        tokens: {
            used: number;
            limit: number;
            remaining: number;
        };
    };
}
export declare class GeminiUsageLimits {
    private static readonly DEFAULT_LIMITS;
    /**
     * Checks the current usage against predefined limits and determines if further requests can be made.
     * @example
     * checkUsageLimits()
     * { canMakeRequest: true, usage: { requests: { used: 50, limit: 1000, remaining: 950 }, tokens: { used: 200, limit: 5000, remaining: 4800 } } }
     * @param {UsageLimits} limits - Object containing usage limits for requests and tokens.
     * @returns {Promise&lt;UsageCheck&gt;} Object indicating if a request can be made and the current usage statistics.
     * @description
     *   - Attempts to fetch today's usage data from the APIUsageService for 'gemini'.
     *   - If the fetch fails, defaults to allowing the request with a warning.
     *   - Maintains a buffer of 100 tokens to ensure requests are not made when limits are too close.
     */
    static checkUsageLimits(limits?: UsageLimits): Promise&lt;UsageCheck&gt;;
    /**
    * Checks if a request can be made with monitoring and returns whether the operation is allowed.
    * @example
    * checkWithMonitoring(100, DEFAULT_LIMITS)
    * { allowed: true }
    * @param {number} estimatedTokens - Number of estimated tokens for the request.
    * @param {UsageLimits} _limits - Usage limits configuration for requests (default provided internally).
    * @returns {Promise&lt;{ allowed: boolean; reason?: string; waitTime?: number }&gt;} Object indicating if the request is allowed and why not if denied.
    * @description
    *   - Uses an internal API monitor to check if requests can be made based on predefined limits.
    *   - Wait time is converted from milliseconds to minutes before being returned.
    */
    static checkWithMonitoring(estimatedTokens: number, _limits?: UsageLimits): Promise&lt;{
        allowed: boolean;
        reason?: string;
        waitTime?: number;
    }&gt;;
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/gemini/responseParser.d.ts (Line 1:1 - Line 11:2), C:/AI/food-truck-finder-poc/dist/lib/lib/gemini/responseParser.d.ts (Line 1:1 - Line 11:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn508" onclick="toggleCodeBlock('cloneGroup508', 'expandBtn508', 'collapseBtn508')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn508" onclick="toggleCodeBlock('cloneGroup508', 'expandBtn508', 'collapseBtn508')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup508"><code class="language-typescript text-sm text-gray-800">import { type MenuCategory, type LocationData, type OperatingHours, type SentimentAnalysisResult, type EnhancedFoodTruckData, type ExtractedFoodTruckDetails } from '../types';
export declare const GeminiResponseParser: {
    parseJson&lt;T&gt;(text: string): T;
    parseMenuData(text: string): MenuCategory[];
    parseLocationData(text: string): LocationData;
    parseOperatingHours(text: string): OperatingHours;
    parseSentimentAnalysis(text: string): SentimentAnalysisResult;
    parseEnhancedFoodTruckData(text: string): EnhancedFoodTruckData;
    parseExtractedFoodTruckDetails(text: string): ExtractedFoodTruckDetails;
    cleanMarkdownResponse(text: string): string;
};</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/gemini/promptTemplates.d.ts (Line 1:1 - Line 8:2), C:/AI/food-truck-finder-poc/dist/lib/lib/gemini/promptTemplates.d.ts (Line 1:1 - Line 8:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn510" onclick="toggleCodeBlock('cloneGroup510', 'expandBtn510', 'collapseBtn510')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn510" onclick="toggleCodeBlock('cloneGroup510', 'expandBtn510', 'collapseBtn510')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup510"><code class="language-typescript text-sm text-gray-800">export declare const PromptTemplates: {
    menuProcessing: (rawMenuText: string) =&gt; string;
    locationExtraction: (textInput: string) =&gt; string;
    operatingHours: (hoursText: string) =&gt; string;
    sentimentAnalysis: (reviewText: string) =&gt; string;
    dataEnhancement: (rawData: unknown) =&gt; string;
    foodTruckExtraction: (markdownContent: string, sourceUrl?: string) =&gt; string;
};</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/gemini/geminiApiClient.d.ts (Line 1:1 - Line 41:2), C:/AI/food-truck-finder-poc/dist/lib/lib/gemini/geminiApiClient.d.ts (Line 1:1 - Line 41:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn512" onclick="toggleCodeBlock('cloneGroup512', 'expandBtn512', 'collapseBtn512')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn512" onclick="toggleCodeBlock('cloneGroup512', 'expandBtn512', 'collapseBtn512')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup512"><code class="language-typescript text-sm text-gray-800">import type { GeminiResponse } from '../types';
export interface GeminiApiConfig {
    temperature?: number;
    maxTokens?: number;
}
export declare class GeminiApiClient {
    private genAI;
    private modelName;
    constructor();
    /**
    * Makes an API request to generate content based on the provided prompt and configuration.
    * @example
    * makeRequest('Create a poem about nature', { temperature: 0.7 })
    * Returns a promise that resolves to a GeminiResponse containing the generated text and token usage.
    * @param {string} prompt - The input prompt for content generation.
    * @param {GeminiApiConfig} config - Configuration settings for the API request, such as temperature. Defaults to an empty object.
    * @returns {Promise&lt;GeminiResponse&lt;T&gt;&gt;} A promise that resolves to a GeminiResponse with the generated content or an error message.
    * @description
    *   - The function calculates the number of tokens used for tracking purposes, even in case of an error.
    *   - The `temperature` parameter affects the randomness of the content generation, with higher values resulting in more creative outputs.
    *   - API usage is tracked asynchronously, and warnings are logged if tracking fails.
    *   - Returns an object indicating success status, the generated content or error message, and the number of tokens used.
    */
    makeRequest&lt;T&gt;(prompt: string, config?: GeminiApiConfig): Promise&lt;GeminiResponse&lt;T&gt;&gt;;
    /**
     * Executes a request using a specified prompt and attempts to parse the response using the provided parser function.
     * @example
     * makeRequestWithParsing(&quot;example prompt&quot;, (text) =&gt; JSON.parse(text))
     * { success: true, data: { key: &quot;value&quot; }, tokensUsed: 100 }
     * @param {string} prompt - The prompt used to make the API request.
     * @param {function} parser - A function to parse the response text into the desired format.
     * @param {GeminiApiConfig} config - Optional configuration settings for the Gemini API request.
     * @returns {Promise&lt;GeminiResponse&lt;T&gt;&gt;} A promise resolving to a GeminiResponse object containing either the parsed data or an error description.
     * @description
     *   - The function makes an asynchronous request using a specific prompt string and configuration.
     *   - If the response is unsuccessful, it returns the original response cast to the expected return type.
     *   - Parses the successful response data using the provided parser function.
     *   - Handles parsing errors gracefully, returning a detailed error message and logs the raw problematic response.
     */
    makeRequestWithParsing&lt;T&gt;(prompt: string, parser: (text: string) =&gt; T, config?: GeminiApiConfig): Promise&lt;GeminiResponse&lt;T&gt;&gt;;
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/data-quality/placeholderUtils.d.ts (Line 1:1 - Line 43:2), C:/AI/food-truck-finder-poc/dist/lib/lib/data-quality/placeholderUtils.d.ts (Line 1:1 - Line 43:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn514" onclick="toggleCodeBlock('cloneGroup514', 'expandBtn514', 'collapseBtn514')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn514" onclick="toggleCodeBlock('cloneGroup514', 'expandBtn514', 'collapseBtn514')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup514"><code class="language-typescript text-sm text-gray-800">import type { FoodTruck } from '@/lib/supabase';
/**
* Returns an array of regular expressions that identify placeholder patterns.
* @example
* getPlaceholderPatterns()
* [ /undefined/i, /placeholder/i, /example\.com/i, /test\s*truck/i, /lorem\s*ipsum/i, /\bna\b/i, /\bn\/a\b/i, /^0+$/, /^null$/i ]
* @returns {RegExp[]} An array of regular expressions to match various placeholder values.
* @description
*   - Regular expressions cover common placeholder values used in data.
*   - Patterns are designed to be case insensitive to support a wider range of inputs.
*   - Contains specific patterns like 'example.com' to catch domain placeholders.
*   - Includes matches for numeric placeholders like '000...' and 'null'.
*/
export declare function getPlaceholderPatterns(): RegExp[];
/**
* Checks the food truck's properties for placeholder patterns and sets them to undefined if a pattern is found.
* @example
* checkForPlaceholders(foodTruckObj, [/\b(?:N\/A|TBD|Unknown)\b/, /^{.+}$/])
* {name: undefined, description: undefined}
* @param {FoodTruck} truck - The food truck object which may contain placeholder text in its properties.
* @param {RegExp[]} patterns - Array of regex patterns used to test against food truck properties.
* @returns {Partial&lt;FoodTruck&gt;} A partial food truck object with properties set to undefined if placeholders are detected.
* @description
*   - The function does not modify the original truck object; it returns a new one.
*   - Handles undefined properties seamlessly to prevent errors during regex testing.
*   - Assumes that the RegExp provided will effectively identify placeholder patterns.
*/
export declare function checkForPlaceholders(truck: FoodTruck, patterns: RegExp[]): Partial&lt;FoodTruck&gt;;
/**
* Processes a FoodTruck object for placeholders and returns updates.
* @example
* processTruckForPlaceholders(truck, [/pattern1/g, /pattern2/g])
* { name: 'Updated Truck Name', address: 'Updated Address' }
* @param {FoodTruck} truck - The FoodTruck object to be processed for placeholders.
* @param {Array&lt;RegExp&gt;} patterns - Array of regular expressions to identify placeholders.
* @returns {Partial&lt;FoodTruck&gt;} An object containing the updated fields of the FoodTruck.
* @description
*   - Performs checks for placeholders in basic information of the truck.
*   - Processes contact information of the FoodTruck for placeholders.
*   - Assesses and updates address details for placeholders.
*   - Combines updates from basic, contact, and address information into a single object.
*/
export declare function processTruckForPlaceholders(truck: FoodTruck, patterns: RegExp[]): Partial&lt;FoodTruck&gt;;</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/data-quality/duplicatePrevention.d.ts (Line 1:1 - Line 93:2), C:/AI/food-truck-finder-poc/dist/lib/lib/data-quality/duplicatePrevention.d.ts (Line 1:1 - Line 93:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn516" onclick="toggleCodeBlock('cloneGroup516', 'expandBtn516', 'collapseBtn516')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn516" onclick="toggleCodeBlock('cloneGroup516', 'expandBtn516', 'collapseBtn516')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup516"><code class="language-typescript text-sm text-gray-800">/**
 * SOTA Duplicate Prevention System
 * Implements intelligent duplicate detection and prevention for food truck data
 */
import { type FoodTruck } from '@/lib/supabase';
export declare const DUPLICATE_DETECTION_CONFIG: {
    readonly thresholds: {
        readonly name: 0.85;
        readonly location: 0.9;
        readonly phone: 1;
        readonly website: 1;
        readonly overall: 0.8;
    };
    readonly weights: {
        readonly name: 0.4;
        readonly location: 0.3;
        readonly contact: 0.2;
        readonly menu: 0.1;
    };
};
export interface DuplicateMatch {
    existingTruck: FoodTruck;
    similarity: number;
    matchedFields: string[];
    confidence: 'high' | 'medium' | 'low';
    recommendation: 'merge' | 'update' | 'skip' | 'manual_review';
}
export interface DuplicateDetectionResult {
    isDuplicate: boolean;
    matches: DuplicateMatch[];
    bestMatch?: DuplicateMatch;
    action: 'create' | 'update' | 'merge' | 'manual_review';
    reason: string;
}
/**
 * Advanced Duplicate Prevention Service
 */
export declare class DuplicatePreventionService {
    /**
     * Check if a food truck is a duplicate of existing trucks
     */
    static checkForDuplicates(candidateTruck: Partial&lt;FoodTruck&gt;): Promise&lt;DuplicateDetectionResult&gt;;
    /**
     * Processes the matches found during duplicate detection and returns the result.
     */
    private static processDuplicateMatches;
    /**
     * Calculate similarity between two food trucks
     */
    private static calculateSimilarity;
    /**
     * Calculate string similarity using Levenshtein distance
     */
    private static calculateStringSimilarity;
    /**
     * Calculate location similarity
     */
    private static calculateLocationSimilarity;
    /**
     * Calculate GPS distance in kilometers
     */
    private static calculateGPSDistance;
    /**
     * Calculate contact similarity
     */
    private static calculateContactSimilarity;
    /**
     * Calculate menu similarity (basic implementation)
     */
    private static calculateMenuSimilarity;
    /**
     * Get confidence level based on similarity score
     */
    private static getConfidenceLevel;
    /**
     * Get recommendation based on similarity analysis
     */
    private static getRecommendation;
    /**
     * Determine action based on matches
     */
    private static determineAction;
    /**
     * Generate human-readable reason
     */
    private static generateReason;
    /**
     * Merge duplicate truck data intelligently
     */
    static mergeDuplicates(targetId: string, sourceId: string): Promise&lt;FoodTruck | {
        error: string;
    }&gt;;
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/data-quality/batchCleanup.d.ts (Line 6:19 - Line 26:4), C:/AI/food-truck-finder-poc/dist/lib/lib/types.d.ts (Line 315:21 - Line 333:7)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn518" onclick="toggleCodeBlock('cloneGroup518', 'expandBtn518', 'collapseBtn518')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn518" onclick="toggleCodeBlock('cloneGroup518', 'expandBtn518', 'collapseBtn518')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup518"><code class="language-typescript text-sm text-gray-800">;
    description: string;
    affectedCount: number;
    successCount: number;
    errorCount: number;
    errors: string[];
}
export interface BatchCleanupResult {
    totalProcessed: number;
    operations: CleanupOperation[];
    summary: {
        trucksImproved: number;
        duplicatesRemoved: number;
        qualityScoreImprovement: number;
        placeholdersRemoved: number;
    };
    duration: number;
}
/**
 * Automated Data Quality Cleanup Service
 */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/data-quality/batchCleanup.d.ts (Line 24:1 - Line 231:2), C:/AI/food-truck-finder-poc/dist/lib/lib/data-quality/batchCleanup.d.ts (Line 7:1 - Line 214:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn519" onclick="toggleCodeBlock('cloneGroup519', 'expandBtn519', 'collapseBtn519')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn519" onclick="toggleCodeBlock('cloneGroup519', 'expandBtn519', 'collapseBtn519')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup519"><code class="language-typescript text-sm text-gray-800">/**
 * Automated Data Quality Cleanup Service
 */
export declare class BatchCleanupService {
    /**
     * Run comprehensive data cleanup operations
     */
    static runFullCleanup(options?: {
        batchSize?: number;
        dryRun?: boolean;
        operations?: CleanupOperation['type'][];
    }): Promise&lt;BatchCleanupResult&gt;;
    /**
    * Initializes and returns a new BatchCleanupResult object with default values.
    * @example
    * initializeCleanupResult()
    * { totalProcessed: 0, operations: [], summary: { trucksImproved: 0, duplicatesRemoved: 0, qualityScoreImprovement: 0, placeholdersRemoved: 0 }, duration: 0 }
    * @returns {BatchCleanupResult} A new BatchCleanupResult object with all properties set to initial default values.
    */
    private static initializeCleanupResult;
    private static finalizeCleanupResult;
    /**
     * Processes food trucks in batches, executing specified operations on each batch.
     * @example
     * processTrucksInBatches(truckList, { batchSize: 10, operations: ['clean'], dryRun: true, result: batchResult })
     * // It executes 'clean' operation on batches of 10 trucks without making permanent changes.
     * @param {FoodTruck[]} trucks - Array of food trucks to be processed in batches.
     * @param {object} options - Options object containing batchSize, operations, dryRun, and result.
     * @param {number} options.batchSize - Number of trucks in each batch.
     * @param {CleanupOperation['type'][]} options.operations - Array of operation types to be executed on each batch.
     * @param {boolean} options.dryRun - If true, operations are executed in simulation mode without permanent changes.
     * @param {BatchCleanupResult} options.result - Stores the results of operations performed on batches.
     * @returns {Promise&lt;void&gt;} Completes processing batches without a return value.
     * @description
     *   - Uses async function to allow non-blocking execution of operations.
     *   - Collects and stores results of batch operations separately, keeping track of each operation's outcome.
     *   - Iterates over arrays using slicing to dynamically create batches for processing.
     */
    private static processTrucksInBatches;
    /**
     * Run a specific cleanup operation
     */
    private static runOperation;
    private static runRemovePlaceholders;
    private static runNormalizePhoneNumbers;
    private static runFixCoordinates;
    private static runUpdateQualityScores;
    private static runMergeDuplicates;
    /**
     * Remove placeholder and mock data
     */
    private static removePlaceholders;
    private static processSingleTruckForPlaceholders;
    /**
     * Perform an update operation on a specified food truck.
     * @example
     * performUpdateOperation('truck123', { name: 'New Name' }, true, cleanupOperation)
     * // No direct return value; operation may log errors.
     * @param {string} truckId - The unique identifier of the food truck to be updated.
     * @param {Partial&lt;FoodTruck&gt;} updates - An object containing the fields to be updated.
     * @param {boolean} dryRun - Flag indicating whether the operation should be a simulation without actual changes.
     * @param {CleanupOperation} operation - An operation object that logs errors encountered during update.
     * @returns {Promise&lt;void&gt;} A promise that resolves when the update operation is complete.
     * @description
     *   - If 'dryRun' is true, no updates are applied but actions are logged.
     *   - Errors during update are caught and logged in the 'operation.errors' array.
     */
    private static performUpdateOperation;
    /**
     * Normalize phone numbers to consistent format
     */
    private static normalizePhoneNumbers;
    /**
     * Apply phone normalization update to a food truck's contact information.
     * @example
     * applyPhoneNormalizationUpdate(truckInstance, '+1234567890', false, operationInstance)
     * // Normalizes and updates phone number of given truckInstance.
     * @param {FoodTruck} truck - The food truck object whose phone number needs normalization.
     * @param {string} normalizedPhone - The normalized phone number to update to the food truck's contact information.
     * @param {boolean} dryRun - Flag indicating whether the operation is a dry run; updates are skipped if true.
     * @param {CleanupOperation} operation - Object containing cleanup operation context including a record of errors.
     * @returns {Promise&lt;void&gt;} Does not return a value, but potentially modifies the truck and operation objects.
     * @description
     *   - Executes the update operation only if `dryRun` is false.
     *   - Pushes error messages to `operation.errors` on failure during the update process.
     *   - Uses `FoodTruckService.updateTruck` for updating the contact information.
     */
    private static applyPhoneNormalizationUpdate;
    /**
     * Helper to determine if coordinates need fixing and provide updates
     */
    private static getFixedCoordinates;
    /**
     * Fix invalid GPS coordinates
     */
    private static fixCoordinates;
    /**
     * Processes coordinates for a single food truck, applying any necessary fixes.
     * @example
     * processSingleTruckCoordinates(truck, context)
     * // No return value, function completes silently
     * @param {FoodTruck} truck - The food truck whose coordinates are to be processed.
     * @param {CoordinateProcessContext} context - Contains configuration and operation context for processing coordinates.
     * @returns {Promise&lt;void&gt;} Returns a promise that resolves when the processing and possible updates are complete.
     * @description
     *   - Skips processing if the truck's current location is not available.
     *   - Retrieves updates for fixed coordinates based on truck's current and default locations.
     *   - Applies updates conditionally based on context settings such as `dryRun` and `operation`.
     */
    private static processSingleTruckCoordinates;
    /**
     * Applies coordinate updates for a food truck's current location.
     * @example
     * applyCoordinateFixUpdate(truck, { lat: 34.05, lng: -118.25 }, false, operation)
     * // Updates the coordinates of the truck's location asynchronously.
     * @param {FoodTruck} truck - The food truck object whose coordinates need correction.
     * @param {Partial&lt;FoodTruck['current_location']&gt;} updates - The latitude and longitude updates to be applied.
     * @param {boolean} dryRun - Flag to simulate the update without altering data.
     * @param {CleanupOperation} operation - The cleanup operation instance used for error tracking.
     * @returns {Promise&lt;void&gt;} Resolves when the coordinate update process is complete.
     * @description
     *   - Executes the update operation only if the dryRun flag is false.
     *   - If the update fails, logs the error details into the operation's error array.
     */
    private static applyCoordinateFixUpdate;
    /**
     * Update quality scores for all trucks
     */
    private static updateQualityScores;
    /**
    * Processes a single food truck for an updated quality score assessment.
    * @example
    * processSingleTruckForQualityScore(truckInstance, false, cleanupOperationInstance)
    * // No return value
    * @param {FoodTruck} truck - The food truck instance to assess and potentially update.
    * @param {boolean} dryRun - Specifies whether this is a dry run (no actual data updates).
    * @param {CleanupOperation} operation - The cleanup operation context for processing.
    * @returns {Promise&lt;void&gt;} No return value; operation is performed asynchronously.
    * @description
    *   - Computes the quality score using data from DataQualityService.
    *   - Updates the quality score only if the score changes significantly (&gt;5% difference).
    *   - Assumes `truck.data_quality_score` might be undefined, defaulting to 0.
    *   - Handles asynchronous processing of the update application if conditions are met.
    */
    private static processSingleTruckForQualityScore;
    /**
     * Updates the quality score of a specified food truck and handles errors during the update process.
     * @example
     * applyQualityScoreUpdate(foodTruckInstance, false, cleanupOperationInstance)
     * void
     * @param {FoodTruck} truck - The food truck for which the quality score will be updated.
     * @param {boolean} dryRun - Flag indicating whether the function should perform the update or just simulate it.
     * @param {CleanupOperation} operation - The cleanup operation containing possible error records.
     * @returns {Promise&lt;void&gt;} Resolves with no value when the update completes. Errors are recorded in the `operation` if thrown.
     * @description
     *   - Throws an error if the quality score update fails.
     *   - If `dryRun` is true, the function simulates the update without changing any data.
     *   - Errors occurring during the update are appended to the `operation.errors` array.
     */
    private static applyQualityScoreUpdate;
    /**
     * Identify and merge duplicate trucks
     */
    private static mergeDuplicates;
    /**
     * Processes a single food truck to detect and handle duplicates in the dataset.
     * @example
     * processSingleTruckForDuplicates(foodTruck, true, mergeContext)
     * // No return value. Performs operations as a side effect.
     * @param {FoodTruck} truck - An instance of FoodTruck to process for duplicates.
     * @param {boolean} dryRun - Flag indicating if the operation should be executed in dry run mode.
     * @param {MergeOperationContext} context - Operational context that carries state and configurations for the merge operation.
     * @returns {Promise&lt;void&gt;} Executes a set of operations for handling duplicate records, does not return any value.
     * @description
     *   - Ensures a food truck is only processed once by maintaining a set of processed IDs.
     *   - Uses DuplicatePreventionService to assess whether the given truck is a duplicate.
     *   - Applies a merge operation if a duplicate truck is confidently identified.
     */
    private static processSingleTruckForDuplicates;
    /**
     * Applies a merge operation between two food trucks and updates the context.
     * @example
     * applyMergeOperation(truck, existingTruck, true, context)
     * // Executes a dry run of the merge operation without affecting data
     * @param {FoodTruck} truck - The food truck that is being merged.
     * @param {FoodTruck} existingTruck - The existing food truck to merge with.
     * @param {boolean} dryRun - Indicates if the merge operation should be simulated.
     * @param {MergeOperationContext} context - Context containing details and state of the merge operation.
     * @returns {Promise&lt;void&gt;} Promise representing the completion of the merge operation.
     * @description
     *   - Updates the list of processed IDs in the context upon successful merge.
     *   - Throws and records an error if the merge operation fails.
     *   - Utilizes the DuplicatePreventionService for performing the merge.
     */
    private static applyMergeOperation;
    /**
     * Normalize phone number format
     */
    private static normalizePhone;
    /**
     * Get operation description
     */
    private static getOperationDescription;
    /**
     * Calculate cleanup summary
     */
    private static calculateSummary;
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/types.ts (Line 20:1 - Line 150:44), C:/AI/food-truck-finder-poc/dist/lib/lib/types.d.ts (Line 19:1 - Line 138:8)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn526" onclick="toggleCodeBlock('cloneGroup526', 'expandBtn526', 'collapseBtn526')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn526" onclick="toggleCodeBlock('cloneGroup526', 'expandBtn526', 'collapseBtn526')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup526"><code class="language-typescript text-sm text-gray-800">}

export interface MenuCategory {
  name: string;
  items: MenuItem[];
}

export interface MenuItem {
  name: string;
  description: string | undefined;
  price: number | string | undefined;
  dietary_tags: string[];
  is_popular?: boolean;
}

export interface UserCoordinates {
  lat: number;
  lng: number;
}

export interface LocationData {
  address: string | undefined;
  city: string | undefined;
  state: string | undefined;
  landmarks: string[];
  coordinates: UserCoordinates;
  confidence: number;
  raw_location_text: string | undefined;
}





export interface ExtractedFoodTruckDetails {
  name: string | undefined;
  description: string | undefined;
  cuisine_type: string[];
  price_range: PriceRange | undefined;
  specialties: string[];
  current_location: {
    address: string | undefined;
    city: string | undefined;
    state: string | undefined;
    zip_code: string | undefined;
    lat?: number;
    lng?: number;
    raw_text: string | undefined;
  };
  scheduled_locations?: {
    address?: string;
    city?: string;
    state?: string;
    zip_code?: string;
    lat?: number;
    lng?: number;
    timestamp: string;
    start_time: string;
    end_time: string;
  }[];
  operating_hours: OperatingHours;
  menu: MenuCategory[];
  contact_info: {
    phone?: string;
    email?: string;
    website?: string;
  };
  social_media: {
    instagram?: string;
    facebook?: string;
    twitter?: string;
    tiktok?: string;
    yelp?: string;
  };
  source_url: string;
}

export interface FirecrawlOutputData {
  markdown: string;
  name?: string;
  source_url?: string;
}

export interface FoodTruckSchema {
  name: string;
  description: string | undefined;
  current_location: {
    lat: number;
    lng: number;
    address: string | undefined;
    timestamp: string;
  };
  scheduled_locations: ExtractedFoodTruckDetails['scheduled_locations'];
  operating_hours: OperatingHours;
  menu: MenuCategory[];
  contact_info: {
    phone?: string;
    email?: string;
    website?: string;
  };
  social_media: {
    instagram?: string;
    facebook?: string;
    twitter?: string;
    tiktok?: string;
    yelp?: string;
  };
  cuisine_type: string[];
  price_range: PriceRange | undefined;
  specialties: string[];
  data_quality_score: number;
  verification_status: 'pending' | 'verified' | 'flagged';
  source_urls: string[];
  last_scraped_at: string;
  test_run_flag?: boolean;
  website?: string;
  phone_number?: string;
  email?: string;
  instagram_handle?: string;
  facebook_handle?: string;
  twitter_handle?: string;
  schedule?: unknown[];
  average_rating?: number;
  review_count?: number;
}

export interface FoodTruck extends FoodTruckSchema {
  id: string;
  created_at: string;
  updated_at: string;
  last_updated_at?: string; // Alternative field name for compatibility</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/types.ts (Line 153:3 - Line 176:2), C:/AI/food-truck-finder-poc/dist/lib/lib/types.d.ts (Line 140:5 - Line 163:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn527" onclick="toggleCodeBlock('cloneGroup527', 'expandBtn527', 'collapseBtn527')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn527" onclick="toggleCodeBlock('cloneGroup527', 'expandBtn527', 'collapseBtn527')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup527"><code class="language-typescript text-sm text-gray-800">is_active?: boolean;
  image_url?: string;
  average_rating?: number;
  review_count?: number;
  exact_location?: any;
  city_location?: any;
}

export interface GeminiResponse&lt;T = unknown&gt; {
  success: boolean;
  data?: T;
  tokensUsed?: number;
  error?: string;
  promptSent?: string;
}

export interface StageResult {
  status: string;
  data?: FirecrawlOutputData | ExtractedFoodTruckDetails | FoodTruckSchema;
  error?: string;
  details?: string;
  prompt?: string;
  tokensUsed?: number;
  metadata?: { name?: string; source_url?: string }</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/types.ts (Line 176:2 - Line 243:56), C:/AI/food-truck-finder-poc/dist/lib/lib/types.d.ts (Line 164:5 - Line 226:8)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn528" onclick="toggleCodeBlock('cloneGroup528', 'expandBtn528', 'collapseBtn528')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn528" onclick="toggleCodeBlock('cloneGroup528', 'expandBtn528', 'collapseBtn528')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup528"><code class="language-typescript text-sm text-gray-800">};
  rawContent?: string;
  preparedData?: FoodTruckSchema;
  recordId?: string;
}

export interface TestPipelineResults {
  firecrawl?: StageResult;
  gemini?: StageResult;
  supabase?: StageResult;
  overallStatus?: string;
  logs?: string[];
  error?: string;
}

export interface PipelineRunResult {
  firecrawl?: StageResult;
  gemini?: StageResult;
  supabase?: StageResult;
  logs: string[];
  overallStatus: 'Success' | 'Error';
}

export interface ScrapingJob {
  id: string;
  job_type: string;
  target_url?: string;
  target_handle?: string;
  platform?: string;
  status: 'pending' | 'running' | 'completed' | 'failed';
  priority: number;
  scheduled_at: string;
  started_at?: string;
  completed_at?: string;
  data_collected?: Record&lt;string, unknown&gt;;
  errors?: string[];
  retry_count: number;
  max_retries: number;
  created_at: string;
}

export interface RealtimeMetrics {
  scrapingJobs: {
    active: number;
    completed: number;
    failed: number;
    pending: number;
  };
  dataQuality: {
    averageScore: number;
    totalTrucks: number;
    recentChanges: number;
  };
  systemHealth: {
    status: 'healthy' | 'warning' | 'error';
    uptime: number;
    lastUpdate: string;
  };
}

export interface TruckRating {
  id: number;
  title: string;
  score: number;
}

export interface PipelineEvent {
  type: string; // e.g., 'job_started', 'job_completed', 'data_updated'</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/types.ts (Line 245:3 - Line 279:63), C:/AI/food-truck-finder-poc/dist/lib/lib/types.d.ts (Line 227:5 - Line 258:7)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn529" onclick="toggleCodeBlock('cloneGroup529', 'expandBtn529', 'collapseBtn529')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn529" onclick="toggleCodeBlock('cloneGroup529', 'expandBtn529', 'collapseBtn529')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup529"><code class="language-typescript text-sm text-gray-800">timestamp: string;
}

export interface SentimentAnalysisResult {
  sentiment: 'positive' | 'negative' | 'neutral';
  score: number;
  confidence: number;
  key_topics: string[];
  positive_aspects: string[];
  negative_aspects: string[];
  summary: string;
  recommended: boolean;
}

export interface EnhancedFoodTruckData {
  name: string | undefined;
  description: string | undefined;
  cuisine_type: string[];
  price_range: PriceRange;
  specialties: string[];
  dietary_options: string[];
  enhanced_menu: {
    categories: MenuCategory[];
  };
  standardized_hours: OperatingHours;
  cleaned_contact: {
    phone: string | undefined;
    email: string | undefined;
    website: string | undefined;
  };
  data_quality_improvements: string[];
  confidence_score: number;
}

// Additional types needed by various parts of the application</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/types.ts (Line 280:1 - Line 344:59), C:/AI/food-truck-finder-poc/dist/lib/lib/types.d.ts (Line 258:1 - Line 313:7)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn530" onclick="toggleCodeBlock('cloneGroup530', 'expandBtn530', 'collapseBtn530')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn530" onclick="toggleCodeBlock('cloneGroup530', 'expandBtn530', 'collapseBtn530')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup530"><code class="language-typescript text-sm text-gray-800">export interface DataProcessingQueue {
  id: string;
  truck_id?: string;
  processing_type: string;
  raw_data: Record&lt;string, unknown&gt;;
  processed_data?: Record&lt;string, unknown&gt;;
  gemini_tokens_used: number;
  status: 'pending' | 'processing' | 'completed' | 'failed';
  priority: number;
  created_at: string;
  processed_at?: string;
}

export interface ApiUsage {
  id: string;
  service_name: string;
  usage_date: string;
  requests_count: number;
  tokens_used: number;
}

export interface QualityCategory {
  name: string;
  score: number;
  issues: string[];
}

export interface SystemAlert {
  id: string;
  type: string;
  message: string;
  timestamp: string;
  severity: 'low' | 'medium' | 'high' | 'critical';
}

export interface RealtimeAdminEvent {
  type: string;
  payload: Record&lt;string, unknown&gt;;
  timestamp: string;
}

export interface FoodTruckWithRatings extends FoodTruck {
  ratings?: TruckRating[];
}

export interface SecurityEvent {
  event_type: string;
  severity: 'low' | 'medium' | 'high' | 'critical';
  timestamp: string;
  details: Record&lt;string, unknown&gt;;
}

export interface APIService {
  name: string;
  endpoint: string;
  status: 'active' | 'inactive';
}

export interface Database {
  public: {
    tables: Record&lt;string, unknown&gt;;
  };
}

// Type aliases to replace namespace-style property access</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/types.ts (Line 346:2 - Line 373:52), C:/AI/food-truck-finder-poc/dist/lib/lib/types.d.ts (Line 313:2 - Line 333:7)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn531" onclick="toggleCodeBlock('cloneGroup531', 'expandBtn531', 'collapseBtn531')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn531" onclick="toggleCodeBlock('cloneGroup531', 'expandBtn531', 'collapseBtn531')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup531"><code class="language-typescript text-sm text-gray-800">'normalize_phone'
  | 'fix_coordinates'
  | 'remove_placeholders'
  | 'update_quality_scores'
  | 'merge_duplicates';

export interface CleanupOperation {
  type: CleanupOperationType;
  description: string;
  affectedCount: number;
  successCount: number;
  errorCount: number;
  errors: string[];
}

export interface BatchCleanupResult {
  totalProcessed: number;
  operations: CleanupOperation[];
  summary: {
    trucksImproved: number;
    duplicatesRemoved: number;
    qualityScoreImprovement: number;
    placeholdersRemoved: number;
  };
  duration: number;
}

// Request/Response types for various API endpoints</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/types.ts (Line 374:1 - Line 409:22), C:/AI/food-truck-finder-poc/dist/api/admin/data-cleanup/handlers.d.ts (Line 2:1 - Line 363:7)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn532" onclick="toggleCodeBlock('cloneGroup532', 'expandBtn532', 'collapseBtn532')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn532" onclick="toggleCodeBlock('cloneGroup532', 'expandBtn532', 'collapseBtn532')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup532"><code class="language-typescript text-sm text-gray-800">export interface DataCleanupRequestBody {
  action: string;
  options?: {
    batchSize?: number;
    dryRun?: boolean;
    operations?: string[];
    truckData?: Record&lt;string, unknown&gt;;
    targetId?: string;
    sourceId?: string;
  };
}

export interface FirecrawlRequestBody {
  url: string;
  extractorOptions?: Record&lt;string, unknown&gt;;
}

export interface TavilyRequestBody {
  query: string;
  searchDepth?: 'basic' | 'advanced';
  includeImages?: boolean;
  includeAnswer?: boolean;
  maxResults?: number;
}

export interface PostRequestBody {
  action: string;
  data?: Record&lt;string, unknown&gt;;
}

export interface PutRequestBody {
  id: string;
  updates: Record&lt;string, unknown&gt;;
}

// UI Component Types</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/types.ts (Line 410:1 - Line 433:24), C:/AI/food-truck-finder-poc/dist/lib/lib/types.d.ts (Line 363:1 - Line 382:7)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn533" onclick="toggleCodeBlock('cloneGroup533', 'expandBtn533', 'collapseBtn533')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn533" onclick="toggleCodeBlock('cloneGroup533', 'expandBtn533', 'collapseBtn533')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup533"><code class="language-typescript text-sm text-gray-800">export interface ButtonProps {
  variant?: 'default' | 'destructive' | 'outline' | 'secondary' | 'ghost' | 'link';
  size?: 'default' | 'sm' | 'lg' | 'icon';
  asChild?: boolean;
}

export interface ToasterToast {
  id: string;
  title?: string;
  description?: string;
  action?: ReactElement;
  variant?: 'default' | 'destructive';
}

export interface ToastComponentProps {
  toast: ToasterToast;
}

export interface ToastActionElement {
  altText: string;
  element: ReactElement;
}

// Generic Result types</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/types.ts (Line 434:1 - Line 457:2), C:/AI/food-truck-finder-poc/dist/lib/lib/types.d.ts (Line 382:1 - Line 403:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn534" onclick="toggleCodeBlock('cloneGroup534', 'expandBtn534', 'collapseBtn534')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn534" onclick="toggleCodeBlock('cloneGroup534', 'expandBtn534', 'collapseBtn534')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup534"><code class="language-typescript text-sm text-gray-800">export interface CleanupResult {
  success: boolean;
  totalProcessed: number;
  operations: CleanupOperation[];
  summary: {
    trucksImproved: number;
    duplicatesRemoved: number;
    qualityScoreImprovement: number;
    placeholdersRemoved: number;
  };
  duration: number;
  error?: string;
}

export interface RequestBody {
  action: string;
  options?: Record&lt;string, unknown&gt;;
}

export interface FirecrawlResponse {
  success: boolean;
  data?: Record&lt;string, unknown&gt;;
  error?: string;
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/ScraperEngine.ts (Line 25:2 - Line 83:2), C:/AI/food-truck-finder-poc/dist/lib/lib/ScraperEngine.d.ts (Line 30:5 - Line 82:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn536" onclick="toggleCodeBlock('cloneGroup536', 'expandBtn536', 'collapseBtn536')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn536" onclick="toggleCodeBlock('cloneGroup536', 'expandBtn536', 'collapseBtn536')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup536"><code class="language-typescript text-sm text-gray-800">};
  comments: number;
}

interface FacebookPageInfo {
  likes: number;
  followers: number;
  check_ins: number;
  about: string;
  hours: Record&lt;string, string&gt;;
}

interface TwitterTweet {
  id: string;
  text: string;
  timestamp: string;
  retweets: number;
  likes: number;
  replies: number;
  location: string;
}

interface TwitterProfile {
  followers: number;
  following: number;
  tweets_count: number;
  bio: string;
  location: string;
  website: string;
}

interface InstagramData {
  posts: InstagramPost[];
  profile: InstagramProfile;
}

interface FacebookData {
  posts: FacebookPost[];
  page_info: FacebookPageInfo;
}

interface TwitterData {
  tweets: TwitterTweet[];
  profile: TwitterProfile;
}

export interface WebsiteScrapeData {
  markdown?: string;
  html?: string;
  metadata?: Record&lt;string, unknown&gt;;
  is_fallback?: boolean;
}

export interface ExtractedHTMLData {
  name?: string;
  location?: string;
  phone?: string;
  hours?: string;
  menu?: { item: string; price: string }</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/ScraperEngine.ts (Line 376:1 - Line 420:6), C:/AI/food-truck-finder-poc/dist/lib/lib/ScraperEngine.d.ts (Line 108:1 - Line 145:8)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn537" onclick="toggleCodeBlock('cloneGroup537', 'expandBtn537', 'collapseBtn537')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn537" onclick="toggleCodeBlock('cloneGroup537', 'expandBtn537', 'collapseBtn537')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup537"><code class="language-typescript text-sm text-gray-800">}

interface LocationData {
  current?: {
    lat?: number;
    lng?: number;
    address?: string;
  };
}

interface ContactInfo {
  phone?: string;
  email?: string;
}

interface OperatingHours {
  [key: string]: {
    open: string;
    close: string;
    closed: boolean;
  };
}

interface MenuItem {
  name: string;
  description?: string;
  price: number;
  dietary_tags?: string[];
}

interface MenuCategory {
  category: string;
  items: MenuItem[];
}

interface TruckData {
  name: string;
  location: LocationData;
  contact?: ContactInfo;
  operating_hours?: OperatingHours;
  menu?: MenuCategory[];
  last_updated?: string;
}

export class</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/ScraperEngine.ts (Line 582:1 - Line 596:2), C:/AI/food-truck-finder-poc/dist/lib/lib/ScraperEngine.d.ts (Line 161:1 - Line 176:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn538" onclick="toggleCodeBlock('cloneGroup538', 'expandBtn538', 'collapseBtn538')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn538" onclick="toggleCodeBlock('cloneGroup538', 'expandBtn538', 'collapseBtn538')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup538"><code class="language-typescript text-sm text-gray-800">}

interface GeminiLocationData {
  address: string;
  city: string;
  state: string;
  coordinates: {
    lat?: number;
    lng?: number;
  };
  confidence: number;
}

interface GeminiOperatingHours {
  monday: { open: string; close: string; closed: boolean }</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/ScraperEngine.ts (Line 793:8 - Line 799:36), C:/AI/food-truck-finder-poc/lib/ScraperEngine.ts (Line 758:8 - Line 764:32)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn539" onclick="toggleCodeBlock('cloneGroup539', 'expandBtn539', 'collapseBtn539')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn539" onclick="toggleCodeBlock('cloneGroup539', 'expandBtn539', 'collapseBtn539')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup539"><code class="language-typescript text-sm text-gray-800">;

      const response = await this.makeGeminiRequest(prompt);
      this.updateUsageCounters(1, prompt.length + response.length);
      const parsed: unknown = JSON.parse(response);
      if (parsed == undefined || typeof parsed !== 'object') {
        throw new Error('Invalid Gemini sentiment response'</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/scheduler.ts (Line 179:1 - Line 211:2), C:/AI/food-truck-finder-poc/dist/lib/lib/scheduler.d.ts (Line 16:1 - Line 43:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn541" onclick="toggleCodeBlock('cloneGroup541', 'expandBtn541', 'collapseBtn541')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn541" onclick="toggleCodeBlock('cloneGroup541', 'expandBtn541', 'collapseBtn541')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup541"><code class="language-typescript text-sm text-gray-800">}

interface ScheduledTask {
  id: string;
  name: string;
  description: string;
  intervalMinutes: number;
  enabled: boolean;
  execute: () =&gt; Promise&lt;void&gt;;
  lastRun?: string;
  lastSuccess?: string;
  successCount: number;
  errorCount: number;
  lastError?: string;
}

interface TaskStatus {
  id: string;
  name: string;
  enabled: boolean;
  intervalMinutes: number;
  lastRun?: string;
  lastSuccess?: string;
  successCount: number;
  errorCount: number;
  lastError?: string;
  nextRun?: string;
}

interface ScraperEngine {
  scrapeSocialMedia: (
    platform: string,
    handle: string,</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/scheduler.ts (Line 220:2 - Line 229:2), C:/AI/food-truck-finder-poc/dist/lib/lib/scheduler.d.ts (Line 59:5 - Line 69:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn542" onclick="toggleCodeBlock('cloneGroup542', 'expandBtn542', 'collapseBtn542')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn542" onclick="toggleCodeBlock('cloneGroup542', 'expandBtn542', 'collapseBtn542')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup542"><code class="language-typescript text-sm text-gray-800">};
  processMenuData: (content: string) =&gt; Promise&lt;unknown&gt;;
  extractLocationFromText: (content: string) =&gt; Promise&lt;unknown&gt;;
  standardizeOperatingHours: (content: string) =&gt; Promise&lt;unknown&gt;;
  analyzeSentiment: (content: string) =&gt; Promise&lt;unknown&gt;;
  enhanceFoodTruckData: (data: unknown) =&gt; Promise&lt;unknown&gt;;
}

interface DataQualityAssessor {
  assessTruckData: (truck: FoodTruck) =&gt; { score: number; issues: string[] }</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/scheduler.ts (Line 229:2 - Line 248:63), C:/AI/food-truck-finder-poc/dist/lib/lib/scheduler.d.ts (Line 70:5 - Line 89:17)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn543" onclick="toggleCodeBlock('cloneGroup543', 'expandBtn543', 'collapseBtn543')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn543" onclick="toggleCodeBlock('cloneGroup543', 'expandBtn543', 'collapseBtn543')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup543"><code class="language-typescript text-sm text-gray-800">};
}

interface FoodTruck {
  id: string;
  name: string;
  contact_info: {
    phone?: string;
    email?: string;
    website?: string;
  };
  social_media: {
    instagram_handle?: string;
    facebook_handle?: string;
    twitter_handle?: string;
  };
  cuisine_type: string;
  price_range?: string;
  specialties: string[];
  menu: unknown; // This should be more specific, but for now, keeping it broad</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/pipelineManager.ts (Line 10:1 - Line 34:21), C:/AI/food-truck-finder-poc/dist/lib/lib/pipelineManager.d.ts (Line 1:1 - Line 22:7)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn545" onclick="toggleCodeBlock('cloneGroup545', 'expandBtn545', 'collapseBtn545')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn545" onclick="toggleCodeBlock('cloneGroup545', 'expandBtn545', 'collapseBtn545')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup545"><code class="language-typescript text-sm text-gray-800">export interface PipelineConfig {
  type: 'discovery' | 'processing' | 'full' | 'maintenance';
  params: {
    maxUrls?: number;
    maxUrlsToProcess?: number;
    targetCities?: string[];
    priority?: number;
    skipDiscovery?: boolean;
    retryFailedJobs?: boolean;
  };
}

export interface DiscoveryParams {
  cities: string[];
  maxUrls: number;
  searchTerms?: string[];
}

export interface ProcessingOptions {
  maxJobs: number;
  priority: number;
  retryFailedJobs: boolean;
}

// Result interfaces</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/pipelineManager.ts (Line 35:1 - Line 86:4), C:/AI/food-truck-finder-poc/dist/lib/lib/pipelineManager.d.ts (Line 22:1 - Line 69:4)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn546" onclick="toggleCodeBlock('cloneGroup546', 'expandBtn546', 'collapseBtn546')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn546" onclick="toggleCodeBlock('cloneGroup546', 'expandBtn546', 'collapseBtn546')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup546"><code class="language-typescript text-sm text-gray-800">export interface PipelineResult {
  success: boolean;
  type: string;
  phase: string;
  summary: {
    urlsDiscovered?: number;
    urlsProcessed?: number;
    jobsCreated?: number;
    trucksCreated?: number;
    errors?: number;
    duration: number;
  };
  details: unknown;
  timestamp: string;
}

export interface DiscoveryResult {
  success: boolean;
  urlsDiscovered: number;
  urlsStored: number;
  urlsDuplicate: number;
  errors: string[];
  duration: number;
}

export interface ProcessingResult {
  success: boolean;
  jobsProcessed: number;
  jobsSuccessful: number;
  jobsFailed: number;
  trucksCreated: number;
  errors: string[];
  duration: number;
}

export interface MaintenanceResult {
  success: boolean;
  trucksProcessed: number;
  newTrucksFound: number;
  errors: string[];
  duration: number;
}

/**
 * Unified Pipeline Manager
 *
 * Consolidates all pipeline operations into a single, modular system:
 * - Discovery: Find new food truck URLs using Tavily
 * - Processing: Process URLs through Firecrawl + Gemini pipeline
 * - Full: Combined discovery + processing
 * - Maintenance: Check existing trucks for stale data
 */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/firecrawl.ts (Line 1:1 - Line 41:10), C:/AI/food-truck-finder-poc/dist/lib/lib/firecrawl.d.ts (Line 1:1 - Line 37:7)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn572" onclick="toggleCodeBlock('cloneGroup572', 'expandBtn572', 'collapseBtn572')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn572" onclick="toggleCodeBlock('cloneGroup572', 'expandBtn572', 'collapseBtn572')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup572"><code class="language-typescript text-sm text-gray-800">export interface FirecrawlResponse {
  success: boolean;
  data?: {
    markdown?: string;
    html?: string;
    metadata?: {
      title?: string;
      description?: string;
      language?: string;
      sourceURL?: string;
    };
    links?: string[];
  };
  error?: string;
}

interface CrawlJobResponse {
  success: boolean;
  jobId?: string;
  error?: string;
}

interface ScrapedMetadata {
  title?: string;
  description?: string;
  language?: string;
  sourceURL?: string;
}

interface CrawlStatusResponse {
  success: boolean;
  status?: 'scraping' | 'completed' | 'failed';
  data?: Array&lt;{
    markdown?: string;
    html?: string;
    metadata?: ScrapedMetadata;
  }&gt;;
  error?: string;
}

interface</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/firecrawl.ts (Line 198:8 - Line 209:2), C:/AI/food-truck-finder-poc/dist/lib/lib/firecrawl.d.ts (Line 101:2 - Line 112:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn573" onclick="toggleCodeBlock('cloneGroup573', 'expandBtn573', 'collapseBtn573')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn573" onclick="toggleCodeBlock('cloneGroup573', 'expandBtn573', 'collapseBtn573')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup573"><code class="language-typescript text-sm text-gray-800">: {
      crawlerOptions?: {
        includes?: string[];
        excludes?: string[];
        maxDepth?: number;
        limit?: number;
      };
      pageOptions?: {
        formats?: ('markdown' | 'html')[];
        onlyMainContent?: boolean;
      };
    } =</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/firecrawl.ts (Line 235:2 - Line 247:17), C:/AI/food-truck-finder-poc/lib/firecrawl.ts (Line 152:2 - Line 164:18)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn574" onclick="toggleCodeBlock('cloneGroup574', 'expandBtn574', 'collapseBtn574')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn574" onclick="toggleCodeBlock('cloneGroup574', 'expandBtn574', 'collapseBtn574')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup574"><code class="language-typescript text-sm text-gray-800">,
        }),
      });

      const data: unknown = await response.json();

      if (!response.ok) {
        const errorData = data as { error?: string };
        throw new Error(errorData.error ?? `HTTP ${response.status}`);
      }

      this.setCacheResult(cacheKey, data);
      return data as CrawlJobResponse</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/firecrawl.ts (Line 281:2 - Line 292:20), C:/AI/food-truck-finder-poc/lib/firecrawl.ts (Line 153:2 - Line 164:18)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn575" onclick="toggleCodeBlock('cloneGroup575', 'expandBtn575', 'collapseBtn575')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn575" onclick="toggleCodeBlock('cloneGroup575', 'expandBtn575', 'collapseBtn575')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup575"><code class="language-typescript text-sm text-gray-800">,
      });

      const data: unknown = await response.json();

      if (!response.ok) {
        const errorData = data as { error?: string };
        throw new Error(errorData.error ?? `HTTP ${response.status}`);
      }

      this.setCacheResult(cacheKey, data);
      return data as CrawlStatusResponse</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/discoveryEngine.ts (Line 5:1 - Line 35:4), C:/AI/food-truck-finder-poc/dist/lib/lib/discoveryEngine.d.ts (Line 1:1 - Line 29:4)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn577" onclick="toggleCodeBlock('cloneGroup577', 'expandBtn577', 'collapseBtn577')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn577" onclick="toggleCodeBlock('cloneGroup577', 'expandBtn577', 'collapseBtn577')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup577"><code class="language-typescript text-sm text-gray-800">export interface DiscoveredUrl {
  url: string;
  source_directory_url?: string;
  region?: string;
  status: 'new' | 'processing' | 'processed' | 'irrelevant';
  notes?: string;
}

export interface DiscoveryResult {
  urls_discovered: number;
  urls_stored: number;
  urls_duplicates: number;
  errors: string[];
}

/**
 * Autonomous Discovery Engine
 *
 * This engine discovers new food truck websites across South Carolina using Tavily for search
 * and Firecrawl for crawling. It operates autonomously without human intervention, finding and
 * validating new URLs to add to the discovered_urls table for subsequent scraping.
 *
 * Strategy:
 * 1. Search for food trucks in each SC city using Tavily search
 * 2. Find food truck directories and event listings using Firecrawl crawling
 * 3. Extract individual food truck website URLs from discovered content
 * 4. Validate and filter URLs to avoid false positives
 * 5. Store new URLs in discovered_urls table for processing
 *
 * NOTE: Uses Tavily for search operations and Firecrawl for crawling/scraping
 */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/discoveryEngine.ts (Line 374:14 - Line 389:65), C:/AI/food-truck-finder-poc/lib/discoveryEngine.ts (Line 294:13 - Line 309:56)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn578" onclick="toggleCodeBlock('cloneGroup578', 'expandBtn578', 'collapseBtn578')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn578" onclick="toggleCodeBlock('cloneGroup578', 'expandBtn578', 'collapseBtn578')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup578"><code class="language-typescript text-sm text-gray-800">) {
        if (typeof result === 'object' &amp;&amp; result !== null &amp;&amp; 'url' in result) {
          const resultUrl = (result as { url?: string }).url;
          if (
            resultUrl != undefined &amp;&amp;
            typeof resultUrl === 'string' &amp;&amp;
            (await this.isFoodTruckUrl(resultUrl))
          ) {
            discoveredUrls.add(resultUrl);
          }
        }
      }
    }
  }

  // Helper method to store discovered URLs from discovery process</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/discoveryEngine.ts (Line 644:2 - Line 652:8), C:/AI/food-truck-finder-poc/lib/discoveryEngine.ts (Line 347:15 - Line 354:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn579" onclick="toggleCodeBlock('cloneGroup579', 'expandBtn579', 'collapseBtn579')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn579" onclick="toggleCodeBlock('cloneGroup579', 'expandBtn579', 'collapseBtn579')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup579"><code class="language-typescript text-sm text-gray-800">);
    } catch (error) {
      console.error(` Location search failed for ${city}:`, error);
      results.errors.push(
        `Location search failed for ${city}: ${error instanceof Error ? error.message : 'Unknown error'}`,
      );
    }

    console</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/discoveryEngine.ts (Line 767:6 - Line 783:8), C:/AI/food-truck-finder-poc/lib/discoveryEngine.ts (Line 411:2 - Line 439:5)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn580" onclick="toggleCodeBlock('cloneGroup580', 'expandBtn580', 'collapseBtn580')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn580" onclick="toggleCodeBlock('cloneGroup580', 'expandBtn580', 'collapseBtn580')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup580"><code class="language-typescript text-sm text-gray-800">,
        });
        if (stored.isNew === true) {
          results.urls_stored += 1;
        } else {
          results.urls_duplicates += 1;
        }
      } catch (error) {
        console.error(` Failed to store URL ${url}:`, error);
        results.errors.push(
          `Failed to store URL ${url}: ${error instanceof Error ? error.message : 'Unknown error'}`,
        );
      }
    }
  }

  private</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/autoScraper.ts (Line 77:1 - Line 125:3), C:/AI/food-truck-finder-poc/dist/lib/lib/autoScraper.d.ts (Line 52:1 - Line 72:4)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn601" onclick="toggleCodeBlock('cloneGroup601', 'expandBtn601', 'collapseBtn601')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn601" onclick="toggleCodeBlock('cloneGroup601', 'expandBtn601', 'collapseBtn601')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup601"><code class="language-typescript text-sm text-gray-800">}

interface GeminiService {
  checkUsageLimits(): Promise&lt;GeminiUsageLimits&gt;;
  processMenuData(input: unknown): Promise&lt;ProcessedMenuData&gt;;
  extractLocationFromText(input: unknown): Promise&lt;ExtractedLocationData&gt;;
  standardizeOperatingHours(input: unknown): Promise&lt;StandardizedOperatingHours&gt;;
  analyzeSentiment(input: unknown): Promise&lt;SentimentAnalysisResult&gt;;
  enhanceFoodTruckData(input: unknown): Promise&lt;EnhancedFoodTruckData&gt;;
}

/*
Food Truck Scraping Strategy (wbs 2.1.2)
----------------------------------------
Goal: Extract structured data for food trucks (description, menu, prices, locations, events) from web sources.

1. Discovery:
   - Use internal API endpoints that leverage Tavily MCP tools to find food truck directories and individual truck sites.
   - Filter urls to target only likely food truck homepages or menu/schedule pages.

2. Content Extraction:
   - For each truck site, extract:
     - Description: Look for about/landing page text, business summary, or meta description.
     - Menu: Scrape menu sections, parse categories, items, prices, and dietary tags.
     - Prices: Extract explicit prices as numbers; fallback to price range if only text is available.
     - Locations: Parse current and scheduled locations, addresses, and geocoordinates if present.
     - Events: Identify event/calendar/schedule sections for upcoming appearances.

3. Data Mapping:
   - Map extracted fields to Supabase schema:
     - name, description, cuisine_type, specialties
     - menu (categories/items/prices/dietary_tags)
     - current_location, scheduled_locations, exact_location, city_location
     - events (future: event table)

4. Quality &amp; Validation:
   - Use Gemini to summarize/clean descriptions and standardize menu/locations.
   - Validate extracted data types and required fields before db insert.
   - Log and skip/flag incomplete or ambiguous records for review.

5. Ingestion:
   - Upsert into Supabase using unique identifier (e.g., website url or business name).
   - Avoid duplicates and resolve conflicts by preferring most recent or most complete data.

6. Automation:
   - Schedule regular crawls and re-scrapes.
   - Track api usage and cache results to stay within rate limits.
   - Monitor for site changes and trigger updates as needed.
*/</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/autoScraper.ts (Line 227:22 - Line 233:3), C:/AI/food-truck-finder-poc/lib/autoScraper.ts (Line 180:27 - Line 186:7)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn602" onclick="toggleCodeBlock('cloneGroup602', 'expandBtn602', 'collapseBtn602')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn602" onclick="toggleCodeBlock('cloneGroup602', 'expandBtn602', 'collapseBtn602')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup602"><code class="language-typescript text-sm text-gray-800">(
  url: string,
  result: { status: string; details?: string },
  counters: { trucksProcessed: number; newTrucksFound: number },
  errors: Array&lt;{ url: string; details?: string }&gt;,
): Promise&lt;void&gt; {
  if</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/hooks/useAuthHandlers.ts (Line 5:1 - Line 36:4), C:/AI/food-truck-finder-poc/dist/lib/hooks/useAuthHandlers.d.ts (Line 1:1 - Line 31:4)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn613" onclick="toggleCodeBlock('cloneGroup613', 'expandBtn613', 'collapseBtn613')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn613" onclick="toggleCodeBlock('cloneGroup613', 'expandBtn613', 'collapseBtn613')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup613"><code class="language-typescript text-sm text-gray-800">interface UseAuthHandlersReturn {
  handleEmailLogin: (e: React.FormEvent) =&gt; Promise&lt;void&gt;;
  handleGoogleLogin: () =&gt; Promise&lt;void&gt;;
  loading: boolean;
  error: string | undefined;
  email: string;
  setEmail: (email: string) =&gt; void;
  password: string;
  setPassword: (password: string) =&gt; void;
}

/**
 * Provides authentication handlers for email and Google login.
 * @example
 * useAuthHandlers('/dashboard')
 * {
 *   handleEmailLogin: [Function],
 *   handleGoogleLogin: [Function],
 *   loading: false,
 *   error: undefined,
 *   email: '',
 *   setEmail: [Function],
 *   password: '',
 *   setPassword: [Function],
 * }
 * @param {string} redirectTo - URL to redirect upon successful login.
 * @returns {UseAuthHandlersReturn} Contains handlers and state variables related to authentication.
 * @description
 *   - Employs Supabase for authentication tasks.
 *   - Utilizes React's `useState` hook for managing local component state.
 *   - Customizes redirection based on user role retrieved from the 'profiles' table.
 */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/types.d.ts (Line 1:1 - Line 143:2), C:/AI/food-truck-finder-poc/dist/lib/lib/types.d.ts (Line 2:1 - Line 144:15)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn614" onclick="toggleCodeBlock('cloneGroup614', 'expandBtn614', 'collapseBtn614')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn614" onclick="toggleCodeBlock('cloneGroup614', 'expandBtn614', 'collapseBtn614')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup614"><code class="language-typescript text-sm text-gray-800">export type PriceRange = '$' | '$$' | '$$$' | '$$$$' | undefined;
export type DailyOperatingHours = {
    open: string;
    close: string;
    closed?: boolean;
} | {
    closed: true;
} | undefined;
export interface OperatingHours {
    monday: DailyOperatingHours;
    tuesday: DailyOperatingHours;
    wednesday: DailyOperatingHours;
    thursday: DailyOperatingHours;
    friday: DailyOperatingHours;
    saturday: DailyOperatingHours;
    sunday: DailyOperatingHours;
    [key: string]: DailyOperatingHours;
}
export interface MenuCategory {
    name: string;
    items: MenuItem[];
}
export interface MenuItem {
    name: string;
    description: string | undefined;
    price: number | string | undefined;
    dietary_tags: string[];
    is_popular?: boolean;
}
export interface UserCoordinates {
    lat: number;
    lng: number;
}
export interface LocationData {
    address: string | undefined;
    city: string | undefined;
    state: string | undefined;
    landmarks: string[];
    coordinates: UserCoordinates;
    confidence: number;
    raw_location_text: string | undefined;
}
export interface ExtractedFoodTruckDetails {
    name: string | undefined;
    description: string | undefined;
    cuisine_type: string[];
    price_range: PriceRange | undefined;
    specialties: string[];
    current_location: {
        address: string | undefined;
        city: string | undefined;
        state: string | undefined;
        zip_code: string | undefined;
        lat?: number;
        lng?: number;
        raw_text: string | undefined;
    };
    scheduled_locations?: {
        address?: string;
        city?: string;
        state?: string;
        zip_code?: string;
        lat?: number;
        lng?: number;
        timestamp: string;
        start_time: string;
        end_time: string;
    }[];
    operating_hours: OperatingHours;
    menu: MenuCategory[];
    contact_info: {
        phone?: string;
        email?: string;
        website?: string;
    };
    social_media: {
        instagram?: string;
        facebook?: string;
        twitter?: string;
        tiktok?: string;
        yelp?: string;
    };
    source_url: string;
}
export interface FirecrawlOutputData {
    markdown: string;
    name?: string;
    source_url?: string;
}
export interface FoodTruckSchema {
    name: string;
    description: string | undefined;
    current_location: {
        lat: number;
        lng: number;
        address: string | undefined;
        timestamp: string;
    };
    scheduled_locations: ExtractedFoodTruckDetails['scheduled_locations'];
    operating_hours: OperatingHours;
    menu: MenuCategory[];
    contact_info: {
        phone?: string;
        email?: string;
        website?: string;
    };
    social_media: {
        instagram?: string;
        facebook?: string;
        twitter?: string;
        tiktok?: string;
        yelp?: string;
    };
    cuisine_type: string[];
    price_range: PriceRange | undefined;
    specialties: string[];
    data_quality_score: number;
    verification_status: 'pending' | 'verified' | 'flagged';
    source_urls: string[];
    last_scraped_at: string;
    test_run_flag?: boolean;
    website?: string;
    phone_number?: string;
    email?: string;
    instagram_handle?: string;
    facebook_handle?: string;
    twitter_handle?: string;
    schedule?: unknown[];
    average_rating?: number;
    review_count?: number;
}
export interface FoodTruck extends FoodTruckSchema {
    id: string;
    created_at: string;
    updated_at: string;
    last_updated_at?: string;
    user_id?: string;
    state?: string;
    is_active?: boolean;
    image_url?: string;
    average_rating?: number;
    review_count?: number;
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/types.d.ts (Line 142:7 - Line 254:2), C:/AI/food-truck-finder-poc/dist/lib/lib/types.d.ts (Line 145:4 - Line 257:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn615" onclick="toggleCodeBlock('cloneGroup615', 'expandBtn615', 'collapseBtn615')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn615" onclick="toggleCodeBlock('cloneGroup615', 'expandBtn615', 'collapseBtn615')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup615"><code class="language-typescript text-sm text-gray-800">;
}
export interface GeminiResponse&lt;T = unknown&gt; {
    success: boolean;
    data?: T;
    tokensUsed?: number;
    error?: string;
    promptSent?: string;
}
export interface StageResult {
    status: string;
    data?: FirecrawlOutputData | ExtractedFoodTruckDetails | FoodTruckSchema;
    error?: string;
    details?: string;
    prompt?: string;
    tokensUsed?: number;
    metadata?: {
        name?: string;
        source_url?: string;
    };
    rawContent?: string;
    preparedData?: FoodTruckSchema;
    recordId?: string;
}
export interface TestPipelineResults {
    firecrawl?: StageResult;
    gemini?: StageResult;
    supabase?: StageResult;
    overallStatus?: string;
    logs?: string[];
    error?: string;
}
export interface PipelineRunResult {
    firecrawl?: StageResult;
    gemini?: StageResult;
    supabase?: StageResult;
    logs: string[];
    overallStatus: 'Success' | 'Error';
}
export interface ScrapingJob {
    id: string;
    job_type: string;
    target_url?: string;
    target_handle?: string;
    platform?: string;
    status: 'pending' | 'running' | 'completed' | 'failed';
    priority: number;
    scheduled_at: string;
    started_at?: string;
    completed_at?: string;
    data_collected?: Record&lt;string, unknown&gt;;
    errors?: string[];
    retry_count: number;
    max_retries: number;
    created_at: string;
}
export interface RealtimeMetrics {
    scrapingJobs: {
        active: number;
        completed: number;
        failed: number;
        pending: number;
    };
    dataQuality: {
        averageScore: number;
        totalTrucks: number;
        recentChanges: number;
    };
    systemHealth: {
        status: 'healthy' | 'warning' | 'error';
        uptime: number;
        lastUpdate: string;
    };
}
export interface TruckRating {
    id: number;
    title: string;
    score: number;
}
export interface PipelineEvent {
    type: string;
    payload: Record&lt;string, unknown&gt;;
    timestamp: string;
}
export interface SentimentAnalysisResult {
    sentiment: 'positive' | 'negative' | 'neutral';
    score: number;
    confidence: number;
    key_topics: string[];
    positive_aspects: string[];
    negative_aspects: string[];
    summary: string;
    recommended: boolean;
}
export interface EnhancedFoodTruckData {
    name: string | undefined;
    description: string | undefined;
    cuisine_type: string[];
    price_range: PriceRange;
    specialties: string[];
    dietary_options: string[];
    enhanced_menu: {
        categories: MenuCategory[];
    };
    standardized_hours: OperatingHours;
    cleaned_contact: {
        phone: string | undefined;
        email: string | undefined;
        website: string | undefined;
    };
    data_quality_improvements: string[];
    confidence_score: number;
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/ScraperEngine.d.ts (Line 1:1 - Line 246:2), C:/AI/food-truck-finder-poc/dist/lib/lib/ScraperEngine.d.ts (Line 1:1 - Line 246:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn618" onclick="toggleCodeBlock('cloneGroup618', 'expandBtn618', 'collapseBtn618')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn618" onclick="toggleCodeBlock('cloneGroup618', 'expandBtn618', 'collapseBtn618')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup618"><code class="language-typescript text-sm text-gray-800">interface InstagramPost {
    id: string;
    caption: string;
    timestamp: string;
    location: string;
    hashtags: string[];
    engagement: {
        likes: number;
        comments: number;
    };
}
interface InstagramProfile {
    followers: number;
    following: number;
    posts_count: number;
    bio: string;
    contact_info: {
        email: string;
        phone: string;
    };
}
interface FacebookPost {
    id: string;
    content: string;
    timestamp: string;
    reactions: {
        likes: number;
        loves: number;
        shares: number;
    };
    comments: number;
}
interface FacebookPageInfo {
    likes: number;
    followers: number;
    check_ins: number;
    about: string;
    hours: Record&lt;string, string&gt;;
}
interface TwitterTweet {
    id: string;
    text: string;
    timestamp: string;
    retweets: number;
    likes: number;
    replies: number;
    location: string;
}
interface TwitterProfile {
    followers: number;
    following: number;
    tweets_count: number;
    bio: string;
    location: string;
    website: string;
}
interface InstagramData {
    posts: InstagramPost[];
    profile: InstagramProfile;
}
interface FacebookData {
    posts: FacebookPost[];
    page_info: FacebookPageInfo;
}
interface TwitterData {
    tweets: TwitterTweet[];
    profile: TwitterProfile;
}
export interface WebsiteScrapeData {
    markdown?: string;
    html?: string;
    metadata?: Record&lt;string, unknown&gt;;
    is_fallback?: boolean;
}
export interface ExtractedHTMLData {
    name?: string;
    location?: string;
    phone?: string;
    hours?: string;
    menu?: {
        item: string;
        price: string;
    }[];
}
interface ScrapeResult {
    success: boolean;
    error?: string;
    data?: InstagramData | FacebookData | TwitterData | WebsiteScrapeData | ExtractedHTMLData;
    timestamp: string;
    source: string;
    note?: string;
}
export declare class ScraperEngine {
    private userAgents;
    private requestDelay;
    private maxRetries;
    constructor();
    private performFallbackScrape;
    scrapeWebsite(url: string, _selectors?: Record&lt;string, string&gt;): Promise&lt;ScrapeResult&gt;;
    scrapeSocialMedia(platform: string, handle: string): Promise&lt;ScrapeResult&gt;;
    private scrapeInstagram;
    private scrapeFacebook;
    private scrapeTwitter;
    private getRandomUserAgent;
    private randomDelay;
    handleRateLimit(retryAfter: number): Promise&lt;void&gt;;
    retryWithBackoff&lt;T&gt;(operation: () =&gt; Promise&lt;T&gt;, maxRetries?: number): Promise&lt;T&gt;;
}
interface LocationData {
    current?: {
        lat?: number;
        lng?: number;
        address?: string;
    };
}
interface ContactInfo {
    phone?: string;
    email?: string;
}
interface OperatingHours {
    [key: string]: {
        open: string;
        close: string;
        closed: boolean;
    };
}
interface MenuItem {
    name: string;
    description?: string;
    price: number;
    dietary_tags?: string[];
}
interface MenuCategory {
    category: string;
    items: MenuItem[];
}
interface TruckData {
    name: string;
    location: LocationData;
    contact?: ContactInfo;
    operating_hours?: OperatingHours;
    menu?: MenuCategory[];
    last_updated?: string;
}
export declare class DataQualityAssessor {
    private assessBasicInfo;
    private assessLocationInfo;
    private assessContactInfo;
    private assessOperatingHours;
    private assessMenuInfo;
    private assessLastUpdated;
    assessTruckData(truckData: TruckData): {
        score: number;
        issues: string[];
    };
    private validateMenuCategory;
    private validateMenuItems;
    private validateMenuData;
    private isValidPhone;
    private isValidEmail;
}
interface GeminiLocationData {
    address: string;
    city: string;
    state: string;
    coordinates: {
        lat?: number;
        lng?: number;
    };
    confidence: number;
}
interface GeminiOperatingHours {
    monday: {
        open: string;
        close: string;
        closed: boolean;
    };
    tuesday: {
        open: string;
        close: string;
        closed: boolean;
    };
    wednesday: {
        open: string;
        close: string;
        closed: boolean;
    };
    thursday: {
        open: string;
        close: string;
        closed: boolean;
    };
    friday: {
        open: string;
        close: string;
        closed: boolean;
    };
    saturday: {
        open: string;
        close: string;
        closed: boolean;
    };
    sunday: {
        open: string;
        close: string;
        closed: boolean;
    };
}
interface GeminiSentimentAnalysis {
    sentiment: 'positive' | 'negative' | 'neutral';
    score: number;
    key_topics: string[];
    summary: string;
}
export declare class GeminiDataProcessor {
    private _apiKey;
    private _baseUrl;
    private requestCount;
    private tokenCount;
    private dailyLimit;
    constructor(apiKey: string);
    processMenuData(rawMenuText: string): Promise&lt;{
        categories: MenuCategory[];
    }&gt;;
    extractLocationFromText(text: string): Promise&lt;GeminiLocationData&gt;;
    private validateGeminiLocationResponse;
    standardizeOperatingHours(hoursText: string): Promise&lt;GeminiOperatingHours&gt;;
    analyzeSentiment(reviewText: string): Promise&lt;GeminiSentimentAnalysis&gt;;
    private makeGeminiRequest;
    private getMockGeminiResponse;
    private canMakeRequest;
    private updateUsageCounters;
    getUsageStats(): {
        requests: {
            used: number;
            limit: number;
            remaining: number;
        };
        tokens: {
            used: number;
            limit: number;
            remaining: number;
        };
    };
}
export {};</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/scheduler.d.ts (Line 1:1 - Line 97:2), C:/AI/food-truck-finder-poc/dist/lib/lib/scheduler.d.ts (Line 1:1 - Line 97:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn620" onclick="toggleCodeBlock('cloneGroup620', 'expandBtn620', 'collapseBtn620')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn620" onclick="toggleCodeBlock('cloneGroup620', 'expandBtn620', 'collapseBtn620')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup620"><code class="language-typescript text-sm text-gray-800">export declare class TaskScheduler {
    private tasks;
    private intervals;
    private isRunning;
    constructor();
    start(): void;
    stop(): void;
    addTask(task: ScheduledTask): void;
    removeTask(taskId: string): void;
    enableTask(taskId: string): void;
    disableTask(taskId: string): void;
    private scheduleTask;
    getTaskStatus(): TaskStatus[];
    private calculateNextRun;
    scheduleFollowUpTasks(result: unknown): void;
}
interface ScheduledTask {
    id: string;
    name: string;
    description: string;
    intervalMinutes: number;
    enabled: boolean;
    execute: () =&gt; Promise&lt;void&gt;;
    lastRun?: string;
    lastSuccess?: string;
    successCount: number;
    errorCount: number;
    lastError?: string;
}
interface TaskStatus {
    id: string;
    name: string;
    enabled: boolean;
    intervalMinutes: number;
    lastRun?: string;
    lastSuccess?: string;
    successCount: number;
    errorCount: number;
    lastError?: string;
    nextRun?: string;
}
interface ScraperEngine {
    scrapeSocialMedia: (platform: string, handle: string) =&gt; Promise&lt;{
        success: boolean;
        error?: string;
        data?: unknown;
    }&gt;;
    scrapeWebsite: (url: string, selectors: Record&lt;string, string&gt;) =&gt; Promise&lt;{
        success: boolean;
        error?: string;
        data?: unknown;
    }&gt;;
}
interface GeminiProcessor {
    getUsageStats: () =&gt; {
        requests: {
            remaining: number;
        };
    };
    processMenuData: (content: string) =&gt; Promise&lt;unknown&gt;;
    extractLocationFromText: (content: string) =&gt; Promise&lt;unknown&gt;;
    standardizeOperatingHours: (content: string) =&gt; Promise&lt;unknown&gt;;
    analyzeSentiment: (content: string) =&gt; Promise&lt;unknown&gt;;
    enhanceFoodTruckData: (data: unknown) =&gt; Promise&lt;unknown&gt;;
}
interface DataQualityAssessor {
    assessTruckData: (truck: FoodTruck) =&gt; {
        score: number;
        issues: string[];
    };
}
interface FoodTruck {
    id: string;
    name: string;
    contact_info: {
        phone?: string;
        email?: string;
        website?: string;
    };
    social_media: {
        instagram_handle?: string;
        facebook_handle?: string;
        twitter_handle?: string;
    };
    cuisine_type: string;
    price_range?: string;
    specialties: string[];
    menu: unknown;
    current_location: {
        lat?: number;
        lng?: number;
        address?: string;
    };
}
export declare function createDefaultTasks(scraperEngine: ScraperEngine, geminiProcessor: GeminiProcessor, dataQualityAssessor: DataQualityAssessor): ScheduledTask[];
export declare const scheduler: TaskScheduler;
export {};</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/pipelineManager.d.ts (Line 1:1 - Line 116:2), C:/AI/food-truck-finder-poc/dist/lib/lib/pipelineManager.d.ts (Line 1:1 - Line 116:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn622" onclick="toggleCodeBlock('cloneGroup622', 'expandBtn622', 'collapseBtn622')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn622" onclick="toggleCodeBlock('cloneGroup622', 'expandBtn622', 'collapseBtn622')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup622"><code class="language-typescript text-sm text-gray-800">export interface PipelineConfig {
    type: 'discovery' | 'processing' | 'full' | 'maintenance';
    params: {
        maxUrls?: number;
        maxUrlsToProcess?: number;
        targetCities?: string[];
        priority?: number;
        skipDiscovery?: boolean;
        retryFailedJobs?: boolean;
    };
}
export interface DiscoveryParams {
    cities: string[];
    maxUrls: number;
    searchTerms?: string[];
}
export interface ProcessingOptions {
    maxJobs: number;
    priority: number;
    retryFailedJobs: boolean;
}
export interface PipelineResult {
    success: boolean;
    type: string;
    phase: string;
    summary: {
        urlsDiscovered?: number;
        urlsProcessed?: number;
        jobsCreated?: number;
        trucksCreated?: number;
        errors?: number;
        duration: number;
    };
    details: unknown;
    timestamp: string;
}
export interface DiscoveryResult {
    success: boolean;
    urlsDiscovered: number;
    urlsStored: number;
    urlsDuplicate: number;
    errors: string[];
    duration: number;
}
export interface ProcessingResult {
    success: boolean;
    jobsProcessed: number;
    jobsSuccessful: number;
    jobsFailed: number;
    trucksCreated: number;
    errors: string[];
    duration: number;
}
export interface MaintenanceResult {
    success: boolean;
    trucksProcessed: number;
    newTrucksFound: number;
    errors: string[];
    duration: number;
}
/**
 * Unified Pipeline Manager
 *
 * Consolidates all pipeline operations into a single, modular system:
 * - Discovery: Find new food truck URLs using Tavily
 * - Processing: Process URLs through Firecrawl + Gemini pipeline
 * - Full: Combined discovery + processing
 * - Maintenance: Check existing trucks for stale data
 */
export declare class PipelineManager {
    /**
     * Run the complete pipeline based on configuration
     */
    runPipeline(config: PipelineConfig): Promise&lt;PipelineResult&gt;;
    /**
     * Execute the specific pipeline type
     */
    private executePipelineType;
    /**
     * Create success result
     */
    private createSuccessResult;
    /**
     * Create error result
     */
    private createErrorResult;
    /**
     * Run URL discovery using Tavily search
     */
    runDiscovery(_params: DiscoveryParams): Promise&lt;DiscoveryResult&gt;;
    /**
     * Process existing scraping jobs
     */
    processJobs(options: ProcessingOptions): Promise&lt;ProcessingResult&gt;;
    /**
     * Create empty processing result when no jobs available
     */
    private createEmptyProcessingResult;
    /**
     * Process a batch of jobs
     */
    private processJobBatch;
    /**
     * Create processing error result
     */
    private createProcessingErrorResult;
    /**
     * Run full pipeline: discovery + processing
     */
    private runFullPipeline;
    /**
     * Run maintenance checks on existing trucks
     */
    runMaintenance(): Promise&lt;MaintenanceResult&gt;;
}
export declare const pipelineManager: PipelineManager;</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/gemini.d.ts (Line 7:4 - Line 38:2), C:/AI/food-truck-finder-poc/dist/lib/lib/gemini.d.ts (Line 7:2 - Line 38:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn624" onclick="toggleCodeBlock('cloneGroup624', 'expandBtn624', 'collapseBtn624')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn624" onclick="toggleCodeBlock('cloneGroup624', 'expandBtn624', 'collapseBtn624')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup624"><code class="language-typescript text-sm text-gray-800">;
    private makeGeminiRequest;
    processMenuData: (rawMenuText: string) =&gt; Promise&lt;GeminiResponse&lt;MenuCategory[]&gt;&gt;;
    extractLocationFromText: (textInput: string) =&gt; Promise&lt;GeminiResponse&lt;LocationData&gt;&gt;;
    standardizeOperatingHours: (hoursText: string) =&gt; Promise&lt;GeminiResponse&lt;OperatingHours&gt;&gt;;
    analyzeSentiment: (reviewText: string) =&gt; Promise&lt;GeminiResponse&lt;SentimentAnalysisResult&gt;&gt;;
    enhanceFoodTruckData: (rawData: unknown) =&gt; Promise&lt;GeminiResponse&lt;EnhancedFoodTruckData&gt;&gt;;
    batchProcess: (items: Array&lt;{
        type: string;
        data: unknown;
    }&gt;) =&gt; Promise&lt;Array&lt;GeminiResponse&lt;unknown&gt;&gt;&gt;;
    getUsageStats: () =&gt; Promise&lt;{
        requests_count: number;
        tokens_used: number;
    } | undefined&gt;;
    extractFoodTruckDetailsFromMarkdown: (markdownContent: string, sourceUrl?: string) =&gt; Promise&lt;GeminiResponse&lt;ExtractedFoodTruckDetails&gt;&gt;;
}
/**
* Dispatches the appropriate Gemini operation based on the provided type.
* @example
* dispatchGeminiOperation('menu', 'data')
* Returns a promise with processed menu data response
* @param {'menu' | 'location' | 'hours' | 'sentiment' | 'enhance' | 'foodTruckExtraction'} type - The type of Gemini operation to dispatch.
* @param {unknown} data - Data relevant to the specified Gemini operation type.
* @returns {Promise&lt;GeminiResponse&lt;unknown&gt;&gt;} Returns a promise that resolves to the Gemini operation's response.
* @description
*   - Operates asynchronously, ensuring the flexibility and responsiveness of Gemini processing.
*   - Utilizes type assertion to correctly handle various data types pertinent to the operation.
*   - If the operation type is unrecognized, the function returns an error response.
*/
export declare function dispatchGeminiOperation(type: 'menu' | 'location' | 'hours' | 'sentiment' | 'enhance' | 'foodTruckExtraction', data: unknown): Promise&lt;GeminiResponse&lt;unknown&gt;&gt;;
export declare const gemini: GeminiService;</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/firecrawl.d.ts (Line 1:1 - Line 226:2), C:/AI/food-truck-finder-poc/dist/lib/lib/firecrawl.d.ts (Line 1:1 - Line 226:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn626" onclick="toggleCodeBlock('cloneGroup626', 'expandBtn626', 'collapseBtn626')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn626" onclick="toggleCodeBlock('cloneGroup626', 'expandBtn626', 'collapseBtn626')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup626"><code class="language-typescript text-sm text-gray-800">export interface FirecrawlResponse {
    success: boolean;
    data?: {
        markdown?: string;
        html?: string;
        metadata?: {
            title?: string;
            description?: string;
            language?: string;
            sourceURL?: string;
        };
        links?: string[];
    };
    error?: string;
}
interface CrawlJobResponse {
    success: boolean;
    jobId?: string;
    error?: string;
}
interface ScrapedMetadata {
    title?: string;
    description?: string;
    language?: string;
    sourceURL?: string;
}
interface CrawlStatusResponse {
    success: boolean;
    status?: 'scraping' | 'completed' | 'failed';
    data?: Array&lt;{
        markdown?: string;
        html?: string;
        metadata?: ScrapedMetadata;
    }&gt;;
    error?: string;
}
export declare class FirecrawlService {
    private apiKey;
    private baseUrl;
    constructor();
    /**
     * Retrieves a cached result based on the given cache key if it hasn't expired.
     * @example
     * getCachedResult('uniqueCacheKey')
     * FirecrawlResponse or undefined
     * @param {string} cacheKey - The unique identifier for the cached result.
     * @returns {FirecrawlResponse | CrawlJobResponse | CrawlStatusResponse | undefined} The cached data if available and valid, otherwise undefined.
     * @description
     *   - Cleans up expired cache entries before attempting to return a cached result.
     *   - Logs a message when a cache hit occurs.
     */
    private getCachedResult;
    private setCacheResult;
    /**
    * Fetches and processes content from a specified URL, optionally customizing the output format and content inclusion/exclusion via provided options.
    * @example
    * scrapeUrl('https://example.com', { formats: ['html'], includeTags: ['h1', 'p'] })
    * Returns a FirecrawlResponse object containing the scraped data.
    * @param {string} url - The URL from which content will be scraped.
    * @param {Object} options - Optional parameters to customize the scraping process.
    * @param {(string[]|undefined)} options.formats - Specifies the desired output formats: 'markdown' or 'html'.
    * @param {(string[]|undefined)} options.includeTags - Tags to specifically include in the scraping results.
    * @param {(string[]|undefined)} options.excludeTags - Tags to exclude from the scraping results.
    * @param {(boolean|undefined)} options.onlyMainContent - If true, extracts only the main content from the URL.
    * @param {(number|undefined)} options.waitFor - Time in milliseconds to wait before starting the scraping process.
    * @returns {Promise&lt;FirecrawlResponse&gt;} A promise resolving to a FirecrawlResponse containing either the successful scraping results or error details.
    * @description
    *   - Utilizes caching to store and retrieve previously fetched data to minimize repeated requests.
    *   - Sends API requests with authentication headers using the instance's API key.
    *   - Handles errors gracefully, returning a descriptive error message if the scraping process fails.
    */
    scrapeUrl(url: string, options?: {
        formats?: ('markdown' | 'html')[];
        includeTags?: string[];
        excludeTags?: string[];
        onlyMainContent?: boolean;
        waitFor?: number;
    }): Promise&lt;FirecrawlResponse&gt;;
    /**
     * Initiates a web crawling process for a specified URL with given options.
     * @example
     * crawlWebsite('https://example.com', { crawlerOptions: { includes: ['.html'] }, pageOptions: { formats: ['markdown'] } })
     * // Returns a promise that resolves to a CrawlJobResponse object
     * @param {string} url - The URL of the website to be crawled.
     * @param {Object} options - Configuration options for the crawling process.
     * @param {Object} [options.crawlerOptions] - Specific options for controlling the crawler behavior.
     * @param {string[]} [options.crawlerOptions.includes] - List of patterns to include in the crawl.
     * @param {string[]} [options.crawlerOptions.excludes] - List of patterns to exclude from the crawl.
     * @param {number} [options.crawlerOptions.maxDepth] - Maximum depth the crawler should reach.
     * @param {number} [options.crawlerOptions.limit] - Limit to the number of pages to crawl.
     * @param {Object} [options.pageOptions] - Options for the page content format and selection.
     * @param {string[]} [options.pageOptions.formats] - Desired formats for the crawled page content.
     * @param {boolean} [options.pageOptions.onlyMainContent] - Whether to include only the main content of the pages.
     * @returns {Promise&lt;CrawlJobResponse&gt;} A promise that resolves with the results of the crawl job including success and potential errors.
     * @description
     *   - Performs a POST request to the Firecrawl service to crawl pages.
     *   - Uses caching to avoid redundant web crawling operations.
     *   - Handles errors gracefully, returning an appropriate error message if the fetch operation fails.
     *   - Crawls with default options which include markdown format and filtering for main content.
     */
    crawlWebsite(url: string, options?: {
        crawlerOptions?: {
            includes?: string[];
            excludes?: string[];
            maxDepth?: number;
            limit?: number;
        };
        pageOptions?: {
            formats?: ('markdown' | 'html')[];
            onlyMainContent?: boolean;
        };
    }): Promise&lt;CrawlJobResponse&gt;;
    /**
     * Retrieves the crawl status for a given job by its ID.
     * @example
     * getCrawlStatus('12345')
     * { success: true, status: 'completed' }
     * @param {string} jobId - The ID of the job for which the crawl status is requested.
     * @returns {Promise&lt;CrawlStatusResponse&gt;} Resolves to a `CrawlStatusResponse` object containing the crawl status or an error.
     * @description
     *   - Attempts to retrieve the crawl status from a cache before making an HTTP request.
     *   - Fetches crawl status using an authenticated request to the API.
     *   - Caches the crawl status response data to minimize redundant network calls.
     *   - Handles errors gracefully, returning a standardized error response.
     */
    getCrawlStatus(jobId: string): Promise&lt;CrawlStatusResponse&gt;;
    /**
     * Scrapes a food truck website and retrieves its main content in markdown format.
     * @example
     * scrapeFoodTruckWebsite('https://example.com/food-truck')
     * // Returns: Promise&lt;{ success: true, data: { markdown: '...', name: 'Example Food Truck', source_url: 'https://example.com/food-truck' } }&gt;
     * @param {string} url - The URL of the food truck website to scrape.
     * @returns {Promise&lt;{ success: boolean, data?: { markdown: string, name?: string, source_url?: string }, error?: string }&gt;} The result of the scrape operation, including markdown content and metadata if successful, or an error message if not.
     * @description
     *   - Configured to wait 2000 milliseconds to ensure all content is loaded.
     *   - Uses 'markdown' format for content extraction to maintain text structure.
     *   - Extracts metadata such as the title and source URL if available.
     */
    scrapeFoodTruckWebsite(url: string): Promise&lt;{
        success: boolean;
        data?: {
            markdown: string;
            name?: string;
            source_url?: string;
        };
        error?: string;
    }&gt;;
    private extractPattern;
    /**
    * Extracts a menu section from a given markdown string based on specific keywords.
    * @example
    * extractMenuSection(&quot;menu: Pizza, Pasta, Salad&quot;)
    * // Returns &quot;Pizza, Pasta, Salad&quot;
    * @param {string} markdown - The markdown string to search for menu-related content.
    * @returns {string | undefined} The extracted menu section if found, otherwise undefined.
    * @description
    *   - Searches for menu-related phrases like &quot;menu&quot;, &quot;food&quot;, &quot;items&quot; up to a maximum of 50 characters.
    *   - Implements case-insensitive search patterns.
    *   - Returns the portion of the markdown line following the specific keywords.
    */
    private extractMenuSection;
    /**
     * Extracts phone and email contact information from a markdown string.
     * @example
     * extractContactInfo(&quot;Contact: +123-456-7890, email: example@test.com&quot;)
     * { phone: &quot;+123-456-7890&quot;, email: &quot;example@test.com&quot; }
     * @param {string} markdown - A markdown string potentially containing contact information.
     * @returns {ContactInfo | undefined} An object containing extracted phone and email, or undefined if none are found.
     * @description
     *   - Utilizes regular expressions to identify phone numbers and email addresses within the markdown.
     *   - Returns an object only when at least one type of contact information is successfully extracted.
     */
    private extractContactInfo;
    /**
    * Extracts social media profile names from a given markdown string.
    * @example
    * extractSocialMedia(&quot;@john_doe instagram.com/jane Facebook.com/joe&quot;)
    * { instagram: 'john_doe', facebook: 'jane', twitter: 'joe' }
    * @param {string} markdown - A string containing markdown text to parse for social media information.
    * @returns {SocialMediaInfo | undefined} An object containing social media profiles if any are found, otherwise undefined.
    * @description
    *   - Supports extracting profiles for Instagram, Facebook, and Twitter.
    *   - Uses regular expressions to match social media patterns.
    *   - Returns the trimmed username of identified social media profiles.
    *   - Returns undefined if no social media profiles are found in the input.
    */
    private extractSocialMedia;
    /**
     * Performs web scraping on multiple URLs with batching and delay options.
     * @example
     * scrapeMultipleUrls(['http://example.com', 'http://another.com'], { batchSize: 2, delay: 1500 })
     * Returns: Promise resolving to an array containing the results of the scraped URLs.
     * @param {string[]} urls - Array of URLs to be scraped.
     * @param {Object} options - Options object for configuring the scraping process.
     * @param {number} [options.batchSize=5] - Size of each batch in which URLs are processed.
     * @param {number} [options.delay=1000] - Delay between processing each batch in milliseconds.
     * @returns {Promise&lt;Array&lt;{ url: string; result: FirecrawlResponse }&gt;&gt;} Promise resolving to an array of objects, each containing a URL and its corresponding scrape result.
     * @description
     *   - Utilizes a batch mechanism to efficiently handle large sets of URLs.
     *   - Incorporates a delay between batches to comply with potential rate limits.
     */
    scrapeMultipleUrls(urls: string[], options?: {
        batchSize?: number;
        delay?: number;
    }): Promise&lt;Array&lt;{
        url: string;
        result: FirecrawlResponse;
    }&gt;&gt;;
    /**
     * Attempts to scrape content from a given URL with retries in case of failure.
     * @example
     * scrapeWithRetry('https://example.com', 3, 1000)
     * { success: true, data: {...} }
     * @param {string} url - The URL to scrape.
     * @param {number} maxRetries - Maximum number of retry attempts. Defaults to 3.
     * @param {number} backoffMs - Initial wait time before retrying in milliseconds. Defaults to 1000ms.
     * @returns {Promise&lt;FirecrawlResponse&gt;} Promise resolving to a FirecrawlResponse object indicating success or failure.
     * @description
     *   - Implements exponential backoff strategy for rate limit errors.
     *   - Logs attempt details and waiting times between retries.
     *   - Returns last error message if all retry attempts fail.
     */
    scrapeWithRetry(url: string, maxRetries?: number, backoffMs?: number): Promise&lt;FirecrawlResponse&gt;;
}
export declare const firecrawl: FirecrawlService;
export {};</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/discoveryEngine.d.ts (Line 1:1 - Line 272:2), C:/AI/food-truck-finder-poc/dist/lib/lib/discoveryEngine.d.ts (Line 1:1 - Line 272:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn628" onclick="toggleCodeBlock('cloneGroup628', 'expandBtn628', 'collapseBtn628')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn628" onclick="toggleCodeBlock('cloneGroup628', 'expandBtn628', 'collapseBtn628')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup628"><code class="language-typescript text-sm text-gray-800">export interface DiscoveredUrl {
    url: string;
    source_directory_url?: string;
    region?: string;
    status: 'new' | 'processing' | 'processed' | 'irrelevant';
    notes?: string;
}
export interface DiscoveryResult {
    urls_discovered: number;
    urls_stored: number;
    urls_duplicates: number;
    errors: string[];
}
/**
 * Autonomous Discovery Engine
 *
 * This engine discovers new food truck websites across South Carolina using Tavily for search
 * and Firecrawl for crawling. It operates autonomously without human intervention, finding and
 * validating new URLs to add to the discovered_urls table for subsequent scraping.
 *
 * Strategy:
 * 1. Search for food trucks in each SC city using Tavily search
 * 2. Find food truck directories and event listings using Firecrawl crawling
 * 3. Extract individual food truck website URLs from discovered content
 * 4. Validate and filter URLs to avoid false positives
 * 5. Store new URLs in discovered_urls table for processing
 *
 * NOTE: Uses Tavily for search operations and Firecrawl for crawling/scraping
 */
interface TavilySearchResult {
    url: string;
    content?: string;
    raw_content?: string;
}
export declare class FoodTruckDiscoveryEngine {
    private readonly searchTerms;
    private readonly directoryUrls;
    /**
     * Processes search results to discover and store food truck URLs.
     * @example
     * processSearchResults([{ url: 'http://example.com', content: '...' }], new Set())
     * // No return value; `discoveredUrls` will contain food truck URLs.
     * @param {TavilySearchResult[]} searchResults - An array of search result objects each possibly containing a URL and content.
     * @param {Set&lt;string&gt;} discoveredUrls - A set to store discovered food truck URLs.
     * @returns {Promise&lt;void&gt;} No return value; operates by modifying the `discoveredUrls` set.
     * @description
     *   - URLs are checked for validity as food truck URLs before being added to the set.
     *   - Extracts URLs from either the `content` or `raw_content` fields.
     *   - Uses asynchronous URL validation.
     */
    private processSearchResults;
    /**
     * Performs search term discovery using the specified search terms.
     * @example
     * performSearchTermDiscovery(new Set(), discoveryResult)
     * No specific return value, performs actions on `discoveredUrls` and `results`.
     * @param {Set&lt;string&gt;} discoveredUrls - A set to store discovered URLs that have been processed.
     * @param {DiscoveryResult} results - An object to accumulate results and errors stemming from the discovery process.
     * @returns {Promise&lt;void&gt;} Returns a promise that resolves when search term discovery is complete.
     * @description
     *   - Utilizes a search function `tavilySearch` to find results based on search terms.
     *   - Incorporates error handling and logs errors to `results.errors`.
     *   - Implements rate limiting by delaying subsequent searches using `DISCOVERY_CONFIG.rateLimitDelayMs`.
     *   - Processes search results using the `processSearchResults` method if valid results are found.
     */
    private performSearchTermDiscovery;
    private performDirectoryCrawling;
    /**
     * Crawls a single directory and processes discovered URLs.
     * @example
     * crawlSingleDirectory('http://example.com', new Set(), resultsInstance)
     * void
     * @param {string} directoryUrl - The URL of the directory to be crawled.
     * @param {Set&lt;string&gt;} discoveredUrls - A set to store URLs discovered during the crawl.
     * @param {DiscoveryResult} results - An object to store the results and errors of the crawl process.
     * @returns {Promise&lt;void&gt;} Resolves when crawl and processing are complete.
     * @description
     *   - Uses a third-party library, `firecrawlCrawl`, for the crawling operation.
     *   - Handles errors by logging and storing error messages in the results object.
     *   - Limits the depth and number of URLs explored based on configuration.
     */
    private crawlSingleDirectory;
    /**
     * Processes the results from a web crawl and adds discovered URLs to a set if they meet certain criteria.
     * @example
     * processCrawlResults(crawlResults, discoveredUrls)
     * // adds qualifying URLs to the discoveredUrls set
     * @param {unknown} crawlResults - The results obtained from the crawling operation.
     * @param {Set&lt;string&gt;} discoveredUrls - A set to store URLs discovered during processing.
     * @returns {Promise&lt;void&gt;}
     * @description
     *   - Only accepts results that are valid non-empty arrays.
     *   - Checks each item to ensure it's an object containing a 'url' property.
     *   - Uses a helper function isFoodTruckUrl to decide if a URL should be added to the set.
     */
    private processCrawlResults;
    private performLocationDiscovery;
    /**
    * Initiates a search for food trucks within a specified city in South Carolina.
    * @example
    * searchSingleCity(&quot;Charleston&quot;, discoveredUrls, results)
    * // Returns undefined but processes the data internally and updates results object.
    * @param {string} city - The name of the city where food trucks are to be searched.
    * @param {Set&lt;string&gt;} discoveredUrls - A Set to keep track of URLs that have been discovered during the search.
    * @param {DiscoveryResult} results - Object to store errors and possibly other results related to the discovery process.
    * @returns {Promise&lt;void&gt;} Resolves after processing the search results.
    * @description
    *   - Uses `tavilySearch` function to perform the location-based search with a limit of 5 results.
    *   - Handles errors by logging them and updating the results object with error messages.
    *   - Assumes South Carolina as the default state for city searches.
    */
    private searchSingleCity;
    /**
     * Processes search results to discover specific URLs and add them to a set.
     * @example
     * processLocationSearchResults(searchResults, discoveredUrls);
     * // The set discoveredUrls will be populated with food truck URLs from searchResults
     * @param {unknown} searchResults - Array of search result objects potentially containing URLs.
     * @param {Set&lt;string&gt;} discoveredUrls - Set used to collect discovered food truck URLs.
     * @returns {Promise&lt;void&gt;} Resolves when all URLs are processed and added to the set.
     * @description
     *   - Ensures the searchResults contain an array of objects with valid URL properties.
     *   - Filters URLs through isFoodTruckUrl method before adding them to discoveredUrls.
     */
    private processLocationSearchResults;
    /**
     * Stores a set of discovered URLs from a discovery process into a database.
     * @example
     * storeDiscoveredUrlsFromDiscovery(new Set(['http://example.com', 'http://example.org']), discoveryResult)
     * // No return value (undefined).
     * @param {Set&lt;string&gt;} discoveredUrls - A set of URLs that have been discovered and need to be stored.
     * @param {DiscoveryResult} results - An object to track and accumulate errors encountered during storage.
     * @returns {Promise&lt;void&gt;} Resolves when all URLs are processed and stored.
     * @description
     *   - This function iterates over a set of URLs and stores each individually.
     *   - Errors encountered during the storage process are logged and appended to the provided results object.
     *   - Utilizes an asynchronous operation to store URLs and handle potential failures gracefully.
     */
    private storeDiscoveredUrlsFromDiscovery;
    /**
    * Initiates autonomous discovery of new food truck URLs.
    * @example
    * discoverNewFoodTrucks()
    * Returns a Promise resolving to a DiscoveryResult object.
    * @param {none} No parameters required.
    * @returns {Promise&lt;DiscoveryResult&gt;} An object containing the counts of discovered, stored, and duplicate URLs and any errors encountered.
    * @description
    *   - Utilizes multiple discovery methods: search term, directory crawling, and location-specific search.
    *   - Aggregates discovered URLs in a Set to ensure uniqueness.
    *   - Logs informative messages regarding the discovery and storage process.
    *   - Handles the storage of newly discovered URLs and logs duplicates.
    */
    discoverNewFoodTrucks(): Promise&lt;DiscoveryResult&gt;;
    /**
     * Extracts valid URLs from a given string content.
     * @example
     * extractFoodTruckUrls(&quot;Check out these two links: https://foodtrucklink.com/menu, and https://anotherlink.com!&quot;)
     * [&quot;https://foodtrucklink.com/menu&quot;, &quot;https://anotherlink.com&quot;]
     * @param {string} content - The textual content from which URLs are extracted.
     * @returns {string[]} An array of valid URLs extracted from the content.
     * @description
     *   - Utilizes a regular expression pattern to identify potential URLs.
     *   - Performs basic URL validation using the URL constructor.
     *   - Cleans up URLs by removing trailing punctuation such as periods, commas, semicolons, etc.
     *   - Skips invalid URLs identified during the validation process.
     */
    private extractFoodTruckUrls;
    /**
     * Checks if a given URL is related to a food truck.
     * @example
     * isFoodTruckUrl(&quot;https://bestfoodtruck.com&quot;)
     * true
     * @param {string} url - The URL to validate and check against known food truck patterns.
     * @returns {Promise&lt;boolean&gt;} True if the URL is likely related to a food truck, false otherwise.
     * @description
     *   - Uses keyword matching to detect food truck-related URLs.
     *   - Excludes common social media and review domains via blacklist.
     *   - Validates if the URL is already present in `discovered_urls` or `food_trucks` database.
     *   - Accepts common business domains not typically associated with blogs or news sites.
     */
    private isFoodTruckUrl;
    /**
     * Initiates a discovery process for food trucks in the specified city and state.
     * @example
     * getLocationSpecificDiscovery('Charleston', 'SC')
     * Promise &lt;DiscoveryResult&gt; {urls_discovered: 5, urls_stored: 4, urls_duplicates: 1, errors: []}
     * @param {string} city - The city where the search is to be performed.
     * @param {string} [state='SC'] - The state where the search is to be performed; defaults to 'SC'.
     * @returns {Promise&lt;DiscoveryResult&gt;} An object containing the discovery results and any errors encountered.
     * @description
     *   - Logs the initiation and completion of the discovery process with results.
     *   - Performs the search using a specified query and stores new URLs found.
     *   - Captures and logs any errors encountered during the search process.
     */
    getLocationSpecificDiscovery(city: string, state?: string): Promise&lt;DiscoveryResult&gt;;
    /**
    * Executes a location-specific search and processes the results.
    * @example
    * performLocationSpecificSearch(&quot;San Francisco&quot;, new Set())
    * // Processes search results for &quot;San Francisco&quot; location
    * @param {string} locationQuery - The location query to perform the search.
    * @param {Set&lt;string&gt;} discoveredUrls - A set to track URLs that have already been discovered.
    * @returns {Promise&lt;void&gt;} Completes search processing without return value.
    * @description
    *   - Searches are performed with a limit of 15 results.
    *   - Only non-empty search results are processed.
    *   - Uses asynchronous calls to handle search and processing operations.
    */
    private performLocationSpecificSearch;
    private processSearchResult;
    /**
     * Extracts food truck URLs from a given result object and adds them to a discovered URL set.
     * @example
     * extractUrlsFromContent(resultObject, discoveredUrlSet)
     * void
     * @param {unknown} result - The result object potentially containing content with URLs.
     * @param {Set&lt;string&gt;} discoveredUrls - A set where extracted food truck URLs will be added.
     * @returns {Promise&lt;void&gt;} Resolves when URLs are added to the set.
     * @description
     *   - Parses both `content` and `raw_content` properties for URLs.
     *   - Uses helper method `extractFoodTruckUrls` to identify specific URLs.
     *   - Filters URLs through `isFoodTruckUrl` method to ensure relevance before adding.
     */
    private extractUrlsFromContent;
    /**
     * Stores location discovery results by iterating through a set of discovered URLs.
     * @example
     * storeLocationDiscoveryResults({
     *   discoveredUrls: new Set(['http://example.com']),
     *   locationQuery: 'pizza restaurant',
     *   city: 'San Francisco',
     *   state: 'CA',
     *   results: {}
     * })
     *
     * @param {Object} params - Parameters for storing the discovery results.
     * @param {Set&lt;string&gt;} params.discoveredUrls - A set of URLs to be stored.
     * @param {string} params.locationQuery - The location query used in the search.
     * @param {string} params.city - The target city for the location search.
     * @param {string} params.state - The target state for the location search.
     * @param {DiscoveryResult} params.results - Object to store results and errors.
     * @returns {Promise&lt;void&gt;} No return value.
     * @description
     *   - Logs an error and records it in the results if storing a URL fails.
     *   - Assumes the existence of a method `storeDiscoveredUrl` to handle storage logic.
     *   - The `results` object is mutated by adding error messages directly.
     */
    private storeLocationDiscoveryResults;
    private delay;
    /**
     * Store multiple discovered URLs with metadata
     */
    storeDiscoveredUrls(urls: string[], discoveryMethod?: string, metadata?: Record&lt;string, unknown&gt;): Promise&lt;{
        urls_stored: number;
        urls_duplicates: number;
        errors: string[];
    }&gt;;
    /**
     * Enhanced store method with discovery method and metadata
     */
    private storeDiscoveredUrl;
    /**
     * Search for food truck directories
     */
    searchFoodTruckDirectories(query?: string): Promise&lt;TavilySearchResult[]&gt;;
    /**
     * Search for food truck websites
     */
    searchFoodTruckWebsites(query: string): Promise&lt;TavilySearchResult[]&gt;;
}
export declare const discoveryEngine: FoodTruckDiscoveryEngine;
export {};</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/database.types.d.ts (Line 1:1 - Line 278:2), C:/AI/food-truck-finder-poc/dist/lib/lib/database.types.d.ts (Line 1:1 - Line 278:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn629" onclick="toggleCodeBlock('cloneGroup629', 'expandBtn629', 'collapseBtn629')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn629" onclick="toggleCodeBlock('cloneGroup629', 'expandBtn629', 'collapseBtn629')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup629"><code class="language-typescript text-sm text-gray-800">/**
 * Database Types for Food Truck Finder Application
 * Auto-generated from Supabase schema
 */
export type Json = string | number | boolean | undefined | {
    [key: string]: Json | undefined;
} | Json[];
export interface Database {
    public: {
        Tables: {
            food_trucks: {
                Row: {
                    id: string;
                    created_at: string;
                    updated_at: string;
                    name: string;
                    description: string | undefined;
                    current_location: Json;
                    scheduled_locations: Json | undefined;
                    operating_hours: Json | undefined;
                    menu: Json | undefined;
                    contact_info: Json | undefined;
                    social_media: Json | undefined;
                    cuisine_type: string[] | undefined;
                    price_range: string | undefined;
                    specialties: string[] | undefined;
                    data_quality_score: number | undefined;
                    verification_status: 'pending' | 'verified' | 'flagged' | 'rejected';
                    source_urls: string[] | undefined;
                    last_scraped_at: string | undefined;
                    exact_location: Json | undefined;
                    city_location: Json | undefined;
                    user_id: string | undefined;
                    average_rating: number | undefined;
                    review_count: number | undefined;
                    last_updated_at: string | undefined;
                    is_active: boolean | undefined;
                };
                Insert: {
                    id?: string;
                    created_at?: string;
                    updated_at?: string;
                    name: string;
                    description?: string | undefined;
                    current_location: Json;
                    scheduled_locations?: Json | undefined;
                    operating_hours?: Json | undefined;
                    menu?: Json | undefined;
                    contact_info?: Json | undefined;
                    social_media?: Json | undefined;
                    cuisine_type?: string[] | undefined;
                    price_range?: string | undefined;
                    specialties?: string[] | undefined;
                    data_quality_score?: number | undefined;
                    verification_status?: 'pending' | 'verified' | 'flagged' | 'rejected';
                    source_urls?: string[] | undefined;
                    last_scraped_at?: string | undefined;
                    exact_location?: Json | undefined;
                    city_location?: Json | undefined;
                    user_id?: string | undefined;
                    average_rating?: number | undefined;
                    review_count?: number | undefined;
                    last_updated_at?: string | undefined;
                    is_active?: boolean | undefined;
                };
                Update: {
                    id?: string;
                    created_at?: string;
                    updated_at?: string;
                    name?: string;
                    description?: string | undefined;
                    current_location?: Json;
                    scheduled_locations?: Json | undefined;
                    operating_hours?: Json | undefined;
                    menu?: Json | undefined;
                    contact_info?: Json | undefined;
                    social_media?: Json | undefined;
                    cuisine_type?: string[] | undefined;
                    price_range?: string | undefined;
                    specialties?: string[] | undefined;
                    data_quality_score?: number | undefined;
                    verification_status?: 'pending' | 'verified' | 'flagged' | 'rejected';
                    source_urls?: string[] | undefined;
                    last_scraped_at?: string | undefined;
                    exact_location?: Json | undefined;
                    city_location?: Json | undefined;
                    user_id?: string | undefined;
                    average_rating?: number | undefined;
                    review_count?: number | undefined;
                    last_updated_at?: string | undefined;
                    is_active?: boolean | undefined;
                };
            };
            scraping_jobs: {
                Row: {
                    id: string;
                    job_type: string;
                    target_url: string | undefined;
                    target_handle: string | undefined;
                    platform: string | undefined;
                    status: 'pending' | 'running' | 'completed' | 'failed';
                    priority: number;
                    scheduled_at: string;
                    started_at: string | undefined;
                    completed_at: string | undefined;
                    data_collected: Json | undefined;
                    errors: string[] | undefined;
                    retry_count: number;
                    max_retries: number;
                    created_at: string;
                };
                Insert: {
                    id?: string;
                    job_type: string;
                    target_url?: string | undefined;
                    target_handle?: string | undefined;
                    platform?: string | undefined;
                    status?: 'pending' | 'running' | 'completed' | 'failed';
                    priority?: number;
                    scheduled_at?: string;
                    started_at?: string | undefined;
                    completed_at?: string | undefined;
                    data_collected?: Json | undefined;
                    errors?: string[] | undefined;
                    retry_count?: number;
                    max_retries?: number;
                    created_at?: string;
                };
                Update: {
                    id?: string;
                    job_type?: string;
                    target_url?: string | undefined;
                    target_handle?: string | undefined;
                    platform?: string | undefined;
                    status?: 'pending' | 'running' | 'completed' | 'failed';
                    priority?: number;
                    scheduled_at?: string;
                    started_at?: string | undefined;
                    completed_at?: string | undefined;
                    data_collected?: Json | undefined;
                    errors?: string[] | undefined;
                    retry_count?: number;
                    max_retries?: number;
                    created_at?: string;
                };
            };
            events: {
                Row: {
                    id: string;
                    food_truck_id: string | undefined;
                    title: string;
                    description: string | undefined;
                    event_date: string;
                    start_time: string | undefined;
                    end_time: string | undefined;
                    location_address: string | undefined;
                    location_lat: number | undefined;
                    location_lng: number | undefined;
                    created_at: string;
                    updated_at: string;
                };
                Insert: {
                    id?: string;
                    food_truck_id?: string | undefined;
                    title: string;
                    description?: string | undefined;
                    event_date: string;
                    start_time?: string | undefined;
                    end_time?: string | undefined;
                    location_address?: string | undefined;
                    location_lat?: number | undefined;
                    location_lng?: number | undefined;
                    created_at?: string;
                    updated_at?: string;
                };
                Update: {
                    id?: string;
                    food_truck_id?: string | undefined;
                    title?: string;
                    description?: string | undefined;
                    event_date?: string;
                    start_time?: string | undefined;
                    end_time?: string | undefined;
                    location_address?: string | undefined;
                    location_lat?: number | undefined;
                    location_lng?: number | undefined;
                    created_at?: string;
                    updated_at?: string;
                };
            };
            discovered_urls: {
                Row: {
                    id: string;
                    url: string;
                    source_directory_url: string | undefined;
                    region: string | undefined;
                    status: 'new' | 'processing' | 'processed' | 'irrelevant' | 'failed';
                    discovery_method: 'manual' | 'autonomous_search' | 'tavily_search' | 'firecrawl_crawl' | 'directory_crawl';
                    discovered_at: string;
                    last_processed_at: string | undefined;
                    processing_attempts: number;
                    notes: string | undefined;
                    metadata: Json | undefined;
                    created_at: string;
                    updated_at: string;
                };
                Insert: {
                    id?: string;
                    url: string;
                    source_directory_url?: string | undefined;
                    region?: string | undefined;
                    status?: 'new' | 'processing' | 'processed' | 'irrelevant' | 'failed';
                    discovery_method?: 'manual' | 'autonomous_search' | 'tavily_search' | 'firecrawl_crawl' | 'directory_crawl';
                    discovered_at?: string;
                    last_processed_at?: string | undefined;
                    processing_attempts?: number;
                    notes?: string | undefined;
                    metadata?: Json | undefined;
                    created_at?: string;
                    updated_at?: string;
                };
                Update: {
                    id?: string;
                    url?: string;
                    source_directory_url?: string | undefined;
                    region?: string | undefined;
                    status?: 'new' | 'processing' | 'processed' | 'irrelevant' | 'failed';
                    discovery_method?: 'manual' | 'autonomous_search' | 'tavily_search' | 'firecrawl_crawl' | 'directory_crawl';
                    discovered_at?: string;
                    last_processed_at?: string | undefined;
                    processing_attempts?: number;
                    notes?: string | undefined;
                    metadata?: Json | undefined;
                    created_at?: string;
                    updated_at?: string;
                };
            };
            profiles: {
                Row: {
                    id: string;
                    user_id: string;
                    username: string | undefined;
                    full_name: string | undefined;
                    avatar_url: string | undefined;
                    updated_at: string;
                };
                Insert: {
                    id?: string;
                    user_id: string;
                    username?: string | undefined;
                    full_name?: string | undefined;
                    avatar_url?: string | undefined;
                    updated_at?: string;
                };
                Update: {
                    id?: string;
                    user_id?: string;
                    username?: string | undefined;
                    full_name?: string | undefined;
                    avatar_url?: string | undefined;
                    updated_at?: string;
                };
            };
        };
        Views: {
            [_ in never]: never;
        };
        Functions: {
            [_ in never]: never;
        };
        Enums: {
            [_ in never]: never;
        };
        CompositeTypes: {
            [_ in never]: never;
        };
    };
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/config.d.ts (Line 1:1 - Line 10:2), C:/AI/food-truck-finder-poc/dist/lib/lib/config.d.ts (Line 1:1 - Line 10:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn631" onclick="toggleCodeBlock('cloneGroup631', 'expandBtn631', 'collapseBtn631')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn631" onclick="toggleCodeBlock('cloneGroup631', 'expandBtn631', 'collapseBtn631')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup631"><code class="language-typescript text-sm text-gray-800">export declare const DEFAULT_SCRAPE_URLS: string[];
export declare const DEFAULT_STALENESS_THRESHOLD_DAYS: number;
export declare const SC_TARGET_CITIES: string[];
export declare const DISCOVERY_CONFIG: {
    maxUrlsPerRun: number;
    maxDepthCrawl: number;
    searchResultsLimit: number;
    batchSize: number;
    rateLimitDelayMs: number;
};</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/autoScraper.d.ts (Line 1:1 - Line 139:2), C:/AI/food-truck-finder-poc/dist/lib/lib/autoScraper.d.ts (Line 1:1 - Line 139:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn633" onclick="toggleCodeBlock('cloneGroup633', 'expandBtn633', 'collapseBtn633')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn633" onclick="toggleCodeBlock('cloneGroup633', 'expandBtn633', 'collapseBtn633')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup633"><code class="language-typescript text-sm text-gray-800">interface TriggerScrapingProcessResult {
    success: boolean;
    jobId?: string;
    message?: string;
    error?: string;
}
export interface AutoScrapeResult {
    trucksProcessed: number;
    newTrucksFound: number;
    errors: Array&lt;{
        url: string;
        details?: string;
    }&gt;;
}
interface GeminiUsageLimits {
    canMakeRequest: boolean;
}
interface ProcessedMenuData {
    menu: Array&lt;{
        category: string;
        items: Array&lt;{
            name: string;
            description?: string;
            price?: number;
            dietary_tags?: string[];
        }&gt;;
    }&gt;;
}
interface ExtractedLocationData {
    location: {
        address?: string;
        city?: string;
        state?: string;
        zip?: string;
        coordinates?: {
            latitude: number;
            longitude: number;
        };
    };
}
interface StandardizedOperatingHours {
    hours: Record&lt;string, string&gt;;
}
interface SentimentAnalysisResult {
    overall_sentiment: 'positive' | 'negative' | 'neutral';
    score: number;
}
interface EnhancedFoodTruckData {
    description: string;
    cuisine_type: string[];
    specialties: string[];
}
interface GeminiService {
    checkUsageLimits(): Promise&lt;GeminiUsageLimits&gt;;
    processMenuData(input: unknown): Promise&lt;ProcessedMenuData&gt;;
    extractLocationFromText(input: unknown): Promise&lt;ExtractedLocationData&gt;;
    standardizeOperatingHours(input: unknown): Promise&lt;StandardizedOperatingHours&gt;;
    analyzeSentiment(input: unknown): Promise&lt;SentimentAnalysisResult&gt;;
    enhanceFoodTruckData(input: unknown): Promise&lt;EnhancedFoodTruckData&gt;;
}
/**
 * Initiates a web scraping process for a given target URL.
 * @example
 * triggerScrapingProcess('https://example.com')
 * { success: true, jobId: '12345', message: 'Scraping job created and processing initiated for https://example.com.' }
 * @param {string} targetUrl - The URL of the website to be scraped.
 * @returns {Promise&lt;TriggerScrapingProcessResult&gt;} Result of the attempt to trigger the scraping process, including success status, job ID, and message or error.
 * @description
 *   - Creates a web scraping job with a priority of 5 and triggers its processing.
 *   - Handles errors during job creation or processing gracefully.
 *   - Uses the current timestamp to schedule the job.
 */
declare function triggerScrapingProcess(targetUrl: string): Promise&lt;TriggerScrapingProcessResult&gt;;
/**
 * Initiates the autonomous scraping process and ensures default trucks data is fetched.
 * @example
 * ensureDefaultTrucksAreScraped()
 * Returns a result object containing the number of trucks processed, new trucks found, and any errors encountered.
 * @returns {Promise&lt;AutoScrapeResult&gt;} An object containing the results of the scraping process, including processed trucks count, new trucks discovered count, and encountered errors.
 * @description
 *   - Combines static default URLs with dynamically discovered URLs for scraping.
 *   - Handles both existing and new trucks, updating counters and tracking errors.
 *   - Logs process information and warnings for unexpected errors during execution.
 */
export declare function ensureDefaultTrucksAreScraped(): Promise&lt;AutoScrapeResult&gt;;
/**
 * Makes a call to Gemini service and caches the result to optimize performance.
 * @example
 * callGeminiWithCache('getData', { id: 123 }, geminiInstance)
 * // returns the result from the Gemini service or cache
 * @param {string} type - The type of operation to perform with Gemini.
 * @param {unknown} input - The input data required for the Gemini operation.
 * @param {GeminiService} gemini - The instance of GeminiService to interact with.
 * @returns {Promise&lt;unknown&gt;} Returns a promise that resolves to the result of the Gemini operation.
 * @description
 *   - Caches the result of Gemini service calls to avoid redundant requests.
 *   - Automatically cleans up expired cache entries based on a specified TTL.
 *   - Checks Gemini usage limits before making API calls to prevent exceeding the daily cap.
 *   - Constructs a unique cache key for each request using the operation type and input.
 */
export declare function callGeminiWithCache(type: string, input: unknown, gemini: GeminiService): Promise&lt;unknown&gt;;
/**
* Retrieves a list of URLs that are ready for scraping.
* @example
* getUrlsToScrape()
* // Returns a Promise that resolves to an array of URLs
* @param {void} - This function does not take any arguments.
* @returns {Promise&lt;string[]&gt;} A promise that resolves to an array of URLs to be scraped.
* @description
*   - The function returns a combination of default URLs and dynamically discovered URLs.
*   - Utilizes Supabase to fetch URLs marked with 'new' or 'processed' status.
*   - Limits results to prevent system overload, fetching a maximum of 100 URLs.
*   - Handles errors gracefully, logging warnings if the Supabase client is not available or if there is an error in fetching URLs.
*/
declare function getUrlsToScrape(): Promise&lt;string[]&gt;;
/**
 * Updates the status of a discovered URL in the database.
 * @example
 * updateDiscoveredUrlStatus('http://example.com', 'processed', 'Page successfully processed')
 * // Returns: void
 * @param {string} url - The URL whose status needs updating.
 * @param {'processing' | 'processed' | 'irrelevant'} status - The new status for the URL.
 * @param {string} [notes] - Optional notes regarding the URL status update.
 * @returns {Promise&lt;void&gt;} Resolves when the update operation is complete.
 * @description
 *   - Logs a warning if the Supabase admin client is not available.
 *   - Uses Supabase to update the status and logs an error if the operation fails.
 *   - Assumes the existence of a 'discovered_urls' table in the database.
 */
declare function updateDiscoveredUrlStatus(url: string, status: 'processing' | 'processed' | 'irrelevant', notes?: string): Promise&lt;void&gt;;
export declare const autoScraper: {
    runAutoScraping: typeof ensureDefaultTrucksAreScraped;
    triggerScrapingProcess: typeof triggerScrapingProcess;
    callGeminiWithCache: typeof callGeminiWithCache;
    getUrlsToScrape: typeof getUrlsToScrape;
    updateDiscoveredUrlStatus: typeof updateDiscoveredUrlStatus;
};
export declare function runAutonomousScraping(): Promise&lt;AutoScrapeResult&gt;;
export {};</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/activityLogger.d.ts (Line 1:1 - Line 22:2), C:/AI/food-truck-finder-poc/dist/lib/lib/activityLogger.d.ts (Line 1:1 - Line 22:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn635" onclick="toggleCodeBlock('cloneGroup635', 'expandBtn635', 'collapseBtn635')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn635" onclick="toggleCodeBlock('cloneGroup635', 'expandBtn635', 'collapseBtn635')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup635"><code class="language-typescript text-sm text-gray-800">interface ActivityLogEntry {
    type: 'cron_job' | 'manual_scrape' | 'system_event' | 'user_action';
    action: string;
    details: Record&lt;string, unknown&gt;;
    timestamp?: string;
}
/**
* Logs an activity entry with a timestamp and unique ID.
* @example
* logActivity({ action: 'user_login', username: 'johndoe' })
* undefined
* @param {ActivityLogEntry} entry - The activity entry to be logged.
* @returns {void} No return value.
* @description
*   - If `timestamp` is not provided in the entry, the current ISO timestamp is used.
*   - A unique ID is generated and added to the log entry.
*   - Logs activity data to the console in a structured format.
*   - Intended for development, but can be extended for production use with database or monitoring integration.
*/
export declare function logActivity(entry: ActivityLogEntry): void;
export declare function getActivityLogs(_type?: string, _limit?: number): ActivityLogEntry[];
export {};</code></pre></div><!-- Add more clone groups for .txt format as needed         // Add more clone groups for .txt format as needed--></div><a name="jsx-clones"></a><h2 class="text-2xl font-semibold text-gray-700 mb-4">jsx</h2><div class="divide-y divide-gray-200 border-b-2"><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/components/admin/dashboard/TotalFoodTrucksCard.jsx (Line 1:1 - Line 26:2), C:/AI/food-truck-finder-poc/dist/lib/components/admin/dashboard/TotalFoodTrucksCard.jsx (Line 1:1 - Line 26:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn103" onclick="toggleCodeBlock('cloneGroup103', 'expandBtn103', 'collapseBtn103')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn103" onclick="toggleCodeBlock('cloneGroup103', 'expandBtn103', 'collapseBtn103')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup103"><code class="language-jsx text-sm text-gray-800">import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Truck } from 'lucide-react';
/**
 * Renders a card displaying the total number of food trucks and pending verifications.
 * @example
 * TotalFoodTrucksCard({ totalFoodTrucks: 24, pendingVerifications: 3 })
 * // returns a React component with the total food trucks as 24 and 3 pending verification.
 * @param {Readonly&lt;TotalFoodTrucksCardProps&gt;} {totalFoodTrucks, pendingVerifications} - Props containing the number of total food trucks and pending verifications.
 * @returns {JSX.Element} A JSX element representing the TotalFoodTrucksCard component.
 * @description
 *   - Utilizes React functional component syntax.
 *   - Uses Tailwind CSS for styling.
 *   - Card displays current numbers of food trucks and verifications dynamically.
 */
export function TotalFoodTrucksCard({ totalFoodTrucks, pendingVerifications, }) {
    return (&lt;Card&gt;
      &lt;CardHeader className=&quot;flex flex-row items-center justify-between space-y-0 pb-2&quot;&gt;
        &lt;CardTitle className=&quot;text-sm font-medium&quot;&gt;Total Food Trucks&lt;/CardTitle&gt;
        &lt;Truck className=&quot;size-4 text-muted-foreground&quot;/&gt;
      &lt;/CardHeader&gt;
      &lt;CardContent&gt;
        &lt;div className=&quot;text-2xl font-bold&quot;&gt;{totalFoodTrucks}&lt;/div&gt;
        &lt;p className=&quot;text-xs text-muted-foreground&quot;&gt;{pendingVerifications} pending verification&lt;/p&gt;
      &lt;/CardContent&gt;
    &lt;/Card&gt;);
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/components/admin/dashboard/RecentErrorsCard.jsx (Line 1:1 - Line 27:2), C:/AI/food-truck-finder-poc/dist/lib/components/admin/dashboard/RecentErrorsCard.jsx (Line 1:1 - Line 27:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn104" onclick="toggleCodeBlock('cloneGroup104', 'expandBtn104', 'collapseBtn104')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn104" onclick="toggleCodeBlock('cloneGroup104', 'expandBtn104', 'collapseBtn104')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup104"><code class="language-jsx text-sm text-gray-800">import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { AlertTriangle } from 'lucide-react';
/**
* Displays a card component that shows the count of recent error items from a data processing queue.
* @example
* RecentErrorsCard({ failedProcessingQueueItemsCount: 10 })
* Displays a card with the title &quot;Recent Errors&quot; and shows the value &quot;10&quot;.
* @param {Object} props - The properties object.
* @param {number} props.failedProcessingQueueItemsCount - The number of failed processing queue items.
* @returns {JSX.Element} A card component displaying the count of recent errors with relevant styling.
* @description
*   - Utilizes the Card, CardHeader, CardTitle, CardContent, and AlertTriangle components from the component library.
*   - Includes text styling for headers and counts to create a visual hierarchy.
*   - The AlertTriangle icon is used to indicate an error status visually.
*/
export function RecentErrorsCard({ failedProcessingQueueItemsCount, }) {
    return (&lt;Card&gt;
      &lt;CardHeader className=&quot;flex flex-row items-center justify-between space-y-0 pb-2&quot;&gt;
        &lt;CardTitle className=&quot;text-sm font-medium&quot;&gt;Recent Errors&lt;/CardTitle&gt;
        &lt;AlertTriangle className=&quot;size-4 text-muted-foreground&quot;/&gt;
      &lt;/CardHeader&gt;
      &lt;CardContent&gt;
        &lt;div className=&quot;text-2xl font-bold&quot;&gt;{failedProcessingQueueItemsCount}&lt;/div&gt;
        &lt;p className=&quot;text-xs text-muted-foreground&quot;&gt;from data processing queue&lt;/p&gt;
      &lt;/CardContent&gt;
    &lt;/Card&gt;);
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/components/admin/dashboard/QualityDistributionCard.jsx (Line 18:5 - Line 25:2), C:/AI/food-truck-finder-poc/dist/lib/components/admin/dashboard/QualityDistributionCard.jsx (Line 17:5 - Line 24:17)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn105" onclick="toggleCodeBlock('cloneGroup105', 'expandBtn105', 'collapseBtn105')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn105" onclick="toggleCodeBlock('cloneGroup105', 'expandBtn105', 'collapseBtn105')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup105"><code class="language-jsx text-sm text-gray-800">return (&lt;Card&gt;
      &lt;CardHeader className=&quot;flex flex-row items-center justify-between space-y-0 pb-2&quot;&gt;
        &lt;CardTitle className=&quot;text-sm font-medium&quot;&gt;Quality Distribution&lt;/CardTitle&gt;
        &lt;AlertTriangle className=&quot;size-4 text-muted-foreground&quot;/&gt;
      &lt;/CardHeader&gt;
      &lt;CardContent&gt;
        &lt;div className=&quot;text-2xl font-bold text-green-600&quot;&gt;
          {(</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/components/admin/dashboard/PipelineStatusCard.jsx (Line 1:1 - Line 36:2), C:/AI/food-truck-finder-poc/dist/lib/components/admin/dashboard/PipelineStatusCard.jsx (Line 1:1 - Line 36:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn106" onclick="toggleCodeBlock('cloneGroup106', 'expandBtn106', 'collapseBtn106')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn106" onclick="toggleCodeBlock('cloneGroup106', 'expandBtn106', 'collapseBtn106')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup106"><code class="language-jsx text-sm text-gray-800">import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Activity } from 'lucide-react';
/**
 * Renders a card displaying the status of pipeline jobs including pending, running, and failed counts.
 * @example
 * PipelineStatusCard({
 *   pendingScrapingJobsCount: 10,
 *   runningScrapingJobsCount: 5,
 *   failedScrapingJobsCount: 2
 * })
 * &lt;Card&gt;
 *   &lt;CardHeader&gt;...&lt;/CardHeader&gt;
 *   &lt;CardContent&gt;...&lt;/CardContent&gt;
 * &lt;/Card&gt;
 * @param {number} pendingScrapingJobsCount - The count of scraping jobs that are currently pending.
 * @param {number} runningScrapingJobsCount - The count of scraping jobs that are currently running.
 * @param {number} failedScrapingJobsCount - The count of scraping jobs that have failed.
 * @returns {JSX.Element} A card component displaying the pipeline status including counts of pending, running, and failed jobs.
 * @description
 *   - Utilizes Card, CardHeader, CardTitle, CardContent components for UI structure.
 *   - Applies flex and spacing utility classes for layout and styling.
 */
export function PipelineStatusCard({ pendingScrapingJobsCount, runningScrapingJobsCount, failedScrapingJobsCount, }) {
    return (&lt;Card&gt;
      &lt;CardHeader className=&quot;flex flex-row items-center justify-between space-y-0 pb-2&quot;&gt;
        &lt;CardTitle className=&quot;text-sm font-medium&quot;&gt;Pipeline Status&lt;/CardTitle&gt;
        &lt;Activity className=&quot;size-4 text-muted-foreground&quot;/&gt;
      &lt;/CardHeader&gt;
      &lt;CardContent&gt;
        &lt;div className=&quot;text-2xl font-bold&quot;&gt;{pendingScrapingJobsCount} pending&lt;/div&gt;
        &lt;p className=&quot;text-xs text-muted-foreground&quot;&gt;
          {runningScrapingJobsCount} running, {failedScrapingJobsCount} failed
        &lt;/p&gt;
      &lt;/CardContent&gt;
    &lt;/Card&gt;);
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/components/admin/dashboard/DataQualityScoreCard.jsx (Line 17:5 - Line 24:2), C:/AI/food-truck-finder-poc/dist/lib/components/admin/dashboard/DataQualityScoreCard.jsx (Line 16:5 - Line 23:17)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn107" onclick="toggleCodeBlock('cloneGroup107', 'expandBtn107', 'collapseBtn107')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn107" onclick="toggleCodeBlock('cloneGroup107', 'expandBtn107', 'collapseBtn107')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup107"><code class="language-jsx text-sm text-gray-800">return (&lt;Card&gt;
      &lt;CardHeader className=&quot;flex flex-row items-center justify-between space-y-0 pb-2&quot;&gt;
        &lt;CardTitle className=&quot;text-sm font-medium&quot;&gt;Data Quality Score&lt;/CardTitle&gt;
        &lt;Settings className=&quot;size-4 text-muted-foreground&quot;/&gt;
      &lt;/CardHeader&gt;
      &lt;CardContent&gt;
        &lt;div className=&quot;text-2xl font-bold&quot;&gt;
          {(((</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/app/admin/food-trucks/page.jsx (Line 1:1 - Line 19:4), C:/AI/food-truck-finder-poc/dist/lib/app/admin/food-trucks/page.jsx (Line 1:1 - Line 19:4)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn116" onclick="toggleCodeBlock('cloneGroup116', 'expandBtn116', 'collapseBtn116')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn116" onclick="toggleCodeBlock('cloneGroup116', 'expandBtn116', 'collapseBtn116')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup116"><code class="language-jsx text-sm text-gray-800">import { FoodTruckService } from '@/lib/supabase';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow, } from '@/components/ui/table';
import { Badge } from '@/components/ui/badge';
import { Button } from '@/components/ui/button';
import { PlusCircle } from 'lucide-react';
import Link from 'next/link';
// Page header component
/**
 * Returns a JSX element representing the page header for the Food Truck Management administration section.
 * @example
 * PageHeader()
 * &lt;div className=&quot;flex items-center justify-between&quot;&gt;...&lt;/div&gt;
 * @returns {JSX.Element} A JSX element containing the page title and &quot;Add Food Truck&quot; button.
 * @description
 *   - Utilizes Tailwind CSS classes for styling and layout.
 *   - Renders a button linking to the &quot;new food truck&quot; creation page.
 *   - Adds an icon inside the button for visual enhancement.
 */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/app/admin/food-trucks/page.jsx (Line 20:1 - Line 58:4), C:/AI/food-truck-finder-poc/dist/lib/app/admin/food-trucks/page.jsx (Line 20:1 - Line 58:4)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn117" onclick="toggleCodeBlock('cloneGroup117', 'expandBtn117', 'collapseBtn117')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn117" onclick="toggleCodeBlock('cloneGroup117', 'expandBtn117', 'collapseBtn117')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup117"><code class="language-jsx text-sm text-gray-800">function PageHeader() {
    return (&lt;div className=&quot;flex items-center justify-between&quot;&gt;
      &lt;h1 className=&quot;text-3xl font-bold tracking-tight&quot;&gt;Food Truck Management&lt;/h1&gt;
      &lt;Button asChild&gt;
        &lt;Link href=&quot;/admin/food-trucks/new&quot;&gt;
          &lt;PlusCircle className=&quot;size-4 mr-2&quot;/&gt;
          Add Food Truck
        &lt;/Link&gt;
      &lt;/Button&gt;
    &lt;/div&gt;);
}
// Quality score helper functions
function getQualityScoreVariant(score) {
    if (score &gt;= 0.8)
        return 'default';
    if (score &gt;= 0.6)
        return 'secondary';
    return 'destructive';
}
function getQualityScoreLabel(score) {
    if (score &gt;= 0.8)
        return 'High';
    if (score &gt;= 0.6)
        return 'Medium';
    return 'Low';
}
// Food truck table row component
/**
 * Renders a table row for displaying food truck information.
 * @example
 * FoodTruckTableRow({ truck })
 * Returns a JSX element representing a table row with food truck info.
 * @param {Object} truck - Contains information about the food truck to be displayed.
 * @returns {JSX.Element} A table row with cells displaying food truck details like name, contact info, cuisine, etc.
 * @description
 *   - Displays contact info only when available; otherwise, shows a 'No contact info' message.
 *   - Formats and shows a quality score as a percentage with an associated badge.
 *   - Includes an &quot;Edit&quot; button linking to the food truck's admin page.
 */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/app/admin/food-trucks/page.jsx (Line 74:2 - Line 113:4), C:/AI/food-truck-finder-poc/dist/lib/app/admin/food-trucks/page.jsx (Line 73:2 - Line 112:4)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn118" onclick="toggleCodeBlock('cloneGroup118', 'expandBtn118', 'collapseBtn118')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn118" onclick="toggleCodeBlock('cloneGroup118', 'expandBtn118', 'collapseBtn118')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup118"><code class="language-jsx text-sm text-gray-800">'N/A'}&lt;/TableCell&gt;
      &lt;TableCell&gt;
        &lt;Badge variant={truck.verification_status === 'verified' ? 'default' : 'outline'}&gt;
          {truck.verification_status}
        &lt;/Badge&gt;
      &lt;/TableCell&gt;
      &lt;TableCell&gt;
        &lt;div className=&quot;flex items-center gap-2&quot;&gt;
          &lt;span&gt;{(qualityScore * 100).toFixed(0)}%&lt;/span&gt;
          &lt;Badge variant={getQualityScoreVariant(qualityScore)} className=&quot;text-xs&quot;&gt;
            {getQualityScoreLabel(qualityScore)}
          &lt;/Badge&gt;
        &lt;/div&gt;
      &lt;/TableCell&gt;
      &lt;TableCell&gt;
        {truck.last_scraped_at == undefined
            ? 'N/A'
            : new Date(truck.last_scraped_at).toLocaleDateString()}
      &lt;/TableCell&gt;
      &lt;TableCell className=&quot;text-right&quot;&gt;
        &lt;Button asChild&gt;
          &lt;Link href={`/admin/food-trucks/${truck.id}`}&gt;Edit&lt;/Link&gt;
        &lt;/Button&gt;
      &lt;/TableCell&gt;
    &lt;/TableRow&gt;);
}
// Food trucks table component
/**
 * Displays a table of food trucks with detailed information
 * @example
 * FoodTrucksTable({ trucks: [{ id: 1, name: 'Truck 1' }], total: 10 })
 * // Returns a JSX element rendering the table
 * @param {{readonly trucks: FoodTruck[], readonly total: number}} props - An object containing an array of food trucks and the total count of trucks.
 * @returns {JSX.Element} A React component that displays a table of food trucks.
 * @description
 *   - Renders a table inside a card layout to manage food truck details.
 *   - Shows various attributes like Name, Contact, and Cuisine of each food truck.
 *   - Maps through the trucks array to create a row for each food truck using the FoodTruckTableRow component.
 *   - Provides a descriptive header highlighting the total count of food trucks.
 */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/app/admin/food-trucks/page.jsx (Line 114:1 - Line 148:2), C:/AI/food-truck-finder-poc/dist/lib/app/admin/food-trucks/page.jsx (Line 113:1 - Line 147:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn119" onclick="toggleCodeBlock('cloneGroup119', 'expandBtn119', 'collapseBtn119')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn119" onclick="toggleCodeBlock('cloneGroup119', 'expandBtn119', 'collapseBtn119')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup119"><code class="language-jsx text-sm text-gray-800">function FoodTrucksTable({ trucks, total, }) {
    return (&lt;Card&gt;
      &lt;CardHeader&gt;
        &lt;CardTitle&gt;Food Trucks&lt;/CardTitle&gt;
        &lt;CardDescription&gt;
          Manage your food trucks and their details. ({total} total)
        &lt;/CardDescription&gt;
      &lt;/CardHeader&gt;
      &lt;CardContent&gt;
        &lt;Table&gt;
          &lt;TableHeader&gt;
            &lt;TableRow&gt;
              &lt;TableHead&gt;Name&lt;/TableHead&gt;
              &lt;TableHead&gt;Contact&lt;/TableHead&gt;
              &lt;TableHead&gt;Cuisine&lt;/TableHead&gt;
              &lt;TableHead&gt;Status&lt;/TableHead&gt;
              &lt;TableHead&gt;Quality Score&lt;/TableHead&gt;
              &lt;TableHead&gt;Last Scraped&lt;/TableHead&gt;
              &lt;TableHead className=&quot;text-right&quot;&gt;Actions&lt;/TableHead&gt;
            &lt;/TableRow&gt;
          &lt;/TableHeader&gt;
          &lt;TableBody&gt;
            {trucks.map((truck) =&gt; (&lt;FoodTruckTableRow key={truck.id} truck={truck}/&gt;))}
          &lt;/TableBody&gt;
        &lt;/Table&gt;
      &lt;/CardContent&gt;
    &lt;/Card&gt;);
}
export default async function FoodTruckManagementPage() {
    const { trucks, total } = await FoodTruckService.getAllTrucks(100, 0); // Fetch first 100 trucks
    return (&lt;div className=&quot;flex flex-col gap-4&quot;&gt;
      &lt;PageHeader /&gt;
      &lt;FoodTrucksTable trucks={trucks} total={total}/&gt;
    &lt;/div&gt;);
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/app/admin/events/page.jsx (Line 1:2 - Line 6:2), C:/AI/food-truck-finder-poc/dist/lib/app/admin/food-trucks/page.jsx (Line 1:2 - Line 6:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn120" onclick="toggleCodeBlock('cloneGroup120', 'expandBtn120', 'collapseBtn120')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn120" onclick="toggleCodeBlock('cloneGroup120', 'expandBtn120', 'collapseBtn120')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup120"><code class="language-jsx text-sm text-gray-800">} from '@/lib/supabase';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow, } from '@/components/ui/table';
import { Badge } from '@/components/ui/badge';
import { Button } from '@/components/ui/button';
import { PlusCircle,</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/app/admin/events/page.jsx (Line 162:17 - Line 177:7), C:/AI/food-truck-finder-poc/dist/app/admin/events/page.jsx (Line 103:2 - Line 118:29)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn121" onclick="toggleCodeBlock('cloneGroup121', 'expandBtn121', 'collapseBtn121')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn121" onclick="toggleCodeBlock('cloneGroup121', 'expandBtn121', 'collapseBtn121')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup121"><code class="language-jsx text-sm text-gray-800">&lt;/TableCell&gt;
                &lt;TableCell className=&quot;text-right&quot;&gt;
                  &lt;Button asChild&gt;
                    &lt;Link href={`/admin/schedules/${schedule.id}`}&gt;
                      &lt;Edit className=&quot;size-4&quot;/&gt;
                      &lt;span className=&quot;sr-only&quot;&gt;Edit&lt;/span&gt;
                    &lt;/Link&gt;
                  &lt;/Button&gt;
                &lt;/TableCell&gt;
              &lt;/TableRow&gt;))}
          &lt;/TableBody&gt;
        &lt;/Table&gt;
      &lt;/CardContent&gt;
    &lt;/Card&gt;);
}
export</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/app/admin/data-quality/page.jsx (Line 1:2 - Line 6:5), C:/AI/food-truck-finder-poc/dist/app/admin/events/page.jsx (Line 1:2 - Line 6:11)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn122" onclick="toggleCodeBlock('cloneGroup122', 'expandBtn122', 'collapseBtn122')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn122" onclick="toggleCodeBlock('cloneGroup122', 'expandBtn122', 'collapseBtn122')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup122"><code class="language-jsx text-sm text-gray-800">supabase } from '@/lib/supabase';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow, } from '@/components/ui/table';
import { Badge } from '@/components/ui/badge';
import { Button } from '@/components/ui/button';
import { Edit</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/app/admin/data-quality/page.jsx (Line 111:6 - Line 121:2), C:/AI/food-truck-finder-poc/dist/lib/app/admin/food-trucks/page.jsx (Line 85:4 - Line 94:5)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn123" onclick="toggleCodeBlock('cloneGroup123', 'expandBtn123', 'collapseBtn123')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn123" onclick="toggleCodeBlock('cloneGroup123', 'expandBtn123', 'collapseBtn123')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup123"><code class="language-jsx text-sm text-gray-800">&gt;
      &lt;/TableCell&gt;
      &lt;TableCell&gt;
        {truck.last_scraped_at == undefined
            ? 'N/A'
            : new Date(truck.last_scraped_at).toLocaleDateString()}
      &lt;/TableCell&gt;
      &lt;TableCell className=&quot;text-right&quot;&gt;
        &lt;Button asChild&gt;
          &lt;Link href={`/admin/food-trucks/${truck.id}`}&gt;
            &lt;</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/app/admin/analytics/page.jsx (Line 1:1 - Line 88:2), C:/AI/food-truck-finder-poc/dist/lib/app/admin/analytics/page.jsx (Line 1:1 - Line 88:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn124" onclick="toggleCodeBlock('cloneGroup124', 'expandBtn124', 'collapseBtn124')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn124" onclick="toggleCodeBlock('cloneGroup124', 'expandBtn124', 'collapseBtn124')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup124"><code class="language-jsx text-sm text-gray-800">import { APIUsageService } from '@/lib/supabase';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow, } from '@/components/ui/table';
import { BarChart3 } from 'lucide-react';
// API Usage Statistics Table Component
/**
 * Renders a table displaying API usage statistics.
 * @example
 * APIUsageTable({usageStats: [{id: '1', service_name: 'ServiceA', usage_date: '2023-01-01', requests_count: 100, tokens_used: 50}]})
 * // Renders a card with a table showing service name, usage date, request count, and tokens used.
 * @param {Object} {usageStats} - An object containing usage statistics.
 * @param {Array} usageStats - Array of usage statistic objects.
 * @param {string} usageStats[].id - Unique identifier for the statistic entry.
 * @param {string} usageStats[].service_name - Name of the service.
 * @param {string} usageStats[].usage_date - Date of the usage in ISO format.
 * @param {number} usageStats[].requests_count - Number of requests made.
 * @param {number} usageStats[].tokens_used - Number of tokens used.
 * @returns {JSX.Element} A React component rendering API usage statistics in a table format.
 * @description
 *   - Transforms each usage date into a locale-specific date string.
 *   - Iterates through `usageStats` to populate table rows.
 */
function APIUsageTable({ usageStats, }) {
    return (&lt;Card&gt;
      &lt;CardHeader&gt;
        &lt;CardTitle&gt;API Usage Statistics&lt;/CardTitle&gt;
        &lt;CardDescription&gt;
          Monitor API requests and token usage for various services.
        &lt;/CardDescription&gt;
      &lt;/CardHeader&gt;
      &lt;CardContent&gt;
        &lt;Table&gt;
          &lt;TableHeader&gt;
            &lt;TableRow&gt;
              &lt;TableHead&gt;Service Name&lt;/TableHead&gt;
              &lt;TableHead&gt;Usage Date&lt;/TableHead&gt;
              &lt;TableHead&gt;Requests Count&lt;/TableHead&gt;
              &lt;TableHead&gt;Tokens Used&lt;/TableHead&gt;
            &lt;/TableRow&gt;
          &lt;/TableHeader&gt;
          &lt;TableBody&gt;
            {usageStats.map((stat) =&gt; (&lt;TableRow key={stat.id}&gt;
                &lt;TableCell className=&quot;font-medium&quot;&gt;{stat.service_name}&lt;/TableCell&gt;
                &lt;TableCell&gt;{new Date(stat.usage_date).toLocaleDateString()}&lt;/TableCell&gt;
                &lt;TableCell&gt;{stat.requests_count}&lt;/TableCell&gt;
                &lt;TableCell&gt;{stat.tokens_used}&lt;/TableCell&gt;
              &lt;/TableRow&gt;))}
          &lt;/TableBody&gt;
        &lt;/Table&gt;
      &lt;/CardContent&gt;
    &lt;/Card&gt;);
}
// Data Trends Placeholder Component
/**
 * Renders a placeholder component to represent food truck data trends.
 * @example
 * DataTrendsPlaceholder()
 * &lt;Card&gt; ... &lt;/Card&gt;
 * @returns {JSX.Element} A JSX element containing placeholder content for future data trend visualizations.
 * @description
 *   - Utilizes the Card component to encapsulate the placeholder content.
 *   - Displays a header specifying the focus on food truck data trends.
 *   - Includes a notification for upcoming advanced charts and visualizations.
 */
function DataTrendsPlaceholder() {
    return (&lt;Card&gt;
      &lt;CardHeader&gt;
        &lt;CardTitle&gt;Food Truck Data Trends&lt;/CardTitle&gt;
        &lt;CardDescription&gt;
          Visualize trends in new food truck additions, menu changes, and event activity.
        &lt;/CardDescription&gt;
      &lt;/CardHeader&gt;
      &lt;CardContent&gt;
        &lt;div className=&quot;flex items-center justify-center h-48 text-muted-foreground&quot;&gt;
          &lt;BarChart3 className=&quot;size-12 mr-2&quot;/&gt;
          Coming Soon: Advanced Charts &amp; Visualizations
        &lt;/div&gt;
      &lt;/CardContent&gt;
    &lt;/Card&gt;);
}
export default async function AnalyticsPage() {
    const usageStats = await APIUsageService.getAllUsageStats();
    return (&lt;div className=&quot;flex flex-col gap-4&quot;&gt;
      &lt;h1 className=&quot;text-2xl font-bold&quot;&gt;Analytics &amp; Reporting&lt;/h1&gt;
      &lt;APIUsageTable usageStats={usageStats}/&gt;
      &lt;DataTrendsPlaceholder /&gt;
    &lt;/div&gt;);
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/lib/performance/bundleAnalyzer.jsx (Line 1:1 - Line 78:4), C:/AI/food-truck-finder-poc/dist/lib/lib/performance/bundleAnalyzer.jsx (Line 1:1 - Line 76:7)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn194" onclick="toggleCodeBlock('cloneGroup194', 'expandBtn194', 'collapseBtn194')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn194" onclick="toggleCodeBlock('cloneGroup194', 'expandBtn194', 'collapseBtn194')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup194"><code class="language-jsx text-sm text-gray-800">/**
 * Bundle Size Analysis and Optimization Utilities
 * Provides insights and recommendations for bundle optimization
 */
import React from 'react';
/**
 * Bundle optimization recommendations based on analysis
 */
export function getBundleOptimizationRecommendations() {
    const recommendations = [
        // Code splitting recommendations
        'Implement dynamic imports for admin dashboard components',
        'Split authentication components into separate chunks',
        'Lazy load chart components (Recharts) only when needed',
        // Tree shaking recommendations
        'Use named imports instead of default imports for UI libraries',
        'Remove unused Lucide React icons',
        'Optimize Radix UI imports to only include used components',
        // External dependencies optimization
        'Consider replacing Recharts with a lighter charting library for simple charts',
        'Use Next.js Image component instead of external image libraries',
        'Minimize Supabase client bundle size by importing only needed functions',
        // Performance optimizations
        'Enable gzip compression in production',
        'Use Next.js bundle analyzer to identify large dependencies',
        'Implement service worker for caching static assets',
        // Modern JavaScript features
        'Use ES2020+ features for smaller bundle sizes',
        'Enable Next.js experimental optimizePackageImports',
        'Consider using SWC minification for better performance',
    ];
    return recommendations;
}
export const PERFORMANCE_BUDGETS = {
    maxBundleSize: 500, // 500KB total bundle
    maxChunkSize: 200, // 200KB per chunk
    maxInitialLoad: 300, // 300KB initial load
    maxAssetSize: 100, // 100KB per asset
};
/**
 * Check if bundle meets performance budgets
 */
export function checkPerformanceBudget(analysis) {
    const violations = [];
    // Check total bundle size
    if (analysis.totalSize != undefined &amp;&amp;
        analysis.totalSize &gt; PERFORMANCE_BUDGETS.maxBundleSize * 1024) {
        violations.push({
            metric: 'Total Bundle Size',
            actual: Math.round(analysis.totalSize / 1024),
            budget: PERFORMANCE_BUDGETS.maxBundleSize,
            severity: 'error',
        });
    }
    // Check individual chunk sizes
    if (analysis.chunks) {
        for (const chunk of analysis.chunks) {
            if (chunk.size &gt; PERFORMANCE_BUDGETS.maxChunkSize * 1024) {
                violations.push({
                    metric: `Chunk Size (${chunk.name})`,
                    actual: Math.round(chunk.size / 1024),
                    budget: PERFORMANCE_BUDGETS.maxChunkSize,
                    severity: 'warning',
                });
            }
        }
    }
    return {
        passed: violations.length === 0,
        violations,
    };
}
/**
 * Dynamic import utilities for code splitting
 */
/**
 * Optimized imports for common libraries
 */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/lib/performance/bundleAnalyzer.jsx (Line 76:1 - Line 205:2), C:/AI/food-truck-finder-poc/dist/lib/lib/performance/bundleAnalyzer.jsx (Line 88:1 - Line 217:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn195" onclick="toggleCodeBlock('cloneGroup195', 'expandBtn195', 'collapseBtn195')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn195" onclick="toggleCodeBlock('cloneGroup195', 'expandBtn195', 'collapseBtn195')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup195"><code class="language-jsx text-sm text-gray-800">/**
 * Optimized imports for common libraries
 */
export const OptimizedImports = {
    // Lucide React - use standard imports (tree-shaking handled by bundler)
    icons: {
        // Use regular lucide-react imports - modern bundlers handle tree-shaking
        Menu: () =&gt; import('lucide-react').then((mod) =&gt; ({ Menu: mod.Menu })),
        Search: () =&gt; import('lucide-react').then((mod) =&gt; ({ Search: mod.Search })),
        User: () =&gt; import('lucide-react').then((mod) =&gt; ({ User: mod.User })),
        BarChart3: () =&gt; import('lucide-react').then((mod) =&gt; ({ BarChart3: mod.BarChart3 })),
        Settings: () =&gt; import('lucide-react').then((mod) =&gt; ({ Settings: mod.Settings })),
        Database: () =&gt; import('lucide-react').then((mod) =&gt; ({ Database: mod.Database })),
    },
    // Radix UI - optimized imports
    ui: {
        Button: () =&gt; import('@radix-ui/react-slot').then((mod) =&gt; ({ Slot: mod.Slot })),
        Dialog: () =&gt; import('@radix-ui/react-dialog'),
        DropdownMenu: () =&gt; import('@radix-ui/react-dropdown-menu'),
    },
};
/**
 * Performance monitoring for bundle loading
 */
export class BundlePerformanceMonitor {
    static loadTimes = new Map();
    /**
     * Track chunk load time
     */
    static trackChunkLoad(chunkName, startTime) {
        const loadTime = performance.now() - startTime;
        this.loadTimes.set(chunkName, loadTime);
        // Log slow loading chunks
        if (loadTime &gt; 1000) {
            // More than 1 second
            console.warn(`Slow chunk load detected: ${chunkName} took ${loadTime.toFixed(2)}ms`);
        }
    }
    /**
     * Get chunk load statistics
     */
    static getLoadStats() {
        return [...this.loadTimes.entries()].map(([chunk, loadTime]) =&gt; ({
            chunk,
            loadTime,
        }));
    }
    /**
     * Get average load time
     */
    static getAverageLoadTime() {
        const times = [...this.loadTimes.values()];
        return times.length &gt; 0 ? times.reduce((sum, time) =&gt; sum + time, 0) / times.length : 0;
    }
}
/**
 * Code splitting helper for React components
 */
export function createLazyComponent(importFn, fallback) {
    const LazyComponent = React.lazy(importFn);
    /**
     * Wraps a lazy loaded component with performance monitoring.
     * @example
     * WrappedComponent(props);
     * Returns a React component wrapped with a Suspense fallback and performance tracking.
     * @param {React.ComponentProps&lt;T&gt;} props - The props for the wrapped lazy component.
     * @returns {React.ReactElement} A React element that wraps the lazy component within a Suspense fallback.
     * @description
     *   - Utilizes React's Suspense to handle lazy loading of components with a fallback UI.
     *   - Tracks the performance of the component chunk loading using BundlePerformanceMonitor.
     *   - Analyzes the load-time performance by capturing the start time at component mount.
     */
    return function WrappedComponent(props) {
        const startTime = performance.now();
        React.useEffect(() =&gt; {
            BundlePerformanceMonitor.trackChunkLoad(importFn.toString().slice(0, 50), // Use function string as identifier
            startTime);
        }, []);
        return (&lt;React.Suspense fallback={fallback ? React.createElement(fallback) : &lt;div&gt;Loading...&lt;/div&gt;}&gt;
        &lt;LazyComponent {...props}/&gt;
      &lt;/React.Suspense&gt;);
    };
}
/**
 * Bundle size recommendations based on current setup
 */
export function getProjectSpecificRecommendations() {
    return [
        {
            category: 'Code Splitting',
            priority: 'high',
            recommendations: [
                'Split admin dashboard into separate route chunks',
                'Lazy load Recharts components only when analytics page is accessed',
                'Dynamic import authentication components',
                'Separate map components into their own chunk',
            ],
        },
        {
            category: 'Dependency Optimization',
            priority: 'medium',
            recommendations: [
                'Use tree-shaking for Lucide React icons',
                'Optimize Radix UI imports to only include used components',
                'Consider lighter alternatives to heavy dependencies',
                'Use Next.js optimizePackageImports for @radix-ui',
            ],
        },
        {
            category: 'Asset Optimization',
            priority: 'medium',
            recommendations: [
                'Optimize images with Next.js Image component',
                'Use WebP/AVIF formats for better compression',
                'Implement proper caching headers for static assets',
                'Minimize CSS bundle size with unused CSS removal',
            ],
        },
        {
            category: 'Runtime Optimization',
            priority: 'low',
            recommendations: [
                'Implement service worker for caching',
                'Use compression middleware in production',
                'Enable HTTP/2 server push for critical resources',
                'Implement resource hints (preload, prefetch)',
            ],
        },
    ];
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/lib/fallback/supabaseFallback.test.jsx (Line 57:77 - Line 64:42), C:/AI/food-truck-finder-poc/dist/lib/fallback/supabaseFallback.test.jsx (Line 37:57 - Line 44:26)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn226" onclick="toggleCodeBlock('cloneGroup226', 'expandBtn226', 'collapseBtn226')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn226" onclick="toggleCodeBlock('cloneGroup226', 'expandBtn226', 'collapseBtn226')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup226"><code class="language-jsx text-sm text-gray-800">, async () =&gt; {
        // Mock the supabase client to simulate an error
        supabaseFallback.supabase.from = jest.fn().mockReturnValue({
            select: jest.fn().mockReturnValue({
                abortSignal: jest.fn().mockRejectedValue(new Error('Supabase error')),
            }),
        });
        // Pre-populate the cache with stale data</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/lib/fallback/supabaseFallback.test.jsx (Line 68:5 - Line 73:8), C:/AI/food-truck-finder-poc/dist/lib/fallback/supabaseFallback.test.jsx (Line 48:2 - Line 53:9)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn227" onclick="toggleCodeBlock('cloneGroup227', 'expandBtn227', 'collapseBtn227')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn227" onclick="toggleCodeBlock('cloneGroup227', 'expandBtn227', 'collapseBtn227')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup227"><code class="language-jsx text-sm text-gray-800">).toLocaleString(),
        };
        window.localStorage.setItem('food-trucks-cache', JSON.stringify(cachedData));
        render(&lt;TestComponent /&gt;);
        await waitFor(() =&gt; {
            expect(screen.getByTestId('status')).toHaveTextContent('stale'</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/lib/fallback/supabaseFallback.test.jsx (Line 77:83 - Line 84:9), C:/AI/food-truck-finder-poc/dist/lib/fallback/supabaseFallback.test.jsx (Line 37:57 - Line 44:26)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn228" onclick="toggleCodeBlock('cloneGroup228', 'expandBtn228', 'collapseBtn228')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn228" onclick="toggleCodeBlock('cloneGroup228', 'expandBtn228', 'collapseBtn228')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup228"><code class="language-jsx text-sm text-gray-800">, async () =&gt; {
        // Mock the supabase client to simulate an error
        supabaseFallback.supabase.from = jest.fn().mockReturnValue({
            select: jest.fn().mockReturnValue({
                abortSignal: jest.fn().mockRejectedValue(new Error('Supabase error')),
            }),
        });
        function</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/lib/fallback/supabaseFallback.test.jsx (Line 84:25 - Line 90:7), C:/AI/food-truck-finder-poc/dist/lib/fallback/supabaseFallback.test.jsx (Line 15:14 - Line 21:4)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn229" onclick="toggleCodeBlock('cloneGroup229', 'expandBtn229', 'collapseBtn229')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn229" onclick="toggleCodeBlock('cloneGroup229', 'expandBtn229', 'collapseBtn229')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup229"><code class="language-jsx text-sm text-gray-800">() {
            const { trucks, loading, dataStatus } = useFoodTrucks();
            if (loading)
                return &lt;div&gt;Loading...&lt;/div&gt;;
            return (&lt;div&gt;
          &lt;div data-testid=&quot;status&quot;&gt;{dataStatus.status}&lt;/div&gt;
          {trucks.length</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/lib/fallback/supabaseFallback.jsx (Line 1:1 - Line 312:2), C:/AI/food-truck-finder-poc/dist/lib/lib/fallback/supabaseFallback.jsx (Line 1:1 - Line 312:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn230" onclick="toggleCodeBlock('cloneGroup230', 'expandBtn230', 'collapseBtn230')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn230" onclick="toggleCodeBlock('cloneGroup230', 'expandBtn230', 'collapseBtn230')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup230"><code class="language-jsx text-sm text-gray-800">// lib/fallback/supabaseFallback.tsx
// This creates a resilient data layer that gracefully handles Supabase outages
import { createClient } from '@supabase/supabase-js';
function isFoodTruckData(obj) {
    return (typeof obj === 'object' &amp;&amp;
        obj !== null &amp;&amp;
        'id' in obj &amp;&amp;
        'name' in obj &amp;&amp;
        'cuisine_type' in obj &amp;&amp;
        'price_range' in obj);
}
function isCachedData(obj) {
    return (typeof obj === 'object' &amp;&amp;
        obj !== null &amp;&amp;
        'trucks' in obj &amp;&amp;
        Array.isArray(obj.trucks) &amp;&amp;
        'timestamp' in obj &amp;&amp;
        'lastSuccessfulUpdate' in obj);
}
// Helper function to safely parse JSON with type validation
function safeJsonParse(jsonString, typeGuard) {
    try {
        const parsed = JSON.parse(jsonString);
        return typeGuard(parsed) ? parsed : undefined;
    }
    catch {
        return undefined;
    }
}
// Helper function to check if we're in a browser environment
function isBrowserEnvironment() {
    // Fixed: Use direct comparison with undefined instead of typeof
    return typeof globalThis !== 'undefined' &amp;&amp;
        globalThis.window != undefined &amp;&amp;
        globalThis.window === globalThis;
}
class SupabaseFallbackManager {
    CACHE_KEY = 'food-trucks-cache';
    TRUCK_CACHE_KEY_PREFIX = 'food-truck-';
    CACHE_DURATION = 24 * 60 * 60 * 1000; // 24 hours in milliseconds
    supabase;
    constructor() {
        if (process.env.NEXT_PUBLIC_SUPABASE_URL === undefined || process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY === undefined) {
            throw new Error('Supabase URL and Anon Key are required!');
        }
        this.supabase = createClient(process.env.NEXT_PUBLIC_SUPABASE_URL, process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY);
    }
    /**
     * This is your main data fetching function that handles all the fallback logic
     * Think of it as your &quot;smart&quot; data fetcher that adapts to different situations
     */
    async getFoodTrucks() {
        try {
            // First, try to get fresh data from Supabase
            const freshData = await this.fetchFromSupabase();
            if (freshData.length &gt; 0) {
                // Success! Cache this data for future fallback use
                this.cacheData(freshData);
                return {
                    trucks: freshData,
                    isFromCache: false,
                    lastUpdate: 'Just now',
                    status: 'fresh'
                };
            }
            // If we reach here, Supabase returned empty results
            // This might mean no trucks are available, or there's a data issue
            return this.handleFallbackScenario();
        }
        catch (error) {
            // Supabase is definitely having issues - engage fallback mode
            console.warn('Supabase unavailable, using fallback strategy:', error);
            return this.handleFallbackScenario();
        }
    }
    async getFoodTruckById(id) {
        const cachedTruck = this.getCachedTruck(id);
        if (cachedTruck !== null) {
            return cachedTruck;
        }
        try {
            const { data, error } = await this.supabase
                .from('food_trucks')
                .select('*')
                .eq('id', id)
                .single();
            if (error !== null) {
                throw new Error(`Supabase error: ${error.message}`);
            }
            // Fixed: Properly handle the data assignment with type checking
            if (data !== null &amp;&amp; isFoodTruckData(data)) {
                this.cacheTruck(data);
                return data;
            }
            return null;
        }
        catch (error) {
            console.warn(`Failed to fetch truck with id ${id} from Supabase, returning null.`, error);
            return null;
        }
    }
    /**
     * This handles the actual Supabase communication
     * Separated so you can easily modify your existing query logic
     */
    async fetchFromSupabase() {
        console.log(' Connecting to Supabase...');
        console.log(' Supabase URL:', process.env.NEXT_PUBLIC_SUPABASE_URL);
        console.log(' Anon key present:', !!process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY);
        try {
            // The key is to set a reasonable timeout so we don't wait forever
            const response = await this.supabase
                .from('food_trucks')
                .select('*')
                .abortSignal(AbortSignal.timeout(10000)); // 10 second timeout
            console.log(' Raw Supabase response:', response);
            console.log(' Response error:', response.error);
            console.log(' Response data type:', typeof response.data);
            console.log(' Response data length:', Array.isArray(response.data) ? response.data.length : 'Not an array');
            if (response.error !== null) {
                console.error(' Supabase query error details:', {
                    message: response.error.message,
                    details: response.error.details,
                    hint: response.error.hint,
                    code: response.error.code
                });
                throw new Error(`Supabase error: ${response.error.message}`);
            }
            // Fixed: Properly handle the data with explicit null checking
            if (response.data != undefined &amp;&amp; Array.isArray(response.data)) {
                console.log(' Found', response.data.length, 'raw records from Supabase');
                if (response.data.length &gt; 0) {
                    console.log(' Sample record:', JSON.stringify(response.data[0], null, 2));
                }
                const filteredData = response.data.filter((item) =&gt; {
                    const isValid = isFoodTruckData(item);
                    if (!isValid) {
                        console.warn(' Invalid food truck data found:', item);
                    }
                    return isValid;
                });
                console.log(' Filtered to', filteredData.length, 'valid food trucks');
                return filteredData;
            }
            console.warn(' No data returned from Supabase or data is not an array');
            return [];
        }
        catch (error) {
            console.error(' Error in fetchFromSupabase:', error);
            throw error;
        }
    }
    /**
     * This is where the magic happens - graceful degradation
     * When Supabase fails, we still provide value to users
     */
    handleFallbackScenario() {
        const cachedData = this.getCachedData();
        if (cachedData !== null) {
            const age = Date.now() - cachedData.timestamp;
            const isStale = age &gt; this.CACHE_DURATION;
            return {
                trucks: cachedData.trucks,
                isFromCache: true,
                lastUpdate: cachedData.lastSuccessfulUpdate,
                status: isStale ? 'stale' : 'cached'
            };
        }
        // No cached data available - this is the worst case scenario
        return {
            trucks: [],
            isFromCache: false,
            lastUpdate: 'Never',
            status: 'unavailable'
        };
    }
    /**
     * Stores successful data fetches for later use
     * This runs every time we successfully get data from Supabase
     */
    cacheData(trucks) {
        const cacheData = {
            trucks,
            timestamp: Date.now(),
            lastSuccessfulUpdate: new Date().toLocaleString()
        };
        try {
            // In a browser environment, use localStorage
            if (isBrowserEnvironment()) {
                globalThis.window.localStorage.setItem(this.CACHE_KEY, JSON.stringify(cacheData));
            }
            // In a server environment, you might use a file or Redis
            // For now, we'll just log that we would cache this data
            console.info(`Cached ${trucks.length} trucks at ${cacheData.lastSuccessfulUpdate}`);
        }
        catch (error) {
            // Caching failed, but that's not critical - log and continue
            console.warn('Failed to cache data:', error);
        }
    }
    cacheTruck(truck) {
        try {
            if (isBrowserEnvironment()) {
                const cacheKey = `${this.TRUCK_CACHE_KEY_PREFIX}${truck.id}`;
                globalThis.window.localStorage.setItem(cacheKey, JSON.stringify(truck));
            }
        }
        catch (error) {
            console.warn(`Failed to cache truck with id ${truck.id}:`, error);
        }
    }
    getCachedTruck(id) {
        try {
            if (isBrowserEnvironment()) {
                const cacheKey = `${this.TRUCK_CACHE_KEY_PREFIX}${id}`;
                const cached = globalThis.window.localStorage.getItem(cacheKey);
                if (cached !== null) {
                    // Fixed: Return the parsed result or null instead of undefined
                    return safeJsonParse(cached, isFoodTruckData) ?? null;
                }
            }
            return null;
        }
        catch (error) {
            console.warn(`Failed to retrieve cached truck with id ${id}:`, error);
            return null;
        }
    }
    /**
     * Retrieves cached data when Supabase is unavailable
     * This is your safety net
     */
    getCachedData() {
        try {
            if (isBrowserEnvironment()) {
                const cached = globalThis.window.localStorage.getItem(this.CACHE_KEY);
                if (cached !== null) {
                    // Fixed: Return the parsed result or null instead of undefined
                    return safeJsonParse(cached, isCachedData) ?? null;
                }
            }
            return null;
        }
        catch (error) {
            console.warn('Failed to retrieve cached data:', error);
            return null;
        }
    }
}
// Usage in your components - this replaces your direct Supabase calls
export const supabaseFallback = new SupabaseFallbackManager();
// Example React hook that uses the fallback system
import { useState, useEffect } from 'react';
export function useFoodTrucks() {
    const [trucks, setTrucks] = useState([]);
    const [loading, setLoading] = useState(true);
    const [dataStatus, setDataStatus] = useState({
        isFromCache: false,
        lastUpdate: '',
        status: 'fresh'
    });
    useEffect(() =&gt; {
        const loadTrucks = async () =&gt; {
            try {
                const result = await supabaseFallback.getFoodTrucks();
                setTrucks(result.trucks);
                setDataStatus({
                    isFromCache: result.isFromCache,
                    lastUpdate: result.lastUpdate,
                    status: result.status
                });
            }
            catch (error) {
                console.error('Failed to load trucks:', error);
                // Even this fails, we still want to show something
                setDataStatus({
                    isFromCache: false,
                    lastUpdate: 'Error',
                    status: 'unavailable'
                });
            }
            finally {
                setLoading(false);
            }
        };
        void loadTrucks(); // Use void to explicitly ignore the Promise
    }, []);
    return { trucks, loading, dataStatus };
}
// Component that displays appropriate messages based on data status
export function DataStatusIndicator({ status, }) {
    if (status.status === 'fresh') {
        // Fixed: Return null instead of undefined when no component should render
        return;
    }
    if (status.status === 'cached') {
        return (&lt;div className=&quot;bg-blue-100 border border-blue-300 text-blue-800 px-4 py-2 rounded&quot;&gt;
        Showing cached data from {status.lastUpdate}. Live data temporarily unavailable.
      &lt;/div&gt;);
    }
    if (status.status === 'stale') {
        return (&lt;div className=&quot;bg-yellow-100 border border-yellow-300 text-yellow-800 px-4 py-2 rounded&quot;&gt;
        Showing older data from {status.lastUpdate}. We're working to restore live updates.
      &lt;/div&gt;);
    }
    if (status.status === 'unavailable') {
        return (&lt;div className=&quot;bg-red-100 border border-red-300 text-red-800 px-4 py-2 rounded&quot;&gt;
        Service temporarily unavailable. Please check back in a few minutes.
      &lt;/div&gt;);
    }
    // Fixed: Return null instead of undefined for the fallback case
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/components/ui/ToggleGroup.jsx (Line 1:1 - Line 14:21), C:/AI/food-truck-finder-poc/dist/components/ui/tooltip.jsx (Line 1:1 - Line 14:17)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn244" onclick="toggleCodeBlock('cloneGroup244', 'expandBtn244', 'collapseBtn244')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn244" onclick="toggleCodeBlock('cloneGroup244', 'expandBtn244', 'collapseBtn244')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup244"><code class="language-jsx text-sm text-gray-800">'use client';
var __rest = (this &amp;&amp; this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) &amp;&amp; e.indexOf(p) &lt; 0)
        t[p] = s[p];
    if (s != null &amp;&amp; typeof Object.getOwnPropertySymbols === &quot;function&quot;)
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i &lt; p.length; i++) {
            if (e.indexOf(p[i]) &lt; 0 &amp;&amp; Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import * as React from 'react';
import * as ToggleGroupPrimitive</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/components/ui/toggle.jsx (Line 1:1 - Line 14:16), C:/AI/food-truck-finder-poc/dist/components/ui/tooltip.jsx (Line 1:1 - Line 14:17)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn245" onclick="toggleCodeBlock('cloneGroup245', 'expandBtn245', 'collapseBtn245')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn245" onclick="toggleCodeBlock('cloneGroup245', 'expandBtn245', 'collapseBtn245')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup245"><code class="language-jsx text-sm text-gray-800">'use client';
var __rest = (this &amp;&amp; this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) &amp;&amp; e.indexOf(p) &lt; 0)
        t[p] = s[p];
    if (s != null &amp;&amp; typeof Object.getOwnPropertySymbols === &quot;function&quot;)
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i &lt; p.length; i++) {
            if (e.indexOf(p[i]) &lt; 0 &amp;&amp; Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import * as React from 'react';
import * as TogglePrimitive</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/components/ui/toaster.jsx (Line 1:1 - Line 13:2), C:/AI/food-truck-finder-poc/dist/components/ui/tooltip.jsx (Line 1:1 - Line 13:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn246" onclick="toggleCodeBlock('cloneGroup246', 'expandBtn246', 'collapseBtn246')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn246" onclick="toggleCodeBlock('cloneGroup246', 'expandBtn246', 'collapseBtn246')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup246"><code class="language-jsx text-sm text-gray-800">'use client';
var __rest = (this &amp;&amp; this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) &amp;&amp; e.indexOf(p) &lt; 0)
        t[p] = s[p];
    if (s != null &amp;&amp; typeof Object.getOwnPropertySymbols === &quot;function&quot;)
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i &lt; p.length; i++) {
            if (e.indexOf(p[i]) &lt; 0 &amp;&amp; Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import {</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/components/ui/toast.jsx (Line 2:1 - Line 15:16), C:/AI/food-truck-finder-poc/dist/components/ui/tooltip.jsx (Line 1:1 - Line 14:17)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn247" onclick="toggleCodeBlock('cloneGroup247', 'expandBtn247', 'collapseBtn247')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn247" onclick="toggleCodeBlock('cloneGroup247', 'expandBtn247', 'collapseBtn247')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup247"><code class="language-jsx text-sm text-gray-800">'use client';
var __rest = (this &amp;&amp; this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) &amp;&amp; e.indexOf(p) &lt; 0)
        t[p] = s[p];
    if (s != null &amp;&amp; typeof Object.getOwnPropertySymbols === &quot;function&quot;)
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i &lt; p.length; i++) {
            if (e.indexOf(p[i]) &lt; 0 &amp;&amp; Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import * as React from 'react';
import * as ToastPrimitives</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/components/ui/textarea.jsx (Line 1:1 - Line 13:2), C:/AI/food-truck-finder-poc/dist/components/ui/tooltip.jsx (Line 2:1 - Line 14:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn248" onclick="toggleCodeBlock('cloneGroup248', 'expandBtn248', 'collapseBtn248')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn248" onclick="toggleCodeBlock('cloneGroup248', 'expandBtn248', 'collapseBtn248')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup248"><code class="language-jsx text-sm text-gray-800">var __rest = (this &amp;&amp; this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) &amp;&amp; e.indexOf(p) &lt; 0)
        t[p] = s[p];
    if (s != null &amp;&amp; typeof Object.getOwnPropertySymbols === &quot;function&quot;)
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i &lt; p.length; i++) {
            if (e.indexOf(p[i]) &lt; 0 &amp;&amp; Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import * as React from 'react';
import {</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/components/ui/tabs.jsx (Line 1:1 - Line 14:14), C:/AI/food-truck-finder-poc/dist/components/ui/tooltip.jsx (Line 1:1 - Line 14:17)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn249" onclick="toggleCodeBlock('cloneGroup249', 'expandBtn249', 'collapseBtn249')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn249" onclick="toggleCodeBlock('cloneGroup249', 'expandBtn249', 'collapseBtn249')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup249"><code class="language-jsx text-sm text-gray-800">'use client';
var __rest = (this &amp;&amp; this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) &amp;&amp; e.indexOf(p) &lt; 0)
        t[p] = s[p];
    if (s != null &amp;&amp; typeof Object.getOwnPropertySymbols === &quot;function&quot;)
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i &lt; p.length; i++) {
            if (e.indexOf(p[i]) &lt; 0 &amp;&amp; Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import * as React from 'react';
import * as TabsPrimitive</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/components/ui/table.jsx (Line 1:1 - Line 14:6), C:/AI/food-truck-finder-poc/dist/components/ui/tooltip.jsx (Line 2:1 - Line 14:9)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn251" onclick="toggleCodeBlock('cloneGroup251', 'expandBtn251', 'collapseBtn251')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn251" onclick="toggleCodeBlock('cloneGroup251', 'expandBtn251', 'collapseBtn251')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup251"><code class="language-jsx text-sm text-gray-800">var __rest = (this &amp;&amp; this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) &amp;&amp; e.indexOf(p) &lt; 0)
        t[p] = s[p];
    if (s != null &amp;&amp; typeof Object.getOwnPropertySymbols === &quot;function&quot;)
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i &lt; p.length; i++) {
            if (e.indexOf(p[i]) &lt; 0 &amp;&amp; Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import * as React from 'react';
import { cn } from '@/lib/utils';
const Table</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/components/ui/switch.jsx (Line 1:1 - Line 14:17), C:/AI/food-truck-finder-poc/dist/components/ui/tooltip.jsx (Line 1:1 - Line 14:17)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn252" onclick="toggleCodeBlock('cloneGroup252', 'expandBtn252', 'collapseBtn252')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn252" onclick="toggleCodeBlock('cloneGroup252', 'expandBtn252', 'collapseBtn252')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup252"><code class="language-jsx text-sm text-gray-800">'use client';
var __rest = (this &amp;&amp; this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) &amp;&amp; e.indexOf(p) &lt; 0)
        t[p] = s[p];
    if (s != null &amp;&amp; typeof Object.getOwnPropertySymbols === &quot;function&quot;)
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i &lt; p.length; i++) {
            if (e.indexOf(p[i]) &lt; 0 &amp;&amp; Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import * as React from 'react';
import * as SwitchPrimitives</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/components/ui/sonner.jsx (Line 1:1 - Line 14:8), C:/AI/food-truck-finder-poc/dist/components/ui/tooltip.jsx (Line 1:1 - Line 13:3)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn253" onclick="toggleCodeBlock('cloneGroup253', 'expandBtn253', 'collapseBtn253')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn253" onclick="toggleCodeBlock('cloneGroup253', 'expandBtn253', 'collapseBtn253')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup253"><code class="language-jsx text-sm text-gray-800">'use client';
var __rest = (this &amp;&amp; this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) &amp;&amp; e.indexOf(p) &lt; 0)
        t[p] = s[p];
    if (s != null &amp;&amp; typeof Object.getOwnPropertySymbols === &quot;function&quot;)
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i &lt; p.length; i++) {
            if (e.indexOf(p[i]) &lt; 0 &amp;&amp; Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import * as React from 'react';
import { Toaster</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/components/ui/slider.jsx (Line 1:1 - Line 14:16), C:/AI/food-truck-finder-poc/dist/components/ui/tooltip.jsx (Line 1:1 - Line 14:17)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn254" onclick="toggleCodeBlock('cloneGroup254', 'expandBtn254', 'collapseBtn254')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn254" onclick="toggleCodeBlock('cloneGroup254', 'expandBtn254', 'collapseBtn254')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup254"><code class="language-jsx text-sm text-gray-800">'use client';
var __rest = (this &amp;&amp; this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) &amp;&amp; e.indexOf(p) &lt; 0)
        t[p] = s[p];
    if (s != null &amp;&amp; typeof Object.getOwnPropertySymbols === &quot;function&quot;)
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i &lt; p.length; i++) {
            if (e.indexOf(p[i]) &lt; 0 &amp;&amp; Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import * as React from 'react';
import * as SliderPrimitive</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/components/ui/skeleton.jsx (Line 1:1 - Line 12:3), C:/AI/food-truck-finder-poc/dist/components/ui/tooltip.jsx (Line 2:1 - Line 13:9)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn255" onclick="toggleCodeBlock('cloneGroup255', 'expandBtn255', 'collapseBtn255')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn255" onclick="toggleCodeBlock('cloneGroup255', 'expandBtn255', 'collapseBtn255')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup255"><code class="language-jsx text-sm text-gray-800">var __rest = (this &amp;&amp; this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) &amp;&amp; e.indexOf(p) &lt; 0)
        t[p] = s[p];
    if (s != null &amp;&amp; typeof Object.getOwnPropertySymbols === &quot;function&quot;)
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i &lt; p.length; i++) {
            if (e.indexOf(p[i]) &lt; 0 &amp;&amp; Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import { cn</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/components/ui/sidebar.jsx (Line 1:1 - Line 14:5), C:/AI/food-truck-finder-poc/dist/components/ui/tooltip.jsx (Line 1:1 - Line 13:3)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn256" onclick="toggleCodeBlock('cloneGroup256', 'expandBtn256', 'collapseBtn256')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn256" onclick="toggleCodeBlock('cloneGroup256', 'expandBtn256', 'collapseBtn256')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup256"><code class="language-jsx text-sm text-gray-800">'use client';
var __rest = (this &amp;&amp; this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) &amp;&amp; e.indexOf(p) &lt; 0)
        t[p] = s[p];
    if (s != null &amp;&amp; typeof Object.getOwnPropertySymbols === &quot;function&quot;)
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i &lt; p.length; i++) {
            if (e.indexOf(p[i]) &lt; 0 &amp;&amp; Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import * as React from 'react';
import { Slot</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/components/ui/sheet.jsx (Line 1:1 - Line 15:15), C:/AI/food-truck-finder-poc/dist/components/ui/toast.jsx (Line 1:1 - Line 14:17)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn257" onclick="toggleCodeBlock('cloneGroup257', 'expandBtn257', 'collapseBtn257')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn257" onclick="toggleCodeBlock('cloneGroup257', 'expandBtn257', 'collapseBtn257')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup257"><code class="language-jsx text-sm text-gray-800">'use client';
'use client';
var __rest = (this &amp;&amp; this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) &amp;&amp; e.indexOf(p) &lt; 0)
        t[p] = s[p];
    if (s != null &amp;&amp; typeof Object.getOwnPropertySymbols === &quot;function&quot;)
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i &lt; p.length; i++) {
            if (e.indexOf(p[i]) &lt; 0 &amp;&amp; Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import * as React from 'react';
import * as SheetPrimitive</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/components/ui/separator.jsx (Line 1:1 - Line 14:19), C:/AI/food-truck-finder-poc/dist/components/ui/tooltip.jsx (Line 1:1 - Line 14:17)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn258" onclick="toggleCodeBlock('cloneGroup258', 'expandBtn258', 'collapseBtn258')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn258" onclick="toggleCodeBlock('cloneGroup258', 'expandBtn258', 'collapseBtn258')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup258"><code class="language-jsx text-sm text-gray-800">'use client';
var __rest = (this &amp;&amp; this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) &amp;&amp; e.indexOf(p) &lt; 0)
        t[p] = s[p];
    if (s != null &amp;&amp; typeof Object.getOwnPropertySymbols === &quot;function&quot;)
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i &lt; p.length; i++) {
            if (e.indexOf(p[i]) &lt; 0 &amp;&amp; Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import * as React from 'react';
import * as SeparatorPrimitive</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/components/ui/select.jsx (Line 1:1 - Line 14:16), C:/AI/food-truck-finder-poc/dist/components/ui/tooltip.jsx (Line 1:1 - Line 14:17)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn259" onclick="toggleCodeBlock('cloneGroup259', 'expandBtn259', 'collapseBtn259')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn259" onclick="toggleCodeBlock('cloneGroup259', 'expandBtn259', 'collapseBtn259')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup259"><code class="language-jsx text-sm text-gray-800">'use client';
var __rest = (this &amp;&amp; this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) &amp;&amp; e.indexOf(p) &lt; 0)
        t[p] = s[p];
    if (s != null &amp;&amp; typeof Object.getOwnPropertySymbols === &quot;function&quot;)
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i &lt; p.length; i++) {
            if (e.indexOf(p[i]) &lt; 0 &amp;&amp; Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import * as React from 'react';
import * as SelectPrimitive</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/components/ui/ScrollArea.jsx (Line 1:1 - Line 14:20), C:/AI/food-truck-finder-poc/dist/components/ui/tooltip.jsx (Line 1:1 - Line 14:17)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn260" onclick="toggleCodeBlock('cloneGroup260', 'expandBtn260', 'collapseBtn260')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn260" onclick="toggleCodeBlock('cloneGroup260', 'expandBtn260', 'collapseBtn260')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup260"><code class="language-jsx text-sm text-gray-800">'use client';
var __rest = (this &amp;&amp; this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) &amp;&amp; e.indexOf(p) &lt; 0)
        t[p] = s[p];
    if (s != null &amp;&amp; typeof Object.getOwnPropertySymbols === &quot;function&quot;)
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i &lt; p.length; i++) {
            if (e.indexOf(p[i]) &lt; 0 &amp;&amp; Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import * as React from 'react';
import * as ScrollAreaPrimitive</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/components/ui/resizable.jsx (Line 1:1 - Line 13:13), C:/AI/food-truck-finder-poc/dist/components/ui/tooltip.jsx (Line 1:1 - Line 13:9)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn261" onclick="toggleCodeBlock('cloneGroup261', 'expandBtn261', 'collapseBtn261')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn261" onclick="toggleCodeBlock('cloneGroup261', 'expandBtn261', 'collapseBtn261')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup261"><code class="language-jsx text-sm text-gray-800">'use client';
var __rest = (this &amp;&amp; this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) &amp;&amp; e.indexOf(p) &lt; 0)
        t[p] = s[p];
    if (s != null &amp;&amp; typeof Object.getOwnPropertySymbols === &quot;function&quot;)
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i &lt; p.length; i++) {
            if (e.indexOf(p[i]) &lt; 0 &amp;&amp; Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import { GripVertical</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/components/ui/RadioGroup.jsx (Line 1:1 - Line 14:20), C:/AI/food-truck-finder-poc/dist/components/ui/tooltip.jsx (Line 1:1 - Line 14:17)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn262" onclick="toggleCodeBlock('cloneGroup262', 'expandBtn262', 'collapseBtn262')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn262" onclick="toggleCodeBlock('cloneGroup262', 'expandBtn262', 'collapseBtn262')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup262"><code class="language-jsx text-sm text-gray-800">'use client';
var __rest = (this &amp;&amp; this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) &amp;&amp; e.indexOf(p) &lt; 0)
        t[p] = s[p];
    if (s != null &amp;&amp; typeof Object.getOwnPropertySymbols === &quot;function&quot;)
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i &lt; p.length; i++) {
            if (e.indexOf(p[i]) &lt; 0 &amp;&amp; Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import * as React from 'react';
import * as RadioGroupPrimitive</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/components/ui/progress.jsx (Line 1:1 - Line 14:18), C:/AI/food-truck-finder-poc/dist/components/ui/tooltip.jsx (Line 1:1 - Line 14:17)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn263" onclick="toggleCodeBlock('cloneGroup263', 'expandBtn263', 'collapseBtn263')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn263" onclick="toggleCodeBlock('cloneGroup263', 'expandBtn263', 'collapseBtn263')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup263"><code class="language-jsx text-sm text-gray-800">'use client';
var __rest = (this &amp;&amp; this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) &amp;&amp; e.indexOf(p) &lt; 0)
        t[p] = s[p];
    if (s != null &amp;&amp; typeof Object.getOwnPropertySymbols === &quot;function&quot;)
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i &lt; p.length; i++) {
            if (e.indexOf(p[i]) &lt; 0 &amp;&amp; Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import * as React from 'react';
import * as ProgressPrimitive</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/components/ui/popover.jsx (Line 1:1 - Line 14:17), C:/AI/food-truck-finder-poc/dist/components/ui/tooltip.jsx (Line 1:1 - Line 14:17)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn264" onclick="toggleCodeBlock('cloneGroup264', 'expandBtn264', 'collapseBtn264')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn264" onclick="toggleCodeBlock('cloneGroup264', 'expandBtn264', 'collapseBtn264')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup264"><code class="language-jsx text-sm text-gray-800">'use client';
var __rest = (this &amp;&amp; this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) &amp;&amp; e.indexOf(p) &lt; 0)
        t[p] = s[p];
    if (s != null &amp;&amp; typeof Object.getOwnPropertySymbols === &quot;function&quot;)
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i &lt; p.length; i++) {
            if (e.indexOf(p[i]) &lt; 0 &amp;&amp; Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import * as React from 'react';
import * as PopoverPrimitive</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/components/ui/pagination.jsx (Line 1:1 - Line 13:12), C:/AI/food-truck-finder-poc/dist/components/ui/tooltip.jsx (Line 2:1 - Line 13:3)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn265" onclick="toggleCodeBlock('cloneGroup265', 'expandBtn265', 'collapseBtn265')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn265" onclick="toggleCodeBlock('cloneGroup265', 'expandBtn265', 'collapseBtn265')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup265"><code class="language-jsx text-sm text-gray-800">var __rest = (this &amp;&amp; this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) &amp;&amp; e.indexOf(p) &lt; 0)
        t[p] = s[p];
    if (s != null &amp;&amp; typeof Object.getOwnPropertySymbols === &quot;function&quot;)
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i &lt; p.length; i++) {
            if (e.indexOf(p[i]) &lt; 0 &amp;&amp; Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import * as React from 'react';
import { ChevronLeft</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/components/ui/NavigationMenu.jsx (Line 1:1 - Line 13:24), C:/AI/food-truck-finder-poc/dist/components/ui/tooltip.jsx (Line 2:1 - Line 14:17)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn266" onclick="toggleCodeBlock('cloneGroup266', 'expandBtn266', 'collapseBtn266')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn266" onclick="toggleCodeBlock('cloneGroup266', 'expandBtn266', 'collapseBtn266')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup266"><code class="language-jsx text-sm text-gray-800">var __rest = (this &amp;&amp; this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) &amp;&amp; e.indexOf(p) &lt; 0)
        t[p] = s[p];
    if (s != null &amp;&amp; typeof Object.getOwnPropertySymbols === &quot;function&quot;)
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i &lt; p.length; i++) {
            if (e.indexOf(p[i]) &lt; 0 &amp;&amp; Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import * as React from 'react';
import * as NavigationMenuPrimitive</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/components/ui/label.jsx (Line 1:1 - Line 15:15), C:/AI/food-truck-finder-poc/dist/components/ui/toast.jsx (Line 1:1 - Line 14:17)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn267" onclick="toggleCodeBlock('cloneGroup267', 'expandBtn267', 'collapseBtn267')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn267" onclick="toggleCodeBlock('cloneGroup267', 'expandBtn267', 'collapseBtn267')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup267"><code class="language-jsx text-sm text-gray-800">'use client';
'use client';
var __rest = (this &amp;&amp; this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) &amp;&amp; e.indexOf(p) &lt; 0)
        t[p] = s[p];
    if (s != null &amp;&amp; typeof Object.getOwnPropertySymbols === &quot;function&quot;)
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i &lt; p.length; i++) {
            if (e.indexOf(p[i]) &lt; 0 &amp;&amp; Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import * as React from 'react';
import * as LabelPrimitive</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/components/ui/InputOtp.jsx (Line 1:1 - Line 14:9), C:/AI/food-truck-finder-poc/dist/components/ui/tooltip.jsx (Line 1:1 - Line 13:3)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn268" onclick="toggleCodeBlock('cloneGroup268', 'expandBtn268', 'collapseBtn268')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn268" onclick="toggleCodeBlock('cloneGroup268', 'expandBtn268', 'collapseBtn268')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup268"><code class="language-jsx text-sm text-gray-800">'use client';
var __rest = (this &amp;&amp; this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) &amp;&amp; e.indexOf(p) &lt; 0)
        t[p] = s[p];
    if (s != null &amp;&amp; typeof Object.getOwnPropertySymbols === &quot;function&quot;)
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i &lt; p.length; i++) {
            if (e.indexOf(p[i]) &lt; 0 &amp;&amp; Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import * as React from 'react';
import { OTPInput</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/components/ui/input.jsx (Line 1:1 - Line 14:6), C:/AI/food-truck-finder-poc/dist/components/ui/tooltip.jsx (Line 2:1 - Line 14:9)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn269" onclick="toggleCodeBlock('cloneGroup269', 'expandBtn269', 'collapseBtn269')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn269" onclick="toggleCodeBlock('cloneGroup269', 'expandBtn269', 'collapseBtn269')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup269"><code class="language-jsx text-sm text-gray-800">var __rest = (this &amp;&amp; this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) &amp;&amp; e.indexOf(p) &lt; 0)
        t[p] = s[p];
    if (s != null &amp;&amp; typeof Object.getOwnPropertySymbols === &quot;function&quot;)
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i &lt; p.length; i++) {
            if (e.indexOf(p[i]) &lt; 0 &amp;&amp; Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import * as React from 'react';
import { cn } from '@/lib/utils';
const Input</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/components/ui/HoverCard.jsx (Line 1:1 - Line 14:19), C:/AI/food-truck-finder-poc/dist/components/ui/tooltip.jsx (Line 1:1 - Line 14:17)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn270" onclick="toggleCodeBlock('cloneGroup270', 'expandBtn270', 'collapseBtn270')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn270" onclick="toggleCodeBlock('cloneGroup270', 'expandBtn270', 'collapseBtn270')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup270"><code class="language-jsx text-sm text-gray-800">'use client';
var __rest = (this &amp;&amp; this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) &amp;&amp; e.indexOf(p) &lt; 0)
        t[p] = s[p];
    if (s != null &amp;&amp; typeof Object.getOwnPropertySymbols === &quot;function&quot;)
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i &lt; p.length; i++) {
            if (e.indexOf(p[i]) &lt; 0 &amp;&amp; Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import * as React from 'react';
import * as HoverCardPrimitive</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/components/ui/form.jsx (Line 1:1 - Line 15:5), C:/AI/food-truck-finder-poc/dist/components/ui/tooltip.jsx (Line 1:1 - Line 16:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn271" onclick="toggleCodeBlock('cloneGroup271', 'expandBtn271', 'collapseBtn271')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn271" onclick="toggleCodeBlock('cloneGroup271', 'expandBtn271', 'collapseBtn271')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup271"><code class="language-jsx text-sm text-gray-800">'use client';
var __rest = (this &amp;&amp; this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) &amp;&amp; e.indexOf(p) &lt; 0)
        t[p] = s[p];
    if (s != null &amp;&amp; typeof Object.getOwnPropertySymbols === &quot;function&quot;)
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i &lt; p.length; i++) {
            if (e.indexOf(p[i]) &lt; 0 &amp;&amp; Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import * as React from 'react';
import * as LabelPrimitive from '@radix-ui/react-label';
import { Slot</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/components/ui/DropdownMenu.jsx (Line 1:1 - Line 14:22), C:/AI/food-truck-finder-poc/dist/components/ui/tooltip.jsx (Line 1:1 - Line 14:17)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn272" onclick="toggleCodeBlock('cloneGroup272', 'expandBtn272', 'collapseBtn272')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn272" onclick="toggleCodeBlock('cloneGroup272', 'expandBtn272', 'collapseBtn272')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup272"><code class="language-jsx text-sm text-gray-800">'use client';
var __rest = (this &amp;&amp; this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) &amp;&amp; e.indexOf(p) &lt; 0)
        t[p] = s[p];
    if (s != null &amp;&amp; typeof Object.getOwnPropertySymbols === &quot;function&quot;)
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i &lt; p.length; i++) {
            if (e.indexOf(p[i]) &lt; 0 &amp;&amp; Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import * as React from 'react';
import * as DropdownMenuPrimitive</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/components/ui/drawer.jsx (Line 1:1 - Line 14:7), C:/AI/food-truck-finder-poc/dist/components/ui/tooltip.jsx (Line 1:1 - Line 13:3)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn273" onclick="toggleCodeBlock('cloneGroup273', 'expandBtn273', 'collapseBtn273')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn273" onclick="toggleCodeBlock('cloneGroup273', 'expandBtn273', 'collapseBtn273')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup273"><code class="language-jsx text-sm text-gray-800">'use client';
var __rest = (this &amp;&amp; this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) &amp;&amp; e.indexOf(p) &lt; 0)
        t[p] = s[p];
    if (s != null &amp;&amp; typeof Object.getOwnPropertySymbols === &quot;function&quot;)
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i &lt; p.length; i++) {
            if (e.indexOf(p[i]) &lt; 0 &amp;&amp; Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import * as React from 'react';
import { Drawer</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/components/ui/dialog.jsx (Line 1:1 - Line 14:16), C:/AI/food-truck-finder-poc/dist/components/ui/tooltip.jsx (Line 1:1 - Line 14:17)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn274" onclick="toggleCodeBlock('cloneGroup274', 'expandBtn274', 'collapseBtn274')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn274" onclick="toggleCodeBlock('cloneGroup274', 'expandBtn274', 'collapseBtn274')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup274"><code class="language-jsx text-sm text-gray-800">'use client';
var __rest = (this &amp;&amp; this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) &amp;&amp; e.indexOf(p) &lt; 0)
        t[p] = s[p];
    if (s != null &amp;&amp; typeof Object.getOwnPropertySymbols === &quot;function&quot;)
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i &lt; p.length; i++) {
            if (e.indexOf(p[i]) &lt; 0 &amp;&amp; Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import * as React from 'react';
import * as DialogPrimitive</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/components/ui/dataQualityCharts.jsx (Line 52:9 - Line 60:3), C:/AI/food-truck-finder-poc/dist/components/ui/chart/QualityPieChart.jsx (Line 17:2 - Line 24:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn276" onclick="toggleCodeBlock('cloneGroup276', 'expandBtn276', 'collapseBtn276')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn276" onclick="toggleCodeBlock('cloneGroup276', 'expandBtn276', 'collapseBtn276')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup276"><code class="language-jsx text-sm text-gray-800">&lt;ResponsiveContainer width=&quot;100%&quot; height={300}&gt;
          &lt;PieChart&gt;
            &lt;Pie data={data} cx=&quot;50%&quot; cy=&quot;50%&quot; labelLine={false} label={({ name, percentage }) =&gt; `${name !== null &amp;&amp; name !== void 0 ? name : 'Unknown'}: ${percentage !== null &amp;&amp; percentage !== void 0 ? percentage : '0'}%`} outerRadius={80} fill=&quot;#8884d8&quot; dataKey=&quot;value&quot;&gt;
              {data.map((entry, index) =&gt; (&lt;Cell key={`cell-${index}`} fill={QUALITY_COLORS[index % QUALITY_COLORS.length]}/&gt;))}
            &lt;/Pie&gt;
            &lt;Tooltip content={&lt;CustomTooltip /&gt;}/&gt;
          &lt;/PieChart&gt;
        &lt;/ResponsiveContainer&gt;
      &lt;/</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/components/ui/ContextMenu.jsx (Line 1:1 - Line 14:21), C:/AI/food-truck-finder-poc/dist/components/ui/tooltip.jsx (Line 1:1 - Line 14:17)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn277" onclick="toggleCodeBlock('cloneGroup277', 'expandBtn277', 'collapseBtn277')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn277" onclick="toggleCodeBlock('cloneGroup277', 'expandBtn277', 'collapseBtn277')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup277"><code class="language-jsx text-sm text-gray-800">'use client';
var __rest = (this &amp;&amp; this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) &amp;&amp; e.indexOf(p) &lt; 0)
        t[p] = s[p];
    if (s != null &amp;&amp; typeof Object.getOwnPropertySymbols === &quot;function&quot;)
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i &lt; p.length; i++) {
            if (e.indexOf(p[i]) &lt; 0 &amp;&amp; Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import * as React from 'react';
import * as ContextMenuPrimitive</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/components/ui/command.jsx (Line 1:1 - Line 14:2), C:/AI/food-truck-finder-poc/dist/components/ui/tooltip.jsx (Line 1:1 - Line 13:3)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn278" onclick="toggleCodeBlock('cloneGroup278', 'expandBtn278', 'collapseBtn278')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn278" onclick="toggleCodeBlock('cloneGroup278', 'expandBtn278', 'collapseBtn278')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup278"><code class="language-jsx text-sm text-gray-800">'use client';
var __rest = (this &amp;&amp; this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) &amp;&amp; e.indexOf(p) &lt; 0)
        t[p] = s[p];
    if (s != null &amp;&amp; typeof Object.getOwnPropertySymbols === &quot;function&quot;)
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i &lt; p.length; i++) {
            if (e.indexOf(p[i]) &lt; 0 &amp;&amp; Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import * as React from 'react';
import {}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/components/ui/checkbox.jsx (Line 1:1 - Line 14:18), C:/AI/food-truck-finder-poc/dist/components/ui/tooltip.jsx (Line 1:1 - Line 14:17)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn279" onclick="toggleCodeBlock('cloneGroup279', 'expandBtn279', 'collapseBtn279')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn279" onclick="toggleCodeBlock('cloneGroup279', 'expandBtn279', 'collapseBtn279')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup279"><code class="language-jsx text-sm text-gray-800">'use client';
var __rest = (this &amp;&amp; this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) &amp;&amp; e.indexOf(p) &lt; 0)
        t[p] = s[p];
    if (s != null &amp;&amp; typeof Object.getOwnPropertySymbols === &quot;function&quot;)
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i &lt; p.length; i++) {
            if (e.indexOf(p[i]) &lt; 0 &amp;&amp; Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import * as React from 'react';
import * as CheckboxPrimitive</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/components/ui/chart.jsx (Line 2:1 - Line 15:18), C:/AI/food-truck-finder-poc/dist/components/ui/tooltip.jsx (Line 1:1 - Line 14:17)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn280" onclick="toggleCodeBlock('cloneGroup280', 'expandBtn280', 'collapseBtn280')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn280" onclick="toggleCodeBlock('cloneGroup280', 'expandBtn280', 'collapseBtn280')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup280"><code class="language-jsx text-sm text-gray-800">'use client';
var __rest = (this &amp;&amp; this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) &amp;&amp; e.indexOf(p) &lt; 0)
        t[p] = s[p];
    if (s != null &amp;&amp; typeof Object.getOwnPropertySymbols === &quot;function&quot;)
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i &lt; p.length; i++) {
            if (e.indexOf(p[i]) &lt; 0 &amp;&amp; Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import * as React from 'react';
import * as RechartsPrimitive</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/components/ui/carousel.jsx (Line 1:1 - Line 14:17), C:/AI/food-truck-finder-poc/dist/components/ui/tooltip.jsx (Line 1:1 - Line 14:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn281" onclick="toggleCodeBlock('cloneGroup281', 'expandBtn281', 'collapseBtn281')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn281" onclick="toggleCodeBlock('cloneGroup281', 'expandBtn281', 'collapseBtn281')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup281"><code class="language-jsx text-sm text-gray-800">'use client';
var __rest = (this &amp;&amp; this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) &amp;&amp; e.indexOf(p) &lt; 0)
        t[p] = s[p];
    if (s != null &amp;&amp; typeof Object.getOwnPropertySymbols === &quot;function&quot;)
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i &lt; p.length; i++) {
            if (e.indexOf(p[i]) &lt; 0 &amp;&amp; Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import * as React from 'react';
import useEmblaCarousel</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/components/ui/card.jsx (Line 1:1 - Line 14:5), C:/AI/food-truck-finder-poc/dist/components/ui/tooltip.jsx (Line 2:1 - Line 14:9)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn283" onclick="toggleCodeBlock('cloneGroup283', 'expandBtn283', 'collapseBtn283')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn283" onclick="toggleCodeBlock('cloneGroup283', 'expandBtn283', 'collapseBtn283')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup283"><code class="language-jsx text-sm text-gray-800">var __rest = (this &amp;&amp; this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) &amp;&amp; e.indexOf(p) &lt; 0)
        t[p] = s[p];
    if (s != null &amp;&amp; typeof Object.getOwnPropertySymbols === &quot;function&quot;)
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i &lt; p.length; i++) {
            if (e.indexOf(p[i]) &lt; 0 &amp;&amp; Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import * as React from 'react';
import { cn } from '@/lib/utils';
const Card</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/components/ui/calendar.jsx (Line 1:1 - Line 14:10), C:/AI/food-truck-finder-poc/dist/components/ui/tooltip.jsx (Line 1:1 - Line 13:3)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn284" onclick="toggleCodeBlock('cloneGroup284', 'expandBtn284', 'collapseBtn284')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn284" onclick="toggleCodeBlock('cloneGroup284', 'expandBtn284', 'collapseBtn284')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup284"><code class="language-jsx text-sm text-gray-800">'use client';
var __rest = (this &amp;&amp; this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) &amp;&amp; e.indexOf(p) &lt; 0)
        t[p] = s[p];
    if (s != null &amp;&amp; typeof Object.getOwnPropertySymbols === &quot;function&quot;)
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i &lt; p.length; i++) {
            if (e.indexOf(p[i]) &lt; 0 &amp;&amp; Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import * as React from 'react';
import { DayPicker</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/components/ui/button.jsx (Line 1:1 - Line 12:11), C:/AI/food-truck-finder-poc/dist/components/ui/tooltip.jsx (Line 2:1 - Line 13:9)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn285" onclick="toggleCodeBlock('cloneGroup285', 'expandBtn285', 'collapseBtn285')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn285" onclick="toggleCodeBlock('cloneGroup285', 'expandBtn285', 'collapseBtn285')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup285"><code class="language-jsx text-sm text-gray-800">var __rest = (this &amp;&amp; this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) &amp;&amp; e.indexOf(p) &lt; 0)
        t[p] = s[p];
    if (s != null &amp;&amp; typeof Object.getOwnPropertySymbols === &quot;function&quot;)
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i &lt; p.length; i++) {
            if (e.indexOf(p[i]) &lt; 0 &amp;&amp; Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import { forwardRef</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/components/ui/breadcrumb.jsx (Line 1:1 - Line 14:13), C:/AI/food-truck-finder-poc/dist/components/ui/tooltip.jsx (Line 2:1 - Line 15:3)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn286" onclick="toggleCodeBlock('cloneGroup286', 'expandBtn286', 'collapseBtn286')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn286" onclick="toggleCodeBlock('cloneGroup286', 'expandBtn286', 'collapseBtn286')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup286"><code class="language-jsx text-sm text-gray-800">var __rest = (this &amp;&amp; this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) &amp;&amp; e.indexOf(p) &lt; 0)
        t[p] = s[p];
    if (s != null &amp;&amp; typeof Object.getOwnPropertySymbols === &quot;function&quot;)
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i &lt; p.length; i++) {
            if (e.indexOf(p[i]) &lt; 0 &amp;&amp; Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import * as React from 'react';
import { Slot } from '@radix-ui/react-slot';
import { ChevronRight</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/components/ui/badge.jsx (Line 1:1 - Line 13:20), C:/AI/food-truck-finder-poc/dist/components/ui/tooltip.jsx (Line 2:1 - Line 14:25)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn287" onclick="toggleCodeBlock('cloneGroup287', 'expandBtn287', 'collapseBtn287')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn287" onclick="toggleCodeBlock('cloneGroup287', 'expandBtn287', 'collapseBtn287')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup287"><code class="language-jsx text-sm text-gray-800">var __rest = (this &amp;&amp; this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) &amp;&amp; e.indexOf(p) &lt; 0)
        t[p] = s[p];
    if (s != null &amp;&amp; typeof Object.getOwnPropertySymbols === &quot;function&quot;)
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i &lt; p.length; i++) {
            if (e.indexOf(p[i]) &lt; 0 &amp;&amp; Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import * as React from 'react';
import {} from 'tailwind-variants'</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/components/ui/avatar.jsx (Line 1:1 - Line 14:16), C:/AI/food-truck-finder-poc/dist/components/ui/tooltip.jsx (Line 1:1 - Line 14:17)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn288" onclick="toggleCodeBlock('cloneGroup288', 'expandBtn288', 'collapseBtn288')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn288" onclick="toggleCodeBlock('cloneGroup288', 'expandBtn288', 'collapseBtn288')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup288"><code class="language-jsx text-sm text-gray-800">'use client';
var __rest = (this &amp;&amp; this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) &amp;&amp; e.indexOf(p) &lt; 0)
        t[p] = s[p];
    if (s != null &amp;&amp; typeof Object.getOwnPropertySymbols === &quot;function&quot;)
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i &lt; p.length; i++) {
            if (e.indexOf(p[i]) &lt; 0 &amp;&amp; Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import * as React from 'react';
import * as AvatarPrimitive</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/components/ui/AlertDialog.jsx (Line 1:1 - Line 14:21), C:/AI/food-truck-finder-poc/dist/components/ui/tooltip.jsx (Line 1:1 - Line 14:17)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn289" onclick="toggleCodeBlock('cloneGroup289', 'expandBtn289', 'collapseBtn289')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn289" onclick="toggleCodeBlock('cloneGroup289', 'expandBtn289', 'collapseBtn289')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup289"><code class="language-jsx text-sm text-gray-800">'use client';
var __rest = (this &amp;&amp; this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) &amp;&amp; e.indexOf(p) &lt; 0)
        t[p] = s[p];
    if (s != null &amp;&amp; typeof Object.getOwnPropertySymbols === &quot;function&quot;)
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i &lt; p.length; i++) {
            if (e.indexOf(p[i]) &lt; 0 &amp;&amp; Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import * as React from 'react';
import * as AlertDialogPrimitive</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/components/ui/alert.jsx (Line 1:1 - Line 15:14), C:/AI/food-truck-finder-poc/dist/components/ui/tooltip.jsx (Line 2:1 - Line 15:14)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn290" onclick="toggleCodeBlock('cloneGroup290', 'expandBtn290', 'collapseBtn290')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn290" onclick="toggleCodeBlock('cloneGroup290', 'expandBtn290', 'collapseBtn290')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup290"><code class="language-jsx text-sm text-gray-800">var __rest = (this &amp;&amp; this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) &amp;&amp; e.indexOf(p) &lt; 0)
        t[p] = s[p];
    if (s != null &amp;&amp; typeof Object.getOwnPropertySymbols === &quot;function&quot;)
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i &lt; p.length; i++) {
            if (e.indexOf(p[i]) &lt; 0 &amp;&amp; Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import * as React from 'react';
import {} from 'tailwind-variants';
import { cn } from '@/lib/utils';
import { alertVariants</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/components/ui/accordion.jsx (Line 1:1 - Line 14:19), C:/AI/food-truck-finder-poc/dist/components/ui/tooltip.jsx (Line 1:1 - Line 14:17)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn291" onclick="toggleCodeBlock('cloneGroup291', 'expandBtn291', 'collapseBtn291')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn291" onclick="toggleCodeBlock('cloneGroup291', 'expandBtn291', 'collapseBtn291')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup291"><code class="language-jsx text-sm text-gray-800">'use client';
var __rest = (this &amp;&amp; this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) &amp;&amp; e.indexOf(p) &lt; 0)
        t[p] = s[p];
    if (s != null &amp;&amp; typeof Object.getOwnPropertySymbols === &quot;function&quot;)
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i &lt; p.length; i++) {
            if (e.indexOf(p[i]) &lt; 0 &amp;&amp; Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import * as React from 'react';
import * as AccordionPrimitive</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/components/monitoring/FeatureList.jsx (Line 17:2 - Line 22:6), C:/AI/food-truck-finder-poc/dist/app/admin/data-cleanup/page.jsx (Line 101:2 - Line 106:5)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn292" onclick="toggleCodeBlock('cloneGroup292', 'expandBtn292', 'collapseBtn292')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn292" onclick="toggleCodeBlock('cloneGroup292', 'expandBtn292', 'collapseBtn292')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup292"><code class="language-jsx text-sm text-gray-800">}) {
    return (&lt;div className=&quot;space-y-3&quot;&gt;
      &lt;h4 className=&quot;font-semibold text-sm&quot;&gt;{title}&lt;/h4&gt;
      &lt;ul className=&quot;space-y-2 text-sm text-muted-foreground&quot;&gt;
        {items.map((item, index) =&gt; (&lt;li key={index} className=&quot;flex items-center gap-2&quot;&gt;
            {React</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/components/map/MapComponent.jsx (Line 11:2 - Line 19:2), C:/AI/food-truck-finder-poc/dist/components/map/MapViewUpdater.jsx (Line 3:2 - Line 11:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn293" onclick="toggleCodeBlock('cloneGroup293', 'expandBtn293', 'collapseBtn293')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn293" onclick="toggleCodeBlock('cloneGroup293', 'expandBtn293', 'collapseBtn293')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup293"><code class="language-jsx text-sm text-gray-800">{
    const map = useMap();
    useEffect(() =&gt; {
        if (center) {
            map.flyTo(center, zoom !== null &amp;&amp; zoom !== void 0 ? zoom : map.getZoom());
        }
    }, [center, zoom, map]);
    return &lt;&gt;&lt;/&gt;;
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/components/map/MapComponent.jsx (Line 95:2 - Line 104:3), C:/AI/food-truck-finder-poc/dist/components/map/TruckMarkers.jsx (Line 30:14 - Line 39:3)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn294" onclick="toggleCodeBlock('cloneGroup294', 'expandBtn294', 'collapseBtn294')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn294" onclick="toggleCodeBlock('cloneGroup294', 'expandBtn294', 'collapseBtn294')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup294"><code class="language-jsx text-sm text-gray-800">} eventHandlers={{
                    click: () =&gt; {
                        if (onSelectTruck) {
                            onSelectTruck(truck.id);
                        }
                    },
                }}&gt;
            &lt;Popup&gt;
              &lt;h4 className=&quot;font-bold&quot;&gt;{truck.name}&lt;/h4&gt;
              {truck.current_location.address &amp;&amp;</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/components/login/EmailFormFields.jsx (Line 1:1 - Line 30:2), C:/AI/food-truck-finder-poc/dist/lib/components/login/EmailFormFields.jsx (Line 1:1 - Line 30:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn295" onclick="toggleCodeBlock('cloneGroup295', 'expandBtn295', 'collapseBtn295')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn295" onclick="toggleCodeBlock('cloneGroup295', 'expandBtn295', 'collapseBtn295')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup295"><code class="language-jsx text-sm text-gray-800">import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
/**
 * A React component for rendering email and password input fields in a form.
 * @example
 * &lt;EmailFormFields email={email} setEmail={setEmail} password={password} setPassword={setPassword} loading={loading} /&gt;
 * // Renders two input fields where users can enter an email and password, respectively.
 * @param {Object} props - Component properties.
 * @param {string} props.email - Current email value.
 * @param {Function} props.setEmail - Function to update the email state.
 * @param {string} props.password - Current password value.
 * @param {Function} props.setPassword - Function to update the password state.
 * @param {boolean} props.loading - Indicates if the form is in a loading state, but it is not used within the component.
 * @returns {JSX.Element} Rendered email and password form fields.
 * @description
 *   - The component requires an email and password, along with their respective state updater functions.
 *   - The jsx elements are wrapped in fragments for structural purposes, allowing multiple sibling elements.
 */
export function EmailFormFields({ email, setEmail, password, setPassword, loading: _loading, }) {
    return (&lt;&gt;
      &lt;div className=&quot;space-y-2&quot;&gt;
        &lt;Label htmlFor=&quot;email&quot;&gt;Email&lt;/Label&gt;
        &lt;Input id=&quot;email&quot; type=&quot;email&quot; placeholder=&quot;zabrien@gmail.com&quot; value={email} onChange={(e) =&gt; setEmail(e.target.value)} required/&gt;
      &lt;/div&gt;
      &lt;div className=&quot;space-y-2&quot;&gt;
        &lt;Label htmlFor=&quot;password&quot;&gt;Password&lt;/Label&gt;
        &lt;Input id=&quot;password&quot; type=&quot;password&quot; placeholder=&quot;Enter your password&quot; value={password} onChange={(e) =&gt; setPassword(e.target.value)} required/&gt;
      &lt;/div&gt;
    &lt;/&gt;);
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/app/login/page.jsx (Line 1:1 - Line 31:4), C:/AI/food-truck-finder-poc/dist/lib/app/login/page.jsx (Line 1:1 - Line 31:4)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn297" onclick="toggleCodeBlock('cloneGroup297', 'expandBtn297', 'collapseBtn297')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn297" onclick="toggleCodeBlock('cloneGroup297', 'expandBtn297', 'collapseBtn297')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup297"><code class="language-jsx text-sm text-gray-800">'use client';
import { useSearchParams } from 'next/navigation';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Alert, AlertDescription } from '@/components/ui/alert';
import { Loader2, Shield, Mail } from 'lucide-react';
import { useAuthHandlers } from '@/hooks/useAuthHandlers';
import { EmailFormFields } from '@/components/login/EmailFormFields';
// Login header component
function LoginHeader() {
    return (&lt;CardHeader className=&quot;text-center&quot;&gt;
      &lt;div className=&quot;mx-auto mb-4 flex size-16 items-center justify-center rounded-full bg-primary/10&quot;&gt;
        &lt;Shield className=&quot;size-8 text-primary&quot;/&gt;
      &lt;/div&gt;
      &lt;CardTitle className=&quot;text-2xl&quot;&gt;Admin Login&lt;/CardTitle&gt;
      &lt;CardDescription&gt;Sign in to access the admin dashboard&lt;/CardDescription&gt;
    &lt;/CardHeader&gt;);
}
// Email login form component
/**
 * Represents a form for logging in using an email and password.
 * @example
 * EmailLoginForm({ email: 'user@example.com', setEmail: fn, password: 'password123', setPassword: fn, loading: false, handleEmailLogin: fn })
 * Returns an HTML form element configured for email login.
 * @param {object} {email, setEmail, password, setPassword, loading, handleEmailLogin} - Object containing email and password properties along with their updater functions, a loading state, and a login handler function.
 * @returns {JSX.Element} The rendered login form component including email fields and submit button.
 * @description
 *   - The submit button's text and state are dynamically updated based on the loading status.
 *   - Uses the EmailFormFields component for input fields to enhance modularity.
 *   - Catches and logs errors during the handleEmailLogin process.
 */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/app/login/page.jsx (Line 32:1 - Line 59:4), C:/AI/food-truck-finder-poc/dist/lib/app/login/page.jsx (Line 32:1 - Line 59:4)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn298" onclick="toggleCodeBlock('cloneGroup298', 'expandBtn298', 'collapseBtn298')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn298" onclick="toggleCodeBlock('cloneGroup298', 'expandBtn298', 'collapseBtn298')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup298"><code class="language-jsx text-sm text-gray-800">function EmailLoginForm({ email, setEmail, password, setPassword, loading, handleEmailLogin, }) {
    return (&lt;form onSubmit={(e) =&gt; {
            handleEmailLogin(e).catch((error) =&gt; {
                console.warn('Failed to handle email login:', error);
            });
        }} className=&quot;space-y-4&quot;&gt;
      &lt;EmailFormFields email={email} setEmail={setEmail} password={password} setPassword={setPassword} loading={loading}/&gt;
      &lt;Button type=&quot;submit&quot; disabled={loading} className=&quot;w-full&quot;&gt;
        {loading ? (&lt;Loader2 className=&quot;mr-2 size-4 animate-spin&quot;/&gt;) : (&lt;Mail className=&quot;mr-2 size-4&quot;/&gt;)}
        {loading ? 'Signing in...' : 'Sign in with Email'}
      &lt;/Button&gt;
    &lt;/form&gt;);
}
// Google login button component
/**
 * Renders a Google login button with a loading state.
 * @example
 * GoogleLoginButton({ loading: true, handleGoogleLogin: asyncFunction })
 * Renders a button either with a spinner if loading or an icon otherwise.
 * @param {Object} props - Properties to configure the Google login button.
 * @param {boolean} props.loading - Indicates whether the button should display a loading spinner.
 * @param {function} props.handleGoogleLogin - Callback function that handles the Google login process.
 * @returns {JSX.Element} A JSX button element configured for Google login interaction.
 * @description
 *   - Uses a loading spinner animation when the login process is ongoing.
 *   - Calls the `handleGoogleLogin` function and manages error handling by logging failures to console.
 *   - Configures the button to be disabled during the loading state to prevent multiple submissions.
 */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/app/login/page.jsx (Line 60:1 - Line 88:3), C:/AI/food-truck-finder-poc/dist/lib/app/login/page.jsx (Line 60:1 - Line 88:3)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn299" onclick="toggleCodeBlock('cloneGroup299', 'expandBtn299', 'collapseBtn299')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn299" onclick="toggleCodeBlock('cloneGroup299', 'expandBtn299', 'collapseBtn299')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup299"><code class="language-jsx text-sm text-gray-800">function GoogleLoginButton({ loading, handleGoogleLogin, }) {
    return (&lt;Button onClick={() =&gt; {
            handleGoogleLogin().catch((error) =&gt; {
                console.warn('Failed to handle Google login:', error);
            });
        }} disabled={loading} className=&quot;w-full&quot;&gt;
      {loading ? (&lt;Loader2 className=&quot;mr-2 size-4 animate-spin&quot;/&gt;) : (&lt;Mail className=&quot;mr-2 size-4&quot;/&gt;)}
      Google
    &lt;/Button&gt;);
}
// Login footer component
function LoginFooter() {
    return (&lt;div className=&quot;text-center text-sm text-muted-foreground&quot;&gt;
      &lt;p&gt;Admin access only&lt;/p&gt;
      &lt;p&gt;Contact your administrator if you need access&lt;/p&gt;
    &lt;/div&gt;);
}
// Divider component
/**
* Component that renders a styled divider section for login options
* @example
* LoginDivider()
* &lt;div&gt;...&lt;/div&gt;
* @returns {JSX.Element} A JSX element representing the login divider component.
* @description
*   - It uses absolute positioning to overlay a horizontal line across the container.
*   - The text &quot;Or continue with&quot; is styled to appear above the divider with a background.
*   - Ensures the text stays within the confines of the container using flexbox for centering.
*/</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/app/login/page.jsx (Line 89:1 - Line 110:4), C:/AI/food-truck-finder-poc/dist/lib/app/login/page.jsx (Line 89:1 - Line 110:4)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn300" onclick="toggleCodeBlock('cloneGroup300', 'expandBtn300', 'collapseBtn300')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn300" onclick="toggleCodeBlock('cloneGroup300', 'expandBtn300', 'collapseBtn300')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup300"><code class="language-jsx text-sm text-gray-800">function LoginDivider() {
    return (&lt;div className=&quot;relative&quot;&gt;
      &lt;div className=&quot;absolute inset-0 flex items-center&quot;&gt;
        &lt;span className=&quot;w-full border-t&quot;/&gt;
      &lt;/div&gt;
      &lt;div className=&quot;relative flex justify-center text-xs uppercase&quot;&gt;
        &lt;span className=&quot;bg-background px-2 text-muted-foreground&quot;&gt;Or continue with&lt;/span&gt;
      &lt;/div&gt;
    &lt;/div&gt;);
}
/**
 * Renders the login page component which provides email or Google login options.
 * @example
 * const element = &lt;LoginPage /&gt;
 * // Returns a JSX element rendering the login page.
 * @returns {JSX.Element} JSX content displaying login options, error alerts, and associated handlers.
 * @description
 *   - Utilizes `useSearchParams` to determine redirect behavior after login.
 *   - Incorporates `useAuthHandlers` for managing the login process.
 *   - Displays an alert when authentication errors occur.
 *   - Uses `Card`, `LoginHeader`, `EmailLoginForm`, `LoginDivider`, `GoogleLoginButton`, and `LoginFooter` for structuring the page.
 */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/app/login/page.jsx (Line 114:2 - Line 134:2), C:/AI/food-truck-finder-poc/dist/lib/app/login/page.jsx (Line 113:2 - Line 133:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn301" onclick="toggleCodeBlock('cloneGroup301', 'expandBtn301', 'collapseBtn301')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn301" onclick="toggleCodeBlock('cloneGroup301', 'expandBtn301', 'collapseBtn301')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup301"><code class="language-jsx text-sm text-gray-800">'/admin';
    const { handleEmailLogin, handleGoogleLogin, loading, error, email, setEmail, password, setPassword, } = useAuthHandlers(redirectTo);
    return (&lt;div className=&quot;min-h-screen flex items-center justify-center bg-gradient-to-b from-background to-secondary/20 p-4&quot;&gt;
      &lt;Card className=&quot;w-full max-w-md&quot;&gt;
        &lt;LoginHeader /&gt;
        &lt;CardContent className=&quot;space-y-4&quot;&gt;
          {error != undefined &amp;&amp; error.length &gt; 0 &amp;&amp; (&lt;Alert&gt;
              &lt;AlertDescription&gt;{error}&lt;/AlertDescription&gt;
            &lt;/Alert&gt;)}

          &lt;EmailLoginForm email={email} setEmail={setEmail} password={password} setPassword={setPassword} loading={loading} handleEmailLogin={handleEmailLogin}/&gt;

          &lt;LoginDivider /&gt;

          &lt;GoogleLoginButton loading={loading} handleGoogleLogin={handleGoogleLogin}/&gt;

          &lt;LoginFooter /&gt;
        &lt;/CardContent&gt;
      &lt;/Card&gt;
    &lt;/div&gt;);
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/app/admin/page.jsx (Line 1:1 - Line 15:4), C:/AI/food-truck-finder-poc/dist/lib/app/admin/page.jsx (Line 1:1 - Line 15:6)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn303" onclick="toggleCodeBlock('cloneGroup303', 'expandBtn303', 'collapseBtn303')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn303" onclick="toggleCodeBlock('cloneGroup303', 'expandBtn303', 'collapseBtn303')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup303"><code class="language-jsx text-sm text-gray-800">'use client';
import { useFoodTrucks, DataStatusIndicator } from '@/lib/fallback/supabaseFallback';
import { ScrapingJobService, DataProcessingService, supabase, } from '@/lib/supabase';
import { TotalFoodTrucksCard } from '@/components/admin/dashboard/TotalFoodTrucksCard';
import { PipelineStatusCard } from '@/components/admin/dashboard/PipelineStatusCard';
import { DataQualityScoreCard } from '@/components/admin/dashboard/DataQualityScoreCard';
import { QualityDistributionCard } from '@/components/admin/dashboard/QualityDistributionCard';
import { RecentErrorsCard } from '@/components/admin/dashboard/RecentErrorsCard';
import { useEffect, useState } from 'react';
export default function AdminDashboard() {
    const { trucks, loading, dataStatus } = useFoodTrucks();
    const [dashboardData, setDashboardData] = useState(undefined);
    useEffect(() =&gt; {
        const getDashboardData = async () =&gt; {
            var</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/app/admin/page.jsx (Line 16:13 - Line 29:2), C:/AI/food-truck-finder-poc/dist/lib/app/admin/page.jsx (Line 15:13 - Line 28:19)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn304" onclick="toggleCodeBlock('cloneGroup304', 'expandBtn304', 'collapseBtn304')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn304" onclick="toggleCodeBlock('cloneGroup304', 'expandBtn304', 'collapseBtn304')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup304"><code class="language-jsx text-sm text-gray-800">const pendingVerifications = trucks.filter((t) =&gt; t.verification_status === 'pending').length;
            const pendingScrapingJobs = await ScrapingJobService.getJobsByStatus('pending');
            const runningScrapingJobs = await ScrapingJobService.getJobsByStatus('running');
            const failedScrapingJobs = await ScrapingJobService.getJobsByStatus('failed');
            const failedProcessingQueueItems = await DataProcessingService.getQueueByStatus('failed');
            const { data: qualityStatsResult, error: qualityError } = await supabase
                .rpc('get_data_quality_stats')
                .single();
            if (qualityError) {
                // The error is logged here, but the promise rejection will be caught below.
                console.error('Error fetching data quality stats:', qualityError);
                throw qualityError; // Re-throw to be caught by the .catch() block
            }
            const dataQualityStats = (</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/app/admin/page.jsx (Line 28:13 - Line 39:17), C:/AI/food-truck-finder-poc/dist/app/admin/data-quality/page.jsx (Line 149:5 - Line 160:63)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn305" onclick="toggleCodeBlock('cloneGroup305', 'expandBtn305', 'collapseBtn305')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn305" onclick="toggleCodeBlock('cloneGroup305', 'expandBtn305', 'collapseBtn305')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup305"><code class="language-jsx text-sm text-gray-800">}
            const dataQualityStats = (_a = qualityStatsResult) !== null &amp;&amp; _a !== void 0 ? _a : {
                total_trucks: 0,
                avg_quality_score: 0,
                high_quality_count: 0,
                medium_quality_count: 0,
                low_quality_count: 0,
                verified_count: 0,
                pending_count: 0,
                flagged_count: 0,
            };
            setDashboardData</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/app/admin/page.jsx (Line 29:2 - Line 82:2), C:/AI/food-truck-finder-poc/dist/lib/app/admin/page.jsx (Line 28:2 - Line 81:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn306" onclick="toggleCodeBlock('cloneGroup306', 'expandBtn306', 'collapseBtn306')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn306" onclick="toggleCodeBlock('cloneGroup306', 'expandBtn306', 'collapseBtn306')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup306"><code class="language-jsx text-sm text-gray-800">{
                total_trucks: 0,
                avg_quality_score: 0,
                high_quality_count: 0,
                medium_quality_count: 0,
                low_quality_count: 0,
                verified_count: 0,
                pending_count: 0,
                flagged_count: 0,
            };
            setDashboardData({
                totalFoodTrucks: trucks.length,
                pendingVerifications,
                pendingScrapingJobsCount: pendingScrapingJobs.length,
                runningScrapingJobsCount: runningScrapingJobs.length,
                failedScrapingJobsCount: failedScrapingJobs.length,
                failedProcessingQueueItemsCount: failedProcessingQueueItems.length,
                dataQualityStats,
            });
        };
        if (trucks.length &gt; 0) {
            // Correctly handle the floating promise by wrapping the call and adding a .catch block.
            (async () =&gt; {
                await getDashboardData();
            })().catch(error =&gt; {
                console.error(&quot;An unhandled error occurred in getDashboardData:&quot;, error);
            });
        }
    }, [trucks]);
    if (loading || !dashboardData) {
        return &lt;div&gt;Loading...&lt;/div&gt;;
    }
    if (dataStatus.status === 'unavailable') {
        return (&lt;div className=&quot;flex flex-col gap-4&quot;&gt;
        &lt;h1 className=&quot;text-2xl font-bold&quot;&gt;Admin Dashboard&lt;/h1&gt;
        &lt;DataStatusIndicator status={dataStatus}/&gt;
        &lt;div className=&quot;text-center py-10&quot;&gt;
          &lt;p className=&quot;text-lg text-gray-500&quot;&gt;Food truck data is currently unavailable. Please try again later.&lt;/p&gt;
        &lt;/div&gt;
      &lt;/div&gt;);
    }
    return (&lt;div className=&quot;flex flex-col gap-4&quot;&gt;
      &lt;h1 className=&quot;text-2xl font-bold&quot;&gt;Admin Dashboard&lt;/h1&gt;
      &lt;DataStatusIndicator status={dataStatus}/&gt;

      &lt;div className=&quot;grid gap-4 md:grid-cols-2 lg:grid-cols-4&quot;&gt;
        &lt;TotalFoodTrucksCard totalFoodTrucks={dashboardData.totalFoodTrucks} pendingVerifications={dashboardData.pendingVerifications}/&gt;
        &lt;PipelineStatusCard pendingScrapingJobsCount={dashboardData.pendingScrapingJobsCount} runningScrapingJobsCount={dashboardData.runningScrapingJobsCount} failedScrapingJobsCount={dashboardData.failedScrapingJobsCount}/&gt;
        &lt;DataQualityScoreCard dataQualityStats={dashboardData.dataQualityStats}/&gt;
        &lt;QualityDistributionCard dataQualityStats={dashboardData.dataQualityStats}/&gt;
        &lt;RecentErrorsCard failedProcessingQueueItemsCount={dashboardData.failedProcessingQueueItemsCount}/&gt;
      &lt;/div&gt;
    &lt;/div&gt;);
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/components/TruckCard.jsx (Line 75:2 - Line 81:2), C:/AI/food-truck-finder-poc/dist/components/TruckDetailsModal.jsx (Line 74:9 - Line 81:3)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn520" onclick="toggleCodeBlock('cloneGroup520', 'expandBtn520', 'collapseBtn520')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn520" onclick="toggleCodeBlock('cloneGroup520', 'expandBtn520', 'collapseBtn520')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup520"><code class="language-jsx text-sm text-gray-800">&lt;MenuSection items={popularItems.map(item =&gt; {
                var _a;
                return ({
                    name: item.name,
                    price: formatPrice((_a = item.price) !== null &amp;&amp; _a !== void 0 ? _a : 0),
                });
            })}/&gt;)</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/dist/components/ThemeProvider.jsx (Line 1:1 - Line 14:14), C:/AI/food-truck-finder-poc/dist/components/ui/tooltip.jsx (Line 1:1 - Line 13:3)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn521" onclick="toggleCodeBlock('cloneGroup521', 'expandBtn521', 'collapseBtn521')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn521" onclick="toggleCodeBlock('cloneGroup521', 'expandBtn521', 'collapseBtn521')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup521"><code class="language-jsx text-sm text-gray-800">'use client';
var __rest = (this &amp;&amp; this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) &amp;&amp; e.indexOf(p) &lt; 0)
        t[p] = s[p];
    if (s != null &amp;&amp; typeof Object.getOwnPropertySymbols === &quot;function&quot;)
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i &lt; p.length; i++) {
            if (e.indexOf(p[i]) &lt; 0 &amp;&amp; Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import * as React from 'react';
import { ThemeProvider</code></pre></div><!-- Add more clone groups for .txt format as needed         // Add more clone groups for .txt format as needed--></div><a name="tsx-clones"></a><h2 class="text-2xl font-semibold text-gray-700 mb-4">tsx</h2><div class="divide-y divide-gray-200 border-b-2"><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/components/admin/realtime/RealtimeStatusDisplay.tsx (Line 98:5 - Line 156:4), C:/AI/food-truck-finder-poc/components/admin/realtime/RealtimeStatusDisplay.tsx (Line 12:10 - Line 60:4)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn328" onclick="toggleCodeBlock('cloneGroup328', 'expandBtn328', 'collapseBtn328')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn328" onclick="toggleCodeBlock('cloneGroup328', 'expandBtn328', 'collapseBtn328')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup328"><code class="language-tsx text-sm text-gray-800">;
  readonly systemMetrics: StatusMetric[];
  readonly scrapingJobs:
    | {
        active: number;
        completed: number;
        failed: number;
        pending: number;
      }
    | undefined;
  readonly alerts: SystemAlert[];
  readonly showDetails: boolean;
  readonly onToggleDetails: () =&gt; void;
  readonly onAcknowledgeAlert: (alertId: string) =&gt; void;
  readonly recentEventsCount: number;
  readonly onClearEvents: () =&gt; void;
}

/**
 * Displays the realtime status of a connection with various metrics and controls.
 * @example
 * RealtimeStatusDisplay({
 *   isConnected: false,
 *   isConnecting: true,
 *   connectionError: &quot;Timeout&quot;,
 *   lastEventTime: 1638349200000,
 *   connect: () =&gt; {},
 *   disconnect: () =&gt; {},
 *   systemMetrics: {},
 *   scrapingJobs: [],
 *   alerts: [],
 *   showDetails: false,
 *   onToggleDetails: () =&gt; {},
 *   onAcknowledgeAlert: () =&gt; {},
 *   recentEventsCount: 5,
 *   onClearEvents: () =&gt; {}
 * })
 * &lt;div&gt;...&lt;/div&gt;
 * @param {Object} props - Props object containing configuration for the display.
 * @param {boolean} props.isConnected - Connection status, true if currently connected.
 * @param {boolean} props.isConnecting - Connection initiation status, true if attempting to connect.
 * @param {string} props.connectionError - Description of the last encountered connection error.
 * @param {number} props.lastEventTime - Unix timestamp of the last event occurrence.
 * @param {function} props.connect - Function to initiate a connection.
 * @param {function} props.disconnect - Function to terminate the connection.
 * @param {Object} props.systemMetrics - Metrics data related to the system.
 * @param {Array} props.scrapingJobs - List of ongoing or past scraping jobs.
 * @param {Array} props.alerts - Array of alerts that have been triggered.
 * @param {boolean} props.showDetails - Flag to show detailed status information.
 * @param {function} props.onToggleDetails - Callback function to toggle detailed view.
 * @param {function} props.onAcknowledgeAlert - Function to acknowledge a specific alert.
 * @param {number} props.recentEventsCount - Count of recent events to display.
 * @param {function} props.onClearEvents - Callback function to clear the list of events.
 * @returns {JSX.Element} React component rendering the realtime status card.
 * @description
 *   - Utilizes conditional styling to indicate connection status through border color.
 *   - Last event time is formatted and passed as a Date object.
 *   - Component structure comprises a header for status and a content section for metrics and actions.
 */</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/app/admin/events/page.tsx (Line 2:2 - Line 14:2), C:/AI/food-truck-finder-poc/app/admin/food-trucks/page.tsx (Line 2:2 - Line 14:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn333" onclick="toggleCodeBlock('cloneGroup333', 'expandBtn333', 'collapseBtn333')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn333" onclick="toggleCodeBlock('cloneGroup333', 'expandBtn333', 'collapseBtn333')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup333"><code class="language-tsx text-sm text-gray-800">} from '@/lib/supabase';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from '@/components/ui/table';
import { Badge } from '@/components/ui/badge';
import { Button } from '@/components/ui/button';
import { PlusCircle,</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/app/admin/events/page.tsx (Line 207:17 - Line 225:7), C:/AI/food-truck-finder-poc/app/admin/events/page.tsx (Line 143:2 - Line 161:29)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn334" onclick="toggleCodeBlock('cloneGroup334', 'expandBtn334', 'collapseBtn334')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn334" onclick="toggleCodeBlock('cloneGroup334', 'expandBtn334', 'collapseBtn334')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup334"><code class="language-tsx text-sm text-gray-800">&lt;/TableCell&gt;
                &lt;TableCell className=&quot;text-right&quot;&gt;
                  &lt;Button asChild&gt;
                    &lt;Link href={`/admin/schedules/${schedule.id}`}&gt;
                      &lt;Edit className=&quot;size-4&quot; /&gt;
                      &lt;span className=&quot;sr-only&quot;&gt;Edit&lt;/span&gt;
                    &lt;/Link&gt;
                  &lt;/Button&gt;
                &lt;/TableCell&gt;
              &lt;/TableRow&gt;
            ))}
          &lt;/TableBody&gt;
        &lt;/Table&gt;
      &lt;/CardContent&gt;
    &lt;/Card&gt;
  );
}

export</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/app/admin/data-quality/page.tsx (Line 2:9 - Line 14:5), C:/AI/food-truck-finder-poc/app/admin/food-trucks/page.tsx (Line 2:17 - Line 14:11)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn335" onclick="toggleCodeBlock('cloneGroup335', 'expandBtn335', 'collapseBtn335')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn335" onclick="toggleCodeBlock('cloneGroup335', 'expandBtn335', 'collapseBtn335')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup335"><code class="language-tsx text-sm text-gray-800">, type FoodTruck } from '@/lib/supabase';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from '@/components/ui/table';
import { Badge } from '@/components/ui/badge';
import { Button } from '@/components/ui/button';
import { Edit</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/app/admin/data-quality/page.tsx (Line 149:6 - Line 159:2), C:/AI/food-truck-finder-poc/app/admin/food-trucks/page.tsx (Line 105:4 - Line 114:5)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn336" onclick="toggleCodeBlock('cloneGroup336', 'expandBtn336', 'collapseBtn336')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn336" onclick="toggleCodeBlock('cloneGroup336', 'expandBtn336', 'collapseBtn336')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup336"><code class="language-tsx text-sm text-gray-800">&gt;
      &lt;/TableCell&gt;
      &lt;TableCell&gt;
        {truck.last_scraped_at == undefined
          ? 'N/A'
          : new Date(truck.last_scraped_at).toLocaleDateString()}
      &lt;/TableCell&gt;
      &lt;TableCell className=&quot;text-right&quot;&gt;
        &lt;Button asChild&gt;
          &lt;Link href={`/admin/food-trucks/${truck.id}`}&gt;
            &lt;</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/fallback/supabaseFallback.test.tsx (Line 72:77 - Line 80:42), C:/AI/food-truck-finder-poc/lib/fallback/supabaseFallback.test.tsx (Line 48:57 - Line 56:26)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn419" onclick="toggleCodeBlock('cloneGroup419', 'expandBtn419', 'collapseBtn419')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn419" onclick="toggleCodeBlock('cloneGroup419', 'expandBtn419', 'collapseBtn419')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup419"><code class="language-tsx text-sm text-gray-800">, async () =&gt; {
    // Mock the supabase client to simulate an error
    supabaseFallback.supabase.from = jest.fn().mockReturnValue({
      select: jest.fn().mockReturnValue({
        abortSignal: jest.fn().mockRejectedValue(new Error('Supabase error')),
      }),
    });

    // Pre-populate the cache with stale data</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/fallback/supabaseFallback.test.tsx (Line 84:5 - Line 91:8), C:/AI/food-truck-finder-poc/lib/fallback/supabaseFallback.test.tsx (Line 60:2 - Line 67:9)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn420" onclick="toggleCodeBlock('cloneGroup420', 'expandBtn420', 'collapseBtn420')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn420" onclick="toggleCodeBlock('cloneGroup420', 'expandBtn420', 'collapseBtn420')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup420"><code class="language-tsx text-sm text-gray-800">).toLocaleString(),
    };
    window.localStorage.setItem('food-trucks-cache', JSON.stringify(cachedData));

    render(&lt;TestComponent /&gt;);

    await waitFor(() =&gt; {
      expect(screen.getByTestId('status')).toHaveTextContent('stale'</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/fallback/supabaseFallback.test.tsx (Line 96:83 - Line 104:9), C:/AI/food-truck-finder-poc/lib/fallback/supabaseFallback.test.tsx (Line 48:57 - Line 56:26)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn421" onclick="toggleCodeBlock('cloneGroup421', 'expandBtn421', 'collapseBtn421')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn421" onclick="toggleCodeBlock('cloneGroup421', 'expandBtn421', 'collapseBtn421')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup421"><code class="language-tsx text-sm text-gray-800">, async () =&gt; {
    // Mock the supabase client to simulate an error
    supabaseFallback.supabase.from = jest.fn().mockReturnValue({
      select: jest.fn().mockReturnValue({
        abortSignal: jest.fn().mockRejectedValue(new Error('Supabase error')),
      }),
    });

    function</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/lib/fallback/supabaseFallback.test.tsx (Line 104:25 - Line 110:7), C:/AI/food-truck-finder-poc/lib/fallback/supabaseFallback.test.tsx (Line 19:14 - Line 25:4)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn422" onclick="toggleCodeBlock('cloneGroup422', 'expandBtn422', 'collapseBtn422')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn422" onclick="toggleCodeBlock('cloneGroup422', 'expandBtn422', 'collapseBtn422')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup422"><code class="language-tsx text-sm text-gray-800">() {
      const { trucks, loading, dataStatus } = useFoodTrucks();
      if (loading) return &lt;div&gt;Loading...&lt;/div&gt;;
      return (
        &lt;div&gt;
          &lt;div data-testid=&quot;status&quot;&gt;{dataStatus.status}&lt;/div&gt;
          {trucks.length</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/components/monitoring/FeatureList.tsx (Line 31:17 - Line 38:6), C:/AI/food-truck-finder-poc/app/admin/data-cleanup/page.tsx (Line 154:2 - Line 161:5)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn523" onclick="toggleCodeBlock('cloneGroup523', 'expandBtn523', 'collapseBtn523')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn523" onclick="toggleCodeBlock('cloneGroup523', 'expandBtn523', 'collapseBtn523')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup523"><code class="language-tsx text-sm text-gray-800">) {
  return (
    &lt;div className=&quot;space-y-3&quot;&gt;
      &lt;h4 className=&quot;font-semibold text-sm&quot;&gt;{title}&lt;/h4&gt;
      &lt;ul className=&quot;space-y-2 text-sm text-muted-foreground&quot;&gt;
        {items.map((item, index) =&gt; (
          &lt;li key={index} className=&quot;flex items-center gap-2&quot;&gt;
            {React</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/components/map/MapComponent.tsx (Line 32:2 - Line 40:2), C:/AI/food-truck-finder-poc/components/map/MapViewUpdater.tsx (Line 10:2 - Line 18:2)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn524" onclick="toggleCodeBlock('cloneGroup524', 'expandBtn524', 'collapseBtn524')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn524" onclick="toggleCodeBlock('cloneGroup524', 'expandBtn524', 'collapseBtn524')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup524"><code class="language-tsx text-sm text-gray-800">{
  const map = useMap();
  useEffect(() =&gt; {
    if (center) {
      map.flyTo(center, zoom ?? map.getZoom());
    }
  }, [center, zoom, map]);
  return &lt;&gt;&lt;/&gt;;
}</code></pre></div><div class="py-4"><p class="text-gray-600">C:/AI/food-truck-finder-poc/components/map/MapComponent.tsx (Line 177:2 - Line 188:3), C:/AI/food-truck-finder-poc/components/map/TruckMarkers.tsx (Line 55:14 - Line 66:3)</p><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2" id="expandBtn525" onclick="toggleCodeBlock('cloneGroup525', 'expandBtn525', 'collapseBtn525')">Show code</button><button class="bg-gray-500 text-white px-1 py-0.5 text-xs rounded focus:outline-none ml-2 hidden" id="collapseBtn525" onclick="toggleCodeBlock('cloneGroup525', 'expandBtn525', 'collapseBtn525')">Hide code</button><pre class="bg-gray-100 border border-gray-200 p-4 rounded mt-2 hidden" id="cloneGroup525"><code class="language-tsx text-sm text-gray-800">}
            eventHandlers={{
              click: () =&gt; {
                if (onSelectTruck) {
                  onSelectTruck(truck.id);
                }
              },
            }}
          &gt;
            &lt;Popup&gt;
              &lt;h4 className=&quot;font-bold&quot;&gt;{truck.name}&lt;/h4&gt;
              {truck.current_location.address &amp;&amp;</code></pre></div><!-- Add more clone groups for .txt format as needed         // Add more clone groups for .txt format as needed--></div><a name="css-clones"></a><h2 class="text-2xl font-semibold text-gray-700 mb-4">css</h2><div class="divide-y divide-gray-200 border-b-2"><!-- Add more clone groups for .txt format as needed         // Add more clone groups for .txt format as needed--></div><a name="markup-clones"></a><h2 class="text-2xl font-semibold text-gray-700 mb-4">markup</h2><div class="divide-y divide-gray-200 border-b-2"><!-- Add more clone groups for .txt format as needed         // Add more clone groups for .txt format as needed--></div><a name="json-clones"></a><h2 class="text-2xl font-semibold text-gray-700 mb-4">json</h2><div class="divide-y divide-gray-200 border-b-2"><!-- Add more clone groups for .txt format as needed         // Add more clone groups for .txt format as needed--></div><a name="markdown-clones"></a><h2 class="text-2xl font-semibold text-gray-700 mb-4">markdown</h2><div class="divide-y divide-gray-200 border-b-2"><!-- Add more clone groups for .txt format as needed         // Add more clone groups for .txt format as needed--></div><a name="powershell-clones"></a><h2 class="text-2xl font-semibold text-gray-700 mb-4">powershell</h2><div class="divide-y divide-gray-200 border-b-2"><!-- Add more clone groups for .txt format as needed         // Add more clone groups for .txt format as needed--></div><a name="sql-clones"></a><h2 class="text-2xl font-semibold text-gray-700 mb-4">sql</h2><div class="divide-y divide-gray-200 border-b-2"><!-- Add more clone groups for .txt format as needed         // Add more clone groups for .txt format as needed--></div></section><!-- Add more sections for other formats and clone groups as needed--></main><footer class="bg-white shadow mt-8 py-4"><div class="container mx-auto px-4 text-center"><p class="text-sm text-gray-600">This report is generated by jscpd, an open-source copy/paste detector.</p><p class="text-sm text-gray-600">jscpd is licensed under the MIT License.</p><a class="text-blue-500 text-sm" href="https://github.com/kucherenko/jscpd" target="_blank" rel="noopener noreferrer">View jscpd on GitHub</a></div></footer><script src="js/prism.js"></script><script>function toggleCodeBlock(codeBlockId, expandBtnId, collapseBtnId) {
  const codeBlock = document.getElementById(codeBlockId);
  const expandBtn = document.getElementById(expandBtnId);
  const collapseBtn = document.getElementById(collapseBtnId);

  codeBlock.classList.toggle('hidden');
  expandBtn.classList.toggle('hidden');
  collapseBtn.classList.toggle('hidden');
}</script></body></html>