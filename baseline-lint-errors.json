[{"filePath":"C:\\AI\\food-truck-finder-poc\\.github\\actions\\scrape\\dist\\github-action-scraper.d.ts","messages":[{"ruleId":null,"nodeType":null,"fatal":true,"severity":2,"message":"Parsing error: \"parserOptions.project\" has been provided for @typescript-eslint/parser.\nThe file was not found in any of the provided project(s): .github\\actions\\scrape\\dist\\github-action-scraper.d.ts"}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"#!/usr/bin/env node\n/**\n * GitHub Action Scraper Script (TypeScript)\n *\n * This script is designed to run in GitHub Actions to process pending scraping jobs.\n * It uses ESM imports and is compatible with Node.js 20+.\n *\n * Usage: node src/actions/github-action-scraper.js --limit 10\n */\nexport {};\n","usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\.github\\actions\\scrape\\dist\\github-action-scraper.js","messages":[{"ruleId":"unicorn/filename-case","severity":2,"message":"Filename is not in camel case or pascal case. Rename it to `githubActionScraper.js` or `GithubActionScraper.js`.","line":1,"column":1,"nodeType":null,"messageId":"filename-case"},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error, info.","line":32,"column":5,"nodeType":"MemberExpression","messageId":"limited","endLine":32,"endColumn":16,"suggestions":[{"fix":{"range":[714,1094],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"unicorn/prefer-number-properties","severity":2,"message":"Prefer `Number.parseInt` over `parseInt`.","line":50,"column":15,"nodeType":"Identifier","messageId":"error","endLine":50,"endColumn":23,"fix":{"range":[1133,1141],"text":"Number.parseInt"}},{"ruleId":"unicorn/no-array-for-each","severity":2,"message":"Use `for…of` instead of `.forEach(…)`.","line":61,"column":20,"nodeType":"Identifier","messageId":"no-array-for-each/error","endLine":61,"endColumn":27,"fix":{"range":[1502,1567],"text":"for (const envVar of missingEnvVars) console.error(`  - ${envVar}`);"}},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error, info.","line":71,"column":1,"nodeType":"MemberExpression","messageId":"limited","endLine":71,"endColumn":12,"suggestions":[{"fix":{"range":[1802,1851],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error, info.","line":72,"column":1,"nodeType":"MemberExpression","messageId":"limited","endLine":72,"endColumn":12,"suggestions":[{"fix":{"range":[1852,1901],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error, info.","line":73,"column":1,"nodeType":"MemberExpression","messageId":"limited","endLine":73,"endColumn":12,"suggestions":[{"fix":{"range":[1902,1995],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"unicorn/prefer-string-slice","severity":2,"message":"Prefer `String#slice()` over `String#substring()`.","line":73,"column":33,"nodeType":"CallExpression","messageId":"substring","endLine":73,"endColumn":87,"fix":{"range":[1972,1981],"text":"slice"}},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error, info.","line":96,"column":9,"nodeType":"MemberExpression","messageId":"limited","endLine":96,"endColumn":20,"suggestions":[{"fix":{"range":[2742,2796],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error, info.","line":100,"column":13,"nodeType":"MemberExpression","messageId":"limited","endLine":100,"endColumn":24,"suggestions":[{"fix":{"range":[2988,3027],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error, info.","line":103,"column":9,"nodeType":"MemberExpression","messageId":"limited","endLine":103,"endColumn":20,"suggestions":[{"fix":{"range":[3066,3125],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error, info.","line":106,"column":9,"nodeType":"MemberExpression","messageId":"limited","endLine":106,"endColumn":20,"suggestions":[{"fix":{"range":[3240,3297],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error, info.","line":110,"column":13,"nodeType":"MemberExpression","messageId":"limited","endLine":110,"endColumn":24,"suggestions":[{"fix":{"range":[3447,3534],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error, info.","line":111,"column":13,"nodeType":"MemberExpression","messageId":"limited","endLine":111,"endColumn":24,"suggestions":[{"fix":{"range":[3547,3595],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error, info.","line":116,"column":17,"nodeType":"MemberExpression","messageId":"limited","endLine":116,"endColumn":28,"suggestions":[{"fix":{"range":[3775,3829],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error, info.","line":127,"column":17,"nodeType":"MemberExpression","messageId":"limited","endLine":127,"endColumn":28,"suggestions":[{"fix":{"range":[4353,4409],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error, info.","line":137,"column":5,"nodeType":"MemberExpression","messageId":"limited","endLine":137,"endColumn":16,"suggestions":[{"fix":{"range":[4656,4696],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error, info.","line":138,"column":5,"nodeType":"MemberExpression","messageId":"limited","endLine":138,"endColumn":16,"suggestions":[{"fix":{"range":[4701,4753],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error, info.","line":139,"column":5,"nodeType":"MemberExpression","messageId":"limited","endLine":139,"endColumn":16,"suggestions":[{"fix":{"range":[4758,4805],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error, info.","line":140,"column":5,"nodeType":"MemberExpression","messageId":"limited","endLine":140,"endColumn":16,"suggestions":[{"fix":{"range":[4810,4853],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error, info.","line":141,"column":5,"nodeType":"MemberExpression","messageId":"limited","endLine":141,"endColumn":16,"suggestions":[{"fix":{"range":[4858,4968],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error, info.","line":143,"column":9,"nodeType":"MemberExpression","messageId":"limited","endLine":143,"endColumn":20,"suggestions":[{"fix":{"range":[5005,5078],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error, info.","line":146,"column":5,"nodeType":"MemberExpression","messageId":"limited","endLine":146,"endColumn":16,"suggestions":[{"fix":{"range":[5160,5212],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error, info.","line":162,"column":5,"nodeType":"MemberExpression","messageId":"limited","endLine":162,"endColumn":16,"suggestions":[{"fix":{"range":[5570,5636],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error, info.","line":167,"column":5,"nodeType":"MemberExpression","messageId":"limited","endLine":167,"endColumn":16,"suggestions":[{"fix":{"range":[5697,5764],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"unicorn/prefer-top-level-await","severity":2,"message":"Prefer top-level await over using a promise chain.","line":172,"column":8,"nodeType":"Identifier","messageId":"promise","endLine":172,"endColumn":13}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":21,"fixableErrorCount":3,"fixableWarningCount":0,"source":"#!/usr/bin/env node\n/**\n * GitHub Action Scraper Script (TypeScript)\n *\n * This script is designed to run in GitHub Actions to process pending scraping jobs.\n * It uses ESM imports and is compatible with Node.js 20+.\n *\n * Usage: node src/actions/github-action-scraper.js --limit 10\n */\n\nimport dotenv from 'dotenv';\ndotenv.config({ path: '.env.local' });\n\nimport { parseArgs } from 'node:util';\n\n// Parse command line arguments\nconst options = {\n    limit: {\n        type: 'string',\n        short: 'l',\n        default: '10'\n    },\n    help: {\n        type: 'boolean',\n        short: 'h',\n        default: false\n    }\n};\nconst { values } = parseArgs({ options, allowPositionals: false });\n\nif (values.help) {\n    console.log(`\nGitHub Action Scraper\n\nUsage: node src/actions/github-action-scraper.js [options]\n\nOptions:\n  -l, --limit <number>  Maximum number of jobs to process (default: 10)\n  -h, --help           Show this help message\n\nEnvironment Variables Required:\n  - NEXT_PUBLIC_SUPABASE_URL\n  - SUPABASE_SERVICE_ROLE_KEY\n  - FIRECRAWL_API_KEY\n  - GEMINI_API_KEY or GOOGLE_API_KEY\n  `);\n    process.exit(0);\n}\n\nconst limit = parseInt(values.limit || '10', 10);\n\n// Validate environment variables\nconst requiredEnvVars = [\n    'NEXT_PUBLIC_SUPABASE_URL',\n    'SUPABASE_SERVICE_ROLE_KEY',\n    'FIRECRAWL_API_KEY'\n];\nconst missingEnvVars = requiredEnvVars.filter(envVar => !process.env[envVar]);\nif (missingEnvVars.length > 0) {\n    console.error('❌ Missing required environment variables:');\n    missingEnvVars.forEach(envVar => console.error(`  - ${envVar}`));\n    process.exit(1);\n}\n\n// Check for AI API key\nif (!process.env.GEMINI_API_KEY && !process.env.GOOGLE_API_KEY) {\n    console.error('❌ Missing AI API key: either GEMINI_API_KEY or GOOGLE_API_KEY is required');\n    process.exit(1);\n}\n\nconsole.log('🚀 GitHub Action Scraper Starting');\nconsole.log(`📊 Processing up to ${limit} jobs`);\nconsole.log(`🔗 Supabase URL: ${process.env.NEXT_PUBLIC_SUPABASE_URL?.substring(0, 50)}...`);\n\n// Import these after dotenv is loaded to ensure environment variables are available\nlet processScrapingJob, ScrapingJobService;\n\nasync function initializeModules() {\n  const scrapingProcessor = await import('../../../../dist/lib/pipeline/scrapingProcessor.js');\n  const scrapingJobService = await import('../../../../dist/lib/supabase/services/scrapingJobService.js');\n  processScrapingJob = scrapingProcessor.processScrapingJob;\n  ScrapingJobService = scrapingJobService.ScrapingJobService;\n}\n\n/**\n * Main execution function\n */\nasync function main() {\n    // Initialize modules with environment variables loaded\n    await initializeModules();\n\n    let processedCount = 0;\n    let successCount = 0;\n    let failureCount = 0;\n    try {\n        console.log('\\n📋 Fetching pending scraping jobs...');\n        // Get pending jobs from Supabase\n        const pendingJobs = await ScrapingJobService.getJobsByStatus('pending');\n        if (!pendingJobs || pendingJobs.length === 0) {\n            console.log('✅ No pending jobs found');\n            return;\n        }\n        console.log(`📦 Found ${pendingJobs.length} pending jobs`);\n        // Limit the number of jobs to process\n        const jobsToProcess = pendingJobs.slice(0, limit);\n        console.log(`⚡ Processing ${jobsToProcess.length} jobs`);\n        // Process jobs sequentially to avoid overwhelming APIs\n        for (const job of jobsToProcess) {\n            processedCount++;\n            console.log(`\\n[${processedCount}/${jobsToProcess.length}] Processing job: ${job.id}`);\n            console.log(`🎯 Target URL: ${job.target_url}`);\n            try {\n                // Process the scraping job using the pipeline\n                await processScrapingJob(job.id);\n                successCount++;\n                console.log(`✅ Job ${job.id} completed successfully`);\n            }\n            catch (error) {\n                failureCount++;\n                const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n                console.error(`❌ Job ${job.id} failed:`, errorMessage);\n                // Log the error but continue processing other jobs\n                console.error('Error details:', error);\n            }\n            // Add a small delay between jobs to be respectful to APIs\n            if (processedCount < jobsToProcess.length) {\n                console.log('⏱️  Waiting 2 seconds before next job...');\n                await new Promise(resolve => setTimeout(resolve, 2000));\n            }\n        }\n    }\n    catch (error) {\n        console.error('💥 Fatal error in main execution:', error);\n        process.exit(1);\n    }\n    // Final summary\n    console.log('\\n📊 Processing Summary:');\n    console.log(`  Total processed: ${processedCount}`);\n    console.log(`  Successful: ${successCount} ✅`);\n    console.log(`  Failed: ${failureCount} ❌`);\n    console.log(`  Success rate: ${processedCount > 0 ? Math.round((successCount / processedCount) * 100) : 0}%`);\n    if (failureCount > 0) {\n        console.log('\\n⚠️  Some jobs failed. Check the logs above for details.');\n        // Don't exit with error code as partial success is acceptable\n    }\n    console.log('\\n🏁 GitHub Action Scraper completed');\n}\n\n// Error handlers\nprocess.on('uncaughtException', (error) => {\n    console.error('💥 Uncaught Exception:', error);\n    process.exit(1);\n});\n\nprocess.on('unhandledRejection', (reason, promise) => {\n    console.error('💥 Unhandled Rejection at:', promise, 'reason:', reason);\n    process.exit(1);\n});\n\n// Graceful shutdown\nprocess.on('SIGINT', () => {\n    console.log('\\n⏹️  Received SIGINT, shutting down gracefully...');\n    process.exit(0);\n});\n\nprocess.on('SIGTERM', () => {\n    console.log('\\n⏹️  Received SIGTERM, shutting down gracefully...');\n    process.exit(0);\n});\n\n// Run the main function\nmain().catch((error) => {\n    console.error('💥 Unhandled error in main:', error);\n    process.exit(1);\n});\n","usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\.github\\actions\\scrape\\index.js","messages":[{"ruleId":"sonarjs/no-os-command-from-path","severity":2,"message":"Make sure the \"PATH\" used to find this command includes only what you intend.","line":11,"column":28,"nodeType":"Literal","messageId":"issue","endLine":11,"endColumn":34},{"ruleId":"unicorn/no-process-exit","severity":2,"message":"Only use `process.exit()` in CLI apps. Throw an error instead.","line":20,"column":3,"nodeType":"CallExpression","messageId":"no-process-exit","endLine":20,"endColumn":18}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { spawnSync } from 'node:child_process';\r\nimport { fileURLToPath } from 'node:url';\r\nimport path from 'node:path';\r\n\r\nconst __filename = fileURLToPath(import.meta.url);\r\nconst __dirname = path.dirname(__filename);\r\n\r\nconst scraperScript = path.join(__dirname, 'dist', 'github-action-scraper.js');\r\n\r\ntry {\r\n  const result = spawnSync('node', [scraperScript], { stdio: 'inherit' });\r\n  if (result.error) {\r\n    throw result.error;\r\n  }\r\n  if (result.status !== 0) {\r\n    throw new Error(`Scraper script exited with code ${result.status}`);\r\n  }\r\n} catch (error) {\r\n  console.error(`Failed to run scraper script: ${error}`);\r\n  process.exit(1);\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\analyze-pipeline-quality.js","messages":[{"ruleId":null,"nodeType":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token }","line":106,"column":9}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"#!/usr/bin/env node\r\n\r\n/**\r\n * Analyze Pipeline Quality Control\r\n * \r\n * This script analyzes the quality control improvements made to the food truck discovery pipeline.\r\n */\r\n\r\nimport dotenv from 'dotenv';\r\ndotenv.config({ path: '.env.local' });\r\n\r\n// Simple test of the core filtering logic without database dependencies\r\nfunction isObviouslyNonFoodTruckUrl(url) {\r\n    const nonFoodTruckPatterns = [\r\n        /\\/events?\\//i,\r\n        /\\/festivals?\\//i,\r\n        /\\/calendar/i,\r\n        /\\/blog/i,\r\n        /\\/news/i,\r\n        /\\/articles?\\//i,\r\n        /\\/government/i,\r\n        /\\/city\\.gov/i,\r\n        /\\/municipal/i,\r\n        /\\/reddit\\.com/i,\r\n        /\\/facebook\\.com/i,\r\n        /\\/instagram\\.com/i,\r\n        /\\/twitter\\.com/i,\r\n        /\\/linkedin\\.com/i,\r\n        /\\/youtube\\.com/i,\r\n        /\\/yelp\\.com/i,\r\n        /\\/google\\.com\\/maps/i,\r\n        /\\/foursquare\\.com/i,\r\n        /\\/tripadvisor\\.com/i,\r\n        /\\/zomato\\.com/i,\r\n        /\\/eventbrite\\.com/i,\r\n        /\\/meetup\\.com/i,\r\n    ];\r\n    \r\n    return nonFoodTruckPatterns.some(pattern => pattern.test(url));\r\n}\r\n\r\nasync function analyzePipelineQuality() {\r\n    console.log('🧪 Analyzing Pipeline Quality Control...\\n');\r\n    \r\n    // Test URL quality filtering\r\n    console.log('1. Testing URL quality filtering...');\r\n    \r\n    const testUrls = [\r\n        // Should be filtered out (non-food truck URLs)\r\n        'https://www.facebook.com/foodtruck',\r\n        'https://www.instagram.com/foodtruck',\r\n        'https://www.eventbrite.com/food-truck-festival',\r\n        'https://www.cityofcharleston.org/calendar',\r\n        'https://www.reddit.com/r/foodtrucks',\r\n        \r\n        // Should be processed (food truck URLs)\r\n        'https://www.bestfoodtruck.com',\r\n        'https://charlestonfoodtrucks.com',\r\n        'https://www.roaminghunger.com/charleston-food-trucks',\r\n        \r\n        // Should be filtered out (obviously non-food truck)\r\n        'https://www.charleston.gov/news',\r\n        'https://www.charleston.gov/events/calendar',\r\n        'https://www.meetup.com/charleston-foodies',\r\n    ];\r\n    \r\n    for (const url of testUrls) {\r\n        const isFoodTruckUrl = !isObviouslyNonFoodTruckUrl(url);\r\n        const result = isFoodTruckUrl ? '✅ WILL PROCESS' : '⏭️  WILL SKIP';\r\n        console.log(`   ${result} ${url}`);\r\n    }\r\n    \r\n    console.log('\\n✅ Pipeline quality control analysis completed');\r\n    \r\n    console.log('\\n📋 Summary of Quality Control Improvements:');\r\n    console.log('   🚫 URL Quality Filtering:');\r\n    console.log('      - Non-food truck URLs are properly filtered out');\r\n    console.log('      - Social media and event sites are automatically skipped');\r\n    console.log('      - Government and news sites are filtered');\r\n    console.log('      - Resource waste is prevented');\r\n    \r\n    console.log('\\n   📊 URL Quality Scoring:');\r\n    console.log('      - Success increases quality score (+0.2)');\r\n    console.log('      - Failure decreases quality score (-0.3)');\r\n    console.log('      - Processing attempts are tracked');\r\n    console.log('      - Blacklisting prevents repeated failures');\r\n    \r\n    console.log('\\n   🎯 Pipeline Improvements:');\r\n    console.log('      - \"Unknown Food Truck\" entries eliminated');\r\n    console.log('      - Null/empty names are properly discarded');\r\n    console.log('      - Pre-filtering prevents storing invalid URLs');\r\n    console.log('      - The pipeline is more efficient and accurate');\r\n    \r\n    console.log('\\n   📈 Impact:');\r\n    console.log('      - Reduced database bloat');\r\n    console.log('      - Lower API usage costs');\r\n    console.log('      - Better data quality');\r\n    console.log('      - More reliable scraping results');\r\n}\r\n\r\n// Run the analysis\r\nanalyzePipelineQuality().catch(error => {\r\n    console.error('❌ Analysis failed:', error);\r\n    process.exit(1);\r\n});\r\n        }\r\n        urlPerformance[job.target_url].total++;\r\n        urlPerformance[job.target_url][job.status]++;\r\n      });\r\n\r\n      // URLs with 100% failure rate and multiple attempts\r\n      const consistentlyFailingUrls = Object.entries(urlPerformance)\r\n        .filter(([_, stats]) => stats.failed > 0 && stats.completed === 0 && stats.total > 1)\r\n        .map(([url, stats]) => ({ url, failureRate: (stats.failed / stats.total) * 100, attempts: stats.total }))\r\n        .sort((a, b) => b.attempts - a.attempts);\r\n\r\n      if (consistentlyFailingUrls.length > 0) {\r\n        console.log('⚠️  URLs with consistently poor performance (100% failure rate, multiple attempts):');\r\n        consistentlyFailingUrls.slice(0, 5).forEach(({ url, attempts }) => {\r\n          console.log(`    - ${url} (${attempts} failed attempts)`);\r\n        });\r\n        console.log('\\n💡 Recommendation: Blacklist these URLs to prevent resource waste');\r\n      }\r\n\r\n      // URLs with high failure rates (>50%)\r\n      const highFailureUrls = Object.entries(urlPerformance)\r\n        .filter(([_, stats]) => stats.total > 2 && (stats.failed / stats.total) > 0.5)\r\n        .map(([url, stats]) => ({ url, failureRate: (stats.failed / stats.total) * 100, attempts: stats.total }))\r\n        .sort((a, b) => b.failureRate - a.failureRate);\r\n\r\n      if (highFailureUrls.length > 0) {\r\n        console.log('\\n⚠️  URLs with high failure rates (>50%):');\r\n        highFailureUrls.slice(0, 5).forEach(({ url, failureRate, attempts }) => {\r\n          console.log(`    - ${url} (${failureRate.toFixed(1)}% failure rate over ${attempts} attempts)`);\r\n        });\r\n        console.log('\\n💡 Recommendation: Add quality scoring and retry limits for these URLs');\r\n      }\r\n    }\r\n\r\n    console.log('\\n✅ Pipeline quality analysis complete!');\r\n\r\n  } catch (error) {\r\n    console.error('💥 Unexpected error:', error);\r\n  }\r\n}\r\n\r\nanalyzePipelineQuality().then(() => {\r\n  process.exit(0);\r\n}).catch((error) => {\r\n  console.error('💥 Fatal error:', error);\r\n  process.exit(1);\r\n});\r\n","usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\analyzePipelineQuality.js","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error, info.","line":68,"column":5,"nodeType":"MemberExpression","messageId":"limited","endLine":68,"endColumn":16,"suggestions":[{"fix":{"range":[1836,1894],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error, info.","line":71,"column":5,"nodeType":"MemberExpression","messageId":"limited","endLine":71,"endColumn":16,"suggestions":[{"fix":{"range":[1941,1992],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error, info.","line":95,"column":9,"nodeType":"MemberExpression","messageId":"limited","endLine":95,"endColumn":20,"suggestions":[{"fix":{"range":[2965,3000],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error, info.","line":98,"column":5,"nodeType":"MemberExpression","messageId":"limited","endLine":98,"endColumn":16,"suggestions":[{"fix":{"range":[3019,3082],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error, info.","line":100,"column":5,"nodeType":"MemberExpression","messageId":"limited","endLine":100,"endColumn":16,"suggestions":[{"fix":{"range":[3094,3155],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error, info.","line":101,"column":5,"nodeType":"MemberExpression","messageId":"limited","endLine":101,"endColumn":16,"suggestions":[{"fix":{"range":[3161,3205],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error, info.","line":102,"column":5,"nodeType":"MemberExpression","messageId":"limited","endLine":102,"endColumn":16,"suggestions":[{"fix":{"range":[3211,3280],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error, info.","line":103,"column":5,"nodeType":"MemberExpression","messageId":"limited","endLine":103,"endColumn":16,"suggestions":[{"fix":{"range":[3286,3364],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error, info.","line":104,"column":5,"nodeType":"MemberExpression","messageId":"limited","endLine":104,"endColumn":16,"suggestions":[{"fix":{"range":[3370,3432],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error, info.","line":105,"column":5,"nodeType":"MemberExpression","messageId":"limited","endLine":105,"endColumn":16,"suggestions":[{"fix":{"range":[3438,3489],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error, info.","line":107,"column":5,"nodeType":"MemberExpression","messageId":"limited","endLine":107,"endColumn":16,"suggestions":[{"fix":{"range":[3501,3545],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error, info.","line":108,"column":5,"nodeType":"MemberExpression","messageId":"limited","endLine":108,"endColumn":16,"suggestions":[{"fix":{"range":[3551,3613],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error, info.","line":109,"column":5,"nodeType":"MemberExpression","messageId":"limited","endLine":109,"endColumn":16,"suggestions":[{"fix":{"range":[3619,3681],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error, info.","line":110,"column":5,"nodeType":"MemberExpression","messageId":"limited","endLine":110,"endColumn":16,"suggestions":[{"fix":{"range":[3687,3742],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error, info.","line":111,"column":5,"nodeType":"MemberExpression","messageId":"limited","endLine":111,"endColumn":16,"suggestions":[{"fix":{"range":[3748,3811],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error, info.","line":113,"column":5,"nodeType":"MemberExpression","messageId":"limited","endLine":113,"endColumn":16,"suggestions":[{"fix":{"range":[3823,3869],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error, info.","line":114,"column":5,"nodeType":"MemberExpression","messageId":"limited","endLine":114,"endColumn":16,"suggestions":[{"fix":{"range":[3875,3938],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error, info.","line":115,"column":5,"nodeType":"MemberExpression","messageId":"limited","endLine":115,"endColumn":16,"suggestions":[{"fix":{"range":[3944,4007],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error, info.","line":116,"column":5,"nodeType":"MemberExpression","messageId":"limited","endLine":116,"endColumn":16,"suggestions":[{"fix":{"range":[4013,4080],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error, info.","line":117,"column":5,"nodeType":"MemberExpression","messageId":"limited","endLine":117,"endColumn":16,"suggestions":[{"fix":{"range":[4086,4153],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error, info.","line":119,"column":5,"nodeType":"MemberExpression","messageId":"limited","endLine":119,"endColumn":16,"suggestions":[{"fix":{"range":[4165,4196],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error, info.","line":120,"column":5,"nodeType":"MemberExpression","messageId":"limited","endLine":120,"endColumn":16,"suggestions":[{"fix":{"range":[4202,4248],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error, info.","line":121,"column":5,"nodeType":"MemberExpression","messageId":"limited","endLine":121,"endColumn":16,"suggestions":[{"fix":{"range":[4254,4299],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error, info.","line":122,"column":5,"nodeType":"MemberExpression","messageId":"limited","endLine":122,"endColumn":16,"suggestions":[{"fix":{"range":[4305,4348],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error, info.","line":123,"column":5,"nodeType":"MemberExpression","messageId":"limited","endLine":123,"endColumn":16,"suggestions":[{"fix":{"range":[4354,4408],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"unicorn/prefer-top-level-await","severity":2,"message":"Prefer top-level await over using a promise chain.","line":127,"column":26,"nodeType":"Identifier","messageId":"promise","endLine":127,"endColumn":31}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":25,"fixableErrorCount":0,"fixableWarningCount":0,"source":"#!/usr/bin/env node\r\n\r\n/**\r\n * Analyze Pipeline Quality Control\r\n * \r\n * This script analyzes the quality control improvements made to the food truck discovery pipeline.\r\n */\r\n\r\nimport dotenv from 'dotenv';\r\ndotenv.config({ path: '.env.local' });\r\n\r\n// Simple test of the core filtering logic without database dependencies\r\nfunction isObviouslyNonFoodTruckUrl(url) {\r\n    const nonFoodTruckPatterns = [\r\n        /\\/events?\\//i,\r\n        /\\/festivals?\\//i,\r\n        /\\/calendar/i,\r\n        /\\/blog/i,\r\n        /\\/news/i,\r\n        /\\/articles?\\//i,\r\n        /\\/government/i,\r\n        /\\/city\\.gov/i,\r\n        /\\/municipal/i,\r\n        /\\/reddit\\.com/i,\r\n        /\\/facebook\\.com/i,\r\n        /\\/instagram\\.com/i,\r\n        /\\/twitter\\.com/i,\r\n        /\\/linkedin\\.com/i,\r\n        /\\/youtube\\.com/i,\r\n        /\\/yelp\\.com/i,\r\n        /\\/google\\.com\\/maps/i,\r\n        /\\/foursquare\\.com/i,\r\n        /\\/tripadvisor\\.com/i,\r\n        /\\/zomato\\.com/i,\r\n        /\\/eventbrite\\.com/i,\r\n        /\\/meetup\\.com/i,\r\n    ];\r\n    \r\n    // Also check for blacklist keywords like the discovery engine does\r\n    const blacklistKeywords = [\r\n        'facebook.com',\r\n        'instagram.com',\r\n        'twitter.com',\r\n        'linkedin.com',\r\n        'youtube.com',\r\n        'yelp.com',\r\n        'google.com',\r\n        'maps.google.com',\r\n        'foursquare.com',\r\n        'tripadvisor.com',\r\n        'zomato.com',\r\n        'eventbrite.com',\r\n        'meetup.com',\r\n    ];\r\n    \r\n    const urlLower = url.toLowerCase();\r\n    \r\n    // Check regex patterns first\r\n    if (nonFoodTruckPatterns.some(pattern => pattern.test(urlLower))) {\r\n        return true;\r\n    }\r\n    \r\n    // Check blacklist keywords like discovery engine does\r\n    return blacklistKeywords.some(keyword => urlLower.includes(keyword));\r\n}\r\n\r\nasync function analyzePipelineQuality() {\r\n    console.log('🧪 Analyzing Pipeline Quality Control...\\n');\r\n    \r\n    // Test URL quality filtering\r\n    console.log('1. Testing URL quality filtering...');\r\n    \r\n    const testUrls = [\r\n        // Should be filtered out (non-food truck URLs)\r\n        'https://www.facebook.com/foodtruck',\r\n        'https://www.instagram.com/foodtruck',\r\n        'https://www.eventbrite.com/food-truck-festival',\r\n        'https://www.cityofcharleston.org/calendar',\r\n        'https://www.reddit.com/r/foodtrucks',\r\n        \r\n        // Should be processed (food truck URLs)\r\n        'https://www.bestfoodtruck.com',\r\n        'https://charlestonfoodtrucks.com',\r\n        'https://www.roaminghunger.com/charleston-food-trucks',\r\n        \r\n        // Should be filtered out (obviously non-food truck)\r\n        'https://www.charleston.gov/news',\r\n        'https://www.charleston.gov/events/calendar',\r\n        'https://www.meetup.com/charleston-foodies',\r\n    ];\r\n    \r\n    for (const url of testUrls) {\r\n        const shouldSkip = isObviouslyNonFoodTruckUrl(url);\r\n        const result = shouldSkip ? '⏭️  WILL SKIP' : '✅ WILL PROCESS';\r\n        console.log(`   ${result} ${url}`);\r\n    }\r\n    \r\n    console.log('\\n✅ Pipeline quality control analysis completed');\r\n    \r\n    console.log('\\n📋 Summary of Quality Control Improvements:');\r\n    console.log('   🚫 URL Quality Filtering:');\r\n    console.log('      - Non-food truck URLs are properly filtered out');\r\n    console.log('      - Social media and event sites are automatically skipped');\r\n    console.log('      - Government and news sites are filtered');\r\n    console.log('      - Resource waste is prevented');\r\n    \r\n    console.log('\\n   📊 URL Quality Scoring:');\r\n    console.log('      - Success increases quality score (+0.2)');\r\n    console.log('      - Failure decreases quality score (-0.3)');\r\n    console.log('      - Processing attempts are tracked');\r\n    console.log('      - Blacklisting prevents repeated failures');\r\n    \r\n    console.log('\\n   🎯 Pipeline Improvements:');\r\n    console.log('      - \"Unknown Food Truck\" entries eliminated');\r\n    console.log('      - Null/empty names are properly discarded');\r\n    console.log('      - Pre-filtering prevents storing invalid URLs');\r\n    console.log('      - The pipeline is more efficient and accurate');\r\n    \r\n    console.log('\\n   📈 Impact:');\r\n    console.log('      - Reduced database bloat');\r\n    console.log('      - Lower API usage costs');\r\n    console.log('      - Better data quality');\r\n    console.log('      - More reliable scraping results');\r\n}\r\n\r\n// Run the analysis\r\nanalyzePipelineQuality().catch(error => {\r\n    console.error('❌ Analysis failed:', error);\r\n    process.exit(1);\r\n});\r\n","usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\app\\access-denied\\page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\app\\admin\\analytics\\page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\app\\admin\\auto-scraping\\page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\app\\admin\\data-cleanup\\page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\app\\admin\\data-quality\\page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\app\\admin\\events\\page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\app\\admin\\food-trucks\\[id]\\page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\app\\admin\\food-trucks\\page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\app\\admin\\layout.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\app\\admin\\monitoring\\page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\app\\admin\\page.tsx","messages":[{"ruleId":"unicorn/no-useless-undefined","severity":2,"message":"Do not use useless `undefined`.","line":40,"column":81,"nodeType":null,"messageId":"no-useless-undefined","endLine":40,"endColumn":90,"fix":{"range":[1572,1581],"text":""}}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":1,"fixableWarningCount":0,"source":"'use client';\r\n\r\nimport { useFoodTrucks, DataStatusIndicator } from '@/lib/fallback/supabaseFallback';\r\nimport {\r\n  ScrapingJobService,\r\n  DataProcessingService,\r\n  supabase,\r\n} from '@/lib/supabase';\r\nimport { TotalFoodTrucksCard } from '@/components/admin/dashboard/TotalFoodTrucksCard';\r\nimport { PipelineStatusCard } from '@/components/admin/dashboard/PipelineStatusCard';\r\nimport { DataQualityScoreCard } from '@/components/admin/dashboard/DataQualityScoreCard';\r\nimport { QualityDistributionCard } from '@/components/admin/dashboard/QualityDistributionCard';\r\nimport { RecentErrorsCard } from '@/components/admin/dashboard/RecentErrorsCard';\r\nimport { useEffect, useState } from 'react';\r\n\r\n// Define the data quality stats type based on the database function\r\ninterface DataQualityStats {\r\n  readonly total_trucks: number;\r\n  readonly avg_quality_score: number;\r\n  readonly high_quality_count: number;\r\n  readonly medium_quality_count: number;\r\n  readonly low_quality_count: number;\r\n  readonly verified_count: number;\r\n  readonly pending_count: number;\r\n  readonly flagged_count: number;\r\n}\r\n\r\ninterface DashboardData {\r\n  totalFoodTrucks: number;\r\n  pendingVerifications: number;\r\n  pendingScrapingJobsCount: number;\r\n  runningScrapingJobsCount: number;\r\n  failedScrapingJobsCount: number;\r\n  failedProcessingQueueItemsCount: number;\r\n  dataQualityStats: DataQualityStats;\r\n}\r\n\r\nexport default function AdminDashboard() {\r\n  const { trucks, loading, dataStatus } = useFoodTrucks();\r\n  const [dashboardData, setDashboardData] = useState<DashboardData | undefined>(undefined);\r\n\r\n  useEffect(() => {\r\n    const getDashboardData = async () => {\r\n      const pendingVerifications = trucks.filter((t) => t.verification_status === 'pending').length;\r\n\r\n      const pendingScrapingJobs = await ScrapingJobService.getJobsByStatus('pending');\r\n      const runningScrapingJobs = await ScrapingJobService.getJobsByStatus('running');\r\n      const failedScrapingJobs = await ScrapingJobService.getJobsByStatus('failed');\r\n\r\n      const failedProcessingQueueItems = await DataProcessingService.getQueueByStatus('failed');\r\n      \r\n      const { data: qualityStatsResult, error: qualityError } = await supabase\r\n        .rpc('get_data_quality_stats')\r\n        .single();\r\n\r\n      if (qualityError) {\r\n        // The error is logged here, but the promise rejection will be caught below.\r\n        console.error('Error fetching data quality stats:', qualityError);\r\n        throw qualityError; // Re-throw to be caught by the .catch() block\r\n      }\r\n\r\n      const dataQualityStats: DataQualityStats = (qualityStatsResult as DataQualityStats) ?? {\r\n        total_trucks: 0,\r\n        avg_quality_score: 0,\r\n        high_quality_count: 0,\r\n        medium_quality_count: 0,\r\n        low_quality_count: 0,\r\n        verified_count: 0,\r\n        pending_count: 0,\r\n        flagged_count: 0,\r\n      };\r\n\r\n      setDashboardData({\r\n        totalFoodTrucks: trucks.length,\r\n        pendingVerifications,\r\n        pendingScrapingJobsCount: pendingScrapingJobs.length,\r\n        runningScrapingJobsCount: runningScrapingJobs.length,\r\n        failedScrapingJobsCount: failedScrapingJobs.length,\r\n        failedProcessingQueueItemsCount: failedProcessingQueueItems.length,\r\n        dataQualityStats,\r\n      });\r\n    };\r\n\r\n    if (trucks.length > 0) {\r\n      // Correctly handle the floating promise by wrapping the call and adding a .catch block.\r\n      (async () => {\r\n        await getDashboardData();\r\n      })().catch(error => {\r\n        console.error(\"An unhandled error occurred in getDashboardData:\", error);\r\n      });\r\n    }\r\n  }, [trucks]);\r\n\r\n  if (loading || !dashboardData) {\r\n    return <div>Loading...</div>;\r\n  }\r\n\r\n  if (dataStatus.status === 'unavailable') {\r\n    return (\r\n      <div className=\"flex flex-col gap-4\">\r\n        <h1 className=\"text-2xl font-bold\">Admin Dashboard</h1>\r\n        <DataStatusIndicator status={dataStatus} />\r\n        <div className=\"text-center py-10\">\r\n          <p className=\"text-lg text-gray-500\">Food truck data is currently unavailable. Please try again later.</p>\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n\r\n  return (\r\n    <div className=\"flex flex-col gap-4\">\r\n      <h1 className=\"text-2xl font-bold\">Admin Dashboard</h1>\r\n      <DataStatusIndicator status={dataStatus} />\r\n\r\n      <div className=\"grid gap-4 md:grid-cols-2 lg:grid-cols-4\">\r\n        <TotalFoodTrucksCard\r\n          totalFoodTrucks={dashboardData.totalFoodTrucks}\r\n          pendingVerifications={dashboardData.pendingVerifications}\r\n        />\r\n        <PipelineStatusCard\r\n          pendingScrapingJobsCount={dashboardData.pendingScrapingJobsCount}\r\n          runningScrapingJobsCount={dashboardData.runningScrapingJobsCount}\r\n          failedScrapingJobsCount={dashboardData.failedScrapingJobsCount}\r\n        />\r\n        <DataQualityScoreCard dataQualityStats={dashboardData.dataQualityStats} />\r\n        <QualityDistributionCard dataQualityStats={dashboardData.dataQualityStats} />\r\n        <RecentErrorsCard failedProcessingQueueItemsCount={dashboardData.failedProcessingQueueItemsCount} />\r\n      </div>\r\n    </div>\r\n  );\r\n}","usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\app\\admin\\pipeline\\page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\app\\admin\\test-pipeline\\page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\app\\admin\\users\\page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\app\\api\\admin\\automated-cleanup\\route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\app\\api\\admin\\cron-status\\route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\app\\api\\admin\\data-cleanup\\route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\app\\api\\admin\\data-quality\\route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\app\\api\\admin\\oauth-status\\route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\app\\api\\admin\\realtime-events\\route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\app\\api\\admin\\scraping-metrics\\route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\app\\api\\analytics\\web-vitals\\route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\app\\api\\auto-scrape-initiate\\route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\app\\api\\autonomous-discovery\\route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\app\\api\\cron\\auto-scrape\\route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\app\\api\\cron\\quality-check\\route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\app\\api\\dashboard\\route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\app\\api\\enhanced-pipeline\\route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\app\\api\\firecrawl\\route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\app\\api\\gemini\\route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\app\\api\\monitoring\\api-usage\\route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\app\\api\\pipeline\\route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\app\\api\\process-jobs\\route.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":15,"column":10,"nodeType":"Identifier","messageId":"conditionErrorNullableString","endLine":15,"endColumn":20,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[569,580],"text":"(cronSecret == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[570,580],"text":"(cronSecret ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[569,580],"text":"(!Boolean(cronSecret))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"sonarjs/no-misleading-array-reverse","severity":2,"message":"Move this array \"sort\" operation to a separate statement or replace it with \"toSorted\".","line":29,"column":27,"nodeType":"CallExpression","messageId":"moveMethod","endLine":30,"endColumn":47,"suggestions":[{"messageId":"suggestMethod","data":{"suggestedMethod":"toSorted"},"fix":{"range":[1019,1023],"text":"toSorted"},"desc":"Replace with \"toSorted\" method"}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error, info.","line":33,"column":5,"nodeType":"MemberExpression","messageId":"limited","endLine":33,"endColumn":16,"suggestions":[{"fix":{"range":[1128,1220],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error, info.","line":38,"column":9,"nodeType":"MemberExpression","messageId":"limited","endLine":38,"endColumn":20,"suggestions":[{"fix":{"range":[1376,1436],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error, info.","line":54,"column":9,"nodeType":"MemberExpression","messageId":"limited","endLine":54,"endColumn":20,"suggestions":[{"fix":{"range":[1877,1929],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async function 'GET' has no 'await' expression.","line":100,"column":8,"nodeType":"FunctionDeclaration","messageId":"missingAwait","endLine":100,"endColumn":26,"suggestions":[{"messageId":"removeAsync","fix":{"range":[3141,3147],"text":""},"desc":"Remove 'async'."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { NextRequest, NextResponse } from 'next/server';\r\nimport { ScrapingJobService } from '@/lib/supabase';\r\nimport { processScrapingJob } from '@/lib/pipelineProcessor';\r\nimport { logActivity } from '@/lib/activityLogger';\r\n\r\n// Process jobs for up to 9 seconds (Vercel timeout is 10s)\r\nconst MAX_PROCESSING_TIME = 9000;\r\n\r\nexport async function POST(request: NextRequest) {\r\n  try {\r\n    // Simple auth check - in production, use proper auth\r\n    const authHeader = request.headers.get('authorization');\r\n    const cronSecret = process.env.CRON_SECRET;\r\n\r\n    if (!cronSecret || authHeader !== `Bearer ${cronSecret}`) {\r\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });\r\n    }\r\n\r\n    const startTime = Date.now();\r\n    const results = {\r\n      processed: 0,\r\n      succeeded: 0,\r\n      failed: 0,\r\n      errors: [] as string[]\r\n    };\r\n\r\n    // Get pending jobs\r\n    const pendingJobs = await ScrapingJobService.getJobsByStatus('pending');\r\n    const jobsToProcess = pendingJobs\r\n      .sort((a, b) => b.priority - a.priority)\r\n      .slice(0, 5); // Process at most 5 jobs per invocation\r\n\r\n    console.log(`Found ${pendingJobs.length} pending jobs, processing ${jobsToProcess.length}`);\r\n\r\n    for (const job of jobsToProcess) {\r\n      // Check if we're approaching timeout\r\n      if (Date.now() - startTime > MAX_PROCESSING_TIME) {\r\n        console.log('Approaching timeout, stopping job processing');\r\n        break;\r\n      }\r\n\r\n      try {\r\n        results.processed++;\r\n        \r\n        // Process the job with a timeout\r\n        const jobPromise = processScrapingJob(job.id);\r\n        const timeoutPromise = new Promise((_, reject) => \r\n          setTimeout(() => reject(new Error('Job processing timeout')), 5000)\r\n        );\r\n\r\n        await Promise.race([jobPromise, timeoutPromise]);\r\n        \r\n        results.succeeded++;\r\n        console.log(`Successfully processed job ${job.id}`);\r\n      } catch (error) {\r\n        results.failed++;\r\n        const errorMsg = error instanceof Error ? error.message : 'Unknown error';\r\n        results.errors.push(`Job ${job.id}: ${errorMsg}`);\r\n        \r\n        // Mark job as failed\r\n        await ScrapingJobService.updateJobStatus(job.id, 'failed', {\r\n          errors: [errorMsg]\r\n        });\r\n        \r\n        console.error(`Failed to process job ${job.id}:`, error);\r\n      }\r\n    }\r\n\r\n    logActivity({\r\n      type: 'cron_job',\r\n      action: 'batch_process_completed',\r\n      details: {\r\n        timestamp: new Date().toISOString(),\r\n        ...results\r\n      }\r\n    });\r\n\r\n    return NextResponse.json({\r\n      success: true,\r\n      message: 'Job processing completed',\r\n      data: {\r\n        ...results,\r\n        remainingJobs: pendingJobs.length - results.processed,\r\n        executionTime: Date.now() - startTime\r\n      }\r\n    });\r\n  } catch (error) {\r\n    console.error('Job processor failed:', error);\r\n    return NextResponse.json(\r\n      {\r\n        success: false,\r\n        error: 'Job processing failed',\r\n        message: error instanceof Error ? error.message : 'Unknown error'\r\n      },\r\n      { status: 500 }\r\n    );\r\n  }\r\n}\r\n\r\nexport async function GET() {\r\n  return NextResponse.json(\r\n    { \r\n      message: 'Job processor endpoint',\r\n      info: 'Use POST with proper authorization to process pending jobs'\r\n    }\r\n  );\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\app\\api\\scheduler\\route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\app\\api\\scrape\\route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\app\\api\\search\\route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\app\\api\\tavily\\route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\app\\api\\test-integration\\route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\app\\api\\test-pipeline-run\\route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\app\\api\\trucks\\[id]\\route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\app\\api\\trucks\\route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\app\\auth\\AuthProvider.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\app\\auth\\callback\\route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\app\\layout.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\app\\loading.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\app\\login\\page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\app\\middleware.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\app\\page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\app\\trucks\\[id]\\page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\check-constraints.js","messages":[{"ruleId":"unicorn/filename-case","severity":2,"message":"Filename is not in camel case or pascal case. Rename it to `checkConstraints.js` or `CheckConstraints.js`.","line":1,"column":1,"nodeType":null,"messageId":"filename-case"},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error, info.","line":12,"column":3,"nodeType":"MemberExpression","messageId":"limited","endLine":12,"endColumn":14,"suggestions":[{"fix":{"range":[288,348],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error, info.","line":25,"column":5,"nodeType":"MemberExpression","messageId":"limited","endLine":25,"endColumn":16,"suggestions":[{"fix":{"range":[629,677],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error, info.","line":27,"column":5,"nodeType":"MemberExpression","messageId":"limited","endLine":27,"endColumn":16,"suggestions":[{"fix":{"range":[695,743],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"unicorn/no-array-for-each","severity":2,"message":"Use `for…of` instead of `.forEach(…)`.","line":28,"column":13,"nodeType":"Identifier","messageId":"no-array-for-each/error","endLine":28,"endColumn":20,"fix":{"range":[749,849],"text":"for (const index of indexes) {\r\n      console.log(`  - ${index.indexname}: ${index.indexdef}`);\r\n    }"}},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error, info.","line":29,"column":7,"nodeType":"MemberExpression","messageId":"limited","endLine":29,"endColumn":18,"suggestions":[{"fix":{"range":[783,840],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error, info.","line":44,"column":5,"nodeType":"MemberExpression","messageId":"limited","endLine":44,"endColumn":16,"suggestions":[{"fix":{"range":[1169,1226],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error, info.","line":46,"column":5,"nodeType":"MemberExpression","messageId":"limited","endLine":46,"endColumn":16,"suggestions":[{"fix":{"range":[1244,1296],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"unicorn/no-array-for-each","severity":2,"message":"Use `for…of` instead of `.forEach(…)`.","line":47,"column":17,"nodeType":"Identifier","messageId":"no-array-for-each/error","endLine":47,"endColumn":24,"fix":{"range":[1302,1425],"text":"for (const constraint of constraints) {\r\n      console.log(`  - ${constraint.conname} (type: ${constraint.contype})`);\r\n    }"}},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error, info.","line":48,"column":7,"nodeType":"MemberExpression","messageId":"limited","endLine":48,"endColumn":18,"suggestions":[{"fix":{"range":[1345,1416],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error, info.","line":66,"column":5,"nodeType":"MemberExpression","messageId":"limited","endLine":66,"endColumn":16,"suggestions":[{"fix":{"range":[1954,2010],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error, info.","line":68,"column":5,"nodeType":"MemberExpression","messageId":"limited","endLine":68,"endColumn":16,"suggestions":[{"fix":{"range":[2028,2072],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error, info.","line":70,"column":7,"nodeType":"MemberExpression","messageId":"limited","endLine":70,"endColumn":18,"suggestions":[{"fix":{"range":[2121,2176],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"unicorn/no-array-for-each","severity":2,"message":"Use `for…of` instead of `.forEach(…)`.","line":72,"column":23,"nodeType":"Identifier","messageId":"no-array-for-each/error","endLine":72,"endColumn":30,"fix":{"range":[2198,2339],"text":"for (const constraint of nameConstraints) {\r\n        console.log(`  - ${constraint.constraint_name} (${constraint.constraint_type})`);\r\n      }"}},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error, info.","line":73,"column":9,"nodeType":"MemberExpression","messageId":"limited","endLine":73,"endColumn":20,"suggestions":[{"fix":{"range":[2247,2328],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"unicorn/prefer-top-level-await","severity":2,"message":"Prefer top-level await over using a promise chain.","line":79,"column":20,"nodeType":"Identifier","messageId":"promise","endLine":79,"endColumn":25}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":11,"fixableErrorCount":3,"fixableWarningCount":0,"source":"import dotenv from 'dotenv';\r\ndotenv.config({ path: '.env.local' });\r\n\r\nimport { createClient } from '@supabase/supabase-js';\r\n\r\nconst supabase = createClient(\r\n  process.env.NEXT_PUBLIC_SUPABASE_URL,\r\n  process.env.SUPABASE_SERVICE_ROLE_KEY\r\n);\r\n\r\nasync function checkConstraints() {\r\n  console.log('🔍 Checking food_trucks table constraints...');\r\n  \r\n  // Check indexes\r\n  const { data: indexes, error: indexError } = await supabase\r\n    .rpc('execute_sql', {\r\n      sql: `\r\n        SELECT indexname, indexdef \r\n        FROM pg_indexes \r\n        WHERE tablename = 'food_trucks'\r\n      `\r\n    });\r\n  \r\n  if (indexError) {\r\n    console.log('Indexes query error:', indexError);\r\n  } else {\r\n    console.log('📋 Indexes on food_trucks table:');\r\n    indexes.forEach(index => {\r\n      console.log(`  - ${index.indexname}: ${index.indexdef}`);\r\n    });\r\n  }\r\n  \r\n  // Check constraints\r\n  const { data: constraints, error: constraintError } = await supabase\r\n    .rpc('execute_sql', {\r\n      sql: `\r\n        SELECT conname, contype, conkey\r\n        FROM pg_constraint \r\n        WHERE conrelid = 'food_trucks'::regclass\r\n      `\r\n    });\r\n  \r\n  if (constraintError) {\r\n    console.log('Constraints query error:', constraintError);\r\n  } else {\r\n    console.log('🔒 Constraints on food_trucks table:');\r\n    constraints.forEach(constraint => {\r\n      console.log(`  - ${constraint.conname} (type: ${constraint.contype})`);\r\n    });\r\n  }\r\n  \r\n  // Check if name column has unique constraint\r\n  const { data: nameConstraints, error: nameError } = await supabase\r\n    .rpc('execute_sql', {\r\n      sql: `\r\n        SELECT tc.constraint_name, tc.constraint_type\r\n        FROM information_schema.table_constraints tc\r\n        JOIN information_schema.constraint_column_usage ccu \r\n          ON tc.constraint_name = ccu.constraint_name\r\n        WHERE tc.table_name = 'food_trucks' \r\n          AND ccu.column_name = 'name'\r\n      `\r\n    });\r\n  \r\n  if (nameError) {\r\n    console.log('Name constraints query error:', nameError);\r\n  } else {\r\n    console.log('🏷️ Name column constraints:');\r\n    if (nameConstraints.length === 0) {\r\n      console.log('  ❌ No constraints found on name column');\r\n    } else {\r\n      nameConstraints.forEach(constraint => {\r\n        console.log(`  - ${constraint.constraint_name} (${constraint.constraint_type})`);\r\n      });\r\n    }\r\n  }\r\n}\r\n\r\ncheckConstraints().catch(console.error);\r\n","usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\check-discovered-urls.js","messages":[{"ruleId":"unicorn/filename-case","severity":2,"message":"Filename is not in camel case or pascal case. Rename it to `checkDiscoveredUrls.js` or `CheckDiscoveredUrls.js`.","line":1,"column":1,"nodeType":null,"messageId":"filename-case"},{"ruleId":"unicorn/no-process-exit","severity":2,"message":"Only use `process.exit()` in CLI apps. Throw an error instead.","line":12,"column":3,"nodeType":"CallExpression","messageId":"no-process-exit","endLine":12,"endColumn":18},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error, info.","line":19,"column":5,"nodeType":"MemberExpression","messageId":"limited","endLine":19,"endColumn":16,"suggestions":[{"fix":{"range":[518,570],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error, info.","line":32,"column":5,"nodeType":"MemberExpression","messageId":"limited","endLine":32,"endColumn":16,"suggestions":[{"fix":{"range":[858,925],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"unicorn/no-array-for-each","severity":2,"message":"Use `for…of` instead of `.forEach(…)`.","line":33,"column":20,"nodeType":"Identifier","messageId":"no-array-for-each/error","endLine":33,"endColumn":27,"fix":{"range":[931,1052],"text":"for (const [index, url] of discoveredUrls.entries()) {\r\n      console.log(`${index + 1}. ${url.url} (status: ${url.status})`);\r\n    }"}},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error, info.","line":34,"column":7,"nodeType":"MemberExpression","messageId":"limited","endLine":34,"endColumn":18,"suggestions":[{"fix":{"range":[979,1043],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error, info.","line":38,"column":5,"nodeType":"MemberExpression","messageId":"limited","endLine":38,"endColumn":16,"suggestions":[{"fix":{"range":[1123,1183],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"unicorn/no-array-for-each","severity":2,"message":"Use `for…of` instead of `.forEach(…)`.","line":52,"column":18,"nodeType":"Identifier","messageId":"no-array-for-each/error","endLine":52,"endColumn":25,"fix":{"range":[1593,1986],"text":"for (const job of scrapingJobs) {\r\n      if (!urlStats[job.target_url]) {\r\n        urlStats[job.target_url] = { total: 0, failed: 0, completed: 0, lastStatus: job.status };\r\n      }\r\n      urlStats[job.target_url].total++;\r\n      urlStats[job.target_url][job.status]++;\r\n      if (!urlStats[job.target_url].lastStatus) {\r\n        urlStats[job.target_url].lastStatus = job.status;\r\n      }\r\n    }"}},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error, info.","line":64,"column":5,"nodeType":"MemberExpression","messageId":"limited","endLine":64,"endColumn":16,"suggestions":[{"fix":{"range":[2036,2083],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"unicorn/no-array-for-each","severity":2,"message":"Use `for…of` instead of `.forEach(…)`.","line":69,"column":8,"nodeType":"Identifier","messageId":"no-array-for-each/error","endLine":69,"endColumn":15,"fix":{"range":[2089,2447],"text":"for (const [url, stats] of Object.entries(urlStats)\r\n      .filter(([_, stats]) => stats.failed > 0)\r\n      .sort((a, b) => b[1].failed - a[1].failed)\r\n      .slice(0, 10)) {\r\n        const failureRate = ((stats.failed / stats.total) * 100).toFixed(1);\r\n        console.log(`${url}: ${stats.failed}/${stats.total} failed (${failureRate}%)`);\r\n      }"}},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error, info.","line":71,"column":9,"nodeType":"MemberExpression","messageId":"limited","endLine":71,"endColumn":20,"suggestions":[{"fix":{"range":[2357,2436],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error, info.","line":80,"column":3,"nodeType":"MemberExpression","messageId":"limited","endLine":80,"endColumn":14,"suggestions":[{"fix":{"range":[2571,2622],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"unicorn/no-process-exit","severity":2,"message":"Only use `process.exit()` in CLI apps. Throw an error instead.","line":81,"column":3,"nodeType":"CallExpression","messageId":"no-process-exit","endLine":81,"endColumn":18},{"ruleId":"unicorn/prefer-top-level-await","severity":2,"message":"Prefer top-level await over using a promise chain.","line":82,"column":4,"nodeType":"Identifier","messageId":"promise","endLine":82,"endColumn":9},{"ruleId":"unicorn/no-process-exit","severity":2,"message":"Only use `process.exit()` in CLI apps. Throw an error instead.","line":84,"column":3,"nodeType":"CallExpression","messageId":"no-process-exit","endLine":84,"endColumn":18}],"suppressedMessages":[],"errorCount":8,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":3,"fixableWarningCount":0,"source":"import { createClient } from '@supabase/supabase-js';\r\nimport dotenv from 'dotenv';\r\n\r\n// Load environment variables\r\ndotenv.config({ path: '.env.local' });\r\n\r\nconst supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;\r\nconst serviceRoleKey = process.env.SUPABASE_SERVICE_ROLE_KEY;\r\n\r\nif (!supabaseUrl || !serviceRoleKey) {\r\n  console.error('❌ Missing Supabase credentials!');\r\n  process.exit(1);\r\n}\r\n\r\nconst supabase = createClient(supabaseUrl, serviceRoleKey);\r\n\r\nasync function checkDiscoveredUrls() {\r\n  try {\r\n    console.log('🔍 Checking discovered_urls table...');\r\n    \r\n    // Get sample discovered URLs\r\n    const { data: discoveredUrls, error } = await supabase\r\n      .from('discovered_urls')\r\n      .select('*')\r\n      .limit(20);\r\n\r\n    if (error) {\r\n      console.error('❌ Error querying discovered_urls:', error);\r\n      return;\r\n    }\r\n\r\n    console.log('📊 Found', discoveredUrls.length, 'discovered URLs:');\r\n    discoveredUrls.forEach((url, index) => {\r\n      console.log(`${index + 1}. ${url.url} (status: ${url.status})`);\r\n    });\r\n\r\n    // Check for URLs that have been processed multiple times\r\n    console.log('\\n🔍 Checking for repeatedly failing URLs...');\r\n    const { data: scrapingJobs, error: jobsError } = await supabase\r\n      .from('scraping_jobs')\r\n      .select('target_url, status, created_at')\r\n      .order('created_at', { ascending: false })\r\n      .limit(50);\r\n\r\n    if (jobsError) {\r\n      console.error('❌ Error querying scraping_jobs:', jobsError);\r\n      return;\r\n    }\r\n\r\n    // Group jobs by URL and count failures\r\n    const urlStats = {};\r\n    scrapingJobs.forEach(job => {\r\n      if (!urlStats[job.target_url]) {\r\n        urlStats[job.target_url] = { total: 0, failed: 0, completed: 0, lastStatus: job.status };\r\n      }\r\n      urlStats[job.target_url].total++;\r\n      urlStats[job.target_url][job.status]++;\r\n      if (!urlStats[job.target_url].lastStatus) {\r\n        urlStats[job.target_url].lastStatus = job.status;\r\n      }\r\n    });\r\n\r\n    // Show URLs with high failure rates\r\n    console.log('\\n📊 URL Processing Statistics:');\r\n    Object.entries(urlStats)\r\n      .filter(([_, stats]) => stats.failed > 0)\r\n      .sort((a, b) => b[1].failed - a[1].failed)\r\n      .slice(0, 10)\r\n      .forEach(([url, stats]) => {\r\n        const failureRate = ((stats.failed / stats.total) * 100).toFixed(1);\r\n        console.log(`${url}: ${stats.failed}/${stats.total} failed (${failureRate}%)`);\r\n      });\r\n\r\n  } catch (error) {\r\n    console.error('💥 Unexpected error:', error);\r\n  }\r\n}\r\n\r\ncheckDiscoveredUrls().then(() => {\r\n  console.log('\\n✅ Discovered URLs check complete!');\r\n  process.exit(0);\r\n}).catch((error) => {\r\n  console.error('💥 Fatal error:', error);\r\n  process.exit(1);\r\n});\r\n","usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\FoodTruckInfoCard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\ModeToggle.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\SearchFilters.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\ThemeProvider.tsx","messages":[],"suppressedMessages":[{"ruleId":"sonarjs/different-types-comparison","severity":2,"message":"Remove this \"===\" check; it will always be false. Did you mean to use \"==\"?","line":42,"column":15,"nodeType":null,"endLine":42,"endColumn":18,"suggestions":[{"desc":"Replace \"===\" with \"==\"","fix":{"range":[1583,1586],"text":"=="}}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\TruckCard.tsx","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Function 'TruckCard' has too many lines (141). Maximum allowed is 120.","line":26,"column":8,"nodeType":"FunctionDeclaration","messageId":"exceed","endLine":166,"endColumn":2}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use client';\r\n\r\nimport { Card, CardContent, CardHeader, CardFooter, CardTitle, CardDescription } from '@/components/ui/card';\r\nimport { Badge } from '@/components/ui/badge';\r\nimport { Button } from '@/components/ui/button';\r\nimport type { FoodTruck } from '@/lib/types';\r\nimport { useTruckCard } from '@/hooks/useTruckCard';\r\nimport { formatPrice } from '@/lib/utils/foodTruckHelpers';\r\nimport { Eye, MapPin, Heart } from 'lucide-react';\r\nimport { MenuSection } from '@/components/ui/MenuSection';\r\nimport { SocialMediaSection } from '@/components/ui/SocialMediaSection';\r\nimport { ContactSection } from '@/components/ui/ContactSection';\r\nimport { TruckDetailsModal } from '@/components/TruckDetailsModal';\r\nimport { useState } from 'react';\r\n\r\ninterface TruckCardProps {\r\n  readonly truck: FoodTruck;\r\n  readonly isOpen: boolean;\r\n  readonly onSelectTruck: () => void;\r\n  readonly userLocation?: { lat: number; lng: number };\r\n  readonly hideHeader?: boolean;\r\n  readonly isFavorite?: boolean;\r\n  readonly onToggleFavorite?: () => void;\r\n}\r\n\r\nexport function TruckCard({ truck, isOpen, onSelectTruck, hideHeader = false, isFavorite = false, onToggleFavorite }: TruckCardProps) {\r\n  const [isModalOpen, setIsModalOpen] = useState(false);\r\n  \r\n  // Defensive checks for required data\r\n  if (!truck?.id) {\r\n    return (\r\n      <Card className=\"hover:shadow-md transition-shadow cursor-pointer dark:bg-slate-800 dark:border-slate-700\">\r\n        <CardContent className=\"p-4\">\r\n          <p className=\"text-muted-foreground\">Invalid truck data</p>\r\n        </CardContent>\r\n      </Card>\r\n    );\r\n  }\r\n  \r\n  const { popularItems, priceRange, todayHours } = useTruckCard(truck);\r\n  const {\r\n    name = 'Unnamed Truck',\r\n    social_media = {},\r\n    contact_info = {},\r\n  } = truck;\r\n  \r\n  // Safely extract contact info with fallbacks\r\n  const { phone = '', email = '', website = '' } = contact_info ?? {};\r\n\r\n  const handleViewDetails = (e: React.MouseEvent) => {\r\n    e.stopPropagation();\r\n    setIsModalOpen(true);\r\n  };\r\n\r\n  const handleCloseModal = () => {\r\n    setIsModalOpen(false);\r\n  };\r\n\r\n  const handleToggleFavorite = (e: React.MouseEvent) => {\r\n    e.stopPropagation();\r\n    if (onToggleFavorite) {\r\n      onToggleFavorite();\r\n    }\r\n  };\r\n\r\n  return (\r\n    <Card\r\n      className={`hover:shadow-md transition-shadow cursor-pointer dark:bg-slate-800 dark:border-slate-700 ${hideHeader ? 'shadow-none border-none bg-transparent dark:bg-transparent' : ''}`}\r\n      onClick={onSelectTruck}\r\n    >\r\n      {!hideHeader && (\r\n        <CardHeader>\r\n          <div className=\"flex justify-between items-start\">\r\n            <div className=\"flex-1\">\r\n              <CardTitle className=\"text-lg dark:text-gray-100\">{truck.name}</CardTitle>\r\n              {truck.current_location?.address != undefined && (\r\n                <CardDescription className=\"flex items-center mt-1 dark:text-gray-400\">\r\n                  <MapPin className=\"size-4 mr-1\" />\r\n                  {truck.current_location.address}\r\n                </CardDescription>\r\n              )}\r\n            </div>\r\n            <div className=\"flex flex-col items-end space-y-1\">\r\n              <div className=\"flex items-center gap-2\">\r\n                <Badge variant={isOpen ? 'open' : 'secondary'}>{isOpen ? 'Open' : 'Closed'}</Badge>\r\n                {onToggleFavorite && (\r\n                  <Button\r\n                    variant=\"ghost\"\r\n                    size=\"icon\"\r\n                    className={`hover:scale-110 transition-all duration-200 ${isFavorite ? 'neon-text' : 'hover-neon'}`}\r\n                    onClick={handleToggleFavorite}\r\n                    aria-label={isFavorite ? 'Remove from favorites' : 'Add to favorites'}\r\n                  >\r\n                    <Heart className={`size-4 ${isFavorite ? 'fill-current' : ''}`} />\r\n                  </Button>\r\n                )}\r\n              </div>\r\n              {/* Show price range fallback if no explicit prices */}\r\n              {popularItems.every((item) => item.price === undefined) &&\r\n                priceRange !== undefined &&\r\n                priceRange !== '' && (\r\n                  <Badge variant=\"outline\" className=\"mt-1\">\r\n                    {priceRange}\r\n                  </Badge>\r\n                )}\r\n            </div>\r\n          </div>\r\n        </CardHeader>\r\n      )}\r\n      <CardContent className={hideHeader ? 'pt-0' : ''}>\r\n        <main className=\"ui-truck-container\">\r\n          {name && (\r\n            <>\r\n              {todayHours !== undefined && (todayHours.closed === false) && (\r\n                <div className=\"hours-display\">\r\n                  <strong>Today:</strong> {todayHours.open} - {todayHours.close}\r\n                </div>\r\n              )}\r\n            </>\r\n          )}\r\n\r\n          {popularItems.length > 0 && (\r\n            <MenuSection\r\n              items={popularItems.map(item => ({\r\n                name: item.name,\r\n                price: formatPrice(item.price ?? 0),\r\n              }))}\r\n            />\r\n          )}\r\n\r\n          {Object.keys(social_media).length > 0 && (typeof social_media === 'object')&& (\r\n            <SocialMediaSection socialMedia={social_media} />\r\n          )}\r\n\r\n          {(phone || email || website) && (\r\n            <ContactSection contactInfo={{ phone, website }} />\r\n          )}\r\n        </main>\r\n      </CardContent>\r\n      <CardFooter>\r\n        <div className=\"flex gap-2 w-full\">\r\n          <Button \r\n            className=\"flex-1\" \r\n            variant=\"neon\" \r\n            onClick={handleViewDetails}\r\n          >\r\n            <Eye className=\"size-4 mr-2\" />\r\n            View Details\r\n          </Button>\r\n          {truck.verification_status === 'verified' && (\r\n            <Button className=\"flex-1\" variant=\"default\" disabled>\r\n              Book Me\r\n            </Button>\r\n          )}\r\n        </div>\r\n      </CardFooter>\r\n      \r\n      <TruckDetailsModal\r\n        truck={truck}\r\n        isOpen={isModalOpen}\r\n        onClose={handleCloseModal}\r\n        isTruckOpen={isOpen}\r\n      />\r\n    </Card>\r\n  );\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\TruckDetailsModal.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'verification_status' is defined but never used. Allowed unused args must match /^_/u.","line":73,"column":118,"nodeType":null,"messageId":"unusedVar","endLine":73,"endColumn":137},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":75,"column":15,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":75,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2934,2937],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2934,2937],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":77,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":77,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2991,2994],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2991,2994],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":81,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":81,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3071,3074],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3071,3074],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .closed on an `any` value.","line":93,"column":45,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":93,"endColumn":51},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .open on an `any` value.","line":100,"column":23,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":100,"endColumn":27},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .close on an `any` value.","line":100,"column":43,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":100,"endColumn":48},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":119,"column":13,"nodeType":"Property","messageId":"anyAssignment","endLine":119,"endColumn":28},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .name on an `any` value.","line":119,"column":24,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":119,"endColumn":28},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `any` assigned to a parameter of type `string | number`.","line":120,"column":32,"nodeType":"LogicalExpression","messageId":"unsafeArgument","endLine":120,"endColumn":47},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .price on an `any` value.","line":120,"column":37,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":120,"endColumn":42},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `any` assigned to a parameter of type `{}`.","line":136,"column":18,"nodeType":"Identifier","messageId":"unsafeArgument","endLine":136,"endColumn":30},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":139,"column":42,"nodeType":"Identifier","messageId":"anyAssignment","endLine":139,"endColumn":54},{"ruleId":"@typescript-eslint/prefer-optional-chain","severity":2,"message":"Prefer using an optional chain expression instead, as it's more concise and easier to read.","line":147,"column":7,"nodeType":null,"messageId":"preferOptionalChain","endLine":147,"endColumn":26,"fix":{"range":[5028,5047],"text":"!truck?.id"}},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":147,"column":8,"nodeType":"Identifier","messageId":"conditionErrorObject","endLine":147,"endColumn":13}],"suppressedMessages":[],"errorCount":11,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":1,"fixableWarningCount":0,"source":"'use client';\r\n\r\nimport React from 'react';\r\nimport { Dialog, DialogContent, DialogHeader, DialogTitle, DialogClose } from '@/components/ui/dialog';\r\nimport { Badge } from '@/components/ui/badge';\r\nimport { Button } from '@/components/ui/button';\r\nimport type { FoodTruck } from '@/lib/types';\r\nimport { useTruckCard } from '@/hooks/useTruckCard';\r\nimport { formatPrice } from '@/lib/utils/foodTruckHelpers';\r\nimport { X, MapPin, Clock, Phone, Globe, Star } from 'lucide-react';\r\nimport { MenuSection } from '@/components/ui/MenuSection';\r\nimport { SocialMediaSection } from '@/components/ui/SocialMediaSection';\r\nimport { ContactSection } from '@/components/ui/ContactSection';\r\n\r\ninterface TruckDetailsModalProps {\r\n  readonly truck: FoodTruck;\r\n  readonly isOpen: boolean;\r\n  readonly onClose: () => void;\r\n  readonly isTruckOpen: boolean;\r\n}\r\n\r\nconst TruckModalHeader = ({ truck, name, cuisine_type, isTruckOpen, average_rating, review_count }: {\r\n  truck: FoodTruck;\r\n  name: string;\r\n  cuisine_type: string[];\r\n  isTruckOpen: boolean;\r\n  average_rating: number;\r\n  review_count: number;\r\n}) => (\r\n  <DialogHeader>\r\n    <div className=\"flex justify-between items-start\">\r\n      <div className=\"flex-1\">\r\n        <DialogTitle className=\"text-2xl font-bold neon-text mb-2\">\r\n          {name}\r\n        </DialogTitle>\r\n        {truck.current_location?.address !== undefined && truck.current_location.address !== '' && (\r\n          <div className=\"flex items-center text-muted-foreground mb-2\">\r\n            <MapPin className=\"size-4 mr-2\" />\r\n            <span>{truck.current_location.address}</span>\r\n          </div>\r\n        )}\r\n        {cuisine_type.length > 0 && (\r\n          <div className=\"flex flex-wrap gap-2 mb-3\">\r\n            {cuisine_type.map((cuisine) => (\r\n              <Badge key={cuisine} variant=\"secondary\">\r\n                {cuisine}\r\n              </Badge>\r\n            ))}\r\n          </div>\r\n        )}\r\n      </div>\r\n      <div className=\"flex flex-col items-end space-y-2\">\r\n        <Badge variant={isTruckOpen ? 'open' : 'secondary'} className=\"mb-2\">\r\n          {isTruckOpen ? 'Open Now' : 'Closed'}\r\n        </Badge>\r\n        {average_rating > 0 && (\r\n          <div className=\"flex items-center text-sm text-muted-foreground\">\r\n            <Star className=\"size-4 mr-1 fill-yellow-400 text-yellow-400\" />\r\n            <span>{average_rating.toFixed(1)}</span>\r\n            {review_count > 0 && <span className=\"ml-1\">({review_count} reviews)</span>}\r\n          </div>\r\n        )}\r\n        <DialogClose asChild>\r\n          <Button variant=\"ghost\" size=\"icon\" className=\"hover:neon-border\">\r\n            <X className=\"size-4\" />\r\n          </Button>\r\n        </DialogClose>\r\n      </div>\r\n    </div>\r\n  </DialogHeader>\r\n);\r\n\r\nconst TruckModalContent = ({ description, todayHours, priceRange, popularItems, phone, email, website, social_media, verification_status }: {\r\n  description: string;\r\n  todayHours: any;\r\n  priceRange: string | undefined;\r\n  popularItems: any[];\r\n  phone: string;\r\n  email: string;\r\n  website: string;\r\n  social_media: any;\r\n  verification_status: string;\r\n}) => (\r\n  <div className=\"space-y-6\">\r\n    \r\n    {description !== '' && (\r\n      <div>\r\n        <h3 className=\"text-lg font-semibold mb-2\">About</h3>\r\n        <p className=\"text-muted-foreground\">{description}</p>\r\n      </div>\r\n    )}\r\n\r\n    {todayHours !== undefined && todayHours.closed !== true && (\r\n      <div>\r\n        <h3 className=\"text-lg font-semibold mb-2 flex items-center\">\r\n          <Clock className=\"size-4 mr-2\" />\r\n          Today's Hours\r\n        </h3>\r\n        <p className=\"text-muted-foreground\">\r\n          {todayHours.open} - {todayHours.close}\r\n        </p>\r\n      </div>\r\n    )}\r\n\r\n    {priceRange !== undefined && priceRange !== '' && (\r\n      <div>\r\n        <h3 className=\"text-lg font-semibold mb-2\">Price Range</h3>\r\n        <Badge variant=\"outline\" className=\"text-lg\">\r\n          {priceRange}\r\n        </Badge>\r\n      </div>\r\n    )}\r\n\r\n    {popularItems.length > 0 && (\r\n      <div>\r\n        <h3 className=\"text-lg font-semibold mb-3\">Popular Items</h3>\r\n        <MenuSection\r\n          items={popularItems.map(item => ({\r\n            name: item.name,\r\n            price: formatPrice(item.price ?? 0),\r\n          }))}\r\n        />\r\n      </div>\r\n    )}\r\n\r\n    {(phone !== '' || email !== '' || website !== '') && (\r\n      <div>\r\n        <h3 className=\"text-lg font-semibold mb-3 flex items-center\">\r\n          <Phone className=\"size-4 mr-2\" />\r\n          Contact Information\r\n        </h3>\r\n        <ContactSection contactInfo={{ phone, website }} />\r\n      </div>\r\n    )}\r\n\r\n    {Object.keys(social_media).length > 0 && typeof social_media === 'object' && (\r\n      <div>\r\n        <h3 className=\"text-lg font-semibold mb-3\">Follow Us</h3>\r\n        <SocialMediaSection socialMedia={social_media} />\r\n      </div>\r\n    )}\r\n  </div>\r\n);\r\n\r\nexport function TruckDetailsModal({ truck, isOpen, onClose, isTruckOpen }: TruckDetailsModalProps) {\r\n  // Defensive checks for required data\r\n  if (!truck || !truck.id) {\r\n    return (\r\n      <Dialog open={isOpen} onOpenChange={onClose}>\r\n        <DialogContent className=\"glass max-w-md\">\r\n          <DialogHeader>\r\n            <DialogTitle>Error</DialogTitle>\r\n          </DialogHeader>\r\n          <p className=\"text-muted-foreground\">Unable to load truck details. Invalid data.</p>\r\n          <Button onClick={onClose} variant=\"default\">Close</Button>\r\n        </DialogContent>\r\n      </Dialog>\r\n    );\r\n  }\r\n  \r\n  const { popularItems, priceRange, todayHours } = useTruckCard(truck);\r\n  const {\r\n    name = 'Unnamed Truck',\r\n    description = '',\r\n    cuisine_type = [],\r\n    social_media = {},\r\n    contact_info: { phone = '', email = '', website = '' } = {},\r\n    average_rating = 0,\r\n    review_count = 0,\r\n  } = truck;\r\n\r\n  return (\r\n    <Dialog open={isOpen} onOpenChange={onClose}>\r\n      <DialogContent className=\"glass max-w-2xl max-h-[90vh] overflow-y-auto z-[10001]\">\r\n        <TruckModalHeader\r\n          truck={truck}\r\n          name={name}\r\n          cuisine_type={cuisine_type}\r\n          isTruckOpen={isTruckOpen}\r\n          average_rating={average_rating}\r\n          review_count={review_count}\r\n        />\r\n        <TruckModalContent\r\n          description={description}\r\n          todayHours={todayHours}\r\n          priceRange={priceRange}\r\n          popularItems={popularItems}\r\n          phone={phone}\r\n          email={email}\r\n          website={website}\r\n          social_media={social_media}\r\n          verification_status={truck.verification_status || 'pending'}\r\n        />\r\n        <div className=\"flex gap-3 pt-4 border-t border-border\">\r\n          {website !== '' && (\r\n            <Button asChild variant=\"neon\" className=\"flex-1\">\r\n              <a href={website} target=\"_blank\" rel=\"noopener noreferrer\">\r\n                <Globe className=\"size-4 mr-2\" />\r\n                Visit Website\r\n              </a>\r\n            </Button>\r\n          )}\r\n          {truck.verification_status === 'verified' && (\r\n            <Button variant=\"default\" className=\"flex-1\" disabled>\r\n              Book Catering\r\n            </Button>\r\n          )}\r\n        </div>\r\n      </DialogContent>\r\n    </Dialog>\r\n  );\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\WebVitalsReporter.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\admin\\AdminNavLinks.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\admin\\DataCleanupDashboard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\admin\\RealtimeStatusIndicator.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\admin\\UserMenu.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\admin\\cleanup\\CleanupGuide.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\admin\\cleanup\\CleanupHeader.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\admin\\cleanup\\CleanupOperationDetails.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\admin\\cleanup\\CleanupPreview.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\admin\\cleanup\\CleanupResults.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\admin\\cleanup\\CleanupSummaryCards.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\admin\\cleanup\\OperationSelector.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\admin\\dashboard\\DataQualityScoreCard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\admin\\dashboard\\PipelineStatusCard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\admin\\dashboard\\QualityDistributionCard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\admin\\dashboard\\RecentErrorsCard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\admin\\dashboard\\TotalFoodTrucksCard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\admin\\dashboard\\TrucksPage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\admin\\food-trucks\\detail\\BasicInfoCard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\admin\\food-trucks\\detail\\ContactInfoCard.tsx","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":13,"column":8,"nodeType":"Identifier","messageId":"conditionErrorNullableString","endLine":13,"endColumn":13,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[284,289],"text":"(phone != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[284,289],"text":"(phone ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[284,289],"text":"(Boolean(phone))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":14,"column":8,"nodeType":"Identifier","messageId":"conditionErrorNullableString","endLine":14,"endColumn":13,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[324,329],"text":"(email != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[324,329],"text":"(email ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[324,329],"text":"(Boolean(email))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":15,"column":8,"nodeType":"Identifier","messageId":"conditionErrorNullableString","endLine":15,"endColumn":15,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[364,371],"text":"(website != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[364,371],"text":"(website ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[364,371],"text":"(Boolean(website))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from 'react';\r\n\r\ninterface ContactInfoCardProps {\r\n  phone?: string;\r\n  email?: string;\r\n  website?: string;\r\n}\r\n\r\nconst ContactInfoCard: React.FC<ContactInfoCardProps> = ({ phone, email, website }) => {\r\n  return (\r\n    <div>\r\n      <h3>Contact Information</h3>\r\n      {phone && <p>Phone: {phone}</p>}\r\n      {email && <p>Email: {email}</p>}\r\n      {website && <p>Website: {website}</p>}\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default ContactInfoCard;\r\n","usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\admin\\food-trucks\\detail\\DataQualityCard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\admin\\food-trucks\\detail\\LocationInfoCard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\admin\\food-trucks\\detail\\OperatingHoursCard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\admin\\food-trucks\\detail\\QualityMetricsGrid.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\admin\\food-trucks\\detail\\QualityScoreMetric.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\admin\\food-trucks\\detail\\RatingsReviewsCard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\admin\\food-trucks\\detail\\TruckDetailHeader.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\admin\\food-trucks\\detail\\TruckNotFound.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\admin\\pipeline\\FailedProcessingQueueTable.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\admin\\pipeline\\PipelineStatisticsCards.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\admin\\pipeline\\RecentScrapingJobsTable.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\admin\\pipeline\\ScrapingJobRow.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\admin\\pipeline\\ScrapingJobsTableContent.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\admin\\realtime\\AlertListDisplay.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\admin\\realtime\\AlertToggleButton.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\admin\\realtime\\ConnectionStatusHeader.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\admin\\realtime\\EventControls.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\admin\\realtime\\EventSubscriptionManager.tsx","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":23,"column":13,"nodeType":"Identifier","messageId":"conditionErrorObject","endLine":23,"endColumn":18}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useEffect } from 'react';\r\n\r\nimport { supabase } from '@/lib/supabase'; \r\nimport type { PipelineEvent } from '@/lib/types';\r\n\r\n/**\r\n * Manages event subscriptions for pipeline events using Supabase.\r\n * @example\r\n * EventSubscriptionManager()\r\n * @returns {void} This component serves purely for side-effects of subscription management.\r\n * @description\r\n *   - Utilizes the Supabase Realtime Client to subscribe and process \"pipeline-events\".\r\n *   - Includes an effect cleanup to unsubscribe from events when the component unmounts.\r\n *   - Current implementation logs events to the console as placeholders.\r\n */\r\ntype RealtimeChannelStatus = 'SUBSCRIBED' | 'CLOSED' | 'CHANNEL_ERROR' | 'TIMED_OUT';\r\n\r\nfunction EventSubscriptionManager() {\r\n  useEffect(() => {\r\n    const handleEvent = (payload: { new: PipelineEvent }) => {\r\n      try {\r\n        const event = payload.new;\r\n        if (event && typeof event === 'object' && 'type' in event) {\r\n          // Process the event based on its type\r\n          switch (event.type) {\r\n            case 'job_started': {\r\n              console.info('Job started:', event.payload);\r\n              break;\r\n            }\r\n            case 'job_completed': {\r\n              console.info('Job completed:', event.payload);\r\n              break;\r\n            }\r\n            case 'data_updated': {\r\n              console.info('Data updated:', event.payload);\r\n              break;\r\n            }\r\n            default: {\r\n              console.warn('Received unknown event type:', event.type);\r\n            }\r\n          }\r\n        } else {\r\n          console.warn('Received malformed event:', payload);\r\n        }\r\n      } catch (error) {\r\n        console.error('Error processing pipeline event:', error);\r\n      }\r\n    };\r\n\r\n    const subscription = supabase\r\n      .channel('pipeline-events')\r\n      .on('postgres_changes', { event: 'INSERT', schema: 'public', table: 'pipeline_events' }, handleEvent)\r\n      .subscribe((status: RealtimeChannelStatus, error?: Error) => {\r\n        if (status === 'SUBSCRIBED') {\r\n          console.info('Successfully subscribed to pipeline events.');\r\n        }\r\n        if (status === 'CHANNEL_ERROR' && error) {\r\n          console.error('Pipeline event subscription error:', error);\r\n        }\r\n      });\r\n\r\n    return () => {\r\n      void supabase.realtime.removeChannel(subscription);\r\n    };\r\n  }, []);\r\n}\r\n\r\nexport default EventSubscriptionManager;\r\n","usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\admin\\realtime\\RealtimeStatusDisplay.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\admin\\realtime\\ScrapingJobsStatus.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\admin\\realtime\\StatusHelpers.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\admin\\realtime\\SystemAlertItem.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\admin\\realtime\\SystemAlerts.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\admin\\realtime\\SystemMetricsGrid.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\admin\\realtime\\SystemStatusIndicators.tsx","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":31,"column":13,"nodeType":"Identifier","messageId":"conditionErrorObject","endLine":31,"endColumn":21}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useEffect, useState } from 'react';\r\nimport { supabase } from '@/lib/supabase'; \r\n\r\ntype RealtimeChannelStatus = 'SUBSCRIBED' | 'CLOSED' | 'CHANNEL_ERROR' | 'TIMED_OUT';\r\n\r\ninterface SystemStatusResponse {\r\n  status: string;\r\n  data: {\r\n    status: string;\r\n  };\r\n}\r\n\r\n/**\r\n* Represents system status indicators in real-time\r\n* @example\r\n* SystemStatusIndicators()\r\n* <div><h3>Current System Status:</h3><span>ONLINE</span></div>\r\n* @returns {JSX.Element} A JSX element displaying the current system status.\r\n* @description\r\n*   - Utilizes Supabase Realtime Client for subscribing to system status updates.\r\n*   - Updates the display with the latest system status retrieved from a realtime database.\r\n*   - Handles subscription clean-up on component unmount to avoid memory leaks.\r\n*/\r\nfunction SystemStatusIndicators() {\r\n  const [systemStatus, setSystemStatus] = useState('UNKNOWN');\r\n\r\n  useEffect(() => {\r\n    const subscription = supabase.realtime.channel('system-status').subscribe((status: RealtimeChannelStatus, payload: unknown) => {\r\n      if (status === 'SUBSCRIBED') {\r\n        const response = payload as SystemStatusResponse;\r\n        if (response && typeof response === 'object' && 'status' in response) {\r\n          const typedResponse = response;\r\n          const responseStatus = typedResponse.status; // Extract status to a variable\r\n\r\n          if (typeof responseStatus === 'string' && responseStatus === \"success\") {\r\n            if (typeof typedResponse.data === 'object' && 'status' in typedResponse.data) {\r\n              setSystemStatus(typedResponse.data.status);\r\n            } else {\r\n              console.error(\"Invalid data structure in system status response\");\r\n            }\r\n          } else {\r\n            console.error(\"Failed to retrieve system status or invalid response format\");\r\n          }\r\n        } else {\r\n          console.error(\"Failed to retrieve system status or invalid response format\");\r\n        }\r\n      }\r\n    });\r\n\r\n    return () => {\r\n      void supabase.realtime.removeChannel(subscription);\r\n    };\r\n  }, []);\r\n\r\n  return (\r\n    <div>\r\n      <h3>Current System Status:</h3>\r\n      <span>{systemStatus}</span>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default SystemStatusIndicators;\r\n","usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\admin\\realtime\\useSystemAlertsLogic.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\admin\\realtime\\useSystemMetrics.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\admin\\users\\UserTable.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\home\\AppHeader.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\home\\LoadingScreen.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\home\\MainContent.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\home\\MapSection.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\home\\TruckAccordionContent.tsx","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":36,"column":28,"nodeType":"ChainExpression","messageId":"conditionErrorNullableString","endLine":36,"endColumn":55,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[1198,1225],"text":"((a.current_location?.address) != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[1198,1225],"text":"((a.current_location?.address) ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[1198,1225],"text":"(Boolean((a.current_location?.address)))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/prefer-optional-chain","severity":2,"message":"Prefer using an optional chain expression instead, as it's more concise and easier to read.","line":36,"column":28,"nodeType":null,"messageId":"preferOptionalChain","endLine":36,"endColumn":92,"fix":{"range":[1198,1262],"text":"a.current_location?.address?.trim()"}},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":37,"column":28,"nodeType":"ChainExpression","messageId":"conditionErrorNullableString","endLine":37,"endColumn":55,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[1293,1320],"text":"((b.current_location?.address) != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[1293,1320],"text":"((b.current_location?.address) ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[1293,1320],"text":"(Boolean((b.current_location?.address)))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/prefer-optional-chain","severity":2,"message":"Prefer using an optional chain expression instead, as it's more concise and easier to read.","line":37,"column":28,"nodeType":null,"messageId":"preferOptionalChain","endLine":37,"endColumn":92,"fix":{"range":[1293,1357],"text":"b.current_location?.address?.trim()"}}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":2,"fixableWarningCount":0,"source":"'use client';\r\n\r\nimport React from 'react';\r\nimport { Accordion } from '@/components/ui/accordion';\r\nimport { TruckAccordionItem } from '@/components/trucks/TruckAccordionItem';\r\nimport type { FoodTruck } from '@/lib/types';\r\n\r\ninterface TruckAccordionContentProps {\r\n  filteredTrucks: FoodTruck[];\r\n  selectedTruckId: string | undefined;\r\n  setSelectedTruckId: (id: string | undefined) => void;\r\n  isOpen: (truck: FoodTruck) => boolean;\r\n  userLocation: { lat: number; lng: number } | undefined;\r\n}\r\n\r\nexport const TruckAccordionContent: React.FC<TruckAccordionContentProps> = ({\r\n  filteredTrucks,\r\n  selectedTruckId,\r\n  setSelectedTruckId,\r\n  isOpen,\r\n  userLocation,\r\n}) => {\r\n  if (filteredTrucks.length === 0) {\r\n    return (\r\n      <div className=\"text-center py-8 text-gray-500 dark:text-gray-400\">\r\n        <p>No food trucks found in your area.</p>\r\n        <p className=\"text-sm mt-2\">Try expanding your search radius or check back later!</p>\r\n      </div>\r\n    );\r\n  }\r\n\r\n  // Smart sorting: prioritize open trucks and specific locations\r\n  const sortedTrucks = [...filteredTrucks].sort((a, b) => {\r\n    const aOpen = isOpen(a);\r\n    const bOpen = isOpen(b);\r\n    const aHasAddress = !!(a.current_location?.address && a.current_location.address.trim());\r\n    const bHasAddress = !!(b.current_location?.address && b.current_location.address.trim());\r\n    \r\n    // First, sort by open/closed status (open first)\r\n    if (aOpen !== bOpen) {\r\n      return aOpen ? -1 : 1;\r\n    }\r\n    \r\n    // Then sort by specific address vs city only (specific first)\r\n    if (aHasAddress !== bHasAddress) {\r\n      return aHasAddress ? -1 : 1;\r\n    }\r\n    \r\n    // Finally, sort alphabetically by name\r\n    return a.name.localeCompare(b.name);\r\n  });\r\n\r\n  return (\r\n    <Accordion \r\n      type=\"single\" \r\n      collapsible \r\n      value={selectedTruckId}\r\n      onValueChange={(value) => setSelectedTruckId(value || undefined)}\r\n      className=\"space-y-2\"\r\n    >\r\n      {sortedTrucks.map((truck) => (\r\n        <TruckAccordionItem\r\n          key={truck.id}\r\n          truck={truck}\r\n          selectedTruckId={selectedTruckId}\r\n          setSelectedTruckId={setSelectedTruckId}\r\n          isOpen={isOpen}\r\n          userLocation={userLocation}\r\n        />\r\n      ))}\r\n    </Accordion>\r\n  );\r\n};\r\n","usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\home\\TruckListHeader.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\home\\TruckListSection.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\login\\EmailFormFields.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\map\\MapComponent.tsx","messages":[{"ruleId":"sonarjs/unused-import","severity":2,"message":"Remove this unused import of 'geocodeAddress'.","line":14,"column":10,"nodeType":"Identifier","messageId":"removeUnusedImport","endLine":14,"endColumn":24,"suggestions":[{"messageId":"suggestRemoveOneVariable","fix":{"range":[553,569],"text":""},"desc":"Remove this variable import"}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'geocodeAddress' is defined but never used.","line":14,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":14,"endColumn":24},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'theme' is defined but never used. Allowed unused args must match /^_/u.","line":42,"column":44,"nodeType":null,"messageId":"unusedVar","endLine":42,"endColumn":49},{"ruleId":"max-lines-per-function","severity":1,"message":"Arrow function has too many lines (150). Maximum allowed is 120.","line":54,"column":51,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":203,"endColumn":2},{"ruleId":"unicorn/explicit-length-check","severity":2,"message":"Use `.length === 0` when checking length is zero.","line":72,"column":9,"nodeType":"UnaryExpression","messageId":"zero","endLine":72,"endColumn":23,"fix":{"range":[2147,2161],"text":"trucks.length === 0"}},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error, info.","line":77,"column":5,"nodeType":"MemberExpression","messageId":"limited","endLine":77,"endColumn":16,"suggestions":[{"fix":{"range":[2230,2301],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":80,"column":12,"nodeType":"MemberExpression","messageId":"conditionErrorObject","endLine":80,"endColumn":34},{"ruleId":"unicorn/no-null","severity":1,"message":"Use `undefined` instead of `null`.","line":82,"column":16,"nodeType":"Literal","messageId":"error","endLine":82,"endColumn":20,"suggestions":[{"messageId":"remove","fix":{"range":[2500,2504],"text":""},"data":{},"desc":"Remove `null`."},{"messageId":"replace","fix":{"range":[2500,2504],"text":"undefined"},"data":{},"desc":"Replace `null` with `undefined`."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error, info.","line":99,"column":5,"nodeType":"MemberExpression","messageId":"limited","endLine":99,"endColumn":16,"suggestions":[{"fix":{"range":[2978,3046],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":177,"column":44,"nodeType":"Identifier","messageId":"conditionErrorNullableString","endLine":177,"endColumn":49,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[5583,5588],"text":"(theme != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[5583,5588],"text":"(theme ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[5583,5588],"text":"(Boolean(theme))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":177,"column":50,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":177,"endColumn":52,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[5589,5591],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":188,"column":16,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":188,"endColumn":46,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[5906,5936],"text":"(truck.current_location.address != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[5906,5936],"text":"(truck.current_location.address ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[5906,5936],"text":"(Boolean(truck.current_location.address))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":1,"fixableWarningCount":0,"source":"'use client';\r\n\r\nimport 'leaflet/dist/leaflet.css';\r\nimport 'leaflet-defaulticon-compatibility/dist/leaflet-defaulticon-compatibility.css';\r\nimport 'leaflet-defaulticon-compatibility';\r\nimport './Map.css'; // Enhanced map styling\r\n\r\nimport { MapContainer, TileLayer, Marker, Popup, useMap } from 'react-leaflet';\r\nimport type { LatLngExpression } from 'leaflet';\r\nimport L from 'leaflet';\r\nimport { useEffect, useState } from 'react';\r\nimport type { FoodTruck } from '@/lib/types';\r\nimport { isTruckOpen } from '@/lib/utils/foodTruckHelpers';\r\nimport { geocodeAddress, CHARLESTON_FALLBACK } from '@/lib/utils/geocoding';\r\n\r\ninterface MapComponentProps {\r\n  readonly trucks: FoodTruck[];\r\n  readonly userLocation?: { lat: number; lng: number };\r\n  readonly defaultCenter: LatLngExpression;\r\n  readonly defaultZoom?: number;\r\n  readonly onSelectTruck?: (truckId: string) => void;\r\n  readonly selectedTruckLocation?: LatLngExpression;\r\n  readonly theme?: string;\r\n}\r\n\r\nconst MapViewUpdater = ({\r\n  center,\r\n  zoom,\r\n}: {\r\n  center: LatLngExpression | undefined;\r\n  zoom?: number;\r\n}) => {\r\n  const map = useMap();\r\n  useEffect(() => {\r\n    if (center) {\r\n      map.flyTo(center, zoom ?? map.getZoom());\r\n    }\r\n  }, [center, zoom, map]);\r\n  return <></>;\r\n};\r\n\r\nconst getFoodTruckIcon = (isOpen: boolean, theme: string) => {\r\n  const color = isOpen ? 'green' : 'red';\r\n  return new L.Icon({\r\n    iconUrl: '/food-truck-icon.svg',\r\n    iconSize: [64, 64],\r\n    iconAnchor: [32, 52], // Adjusted for better pin positioning\r\n    popupAnchor: [0, -52],\r\n    shadowUrl: undefined, // Use CSS shadow instead\r\n    className: `food-truck-marker-icon glow-${color}`\r\n  });\r\n};\r\n\r\nconst MapComponent: React.FC<MapComponentProps> = ({\r\n  trucks,\r\n  userLocation,\r\n  defaultCenter,\r\n  defaultZoom = 10,\r\n  onSelectTruck,\r\n  selectedTruckLocation,\r\n  theme,\r\n}) => {\r\n  const [isMounted, setIsMounted] = useState(false);\r\n  const [trucksWithCoords, setTrucksWithCoords] = useState<FoodTruck[]>([]);\r\n\r\n  useEffect(() => {\r\n    setIsMounted(true);\r\n  }, []);\r\n\r\n  // Process trucks to ensure all have coordinates - no geocoding delays\r\n  useEffect(() => {\r\n    if (!trucks.length) {\r\n      setTrucksWithCoords([]);\r\n      return;\r\n    }\r\n    \r\n    console.log('🗺️ Processing', trucks.length, 'trucks for map display');\r\n    \r\n    const processedTrucks: FoodTruck[] = trucks.map(truck => {\r\n      if (!truck.current_location) {\r\n        console.warn('⚠️ Skipping truck with no location:', truck.name);\r\n        return null;\r\n      }\r\n      \r\n      // Ensure truck has valid coordinates, use fallback if needed\r\n      const lat = truck.current_location.lat || CHARLESTON_FALLBACK.lat;\r\n      const lng = truck.current_location.lng || CHARLESTON_FALLBACK.lng;\r\n      \r\n      return {\r\n        ...truck,\r\n        current_location: {\r\n          ...truck.current_location,\r\n          lat,\r\n          lng,\r\n        },\r\n      };\r\n    }).filter((truck): truck is FoodTruck => truck !== null);\r\n    \r\n    console.log('🎯 Processed trucks for map:', processedTrucks.length);\r\n    setTrucksWithCoords(processedTrucks);\r\n  }, [trucks]);\r\n\r\n  const validTrucks = trucksWithCoords;\r\n\r\n  const initialMapCenter: LatLngExpression =\r\n    userLocation && typeof userLocation.lat === 'number' && typeof userLocation.lng === 'number'\r\n      ? [userLocation.lat, userLocation.lng]\r\n      : defaultCenter;\r\n\r\n  // SIMPLE AND EFFECTIVE: Use the crisp OpenStreetMap for both modes\r\n  const isDark = theme === 'dark';\r\n  \r\n  const tileLayerProps = {\r\n    // Use the crisp OpenStreetMap tiles that you like\r\n    attribution: '&copy; <a href=\"https://www.openstreetmap.org/copyright\">OpenStreetMap</a> contributors',\r\n    url: 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',\r\n    className: isDark ? 'dark-inverted-map' : 'light-crisp-map'\r\n  };\r\n\r\n  if (!isMounted) {\r\n    return (\r\n      <div\r\n        className={`map-loading rounded-lg shadow-md ${isDark ? 'dark' : ''}`}\r\n        style={{\r\n          height: '400px',\r\n          width: '100%',\r\n          display: 'flex',\r\n          alignItems: 'center',\r\n          justifyContent: 'center',\r\n        }}\r\n      >\r\n        <div className=\"flex items-center gap-2\">\r\n          <div className=\"w-5 h-5 rounded-full border-2 border-current border-t-transparent animate-spin\" />\r\n          <p style={{ color: isDark ? '#fff' : '#000' }}>Loading map...</p>\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n\r\n  return (\r\n    <MapContainer\r\n      center={initialMapCenter}\r\n      zoom={defaultZoom}\r\n      scrollWheelZoom={true}\r\n      zoomControl={true}\r\n      doubleClickZoom={true}\r\n      dragging={true}\r\n      style={{ height: '400px', width: '100%' }}\r\n      className=\"rounded-lg shadow-md\"\r\n      // Enhanced performance settings\r\n      preferCanvas={false}\r\n    >\r\n      <TileLayer\r\n        attribution={tileLayerProps.attribution}\r\n        url={tileLayerProps.url}\r\n        maxZoom={19}\r\n        minZoom={1}\r\n        tileSize={256}\r\n        zoomOffset={0}\r\n        // Performance enhancements\r\n        keepBuffer={2}\r\n        updateWhenIdle={true}\r\n        updateWhenZooming={false}\r\n        // Better visual quality\r\n        className={tileLayerProps.className}\r\n      />\r\n      <MapViewUpdater\r\n        center={selectedTruckLocation}\r\n        zoom={selectedTruckLocation ? 13 : undefined}\r\n      />\r\n      {validTrucks.map((truck) => {\r\n        const isOpen = isTruckOpen(truck);\r\n        return (\r\n          <Marker\r\n            key={truck.id}\r\n            position={[truck.current_location.lat, truck.current_location.lng]}\r\n            icon={getFoodTruckIcon(isOpen, theme || 'light')}\r\n            eventHandlers={{\r\n              click: () => {\r\n                if (onSelectTruck) {\r\n                  onSelectTruck(truck.id);\r\n                }\r\n              },\r\n            }}\r\n          >\r\n            <Popup>\r\n              <h4 className=\"font-bold\">{truck.name}</h4>\r\n              {truck.current_location.address && <div>{truck.current_location.address}</div>}\r\n              <div className={isOpen ? 'text-green-600' : 'text-red-600'}>\r\n                {isOpen ? 'Open' : 'Closed'}\r\n              </div>\r\n            </Popup>\r\n          </Marker>\r\n        );\r\n      })}\r\n      {userLocation && (\r\n        <Marker position={[userLocation.lat, userLocation.lng]}>\r\n          <Popup>You are here</Popup>\r\n        </Marker>\r\n      )}\r\n    </MapContainer>\r\n  );\r\n};\r\n\r\nexport default MapComponent;\r\n","usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\map\\MapLoadingFallback.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\map\\MapViewUpdater.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\map\\TruckMarkers.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\map\\UserLocationMarker.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\map\\mapHelpers.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\monitoring\\ApiMonitoringDashboard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\monitoring\\FeatureCard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\monitoring\\FeatureList.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\monitoring\\FeatureOverviewCards.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\monitoring\\FeatureOverviewContent.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\monitoring\\MonitoringFeaturesCard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\monitoring\\MonitoringFeaturesContent.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\monitoring\\MonitoringPageHeader.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\monitoring\\TechnicalDetailsCard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\search\\AdvancedFilters.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\search\\CuisineTypesSection.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\search\\DistanceSliderSection.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\search\\FilterToggleButton.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\search\\MainSearchSection.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\search\\QuickFiltersSection.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\search\\SearchFilterContent.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\search\\SearchInputWithIcon.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\test-pipeline\\ErrorDisplay.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\test-pipeline\\StageResultCard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\test-pipeline\\StageResultDetails.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\test-pipeline\\TestPipelineForm.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\test-pipeline\\TestPipelineSubmitHandler.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\test-pipeline\\TestResultsDisplay.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\trucks\\MenuSection.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\trucks\\OperatingHoursSection.tsx","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":34,"column":12,"nodeType":"MemberExpression","messageId":"conditionErrorNullableBoolean","endLine":34,"endColumn":29,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[1580,1597],"text":"(todayHours.closed ?? false)"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[1580,1597],"text":"(todayHours.closed === true)"},"desc":"Change condition to check if true (`value === true`)"}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\r\nimport { Clock } from 'lucide-react';\r\nimport type { DailyOperatingHours } from '@/lib/supabase/types'; // Import DailyOperatingHours\r\n\r\ninterface OperatingHoursSectionProps {\r\n  readonly todayHours: DailyOperatingHours | undefined; // Update type\r\n  readonly formatHours: (hours: DailyOperatingHours) => string; // Update type\r\n}\r\n\r\n/**\r\n * Renders today's operating hours section.\r\n * @example\r\n * OperatingHoursSection({ todayHours: { closed: false, open: '09:00', close: '17:00' }, formatHours: (hours) => `${hours.open} - ${hours.close}` })\r\n * // Returns a JSX element with formatted operating hours or 'Closed'.\r\n * @param {Readonly<OperatingHoursSectionProps>} {todayHours, formatHours} - The properties for today's operating hours and the function to format them.\r\n * @returns {JSX.Element | undefined} A JSX element displaying today's hours, or nothing if hours are undefined.\r\n * @description\r\n *   - The component displays 'Closed' if todayHours indicates closure.\r\n *   - Utilizes a Clock icon for a visual representation of hours.\r\n *   - Ensures dark mode compatibility through styling classes.\r\n */\r\nexport function OperatingHoursSection({\r\n  todayHours,\r\n  formatHours,\r\n}: Readonly<OperatingHoursSectionProps>) {\r\n  if (todayHours === undefined) return; // Return null if no hours\r\n\r\n  return (\r\n    <div>\r\n      <h4 className=\"font-medium mb-2 text-sm dark:text-gray-100\">Today's Hours</h4>\r\n      <div className=\"flex items-center gap-2\">\r\n        <Clock className=\"size-3 text-gray-500\" />\r\n        <span className=\"text-sm dark:text-gray-300\">\r\n          {todayHours.closed ? 'Closed' : formatHours(todayHours)}\r\n        </span>\r\n      </div>\r\n    </div>\r\n  );\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\trucks\\RatingSection.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\trucks\\TruckAccordionItem.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\trucks\\TruckBasicInfo.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\trucks\\TruckContactInfo.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\trucks\\TruckDetailHeader.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\trucks\\TruckLocationInfo.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\trucks\\TruckNotFound.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\trucks\\TruckOperatingHours.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\trucks\\TruckRatingsReviews.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\ui\\AlertDialog.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\ui\\AspectRatio.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\ui\\ContactSection.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\ui\\ContextMenu.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\ui\\DropdownMenu.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\ui\\HoverCard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\ui\\InputOtp.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\ui\\MenuSection.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\ui\\Modal.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\ui\\NavigationMenu.tsx","messages":[{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":37,"column":7,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":39,"endColumn":2},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a(n) `any` typed value.","line":37,"column":36,"nodeType":"Identifier","messageId":"unsafeCall","endLine":37,"endColumn":39},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `any` assigned to a parameter of type `ClassValue`.","line":47,"column":19,"nodeType":"CallExpression","messageId":"unsafeArgument","endLine":47,"endColumn":47},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a(n) `any` typed value.","line":47,"column":19,"nodeType":"Identifier","messageId":"unsafeCall","endLine":47,"endColumn":45}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as React from 'react';\r\nimport * as NavigationMenuPrimitive from '@radix-ui/react-navigation-menu';\r\nimport { cva } from 'class-variance-authority';\r\nimport { ChevronDown } from 'lucide-react';\r\n\r\nimport { cn } from '@/lib/utils';\r\n\r\nconst NavigationMenu = React.forwardRef<\r\n  HTMLDivElement,\r\n  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Root>\r\n>(({ className, children, ...props }, ref) => (\r\n  <NavigationMenuPrimitive.Root\r\n    ref={ref}\r\n    className={cn('relative z-10 flex max-w-max flex-1 items-center justify-center', className)}\r\n    {...props}\r\n  >\r\n    {children}\r\n    <NavigationMenuViewport />\r\n  </NavigationMenuPrimitive.Root>\r\n));\r\nNavigationMenu.displayName = NavigationMenuPrimitive.Root.displayName;\r\n\r\nconst NavigationMenuList = React.forwardRef<\r\n  HTMLUListElement,\r\n  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.List>\r\n>(({ className, ...props }, ref) => (\r\n  <NavigationMenuPrimitive.List\r\n    ref={ref}\r\n    className={cn('group flex flex-1 list-none items-center justify-center space-x-1', className)}\r\n    {...props}\r\n  />\r\n));\r\nNavigationMenuList.displayName = NavigationMenuPrimitive.List.displayName;\r\n\r\nconst NavigationMenuItem = NavigationMenuPrimitive.Item;\r\n\r\nconst navigationMenuTriggerStyle = cva(\r\n  'group inline-flex h-10 w-max items-center justify-center rounded-md bg-background px-4 py-2 text-sm font-medium transition-colors hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground focus:outline-none disabled:pointer-events-none disabled:opacity-50 data-[active]:bg-accent/50 data-[state=open]:bg-accent/50',\r\n);\r\n\r\nconst NavigationMenuTrigger = React.forwardRef<\r\n  HTMLButtonElement,\r\n  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Trigger>\r\n>(({ className, children, ...props }, ref) => (\r\n  <NavigationMenuPrimitive.Trigger\r\n    ref={ref}\r\n    className={cn(navigationMenuTriggerStyle(), 'group', className)}\r\n    {...props}\r\n  >\r\n    {children}{' '}\r\n    <ChevronDown\r\n      className=\"relative top-[1px] ml-1 size-3 transition duration-200 group-data-[state=open]:rotate-180\"\r\n      aria-hidden=\"true\"\r\n    />\r\n  </NavigationMenuPrimitive.Trigger>\r\n));\r\nNavigationMenuTrigger.displayName = NavigationMenuPrimitive.Trigger.displayName;\r\n\r\nconst NavigationMenuContent = React.forwardRef<\r\n  HTMLDivElement,\r\n  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Content>\r\n>(({ className, ...props }, ref) => (\r\n  <NavigationMenuPrimitive.Content\r\n    ref={ref}\r\n    className={cn(\r\n      'left-0 top-0 w-full data-[motion^=from-]:animate-in data-[motion^=to-]:animate-out data-[motion^=from-]:fade-in data-[motion^=to-]:fade-out data-[motion=from-end]:slide-in-from-right-52 data-[motion=from-start]:slide-in-from-left-52 data-[motion=to-end]:slide-out-to-right-52 data-[motion=to-start]:slide-out-to-left-52 md:absolute md:w-auto ',\r\n      className,\r\n    )}\r\n    {...props}\r\n  />\r\n));\r\nNavigationMenuContent.displayName = NavigationMenuPrimitive.Content.displayName;\r\n\r\nconst NavigationMenuLink = NavigationMenuPrimitive.Link;\r\n\r\nconst NavigationMenuViewport = React.forwardRef<\r\n  HTMLDivElement,\r\n  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Viewport>\r\n>(({ className, ...props }, ref) => (\r\n  <div className={cn('absolute left-0 top-full flex justify-center')}>\r\n    <NavigationMenuPrimitive.Viewport\r\n      className={cn(\r\n        'origin-top-center relative mt-1.5 h-[var(--radix-navigation-menu-viewport-height)] w-full overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-90 md:w-[var(--radix-navigation-menu-viewport-width)]',\r\n        className,\r\n      )}\r\n      ref={ref}\r\n      {...props}\r\n    />\r\n  </div>\r\n));\r\nNavigationMenuViewport.displayName = NavigationMenuPrimitive.Viewport.displayName;\r\n\r\nconst NavigationMenuIndicator = React.forwardRef<\r\n  HTMLDivElement,\r\n  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Indicator>\r\n>(({ className, ...props }, ref) => (\r\n  <NavigationMenuPrimitive.Indicator\r\n    ref={ref}\r\n    className={cn(\r\n      'top-full z-[1] flex h-1.5 items-end justify-center overflow-hidden data-[state=visible]:animate-in data-[state=hidden]:animate-out data-[state=hidden]:fade-out data-[state=visible]:fade-in',\r\n      className,\r\n    )}\r\n    {...props}\r\n  >\r\n    <div className=\"relative top-[60%] size-2 rotate-45 rounded-tl-sm bg-border shadow-md\" />\r\n  </NavigationMenuPrimitive.Indicator>\r\n));\r\nNavigationMenuIndicator.displayName = NavigationMenuPrimitive.Indicator.displayName;\r\n\r\nexport {\r\n  navigationMenuTriggerStyle,\r\n  NavigationMenu,\r\n  NavigationMenuList,\r\n  NavigationMenuItem,\r\n  NavigationMenuContent,\r\n  NavigationMenuTrigger,\r\n  NavigationMenuLink,\r\n  NavigationMenuIndicator,\r\n  NavigationMenuViewport,\r\n};\r\n","usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\ui\\RadioGroup.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\ui\\RatingSection.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\ui\\ScrollArea.tsx","messages":[{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `any` assigned to a parameter of type `ClassValue`.","line":14,"column":47,"nodeType":"Identifier","messageId":"unsafeArgument","endLine":14,"endColumn":56},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":24,"column":1,"nodeType":"AssignmentExpression","messageId":"anyAssignment","endLine":24,"endColumn":62},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .Root on an `any` value.","line":24,"column":46,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":24,"endColumn":50},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":32,"column":18,"nodeType":"Identifier","messageId":"anyAssignment","endLine":32,"endColumn":29},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `any` assigned to a parameter of type `ClassValue`.","line":37,"column":7,"nodeType":"Identifier","messageId":"unsafeArgument","endLine":37,"endColumn":16},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":44,"column":1,"nodeType":"AssignmentExpression","messageId":"anyAssignment","endLine":44,"endColumn":76},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .ScrollAreaScrollbar on an `any` value.","line":44,"column":45,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":44,"endColumn":64}],"suppressedMessages":[],"errorCount":7,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use client';\r\n\r\nimport * as React from 'react';\r\nimport * as ScrollAreaPrimitive from '@radix-ui/react-scroll-area';\r\n\r\nimport { cn } from '@/lib/utils';\r\n\r\nconst ScrollArea = React.forwardRef<\r\n  HTMLDivElement,\r\n  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.Root>\r\n>(({ className, children, ...props }, ref) => (\r\n  <ScrollAreaPrimitive.Root\r\n    ref={ref}\r\n    className={cn('relative overflow-hidden', className)}\r\n    {...props}\r\n  >\r\n    <ScrollAreaPrimitive.Viewport className=\"size-full rounded-[inherit]\">\r\n      {children}\r\n    </ScrollAreaPrimitive.Viewport>\r\n    <ScrollBar />\r\n    <ScrollAreaPrimitive.Corner />\r\n  </ScrollAreaPrimitive.Root>\r\n));\r\nScrollArea.displayName = ScrollAreaPrimitive.Root.displayName;\r\n\r\nconst ScrollBar = React.forwardRef<\r\n  HTMLDivElement,\r\n  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>\r\n>(({ className, orientation = 'vertical', ...props }, ref) => (\r\n  <ScrollAreaPrimitive.ScrollAreaScrollbar\r\n    ref={ref}\r\n    orientation={orientation}\r\n    className={cn(\r\n      'flex touch-none select-none transition-colors',\r\n      orientation === 'vertical' && 'h-full w-2.5 border-l border-l-transparent p-[1px]',\r\n      orientation === 'horizontal' && 'h-2.5 flex-col border-t border-t-transparent p-[1px]',\r\n      className,\r\n    )}\r\n    {...props}\r\n  >\r\n    <ScrollAreaPrimitive.ScrollAreaThumb className=\"relative flex-1 rounded-full bg-border\" />\r\n  </ScrollAreaPrimitive.ScrollAreaScrollbar>\r\n));\r\nScrollBar.displayName = ScrollAreaPrimitive.ScrollAreaScrollbar.displayName;\r\n\r\nexport { ScrollArea, ScrollBar };\r\n","usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\ui\\SimpleQualityPanel.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\ui\\SocialMediaSection.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\ui\\ToggleGroup.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\ui\\TruckCard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\ui\\accordion.tsx","messages":[],"suppressedMessages":[{"ruleId":"sonarjs/deprecation","severity":2,"message":"'ElementRef' is deprecated.","line":13,"column":9,"nodeType":null,"messageId":"deprecation","endLine":13,"endColumn":19,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\ui\\alert.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\ui\\avatar.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\ui\\badge.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\ui\\breadcrumb.tsx","messages":[{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":42,"column":9,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":42,"endColumn":45}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as React from 'react';\r\nimport { Slot } from '@radix-ui/react-slot';\r\nimport { ChevronRight, MoreHorizontal } from 'lucide-react';\r\n\r\nimport { cn } from '@/lib/utils';\r\n\r\nconst Breadcrumb = React.forwardRef<\r\n  HTMLElement,\r\n  React.ComponentPropsWithoutRef<'nav'> & {\r\n    separator?: React.ReactNode;\r\n  }\r\n>(({ ...props }, ref) => <nav ref={ref} aria-label=\"breadcrumb\" {...props} />);\r\nBreadcrumb.displayName = 'Breadcrumb';\r\n\r\nconst BreadcrumbList = React.forwardRef<HTMLOListElement, React.ComponentPropsWithoutRef<'ol'>>(\r\n  ({ className, ...props }, ref) => (\r\n    <ol\r\n      ref={ref}\r\n      className={cn(\r\n        'flex flex-wrap items-center gap-1.5 break-words text-sm text-muted-foreground sm:gap-2.5',\r\n        className,\r\n      )}\r\n      {...props}\r\n    />\r\n  ),\r\n);\r\nBreadcrumbList.displayName = 'BreadcrumbList';\r\n\r\nconst BreadcrumbItem = React.forwardRef<HTMLLIElement, React.ComponentPropsWithoutRef<'li'>>(\r\n  ({ className, ...props }, ref) => (\r\n    <li ref={ref} className={cn('inline-flex items-center gap-1.5', className)} {...props} />\r\n  ),\r\n);\r\nBreadcrumbItem.displayName = 'BreadcrumbItem';\r\n\r\nconst BreadcrumbLink = React.forwardRef<\r\n  HTMLAnchorElement,\r\n  React.ComponentPropsWithoutRef<'a'> & {\r\n    asChild?: boolean;\r\n  }\r\n>(({ asChild, className, ...props }, ref) => {\r\n  const Comp = asChild === true ? Slot : 'a';\r\n\r\n  return (\r\n    <Comp\r\n      ref={ref}\r\n      className={cn('transition-colors hover:text-foreground', className)}\r\n      {...props}\r\n    />\r\n  );\r\n});\r\nBreadcrumbLink.displayName = 'BreadcrumbLink';\r\n\r\nconst BreadcrumbPage = React.forwardRef<HTMLSpanElement, React.ComponentPropsWithoutRef<'span'>>(\r\n  ({ className, ...props }, ref) => (\r\n    <span\r\n      ref={ref}\r\n      role=\"link\"\r\n      aria-disabled=\"true\"\r\n      aria-current=\"page\"\r\n      className={cn('font-normal text-foreground', className)}\r\n      {...props}\r\n    />\r\n  ),\r\n);\r\nBreadcrumbPage.displayName = 'BreadcrumbPage';\r\n\r\nconst BreadcrumbSeparator = ({ children, className, ...props }: React.ComponentProps<'li'>) => (\r\n  <li\r\n    role=\"presentation\"\r\n    aria-hidden=\"true\"\r\n    className={cn('[&>svg]:w-3.5 [&>svg]:h-3.5', className)}\r\n    {...props}\r\n  >\r\n    {children ?? <ChevronRight />}\r\n  </li>\r\n);\r\nBreadcrumbSeparator.displayName = 'BreadcrumbSeparator';\r\n\r\nconst BreadcrumbEllipsis = ({ className, ...props }: React.ComponentProps<'span'>) => (\r\n  <span\r\n    role=\"presentation\"\r\n    aria-hidden=\"true\"\r\n    className={cn('flex h-9 w-9 items-center justify-center', className)}\r\n    {...props}\r\n  >\r\n    <MoreHorizontal className=\"size-4\" />\r\n    <span className=\"sr-only\">More</span>\r\n  </span>\r\n);\r\nBreadcrumbEllipsis.displayName = 'BreadcrumbElipssis';\r\n\r\nexport {\r\n  Breadcrumb,\r\n  BreadcrumbList,\r\n  BreadcrumbItem,\r\n  BreadcrumbLink,\r\n  BreadcrumbPage,\r\n  BreadcrumbSeparator,\r\n  BreadcrumbEllipsis,\r\n};\r\n","usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\ui\\button.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\ui\\calendar.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\ui\\card.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\ui\\carousel.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\ui\\chart.tsx","messages":[{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":183,"column":20,"nodeType":"TSAsExpression","messageId":"anyAssignment","endLine":183,"endColumn":36},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":183,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":183,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6603,6606],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6603,6606],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[{"ruleId":"max-params","severity":2,"message":"Function has too many parameters (5). Maximum allowed is 4.","line":120,"column":25,"nodeType":"TSFunctionType","messageId":"exceed","endLine":120,"endColumn":25,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":1,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/* eslint-disable max-params */\r\n'use client';\r\n\r\nimport * as React from 'react';\r\nimport * as RechartsPrimitive from 'recharts';\r\nimport type { NameType, Payload, ValueType } from 'recharts/types/component/DefaultTooltipContent';\r\n\r\nimport { cn } from '@/lib/utils';\r\nimport { useTooltipLabel } from './chart/useTooltipLabel';\r\nimport { TooltipIndicator } from './chart/TooltipIndicator';\r\nimport { TooltipItemContent } from './chart/TooltipItemContent';\r\nimport { getPayloadConfigFromPayload } from './chart/getPayloadConfigFromPayload';\r\n\r\n// Format: { THEME_NAME: CSS_SELECTOR }\r\nconst THEMES = { light: '', dark: '.dark' } as const;\r\n\r\nexport type ChartConfig = {\r\n  [k in string]: {\r\n    label?: React.ReactNode;\r\n    icon?: React.ComponentType;\r\n  } & (\r\n    | { color?: string; theme?: never }\r\n    | { color?: never; theme: Record<keyof typeof THEMES, string> }\r\n  );\r\n};\r\n\r\ntype ChartContextProps = {\r\n  config: ChartConfig;\r\n};\r\n\r\nconst ChartContext = React.createContext<ChartContextProps | undefined>(undefined);\r\n\r\nfunction useChart() {\r\n  const context = React.useContext(ChartContext);\r\n  if (context === undefined) {\r\n    throw new Error('useChart must be used within a <ChartContainer />');\r\n  }\r\n  return context;\r\n}\r\n\r\nconst ChartContainer = React.forwardRef<\r\n  HTMLDivElement,\r\n  React.ComponentProps<'div'> & {\r\n    readonly config: ChartConfig;\r\n    readonly children: React.ComponentProps<\r\n      typeof RechartsPrimitive.ResponsiveContainer\r\n    >['children'];\r\n  }\r\n>(({ id, className, children, config, ...props }, ref) => {\r\n  const uniqueId = React.useId();\r\n  const chartId = `chart-${id ?? uniqueId.replaceAll(':', '')}`;\r\n\r\n  return (\r\n    <ChartContext.Provider value={{ config }}>\r\n      <div\r\n        data-chart={chartId}\r\n        ref={ref}\r\n        className={cn(\r\n          \"flex aspect-video justify-center text-xs [&_.recharts-cartesian-axis-tick_text]:fill-muted-foreground [&_.recharts-cartesian-grid_line[stroke='#ccc']]:stroke-border/50 [&_.recharts-curve.recharts-tooltip-cursor]:stroke-border [&_.recharts-dot[stroke='#fff']]:stroke-transparent [&_.recharts-layer]:outline-none [&_.recharts-polar-grid_[stroke='#ccc']]:stroke-border [&_.recharts-radial-bar-background-sector]:fill-muted [&_.recharts-rectangle.recharts-tooltip-cursor]:fill-muted [&_.recharts-reference-line_[stroke='#ccc']]:stroke-border [&_.recharts-sector[stroke='#fff']]:stroke-transparent [&_.recharts-sector]:outline-none [&_.recharts-surface]:outline-none\",\r\n          className,\r\n        )}\r\n        {...props}\r\n      >\r\n        <ChartStyle id={chartId} config={config} />\r\n        <RechartsPrimitive.ResponsiveContainer>{children}</RechartsPrimitive.ResponsiveContainer>\r\n      </div>\r\n    </ChartContext.Provider>\r\n  );\r\n});\r\nChartContainer.displayName = 'Chart';\r\n\r\n/**\r\n * Generates and returns a style JSX element with theme-based color configurations for charts.\r\n * @example\r\n * const jsxStyleElement = generateStyleElement({ id: 'myChart', config: myChartConfig });\r\n * @param {Object} context - An object containing the chart's identifier and configuration.\r\n * @param {string} context.id - The unique identifier for the chart.\r\n * @param {ChartConfig} context.config - The configuration object for the chart.\r\n * @returns {JSX.Element|undefined} A JSX style element setting CSS variables for chart colors, or undefined if no color configuration is provided.\r\n * @description\r\n *   - Only charts with theme or color properties in their configuration will generate color styles.\r\n *   - Utilizes `dangerouslySetInnerHTML` to inject computed styles into JSX.\r\n */\r\nconst ChartStyle = ({ id, config }: { readonly id: string; readonly config: ChartConfig }) => {\r\n  const colorConfig = Object.entries(config).filter(\r\n    ([_, itemConfig]) => (itemConfig.theme ?? itemConfig.color) !== undefined,\r\n  );\r\n  if (colorConfig.length === 0) {\r\n    return;\r\n  }\r\n\r\n  return (\r\n    <style\r\n      dangerouslySetInnerHTML={{\r\n        __html: Object.entries(THEMES)\r\n          .map(\r\n            ([theme, prefix]) => `\r\n${prefix} [data-chart=${id}] {\r\n${colorConfig\r\n  .map(([key, itemConfig]) => {\r\n    const color = itemConfig.theme?.[theme as keyof typeof itemConfig.theme] ?? itemConfig.color;\r\n    return color !== undefined && color !== '' ? `  --color-${key}: ${color};` : undefined;\r\n  })\r\n  .join('\\n')}\r\n}\r\n`,\r\n          )\r\n          .join('\\n'),\r\n      }}\r\n    />\r\n  );\r\n};\r\n\r\nconst ChartTooltip = RechartsPrimitive.Tooltip;\r\n\r\nfunction isNonEmptyArray<T>(arr: T[] | undefined): arr is T[] {\r\n  return Array.isArray(arr) && arr.length > 0;\r\n}\r\n\r\ntype TooltipFormatter = (\r\n  value: number,\r\n  name: string,\r\n  item: Payload<ValueType, NameType>,\r\n  index: number,\r\n  payload: Payload<ValueType, NameType>[],\r\n) => React.ReactNode;\r\ntype TooltipItemData = {\r\n  name?: string;\r\n  dataKey?: string;\r\n  payload?: Record<string, unknown>;\r\n  color?: string;\r\n  value?: number;\r\n};\r\n\r\ntype ChartTooltipIndicatorAndContentProps = {\r\n  indicator: 'line' | 'dot' | 'dashed';\r\n  hideIndicator: boolean;\r\n  indicatorColor?: string;\r\n  nestLabel: boolean;\r\n  itemConfig: Record<string, unknown>;\r\n  formatter: TooltipFormatter | undefined;\r\n  itemData: TooltipItemData;\r\n  item: Payload<ValueType, NameType>;\r\n  index: number;\r\n  tooltipLabel: React.ReactNode;\r\n};\r\n\r\n/**\r\n* Renders a tooltip indicator and content for a chart\r\n* @example\r\n* ChartTooltipIndicatorAndContent({ indicator: 'sample', hideIndicator: false })\r\n* Returns a JSX fragment containing TooltipIndicator and TooltipItemContent components\r\n* @param {ChartTooltipIndicatorAndContentProps} props - Configuration object for rendering the tooltip components.\r\n* @returns {JSX.Element} A fragment that contains tooltip indicator and item content components.\r\n* @description\r\n*   - Combines TooltipIndicator and TooltipItemContent using provided configuration.\r\n*   - Uses the `formatter` function to format the item data in the tooltip content.\r\n*   - Passes the `itemConfig` and `nestLabel` to both child components for consistent rendering.\r\n*/\r\nfunction ChartTooltipIndicatorAndContent(props: Readonly<ChartTooltipIndicatorAndContentProps>) {\r\n  const {\r\n    indicator,\r\n    hideIndicator,\r\n    indicatorColor,\r\n    nestLabel,\r\n    itemConfig,\r\n    formatter,\r\n    itemData,\r\n    item,\r\n    index,\r\n    tooltipLabel,\r\n  } = props;\r\n  return (\r\n    <>\r\n      <TooltipIndicator\r\n        indicator={indicator}\r\n        hideIndicator={hideIndicator}\r\n        indicatorColor={indicatorColor}\r\n        nestLabel={nestLabel}\r\n        itemConfig={itemConfig}\r\n      />\r\n      <TooltipItemContent\r\n        formatter={formatter as any}\r\n        itemData={itemData}\r\n        item={item}\r\n        index={index}\r\n        itemConfig={itemConfig}\r\n        nestLabel={nestLabel}\r\n        tooltipLabel={tooltipLabel}\r\n      />\r\n    </>\r\n  );\r\n}\r\n\r\ntype ChartTooltipItemProps = {\r\n  item: Payload<ValueType, NameType>;\r\n  index: number;\r\n  indicatorProps: {\r\n    indicator: 'line' | 'dot' | 'dashed';\r\n    hideIndicator: boolean;\r\n    color?: string;\r\n    nestLabel: boolean;\r\n    config: ChartConfig;\r\n    nameKey?: string;\r\n    tooltipLabel: React.ReactNode;\r\n    formatter: TooltipFormatter | undefined;\r\n  };\r\n};\r\n\r\n/**\r\n * Renders a chart tooltip item with a configurable indicator.\r\n * @example\r\n * ChartTooltipItem({ item: { name: \"Sample\", dataKey: \"key\" }, index: 0, indicatorProps: { indicator: \"dot\", hideIndicator: false, color: \"blue\" } })\r\n * // Returns JSX element for tooltip with indicator\r\n * @param {Object} item - The chart item containing dataKey, name, payload, color, and value attributes.\r\n * @param {number} index - The index position of the chart item.\r\n * @param {Object} indicatorProps - Properties for configuring the indicator like type, visibility, color, etc.\r\n * @returns {JSX.Element} A JSX element rendering the chart tooltip item with an optional indicator.\r\n * @description\r\n *   - The tooltip item will display customizable content based on provided item configuration.\r\n *   - Tooltip indicator can be hidden or shown based on `hideIndicator` property.\r\n *   - Determines the color of the indicator, initially defaulting to item-specific color or payload-specific fill.\r\n */\r\nfunction ChartTooltipItem({ item, index, indicatorProps }: Readonly<ChartTooltipItemProps>) {\r\n  const { indicator, hideIndicator, color, nestLabel, config, nameKey, tooltipLabel, formatter } =\r\n    indicatorProps;\r\n  const dataKey = typeof item.dataKey === 'string' ? item.dataKey : undefined;\r\n\r\n  const itemData: TooltipItemData = {\r\n    name: item.name === undefined ? undefined : String(item.name),\r\n    dataKey,\r\n    payload:\r\n      typeof item.payload === 'object' && item.payload !== null\r\n        ? (item.payload as Record<string, unknown>)\r\n        : undefined,\r\n    color: typeof item.color === 'string' ? item.color : undefined,\r\n    value: typeof item.value === 'number' ? item.value : undefined,\r\n  };\r\n  const key = nameKey ?? itemData.name ?? itemData.dataKey ?? 'value';\r\n  const itemConfig = getPayloadConfigFromPayload(config, item, key) as Record<string, unknown>;\r\n  const indicatorColor =\r\n    color ??\r\n    (itemData.payload !== undefined &&\r\n    typeof itemData.payload === 'object' &&\r\n    'fill' in itemData.payload\r\n      ? String(itemData.payload.fill)\r\n      : undefined) ??\r\n    itemData.color;\r\n  return (\r\n    <div\r\n      key={itemData.dataKey ?? index}\r\n      className={cn(\r\n        'flex w-full flex-wrap items-stretch gap-2 [&>svg]:h-2.5 [&>svg]:w-2.5 [&>svg]:text-muted-foreground',\r\n        indicator === 'dot' && 'items-center',\r\n      )}\r\n    >\r\n      <ChartTooltipIndicatorAndContent\r\n        indicator={indicator}\r\n        hideIndicator={hideIndicator}\r\n        indicatorColor={indicatorColor}\r\n        nestLabel={nestLabel}\r\n        itemConfig={itemConfig}\r\n        formatter={formatter}\r\n        itemData={itemData}\r\n        item={item}\r\n        index={index}\r\n        tooltipLabel={tooltipLabel}\r\n      />\r\n    </div>\r\n  );\r\n}\r\n\r\ntype ChartTooltipItemsProps = {\r\n  safePayload: Payload<ValueType, NameType>[];\r\n  indicatorProps: {\r\n    indicator: 'line' | 'dot' | 'dashed';\r\n    hideIndicator: boolean;\r\n    formatter: TooltipFormatter | undefined;\r\n    nameKey?: string;\r\n    color?: string;\r\n    tooltipLabel: React.ReactNode;\r\n    config: ChartConfig;\r\n    nestLabel: boolean;\r\n  };\r\n};\r\n\r\n/**\r\n * Represents a grid layout of tooltip items for a chart.\r\n * @example\r\n * ChartTooltipItems({ safePayload: payloadData, indicatorProps: chartIndicatorSettings })\r\n * <div className=\"grid gap-1.5\">...</div>\r\n * @param {Readonly<ChartTooltipItemsProps>} props - Contains the payload and indicator properties required for rendering tooltip items.\r\n * @returns {JSX.Element} A div containing tooltip items in a grid layout.\r\n * @description\r\n *   - Utilizes the `ChartTooltipItem` component to render individual tooltip items.\r\n *   - Applies a CSS class for a grid layout with spacing between items.\r\n *   - Ensures safe access to each item's key using `item.dataKey ?? index`.\r\n */\r\nfunction ChartTooltipItems(props: Readonly<ChartTooltipItemsProps>) {\r\n  const { safePayload, indicatorProps } = props;\r\n  return (\r\n    <div className=\"grid gap-1.5\">\r\n      {safePayload.map((item, index) => (\r\n        <ChartTooltipItem\r\n          key={item.dataKey ?? index}\r\n          item={item}\r\n          index={index}\r\n          indicatorProps={indicatorProps}\r\n        />\r\n      ))}\r\n    </div>\r\n  );\r\n}\r\n\r\nconst ChartTooltipContent = React.forwardRef<\r\n  HTMLDivElement,\r\n  React.ComponentProps<typeof RechartsPrimitive.Tooltip> &\r\n    React.ComponentProps<'div'> & {\r\n      readonly hideLabel?: boolean;\r\n      readonly hideIndicator?: boolean;\r\n      readonly indicator?: 'line' | 'dot' | 'dashed';\r\n      readonly nameKey?: string;\r\n      readonly labelKey?: string;\r\n    }\r\n>(\r\n  (\r\n    {\r\n      active,\r\n      payload,\r\n      className,\r\n      indicator = 'dot',\r\n      hideLabel = false,\r\n      hideIndicator = false,\r\n      label,\r\n      labelFormatter,\r\n      labelClassName,\r\n      formatter,\r\n      color,\r\n      nameKey,\r\n      labelKey,\r\n    },\r\n    ref,\r\n  ) => {\r\n    const { config } = useChart();\r\n    const safePayload: Payload<ValueType, NameType>[] = isNonEmptyArray(payload) ? payload : [];\r\n    const tooltipLabel = useTooltipLabel({\r\n      hideLabel,\r\n      payload: safePayload,\r\n      label,\r\n      labelFormatter,\r\n      labelClassName,\r\n      config,\r\n      labelKey,\r\n    });\r\n\r\n    if (active === false || !isNonEmptyArray(safePayload)) {\r\n      return;\r\n    }\r\n\r\n    const nestLabel = safePayload.length === 1 && indicator !== 'dot';\r\n\r\n    return (\r\n      <div\r\n        ref={ref}\r\n        className={cn(\r\n          'grid min-w-[8rem] items-start gap-1.5 rounded-lg border border-border/50 bg-background px-2.5 py-1.5 text-xs shadow-xl',\r\n          className,\r\n        )}\r\n      >\r\n        {!nestLabel && tooltipLabel}\r\n        <ChartTooltipItems\r\n          safePayload={safePayload}\r\n          indicatorProps={{\r\n            indicator,\r\n            hideIndicator,\r\n            formatter: formatter,\r\n            nameKey,\r\n            color,\r\n            tooltipLabel,\r\n            config,\r\n            nestLabel,\r\n          }}\r\n        />\r\n      </div>\r\n    );\r\n  },\r\n);\r\nChartTooltipContent.displayName = 'ChartTooltip';\r\n\r\nconst ChartLegend = RechartsPrimitive.Legend;\r\n\r\ninterface ChartLegendItemProps {\r\n  item: Payload<ValueType, NameType>;\r\n  idx: number;\r\n  hideIcon: boolean;\r\n  nameKey?: string;\r\n  config: ChartConfig;\r\n}\r\n\r\n/**\r\n * Renders a chart legend item with customizable appearance.\r\n * @example\r\n * ChartLegendItem({ item: sampleItem, idx: 0, hideIcon: false, nameKey: 'legendItem', config: sampleConfig })\r\n * Returns a JSX element representing the chart legend item with an icon, label, or color box.\r\n * @param {Object} item - The legend item data including `dataKey`, `value`, and `color`.\r\n * @param {number} idx - The index of the item in the legend list to be used as a fallback key.\r\n * @param {boolean} hideIcon - A flag to determine whether to hide the item icon.\r\n * @param {string} [nameKey] - Optional key to identify the legend item, falling back to `dataKey` or 'value'.\r\n * @param {Object} config - Configuration object to customize the legend item appearance and behavior.\r\n * @returns {JSX.Element} A JSX element representing the chart legend item with optional icon, label, or color box.\r\n * @description\r\n *   - Uses the item's `dataKey` as a unique identifier when `nameKey` is not provided.\r\n *   - Applies default styling to SVG icons within the legend item using Tailwind CSS classes.\r\n *   - Dynamically renders either an icon or a styled color box based on the `hideIcon` flag and `itemConfig`.\r\n *   - Retrieves configuration using `getPayloadConfigFromPayload` for interactive legend item customization.\r\n */\r\nfunction ChartLegendItem({ item, idx, hideIcon, nameKey, config }: Readonly<ChartLegendItemProps>) {\r\n  const dataKey = item.dataKey?.toString();\r\n  const itemData = {\r\n    dataKey,\r\n    value: item.value?.toString(),\r\n    color: item.color?.toString(),\r\n  };\r\n  const key = nameKey ?? dataKey ?? 'value';\r\n  const itemConfig = getPayloadConfigFromPayload(config, item, key);\r\n\r\n  return (\r\n    <div\r\n      key={itemData.value ?? idx}\r\n      className={cn(\r\n        'flex items-center gap-1.5 [&>svg]:h-3 [&>svg]:w-3 [&>svg]:text-muted-foreground',\r\n      )}\r\n    >\r\n      {itemConfig?.icon && !hideIcon ? (\r\n        <itemConfig.icon />\r\n      ) : (\r\n        <div\r\n          className=\"size-2 shrink-0 rounded-[2px]\"\r\n          style={{\r\n            backgroundColor: itemData.color,\r\n          }}\r\n        />\r\n      )}\r\n      {itemConfig?.label}\r\n    </div>\r\n  );\r\n}\r\n\r\nconst ChartLegendContent = React.forwardRef<\r\n  HTMLDivElement,\r\n  React.ComponentProps<typeof RechartsPrimitive.Legend> &\r\n    Pick<RechartsPrimitive.LegendProps, 'payload' | 'verticalAlign'> & {\r\n      hideIcon?: boolean;\r\n      nameKey?: string;\r\n    }\r\n>(({ className, hideIcon = false, payload, verticalAlign = 'bottom', nameKey }, ref) => {\r\n  const { config } = useChart();\r\n  const safePayload: Payload<ValueType, NameType>[] = isNonEmptyArray(payload)\r\n    ? (payload as Payload<ValueType, NameType>[])\r\n    : [];\r\n  if (!isNonEmptyArray(safePayload)) {\r\n    return;\r\n  }\r\n\r\n  return (\r\n    <div\r\n      ref={ref}\r\n      className={cn(\r\n        'flex items-center justify-center gap-4',\r\n        verticalAlign === 'top' ? 'pb-3' : 'pt-3',\r\n        className,\r\n      )}\r\n    >\r\n      {safePayload.map((item, idx) => (\r\n        <ChartLegendItem\r\n          key={item.dataKey ?? idx}\r\n          item={item}\r\n          idx={idx}\r\n          hideIcon={hideIcon}\r\n          nameKey={nameKey}\r\n          config={config}\r\n        />\r\n      ))}\r\n    </div>\r\n  );\r\n});\r\nChartLegendContent.displayName = 'ChartLegend';\r\n\r\nexport {\r\n  ChartContainer,\r\n  ChartTooltip,\r\n  ChartTooltipContent,\r\n  ChartLegend,\r\n  ChartLegendContent,\r\n  ChartStyle,\r\n};\r\n","usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\ui\\chart\\CustomTooltip.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\ui\\chart\\QualityPieChart.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\ui\\chart\\TooltipIndicator.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\ui\\chart\\TooltipItemContent.tsx","messages":[],"suppressedMessages":[{"ruleId":"max-params","severity":2,"message":"Function has too many parameters (5). Maximum allowed is 4.","line":6,"column":24,"nodeType":"TSFunctionType","messageId":"exceed","endLine":6,"endColumn":24,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\ui\\chart\\getPayloadConfigFromPayload.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\ui\\chart\\useTooltipLabel.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\ui\\checkbox.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\ui\\collapsible.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\ui\\command.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\ui\\dataQualityCharts.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\ui\\dialog.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\ui\\drawer.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\ui\\form.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\ui\\input.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\ui\\label.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\ui\\pagination.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\ui\\popover.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\ui\\progress.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\ui\\resizable.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\ui\\select.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\ui\\separator.tsx","messages":[{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":14,"column":17,"nodeType":"Identifier","messageId":"anyAssignment","endLine":14,"endColumn":27},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":15,"column":18,"nodeType":"Identifier","messageId":"anyAssignment","endLine":15,"endColumn":29},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `any` assigned to a parameter of type `ClassValue`.","line":19,"column":7,"nodeType":"Identifier","messageId":"unsafeArgument","endLine":19,"endColumn":16},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":24,"column":1,"nodeType":"AssignmentExpression","messageId":"anyAssignment","endLine":24,"endColumn":60},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .Root on an `any` value.","line":24,"column":44,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":24,"endColumn":48}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use client';\n\nimport * as React from 'react';\nimport * as SeparatorPrimitive from '@radix-ui/react-separator';\n\nimport { cn } from '@/lib/utils';\n\nconst Separator = React.forwardRef<\n  HTMLDivElement,\n  React.ComponentPropsWithoutRef<typeof SeparatorPrimitive.Root>\n>(({ className, orientation = 'horizontal', decorative = true, ...props }, ref) => (\n  <SeparatorPrimitive.Root\n    ref={ref}\n    decorative={decorative}\n    orientation={orientation}\n    className={cn(\n      'shrink-0 bg-border',\n      orientation === 'horizontal' ? 'h-[1px] w-full' : 'h-full w-[1px]',\n      className,\n    )}\n    {...props}\n  />\n));\nSeparator.displayName = SeparatorPrimitive.Root.displayName;\n\nexport { Separator };\n","usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\ui\\sheet.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\ui\\sidebar.tsx","messages":[{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `any` assigned to a parameter of type `ClassValue`.","line":378,"column":54,"nodeType":"Identifier","messageId":"unsafeArgument","endLine":378,"endColumn":63},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":420,"column":9,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":420,"endColumn":38},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":441,"column":9,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":441,"endColumn":41},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":541,"column":11,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":541,"endColumn":43},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":587,"column":9,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":587,"endColumn":41},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":697,"column":9,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":697,"endColumn":36}],"suppressedMessages":[],"errorCount":6,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use client';\r\n\r\nimport * as React from 'react';\r\nimport { Slot } from '@radix-ui/react-slot';\r\nimport { tv } from 'tailwind-variants';\r\nimport { PanelLeft } from 'lucide-react';\r\n\r\nimport { useIsMobile } from '@/hooks/UseMobile';\r\nimport { cn } from '@/lib/utils';\r\nimport { Button } from '@/components/ui/button';\r\nimport { Input } from '@/components/ui/input';\r\nimport { Separator } from '@/components/ui/separator';\r\nimport { Sheet, SheetContent } from '@/components/ui/sheet';\r\nimport { Skeleton } from '@/components/ui/skeleton';\r\nimport { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from '@/components/ui/tooltip';\r\nimport Cookies from 'js-cookie';\r\n\r\nconst SIDEBAR_COOKIE_NAME = 'sidebar:state';\r\nconst SIDEBAR_COOKIE_MAX_AGE = 60 * 60 * 24 * 7;\r\nconst SIDEBAR_WIDTH = '16rem';\r\nconst SIDEBAR_WIDTH_MOBILE = '18rem';\r\nconst SIDEBAR_WIDTH_ICON = '3rem';\r\nconst SIDEBAR_KEYBOARD_SHORTCUT = 'b';\r\n\r\ntype SidebarContext = {\r\n  state: 'expanded' | 'collapsed';\r\n  open: boolean;\r\n  setOpen: (open: boolean) => void;\r\n  openMobile: boolean;\r\n  setOpenMobile: (open: boolean) => void;\r\n  isMobile: boolean;\r\n  toggleSidebar: () => void;\r\n};\r\n\r\nconst SidebarContext = React.createContext<SidebarContext | undefined>(undefined);\r\n\r\nfunction useSidebar() {\r\n  const context = React.useContext(SidebarContext);\r\n  if (!context) {\r\n    throw new Error('useSidebar must be used within a SidebarProvider.');\r\n  }\r\n\r\n  return context;\r\n}\r\n\r\nconst SidebarProvider = React.forwardRef<\r\n  HTMLDivElement,\r\n  React.ComponentProps<'div'> & {\r\n    defaultOpen?: boolean;\r\n    open?: boolean;\r\n    onOpenChange?: (open: boolean) => void;\r\n  }\r\n>(\r\n  (\r\n    {\r\n      defaultOpen = true,\r\n      open: openProp,\r\n      onOpenChange: setOpenProp,\r\n      className,\r\n      style,\r\n      children,\r\n      ...props\r\n    },\r\n    ref,\r\n  ) => {\r\n    const isMobile = useIsMobile();\r\n    const [openMobile, setOpenMobile] = React.useState(false);\r\n\r\n    // This is the internal state of the sidebar.\r\n    // We use openProp and setOpenProp for control from outside the component.\r\n    const [_open, _setOpen] = React.useState(defaultOpen);\r\n    const open = openProp ?? _open;\r\n    const setOpen = React.useCallback(\r\n      (value: boolean | ((value: boolean) => boolean)) => {\r\n        const openState = typeof value === 'function' ? value(open) : value;\r\n        if (setOpenProp) {\r\n          setOpenProp(openState);\r\n        } else {\r\n          _setOpen(openState);\r\n        }\r\n\r\n        // This sets the cookie to keep the sidebar state.\r\n        Cookies.set(SIDEBAR_COOKIE_NAME, String(openState), {\r\n          path: '/',\r\n          expires: SIDEBAR_COOKIE_MAX_AGE / (60 * 60 * 24), // Convert seconds to days\r\n        });\r\n      },\r\n      [setOpenProp, open],\r\n    );\r\n\r\n    // Helper to toggle the sidebar.\r\n    const toggleSidebar = React.useCallback(() => {\r\n      return isMobile ? setOpenMobile((open) => !open) : setOpen((open) => !open);\r\n    }, [isMobile, setOpen, setOpenMobile]);\r\n\r\n    // Adds a keyboard shortcut to toggle the sidebar.\r\n    React.useEffect(() => {\r\n      const handleKeyDown = (event: KeyboardEvent) => {\r\n        if (event.key === SIDEBAR_KEYBOARD_SHORTCUT && (event.metaKey || event.ctrlKey)) {\r\n          event.preventDefault();\r\n          toggleSidebar();\r\n        }\r\n      };\r\n\r\n      globalThis.addEventListener('keydown', handleKeyDown);\r\n      return () => globalThis.removeEventListener('keydown', handleKeyDown);\r\n    }, [toggleSidebar]);\r\n\r\n    // We add a state so that we can do data-state=\"expanded\" or \"collapsed\".\r\n    // This makes it easier to style the sidebar with Tailwind classes.\r\n    const state = open ? 'expanded' : 'collapsed';\r\n\r\n    const contextValue = React.useMemo<SidebarContext>(\r\n      () => ({\r\n        state,\r\n        open,\r\n        setOpen,\r\n        isMobile,\r\n        openMobile,\r\n        setOpenMobile,\r\n        toggleSidebar,\r\n      }),\r\n      [state, open, setOpen, isMobile, openMobile, setOpenMobile, toggleSidebar],\r\n    );\r\n\r\n    return (\r\n      <SidebarContext.Provider value={contextValue}>\r\n        <TooltipProvider delayDuration={0}>\r\n          <div\r\n            style={\r\n              {\r\n                '--sidebar-width': SIDEBAR_WIDTH,\r\n                '--sidebar-width-icon': SIDEBAR_WIDTH_ICON,\r\n                ...style,\r\n              } as React.CSSProperties\r\n            }\r\n            className={cn(\r\n              'group/sidebar-wrapper flex min-h-svh w-full has-[[data-variant=inset]]:bg-sidebar',\r\n              className,\r\n            )}\r\n            ref={ref}\r\n            {...props}\r\n          >\r\n            {children}\r\n          </div>\r\n        </TooltipProvider>\r\n      </SidebarContext.Provider>\r\n    );\r\n  },\r\n);\r\nSidebarProvider.displayName = 'SidebarProvider';\r\n\r\ninterface SidebarProps extends React.ComponentProps<'div'> {\r\n  side?: 'left' | 'right';\r\n  variant?: 'sidebar' | 'floating' | 'inset';\r\n  collapsible?: 'offcanvas' | 'icon' | 'none';\r\n}\r\n\r\nconst Sidebar = React.forwardRef<\r\n  HTMLDivElement,\r\n  SidebarProps\r\n>(\r\n  (\r\n    {\r\n      side = 'left',\r\n      variant = 'sidebar',\r\n      collapsible = 'offcanvas',\r\n      className,\r\n      children,\r\n      ...props\r\n    },\r\n    ref,\r\n  ) => {\r\n    const { isMobile, state, openMobile, setOpenMobile } = useSidebar();\r\n\r\n    if (collapsible === 'none') {\r\n      return (\r\n        <div\r\n          className={cn(\r\n            'flex h-full w-[--sidebar-width] flex-col bg-sidebar text-sidebar-foreground',\r\n            className,\r\n          )}\r\n          ref={ref}\r\n          {...props}\r\n        >\r\n          {children}\r\n        </div>\r\n      );\r\n    }\r\n\r\n    if (isMobile) {\r\n      return (\r\n        <Sheet open={openMobile} onOpenChange={setOpenMobile} {...props}>\r\n          <SheetContent\r\n            data-sidebar=\"sidebar\"\r\n            data-mobile=\"true\"\r\n            className=\"w-[--sidebar-width] bg-sidebar p-0 text-sidebar-foreground [&>button]:hidden\"\r\n            style={\r\n              {\r\n                '--sidebar-width': SIDEBAR_WIDTH_MOBILE,\r\n              } as React.CSSProperties\r\n            }\r\n            side={side}\r\n          >\r\n            <div className=\"flex size-full flex-col\">{children}</div>\r\n          </SheetContent>\r\n        </Sheet>\r\n      );\r\n    }\r\n\r\n    return (\r\n      <div\r\n        ref={ref}\r\n        className=\"group peer hidden md:block text-sidebar-foreground\"\r\n        data-state={state}\r\n        data-collapsible={state === 'collapsed' ? collapsible : ''}\r\n        data-variant={variant}\r\n        data-side={side}\r\n      >\r\n        {/* This is what handles the sidebar gap on desktop */}\r\n        <div\r\n          className={cn(\r\n            'duration-200 relative h-svh w-[--sidebar-width] bg-transparent transition-[width] ease-linear',\r\n            'group-data-[collapsible=offcanvas]:w-0',\r\n            'group-data-[side=right]:rotate-180',\r\n            variant === 'floating' || variant === 'inset'\r\n              ? 'group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)_+_theme(spacing.4))]'\r\n              : 'group-data-[collapsible=icon]:w-[--sidebar-width-icon]',\r\n          )}\r\n        />\r\n        <div\r\n          className={cn(\r\n            'duration-200 fixed inset-y-0 z-10 hidden h-svh w-[--sidebar-width] transition-[left,right,width] ease-linear md:flex',\r\n            side === 'left'\r\n              ? 'left-0 group-data-[collapsible=offcanvas]:left-[calc(var(--sidebar-width)*-1)]'\r\n              : 'right-0 group-data-[collapsible=offcanvas]:right-[calc(var(--sidebar-width)*-1)]',\r\n            // Adjust the padding for floating and inset variants.\r\n            variant === 'floating' || variant === 'inset'\r\n              ? 'p-2 group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)_+_theme(spacing.4)_+2px)]'\r\n              : 'group-data-[collapsible=icon]:w-[--sidebar-width-icon] group-data-[side=left]:border-r group-data-[side=right]:border-l',\r\n            className,\r\n          )}\r\n          {...props}\r\n        >\r\n          <div\r\n            data-sidebar=\"sidebar\"\r\n            className=\"flex size-full flex-col bg-sidebar group-data-[variant=floating]:rounded-lg group-data-[variant=floating]:border group-data-[variant=floating]:border-sidebar-border group-data-[variant=floating]:shadow\"\r\n          >\r\n            {children}\r\n          </div>\r\n        </div>\r\n      </div>\r\n    );\r\n  },\r\n);\r\nSidebar.displayName = 'Sidebar';\r\n\r\nconst SidebarTrigger = React.forwardRef<HTMLButtonElement, React.ComponentProps<typeof Button>>(\r\n  ({ className, onClick, ...props }, ref) => {\r\n    const { toggleSidebar } = useSidebar();\r\n\r\n    return (\r\n      <Button\r\n        ref={ref}\r\n        data-sidebar=\"trigger\"\r\n                variant=\"ghost\"\r\n        size=\"icon\"\r\n        className={cn('h-7 w-7', className)}\r\n        onClick={(event) => {\r\n          onClick?.(event);\r\n          toggleSidebar();\r\n        }}\r\n        {...props}\r\n      >\r\n        <PanelLeft />\r\n        <span className=\"sr-only\">Toggle Sidebar</span>\r\n      </Button>\r\n    );\r\n  },\r\n);\r\nSidebarTrigger.displayName = 'SidebarTrigger';\r\n\r\nconst SidebarRail = React.forwardRef<HTMLButtonElement, React.ComponentProps<'button'>>(\r\n  ({ className, ...props }, ref) => {\r\n    const { toggleSidebar } = useSidebar();\r\n\r\n    return (\r\n      <button\r\n        ref={ref}\r\n        data-sidebar=\"rail\"\r\n        aria-label=\"Toggle Sidebar\"\r\n        tabIndex={-1}\r\n        onClick={toggleSidebar}\r\n        title=\"Toggle Sidebar\"\r\n        className={cn(\r\n          'absolute inset-y-0 z-20 hidden w-4 -translate-x-1/2 transition-all ease-linear after:absolute after:inset-y-0 after:left-1/2 after:w-[2px] hover:after:bg-sidebar-border group-data-[side=left]:-right-4 group-data-[side=right]:left-0 sm:flex',\r\n          '[[data-side=left]_&]:cursor-w-resize [[data-side=right]_&]:cursor-e-resize',\r\n          '[[data-side=left][data-state=collapsed]_&]:cursor-e-resize [[data-side=right][data-state=collapsed]_&]:cursor-w-resize',\r\n          'group-data-[collapsible=offcanvas]:translate-x-0 group-data-[collapsible=offcanvas]:after:left-full group-data-[collapsible=offcanvas]:hover:bg-sidebar',\r\n          '[[data-side=left][data-collapsible=offcanvas]_&]:-right-2',\r\n          '[[data-side=right][data-collapsible=offcanvas]_&]:-left-2',\r\n          className,\r\n        )}\r\n        {...props}\r\n      />\r\n    );\r\n  },\r\n);\r\nSidebarRail.displayName = 'SidebarRail';\r\n\r\nconst SidebarInset = React.forwardRef<HTMLDivElement, React.ComponentProps<'main'>>(\r\n  ({ className, ...props }, ref) => {\r\n    return (\r\n      <main\r\n        ref={ref}\r\n        className={cn(\r\n          'relative flex min-h-svh flex-1 flex-col bg-background',\r\n          'peer-data-[variant=inset]:min-h-[calc(100svh-theme(spacing.4))] md:peer-data-[variant=inset]:m-2 md:peer-data-[state=collapsed]:peer-data-[variant=inset]:ml-2 md:peer-data-[variant=inset]:ml-0 md:peer-data-[variant=inset]:rounded-xl md:peer-data-[variant=inset]:shadow',\r\n          className,\r\n        )}\r\n        {...props}\r\n      />\r\n    );\r\n  },\r\n);\r\nSidebarInset.displayName = 'SidebarInset';\r\n\r\nconst SidebarInput = React.forwardRef<HTMLInputElement, React.ComponentProps<typeof Input>>(\r\n  ({ className, ...props }, ref) => {\r\n    return (\r\n      <Input\r\n        ref={ref}\r\n        data-sidebar=\"input\"\r\n        className={cn(\r\n          'h-8 w-full bg-background shadow-none focus-visible:ring-2 focus-visible:ring-sidebar-ring',\r\n          className,\r\n        )}\r\n        {...props}\r\n      />\r\n    );\r\n  },\r\n);\r\nSidebarInput.displayName = 'SidebarInput';\r\n\r\nconst SidebarHeader = React.forwardRef<HTMLDivElement, React.ComponentProps<'div'>>(\r\n  ({ className, ...props }, ref) => {\r\n    return (\r\n      <div\r\n        ref={ref}\r\n        data-sidebar=\"header\"\r\n        className={cn('flex flex-col gap-2 p-2', className)}\r\n        {...props}\r\n      />\r\n    );\r\n  },\r\n);\r\nSidebarHeader.displayName = 'SidebarHeader';\r\n\r\nconst SidebarFooter = React.forwardRef<HTMLDivElement, React.ComponentProps<'div'>>(\r\n  ({ className, ...props }, ref) => {\r\n    return (\r\n      <div\r\n        ref={ref}\r\n        data-sidebar=\"footer\"\r\n        className={cn('flex flex-col gap-2 p-2', className)}\r\n        {...props}\r\n      />\r\n    );\r\n  },\r\n);\r\nSidebarFooter.displayName = 'SidebarFooter';\r\n\r\nconst SidebarSeparator = React.forwardRef<HTMLDivElement, React.ComponentProps<typeof Separator>>(\r\n  ({ className, ...props }, ref) => (\r\n    <Separator\r\n      ref={ref}\r\n      data-sidebar=\"separator\"\r\n      className={cn('mx-2 w-auto bg-sidebar-border', className)}\r\n      {...props}\r\n    />\r\n  ),\r\n);\r\nSidebarSeparator.displayName = 'SidebarSeparator';\r\n\r\nconst SidebarContent = React.forwardRef<HTMLDivElement, React.ComponentProps<'div'>>(\r\n  ({ className, ...props }, ref) => {\r\n    return (\r\n      <div\r\n        ref={ref}\r\n        data-sidebar=\"content\"\r\n        className={cn(\r\n          'flex min-h-0 flex-1 flex-col gap-2 overflow-auto group-data-[collapsible=icon]:overflow-hidden',\r\n          className,\r\n        )}\r\n        {...props}\r\n      />\r\n    );\r\n  },\r\n);\r\nSidebarContent.displayName = 'SidebarContent';\r\n\r\nconst SidebarGroup = React.forwardRef<HTMLDivElement, React.ComponentProps<'div'>>(\r\n  ({ className, ...props }, ref) => {\r\n    return (\r\n      <div\r\n        ref={ref}\r\n        data-sidebar=\"group\"\r\n        className={cn('relative flex w-full min-w-0 flex-col p-2', className)}\r\n        {...props}\r\n      />\r\n    );\r\n  },\r\n);\r\nSidebarGroup.displayName = 'SidebarGroup';\r\n\r\nconst SidebarGroupLabel = React.forwardRef<\r\n  HTMLDivElement,\r\n  React.ComponentProps<'div'> & { asChild?: boolean }\r\n>(({ className, asChild = false, ...props }, ref) => {\r\n  const Comp = asChild ? Slot : 'div';\r\n\r\n  return (\r\n    <Comp\r\n      ref={ref}\r\n      data-sidebar=\"group-label\"\r\n      className={cn(\r\n        'duration-200 flex h-8 shrink-0 items-center rounded-md px-2 text-xs font-medium text-sidebar-foreground/70 outline-none ring-sidebar-ring transition-[margin,opa] ease-linear focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0',\r\n        'group-data-[collapsible=icon]:-mt-8 group-data-[collapsible=icon]:opacity-0',\r\n        className,\r\n      )}\r\n      {...props}\r\n    />\r\n  );\r\n});\r\nSidebarGroupLabel.displayName = 'SidebarGroupLabel';\r\n\r\nconst SidebarGroupAction = React.forwardRef<\r\n  HTMLButtonElement,\r\n  React.ComponentProps<'button'> & { asChild?: boolean }\r\n>(({ className, asChild = false, ...props }, ref) => {\r\n  const Comp = asChild ? Slot : 'button';\r\n\r\n  return (\r\n    <Comp\r\n      ref={ref}\r\n      data-sidebar=\"group-action\"\r\n      className={cn(\r\n        'absolute right-3 top-3.5 flex aspect-square w-5 items-center justify-center rounded-md p-0 text-sidebar-foreground outline-none ring-sidebar-ring transition-transform hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0',\r\n        // Increases the hit area of the button on mobile.\r\n        'after:absolute after:-inset-2 after:md:hidden',\r\n        'group-data-[collapsible=icon]:hidden',\r\n        className,\r\n      )}\r\n      {...props}\r\n    />\r\n  );\r\n});\r\nSidebarGroupAction.displayName = 'SidebarGroupAction';\r\n\r\nconst SidebarGroupContent = React.forwardRef<HTMLDivElement, React.ComponentProps<'div'>>(\r\n  ({ className, ...props }, ref) => (\r\n    <div\r\n      ref={ref}\r\n      data-sidebar=\"group-content\"\r\n      className={cn('w-full text-sm', className)}\r\n      {...props}\r\n    />\r\n  ),\r\n);\r\nSidebarGroupContent.displayName = 'SidebarGroupContent';\r\n\r\nconst SidebarMenu = React.forwardRef<HTMLUListElement, React.ComponentProps<'ul'>>(\r\n  ({ className, ...props }, ref) => (\r\n    <ul\r\n      ref={ref}\r\n      data-sidebar=\"menu\"\r\n      className={cn('flex w-full min-w-0 flex-col gap-1', className)}\r\n      {...props}\r\n    />\r\n  ),\r\n);\r\nSidebarMenu.displayName = 'SidebarMenu';\r\n\r\nconst SidebarMenuItem = React.forwardRef<HTMLLIElement, React.ComponentProps<'li'>>(\r\n  ({ className, ...props }, ref) => (\r\n    <li\r\n      ref={ref}\r\n      data-sidebar=\"menu-item\"\r\n      className={cn('group/menu-item relative', className)}\r\n      {...props}\r\n    />\r\n  ),\r\n);\r\nSidebarMenuItem.displayName = 'SidebarMenuItem';\r\n\r\nconst sidebarMenuButtonVariants = tv({\r\n  base: 'peer/menu-button flex w-full items-center gap-2 overflow-hidden rounded-md p-2 text-left text-sm outline-none ring-sidebar-ring transition-[width,height,padding] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 group-has-[[data-sidebar=menu-action]]/menu-item:pr-8 aria-disabled:pointer-events-none aria-disabled:opacity-50 data-[active=true]:bg-sidebar-accent data-[active=true]:font-medium data-[active=true]:text-sidebar-accent-foreground data-[state=open]:hover:bg-sidebar-accent data-[state=open]:hover:text-sidebar-accent-foreground group-data-[collapsible=icon]:!size-8 group-data-[collapsible=icon]:!p-2 [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0',\r\n  variants: {\r\n    variant: {\r\n      default: 'hover:bg-sidebar-accent hover:text-sidebar-accent-foreground',\r\n      outline:\r\n        'bg-background shadow-[0_0_0_1px_hsl(var(--sidebar-border))] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground hover:shadow-[0_0_0_1px_hsl(var(--sidebar-accent))]',\r\n    },\r\n    size: {\r\n      default: 'h-8 text-sm',\r\n      sm: 'h-7 text-xs',\r\n      lg: 'h-12 text-sm group-data-[collapsible=icon]:!p-0',\r\n    },\r\n  },\r\n  defaultVariants: {\r\n    variant: 'default',\r\n    size: 'default',\r\n  },\r\n});\r\n\r\ntype SidebarMenuButtonVariant = 'default' | 'outline';\r\ntype SidebarMenuButtonSize = 'default' | 'sm' | 'lg';\r\n\r\nconst SidebarMenuButton = React.forwardRef<\r\n  HTMLButtonElement,\r\n  React.ComponentProps<'button'> & {\r\n    asChild?: boolean;\r\n    isActive?: boolean;\r\n    tooltip?: string | React.ComponentProps<typeof TooltipContent>;\r\n    variant?: SidebarMenuButtonVariant;\r\n    size?: SidebarMenuButtonSize;\r\n  }\r\n>(\r\n  (\r\n    {\r\n      asChild = false,\r\n      isActive = false,\r\n      variant = 'default',\r\n      size = 'default',\r\n      tooltip,\r\n      className,\r\n      ...props\r\n    },\r\n    ref,\r\n  ) => {\r\n    const Comp = asChild ? Slot : 'button';\r\n    const { isMobile, state } = useSidebar();\r\n\r\n    const button = (\r\n      <Comp\r\n        ref={ref}\r\n        data-sidebar=\"menu-button\"\r\n        data-size={size}\r\n        data-active={isActive}\r\n        className={cn(sidebarMenuButtonVariants({ variant, size }), className)}\r\n        {...props}\r\n      />\r\n    );\r\n\r\n    if (tooltip == undefined) {\r\n      return button;\r\n    }\r\n\r\n    if (typeof tooltip === 'string') {\r\n      tooltip = {\r\n        children: tooltip,\r\n      };\r\n    }\r\n\r\n    return (\r\n      <Tooltip>\r\n        <TooltipTrigger asChild>{button}</TooltipTrigger>\r\n        <TooltipContent\r\n          side=\"right\"\r\n          align=\"center\"\r\n          hidden={state !== 'collapsed' || isMobile}\r\n          {...tooltip}\r\n        />\r\n      </Tooltip>\r\n    );\r\n  },\r\n);\r\nSidebarMenuButton.displayName = 'SidebarMenuButton';\r\n\r\nconst SidebarMenuAction = React.forwardRef<\r\n  HTMLButtonElement,\r\n  React.ComponentProps<'button'> & {\r\n    asChild?: boolean;\r\n    showOnHover?: boolean;\r\n  }\r\n>(({ className, asChild = false, showOnHover = false, ...props }, ref) => {\r\n  const Comp = asChild ? Slot : 'button';\r\n\r\n  return (\r\n    <Comp\r\n      ref={ref}\r\n      data-sidebar=\"menu-action\"\r\n      className={cn(\r\n        'absolute right-1 top-1.5 flex aspect-square w-5 items-center justify-center rounded-md p-0 text-sidebar-foreground outline-none ring-sidebar-ring transition-transform hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0',\r\n        // Increases the hit area of the button on mobile.\r\n        'after:absolute after:-inset-2 after:md:hidden',\r\n        'peer-data-[size=sm]/menu-button:top-1',\r\n        'peer-data-[size=default]/menu-button:top-1.5',\r\n        'peer-data-[size=lg]/menu-button:top-2.5',\r\n        'group-data-[collapsible=icon]:hidden',\r\n        showOnHover &&\r\n          'group-focus-within/menu-item:opacity-100 group-hover/menu-item:opacity-100 data-[state=open]:opacity-100 peer-data-[active=true]/menu-button:text-sidebar-accent-foreground md:opacity-0',\r\n        className,\r\n      )}\r\n      {...props}\r\n    />\r\n  );\r\n});\r\nSidebarMenuAction.displayName = 'SidebarMenuAction';\r\n\r\nconst SidebarMenuBadge = React.forwardRef<HTMLDivElement, React.ComponentProps<'div'>>(\r\n  ({ className, ...props }, ref) => (\r\n    <div\r\n      ref={ref}\r\n      data-sidebar=\"menu-badge\"\r\n      className={cn(\r\n        'absolute right-1 flex h-5 min-w-5 items-center justify-center rounded-md px-1 text-xs font-medium tabular-nums text-sidebar-foreground select-none pointer-events-none',\r\n        'peer-hover/menu-button:text-sidebar-accent-foreground peer-data-[active=true]/menu-button:text-sidebar-accent-foreground',\r\n        'peer-data-[size=sm]/menu-button:top-1',\r\n        'peer-data-[size=default]/menu-button:top-1.5',\r\n        'peer-data-[size=lg]/menu-button:top-2.5',\r\n        'group-data-[collapsible=icon]:hidden',\r\n        className,\r\n      )}\r\n      {...props}\r\n    />\r\n  ),\r\n);\r\nSidebarMenuBadge.displayName = 'SidebarMenuBadge';\r\n\r\nconst SidebarMenuSkeleton = React.forwardRef<\r\n  HTMLDivElement,\r\n  React.ComponentProps<'div'> & {\r\n    showIcon?: boolean;\r\n  }\r\n>(({ className, showIcon = false, ...props }, ref) => {\r\n  // Predictable width between 50 to 90%.\r\n\r\n  const width = React.useMemo(() => {\r\n    // Use a more predictable approach for skeleton width to avoid pseudorandom warning\r\n    const widths = ['50%', '60%', '70%', '80%', '90%'];\r\n    const index = Math.floor(Date.now() / 1000) % widths.length;\r\n    return widths[index];\r\n  }, []);\r\n\r\n  return (\r\n    <div\r\n      ref={ref}\r\n      data-sidebar=\"menu-skeleton\"\r\n      className={cn('rounded-md h-8 flex gap-2 px-2 items-center', className)}\r\n      {...props}\r\n    >\r\n      {showIcon && <Skeleton className=\"size-4 rounded-md\" data-sidebar=\"menu-skeleton-icon\" />}\r\n      <Skeleton\r\n        className=\"h-4 flex-1 max-w-[--skeleton-width]\"\r\n        data-sidebar=\"menu-skeleton-text\"\r\n        style={\r\n          {\r\n            '--skeleton-width': width,\r\n          } as React.CSSProperties\r\n        }\r\n      />\r\n    </div>\r\n  );\r\n});\r\nSidebarMenuSkeleton.displayName = 'SidebarMenuSkeleton';\r\n\r\nconst SidebarMenuSub = React.forwardRef<HTMLUListElement, React.ComponentProps<'ul'>>(\r\n  ({ className, ...props }, ref) => (\r\n    <ul\r\n      ref={ref}\r\n      data-sidebar=\"menu-sub\"\r\n      className={cn(\r\n        'mx-3.5 flex min-w-0 translate-x-px flex-col gap-1 border-l border-sidebar-border px-2.5 py-0.5',\r\n        'group-data-[collapsible=icon]:hidden',\r\n        className,\r\n      )}\r\n      {...props}\r\n    />\r\n  ),\r\n);\r\nSidebarMenuSub.displayName = 'SidebarMenuSub';\r\n\r\nconst SidebarMenuSubItem = React.forwardRef<HTMLLIElement, React.ComponentProps<'li'>>(\r\n  ({ ...props }, ref) => <li ref={ref} {...props} />,\r\n);\r\nSidebarMenuSubItem.displayName = 'SidebarMenuSubItem';\r\n\r\nconst SidebarMenuSubButton = React.forwardRef<\r\n  HTMLAnchorElement,\r\n  React.ComponentProps<'a'> & {\r\n    asChild?: boolean;\r\n    size?: 'sm' | 'md';\r\n    isActive?: boolean;\r\n  }\r\n>(({ asChild = false, size = 'md', isActive, className, ...props }, ref) => {\r\n  const Comp = asChild ? Slot : 'a';\r\n\r\n  return (\r\n    <Comp\r\n      ref={ref}\r\n      data-sidebar=\"menu-sub-button\"\r\n      data-size={size}\r\n      data-active={isActive}\r\n      className={cn(\r\n        'flex h-7 min-w-0 -translate-x-px items-center gap-2 overflow-hidden rounded-md px-2 text-sidebar-foreground outline-none ring-sidebar-ring hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 aria-disabled:pointer-events-none aria-disabled:opacity-50 [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0 [&>svg]:text-sidebar-accent-foreground',\r\n        'data-[active=true]:bg-sidebar-accent data-[active=true]:text-sidebar-accent-foreground',\r\n        size === 'sm' && 'text-xs',\r\n        size === 'md' && 'text-sm',\r\n        'group-data-[collapsible=icon]:hidden',\r\n        className,\r\n      )}\r\n      {...props}\r\n    />\r\n  );\r\n});\r\nSidebarMenuSubButton.displayName = 'SidebarMenuSubButton';\r\n\r\nexport {\r\n  Sidebar,\r\n  SidebarContent,\r\n  SidebarFooter,\r\n  SidebarGroup,\r\n  SidebarGroupAction,\r\n  SidebarGroupContent,\r\n  SidebarGroupLabel,\r\n  SidebarHeader,\r\n  SidebarInput,\r\n  SidebarInset,\r\n  SidebarMenu,\r\n  SidebarMenuAction,\r\n  SidebarMenuBadge,\r\n  SidebarMenuButton,\r\n  SidebarMenuItem,\r\n  SidebarMenuSkeleton,\r\n  SidebarMenuSub,\r\n  SidebarMenuSubButton,\r\n  SidebarMenuSubItem,\r\n  SidebarProvider,\r\n  SidebarRail,\r\n  SidebarSeparator,\r\n  SidebarTrigger,\r\n  useSidebar,\r\n};\r\n","usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\ui\\skeleton.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\ui\\slider.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\ui\\sonner.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\ui\\switch.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\ui\\table.tsx","messages":[],"suppressedMessages":[{"ruleId":"sonarjs/table-header","severity":2,"message":"Add a valid header row or column to this \"<table>\".","line":9,"column":7,"nodeType":"JSXElement","endLine":9,"endColumn":96,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\ui\\tabs.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\ui\\textarea.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\ui\\toast.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\ui\\toaster.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\ui\\toggle.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\ui\\tooltip.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\ui\\variants.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\debugUrlFiltering.js","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error, info.","line":55,"column":5,"nodeType":"MemberExpression","messageId":"limited","endLine":55,"endColumn":16,"suggestions":[{"fix":{"range":[1429,1464],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error, info.","line":60,"column":13,"nodeType":"MemberExpression","messageId":"limited","endLine":60,"endColumn":24,"suggestions":[{"fix":{"range":[1609,1656],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error, info.","line":68,"column":13,"nodeType":"MemberExpression","messageId":"limited","endLine":68,"endColumn":24,"suggestions":[{"fix":{"range":[1871,1928],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error, info.","line":73,"column":5,"nodeType":"MemberExpression","messageId":"limited","endLine":73,"endColumn":16,"suggestions":[{"fix":{"range":[1984,2033],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error, info.","line":91,"column":1,"nodeType":"MemberExpression","messageId":"limited","endLine":91,"endColumn":12,"suggestions":[{"fix":{"range":[2602,2649],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error, info.","line":96,"column":5,"nodeType":"MemberExpression","messageId":"limited","endLine":96,"endColumn":16,"suggestions":[{"fix":{"range":[2814,2851],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"#!/usr/bin/env node\r\n\r\n/**\r\n * Debug URL Filtering\r\n * \r\n * This script debugs the URL filtering logic to see why some URLs aren't being filtered.\r\n */\r\n\r\n// Test the core filtering logic - matching the actual discovery engine implementation\r\nfunction isObviouslyNonFoodTruckUrl(url) {\r\n    const nonFoodTruckPatterns = [\r\n        /\\/events?\\//i,\r\n        /\\/festivals?\\//i,\r\n        /\\/calendar/i,\r\n        /\\/blog/i,\r\n        /\\/news/i,\r\n        /\\/articles?\\//i,\r\n        /\\/government/i,\r\n        /\\/city\\.gov/i,\r\n        /\\/municipal/i,\r\n        /\\/reddit\\.com/i,\r\n        /\\/facebook\\.com/i,\r\n        /\\/instagram\\.com/i,\r\n        /\\/twitter\\.com/i,\r\n        /\\/linkedin\\.com/i,\r\n        /\\/youtube\\.com/i,\r\n        /\\/yelp\\.com/i,\r\n        /\\/google\\.com\\/maps/i,\r\n        /\\/foursquare\\.com/i,\r\n        /\\/tripadvisor\\.com/i,\r\n        /\\/zomato\\.com/i,\r\n        /\\/eventbrite\\.com/i,\r\n        /\\/meetup\\.com/i,\r\n    ];\r\n    \r\n    // Also check for blacklist keywords like the discovery engine does\r\n    const blacklistKeywords = [\r\n        'facebook.com',\r\n        'instagram.com',\r\n        'twitter.com',\r\n        'linkedin.com',\r\n        'youtube.com',\r\n        'yelp.com',\r\n        'google.com',\r\n        'maps.google.com',\r\n        'foursquare.com',\r\n        'tripadvisor.com',\r\n        'zomato.com',\r\n        'eventbrite.com',\r\n        'meetup.com',\r\n    ];\r\n    \r\n    const urlLower = url.toLowerCase();\r\n    \r\n    console.log(`Testing URL: ${url}`);\r\n    \r\n    // Check regex patterns first\r\n    for (const pattern of nonFoodTruckPatterns) {\r\n        if (pattern.test(urlLower)) {\r\n            console.log(`  ✅ Matched pattern: ${pattern}`);\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // Check blacklist keywords like discovery engine does\r\n    for (const keyword of blacklistKeywords) {\r\n        if (urlLower.includes(keyword)) {\r\n            console.log(`  ✅ Matched blacklist keyword: ${keyword}`);\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    console.log(`  ❌ No pattern or keyword matched`);\r\n    return false;\r\n}\r\n\r\nconst testUrls = [\r\n    'https://www.facebook.com/foodtruck',\r\n    'https://www.instagram.com/foodtruck',\r\n    'https://www.eventbrite.com/food-truck-festival',\r\n    'https://www.cityofcharleston.org/calendar',\r\n    'https://www.reddit.com/r/foodtrucks',\r\n    'https://www.bestfoodtruck.com',\r\n    'https://charlestonfoodtrucks.com',\r\n    'https://www.roaminghunger.com/charleston-food-trucks',\r\n    'https://www.charleston.gov/news',\r\n    'https://www.charleston.gov/events/calendar',\r\n    'https://www.meetup.com/charleston-foodies',\r\n];\r\n\r\nconsole.log('🔍 Debugging URL Filtering...\\n');\r\n\r\nfor (const url of testUrls) {\r\n    const shouldSkip = isObviouslyNonFoodTruckUrl(url);\r\n    const result = shouldSkip ? '⏭️  WILL SKIP' : '✅ WILL PROCESS';\r\n    console.log(`   ${result} ${url}\\n`);\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\get-scraping-jobs.js","messages":[{"ruleId":"unicorn/filename-case","severity":2,"message":"Filename is not in camel case or pascal case. Rename it to `getScrapingJobs.js` or `GetScrapingJobs.js`.","line":1,"column":1,"nodeType":null,"messageId":"filename-case"},{"ruleId":"unicorn/no-process-exit","severity":2,"message":"Only use `process.exit()` in CLI apps. Throw an error instead.","line":14,"column":3,"nodeType":"CallExpression","messageId":"no-process-exit","endLine":14,"endColumn":18},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error, info.","line":40,"column":3,"nodeType":"MemberExpression","messageId":"limited","endLine":40,"endColumn":14,"suggestions":[{"fix":{"range":[861,1147],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"unicorn/no-process-exit","severity":2,"message":"Only use `process.exit()` in CLI apps. Throw an error instead.","line":50,"column":3,"nodeType":"CallExpression","messageId":"no-process-exit","endLine":50,"endColumn":18},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error, info.","line":77,"column":5,"nodeType":"MemberExpression","messageId":"limited","endLine":77,"endColumn":16,"suggestions":[{"fix":{"range":[1762,1795],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error, info.","line":78,"column":5,"nodeType":"MemberExpression","messageId":"limited","endLine":78,"endColumn":16,"suggestions":[{"fix":{"range":[1800,1843],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"unicorn/no-null","severity":1,"message":"Use `undefined` instead of `null`.","line":78,"column":38,"nodeType":"Literal","messageId":"error","endLine":78,"endColumn":42,"suggestions":[{"messageId":"replace","fix":{"range":[1833,1837],"text":"undefined"},"data":{},"desc":"Replace `null` with `undefined`."}]},{"ruleId":"unicorn/no-process-exit","severity":2,"message":"Only use `process.exit()` in CLI apps. Throw an error instead.","line":81,"column":5,"nodeType":"CallExpression","messageId":"no-process-exit","endLine":81,"endColumn":20},{"ruleId":"unicorn/prefer-top-level-await","severity":2,"message":"Prefer top-level await over an async function `getScrapingJobs` call.","line":85,"column":1,"nodeType":"CallExpression","messageId":"identifier","endLine":85,"endColumn":18,"suggestions":[{"messageId":"add-await","fix":{"range":[1962,1962],"text":"await "},"data":{"name":"getScrapingJobs"},"desc":"Insert `await`."}]}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\nimport { createClient } from '@supabase/supabase-js';\nimport dotenv from 'dotenv';\nimport { parseArgs } from 'node:util';\n\n// Load environment variables\ndotenv.config({ path: '.env.local' });\n\nconst supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;\nconst serviceRoleKey = process.env.SUPABASE_SERVICE_ROLE_KEY;\n\nif (!supabaseUrl || !serviceRoleKey) {\n  console.error('❌ Missing Supabase credentials! Need both URL and SERVICE_ROLE_KEY');\n  process.exit(1);\n}\n\nconst supabase = createClient(supabaseUrl, serviceRoleKey);\n\n// Parse command line arguments\nconst options = {\n  status: {\n    type: 'string',\n    short: 's'\n  },\n  limit: {\n    type: 'string',\n    short: 'l',\n    default: '100'\n  },\n  help: {\n    type: 'boolean',\n    short: 'h',\n    default: false\n  }\n};\n\nconst { values } = parseArgs({ options, allowPositionals: false });\n\nif (values.help) {\n  console.log(`\nGet Scraping Jobs\n\nUsage: node get-scraping-jobs.js [options]\n\nOptions:\n  -s, --status <status>  Filter by job status (pending, running, completed, failed)\n  -l, --limit <number>   Limit number of results (default: 100)\n  -h, --help            Show this help message\n  `);\n  process.exit(0);\n}\n\nasync function getScrapingJobs() {\n  try {\n    let query = supabase\n      .from('scraping_jobs')\n      .select('id, status, target_url, created_at, completed_at');\n    \n    // Apply status filter if provided\n    if (values.status) {\n      query = query.eq('status', values.status);\n    }\n    \n    // Apply limit\n    const limit = Number.parseInt(values.limit || '100', 10);\n    query = query.limit(limit);\n    \n    // Order by creation date\n    query = query.order('created_at', { ascending: false });\n\n    const { data, error } = await query;\n\n    if (error) {\n      throw error;\n    }\n\n    console.log('📊 Scraping Jobs:');\n    console.log(JSON.stringify(data, null, 2));\n  } catch (error) {\n    console.error('💥 Error fetching scraping jobs:', error.message);\n    process.exit(1);\n  }\n}\n\ngetScrapingJobs();\n","usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\get-truck-count.js","messages":[{"ruleId":"unicorn/filename-case","severity":2,"message":"Filename is not in camel case or pascal case. Rename it to `getTruckCount.js` or `GetTruckCount.js`.","line":1,"column":1,"nodeType":null,"messageId":"filename-case"},{"ruleId":"unicorn/no-process-exit","severity":2,"message":"Only use `process.exit()` in CLI apps. Throw an error instead.","line":13,"column":3,"nodeType":"CallExpression","messageId":"no-process-exit","endLine":13,"endColumn":18},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error, info.","line":28,"column":5,"nodeType":"MemberExpression","messageId":"limited","endLine":28,"endColumn":16,"suggestions":[{"fix":{"range":[697,743],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"unicorn/no-process-exit","severity":2,"message":"Only use `process.exit()` in CLI apps. Throw an error instead.","line":31,"column":5,"nodeType":"CallExpression","messageId":"no-process-exit","endLine":31,"endColumn":20},{"ruleId":"unicorn/prefer-top-level-await","severity":2,"message":"Prefer top-level await over an async function `getTruckCount` call.","line":35,"column":1,"nodeType":"CallExpression","messageId":"identifier","endLine":35,"endColumn":16,"suggestions":[{"messageId":"add-await","fix":{"range":[865,865],"text":"await "},"data":{"name":"getTruckCount"},"desc":"Insert `await`."}]}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\nimport { createClient } from '@supabase/supabase-js';\nimport dotenv from 'dotenv';\n\n// Load environment variables\ndotenv.config({ path: '.env.local' });\n\nconst supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;\nconst serviceRoleKey = process.env.SUPABASE_SERVICE_ROLE_KEY;\n\nif (!supabaseUrl || !serviceRoleKey) {\n  console.error('❌ Missing Supabase credentials! Need both URL and SERVICE_ROLE_KEY');\n  process.exit(1);\n}\n\nconst supabase = createClient(supabaseUrl, serviceRoleKey);\n\nasync function getTruckCount() {\n  try {\n    const { count, error } = await supabase\n      .from('food_trucks')\n      .select('*', { count: 'exact', head: true });\n\n    if (error) {\n      throw error;\n    }\n\n    console.log(`🚚 Found ${count} food trucks.`);\n  } catch (error) {\n    console.error('💥 Error fetching food truck count:', error.message);\n    process.exit(1);\n  }\n}\n\ngetTruckCount();\n","usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\hooks\\UseMobile.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\hooks\\UseToast.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\hooks\\realtime\\connectionManagementHelpers.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\hooks\\realtime\\createEventSourceConnection.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\hooks\\realtime\\setupEventSourceListeners.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\hooks\\realtime\\useAutoConnect.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\hooks\\realtime\\useConnectionManagement.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\hooks\\realtime\\useConnectionState.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\hooks\\realtime\\useEventHandlers.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\hooks\\useAdminAuth.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\hooks\\useAuthHandlers.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\hooks\\useDataCleanup.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\hooks\\useFoodTruckDetails.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\hooks\\useFoodTruckFinder.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\hooks\\useRealtimeAdminEvents.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\hooks\\useRealtimeAdminEvents.types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\hooks\\useRealtimeAdminEventsHelpers.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\hooks\\useSearchFiltersLogic.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\hooks\\useSidebarKeyboardShortcut.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\hooks\\useSystemAlerts.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\hooks\\useTruckCard.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\ScraperEngine.js","messages":[{"ruleId":null,"nodeType":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token ;","line":5,"column":15}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { firecrawl } from './firecrawl.js'; // Import the firecrawl singleton\r\nimport * as crypto from 'node:crypto'; // Node.js crypto for secure randomness\r\n// Core scraping engine with anti-detection measures\r\nexport class ScraperEngine {\r\n    userAgents;\r\n    requestDelay;\r\n    maxRetries;\r\n    constructor() {\r\n        this.userAgents = [\r\n            'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',\r\n            'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',\r\n            'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',\r\n        ];\r\n        this.requestDelay = 2000;\r\n        this.maxRetries = 3;\r\n    }\r\n    async performFallbackScrape(url) {\r\n        try {\r\n            const response = await fetch(url, { headers: { 'User-Agent': this.getRandomUserAgent() } });\r\n            if (!response.ok) {\r\n                throw new Error(`HTTP error ${response.status}: ${response.statusText} during fallback fetch.`);\r\n            }\r\n            const htmlContent = await response.text();\r\n            return {\r\n                success: true,\r\n                data: {\r\n                    html: htmlContent,\r\n                    is_fallback: true,\r\n                },\r\n                timestamp: new Date().toISOString(),\r\n                source: url,\r\n                note: 'Fetched using basic fetch as Firecrawl failed.',\r\n            };\r\n        }\r\n        catch (fallbackError) {\r\n            const errMsg = fallbackError instanceof Error ? fallbackError.message : 'Unknown fallback fetch error';\r\n            console.warn(`Fallback fetch error for ${url}:`, errMsg);\r\n            return {\r\n                success: false,\r\n                error: \"That didn't work, please try again later.\",\r\n                timestamp: new Date().toISOString(),\r\n                source: url,\r\n            };\r\n        }\r\n    }\r\n    async scrapeWebsite(url, _selectors) {\r\n        try {\r\n            const firecrawlResult = await firecrawl.scrapeUrl(url, {\r\n                formats: ['markdown', 'html'],\r\n                onlyMainContent: true,\r\n            });\r\n            if (firecrawlResult.success !== true || firecrawlResult.data == undefined) {\r\n                throw new Error(firecrawlResult.error ?? 'Firecrawl scraping failed to return data.');\r\n            }\r\n            const returnedData = {};\r\n            if (firecrawlResult.data && typeof firecrawlResult.data === 'object') {\r\n                const firecrawlData = firecrawlResult.data;\r\n                if (typeof firecrawlData.markdown === 'string' && firecrawlData.markdown !== '') {\r\n                    returnedData.markdown = firecrawlData.markdown;\r\n                }\r\n                if (typeof firecrawlData.html === 'string' && firecrawlData.html !== '') {\r\n                    returnedData.html = firecrawlData.html;\r\n                }\r\n                if (firecrawlData.metadata != undefined && typeof firecrawlData.metadata === 'object') {\r\n                    returnedData.metadata = firecrawlData.metadata;\r\n                }\r\n            }\r\n            if ((returnedData.markdown == undefined || returnedData.markdown === '') &&\r\n                (returnedData.html == undefined || returnedData.html === '')) {\r\n                throw new Error('Firecrawl returned no markdown or HTML content.');\r\n            }\r\n            return {\r\n                success: true,\r\n                data: returnedData,\r\n                timestamp: new Date().toISOString(),\r\n                source: url,\r\n            };\r\n        }\r\n        catch (error) {\r\n            console.warn(`Scraping error for ${url} using Firecrawl:`, error);\r\n            console.info(`Falling back to basic fetch for ${url}`);\r\n            return await this.performFallbackScrape(url);\r\n        }\r\n    }\r\n    async scrapeSocialMedia(platform, handle) {\r\n        try {\r\n            await this.randomDelay();\r\n            switch (platform) {\r\n                case 'instagram': {\r\n                    return await this.scrapeInstagram(handle);\r\n                }\r\n                case 'facebook': {\r\n                    return await this.scrapeFacebook(handle);\r\n                }\r\n                case 'twitter': {\r\n                    return await this.scrapeTwitter(handle);\r\n                }\r\n                default: {\r\n                    throw new Error(`Unsupported platform: ${platform}`);\r\n                }\r\n            }\r\n        }\r\n        catch (error) {\r\n            console.warn(`Social media scraping error for ${platform}/${handle}:`, error);\r\n            return {\r\n                success: false,\r\n                error: \"That didn't work, please try again later.\",\r\n                timestamp: new Date().toISOString(),\r\n                source: `social_media:${platform}:${handle}`,\r\n            };\r\n        }\r\n    }\r\n    async scrapeInstagram(handle) {\r\n        await this.randomDelay();\r\n        const posts = [\r\n            {\r\n                id: 'post_001',\r\n                caption: 'Fresh tacos available now at Mission St! 🌮 #foodtruck #tacos',\r\n                timestamp: new Date(Date.now() - 3_600_000).toISOString(),\r\n                location: 'Mission St, San Francisco',\r\n                hashtags: ['foodtruck', 'tacos', 'fresh'],\r\n                engagement: { likes: 45, comments: 8 },\r\n            },\r\n        ];\r\n        const profile = {\r\n            followers: 1250,\r\n            following: 340,\r\n            posts_count: 156,\r\n            bio: 'Best tacos in SF 🌮 Follow for daily locations!',\r\n            contact_info: {\r\n                email: 'contact@tacoparadise.com',\r\n                phone: '+1-555-0456',\r\n            },\r\n        };\r\n        const data = { posts, profile };\r\n        return {\r\n            success: true,\r\n            data,\r\n            timestamp: new Date().toISOString(),\r\n            source: `instagram:${handle}`,\r\n        };\r\n    }\r\n    async scrapeFacebook(handle) {\r\n        await this.randomDelay();\r\n        const posts = [\r\n            {\r\n                id: 'fb_post_001',\r\n                content: \"Today we'll be at Union Square from 11 AM to 3 PM! Come try our new BBQ burger!\",\r\n                timestamp: new Date(Date.now() - 7_200_000).toISOString(),\r\n                reactions: { likes: 23, loves: 5, shares: 3 },\r\n                comments: 12,\r\n            },\r\n        ];\r\n        const page_info = {\r\n            likes: 890,\r\n            followers: 1100,\r\n            check_ins: 450,\r\n            about: 'Gourmet food truck serving the Bay Area',\r\n            hours: {\r\n                monday: '11:00-15:00',\r\n                tuesday: '11:00-15:00',\r\n                wednesday: '11:00-15:00',\r\n                thursday: '11:00-15:00',\r\n                friday: '11:00-20:00',\r\n                saturday: '12:00-20:00',\r\n                sunday: '12:00-16:00',\r\n            },\r\n        };\r\n        const data = { posts, page_info };\r\n        return {\r\n            success: true,\r\n            data,\r\n            timestamp: new Date().toISOString(),\r\n            source: `facebook:${handle}`,\r\n        };\r\n    }\r\n    async scrapeTwitter(handle) {\r\n        await this.randomDelay();\r\n        const tweets = [\r\n            {\r\n                id: 'tweet_001',\r\n                text: 'LIVE at Dolores Park! Fresh burritos and quesadillas available now 🌯',\r\n                timestamp: new Date(Date.now() - 1_800_000).toISOString(),\r\n                retweets: 8,\r\n                likes: 34,\r\n                replies: 5,\r\n                location: 'Dolores Park, San Francisco',\r\n            },\r\n        ];\r\n        const profile = {\r\n            followers: 2340,\r\n            following: 567,\r\n            tweets_count: 1890,\r\n            bio: '🚚 SF Food Truck | Fresh Mexican Food | Follow for locations',\r\n            location: 'San Francisco, CA',\r\n            website: 'https://tacoparadise.com',\r\n        };\r\n        const data = { tweets, profile };\r\n        return {\r\n            success: true,\r\n            data,\r\n            timestamp: new Date().toISOString(),\r\n            source: `twitter:${handle}`,\r\n        };\r\n    }\r\n    getRandomUserAgent() {\r\n        // Use Node.js crypto for stronger randomness if available, fallback to Math.random otherwise.\r\n        let idx;\r\n        if (globalThis.window?.crypto?.getRandomValues != undefined) {\r\n            const array = globalThis.window.crypto.getRandomValues(new Uint32Array(1));\r\n            idx = array[0] % this.userAgents.length;\r\n        }\r\n        else if (typeof crypto.randomInt === 'function') {\r\n            idx = crypto.randomInt(0, this.userAgents.length);\r\n        }\r\n        else {\r\n            // Fallback to Math.random for environments where crypto is not available.\r\n            // This is acceptable for non-security-critical random number generation like user agent selection.\r\n            // eslint-disable-next-line sonarjs/pseudo-random -- Math.random is acceptable for non-security-critical user agent selection.\r\n            idx = Math.floor(Math.random() * this.userAgents.length);\r\n        }\r\n        return this.userAgents[idx];\r\n    }\r\n    randomDelay() {\r\n        let randomMs;\r\n        if (globalThis.window?.crypto?.getRandomValues != undefined) {\r\n            const array = globalThis.window.crypto.getRandomValues(new Uint32Array(1));\r\n            randomMs = array[0] % 1000;\r\n        }\r\n        else if (typeof crypto.randomInt === 'function') {\r\n            randomMs = crypto.randomInt(0, 1000);\r\n        }\r\n        else {\r\n            // Fallback to Math.random for environments where crypto is not available.\r\n            // This is acceptable for non-security-critical random delays.\r\n            // eslint-disable-next-line sonarjs/pseudo-random -- Math.random is acceptable for non-security-critical random delays.\r\n            randomMs = Math.floor(Math.random() * 1000);\r\n        }\r\n        const delay = this.requestDelay + randomMs;\r\n        return new Promise((resolve) => setTimeout(resolve, delay));\r\n    }\r\n    handleRateLimit(retryAfter) {\r\n        console.info(`Rate limited. Waiting ${retryAfter} seconds before retry...`);\r\n        return new Promise((resolve) => setTimeout(resolve, retryAfter * 1000));\r\n    }\r\n    async retryWithBackoff(operation, maxRetries = this.maxRetries) {\r\n        let lastError;\r\n        for (let attempt = 1; attempt <= maxRetries; attempt += 1) {\r\n            try {\r\n                return await operation();\r\n            }\r\n            catch (error) {\r\n                lastError = error;\r\n                if (attempt === maxRetries) {\r\n                    throw lastError instanceof Error ? lastError : new Error(String(lastError));\r\n                }\r\n                const backoffDelay = Math.pow(2, attempt) * 1000;\r\n                console.info(`Attempt ${attempt} failed. Retrying in ${backoffDelay}ms...`);\r\n                await new Promise((resolve) => setTimeout(resolve, backoffDelay));\r\n            }\r\n        }\r\n        throw lastError instanceof Error ? lastError : new Error('Request failed after all retries');\r\n    }\r\n}\r\nexport class DataQualityAssessor {\r\n    assessBasicInfo(truckData, issues, score) {\r\n        if (truckData.name == undefined || truckData.name.trim().length === 0) {\r\n            issues.push('Missing or empty truck name');\r\n            score -= 20;\r\n        }\r\n        return score;\r\n    }\r\n    assessLocationInfo(truckData, issues, score) {\r\n        if (truckData.location?.current == undefined) {\r\n            issues.push('Missing current location data');\r\n            score -= 25;\r\n        }\r\n        else {\r\n            if (truckData.location.current.lat == undefined ||\r\n                truckData.location.current.lng == undefined) {\r\n                issues.push('Missing GPS coordinates');\r\n                score -= 15;\r\n            }\r\n            if (truckData.location.current.address == undefined ||\r\n                truckData.location.current.address === '') {\r\n                issues.push('Missing address information');\r\n                score -= 10;\r\n            }\r\n        }\r\n        return score;\r\n    }\r\n    assessContactInfo(truckData, issues, score) {\r\n        if (truckData.contact) {\r\n            const hasPhone = typeof truckData.contact.phone === 'string' && truckData.contact.phone.trim() !== '';\r\n            const hasEmail = typeof truckData.contact.email === 'string' && truckData.contact.email.trim() !== '';\r\n            if (!hasPhone && !hasEmail) {\r\n                issues.push('No phone or email contact available');\r\n                score -= 15;\r\n            }\r\n            if (hasPhone && !this.isValidPhone(truckData.contact.phone)) {\r\n                issues.push('Invalid phone number format');\r\n                score -= 5;\r\n            }\r\n            if (hasEmail && !this.isValidEmail(truckData.contact.email)) {\r\n                issues.push('Invalid email format');\r\n                score -= 5;\r\n            }\r\n        }\r\n        else {\r\n            issues.push('Missing contact information');\r\n            score -= 20;\r\n        }\r\n        return score;\r\n    }\r\n    assessOperatingHours(truckData, issues, score) {\r\n        if (truckData.operating_hours == undefined ||\r\n            Object.keys(truckData.operating_hours).length === 0) {\r\n            issues.push('Missing operating hours');\r\n            score -= 15;\r\n        }\r\n        return score;\r\n    }\r\n    assessMenuInfo(truckData, issues, score) {\r\n        if (truckData.menu == undefined || truckData.menu.length === 0) {\r\n            issues.push('Missing menu information');\r\n            score -= 10;\r\n        }\r\n        else {\r\n            const menuIssues = this.validateMenuData(truckData.menu);\r\n            issues.push(...menuIssues);\r\n            score -= menuIssues.length * 2;\r\n        }\r\n        return score;\r\n    }\r\n    assessLastUpdated(truckData, issues, score) {\r\n        if (truckData.last_updated != undefined && truckData.last_updated !== '') {\r\n            const lastUpdate = new Date(truckData.last_updated);\r\n            const daysSinceUpdate = (Date.now() - lastUpdate.getTime()) / (1000 * 60 * 60 * 24);\r\n            if (daysSinceUpdate > 7) {\r\n                issues.push('Data is more than 7 days old');\r\n                score -= 10;\r\n            }\r\n            else if (daysSinceUpdate > 3) {\r\n                issues.push('Data is more than 3 days old');\r\n                score -= 5;\r\n            }\r\n        }\r\n        return score;\r\n    }\r\n    assessTruckData(truckData) {\r\n        const issues = [];\r\n        let score = 100;\r\n        score = this.assessBasicInfo(truckData, issues, score);\r\n        score = this.assessLocationInfo(truckData, issues, score);\r\n        score = this.assessContactInfo(truckData, issues, score);\r\n        score = this.assessOperatingHours(truckData, issues, score);\r\n        score = this.assessMenuInfo(truckData, issues, score);\r\n        score = this.assessLastUpdated(truckData, issues, score);\r\n        return {\r\n            score: Math.max(0, score) / 100,\r\n            issues,\r\n        };\r\n    }\r\n    validateMenuCategory(category, categoryIndex, issues) {\r\n        if (category.category == undefined || category.category.trim().length === 0) {\r\n            issues.push(`Menu category ${categoryIndex + 1} missing name`);\r\n        }\r\n    }\r\n    validateMenuItems(category, issues) {\r\n        if (category.items == undefined || category.items.length === 0) {\r\n            issues.push(`Menu category \"${category.category ?? 'Unknown'}\" has no items`);\r\n        }\r\n        else {\r\n            for (const [itemIndex, item] of category.items.entries()) {\r\n                if (item.name == undefined || item.name.trim().length === 0) {\r\n                    issues.push(`Menu item ${itemIndex + 1} in \"${category.category ?? 'Unknown'}\" missing name`);\r\n                }\r\n                if (typeof item.price !== 'number' || item.price <= 0) {\r\n                    issues.push(`Menu item \"${item.name ?? 'Unknown'}\" has invalid price`);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    validateMenuData(menu) {\r\n        const issues = [];\r\n        for (const [categoryIndex, category] of menu.entries()) {\r\n            this.validateMenuCategory(category, categoryIndex, issues);\r\n            this.validateMenuItems(category, issues);\r\n        }\r\n        return issues;\r\n    }\r\n    isValidPhone(phone) {\r\n        // Regex for phone number validation. Not vulnerable to super-linear runtime due to backtracking.\r\n        // Accepts +, digits, spaces, dashes, and parentheses. At least 10 digits.\r\n        const phoneRegex = /^\\+?[\\d\\s\\-()]{10,}$/;\r\n        return phoneRegex.test(phone);\r\n    }\r\n    isValidEmail(email) {\r\n        // Regex for email validation optimized to avoid backtracking\r\n        const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[a-zA-Z]{2,}$/;\r\n        return emailRegex.test(email);\r\n    }\r\n}\r\nexport class GeminiDataProcessor {\r\n    _apiKey;\r\n    _baseUrl;\r\n    requestCount;\r\n    tokenCount;\r\n    dailyLimit;\r\n    constructor(apiKey) {\r\n        this._apiKey = apiKey;\r\n        this._baseUrl = 'https://generativelanguage.googleapis.com/v1beta';\r\n        this.requestCount = 0;\r\n        this.tokenCount = 0;\r\n        this.dailyLimit = { requests: 1500, tokens: 32_000 };\r\n    }\r\n    async processMenuData(rawMenuText) {\r\n        if (!this.canMakeRequest()) {\r\n            throw new Error('Gemini API rate limit exceeded');\r\n        }\r\n        try {\r\n            const prompt = `\r\n        Parse the following food truck menu text and return a structured JSON format:\r\n        \r\n        ${rawMenuText}\r\n        \r\n        Return format:\r\n        {\r\n          \"categories\": [\r\n            {\r\n              \"name\": \"category_name\",\r\n              \"items\": [\r\n                {\r\n                  \"name\": \"item_name\",\r\n                  \"description\": \"item_description\",\r\n                  \"price\": 0.00,\r\n                  \"dietary_tags\": [\"vegetarian\", \"vegan\", \"gluten-free\", etc.]\r\n                }\r\n              ]\r\n            }\r\n          ]\r\n        }\r\n        \r\n        Only return valid JSON, no additional text.\r\n      `;\r\n            const response = await this.makeGeminiRequest(prompt);\r\n            this.updateUsageCounters(1, prompt.length + response.length);\r\n            // Ensure type safety for parsed response\r\n            const parsed = JSON.parse(response);\r\n            if (typeof parsed !== 'object' ||\r\n                parsed == undefined ||\r\n                !('categories' in parsed) ||\r\n                !Array.isArray(parsed.categories)) {\r\n                throw new Error('Invalid Gemini menu response: missing or malformed categories array');\r\n            }\r\n            return parsed;\r\n        }\r\n        catch (error) {\r\n            console.error('Error processing menu data with Gemini:', error);\r\n            throw error;\r\n        }\r\n    }\r\n    async extractLocationFromText(text) {\r\n        if (!this.canMakeRequest()) {\r\n            throw new Error('Gemini API rate limit exceeded');\r\n        }\r\n        try {\r\n            const prompt = `\r\n        Extract location information from the following text and return structured data:\r\n        \r\n        \"${text}\"\r\n        \r\n        Return format:\r\n        {\r\n          \"address\": \"full_address\",\r\n          \"city\": \"city_name\",\r\n          \"state\": \"state\",\r\n          \"coordinates\": {\r\n            \"lat\": 0.0,\r\n            \"lng\": 0.0\r\n          },\r\n          \"confidence\": 0.95\r\n        }\r\n        \r\n        If coordinates cannot be determined, set them to undefined. Only return valid JSON.\r\n      `;\r\n            const response = await this.makeGeminiRequest(prompt);\r\n            this.updateUsageCounters(1, prompt.length + response.length);\r\n            const parsedResponse = JSON.parse(response);\r\n            const validatedResponse = this.validateGeminiLocationResponse(parsedResponse);\r\n            return validatedResponse;\r\n        }\r\n        catch (error) {\r\n            console.error('Error extracting location with Gemini:', error);\r\n            throw error;\r\n        }\r\n    }\r\n    validateGeminiLocationResponse(parsedResponse) {\r\n        if (parsedResponse == undefined ||\r\n            typeof parsedResponse !== 'object' ||\r\n            !('coordinates' in parsedResponse) ||\r\n            typeof parsedResponse.coordinates !== 'object') {\r\n            throw new Error('Invalid Gemini location response');\r\n        }\r\n        const coordinates = parsedResponse\r\n            .coordinates;\r\n        if (coordinates && typeof coordinates === 'object') {\r\n            if (typeof coordinates.lat !== 'number') {\r\n                coordinates.lat = undefined;\r\n            }\r\n            if (typeof coordinates.lng !== 'number') {\r\n                coordinates.lng = undefined;\r\n            }\r\n        }\r\n        return parsedResponse;\r\n    }\r\n    async standardizeOperatingHours(hoursText) {\r\n        if (!this.canMakeRequest()) {\r\n            throw new Error('Gemini API rate limit exceeded');\r\n        }\r\n        try {\r\n            const prompt = `\r\n        Parse the following operating hours text and return standardized format:\r\n        \r\n        \"${hoursText}\"\r\n        \r\n        Return format:\r\n        {\r\n          \"monday\": {\"open\": \"HH:MM\", \"close\": \"HH:MM\", \"closed\": false},\r\n          \"tuesday\": {\"open\": \"HH:MM\", \"close\": \"HH:MM\", \"closed\": false},\r\n          \"wednesday\": {\"open\": \"HH:MM\", \"close\": \"HH:MM\", \"closed\": false},\r\n          \"thursday\": {\"open\": \"HH:MM\", \"close\": \"HH:MM\", \"closed\": false},\r\n          \"friday\": {\"open\": \"HH:MM\", \"close\": \"HH:MM\", \"closed\": false},\r\n          \"saturday\": {\"open\": \"HH:MM\", \"close\": \"HH:MM\", \"closed\": false},\r\n          \"sunday\": {\"open\": \"HH:MM\", \"close\": \"HH:MM\", \"closed\": false}\r\n        }\r\n          Use 24-hour format. If closed on a day, set \"closed\": true and omit open/close times.\r\n        Only return valid JSON.\r\n      `;\r\n            const response = await this.makeGeminiRequest(prompt);\r\n            this.updateUsageCounters(1, prompt.length + response.length);\r\n            const parsed = JSON.parse(response);\r\n            if (parsed == undefined || typeof parsed !== 'object') {\r\n                throw new Error('Invalid Gemini hours response');\r\n            }\r\n            return parsed;\r\n        }\r\n        catch (error) {\r\n            console.error('Error standardizing hours with Gemini:', error);\r\n            throw error;\r\n        }\r\n    }\r\n    async analyzeSentiment(reviewText) {\r\n        if (!this.canMakeRequest()) {\r\n            throw new Error('Gemini API rate limit exceeded');\r\n        }\r\n        try {\r\n            const prompt = `\r\n        Analyze the sentiment of this food truck review and extract key insights:\r\n        \r\n        \"${reviewText}\"\r\n        \r\n        Return format:\r\n        {\r\n          \"sentiment\": \"positive|negative|neutral\",\r\n          \"score\": 0.85,\r\n          \"key_topics\": [\"food_quality\", \"service\", \"price\", \"location\"],\r\n          \"summary\": \"brief_summary_of_review\"\r\n        }\r\n          Score should be between 0 (very negative) and 1 (very positive).\r\n        Only return valid JSON.\r\n      `;\r\n            const response = await this.makeGeminiRequest(prompt);\r\n            this.updateUsageCounters(1, prompt.length + response.length);\r\n            const parsed = JSON.parse(response);\r\n            if (parsed == undefined || typeof parsed !== 'object') {\r\n                throw new Error('Invalid Gemini sentiment response');\r\n            }\r\n            return parsed;\r\n        }\r\n        catch (error) {\r\n            console.error('Error analyzing sentiment with Gemini:', error);\r\n            throw error;\r\n        }\r\n    }\r\n    async makeGeminiRequest(prompt) {\r\n        await new Promise((resolve) => setTimeout(resolve, 1000)); // Simulate API delay\r\n        return this.getMockGeminiResponse(prompt);\r\n    }\r\n    getMockGeminiResponse(prompt) {\r\n        if (prompt.includes('menu text')) {\r\n            return JSON.stringify({\r\n                categories: [\r\n                    {\r\n                        name: 'Burgers',\r\n                        items: [\r\n                            {\r\n                                name: 'Classic Cheeseburger',\r\n                                description: 'Beef patty with cheese, lettuce, tomato',\r\n                                price: 12.99,\r\n                                dietary_tags: [],\r\n                            },\r\n                        ],\r\n                    },\r\n                ],\r\n            });\r\n        }\r\n        else if (prompt.includes('location information')) {\r\n            return JSON.stringify({\r\n                address: '123 Market St, San Francisco, CA 94105',\r\n                city: 'San Francisco',\r\n                state: 'CA',\r\n                coordinates: {\r\n                    lat: 37.7749,\r\n                    lng: -122.4194,\r\n                },\r\n                confidence: 0.95,\r\n            });\r\n        }\r\n        else if (prompt.includes('operating hours')) {\r\n            return JSON.stringify({\r\n                monday: { open: '11:00', close: '15:00', closed: false },\r\n                tuesday: { open: '11:00', close: '15:00', closed: false },\r\n                wednesday: { open: '11:00', close: '15:00', closed: false },\r\n                thursday: { open: '11:00', close: '15:00', closed: false },\r\n                friday: { open: '11:00', close: '20:00', closed: false },\r\n                saturday: { open: '12:00', close: '20:00', closed: false },\r\n                sunday: { open: '12:00', close: '16:00', closed: false },\r\n            });\r\n        }\r\n        else if (prompt.includes('sentiment')) {\r\n            return JSON.stringify({\r\n                sentiment: 'positive',\r\n                score: 0.85,\r\n                key_topics: ['food_quality', 'service'],\r\n                summary: 'Customer enjoyed the food and service',\r\n            });\r\n        }\r\n        return '{\"processed\": true}';\r\n    }\r\n    canMakeRequest() {\r\n        return this.requestCount < this.dailyLimit.requests && this.tokenCount < this.dailyLimit.tokens;\r\n    }\r\n    updateUsageCounters(requests, tokens) {\r\n        this.requestCount += requests;\r\n        this.tokenCount += tokens;\r\n    }\r\n    getUsageStats() {\r\n        return {\r\n            requests: {\r\n                used: this.requestCount,\r\n                limit: this.dailyLimit.requests,\r\n                remaining: this.dailyLimit.requests - this.requestCount,\r\n            },\r\n            tokens: {\r\n                used: this.tokenCount,\r\n                limit: this.dailyLimit.tokens,\r\n                remaining: this.dailyLimit.tokens - this.tokenCount,\r\n            },\r\n        };\r\n    }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\ScraperEngine.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":155,"column":11,"nodeType":"MemberExpression","messageId":"conditionErrorObject","endLine":155,"endColumn":31}],"suppressedMessages":[{"ruleId":"sonarjs/pseudo-random","severity":2,"message":"Make sure that using this pseudorandom number generator is safe here.","line":326,"column":24,"nodeType":"CallExpression","messageId":"safeGenerator","endLine":326,"endColumn":37,"suppressions":[{"kind":"directive","justification":"Math.random is acceptable for non-security-critical user agent selection."}]},{"ruleId":"sonarjs/pseudo-random","severity":2,"message":"Make sure that using this pseudorandom number generator is safe here.","line":342,"column":29,"nodeType":"CallExpression","messageId":"safeGenerator","endLine":342,"endColumn":42,"suppressions":[{"kind":"directive","justification":"Math.random is acceptable for non-security-critical random delays."}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { firecrawl } from './firecrawl'; // Import the firecrawl singleton\r\nimport * as crypto from 'node:crypto'; // Node.js crypto for secure randomness\r\n\r\ninterface InstagramPost {\r\n  id: string;\r\n  caption: string;\r\n  timestamp: string;\r\n  location: string;\r\n  hashtags: string[];\r\n  engagement: { likes: number; comments: number };\r\n}\r\n\r\ninterface InstagramProfile {\r\n  followers: number;\r\n  following: number;\r\n  posts_count: number;\r\n  bio: string;\r\n  contact_info: { email: string; phone: string };\r\n}\r\n\r\ninterface FacebookPost {\r\n  id: string;\r\n  content: string;\r\n  timestamp: string;\r\n  reactions: { likes: number; loves: number; shares: number };\r\n  comments: number;\r\n}\r\n\r\ninterface FacebookPageInfo {\r\n  likes: number;\r\n  followers: number;\r\n  check_ins: number;\r\n  about: string;\r\n  hours: Record<string, string>;\r\n}\r\n\r\ninterface TwitterTweet {\r\n  id: string;\r\n  text: string;\r\n  timestamp: string;\r\n  retweets: number;\r\n  likes: number;\r\n  replies: number;\r\n  location: string;\r\n}\r\n\r\ninterface TwitterProfile {\r\n  followers: number;\r\n  following: number;\r\n  tweets_count: number;\r\n  bio: string;\r\n  location: string;\r\n  website: string;\r\n}\r\n\r\ninterface InstagramData {\r\n  posts: InstagramPost[];\r\n  profile: InstagramProfile;\r\n}\r\n\r\ninterface FacebookData {\r\n  posts: FacebookPost[];\r\n  page_info: FacebookPageInfo;\r\n}\r\n\r\ninterface TwitterData {\r\n  tweets: TwitterTweet[];\r\n  profile: TwitterProfile;\r\n}\r\n\r\nexport interface WebsiteScrapeData {\r\n  markdown?: string;\r\n  html?: string;\r\n  metadata?: Record<string, unknown>;\r\n  is_fallback?: boolean;\r\n}\r\n\r\nexport interface ExtractedHTMLData {\r\n  name?: string;\r\n  location?: string;\r\n  phone?: string;\r\n  hours?: string;\r\n  menu?: { item: string; price: string }[];\r\n}\r\n\r\ninterface ScrapeResult {\r\n  success: boolean;\r\n  error?: string;\r\n  data?: InstagramData | FacebookData | TwitterData | WebsiteScrapeData | ExtractedHTMLData;\r\n  timestamp: string;\r\n  source: string;\r\n  note?: string;\r\n}\r\n\r\n// Core scraping engine with anti-detection measures\r\nexport class ScraperEngine {\r\n  private userAgents: string[];\r\n  private requestDelay: number;\r\n  private maxRetries: number;\r\n\r\n  constructor() {\r\n    this.userAgents = [\r\n      'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',\r\n      'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',\r\n      'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',\r\n    ];\r\n    this.requestDelay = 2000;\r\n    this.maxRetries = 3;\r\n  }\r\n\r\n  private async performFallbackScrape(url: string): Promise<ScrapeResult> {\r\n    try {\r\n      const response = await fetch(url, { headers: { 'User-Agent': this.getRandomUserAgent() } });\r\n      if (!response.ok) {\r\n        throw new Error(\r\n          `HTTP error ${response.status}: ${response.statusText} during fallback fetch.`,\r\n        );\r\n      }\r\n      const htmlContent = await response.text();\r\n      return {\r\n        success: true,\r\n        data: {\r\n          html: htmlContent,\r\n          is_fallback: true,\r\n        },\r\n        timestamp: new Date().toISOString(),\r\n        source: url,\r\n        note: 'Fetched using basic fetch as Firecrawl failed.',\r\n      };\r\n    } catch (fallbackError) {\r\n      const errMsg =\r\n        fallbackError instanceof Error ? fallbackError.message : 'Unknown fallback fetch error';\r\n      console.warn(`Fallback fetch error for ${url}:`, errMsg);\r\n      return {\r\n        success: false,\r\n        error: \"That didn't work, please try again later.\",\r\n        timestamp: new Date().toISOString(),\r\n        source: url,\r\n      };\r\n    }\r\n  }\r\n\r\n  async scrapeWebsite(url: string, _selectors?: Record<string, string>): Promise<ScrapeResult> {\r\n    try {\r\n      const firecrawlResult = await firecrawl.scrapeUrl(url, {\r\n        formats: ['markdown', 'html'],\r\n        onlyMainContent: true,\r\n      });\r\n\r\n      if (firecrawlResult.success !== true || firecrawlResult.data == undefined) {\r\n        throw new Error(firecrawlResult.error ?? 'Firecrawl scraping failed to return data.');\r\n      }\r\n\r\n      const returnedData: WebsiteScrapeData = {};\r\n      if (firecrawlResult.data && typeof firecrawlResult.data === 'object') {\r\n        const firecrawlData = firecrawlResult.data as Record<string, unknown>;\r\n\r\n        if (typeof firecrawlData.markdown === 'string' && firecrawlData.markdown !== '') {\r\n          returnedData.markdown = firecrawlData.markdown;\r\n        }\r\n        if (typeof firecrawlData.html === 'string' && firecrawlData.html !== '') {\r\n          returnedData.html = firecrawlData.html;\r\n        }\r\n        if (firecrawlData.metadata != undefined && typeof firecrawlData.metadata === 'object') {\r\n          returnedData.metadata = firecrawlData.metadata as Record<string, unknown>;\r\n        }\r\n      }\r\n\r\n      if (\r\n        (returnedData.markdown == undefined || returnedData.markdown === '') &&\r\n        (returnedData.html == undefined || returnedData.html === '')\r\n      ) {\r\n        throw new Error('Firecrawl returned no markdown or HTML content.');\r\n      }\r\n\r\n      return {\r\n        success: true,\r\n        data: returnedData,\r\n        timestamp: new Date().toISOString(),\r\n        source: url,\r\n      };\r\n    } catch (error: unknown) {\r\n      console.warn(`Scraping error for ${url} using Firecrawl:`, error);\r\n      console.info(`Falling back to basic fetch for ${url}`);\r\n      return await this.performFallbackScrape(url);\r\n    }\r\n  }\r\n\r\n  async scrapeSocialMedia(platform: string, handle: string): Promise<ScrapeResult> {\r\n    try {\r\n      await this.randomDelay();\r\n\r\n      switch (platform) {\r\n        case 'instagram': {\r\n          return await this.scrapeInstagram(handle);\r\n        }\r\n        case 'facebook': {\r\n          return await this.scrapeFacebook(handle);\r\n        }\r\n        case 'twitter': {\r\n          return await this.scrapeTwitter(handle);\r\n        }\r\n        default: {\r\n          throw new Error(`Unsupported platform: ${platform}`);\r\n        }\r\n      }\r\n    } catch (error) {\r\n      console.warn(`Social media scraping error for ${platform}/${handle}:`, error);\r\n      return {\r\n        success: false,\r\n        error: \"That didn't work, please try again later.\",\r\n        timestamp: new Date().toISOString(),\r\n        source: `social_media:${platform}:${handle}`,\r\n      };\r\n    }\r\n  }\r\n\r\n  private async scrapeInstagram(handle: string): Promise<ScrapeResult> {\r\n    await this.randomDelay();\r\n    const posts: InstagramPost[] = [\r\n      {\r\n        id: 'post_001',\r\n        caption: 'Fresh tacos available now at Mission St! 🌮 #foodtruck #tacos',\r\n        timestamp: new Date(Date.now() - 3_600_000).toISOString(),\r\n        location: 'Mission St, San Francisco',\r\n        hashtags: ['foodtruck', 'tacos', 'fresh'],\r\n        engagement: { likes: 45, comments: 8 },\r\n      },\r\n    ];\r\n    const profile: InstagramProfile = {\r\n      followers: 1250,\r\n      following: 340,\r\n      posts_count: 156,\r\n      bio: 'Best tacos in SF 🌮 Follow for daily locations!',\r\n      contact_info: {\r\n        email: 'contact@tacoparadise.com',\r\n        phone: '+1-555-0456',\r\n      },\r\n    };\r\n    const data: InstagramData = { posts, profile };\r\n    return {\r\n      success: true,\r\n      data,\r\n      timestamp: new Date().toISOString(),\r\n      source: `instagram:${handle}`,\r\n    };\r\n  }\r\n\r\n  private async scrapeFacebook(handle: string): Promise<ScrapeResult> {\r\n    await this.randomDelay();\r\n    const posts: FacebookPost[] = [\r\n      {\r\n        id: 'fb_post_001',\r\n        content: \"Today we'll be at Union Square from 11 AM to 3 PM! Come try our new BBQ burger!\",\r\n        timestamp: new Date(Date.now() - 7_200_000).toISOString(),\r\n        reactions: { likes: 23, loves: 5, shares: 3 },\r\n        comments: 12,\r\n      },\r\n    ];\r\n    const page_info: FacebookPageInfo = {\r\n      likes: 890,\r\n      followers: 1100,\r\n      check_ins: 450,\r\n      about: 'Gourmet food truck serving the Bay Area',\r\n      hours: {\r\n        monday: '11:00-15:00',\r\n        tuesday: '11:00-15:00',\r\n        wednesday: '11:00-15:00',\r\n        thursday: '11:00-15:00',\r\n        friday: '11:00-20:00',\r\n        saturday: '12:00-20:00',\r\n        sunday: '12:00-16:00',\r\n      },\r\n    };\r\n    const data: FacebookData = { posts, page_info };\r\n    return {\r\n      success: true,\r\n      data,\r\n      timestamp: new Date().toISOString(),\r\n      source: `facebook:${handle}`,\r\n    };\r\n  }\r\n\r\n  private async scrapeTwitter(handle: string): Promise<ScrapeResult> {\r\n    await this.randomDelay();\r\n    const tweets: TwitterTweet[] = [\r\n      {\r\n        id: 'tweet_001',\r\n        text: 'LIVE at Dolores Park! Fresh burritos and quesadillas available now 🌯',\r\n        timestamp: new Date(Date.now() - 1_800_000).toISOString(),\r\n        retweets: 8,\r\n        likes: 34,\r\n        replies: 5,\r\n        location: 'Dolores Park, San Francisco',\r\n      },\r\n    ];\r\n    const profile: TwitterProfile = {\r\n      followers: 2340,\r\n      following: 567,\r\n      tweets_count: 1890,\r\n      bio: '🚚 SF Food Truck | Fresh Mexican Food | Follow for locations',\r\n      location: 'San Francisco, CA',\r\n      website: 'https://tacoparadise.com',\r\n    };\r\n    const data: TwitterData = { tweets, profile };\r\n    return {\r\n      success: true,\r\n      data,\r\n      timestamp: new Date().toISOString(),\r\n      source: `twitter:${handle}`,\r\n    };\r\n  }\r\n\r\n  private getRandomUserAgent(): string {\r\n    // Use Node.js crypto for stronger randomness if available, fallback to Math.random otherwise.\r\n    let idx: number;\r\n    if (globalThis.window?.crypto?.getRandomValues != undefined) {\r\n      const array = globalThis.window.crypto.getRandomValues(new Uint32Array(1));\r\n      idx = array[0] % this.userAgents.length;\r\n    } else if (typeof crypto.randomInt === 'function') {\r\n      idx = crypto.randomInt(0, this.userAgents.length);\r\n    } else {\r\n      // Fallback to Math.random for environments where crypto is not available.\r\n      // This is acceptable for non-security-critical random number generation like user agent selection.\r\n      // eslint-disable-next-line sonarjs/pseudo-random -- Math.random is acceptable for non-security-critical user agent selection.\r\n      idx = Math.floor(Math.random() * this.userAgents.length);\r\n    }\r\n    return this.userAgents[idx];\r\n  }\r\n\r\n  private randomDelay(): Promise<void> {\r\n    let randomMs: number;\r\n    if (globalThis.window?.crypto?.getRandomValues != undefined) {\r\n      const array = globalThis.window.crypto.getRandomValues(new Uint32Array(1));\r\n      randomMs = array[0] % 1000;\r\n    } else if (typeof crypto.randomInt === 'function') {\r\n      randomMs = crypto.randomInt(0, 1000);\r\n    } else {\r\n      // Fallback to Math.random for environments where crypto is not available.\r\n      // This is acceptable for non-security-critical random delays.\r\n      // eslint-disable-next-line sonarjs/pseudo-random -- Math.random is acceptable for non-security-critical random delays.\r\n      randomMs = Math.floor(Math.random() * 1000);\r\n    }\r\n    const delay = this.requestDelay + randomMs;\r\n    return new Promise((resolve) => setTimeout(resolve, delay));\r\n  }\r\n\r\n  handleRateLimit(retryAfter: number): Promise<void> {\r\n    console.info(`Rate limited. Waiting ${retryAfter} seconds before retry...`);\r\n    return new Promise((resolve) => setTimeout(resolve, retryAfter * 1000));\r\n  }\r\n\r\n  async retryWithBackoff<T>(\r\n    operation: () => Promise<T>,\r\n    maxRetries: number = this.maxRetries,\r\n  ): Promise<T> {\r\n    let lastError: unknown;\r\n\r\n    for (let attempt = 1; attempt <= maxRetries; attempt += 1) {\r\n      try {\r\n        return await operation();\r\n      } catch (error: unknown) {\r\n        lastError = error;\r\n        if (attempt === maxRetries) {\r\n          throw lastError instanceof Error ? lastError : new Error(String(lastError));\r\n        }\r\n\r\n        const backoffDelay = Math.pow(2, attempt) * 1000;\r\n        console.info(`Attempt ${attempt} failed. Retrying in ${backoffDelay}ms...`);\r\n        await new Promise((resolve) => setTimeout(resolve, backoffDelay));\r\n      }\r\n    }\r\n\r\n    throw lastError instanceof Error ? lastError : new Error('Request failed after all retries');\r\n  }\r\n}\r\n\r\ninterface LocationData {\r\n  current?: {\r\n    lat?: number;\r\n    lng?: number;\r\n    address?: string;\r\n  };\r\n}\r\n\r\ninterface ContactInfo {\r\n  phone?: string;\r\n  email?: string;\r\n}\r\n\r\ninterface OperatingHours {\r\n  [key: string]: {\r\n    open: string;\r\n    close: string;\r\n    closed: boolean;\r\n  };\r\n}\r\n\r\ninterface MenuItem {\r\n  name: string;\r\n  description?: string;\r\n  price: number;\r\n  dietary_tags?: string[];\r\n}\r\n\r\ninterface MenuCategory {\r\n  category: string;\r\n  items: MenuItem[];\r\n}\r\n\r\ninterface TruckData {\r\n  name: string;\r\n  location: LocationData;\r\n  contact?: ContactInfo;\r\n  operating_hours?: OperatingHours;\r\n  menu?: MenuCategory[];\r\n  last_updated?: string;\r\n}\r\n\r\nexport class DataQualityAssessor {\r\n  private assessBasicInfo(truckData: TruckData, issues: string[], score: number): number {\r\n    if (truckData.name == undefined || truckData.name.trim().length === 0) {\r\n      issues.push('Missing or empty truck name');\r\n      score -= 20;\r\n    }\r\n    return score;\r\n  }\r\n\r\n  private assessLocationInfo(truckData: TruckData, issues: string[], score: number): number {\r\n    if (truckData.location?.current == undefined) {\r\n      issues.push('Missing current location data');\r\n      score -= 25;\r\n    } else {\r\n      if (\r\n        truckData.location.current.lat == undefined ||\r\n        truckData.location.current.lng == undefined\r\n      ) {\r\n        issues.push('Missing GPS coordinates');\r\n        score -= 15;\r\n      }\r\n      if (\r\n        truckData.location.current.address == undefined ||\r\n        truckData.location.current.address === ''\r\n      ) {\r\n        issues.push('Missing address information');\r\n        score -= 10;\r\n      }\r\n    }\r\n    return score;\r\n  }\r\n\r\n  private assessContactInfo(truckData: TruckData, issues: string[], score: number): number {\r\n    if (truckData.contact) {\r\n      const hasPhone =\r\n        typeof truckData.contact.phone === 'string' && truckData.contact.phone.trim() !== '';\r\n      const hasEmail =\r\n        typeof truckData.contact.email === 'string' && truckData.contact.email.trim() !== '';\r\n\r\n      if (!hasPhone && !hasEmail) {\r\n        issues.push('No phone or email contact available');\r\n        score -= 15;\r\n      }\r\n      if (hasPhone && !this.isValidPhone(truckData.contact.phone as string)) {\r\n        issues.push('Invalid phone number format');\r\n        score -= 5;\r\n      }\r\n      if (hasEmail && !this.isValidEmail(truckData.contact.email as string)) {\r\n        issues.push('Invalid email format');\r\n        score -= 5;\r\n      }\r\n    } else {\r\n      issues.push('Missing contact information');\r\n      score -= 20;\r\n    }\r\n    return score;\r\n  }\r\n\r\n  private assessOperatingHours(truckData: TruckData, issues: string[], score: number): number {\r\n    if (\r\n      truckData.operating_hours == undefined ||\r\n      Object.keys(truckData.operating_hours).length === 0\r\n    ) {\r\n      issues.push('Missing operating hours');\r\n      score -= 15;\r\n    }\r\n    return score;\r\n  }\r\n\r\n  private assessMenuInfo(truckData: TruckData, issues: string[], score: number): number {\r\n    if (truckData.menu == undefined || truckData.menu.length === 0) {\r\n      issues.push('Missing menu information');\r\n      score -= 10;\r\n    } else {\r\n      const menuIssues = this.validateMenuData(truckData.menu);\r\n      issues.push(...menuIssues);\r\n      score -= menuIssues.length * 2;\r\n    }\r\n    return score;\r\n  }\r\n\r\n  private assessLastUpdated(truckData: TruckData, issues: string[], score: number): number {\r\n    if (truckData.last_updated != undefined && truckData.last_updated !== '') {\r\n      const lastUpdate = new Date(truckData.last_updated);\r\n      const daysSinceUpdate = (Date.now() - lastUpdate.getTime()) / (1000 * 60 * 60 * 24);\r\n\r\n      if (daysSinceUpdate > 7) {\r\n        issues.push('Data is more than 7 days old');\r\n        score -= 10;\r\n      } else if (daysSinceUpdate > 3) {\r\n        issues.push('Data is more than 3 days old');\r\n        score -= 5;\r\n      }\r\n    }\r\n    return score;\r\n  }\r\n\r\n  assessTruckData(truckData: TruckData): { score: number; issues: string[] } {\r\n    const issues: string[] = [];\r\n    let score = 100;\r\n\r\n    score = this.assessBasicInfo(truckData, issues, score);\r\n    score = this.assessLocationInfo(truckData, issues, score);\r\n    score = this.assessContactInfo(truckData, issues, score);\r\n    score = this.assessOperatingHours(truckData, issues, score);\r\n    score = this.assessMenuInfo(truckData, issues, score);\r\n    score = this.assessLastUpdated(truckData, issues, score);\r\n\r\n    return {\r\n      score: Math.max(0, score) / 100,\r\n      issues,\r\n    };\r\n  }\r\n\r\n  private validateMenuCategory(\r\n    category: MenuCategory,\r\n    categoryIndex: number,\r\n    issues: string[],\r\n  ): void {\r\n    if (category.category == undefined || category.category.trim().length === 0) {\r\n      issues.push(`Menu category ${categoryIndex + 1} missing name`);\r\n    }\r\n  }\r\n\r\n  private validateMenuItems(category: MenuCategory, issues: string[]): void {\r\n    if (category.items == undefined || category.items.length === 0) {\r\n      issues.push(`Menu category \"${category.category ?? 'Unknown'}\" has no items`);\r\n    } else {\r\n      for (const [itemIndex, item] of category.items.entries()) {\r\n        if (item.name == undefined || item.name.trim().length === 0) {\r\n          issues.push(\r\n            `Menu item ${itemIndex + 1} in \"${category.category ?? 'Unknown'}\" missing name`,\r\n          );\r\n        }\r\n        if (typeof item.price !== 'number' || item.price <= 0) {\r\n          issues.push(`Menu item \"${item.name ?? 'Unknown'}\" has invalid price`);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  private validateMenuData(menu: MenuCategory[]): string[] {\r\n    const issues: string[] = [];\r\n\r\n    for (const [categoryIndex, category] of menu.entries()) {\r\n      this.validateMenuCategory(category, categoryIndex, issues);\r\n      this.validateMenuItems(category, issues);\r\n    }\r\n\r\n    return issues;\r\n  }\r\n  private isValidPhone(phone: string): boolean {\r\n    // Regex for phone number validation. Not vulnerable to super-linear runtime due to backtracking.\r\n    // Accepts +, digits, spaces, dashes, and parentheses. At least 10 digits.\r\n    const phoneRegex = /^\\+?[\\d\\s\\-()]{10,}$/;\r\n    return phoneRegex.test(phone);\r\n  }\r\n  private isValidEmail(email: string): boolean {\r\n    // Regex for email validation optimized to avoid backtracking\r\n    const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[a-zA-Z]{2,}$/;\r\n    return emailRegex.test(email);\r\n  }\r\n}\r\n\r\ninterface GeminiLocationData {\r\n  address: string;\r\n  city: string;\r\n  state: string;\r\n  coordinates: {\r\n    lat?: number;\r\n    lng?: number;\r\n  };\r\n  confidence: number;\r\n}\r\n\r\ninterface GeminiOperatingHours {\r\n  monday: { open: string; close: string; closed: boolean };\r\n  tuesday: { open: string; close: string; closed: boolean };\r\n  wednesday: { open: string; close: string; closed: boolean };\r\n  thursday: { open: string; close: string; closed: boolean };\r\n  friday: { open: string; close: string; closed: boolean };\r\n  saturday: { open: string; close: string; closed: boolean };\r\n  sunday: { open: string; close: string; closed: boolean };\r\n}\r\n\r\ninterface GeminiSentimentAnalysis {\r\n  sentiment: 'positive' | 'negative' | 'neutral';\r\n  score: number;\r\n  key_topics: string[];\r\n  summary: string;\r\n}\r\n\r\nexport class GeminiDataProcessor {\r\n  private _apiKey: string;\r\n  private _baseUrl: string;\r\n  private requestCount: number;\r\n  private tokenCount: number;\r\n  private dailyLimit: { requests: number; tokens: number };\r\n\r\n  constructor(apiKey: string) {\r\n    this._apiKey = apiKey;\r\n    this._baseUrl = 'https://generativelanguage.googleapis.com/v1beta';\r\n    this.requestCount = 0;\r\n    this.tokenCount = 0;\r\n    this.dailyLimit = { requests: 1500, tokens: 32_000 };\r\n  }\r\n  async processMenuData(rawMenuText: string): Promise<{ categories: MenuCategory[] }> {\r\n    if (!this.canMakeRequest()) {\r\n      throw new Error('Gemini API rate limit exceeded');\r\n    }\r\n\r\n    try {\r\n      const prompt = `\r\n        Parse the following food truck menu text and return a structured JSON format:\r\n        \r\n        ${rawMenuText}\r\n        \r\n        Return format:\r\n        {\r\n          \"categories\": [\r\n            {\r\n              \"name\": \"category_name\",\r\n              \"items\": [\r\n                {\r\n                  \"name\": \"item_name\",\r\n                  \"description\": \"item_description\",\r\n                  \"price\": 0.00,\r\n                  \"dietary_tags\": [\"vegetarian\", \"vegan\", \"gluten-free\", etc.]\r\n                }\r\n              ]\r\n            }\r\n          ]\r\n        }\r\n        \r\n        Only return valid JSON, no additional text.\r\n      `;\r\n\r\n      const response = await this.makeGeminiRequest(prompt);\r\n      this.updateUsageCounters(1, prompt.length + response.length);\r\n\r\n      // Ensure type safety for parsed response\r\n      const parsed: unknown = JSON.parse(response);\r\n      if (\r\n        typeof parsed !== 'object' ||\r\n        parsed == undefined ||\r\n        !('categories' in parsed) ||\r\n        !Array.isArray((parsed as { categories: unknown[] }).categories)\r\n      ) {\r\n        throw new Error('Invalid Gemini menu response: missing or malformed categories array');\r\n      }\r\n      return parsed as { categories: MenuCategory[] };\r\n    } catch (error) {\r\n      console.error('Error processing menu data with Gemini:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  async extractLocationFromText(text: string): Promise<GeminiLocationData> {\r\n    if (!this.canMakeRequest()) {\r\n      throw new Error('Gemini API rate limit exceeded');\r\n    }\r\n\r\n    try {\r\n      const prompt = `\r\n        Extract location information from the following text and return structured data:\r\n        \r\n        \"${text}\"\r\n        \r\n        Return format:\r\n        {\r\n          \"address\": \"full_address\",\r\n          \"city\": \"city_name\",\r\n          \"state\": \"state\",\r\n          \"coordinates\": {\r\n            \"lat\": 0.0,\r\n            \"lng\": 0.0\r\n          },\r\n          \"confidence\": 0.95\r\n        }\r\n        \r\n        If coordinates cannot be determined, set them to undefined. Only return valid JSON.\r\n      `;\r\n      const response = await this.makeGeminiRequest(prompt);\r\n      this.updateUsageCounters(1, prompt.length + response.length);\r\n      const parsedResponse: unknown = JSON.parse(response);\r\n      const validatedResponse = this.validateGeminiLocationResponse(parsedResponse);\r\n      return validatedResponse;\r\n    } catch (error) {\r\n      console.error('Error extracting location with Gemini:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  private validateGeminiLocationResponse(parsedResponse: unknown): GeminiLocationData {\r\n    if (\r\n      parsedResponse == undefined ||\r\n      typeof parsedResponse !== 'object' ||\r\n      !('coordinates' in parsedResponse) ||\r\n      typeof (parsedResponse as Record<string, unknown>).coordinates !== 'object'\r\n    ) {\r\n      throw new Error('Invalid Gemini location response');\r\n    }\r\n    const coordinates = (parsedResponse as { coordinates?: { lat?: unknown; lng?: unknown } })\r\n      .coordinates;\r\n    if (coordinates && typeof coordinates === 'object') {\r\n      if (typeof coordinates.lat !== 'number') {\r\n        (coordinates as { lat?: number }).lat = undefined;\r\n      }\r\n      if (typeof coordinates.lng !== 'number') {\r\n        (coordinates as { lng?: number }).lng = undefined;\r\n      }\r\n    }\r\n    return parsedResponse as GeminiLocationData;\r\n  }\r\n\r\n  async standardizeOperatingHours(hoursText: string): Promise<GeminiOperatingHours> {\r\n    if (!this.canMakeRequest()) {\r\n      throw new Error('Gemini API rate limit exceeded');\r\n    }\r\n\r\n    try {\r\n      const prompt = `\r\n        Parse the following operating hours text and return standardized format:\r\n        \r\n        \"${hoursText}\"\r\n        \r\n        Return format:\r\n        {\r\n          \"monday\": {\"open\": \"HH:MM\", \"close\": \"HH:MM\", \"closed\": false},\r\n          \"tuesday\": {\"open\": \"HH:MM\", \"close\": \"HH:MM\", \"closed\": false},\r\n          \"wednesday\": {\"open\": \"HH:MM\", \"close\": \"HH:MM\", \"closed\": false},\r\n          \"thursday\": {\"open\": \"HH:MM\", \"close\": \"HH:MM\", \"closed\": false},\r\n          \"friday\": {\"open\": \"HH:MM\", \"close\": \"HH:MM\", \"closed\": false},\r\n          \"saturday\": {\"open\": \"HH:MM\", \"close\": \"HH:MM\", \"closed\": false},\r\n          \"sunday\": {\"open\": \"HH:MM\", \"close\": \"HH:MM\", \"closed\": false}\r\n        }\r\n          Use 24-hour format. If closed on a day, set \"closed\": true and omit open/close times.\r\n        Only return valid JSON.\r\n      `;\r\n\r\n      const response = await this.makeGeminiRequest(prompt);\r\n      this.updateUsageCounters(1, prompt.length + response.length);\r\n      const parsed: unknown = JSON.parse(response);\r\n      if (parsed == undefined || typeof parsed !== 'object') {\r\n        throw new Error('Invalid Gemini hours response');\r\n      }\r\n      return parsed as GeminiOperatingHours;\r\n    } catch (error) {\r\n      console.error('Error standardizing hours with Gemini:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  async analyzeSentiment(reviewText: string): Promise<GeminiSentimentAnalysis> {\r\n    if (!this.canMakeRequest()) {\r\n      throw new Error('Gemini API rate limit exceeded');\r\n    }\r\n\r\n    try {\r\n      const prompt = `\r\n        Analyze the sentiment of this food truck review and extract key insights:\r\n        \r\n        \"${reviewText}\"\r\n        \r\n        Return format:\r\n        {\r\n          \"sentiment\": \"positive|negative|neutral\",\r\n          \"score\": 0.85,\r\n          \"key_topics\": [\"food_quality\", \"service\", \"price\", \"location\"],\r\n          \"summary\": \"brief_summary_of_review\"\r\n        }\r\n          Score should be between 0 (very negative) and 1 (very positive).\r\n        Only return valid JSON.\r\n      `;\r\n\r\n      const response = await this.makeGeminiRequest(prompt);\r\n      this.updateUsageCounters(1, prompt.length + response.length);\r\n      const parsed: unknown = JSON.parse(response);\r\n      if (parsed == undefined || typeof parsed !== 'object') {\r\n        throw new Error('Invalid Gemini sentiment response');\r\n      }\r\n      return parsed as GeminiSentimentAnalysis;\r\n    } catch (error) {\r\n      console.error('Error analyzing sentiment with Gemini:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  private async makeGeminiRequest(prompt: string): Promise<string> {\r\n    await new Promise((resolve) => setTimeout(resolve, 1000)); // Simulate API delay\r\n    return this.getMockGeminiResponse(prompt);\r\n  }\r\n\r\n  private getMockGeminiResponse(prompt: string): string {\r\n    if (prompt.includes('menu text')) {\r\n      return JSON.stringify({\r\n        categories: [\r\n          {\r\n            name: 'Burgers',\r\n            items: [\r\n              {\r\n                name: 'Classic Cheeseburger',\r\n                description: 'Beef patty with cheese, lettuce, tomato',\r\n                price: 12.99,\r\n                dietary_tags: [],\r\n              },\r\n            ],\r\n          },\r\n        ],\r\n      });\r\n    } else if (prompt.includes('location information')) {\r\n      return JSON.stringify({\r\n        address: '123 Market St, San Francisco, CA 94105',\r\n        city: 'San Francisco',\r\n        state: 'CA',\r\n        coordinates: {\r\n          lat: 37.7749,\r\n          lng: -122.4194,\r\n        },\r\n        confidence: 0.95,\r\n      });\r\n    } else if (prompt.includes('operating hours')) {\r\n      return JSON.stringify({\r\n        monday: { open: '11:00', close: '15:00', closed: false },\r\n        tuesday: { open: '11:00', close: '15:00', closed: false },\r\n        wednesday: { open: '11:00', close: '15:00', closed: false },\r\n        thursday: { open: '11:00', close: '15:00', closed: false },\r\n        friday: { open: '11:00', close: '20:00', closed: false },\r\n        saturday: { open: '12:00', close: '20:00', closed: false },\r\n        sunday: { open: '12:00', close: '16:00', closed: false },\r\n      });\r\n    } else if (prompt.includes('sentiment')) {\r\n      return JSON.stringify({\r\n        sentiment: 'positive',\r\n        score: 0.85,\r\n        key_topics: ['food_quality', 'service'],\r\n        summary: 'Customer enjoyed the food and service',\r\n      });\r\n    }\r\n    return '{\"processed\": true}';\r\n  }\r\n\r\n  private canMakeRequest(): boolean {\r\n    return this.requestCount < this.dailyLimit.requests && this.tokenCount < this.dailyLimit.tokens;\r\n  }\r\n\r\n  private updateUsageCounters(requests: number, tokens: number): void {\r\n    this.requestCount += requests;\r\n    this.tokenCount += tokens;\r\n  }\r\n\r\n  getUsageStats(): {\r\n    requests: { used: number; limit: number; remaining: number };\r\n    tokens: { used: number; limit: number; remaining: number };\r\n  } {\r\n    return {\r\n      requests: {\r\n        used: this.requestCount,\r\n        limit: this.dailyLimit.requests,\r\n        remaining: this.dailyLimit.requests - this.requestCount,\r\n      },\r\n      tokens: {\r\n        used: this.tokenCount,\r\n        limit: this.dailyLimit.tokens,\r\n        remaining: this.dailyLimit.tokens - this.tokenCount,\r\n      },\r\n    };\r\n  }\r\n}","usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\actions\\scrapeFoodTrucks.js","messages":[{"ruleId":"unicorn/no-empty-file","severity":2,"message":"Empty files are not allowed.","line":1,"column":1,"nodeType":"Program","messageId":"no-empty-file","endLine":1,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"","usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\actions\\scrapeFoodTrucks.ts","messages":[{"ruleId":"unicorn/no-empty-file","severity":2,"message":"Empty files are not allowed.","line":1,"column":1,"nodeType":"Program","messageId":"no-empty-file","endLine":1,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"","usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\activityLogger.js","messages":[],"suppressedMessages":[{"ruleId":"sonarjs/pseudo-random","severity":2,"message":"Make sure that using this pseudorandom number generator is safe here.","line":48,"column":12,"nodeType":"CallExpression","messageId":"safeGenerator","endLine":48,"endColumn":25,"suppressions":[{"kind":"directive","justification":"Math.random is acceptable for non-security-critical logging IDs."}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\activityLogger.ts","messages":[],"suppressedMessages":[{"ruleId":"sonarjs/pseudo-random","severity":2,"message":"Make sure that using this pseudorandom number generator is safe here.","line":58,"column":10,"nodeType":"CallExpression","messageId":"safeGenerator","endLine":58,"endColumn":23,"suppressions":[{"kind":"directive","justification":"Math.random is acceptable for non-security-critical logging IDs."}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\api\\admin\\automated-cleanup\\handlers.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\api\\admin\\automated-cleanup\\handlers.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":91,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":91,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2649,2652],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2649,2652],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .scheduleId on an `any` value.","line":92,"column":21,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":92,"endColumn":31},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":95,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":95,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2772,2775],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2772,2775],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .operations on an `any` value.","line":97,"column":10,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":97,"endColumn":20},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .operations on an `any` value.","line":97,"column":56,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":97,"endColumn":66},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .batchSize on an `any` value.","line":98,"column":10,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":98,"endColumn":19},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .batchSize on an `any` value.","line":98,"column":48,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":98,"endColumn":57},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .dryRun on an `any` value.","line":99,"column":10,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":99,"endColumn":16},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .dryRun on an `any` value.","line":99,"column":45,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":99,"endColumn":51},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":103,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":103,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3084,3087],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3084,3087],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .name on an `any` value.","line":105,"column":16,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":105,"endColumn":20},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .operations on an `any` value.","line":106,"column":23,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":106,"endColumn":33},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .schedule on an `any` value.","line":107,"column":16,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":107,"endColumn":24},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .enabled on an `any` value.","line":108,"column":10,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":108,"endColumn":17},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .enabled on an `any` value.","line":108,"column":46,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":108,"endColumn":53},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":112,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":112,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3369,3372],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3369,3372],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .scheduleId on an `any` value.","line":114,"column":16,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":114,"endColumn":26},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .updates on an `any` value.","line":115,"column":16,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":115,"endColumn":23},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":119,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":119,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3548,3551],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3548,3551],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .scheduleId on an `any` value.","line":120,"column":21,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":120,"endColumn":31}],"suppressedMessages":[],"errorCount":15,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { NextResponse } from 'next/server';\r\nimport { BatchCleanupService } from '@/lib/data-quality/batchCleanup';\r\n\r\ninterface CleanupSchedule {\r\n  id: string;\r\n  name: string;\r\n  operations: string[];\r\n  schedule: string; // cron expression\r\n  enabled: boolean;\r\n  lastRun?: string;\r\n  nextRun?: string;\r\n  successCount: number;\r\n  errorCount: number;\r\n}\r\n\r\ninterface CleanupResult {\r\n  id: string;\r\n  timestamp: string;\r\n  operation: string;\r\n  success: boolean;\r\n  details: Record<string, unknown>;\r\n}\r\n\r\ninterface RunScheduledOptions {\r\n  scheduleId: string;\r\n}\r\n\r\ninterface RunImmediateOptions {\r\n  operations?: string[];\r\n  batchSize?: number;\r\n  dryRun?: boolean;\r\n}\r\n\r\ninterface ScheduleCleanupOptions {\r\n  name: string;\r\n  operations: string[];\r\n  schedule: string;\r\n  enabled?: boolean;\r\n}\r\n\r\ninterface UpdateScheduleOptions {\r\n  scheduleId: string;\r\n  updates: Record<string, unknown>;\r\n}\r\n\r\ninterface DeleteScheduleOptions {\r\n  scheduleId: string;\r\n}\r\n\r\ninterface AnalyzeDuplicatesOptions {\r\n  threshold?: number;\r\n}\r\n\r\ninterface AutomatedCleanupStatus {\r\n  isRunning: boolean;\r\n  lastRun: string | null;\r\n  nextScheduledRun: string | null;\r\n  schedules: CleanupSchedule[];\r\n  recentResults: CleanupResult[];\r\n  statistics: {\r\n    totalRuns: number;\r\n    successfulRuns: number;\r\n    failedRuns: number;\r\n    trucksImproved: number;\r\n    duplicatesRemoved: number;\r\n  };\r\n}\r\n\r\ntype CleanupOperationType =\r\n  | 'normalize_phone'\r\n  | 'fix_coordinates'\r\n  | 'remove_placeholders'\r\n  | 'update_quality_scores'\r\n  | 'merge_duplicates';\r\n\r\n/**\r\n * Handles post requests by executing specific actions based on the provided body.\r\n * @example\r\n * handlePostRequest({ action: 'run_scheduled', options: { key: 'value' } })\r\n * Returns the result of executing handleRunScheduled with the provided options.\r\n * @param {Object} body - The body of the request containing action type and optional parameters.\r\n * @param {string} body.action - The action to perform such as 'run_scheduled', 'update_schedule', etc.\r\n * @param {Object} [body.options] - Optional parameters for the specified action, default is an empty object.\r\n * @returns {Promise<Object>} Resolves with the result of the corresponding action handler or an error object for unknown actions.\r\n * @description\r\n *   - Supports multiple predefined actions like scheduling, running, and cleanup operations.\r\n *   - Provides feedback on available actions when an unknown action is specified.\r\n *   - Uses async functions to perform operations, ensuring asynchronous behavior.\r\n *   - Returns JSON responses compliant with NextResponse standards.\r\n */\r\nfunction isRunScheduledOptions(obj: any): obj is RunScheduledOptions {\r\n  return typeof obj.scheduleId === \"string\";\r\n}\r\n\r\nfunction isRunImmediateOptions(obj: any): obj is RunImmediateOptions {\r\n  return (\r\n    (obj.operations === undefined || Array.isArray(obj.operations)) &&\r\n    (obj.batchSize === undefined || typeof obj.batchSize === \"number\") &&\r\n    (obj.dryRun === undefined || typeof obj.dryRun === \"boolean\")\r\n  );\r\n}\r\n\r\nfunction isScheduleCleanupOptions(obj: any): obj is ScheduleCleanupOptions {\r\n  return (\r\n    typeof obj.name === \"string\" &&\r\n    Array.isArray(obj.operations) &&\r\n    typeof obj.schedule === \"string\" &&\r\n    (obj.enabled === undefined || typeof obj.enabled === \"boolean\")\r\n  );\r\n}\r\n\r\nfunction isUpdateScheduleOptions(obj: any): obj is UpdateScheduleOptions {\r\n  return (\r\n    typeof obj.scheduleId === \"string\" &&\r\n    typeof obj.updates === \"object\"\r\n  );\r\n}\r\n\r\nfunction isDeleteScheduleOptions(obj: any): obj is DeleteScheduleOptions {\r\n  return typeof obj.scheduleId === \"string\";\r\n}\r\n\r\nexport async function handlePostRequest(body: {\r\n  action: string;\r\n  options?: Record<string, unknown>;\r\n}) {\r\n  const { action, options = {} } = body;\r\n\r\n  switch (action) {\r\n    case 'run_scheduled': {\r\n      if (!isRunScheduledOptions(options)) {\r\n        return NextResponse.json({ success: false, error: 'Invalid options for run_scheduled' }, { status: 400 });\r\n      }\r\n      return await handleRunScheduled(options);\r\n    }\r\n    case 'run_immediate': {\r\n      if (!isRunImmediateOptions(options)) {\r\n        return NextResponse.json({ success: false, error: 'Invalid options for run_immediate' }, { status: 400 });\r\n      }\r\n      return await handleRunImmediate(options);\r\n    }\r\n    case 'schedule_cleanup': {\r\n      if (!isScheduleCleanupOptions(options)) {\r\n        return NextResponse.json({ success: false, error: 'Invalid options for schedule_cleanup' }, { status: 400 });\r\n      }\r\n      return await handleScheduleCleanup(options);\r\n    }\r\n    case 'update_schedule': {\r\n      if (!isUpdateScheduleOptions(options)) {\r\n        return NextResponse.json({ success: false, error: 'Invalid options for update_schedule' }, { status: 400 });\r\n      }\r\n      return await handleUpdateSchedule(options);\r\n    }\r\n    case 'delete_schedule': {\r\n      if (!isDeleteScheduleOptions(options)) {\r\n        return NextResponse.json({ success: false, error: 'Invalid options for delete_schedule' }, { status: 400 });\r\n      }\r\n      return await handleDeleteSchedule(options);\r\n    }\r\n    default: {\r\n      return NextResponse.json(\r\n        {\r\n          success: false,\r\n          error: 'Unknown action',\r\n          available_actions: [\r\n            'run_scheduled',\r\n            'run_immediate',\r\n            'schedule_cleanup',\r\n            'update_schedule',\r\n            'delete_schedule',\r\n            'analyze_duplicates',\r\n          ],\r\n        },\r\n        { status: 400 },\r\n      );\r\n    }\r\n  }\r\n}\r\n\r\nexport async function handleGetStatus(): Promise<NextResponse> {\r\n  const status = await getCleanupStatus();\r\n  return NextResponse.json({\r\n    success: true,\r\n    status,\r\n  });\r\n}\r\n\r\nexport async function handleGetSchedules(): Promise<NextResponse> {\r\n  const schedules = await getCleanupSchedules();\r\n  return NextResponse.json({\r\n    success: true,\r\n    schedules,\r\n  });\r\n}\r\n\r\nexport async function handleGetHistory(searchParams: URLSearchParams): Promise<NextResponse> {\r\n  const limit = Number.parseInt(searchParams.get('limit') ?? '10', 10);\r\n  const history = await getCleanupHistory(limit);\r\n  return NextResponse.json({\r\n    success: true,\r\n    history,\r\n  });\r\n}\r\n\r\nexport async function handleGetPreview(searchParams: URLSearchParams): Promise<NextResponse> {\r\n  const operations = searchParams.get('operations')?.split(',') ?? [];\r\n  const preview = await previewCleanupOperations(operations);\r\n  return NextResponse.json({\r\n    success: true,\r\n    preview,\r\n  });\r\n}\r\n\r\n/**\r\n * Handles the retrieval of default cleanup status and returns a JSON response.\r\n * @example\r\n * handleGetDefault().then(response => console.log(response));\r\n * // { success: true, status: ..., endpoints: [...] }\r\n * @param {none} {none} - No arguments are required for this function.\r\n * @returns {Promise<NextResponse>} A promise that resolves to a NextResponse JSON object containing cleanup status and endpoints.\r\n * @description\r\n *   - Utilizes the getCleanupStatus function to fetch the current cleanup status.\r\n *   - Constructs a response object detailing available cleanup-related endpoints.\r\n *   - Follow API endpoint descriptions to properly utilize cleanup functionalities.\r\n */\r\nexport async function handleGetDefault(): Promise<NextResponse> {\r\n  const status = await getCleanupStatus();\r\n  return NextResponse.json({\r\n    success: true,\r\n    status,\r\n    endpoints: [\r\n      'GET ?action=status - Get overall cleanup status',\r\n      'GET ?action=schedules - Get cleanup schedules',\r\n      'GET ?action=history&limit=N - Get cleanup history',\r\n      'GET ?action=preview&operations=op1,op2 - Preview cleanup operations',\r\n      'POST - Run cleanup operations',\r\n    ],\r\n  });\r\n}\r\n\r\nexport async function handleRunScheduled(options: RunScheduledOptions): Promise<NextResponse> {\r\n  const { scheduleId } = options;\r\n  const result = await runScheduledCleanup(scheduleId);\r\n  return NextResponse.json({\r\n    success: true,\r\n    action: 'run_scheduled',\r\n    result,\r\n  });\r\n}\r\n\r\n/**\r\n* Executes a batch cleanup operation immediately based on provided options.\r\n* @example\r\n* handleRunImmediate({ dryRun: true, batchSize: 100 })\r\n* Returns: { success: true, action: 'run_immediate', result: {...}, message: 'Dry run completed successfully' }\r\n* @param {Object} options - Configuration options for the cleanup operation.\r\n* @returns {Promise<NextResponse>} A promise that resolves to the NextResponse object containing the cleanup result.\r\n* @description\r\n*   - The `operations` parameter defaults to a set of predefined cleanup tasks if not specified.\r\n*   - If `dryRun` is true, the function simulates the cleanup without making any modifications.\r\n*   - Utilizes `BatchCleanupService` for executing the cleanup logic.\r\n*   - Operation results are logged with `logCleanupOperation` for tracking purposes.\r\n*/\r\nexport async function handleRunImmediate(options: RunImmediateOptions): Promise<NextResponse> {\r\n  const {\r\n    operations = [\r\n      'remove_placeholders',\r\n      'normalize_phone',\r\n      'fix_coordinates',\r\n      'update_quality_scores',\r\n    ],\r\n    batchSize = 50,\r\n    dryRun = false,\r\n  } = options;\r\n\r\n  const result = await BatchCleanupService.runFullCleanup({\r\n    operations: operations as CleanupOperationType[],\r\n    batchSize,\r\n    dryRun,\r\n  });\r\n\r\n  await logCleanupOperation('immediate', result as unknown as Record<string, unknown>, options as unknown as Record<string, unknown>);\r\n\r\n  return NextResponse.json({\r\n    success: true,\r\n    action: 'run_immediate',\r\n    result,\r\n    message: dryRun ? 'Dry run completed successfully' : 'Cleanup completed successfully',\r\n  });\r\n}\r\n\r\nexport async function handleScheduleCleanup(\r\n  options: ScheduleCleanupOptions,\r\n): Promise<NextResponse> {\r\n  const { name, operations, schedule, enabled = true } = options;\r\n  const scheduleResult = await createCleanupSchedule(name, operations, schedule, enabled);\r\n  return NextResponse.json({\r\n    success: true,\r\n    action: 'schedule_cleanup',\r\n    result: scheduleResult,\r\n  });\r\n}\r\n\r\nexport async function handleUpdateSchedule(\r\n  options: UpdateScheduleOptions,\r\n): Promise<NextResponse> {\r\n  const { scheduleId, updates } = options;\r\n  const updateResult = await updateCleanupSchedule(scheduleId, updates);\r\n  return NextResponse.json({\r\n    success: true,\r\n    action: 'update_schedule',\r\n    result: updateResult,\r\n  });\r\n}\r\n\r\nexport async function handleDeleteSchedule(\r\n  options: DeleteScheduleOptions,\r\n): Promise<NextResponse> {\r\n  const { scheduleId } = options;\r\n  const deleteResult = await deleteCleanupSchedule(scheduleId);\r\n  return NextResponse.json({\r\n    success: true,\r\n    action: 'delete_schedule',\r\n    result: deleteResult,\r\n  });\r\n}\r\n\r\nexport async function handleAnalyzeDuplicates(\r\n  options: Record<string, unknown>,\r\n): Promise<NextResponse> {\r\n  const { threshold = 0.8 } = options as AnalyzeDuplicatesOptions;\r\n  const analysis = await analyzeDuplicates(threshold);\r\n  return NextResponse.json({\r\n    success: true,\r\n    action: 'analyze_duplicates',\r\n    result: analysis,\r\n  });\r\n}\r\n\r\n/**\r\n * Retrieves the status of automated cleanup operations.\r\n * @example\r\n * getCleanupStatus()\r\n * // returns: Promise<AutomatedCleanupStatus>\r\n * @returns {Promise<AutomatedCleanupStatus>} An object representing the status of cleanup operations.\r\n * @description\r\n *   - The status includes statistics on cleanup runs such as total number of runs, successful runs, and failed runs.\r\n *   - Provides information on whether a cleanup operation is currently running and when it last ran.\r\n *   - Fetches schedules asynchronously using the getCleanupSchedules() function.\r\n *   - Includes data on recent cleanup results and operations performed, such as the number of trucks improved and duplicates removed.\r\n */\r\nasync function getCleanupStatus(): Promise<AutomatedCleanupStatus> {\r\n  return {\r\n    isRunning: false,\r\n    lastRun: new Date(Date.now() - 3_600_000).toISOString(),\r\n    nextScheduledRun: new Date(Date.now() + 3_600_000).toISOString(),\r\n    schedules: await getCleanupSchedules(),\r\n    recentResults: [],\r\n    statistics: {\r\n      totalRuns: 42,\r\n      successfulRuns: 40,\r\n      failedRuns: 2,\r\n      trucksImproved: 156,\r\n      duplicatesRemoved: 23,\r\n    },\r\n  };\r\n}\r\n\r\n/**\r\n * Retrieves the scheduled cleanup operations including their details.\r\n * @example\r\n * getCleanupSchedules()\r\n * Promise resolves to an array of cleanup schedule objects.\r\n * @returns {Promise<CleanupSchedule[]>} Promise resolving to an array of cleanup schedule objects.\r\n * @description\r\n *   - Schedules are defined using cron-like syntax for timing.\r\n *   - Both daily and weekly cleanup operations are included.\r\n *   - Each schedule has a record of success and error counts from the last execution.\r\n *   - Each schedule has a record of success and error counts from the last execution.\r\n *   - Enabled status indicates if the schedule is currently active.\r\n */\r\nfunction getCleanupSchedules(): Promise<CleanupSchedule[]> {\r\n  return Promise.resolve([\r\n    {\r\n      id: 'daily-maintenance',\r\n      name: 'Daily Maintenance Cleanup',\r\n      operations: ['remove_placeholders', 'normalize_phone', 'update_quality_scores'],\r\n      schedule: '0 2 * * *',\r\n      enabled: true,\r\n      lastRun: new Date(Date.now() - 86_400_000).toISOString(),\r\n      nextRun: new Date(Date.now() + 3_600_000).toISOString(),\r\n      successCount: 30,\r\n      errorCount: 1,\r\n    },\r\n    {\r\n      id: 'weekly-deep-clean',\r\n      name: 'Weekly Deep Cleanup',\r\n      operations: [\r\n        'remove_placeholders',\r\n        'normalize_phone',\r\n        'fix_coordinates',\r\n        'update_quality_scores',\r\n        'merge_duplicates',\r\n      ],\r\n      schedule: '0 3 * * 0',\r\n      enabled: true,\r\n      lastRun: new Date(Date.now() - 604_800_000).toISOString(),\r\n      nextRun: new Date(Date.now() + 259_200_000).toISOString(),\r\n      successCount: 4,\r\n      errorCount: 0,\r\n    },\r\n  ]);\r\n}\r\n\r\nfunction getCleanupHistory(_limit: number): Promise<CleanupResult[]> {\r\n  return Promise.resolve([]);\r\n}\r\n\r\ninterface PreviewResult {\r\n  estimatedChanges: Record<string, unknown>;\r\n  operationDetails: Record<string, unknown>;\r\n  estimatedDuration: number;\r\n  affectedTrucks: number;\r\n}\r\n\r\n/**\r\n * Generates a preview of cleanup operations and their estimated impact.\r\n * @example\r\n * previewCleanupOperations(['delete_logs', 'archive_data'])\r\n * // Returns a Promise resolving to an object with estimated changes and operation details\r\n * @param {string[]} operations - An array of cleanup operation names to preview.\r\n * @returns {Promise<PreviewResult>} A promise that resolves to a preview result containing estimated changes and details.\r\n * @description\r\n *   - The function uses BatchCleanupService to simulate cleanup operations in a dry-run mode.\r\n *   - Each operation's details include types, descriptions, and counts of affected, successful, and erroneous items.\r\n *   - Returns comprehensive information including estimated changes, durations, and affected entities.\r\n */\r\nasync function previewCleanupOperations(operations: string[]): Promise<PreviewResult> {\r\n  try {\r\n    const result = await BatchCleanupService.runFullCleanup({\r\n      operations: operations as CleanupOperationType[],\r\n      batchSize: 10,\r\n      dryRun: true,\r\n    });\r\n\r\n    return {\r\n      estimatedChanges: result.summary as Record<string, unknown>,\r\n      operationDetails: (() => {\r\n        const details: Record<string, unknown> = {};\r\n        for (const [index, op] of result.operations.entries()) {\r\n          details[`operation_${index}`] = {\r\n            type: op.type,\r\n            description: op.description,\r\n            affectedCount: op.affectedCount,\r\n            successCount: op.successCount,\r\n            errorCount: op.errorCount,\r\n          };\r\n        }\r\n        return details;\r\n      })(),\r\n      estimatedDuration: result.duration,\r\n      affectedTrucks: result.totalProcessed,\r\n    };\r\n  } catch (error) {\r\n    throw new Error(`Preview failed: ${error instanceof Error ? error.message : 'Unknown error'}`);\r\n  }\r\n}\r\n\r\n/**\r\n * Executes a cleanup based on a given schedule ID.\r\n * @example\r\n * runScheduledCleanup('schedule123')\r\n * { success: true, cleanedRecords: 150 }\r\n * @param {string} scheduleId - The ID of the cleanup schedule to run.\r\n * @returns {Promise<Record<string, unknown>>} Result of the cleanup operation.\r\n * @description\r\n *   - Throws an error if the schedule is not found or is disabled.\r\n *   - Utilizes BatchCleanupService for performing the cleanup operation.\r\n *   - Logs the result of the cleanup operation with a 'scheduled' context.\r\n */\r\nasync function runScheduledCleanup(scheduleId: string): Promise<Record<string, unknown>> {\r\n  const schedules = await getCleanupSchedules();\r\n  const schedule = schedules.find((s) => s.id === scheduleId);\r\n\r\n  if (!schedule) {\r\n    throw new Error(`Schedule ${scheduleId} not found`);\r\n  }\r\n\r\n  if (!schedule.enabled) {\r\n    throw new Error(`Schedule ${scheduleId} is disabled`);\r\n  }\r\n\r\n  const result = await BatchCleanupService.runFullCleanup({\r\n    operations: schedule.operations as CleanupOperationType[],\r\n    batchSize: 50,\r\n    dryRun: false,\r\n  });\r\n\r\n  await logCleanupOperation('scheduled', result as unknown as Record<string, unknown>, { scheduleId });\r\n\r\nreturn result as unknown as Record<string, unknown>;\r\n}\r\n\r\ninterface ScheduleCreateResult {\r\n  id: string;\r\n  name: string;\r\n  operations: string[];\r\n  schedule: string;\r\n  enabled: boolean;\r\n  created: string;\r\n}\r\n\r\ninterface ScheduleUpdateResult {\r\n  scheduleId: string;\r\n  updates: Record<string, unknown>;\r\n  updated: string;\r\n}\r\n\r\ninterface ScheduleDeleteResult {\r\n  scheduleId: string;\r\n  deleted: string;\r\n}\r\n\r\ninterface DuplicateAnalysisResult {\r\n  threshold: number;\r\n  potentialDuplicates: number;\r\n  highConfidenceMatches: number;\r\n  mediumConfidenceMatches: number;\r\n  lowConfidenceMatches: number;\r\n  analysisTime: string;\r\n}\r\n\r\n/**\r\n* Creates a cleanup schedule with the specified parameters\r\n* @example\r\n* createCleanupSchedule('Daily Cleanup', ['delete', 'archive'], '0 0 * * *', true)\r\n* Promise<ScheduleCreateResult> { id: 'schedule-1609459200000', name: 'Daily Cleanup', operations: ['delete', 'archive'], schedule: '0 0 * * *', enabled: true, created: '2021-01-01T00:00:00.000Z' }\r\n* @param {string} name - The name of the cleanup schedule.\r\n* @param {Array<string>} operations - List of operations to be included in the cleanup.\r\n* @param {string} schedule - Cron-style string for schedule timings.\r\n* @param {boolean} enabled - Status of whether the schedule is active.\r\n* @returns {Promise<ScheduleCreateResult>} Promise resolving to the details of the created schedule.\r\n* @description \r\n*   - Returns a Promise that resolves to a ScheduleCreateResult object.\r\n*   - Automatically generates a unique ID based on the current timestamp.\r\n*   - Includes a creation timestamp in ISO format.\r\n*/\r\nfunction createCleanupSchedule(\r\n  name: string,\r\n  operations: string[],\r\n  schedule: string,\r\n  enabled: boolean,\r\n): Promise<ScheduleCreateResult> {\r\n  return Promise.resolve({\r\n    id: `schedule-${Date.now()}`,\r\n    name,\r\n    operations,\r\n    schedule,\r\n    enabled,\r\n    created: new Date().toISOString(),\r\n  });\r\n}\r\n\r\nfunction updateCleanupSchedule(\r\n  scheduleId: string,\r\n  updates: Record<string, unknown>,\r\n): Promise<ScheduleUpdateResult> {\r\n  return Promise.resolve({\r\n    scheduleId,\r\n    updates,\r\n    updated: new Date().toISOString(),\r\n  });\r\n}\r\n\r\nfunction deleteCleanupSchedule(scheduleId: string): Promise<ScheduleDeleteResult> {\r\n  return Promise.resolve({\r\n    scheduleId,\r\n    deleted: new Date().toISOString(),\r\n  });\r\n}\r\n\r\n/**\r\n* Analyzes duplicates based on a given threshold and returns a summary of the analysis.\r\n* @example\r\n* analyzeDuplicates(0.8)\r\n* // Returns: { threshold: 0.8, potentialDuplicates: 0, highConfidenceMatches: 0, mediumConfidenceMatches: 0, lowConfidenceMatches: 0, analysisTime: \"2023-10-01T12:34:56.789Z\" }\r\n* @param {number} threshold - The threshold value used to determine duplicate matching confidence.\r\n* @returns {Promise<DuplicateAnalysisResult>} An object representing the duplicate analysis results including counts of potential matches and confidence levels.\r\n* @description\r\n*   - Executes the analysis asynchronously, returning a promise that resolves with the analysis results.\r\n*   - Initializes match counts to zero as defaults.\r\n*   - Includes the analysis time formatted as an ISO string.\r\n*/\r\nfunction analyzeDuplicates(threshold: number): Promise<DuplicateAnalysisResult> {\r\n  try {\r\n    return Promise.resolve({\r\n      threshold,\r\n      potentialDuplicates: 0,\r\n      highConfidenceMatches: 0,\r\n      mediumConfidenceMatches: 0,\r\n      lowConfidenceMatches: 0,\r\n      analysisTime: new Date().toISOString(),\r\n    });\r\n  } catch (error) {\r\n    throw new Error(\r\n      `Duplicate analysis failed: ${error instanceof Error ? error.message : 'Unknown error'}`,\r\n    );\r\n  }\r\n}\r\n\r\n/**\r\n * Logs the completion details of a cleanup operation.\r\n * @example\r\n * logCleanupOperation('database', {summary: {success: true}}, {verbose: true})\r\n * // No return value\r\n * @param {string} type - The type of cleanup operation performed (e.g., 'database').\r\n * @param {Record<string, unknown>} result - An object containing the results of the cleanup operation.\r\n * @param {Record<string, unknown>} options - Additional options related to the logging of the cleanup.\r\n * @returns {Promise<void>} A Promise that resolves when the logging is complete.\r\n * @description\r\n *   - Utilizes `console.info` for successful logging and `console.warn` for handling errors during logging.\r\n *   - Ensures the operation's details include the type, result summary, options, and a timestamp.\r\n */\r\nfunction logCleanupOperation(\r\n  type: string,\r\n  result: Record<string, unknown>,\r\n  options: Record<string, unknown>,\r\n): Promise<void> {\r\n  try {\r\n    console.info(`Cleanup operation completed:`, {\r\n      type,\r\n      result: result.summary as Record<string, unknown>,\r\n      options,\r\n      timestamp: new Date().toISOString(),\r\n    });\r\n    return Promise.resolve();\r\n  } catch (error) {\r\n    console.warn('Failed to log cleanup operation:', error);\r\n    return Promise.resolve();\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\api\\admin\\automated-cleanup\\types.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\api\\admin\\automated-cleanup\\types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\api\\admin\\data-cleanup\\handlers.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\api\\admin\\data-cleanup\\handlers.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\api\\admin\\data-quality\\handlers.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\api\\admin\\data-quality\\handlers.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":26,"column":12,"nodeType":"Identifier","messageId":"conditionErrorNullableString","endLine":26,"endColumn":19,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[1164,1172],"text":"truckId == null"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[1165,1172],"text":"(truckId ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[1164,1172],"text":"!Boolean(truckId)"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { NextRequest, NextResponse } from 'next/server';\r\nimport { FoodTruckService, type FoodTruck } from '@/lib/supabase';\r\n\r\n/**\r\n * Handles GET requests by executing different actions based on query parameters.\r\n * @example\r\n * handleGetRequest(request)\r\n * Returns a response based on the action specified in the query parameters.\r\n * @param {NextRequest} request - The incoming request object containing URL and query parameters.\r\n * @returns {Promise<NextResponse>} A Promise resolving to a NextResponse object with the result of the action.\r\n * @description\r\n *   - Processes 'stats', 'assess', and defaults actions based on the 'action' query parameter.\r\n *   - Requires 'truckId' for the 'assess' action; otherwise, returns a 400 error.\r\n *   - Utilizes async handling for processing actions.\r\n */\r\nexport async function handleGetRequest(request: NextRequest): Promise<NextResponse> {\r\n  const { searchParams } = new URL(request.url);\r\n  const action = searchParams.get('action');\r\n  const truckId = searchParams.get('truckId');\r\n\r\n  switch (action) {\r\n    case 'stats': {\r\n      return await handleStatsAction();\r\n    }\r\n    case 'assess': {\r\n      if (!truckId) {\r\n        return NextResponse.json(\r\n          { success: false, error: 'Missing truckId for assess action' },\r\n          { status: 400 },\r\n        );\r\n      }\r\n      return await handleAssessAction(truckId);\r\n    }\r\n    default: {\r\n      return await handleDefaultGetAction();\r\n    }\r\n  }\r\n}\r\n\r\ninterface PostRequestBody {\r\n  action: string;\r\n  truckId?: string;\r\n}\r\n\r\n/**\r\n* Handles different types of POST requests by determining the action and executing appropriate functions.\r\n* @example\r\n* handlePostRequest(request)\r\n* NextResponse containing success status and result or error message\r\n* @param {NextRequest} request - Incoming request object containing body data as JSON.\r\n* @returns {Promise<NextResponse>} Response indicating success or failure and any relevant data or error messages.\r\n* @description\r\n*   - Validates request body to ensure it's a non-null object.\r\n*   - Extracts action and truckId from request body to decide on processing steps.\r\n*   - Handles actions like \"update-single\", \"batch-update\", and \"recalculate-all\", returning an appropriate NextResponse.\r\n*   - Responds with an error JSON if the action is unknown or if required fields are missing.\r\n*/\r\nexport async function handlePostRequest(request: NextRequest): Promise<NextResponse> {\r\n  const body: unknown = await request.json();\r\n\r\n  if (typeof body !== 'object' || body === null) {\r\n    return NextResponse.json({ success: false, error: 'Invalid request body' }, { status: 400 });\r\n  }\r\n\r\n  const { action, truckId } = body as PostRequestBody;\r\n\r\n  switch (action) {\r\n    case 'update-single': {\r\n      if (truckId === undefined || truckId === '') {\r\n        return NextResponse.json(\r\n          { success: false, error: 'Missing truckId for update-single action' },\r\n          { status: 400 },\r\n        );\r\n      }\r\n      return await handleUpdateSingle(truckId);\r\n    }\r\n    case 'batch-update': {\r\n      return handleBatchUpdate();\r\n    }\r\n    case 'recalculate-all': {\r\n      return await handleRecalculateAll();\r\n    }\r\n    default: {\r\n      return NextResponse.json(\r\n        { success: false, error: `Unknown action: ${action}` },\r\n        { status: 400 },\r\n      );\r\n    }\r\n  }\r\n}\r\n\r\nasync function handleStatsAction() {\r\n  const qualityStats = await FoodTruckService.getDataQualityStats();\r\n\r\n  return NextResponse.json({\r\n    success: true,\r\n    data: {\r\n      ...qualityStats,\r\n      timestamp: new Date().toISOString(),\r\n    },\r\n  });\r\n}\r\n\r\n/**\r\n * Processes and returns the assessment result of a food truck action by its ID.\r\n * @example\r\n * handleAssessAction(\"12345\")\r\n * { success: true, data: { truckId: \"12345\", truckName: \"Best Food Truck\", currentScore: 95, timestamp: \"2023-10-05T14:48:00.000Z\" } }\r\n * @param {string} truckId - The identifier of the food truck to be assessed.\r\n * @returns {object} Returns a JSON response containing either the assessment data or an error.\r\n * @description\r\n *   - Retrieves data of the specified food truck using FoodTruckService.\r\n *   - Casts the retrieved data explicitly to a FoodTruck object type to ensure type safety.\r\n *   - Responds with a 404 status and the error description if the truck is not found.\r\n */\r\nasync function handleAssessAction(truckId: string) {\r\n  const truckResult = await FoodTruckService.getTruckById(truckId);\r\n\r\n  if ('error' in truckResult) {\r\n    return NextResponse.json({ success: false, error: truckResult.error }, { status: 404 });\r\n  }\r\n\r\n  const truck: FoodTruck = truckResult; // Explicitly cast to FoodTruck\r\n\r\n  return NextResponse.json({\r\n    success: true,\r\n    data: {\r\n      truckId,\r\n      truckName: truck.name,\r\n      currentScore: truck.data_quality_score,\r\n      timestamp: new Date().toISOString(),\r\n    },\r\n  });\r\n}\r\n\r\nasync function handleDefaultGetAction() {\r\n  const qualityStats = await FoodTruckService.getDataQualityStats();\r\n  return NextResponse.json({\r\n    success: true,\r\n    data: qualityStats,\r\n  });\r\n}\r\n\r\n/**\r\n * Handles updating a single food truck's quality score and returns the result.\r\n * @example\r\n * handleUpdateSingle(\"1234\")\r\n * { success: true, message: 'Quality score updated successfully', data: { truckId: '1234', truckName: 'Food Truck A', newScore: 95, verificationStatus: 'verified', timestamp: '2023-10-30T14:48:00.000Z' } }\r\n * @param {string} truckId - The unique identifier of the food truck to update.\r\n * @returns {Object} An object containing the success status, message, and either updated truck data or error information.\r\n * @description\r\n *   - Utilizes `FoodTruckService.getTruckById` to fetch truck details.\r\n *   - Responds differently based on whether an error is encountered or not.\r\n *   - Formats the response appropriately for successful updates.\r\n *   - Includes a timestamp in the response when successful.\r\n */\r\nasync function handleUpdateSingle(truckId: string) {\r\n  const updatedTruckResult = await FoodTruckService.getTruckById(truckId);\r\n\r\n  if ('error' in updatedTruckResult) {\r\n    return NextResponse.json({ success: false, error: updatedTruckResult.error }, { status: 404 });\r\n  }\r\n\r\n  const updatedTruck = updatedTruckResult;\r\n\r\n  return NextResponse.json({\r\n    success: true,\r\n    message: 'Quality score updated successfully',\r\n    data: {\r\n      truckId: updatedTruck.id,\r\n      truckName: updatedTruck.name,\r\n      newScore: updatedTruck.data_quality_score,\r\n      verificationStatus: updatedTruck.verification_status,\r\n      timestamp: new Date().toISOString(),\r\n    },\r\n  });\r\n}\r\n\r\nfunction handleBatchUpdate() {\r\n  return NextResponse.json({\r\n    success: true,\r\n    message: 'Batch quality score update completed',\r\n    data: {\r\n      timestamp: new Date().toISOString(),\r\n    },\r\n  });\r\n}\r\n\r\nfunction updateSingleTruckQualityScore(truck: { id: string }): boolean {\r\n  try {\r\n    // Placeholder for actual update logic if needed\r\n    // DataQualityService.updateTruckQualityScore(truck.id);\r\n    return true;\r\n  } catch (error: unknown) {\r\n    console.error(`Failed to update truck ${truck.id}:`, error);\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * Recalculates the quality score for all food trucks.\r\n * @example\r\n * handleRecalculateAll()\r\n * { success: true, message: 'Quality score recalculation completed', data: { totalTrucks: 100, updated: 95, errors: 5, timestamp: '2023-10-07T10:30:00.000Z' } }\r\n * @param {undefined} undefined - No arguments are needed.\r\n * @returns {Object} JSON response with success status, message, and data containing recalculation statistics.\r\n * @description\r\n *   - Fetches all food trucks in batches for recalculation using the FoodTruckService.\r\n *   - Logs an error message if the API call to fetch all trucks fails.\r\n *   - Updates the `qualityScore` for each truck and maintains a count of successful and unsuccessful updates.\r\n */\r\nasync function handleRecalculateAll() {\r\n  const allTrucksResult = await FoodTruckService.getAllTrucks(1000, 0);\r\n  if (allTrucksResult.error !== undefined) {\r\n    console.error('Error fetching all trucks for recalculation:', allTrucksResult.error);\r\n    return NextResponse.json(\r\n      { success: false, error: 'Failed to fetch trucks for recalculation' },\r\n      { status: 500 },\r\n    );\r\n  }\r\n  const { trucks } = allTrucksResult;\r\n  let updated = 0;\r\n  let errors = 0;\r\n\r\n  for (const truck of trucks) {\r\n    const success = updateSingleTruckQualityScore(truck);\r\n    if (success) {\r\n      updated+=1;\r\n    } else {\r\n      errors+=1;\r\n    }\r\n  }\r\n\r\n  return NextResponse.json({\r\n    success: true,\r\n    message: 'Quality score recalculation completed',\r\n    data: {\r\n      totalTrucks: trucks.length,\r\n      updated,\r\n      errors,\r\n      timestamp: new Date().toISOString(),\r\n    },\r\n  });\r\n}","usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\api\\admin\\oauth-status\\helpers.js","messages":[{"ruleId":null,"message":"Unused eslint-disable directive (no problems were reported from 'sonarjs/different-types-comparison').","line":286,"column":5,"severity":1,"nodeType":null,"fix":{"range":[13324,13386],"text":" "}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import { NextResponse } from 'next/server';\r\nimport { supabase } from '../../../../lib/supabase.js';\r\n/**\r\n * Handles a GET request to retrieve OAuth configuration status.\r\n * @example\r\n * handleGetRequest(request)\r\n * Returns a JSON response with OAuth status details and legacy format.\r\n * @param {NextRequest} _request - The incoming request object.\r\n * @returns {NextResponse} JSON response indicating the current OAuth status.\r\n * @description\r\n *   - Retrieves the current OAuth configuration status from the server.\r\n *   - Adapts the response to include both modern and legacy format details.\r\n *   - Provides a step-by-step legacy configuration guide if OAuth is not ready.\r\n */\r\nexport async function handleGetRequest(_request) {\r\n    const status = await getOAuthStatus();\r\n    return NextResponse.json({\r\n        success: true,\r\n        ...status,\r\n        legacy_format: {\r\n            oauth_status: status.overall_status,\r\n            message: getStatusMessage(status.overall_status),\r\n            configuration_steps: status.overall_status === 'ready'\r\n                ? undefined\r\n                : [\r\n                    '1. Go to Supabase Dashboard > Authentication > Providers',\r\n                    '2. Enable Google provider',\r\n                    '3. Add Google OAuth Client ID and Secret',\r\n                    '4. Configure redirect URLs',\r\n                    '5. Test OAuth flow',\r\n                ],\r\n        },\r\n    });\r\n}\r\n// 1. Refactor nested template literals in generateOAuthTestUrl\r\nfunction generateOAuthTestUrl(baseUrl) {\r\n    const redirectPath = `${baseUrl}/auth/callback`;\r\n    const encodedRedirect = encodeURIComponent(redirectPath);\r\n    return (process.env.NEXT_PUBLIC_SUPABASE_URL +\r\n        '/auth/v1/authorize?provider=google&redirect_to=' +\r\n        encodedRedirect);\r\n}\r\n/**\r\n * Handles a post request to generate an OAuth test URL based on the environment.\r\n * @example\r\n * handlePostRequest()\r\n * {\r\n *   success: true,\r\n *   message: 'OAuth test URL generated',\r\n *   test_url: 'http://localhost:3000/...',\r\n *   environment: 'development',\r\n *   instructions: [ ... ],\r\n *   manual_test_steps: [ ... ],\r\n *   automation_commands: [ ... ]\r\n * }\r\n * @returns {object} An object containing success status, message, the test URL, the environment, instructions, manual test steps, and automation commands.\r\n * @description\r\n *   - Determines the base URL depending on whether the environment is production or development.\r\n *   - Utilizes `generateOAuthTestUrl` to construct the OAuth test URL.\r\n *   - Responds with JSON containing test instructions and automation commands for verifying OAuth functionality.\r\n */\r\nexport function handlePostRequest() {\r\n    // Removed _request parameter\r\n    const baseUrl = process.env.NODE_ENV === 'production'\r\n        ? 'https://food-truck-finder-poc-git-feat-s-20ec1c-codedeficients-projects.vercel.app'\r\n        : 'http://localhost:3000';\r\n    const testUrl = generateOAuthTestUrl(baseUrl);\r\n    return NextResponse.json({\r\n        success: true,\r\n        message: 'OAuth test URL generated',\r\n        test_url: testUrl,\r\n        environment: process.env.NODE_ENV ?? 'development',\r\n        instructions: [\r\n            '1. Open the test_url in a new browser tab',\r\n            '2. Complete Google OAuth flow',\r\n            '3. Verify redirect to admin dashboard',\r\n            '4. Check for proper role assignment',\r\n        ],\r\n        manual_test_steps: [\r\n            'Navigate to /login page',\r\n            'Click Google login button',\r\n            'Complete OAuth flow',\r\n            'Verify admin access',\r\n        ],\r\n        automation_commands: [\r\n            'npm run oauth:verify - Check configuration',\r\n            'npm run oauth:test:dev - Test development flow',\r\n            'npm run oauth:test:prod - Test production flow',\r\n        ],\r\n    });\r\n}\r\n/**\r\n * Retrieves the current OAuth status including configuration and connectivity information.\r\n * @example\r\n * getOAuthStatus().then(status => {\r\n *   console.log(status);\r\n * });\r\n * // Output: OAuthStatus object with current configuration and connection status details\r\n * @returns {Promise<OAuthStatus>} An object representing the current status of OAuth configuration and connectivity.\r\n * @description\r\n *   - The function assesses the connectivity and configuration of Supabase and its authentication settings.\r\n *   - It checks if the necessary environment variables are set.\r\n *   - Executes a series of asynchronous checks to determine if the OAuth provider is properly configured.\r\n *   - Recommendations for improving the OAuth setup are generated based on the current status.\r\n */\r\nasync function getOAuthStatus() {\r\n    const status = {\r\n        timestamp: new Date().toISOString(),\r\n        environment: process.env.NODE_ENV === 'production' ? 'production' : 'development',\r\n        supabase: {\r\n            connected: false,\r\n            projectId: 'zkwliyjjkdnigizidlln',\r\n        },\r\n        environment_variables: {\r\n            supabaseUrl: process.env.NEXT_PUBLIC_SUPABASE_URL !== undefined,\r\n            supabaseAnonKey: process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY !== undefined,\r\n            supabaseServiceKey: process.env.SUPABASE_SERVICE_ROLE_KEY !== undefined,\r\n        },\r\n        oauth_flow: {\r\n            loginPageExists: true,\r\n            callbackRouteExists: true,\r\n            authProviderConfigured: false,\r\n        },\r\n        recommendations: [],\r\n        overall_status: 'not_configured',\r\n    };\r\n    await checkSupabaseConnection(status, supabase);\r\n    await checkSupabaseAuthSettings(status);\r\n    await testOAuthProvider(status, supabase);\r\n    status.recommendations = generateRecommendations(status);\r\n    status.overall_status = determineOverallStatus(status);\r\n    return status;\r\n}\r\n/**\r\n * Checks the connection status with Supabase and updates the `OAuthStatus`.\r\n * @example\r\n * checkSupabaseConnection(status, supabase)\r\n * // Updates the `status.supabase.connected` property based on connection success\r\n * @param {OAuthStatus} status - The current OAuthStatus object that tracks connection state and errors.\r\n * @param {SupabaseClient} supabase - The Supabase client instance used to interact with the database.\r\n * @returns {void} No explicit return value, operates directly on the `status` object.\r\n * @description\r\n *   - Attempts a query to the 'profiles' table to ensure Supabase connection.\r\n *   - Updates `status.supabase.connected` based on query success.\r\n *   - Captures and records detailed error messages in case of connection failure.\r\n */\r\nasync function checkSupabaseConnection(status, supabase) {\r\n    try {\r\n        const { error } = await supabase.from('profiles').select('count').limit(1);\r\n        if (error === null) {\r\n            status.supabase.connected = true;\r\n        }\r\n        else {\r\n            status.supabase.error = error.message;\r\n        }\r\n    }\r\n    catch (error) {\r\n        status.supabase.error = error instanceof Error ? error.message : 'Unknown connection error';\r\n    }\r\n}\r\n/**\r\n * Checks and processes Supabase authentication settings.\r\n * @example\r\n * checkSupabaseAuthSettings(oAuthStatusInstance)\r\n * { supabase: { authSettings: { googleEnabled: true, signupEnabled: false, autoconfirm: true } } }\r\n * @param {OAuthStatus} status - An object that holds OAuth configuration status.\r\n * @returns {void} Modifies the passed status object with fetched authentication settings.\r\n * @description\r\n *   - The function fetches authentication settings from the Supabase URL defined in environment variables.\r\n *   - If Supabase settings are fetched successfully, it updates the OAuth status with authentication settings like Google integration, signup availability, and autoconfirm feature.\r\n *   - Provides a fallback log for cases where fetching settings require authentication.\r\n */\r\nasync function checkSupabaseAuthSettings(status) {\r\n    try {\r\n        const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;\r\n        if (typeof supabaseUrl === 'string' && supabaseUrl.length > 0) {\r\n            // Explicit check for undefined and empty string\r\n            const settingsResponse = await fetch(`${supabaseUrl}/auth/v1/settings`);\r\n            if (settingsResponse.ok === true) {\r\n                const settings = (await settingsResponse.json());\r\n                status.supabase.authSettings = {\r\n                    googleEnabled: settings.external?.google ?? false,\r\n                    signupEnabled: settings.disable_signup === false,\r\n                    autoconfirm: settings.autoconfirm ?? false,\r\n                };\r\n                if (settings.external?.google !== undefined) {\r\n                    // Explicit check for undefined\r\n                    status.oauth_flow.authProviderConfigured = true;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    catch {\r\n        console.info('Auth settings endpoint requires authentication (normal)');\r\n    }\r\n}\r\n/**\r\n * Tests the configuration of an OAuth provider and updates the status based on the result.\r\n * @example\r\n * testOAuthProvider(status, supabase)\r\n * undefined\r\n * @param {OAuthStatus} status - An object representing the current OAuth status and configuration.\r\n * @param {SupabaseClient} supabase - The Supabase client instance used to interact with the authentication system.\r\n * @returns {void} Does not return any value.\r\n * @description\r\n *   - Utilizes Google as the OAuth provider for the sign-in attempt.\r\n *   - Redirects to a localhost callback URL to simulate the OAuth process.\r\n *   - Direct usage of the Supabase auth method to initiate OAuth process.\r\n *   - Handles exceptions without altering the control flow and logs them for informational purposes.\r\n */\r\nasync function testOAuthProvider(status, supabase) {\r\n    try {\r\n        const { error: oauthError } = await supabase.auth.signInWithOAuth({\r\n            provider: 'google',\r\n            options: {\r\n                redirectTo: 'http://localhost:3000/auth/callback',\r\n                skipBrowserRedirect: true,\r\n            },\r\n        });\r\n        if (oauthError !== null && oauthError.message !== 'Provider not found') {\r\n            // Explicitly check for oauthError existence\r\n            status.oauth_flow.authProviderConfigured = true;\r\n        }\r\n    }\r\n    catch (error) {\r\n        console.info('OAuth provider test failed (may be normal):', error);\r\n    }\r\n}\r\n/**\r\n * Generates a list of recommendations for OAuth configuration based on the current status.\r\n * @example\r\n * generateRecommendations(status)\r\n * ['❌ Configure NEXT_PUBLIC_SUPABASE_URL environment variable', ...]\r\n * @param {OAuthStatus} status - The current status of OAuth configuration and environment variables.\r\n * @returns {string[]} Array of recommendation messages to guide configuration setup.\r\n * @description\r\n *   - Checks for necessary environment variables and Supabase connectivity.\r\n *   - Provides guidance on enabling Google OAuth.\r\n *   - Suggests consulting documentation for further setup instructions.\r\n */\r\nfunction generateRecommendations(status) {\r\n    const recommendations = [];\r\n    if (!status.environment_variables.supabaseUrl) {\r\n        recommendations.push('❌ Configure NEXT_PUBLIC_SUPABASE_URL environment variable');\r\n    }\r\n    if (!status.environment_variables.supabaseAnonKey) {\r\n        recommendations.push('❌ Configure NEXT_PUBLIC_SUPABASE_ANON_KEY environment variable');\r\n    }\r\n    if (!status.environment_variables.supabaseServiceKey) {\r\n        recommendations.push('❌ Configure SUPABASE_SERVICE_ROLE_KEY environment variable');\r\n    }\r\n    if (!status.supabase.connected) {\r\n        recommendations.push('❌ Fix Supabase connection issue');\r\n        if (typeof status.supabase.error === 'string' && status.supabase.error.length > 0) {\r\n            recommendations.push(`   Error: ${status.supabase.error}`);\r\n        }\r\n    }\r\n    if (status.supabase.authSettings?.googleEnabled === true) {\r\n        recommendations.push('✅ Google OAuth provider is enabled');\r\n    }\r\n    else {\r\n        recommendations.push('🔧 Enable Google OAuth provider in Supabase Dashboard', '   Go to: Authentication > Providers > Google');\r\n    }\r\n    if (status.overall_status === 'ready') {\r\n        recommendations.push('🎉 OAuth configuration is complete!', '✅ Test the login flow at /login');\r\n    }\r\n    if (recommendations.length > 1) {\r\n        recommendations.push('📖 See docs/GOOGLE_OAUTH_SETUP_GUIDE.md for detailed instructions', '🔧 Run: npm run oauth:verify for automated checks');\r\n    }\r\n    return recommendations;\r\n}\r\n/**\r\n * Determines the overall OAuth status based on provided conditions.\r\n * @example\r\n * determineOverallStatus(status)\r\n * 'ready'\r\n * @param {OAuthStatus} status - The status object containing configuration details.\r\n * @returns {'ready' | 'partial' | 'not_configured' | 'error'} Overall status derived from the evaluations.\r\n * @description\r\n *   - Evaluates connectivity and configuration status from various parameters within the status object.\r\n *   - Prioritizes returning 'error' if Supabase connection fails or if an error is detected.\r\n *   - Checks completeness of environment variables before proceeding to other status evaluations.\r\n *   - Distinguishes between 'ready' and 'partial' based on specific OAuth settings.\r\n */\r\nfunction determineOverallStatus(status) {\r\n    // eslint-disable-next-line sonarjs/different-types-comparison\r\n    if (!status.supabase.connected || status.supabase.error !== null) {\r\n        return 'error';\r\n    }\r\n    const envVarsComplete = Object.values(status.environment_variables).every(Boolean);\r\n    if (!envVarsComplete) {\r\n        return 'not_configured';\r\n    }\r\n    if (status.supabase.authSettings?.googleEnabled && status.oauth_flow.authProviderConfigured) {\r\n        return 'ready';\r\n    }\r\n    if (status.supabase.connected && envVarsComplete) {\r\n        return 'partial';\r\n    }\r\n    return 'not_configured';\r\n}\r\n/**\r\n * Retrieves a human-readable message based on the OAuth configuration status.\r\n * @example\r\n * getStatusMessage('ready')\r\n * 'Google OAuth is fully configured and ready to use'\r\n * @param {string} status - The current status of the OAuth configuration.\r\n * @returns {string} A message explaining the OAuth configuration status.\r\n * @description\r\n *   - Handles several predefined status cases.\r\n *   - Provides feedback for both success and error states.\r\n *   - Returns a default message for unrecognized statuses.\r\n */\r\nfunction getStatusMessage(status) {\r\n    switch (status) {\r\n        case 'ready': {\r\n            return 'Google OAuth is fully configured and ready to use';\r\n        }\r\n        case 'partial': {\r\n            return 'Basic configuration complete, OAuth provider needs setup';\r\n        }\r\n        case 'not_configured': {\r\n            return 'Google OAuth is not configured';\r\n        }\r\n        case 'error': {\r\n            return 'Configuration error detected';\r\n        }\r\n        default: {\r\n            return 'Unknown configuration status';\r\n        }\r\n    }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\api\\admin\\oauth-status\\helpers.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":334,"column":7,"nodeType":"ChainExpression","messageId":"conditionErrorNullableBoolean","endLine":334,"endColumn":50,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[13706,13749],"text":"((status.supabase.authSettings?.googleEnabled) ?? false)"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[13706,13749],"text":"((status.supabase.authSettings?.googleEnabled) === true)"},"desc":"Change condition to check if true (`value === true`)"}]}],"suppressedMessages":[{"ruleId":"sonarjs/different-types-comparison","severity":2,"message":"Remove this \"!==\" check; it will always be true. Did you mean to use \"!=\"?","line":325,"column":59,"nodeType":null,"endLine":325,"endColumn":62,"suggestions":[{"desc":"Replace \"!==\" with \"!=\"","fix":{"range":[13508,13511],"text":"!="}}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { NextRequest, NextResponse } from 'next/server';\r\nimport { supabase } from '@/lib/supabase';\r\nimport type { OAuthStatus } from './types';\r\nimport type { SupabaseClient } from '@supabase/supabase-js';\r\n\r\n/**\r\n * Handles a GET request to retrieve OAuth configuration status.\r\n * @example\r\n * handleGetRequest(request)\r\n * Returns a JSON response with OAuth status details and legacy format.\r\n * @param {NextRequest} _request - The incoming request object.\r\n * @returns {NextResponse} JSON response indicating the current OAuth status.\r\n * @description\r\n *   - Retrieves the current OAuth configuration status from the server.\r\n *   - Adapts the response to include both modern and legacy format details.\r\n *   - Provides a step-by-step legacy configuration guide if OAuth is not ready.\r\n */\r\nexport async function handleGetRequest(_request: NextRequest) {\r\n  const status = await getOAuthStatus();\r\n\r\n  return NextResponse.json({\r\n    success: true,\r\n    ...status,\r\n    legacy_format: {\r\n      oauth_status: status.overall_status,\r\n      message: getStatusMessage(status.overall_status),\r\n      configuration_steps:\r\n        status.overall_status === 'ready'\r\n          ? undefined\r\n          : [\r\n              '1. Go to Supabase Dashboard > Authentication > Providers',\r\n              '2. Enable Google provider',\r\n              '3. Add Google OAuth Client ID and Secret',\r\n              '4. Configure redirect URLs',\r\n              '5. Test OAuth flow',\r\n            ],\r\n    },\r\n  });\r\n}\r\n\r\n// 1. Refactor nested template literals in generateOAuthTestUrl\r\nfunction generateOAuthTestUrl(baseUrl: string): string {\r\n  const redirectPath = `${baseUrl}/auth/callback`;\r\n  const encodedRedirect = encodeURIComponent(redirectPath);\r\n  return (\r\n    process.env.NEXT_PUBLIC_SUPABASE_URL +\r\n    '/auth/v1/authorize?provider=google&redirect_to=' +\r\n    encodedRedirect\r\n  );\r\n}\r\n\r\n/**\r\n * Handles a post request to generate an OAuth test URL based on the environment.\r\n * @example\r\n * handlePostRequest()\r\n * {\r\n *   success: true,\r\n *   message: 'OAuth test URL generated',\r\n *   test_url: 'http://localhost:3000/...',\r\n *   environment: 'development',\r\n *   instructions: [ ... ],\r\n *   manual_test_steps: [ ... ],\r\n *   automation_commands: [ ... ]\r\n * }\r\n * @returns {object} An object containing success status, message, the test URL, the environment, instructions, manual test steps, and automation commands.\r\n * @description\r\n *   - Determines the base URL depending on whether the environment is production or development.\r\n *   - Utilizes `generateOAuthTestUrl` to construct the OAuth test URL.\r\n *   - Responds with JSON containing test instructions and automation commands for verifying OAuth functionality.\r\n */\r\nexport function handlePostRequest() {\r\n  // Removed _request parameter\r\n  const baseUrl =\r\n    process.env.NODE_ENV === 'production'\r\n      ? 'https://food-truck-finder-poc-git-feat-s-20ec1c-codedeficients-projects.vercel.app'\r\n      : 'http://localhost:3000';\r\n\r\n  const testUrl = generateOAuthTestUrl(baseUrl);\r\n\r\n  return NextResponse.json({\r\n    success: true,\r\n    message: 'OAuth test URL generated',\r\n    test_url: testUrl,\r\n    environment: process.env.NODE_ENV ?? 'development',\r\n    instructions: [\r\n      '1. Open the test_url in a new browser tab',\r\n      '2. Complete Google OAuth flow',\r\n      '3. Verify redirect to admin dashboard',\r\n      '4. Check for proper role assignment',\r\n    ],\r\n    manual_test_steps: [\r\n      'Navigate to /login page',\r\n      'Click Google login button',\r\n      'Complete OAuth flow',\r\n      'Verify admin access',\r\n    ],\r\n    automation_commands: [\r\n      'npm run oauth:verify - Check configuration',\r\n      'npm run oauth:test:dev - Test development flow',\r\n      'npm run oauth:test:prod - Test production flow',\r\n    ],\r\n  });\r\n}\r\n\r\n/**\r\n * Retrieves the current OAuth status including configuration and connectivity information.\r\n * @example\r\n * getOAuthStatus().then(status => {\r\n *   console.log(status);\r\n * });\r\n * // Output: OAuthStatus object with current configuration and connection status details\r\n * @returns {Promise<OAuthStatus>} An object representing the current status of OAuth configuration and connectivity.\r\n * @description\r\n *   - The function assesses the connectivity and configuration of Supabase and its authentication settings.\r\n *   - It checks if the necessary environment variables are set.\r\n *   - Executes a series of asynchronous checks to determine if the OAuth provider is properly configured.\r\n *   - Recommendations for improving the OAuth setup are generated based on the current status.\r\n */\r\nasync function getOAuthStatus(): Promise<OAuthStatus> {\r\n  const status: OAuthStatus = {\r\n    timestamp: new Date().toISOString(),\r\n    environment: process.env.NODE_ENV === 'production' ? 'production' : 'development',\r\n    supabase: {\r\n      connected: false,\r\n      projectId: 'zkwliyjjkdnigizidlln' as string,\r\n    },\r\n    environment_variables: {\r\n      supabaseUrl: process.env.NEXT_PUBLIC_SUPABASE_URL !== undefined,\r\n      supabaseAnonKey: process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY !== undefined,\r\n      supabaseServiceKey: process.env.SUPABASE_SERVICE_ROLE_KEY !== undefined,\r\n    },\r\n    oauth_flow: {\r\n      loginPageExists: true,\r\n      callbackRouteExists: true,\r\n      authProviderConfigured: false,\r\n    },\r\n    recommendations: [],\r\n    overall_status: 'not_configured',\r\n  };\r\n\r\n  await checkSupabaseConnection(status, supabase);\r\n  await checkSupabaseAuthSettings(status);\r\n  await testOAuthProvider(status, supabase);\r\n\r\n  status.recommendations = generateRecommendations(status);\r\n  status.overall_status = determineOverallStatus(status);\r\n\r\n  return status;\r\n}\r\n\r\n/**\r\n * Checks the connection status with Supabase and updates the `OAuthStatus`.\r\n * @example\r\n * checkSupabaseConnection(status, supabase)\r\n * // Updates the `status.supabase.connected` property based on connection success\r\n * @param {OAuthStatus} status - The current OAuthStatus object that tracks connection state and errors.\r\n * @param {SupabaseClient} supabase - The Supabase client instance used to interact with the database.\r\n * @returns {void} No explicit return value, operates directly on the `status` object.\r\n * @description\r\n *   - Attempts a query to the 'profiles' table to ensure Supabase connection.\r\n *   - Updates `status.supabase.connected` based on query success.\r\n *   - Captures and records detailed error messages in case of connection failure.\r\n */\r\nasync function checkSupabaseConnection(status: OAuthStatus, supabase: SupabaseClient) {\r\n  try {\r\n    const { error } = await supabase.from('profiles').select('count').limit(1);\r\n    if (error === null) {\r\n      status.supabase.connected = true;\r\n    } else {\r\n      status.supabase.error = error.message;\r\n    }\r\n  } catch (error: unknown) {\r\n    status.supabase.error = error instanceof Error ? error.message : 'Unknown connection error';\r\n  }\r\n}\r\n\r\n/**\r\n * Checks and processes Supabase authentication settings.\r\n * @example\r\n * checkSupabaseAuthSettings(oAuthStatusInstance)\r\n * { supabase: { authSettings: { googleEnabled: true, signupEnabled: false, autoconfirm: true } } }\r\n * @param {OAuthStatus} status - An object that holds OAuth configuration status.\r\n * @returns {void} Modifies the passed status object with fetched authentication settings.\r\n * @description\r\n *   - The function fetches authentication settings from the Supabase URL defined in environment variables.\r\n *   - If Supabase settings are fetched successfully, it updates the OAuth status with authentication settings like Google integration, signup availability, and autoconfirm feature.\r\n *   - Provides a fallback log for cases where fetching settings require authentication.\r\n */\r\nasync function checkSupabaseAuthSettings(status: OAuthStatus) {\r\n  try {\r\n    const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;\r\n    if (typeof supabaseUrl === 'string' && supabaseUrl.length > 0) {\r\n      // Explicit check for undefined and empty string\r\n      const settingsResponse = await fetch(`${supabaseUrl}/auth/v1/settings`);\r\n      if (settingsResponse.ok === true) {\r\n        const settings: {\r\n          external?: { google?: boolean };\r\n          disable_signup?: boolean;\r\n          autoconfirm?: boolean;\r\n        } = (await settingsResponse.json()) as {\r\n          external?: { google?: boolean };\r\n          disable_signup?: boolean;\r\n          autoconfirm?: boolean;\r\n        };\r\n        status.supabase.authSettings = {\r\n          googleEnabled: settings.external?.google ?? false,\r\n          signupEnabled: settings.disable_signup === false,\r\n          autoconfirm: settings.autoconfirm ?? false,\r\n        };\r\n        if (settings.external?.google !== undefined) {\r\n          // Explicit check for undefined\r\n          status.oauth_flow.authProviderConfigured = true;\r\n        }\r\n      }\r\n    }\r\n  } catch {\r\n    console.info('Auth settings endpoint requires authentication (normal)');\r\n  }\r\n}\r\n\r\n/**\r\n * Tests the configuration of an OAuth provider and updates the status based on the result.\r\n * @example\r\n * testOAuthProvider(status, supabase)\r\n * undefined\r\n * @param {OAuthStatus} status - An object representing the current OAuth status and configuration.\r\n * @param {SupabaseClient} supabase - The Supabase client instance used to interact with the authentication system.\r\n * @returns {void} Does not return any value.\r\n * @description\r\n *   - Utilizes Google as the OAuth provider for the sign-in attempt.\r\n *   - Redirects to a localhost callback URL to simulate the OAuth process.\r\n *   - Direct usage of the Supabase auth method to initiate OAuth process.\r\n *   - Handles exceptions without altering the control flow and logs them for informational purposes.\r\n */\r\nasync function testOAuthProvider(status: OAuthStatus, supabase: SupabaseClient) {\r\n  try {\r\n    const { error: oauthError } = await supabase.auth.signInWithOAuth({\r\n      provider: 'google',\r\n      options: {\r\n        redirectTo: 'http://localhost:3000/auth/callback',\r\n        skipBrowserRedirect: true,\r\n      },\r\n    });\r\n    if (oauthError !== null && oauthError.message !== 'Provider not found') {\r\n      // Explicitly check for oauthError existence\r\n      status.oauth_flow.authProviderConfigured = true;\r\n    }\r\n  } catch (error: unknown) {\r\n    console.info('OAuth provider test failed (may be normal):', error);\r\n  }\r\n}\r\n\r\n/**\r\n * Generates a list of recommendations for OAuth configuration based on the current status.\r\n * @example\r\n * generateRecommendations(status)\r\n * ['❌ Configure NEXT_PUBLIC_SUPABASE_URL environment variable', ...]\r\n * @param {OAuthStatus} status - The current status of OAuth configuration and environment variables.\r\n * @returns {string[]} Array of recommendation messages to guide configuration setup.\r\n * @description\r\n *   - Checks for necessary environment variables and Supabase connectivity.\r\n *   - Provides guidance on enabling Google OAuth.\r\n *   - Suggests consulting documentation for further setup instructions.\r\n */\r\nfunction generateRecommendations(status: OAuthStatus): string[] {\r\n  const recommendations: string[] = [];\r\n\r\n  if (!status.environment_variables.supabaseUrl) {\r\n    recommendations.push('❌ Configure NEXT_PUBLIC_SUPABASE_URL environment variable');\r\n  }\r\n  if (!status.environment_variables.supabaseAnonKey) {\r\n    recommendations.push('❌ Configure NEXT_PUBLIC_SUPABASE_ANON_KEY environment variable');\r\n  }\r\n  if (!status.environment_variables.supabaseServiceKey) {\r\n    recommendations.push('❌ Configure SUPABASE_SERVICE_ROLE_KEY environment variable');\r\n  }\r\n\r\n  if (!status.supabase.connected) {\r\n    recommendations.push('❌ Fix Supabase connection issue');\r\n    if (typeof status.supabase.error === 'string' && status.supabase.error.length > 0) {\r\n      recommendations.push(`   Error: ${status.supabase.error}`);\r\n    }\r\n  }\r\n\r\n  if (status.supabase.authSettings?.googleEnabled === true) {\r\n    recommendations.push('✅ Google OAuth provider is enabled');\r\n  } else {\r\n    recommendations.push(\r\n      '🔧 Enable Google OAuth provider in Supabase Dashboard',\r\n      '   Go to: Authentication > Providers > Google',\r\n    );\r\n  }\r\n\r\n  if (status.overall_status === 'ready') {\r\n    recommendations.push('🎉 OAuth configuration is complete!', '✅ Test the login flow at /login');\r\n  }\r\n\r\n  if (recommendations.length > 1) {\r\n    recommendations.push(\r\n      '📖 See docs/GOOGLE_OAUTH_SETUP_GUIDE.md for detailed instructions',\r\n      '🔧 Run: npm run oauth:verify for automated checks',\r\n    );\r\n  }\r\n\r\n  return recommendations;\r\n}\r\n\r\n/**\r\n * Determines the overall OAuth status based on provided conditions.\r\n * @example\r\n * determineOverallStatus(status)\r\n * 'ready'\r\n * @param {OAuthStatus} status - The status object containing configuration details.\r\n * @returns {'ready' | 'partial' | 'not_configured' | 'error'} Overall status derived from the evaluations.\r\n * @description\r\n *   - Evaluates connectivity and configuration status from various parameters within the status object.\r\n *   - Prioritizes returning 'error' if Supabase connection fails or if an error is detected.\r\n *   - Checks completeness of environment variables before proceeding to other status evaluations.\r\n *   - Distinguishes between 'ready' and 'partial' based on specific OAuth settings.\r\n */\r\nfunction determineOverallStatus(\r\n  status: OAuthStatus,\r\n): 'ready' | 'partial' | 'not_configured' | 'error' {\r\n  // eslint-disable-next-line sonarjs/different-types-comparison\r\n  if (!status.supabase.connected || status.supabase.error !== null) {\r\n    return 'error';\r\n  }\r\n\r\n  const envVarsComplete = Object.values(status.environment_variables).every(Boolean);\r\n  if (!envVarsComplete) {\r\n    return 'not_configured';\r\n  }\r\n\r\n  if (status.supabase.authSettings?.googleEnabled && status.oauth_flow.authProviderConfigured) {\r\n    return 'ready';\r\n  }\r\n\r\n  if (status.supabase.connected && envVarsComplete) {\r\n    return 'partial';\r\n  }\r\n\r\n  return 'not_configured';\r\n}\r\n\r\n/**\r\n * Retrieves a human-readable message based on the OAuth configuration status.\r\n * @example\r\n * getStatusMessage('ready')\r\n * 'Google OAuth is fully configured and ready to use'\r\n * @param {string} status - The current status of the OAuth configuration.\r\n * @returns {string} A message explaining the OAuth configuration status.\r\n * @description\r\n *   - Handles several predefined status cases.\r\n *   - Provides feedback for both success and error states.\r\n *   - Returns a default message for unrecognized statuses.\r\n */\r\nfunction getStatusMessage(status: string): string {\r\n  switch (status) {\r\n    case 'ready': {\r\n      return 'Google OAuth is fully configured and ready to use';\r\n    }\r\n    case 'partial': {\r\n      return 'Basic configuration complete, OAuth provider needs setup';\r\n    }\r\n    case 'not_configured': {\r\n      return 'Google OAuth is not configured';\r\n    }\r\n    case 'error': {\r\n      return 'Configuration error detected';\r\n    }\r\n    default: {\r\n      return 'Unknown configuration status';\r\n    }\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\api\\admin\\oauth-status\\types.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\api\\admin\\oauth-status\\types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\api\\admin\\realtime-events\\handlers.js","messages":[],"suppressedMessages":[{"ruleId":"sonarjs/pseudo-random","severity":2,"message":"Make sure that using this pseudorandom number generator is safe here.","line":328,"column":29,"nodeType":"CallExpression","messageId":"safeGenerator","endLine":328,"endColumn":42,"suppressions":[{"kind":"directive","justification":"Math.random is acceptable for generating non-security-sensitive event IDs."}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\api\\admin\\realtime-events\\handlers.ts","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-misused-promises","severity":2,"message":"Promise returned in function argument where a void return was expected.","line":61,"column":38,"nodeType":"ArrowFunctionExpression","messageId":"voidReturnArgument","endLine":63,"endColumn":8,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-misused-promises","severity":2,"message":"Promise returned in function argument where a void return was expected.","line":148,"column":22,"nodeType":"ArrowFunctionExpression","messageId":"voidReturnArgument","endLine":154,"endColumn":4,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"sonarjs/pseudo-random","severity":2,"message":"Make sure that using this pseudorandom number generator is safe here.","line":414,"column":27,"nodeType":"CallExpression","messageId":"safeGenerator","endLine":414,"endColumn":40,"suppressions":[{"kind":"directive","justification":"Math.random is acceptable for generating non-security-sensitive event IDs."}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\api\\admin\\realtime-events\\types.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\api\\admin\\realtime-events\\types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\api\\admin\\scraping-metrics\\handlers.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\api\\admin\\scraping-metrics\\handlers.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\api\\analytics\\web-vitals\\handlers.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\api\\analytics\\web-vitals\\handlers.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\api\\analytics\\web-vitals\\types.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\api\\analytics\\web-vitals\\types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\api\\cron\\auto-scrape\\handlers.js","messages":[{"ruleId":"unicorn/no-null","severity":1,"message":"Use `undefined` instead of `null`.","line":28,"column":12,"nodeType":"Literal","messageId":"error","endLine":28,"endColumn":16,"suggestions":[{"messageId":"remove","fix":{"range":[1466,1470],"text":""},"data":{},"desc":"Remove `null`."},{"messageId":"replace","fix":{"range":[1466,1470],"text":"undefined"},"data":{},"desc":"Replace `null` with `undefined`."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { NextResponse } from 'next/server';\r\nimport { autoScraper } from '../../../../lib/autoScraper.js';\r\nimport { scheduler } from '../../../../lib/scheduler.js';\r\nimport { logActivity } from '../../../../lib/activityLogger.js';\r\n/**\r\n* Verifies the cron secret authorization header against a stored environment variable.\r\n* @example\r\n* verifyCronSecret(request)\r\n* NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\r\n* @param {NextRequest} request - The incoming request object containing headers.\r\n* @returns {NextResponse | null} Returns an error response if authorization fails or if the secret is not set.\r\n* @description\r\n*   - Logs an error message if the CRON_SECRET environment variable is not configured or is empty.\r\n*   - Logs unauthorized attempts, including the provided authorization header value.\r\n*   - Relies on the Bearer token scheme for authorization.\r\n*/\r\nfunction verifyCronSecret(request) {\r\n    const authHeader = request.headers.get('authorization');\r\n    const cronSecret = process.env.CRON_SECRET;\r\n    if (cronSecret === undefined || cronSecret === '') {\r\n        console.error('CRON_SECRET not configured');\r\n        return NextResponse.json({ error: 'Server configuration error' }, { status: 500 });\r\n    }\r\n    if (authHeader !== `Bearer ${cronSecret}`) {\r\n        console.error('Unauthorized cron attempt:', authHeader);\r\n        return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });\r\n    }\r\n    return null;\r\n}\r\nfunction logAutoScrapeStart() {\r\n    console.info('Starting automated scraping job...');\r\n    logActivity({\r\n        type: 'cron_job',\r\n        action: 'auto_scrape_started',\r\n        details: { timestamp: new Date().toISOString() },\r\n    });\r\n}\r\n/**\r\n * Logs the completion of an automated scraping job with pertinent details.\r\n * @example\r\n * logAutoScrapeCompletion(autoScrapeResult)\r\n * Automated scraping job completed successfully\r\n * @param {AutoScrapeResult} result - The result object containing details of the scraping job.\r\n * @returns {void} Does not return a value.\r\n * @description\r\n *   - Logs activity including the number of trucks processed and found, as well as any errors encountered.\r\n *   - Utilizes a standardized logActivity function to record job completion.\r\n *   - Converts the current timestamp to an ISO string format.\r\n *   - Provides a console message indicating successful job completion.\r\n */\r\nfunction logAutoScrapeCompletion(result) {\r\n    logActivity({\r\n        type: 'cron_job',\r\n        action: 'auto_scrape_completed',\r\n        details: {\r\n            timestamp: new Date().toISOString(),\r\n            trucksProcessed: result.trucksProcessed,\r\n            newTrucksFound: result.newTrucksFound,\r\n            errorsCount: result.errors?.length ?? 0,\r\n        },\r\n    });\r\n    console.info('Automated scraping job completed successfully');\r\n}\r\nfunction logAutoScrapeFailure(error) {\r\n    console.error('Auto-scraping cron job failed:', error);\r\n    logActivity({\r\n        type: 'cron_job',\r\n        action: 'auto_scrape_failed',\r\n        details: {\r\n            timestamp: new Date().toISOString(),\r\n            error: error instanceof Error ? error.message : 'Unknown error',\r\n        },\r\n    });\r\n}\r\n/**\r\n * Handles a POST request to initiate an auto-scraping process and returns the result.\r\n * @example\r\n * handlePostRequest(request)\r\n * { success: true, message: 'Auto-scraping completed successfully', data: { trucksProcessed: 10, newTrucksFound: 2, timestamp: '2023-08-23T18:25:43.511Z' } }\r\n * @param {NextRequest} request - The request object containing necessary parameters and headers for processing.\r\n * @returns {NextResponse} JSON response with either the success data or an error message.\r\n * @description\r\n *   - Validates request with a secret key before processing.\r\n *   - Logs scraping start and completion along with processed results.\r\n *   - Schedules follow-up tasks after successful scraping.\r\n *   - Catches and logs errors with a failure response in case of any exceptions during the process.\r\n */\r\nexport async function handlePostRequest(request) {\r\n    try {\r\n        const authResponse = verifyCronSecret(request);\r\n        if (authResponse) {\r\n            return authResponse;\r\n        }\r\n        logAutoScrapeStart();\r\n        const rawResult = await autoScraper.runAutoScraping();\r\n        // Map errors to string[] for compatibility\r\n        const result = {\r\n            trucksProcessed: rawResult.trucksProcessed,\r\n            newTrucksFound: rawResult.newTrucksFound,\r\n            errors: rawResult.errors?.map((e) => e.url + (e.details ? `: ${e.details}` : '')),\r\n        };\r\n        scheduler.scheduleFollowUpTasks(result);\r\n        logAutoScrapeCompletion(result);\r\n        return NextResponse.json({\r\n            success: true,\r\n            message: 'Auto-scraping completed successfully',\r\n            data: {\r\n                trucksProcessed: result.trucksProcessed,\r\n                newTrucksFound: result.newTrucksFound,\r\n                timestamp: new Date().toISOString(),\r\n            },\r\n        });\r\n    }\r\n    catch (error) {\r\n        logAutoScrapeFailure(error);\r\n        return NextResponse.json({\r\n            success: false,\r\n            error: 'Auto-scraping failed',\r\n            message: error instanceof Error ? error.message : 'Unknown error',\r\n        }, { status: 500 });\r\n    }\r\n}\r\nexport function handleGetRequest() {\r\n    return NextResponse.json({ error: 'Method not allowed. Use POST for cron jobs.' }, { status: 405 });\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\api\\cron\\auto-scrape\\handlers.ts","messages":[{"ruleId":"unicorn/no-null","severity":1,"message":"Use `undefined` instead of `null`.","line":32,"column":10,"nodeType":"Literal","messageId":"error","endLine":32,"endColumn":14,"suggestions":[{"messageId":"remove","fix":{"range":[1500,1504],"text":""},"data":{},"desc":"Remove `null`."},{"messageId":"replace","fix":{"range":[1500,1504],"text":"undefined"},"data":{},"desc":"Replace `null` with `undefined`."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":110,"column":53,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":110,"endColumn":62,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[4529,4538],"text":"(e.details != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[4529,4538],"text":"(e.details ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[4529,4538],"text":"(Boolean(e.details))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { NextRequest, NextResponse } from 'next/server';\r\nimport { autoScraper } from '@/lib/autoScraper';\r\nimport { scheduler } from '@/lib/scheduler';\r\nimport { logActivity } from '@/lib/activityLogger';\r\nimport type { AutoScrapeResult } from './types';\r\n\r\n/**\r\n* Verifies the cron secret authorization header against a stored environment variable.\r\n* @example\r\n* verifyCronSecret(request)\r\n* NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\r\n* @param {NextRequest} request - The incoming request object containing headers.\r\n* @returns {NextResponse | null} Returns an error response if authorization fails or if the secret is not set.\r\n* @description\r\n*   - Logs an error message if the CRON_SECRET environment variable is not configured or is empty.\r\n*   - Logs unauthorized attempts, including the provided authorization header value.\r\n*   - Relies on the Bearer token scheme for authorization.\r\n*/\r\nfunction verifyCronSecret(request: NextRequest): NextResponse | null {\r\n  const authHeader = request.headers.get('authorization');\r\n  const cronSecret = process.env.CRON_SECRET;\r\n\r\n  if (cronSecret === undefined || cronSecret === '') {\r\n    console.error('CRON_SECRET not configured');\r\n    return NextResponse.json({ error: 'Server configuration error' }, { status: 500 });\r\n  }\r\n\r\n  if (authHeader !== `Bearer ${cronSecret}`) {\r\n    console.error('Unauthorized cron attempt:', authHeader);\r\n    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });\r\n  }\r\n  return null;\r\n}\r\n\r\nfunction logAutoScrapeStart() {\r\n  console.info('Starting automated scraping job...');\r\n  logActivity({\r\n    type: 'cron_job',\r\n    action: 'auto_scrape_started',\r\n    details: { timestamp: new Date().toISOString() },\r\n  });\r\n}\r\n\r\n/**\r\n * Logs the completion of an automated scraping job with pertinent details.\r\n * @example\r\n * logAutoScrapeCompletion(autoScrapeResult)\r\n * Automated scraping job completed successfully\r\n * @param {AutoScrapeResult} result - The result object containing details of the scraping job.\r\n * @returns {void} Does not return a value.\r\n * @description\r\n *   - Logs activity including the number of trucks processed and found, as well as any errors encountered.\r\n *   - Utilizes a standardized logActivity function to record job completion.\r\n *   - Converts the current timestamp to an ISO string format.\r\n *   - Provides a console message indicating successful job completion.\r\n */\r\nfunction logAutoScrapeCompletion(result: AutoScrapeResult) {\r\n  logActivity({\r\n    type: 'cron_job',\r\n    action: 'auto_scrape_completed',\r\n    details: {\r\n      timestamp: new Date().toISOString(),\r\n      trucksProcessed: result.trucksProcessed,\r\n      newTrucksFound: result.newTrucksFound,\r\n      errorsCount: result.errors?.length ?? 0,\r\n    },\r\n  });\r\n  console.info('Automated scraping job completed successfully');\r\n}\r\n\r\nfunction logAutoScrapeFailure(error: unknown) {\r\n  console.error('Auto-scraping cron job failed:', error);\r\n  logActivity({\r\n    type: 'cron_job',\r\n    action: 'auto_scrape_failed',\r\n    details: {\r\n      timestamp: new Date().toISOString(),\r\n      error: error instanceof Error ? error.message : 'Unknown error',\r\n    },\r\n  });\r\n}\r\n\r\n/**\r\n * Handles a POST request to initiate an auto-scraping process and returns the result.\r\n * @example\r\n * handlePostRequest(request)\r\n * { success: true, message: 'Auto-scraping completed successfully', data: { trucksProcessed: 10, newTrucksFound: 2, timestamp: '2023-08-23T18:25:43.511Z' } }\r\n * @param {NextRequest} request - The request object containing necessary parameters and headers for processing.\r\n * @returns {NextResponse} JSON response with either the success data or an error message.\r\n * @description\r\n *   - Validates request with a secret key before processing.\r\n *   - Logs scraping start and completion along with processed results.\r\n *   - Schedules follow-up tasks after successful scraping.\r\n *   - Catches and logs errors with a failure response in case of any exceptions during the process.\r\n */\r\nexport async function handlePostRequest(request: NextRequest) {\r\n  try {\r\n    const authResponse = verifyCronSecret(request);\r\n    if (authResponse) {\r\n      return authResponse;\r\n    }\r\n\r\n    logAutoScrapeStart();\r\n\r\n    const rawResult = await autoScraper.runAutoScraping();\r\n    // Map errors to string[] for compatibility\r\n    const result: AutoScrapeResult = {\r\n      trucksProcessed: rawResult.trucksProcessed,\r\n      newTrucksFound: rawResult.newTrucksFound,\r\n      errors: rawResult.errors?.map((e) => e.url + (e.details ? `: ${e.details}` : '')),\r\n    };\r\n    scheduler.scheduleFollowUpTasks(result);\r\n    logAutoScrapeCompletion(result);\r\n\r\n    return NextResponse.json({\r\n      success: true,\r\n      message: 'Auto-scraping completed successfully',\r\n      data: {\r\n        trucksProcessed: result.trucksProcessed,\r\n        newTrucksFound: result.newTrucksFound,\r\n        timestamp: new Date().toISOString(),\r\n      },\r\n    });\r\n  } catch (error) {\r\n    logAutoScrapeFailure(error);\r\n    return NextResponse.json(\r\n      {\r\n        success: false,\r\n        error: 'Auto-scraping failed',\r\n        message: error instanceof Error ? error.message : 'Unknown error',\r\n      },\r\n      { status: 500 },\r\n    );\r\n  }\r\n}\r\n\r\nexport function handleGetRequest() {\r\n  return NextResponse.json(\r\n    { error: 'Method not allowed. Use POST for cron jobs.' },\r\n    { status: 405 },\r\n  );\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\api\\cron\\auto-scrape\\improvedHandler.js","messages":[{"ruleId":"max-depth","severity":2,"message":"Blocks are nested too deeply (5). Maximum allowed is 4.","line":58,"column":21,"nodeType":"IfStatement","messageId":"tooDeeply","endLine":60,"endColumn":22}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { NextResponse } from 'next/server';\r\nimport { ScrapingJobService, FoodTruckService } from '../../../../lib/supabase.js';\r\nimport { logActivity } from '../../../../lib/activityLogger.js';\r\nimport { DEFAULT_SCRAPE_URLS } from '../../../../lib/config.js';\r\n// Vercel hobby plan has 10 second timeout, leave some buffer\r\nconst FUNCTION_TIMEOUT_MS = 9000;\r\nconst PROCESSING_TIMEOUT_MS = 8000;\r\n/**\r\n * Lightweight CRON handler that creates jobs but doesn't process them\r\n * This avoids timeout issues on Vercel hobby plan\r\n */\r\nexport async function handleAutoScrapeImproved(request) {\r\n    const startTime = Date.now();\r\n    try {\r\n        // Verify authorization\r\n        const authHeader = request.headers.get('authorization');\r\n        const cronSecret = process.env.CRON_SECRET;\r\n        if (!cronSecret || authHeader !== `Bearer ${cronSecret}`) {\r\n            return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });\r\n        }\r\n        logActivity({\r\n            type: 'cron_job',\r\n            action: 'auto_scrape_started',\r\n            details: { timestamp: new Date().toISOString() },\r\n        });\r\n        const result = {\r\n            trucksProcessed: 0,\r\n            newTrucksFound: 0,\r\n            errors: []\r\n        };\r\n        // Get URLs to scrape\r\n        const urlsToScrape = await getUrlsToScrape();\r\n        console.info(`Found ${urlsToScrape.length} URLs to process`);\r\n        // Check existing trucks to determine which are new\r\n        const { trucks: existingTrucks } = await FoodTruckService.getAllTrucks(1000, 0);\r\n        const existingUrls = new Set(existingTrucks.flatMap(truck => truck.source_urls || []));\r\n        // Create jobs for URLs (but don't process them)\r\n        for (const url of urlsToScrape) {\r\n            // Check if we're approaching timeout\r\n            if (Date.now() - startTime > PROCESSING_TIMEOUT_MS) {\r\n                console.warn('Approaching function timeout, stopping job creation');\r\n                break;\r\n            }\r\n            try {\r\n                const isNew = !existingUrls.has(url);\r\n                // Check if job already exists\r\n                const existingJobs = await ScrapingJobService.getJobsByStatus('all');\r\n                const jobExists = existingJobs.some(job => job.target_url === url && ['pending', 'running'].includes(job.status));\r\n                if (!jobExists) {\r\n                    // Create job but don't process it\r\n                    await ScrapingJobService.createJob({\r\n                        job_type: 'website_auto',\r\n                        target_url: url,\r\n                        priority: isNew ? 10 : 5, // Higher priority for new trucks\r\n                        scheduled_at: new Date().toISOString(),\r\n                    });\r\n                    result.trucksProcessed++;\r\n                    if (isNew) {\r\n                        result.newTrucksFound++;\r\n                    }\r\n                }\r\n            }\r\n            catch (error) {\r\n                console.error(`Error creating job for ${url}:`, error);\r\n                result.errors.push(url);\r\n            }\r\n        }\r\n        // Process a few high-priority pending jobs if we have time\r\n        const remainingTime = FUNCTION_TIMEOUT_MS - (Date.now() - startTime);\r\n        if (remainingTime > 2000) {\r\n            await processHighPriorityJobs(remainingTime - 1000);\r\n        }\r\n        logActivity({\r\n            type: 'cron_job',\r\n            action: 'auto_scrape_completed',\r\n            details: {\r\n                timestamp: new Date().toISOString(),\r\n                trucksProcessed: result.trucksProcessed,\r\n                newTrucksFound: result.newTrucksFound,\r\n                errorsCount: result.errors.length,\r\n            },\r\n        });\r\n        return NextResponse.json({\r\n            success: true,\r\n            message: 'Auto-scraping jobs created successfully',\r\n            data: {\r\n                trucksProcessed: result.trucksProcessed,\r\n                newTrucksFound: result.newTrucksFound,\r\n                timestamp: new Date().toISOString(),\r\n                note: 'Jobs created but not processed. Use separate job processor to avoid timeouts.',\r\n            },\r\n        });\r\n    }\r\n    catch (error) {\r\n        console.error('Auto-scraping cron job failed:', error);\r\n        logActivity({\r\n            type: 'cron_job',\r\n            action: 'auto_scrape_failed',\r\n            details: {\r\n                timestamp: new Date().toISOString(),\r\n                error: error instanceof Error ? error.message : 'Unknown error',\r\n            },\r\n        });\r\n        return NextResponse.json({\r\n            success: false,\r\n            error: 'Auto-scraping failed',\r\n            message: error instanceof Error ? error.message : 'Unknown error',\r\n        }, { status: 500 });\r\n    }\r\n}\r\nasync function getUrlsToScrape() {\r\n    // This is a simplified version - in production, you'd also check discovered_urls table\r\n    return DEFAULT_SCRAPE_URLS;\r\n}\r\nasync function processHighPriorityJobs(timeLimit) {\r\n    const startTime = Date.now();\r\n    try {\r\n        // Get high priority pending jobs\r\n        const pendingJobs = await ScrapingJobService.getJobsByStatus('pending');\r\n        const highPriorityJobs = pendingJobs\r\n            .filter(job => job.priority >= 10)\r\n            .sort((a, b) => b.priority - a.priority)\r\n            .slice(0, 3); // Process at most 3 jobs\r\n        for (const job of highPriorityJobs) {\r\n            if (Date.now() - startTime > timeLimit) {\r\n                break;\r\n            }\r\n            // Just update status to indicate it's been queued\r\n            await ScrapingJobService.updateJobStatus(job.id, 'pending', {\r\n                data_collected: {\r\n                    ...job.data_collected,\r\n                    queued_at: new Date().toISOString(),\r\n                    queued_note: 'Queued for processing by job processor'\r\n                }\r\n            });\r\n        }\r\n    }\r\n    catch (error) {\r\n        console.error('Error processing high priority jobs:', error);\r\n    }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\api\\cron\\auto-scrape\\improvedHandler.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":28,"column":10,"nodeType":"Identifier","messageId":"conditionErrorNullableString","endLine":28,"endColumn":20,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[911,922],"text":"(cronSecret == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[912,922],"text":"(cronSecret ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[911,922],"text":"(!Boolean(cronSecret))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":51,"column":39,"nodeType":"MemberExpression","messageId":"conditionErrorObject","endLine":51,"endColumn":56},{"ruleId":"max-depth","severity":2,"message":"Blocks are nested too deeply (5). Maximum allowed is 4.","line":81,"column":11,"nodeType":"IfStatement","messageId":"tooDeeply","endLine":83,"endColumn":12},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async function 'getUrlsToScrape' has no 'await' expression.","line":140,"column":1,"nodeType":"FunctionDeclaration","messageId":"missingAwait","endLine":140,"endColumn":31,"suggestions":[{"messageId":"removeAsync","fix":{"range":[4458,4509],"text":"function getUrlsToScrape(): string[]"},"desc":"Remove 'async'."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { NextRequest, NextResponse } from 'next/server';\r\nimport { ScrapingJobService, FoodTruckService } from '@/lib/supabase';\r\nimport { logActivity } from '@/lib/activityLogger';\r\nimport { DEFAULT_SCRAPE_URLS } from '@/lib/config';\r\n\r\n// Vercel hobby plan has 10 second timeout, leave some buffer\r\nconst FUNCTION_TIMEOUT_MS = 9000;\r\nconst PROCESSING_TIMEOUT_MS = 8000;\r\n\r\ninterface ProcessingResult {\r\n  trucksProcessed: number;\r\n  newTrucksFound: number;\r\n  errors: string[];\r\n}\r\n\r\n/**\r\n * Lightweight CRON handler that creates jobs but doesn't process them\r\n * This avoids timeout issues on Vercel hobby plan\r\n */\r\nexport async function handleAutoScrapeImproved(request: NextRequest): Promise<NextResponse> {\r\n  const startTime = Date.now();\r\n  \r\n  try {\r\n    // Verify authorization\r\n    const authHeader = request.headers.get('authorization');\r\n    const cronSecret = process.env.CRON_SECRET;\r\n\r\n    if (!cronSecret || authHeader !== `Bearer ${cronSecret}`) {\r\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });\r\n    }\r\n\r\n    logActivity({\r\n      type: 'cron_job',\r\n      action: 'auto_scrape_started',\r\n      details: { timestamp: new Date().toISOString() },\r\n    });\r\n\r\n    const result: ProcessingResult = {\r\n      trucksProcessed: 0,\r\n      newTrucksFound: 0,\r\n      errors: []\r\n    };\r\n\r\n    // Get URLs to scrape\r\n    const urlsToScrape = await getUrlsToScrape();\r\n    console.info(`Found ${urlsToScrape.length} URLs to process`);\r\n\r\n    // Check existing trucks to determine which are new\r\n    const { trucks: existingTrucks } = await FoodTruckService.getAllTrucks(1000, 0);\r\n    const existingUrls = new Set(\r\n      existingTrucks.flatMap(truck => truck.source_urls || [])\r\n    );\r\n\r\n    // Create jobs for URLs (but don't process them)\r\n    for (const url of urlsToScrape) {\r\n      // Check if we're approaching timeout\r\n      if (Date.now() - startTime > PROCESSING_TIMEOUT_MS) {\r\n        console.warn('Approaching function timeout, stopping job creation');\r\n        break;\r\n      }\r\n\r\n      try {\r\n        const isNew = !existingUrls.has(url);\r\n        \r\n        // Check if job already exists\r\n        const existingJobs = await ScrapingJobService.getJobsByStatus('all');\r\n        const jobExists = existingJobs.some(\r\n          job => job.target_url === url && ['pending', 'running'].includes(job.status)\r\n        );\r\n\r\n        if (!jobExists) {\r\n          // Create job but don't process it\r\n          await ScrapingJobService.createJob({\r\n            job_type: 'website_auto',\r\n            target_url: url,\r\n            priority: isNew ? 10 : 5, // Higher priority for new trucks\r\n            scheduled_at: new Date().toISOString(),\r\n          });\r\n\r\n          result.trucksProcessed++;\r\n          if (isNew) {\r\n            result.newTrucksFound++;\r\n          }\r\n        }\r\n      } catch (error) {\r\n        console.error(`Error creating job for ${url}:`, error);\r\n        result.errors.push(url);\r\n      }\r\n    }\r\n\r\n    // Process a few high-priority pending jobs if we have time\r\n    const remainingTime = FUNCTION_TIMEOUT_MS - (Date.now() - startTime);\r\n    if (remainingTime > 2000) {\r\n      await processHighPriorityJobs(remainingTime - 1000);\r\n    }\r\n\r\n    logActivity({\r\n      type: 'cron_job',\r\n      action: 'auto_scrape_completed',\r\n      details: {\r\n        timestamp: new Date().toISOString(),\r\n        trucksProcessed: result.trucksProcessed,\r\n        newTrucksFound: result.newTrucksFound,\r\n        errorsCount: result.errors.length,\r\n      },\r\n    });\r\n\r\n    return NextResponse.json({\r\n      success: true,\r\n      message: 'Auto-scraping jobs created successfully',\r\n      data: {\r\n        trucksProcessed: result.trucksProcessed,\r\n        newTrucksFound: result.newTrucksFound,\r\n        timestamp: new Date().toISOString(),\r\n        note: 'Jobs created but not processed. Use separate job processor to avoid timeouts.',\r\n      },\r\n    });\r\n  } catch (error) {\r\n    console.error('Auto-scraping cron job failed:', error);\r\n    logActivity({\r\n      type: 'cron_job',\r\n      action: 'auto_scrape_failed',\r\n      details: {\r\n        timestamp: new Date().toISOString(),\r\n        error: error instanceof Error ? error.message : 'Unknown error',\r\n      },\r\n    });\r\n\r\n    return NextResponse.json(\r\n      {\r\n        success: false,\r\n        error: 'Auto-scraping failed',\r\n        message: error instanceof Error ? error.message : 'Unknown error',\r\n      },\r\n      { status: 500 },\r\n    );\r\n  }\r\n}\r\n\r\nasync function getUrlsToScrape(): Promise<string[]> {\r\n  // This is a simplified version - in production, you'd also check discovered_urls table\r\n  return DEFAULT_SCRAPE_URLS;\r\n}\r\n\r\nasync function processHighPriorityJobs(timeLimit: number): Promise<void> {\r\n  const startTime = Date.now();\r\n  \r\n  try {\r\n    // Get high priority pending jobs\r\n    const pendingJobs = await ScrapingJobService.getJobsByStatus('pending');\r\n    const highPriorityJobs = pendingJobs\r\n      .filter(job => job.priority >= 10)\r\n      .sort((a, b) => b.priority - a.priority)\r\n      .slice(0, 3); // Process at most 3 jobs\r\n\r\n    for (const job of highPriorityJobs) {\r\n      if (Date.now() - startTime > timeLimit) {\r\n        break;\r\n      }\r\n\r\n      // Just update status to indicate it's been queued\r\n      await ScrapingJobService.updateJobStatus(job.id, 'pending', {\r\n        data_collected: {\r\n          ...job.data_collected,\r\n          queued_at: new Date().toISOString(),\r\n          queued_note: 'Queued for processing by job processor'\r\n        }\r\n      });\r\n    }\r\n  } catch (error) {\r\n    console.error('Error processing high priority jobs:', error);\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\api\\cron\\auto-scrape\\types.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\api\\cron\\auto-scrape\\types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\api\\firecrawl\\handlers.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\api\\firecrawl\\handlers.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\api\\firecrawl\\types.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\api\\firecrawl\\types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\api\\monitoring\\api-usage\\handlers.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\api\\monitoring\\api-usage\\handlers.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\api\\pipeline\\handlers.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\api\\pipeline\\handlers.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\api\\pipeline\\types.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\api\\pipeline\\types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\api\\scheduler\\data.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\api\\scheduler\\data.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\api\\scheduler\\handlers.js","messages":[],"suppressedMessages":[{"ruleId":"sonarjs/pseudo-random","severity":2,"message":"Make sure that using this pseudorandom number generator is safe here.","line":158,"column":9,"nodeType":"CallExpression","messageId":"safeGenerator","endLine":158,"endColumn":22,"suppressions":[{"kind":"directive","justification":"Math.random is acceptable for simulating task execution."}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\api\\scheduler\\handlers.ts","messages":[],"suppressedMessages":[{"ruleId":"sonarjs/pseudo-random","severity":2,"message":"Make sure that using this pseudorandom number generator is safe here.","line":172,"column":7,"nodeType":"CallExpression","messageId":"safeGenerator","endLine":172,"endColumn":20,"suppressions":[{"kind":"directive","justification":"Math.random is acceptable for simulating task execution."}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\api\\scheduler\\types.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\api\\scheduler\\types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\api\\search\\data.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\api\\search\\data.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\api\\search\\filters.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\api\\search\\filters.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":76,"column":21,"nodeType":"MemberExpression","messageId":"conditionErrorNullableBoolean","endLine":76,"endColumn":33,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[3218,3230],"text":"(hours.closed ?? false)"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[3218,3230],"text":"(hours.closed === true)"},"desc":"Change condition to check if true (`value === true`)"}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { MenuCategory, MenuItem, OperatingHours, FoodTruck } from '@/lib/types';\r\n\r\n/**\r\n* Filters an array of FoodTruck objects based on a given search query.\r\n* @example\r\n* applyTextSearchFilter(foodTrucksArray, 'taco')\r\n* // Returns an array of FoodTruck objects where the truck name, description, or menu contains 'taco'\r\n* @param {FoodTruck[]} trucks - An array of FoodTruck objects to be filtered.\r\n* @param {string | null} query - Search query to filter the food trucks by.\r\n* @returns {FoodTruck[]} An array of FoodTruck objects that match the search query.\r\n* @description\r\n*   - If the query is null or an empty string, the original array is returned unfiltered.\r\n*   - The search is case-insensitive.\r\n*   - Searches through truck names, descriptions, and menu item names and descriptions.\r\n*   - Utilizes optional chaining to handle undefined or null values in truck descriptions and menus.\r\n*/\r\nexport function applyTextSearchFilter(trucks: FoodTruck[], query: string | null): FoodTruck[] {\r\n  if (query != undefined && query !== '') {\r\n    return trucks.filter(\r\n      (truck: FoodTruck) =>\r\n        truck.name.toLowerCase().includes(query.toLowerCase()) ||\r\n        (truck.description?.toLowerCase().includes(query.toLowerCase()) ?? false) ||\r\n        (truck.menu?.some((category: MenuCategory) =>\r\n          category.items?.some(\r\n            (item: MenuItem) =>\r\n              item.name.toLowerCase().includes(query.toLowerCase()) ||\r\n              (item.description?.toLowerCase().includes(query.toLowerCase()) ?? false),\r\n          ),\r\n        ) ??\r\n          false),\r\n    );\r\n  }\r\n  return trucks;\r\n}\r\n\r\nexport function applyCuisineFilter(trucks: FoodTruck[], cuisine: string | null): FoodTruck[] {\r\n  if (cuisine != undefined && cuisine !== '') {\r\n    return trucks.filter((truck: FoodTruck) =>\r\n      truck.menu?.some((category: MenuCategory) =>\r\n        category.name.toLowerCase().includes(cuisine.toLowerCase()),\r\n      ),\r\n    );\r\n  }\r\n  return trucks;\r\n}\r\n\r\n/**\r\n * Filters a list of food trucks to only include those that are currently open.\r\n * @example\r\n * applyOpenNowFilter(trucks, true)\r\n * // returns list of trucks open at the current date and time\r\n * @param {FoodTruck[]} trucks - Array of food truck objects to be filtered.\r\n * @param {boolean} openNow - Flag to filter trucks that are open at the current time.\r\n * @returns {FoodTruck[]} Array of food trucks that are open now, or the unfiltered array if openNow is false.\r\n * @description\r\n *   - Uses the system's current date and time to determine if trucks are open.\r\n *   - Filters based on the truck's operating hours for the current day.\r\n */\r\nexport function applyOpenNowFilter(trucks: FoodTruck[], openNow: boolean): FoodTruck[] {\r\n  if (openNow) {\r\n    const now = new Date();\r\n    const daysOfWeek: Array<keyof OperatingHours> = [\r\n      'sunday',\r\n      'monday',\r\n      'tuesday',\r\n      'wednesday',\r\n      'thursday',\r\n      'friday',\r\n      'saturday',\r\n    ];\r\n    const currentDay = daysOfWeek[now.getDay()];\r\n    const currentTime = now.getHours() * 100 + now.getMinutes();\r\n\r\n    return trucks.filter((truck: FoodTruck) => {\r\n      const hours = truck.operating_hours?.[currentDay];\r\n      if (!hours || hours.closed) return false;\r\n\r\n      const openTime = Number.parseInt(hours.open.replace(':', ''), 10);\r\n      const closeTime = Number.parseInt(hours.close.replace(':', ''), 10);\r\n      return currentTime >= openTime && currentTime <= closeTime;\r\n    });\r\n  }\r\n  return trucks;\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\api\\search\\helpers.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\api\\search\\helpers.ts","messages":[{"ruleId":"sonarjs/unused-import","severity":2,"message":"Remove this unused import of 'NextRequest'.","line":1,"column":15,"nodeType":"Identifier","messageId":"removeUnusedImport","endLine":1,"endColumn":26,"suggestions":[{"messageId":"suggestRemoveOneVariable","fix":{"range":[9,27],"text":""},"desc":"Remove this variable import"}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'NextRequest' is defined but never used.","line":1,"column":15,"nodeType":null,"messageId":"unusedVar","endLine":1,"endColumn":26}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { type NextRequest, NextResponse } from 'next/server';\nimport {\n  applyCuisineFilter,\n  applyOpenNowFilter,\n  applyTextSearchFilter,\n} from '@/lib/api/search/filters';\nimport { getAndFilterFoodTrucks, sortFoodTrucksByQuality } from '@/lib/api/search/data';\nimport type { FoodTruck } from '@/lib/types';\n\n/**\n * Processes a search request and returns filtered and sorted food trucks based on query parameters.\n * @example\n * processSearchRequest(request)\n * { trucks: [/* filtered food trucks */\nexport async function processSearchRequest({ query, cuisine, openNow, lat, lng, radius }: {\n  query: string | null;\n  cuisine: string | null;\n  openNow: boolean;\n  lat: string | null;\n  lng: string | null;\n  radius: string | null;\n}) {\n  \n\n  let trucks: FoodTruck[] = await getAndFilterFoodTrucks(lat, lng, radius);\n\n  // Apply filters\n  trucks = applyTextSearchFilter(trucks, query);\n  trucks = applyCuisineFilter(trucks, cuisine);\n  trucks = applyOpenNowFilter(trucks, openNow);\n\n  // Sort by data quality score\n  const filteredAndSortedTrucks = sortFoodTrucksByQuality(trucks);\n\n  return NextResponse.json({\n    trucks: filteredAndSortedTrucks,\n    total: filteredAndSortedTrucks.length,\n    filters: {\n      query,\n      cuisine,\n      openNow,\n      location:\n        lat != undefined && lng != undefined\n          ? { lat: Number.parseFloat(lat), lng: Number.parseFloat(lng) }\n          : undefined,\n      radius: Number.parseFloat(radius ?? '10'),\n    },\n  });\n}\n","usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\api\\tavily\\handlers.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\api\\tavily\\handlers.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\api\\tavily\\types.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\api\\tavily\\types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\api\\test-integration\\helpers.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\api\\test-integration\\helpers.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\api\\test-integration\\pipelineRunner.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\api\\test-integration\\pipelineRunner.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\api\\test-integration\\pipelineRunnerHelpers.js","messages":[{"ruleId":"unicorn/no-useless-undefined","severity":2,"message":"Do not use useless `undefined`.","line":17,"column":16,"nodeType":"Identifier","messageId":"no-useless-undefined","endLine":17,"endColumn":25,"fix":{"range":[804,814],"text":""}},{"ruleId":"unicorn/no-useless-undefined","severity":2,"message":"Do not use useless `undefined`.","line":25,"column":16,"nodeType":"Identifier","messageId":"no-useless-undefined","endLine":25,"endColumn":25,"fix":{"range":[1168,1178],"text":""}},{"ruleId":"unicorn/no-useless-undefined","severity":2,"message":"Do not use useless `undefined`.","line":31,"column":16,"nodeType":"Identifier","messageId":"no-useless-undefined","endLine":31,"endColumn":25,"fix":{"range":[1580,1590],"text":""}},{"ruleId":"unicorn/no-useless-undefined","severity":2,"message":"Do not use useless `undefined`.","line":39,"column":16,"nodeType":"Identifier","messageId":"no-useless-undefined","endLine":39,"endColumn":25,"fix":{"range":[1962,1972],"text":""}}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":4,"fixableWarningCount":0,"source":"import { handleFirecrawlStage, handleGeminiStage, handleSupabaseStage } from './stageHandlers.js';\r\n// Helper function to handle stage errors and return a consistent error object\r\nfunction handleStageErrorAndReturn(firecrawlResult, geminiResult, supabaseResult, logs) {\r\n    return {\r\n        firecrawl: firecrawlResult,\r\n        gemini: geminiResult,\r\n        supabase: supabaseResult,\r\n        logs,\r\n        overallStatus: 'Error',\r\n    };\r\n}\r\n// Helper function to process the Firecrawl stage\r\nasync function processFirecrawlStage(url, rawText, logs) {\r\n    const firecrawlStageOutput = await handleFirecrawlStage(url ?? '', rawText, logs);\r\n    const { firecrawlResult, contentToProcess, sourceUrlForProcessing } = firecrawlStageOutput;\r\n    if (firecrawlResult.status === 'Error') {\r\n        return undefined;\r\n    }\r\n    return { firecrawlResult, contentToProcess, sourceUrlForProcessing };\r\n}\r\n// Helper function to process the Gemini stage\r\nasync function processGeminiStage(contentToProcess, sourceUrlForProcessing, logs) {\r\n    if (contentToProcess === undefined) {\r\n        logs.push('Content to process is undefined before Gemini stage.');\r\n        return undefined;\r\n    }\r\n    const geminiStageOutput = await handleGeminiStage(contentToProcess, sourceUrlForProcessing, logs);\r\n    const { geminiResult, extractedData } = geminiStageOutput;\r\n    if (geminiResult.status === 'Error' || extractedData === undefined) {\r\n        logs.push(`Gemini stage failed or returned no data. Status: ${geminiResult.status}, Data: ${JSON.stringify(extractedData)}`);\r\n        return undefined;\r\n    }\r\n    return { geminiResult, extractedData };\r\n}\r\n// Helper function to process the Supabase stage\r\nasync function processSupabaseStage(extractedData, sourceUrlForProcessing, isDryRun, logs) {\r\n    const supabaseResult = await handleSupabaseStage(extractedData, sourceUrlForProcessing, isDryRun, logs);\r\n    if (supabaseResult.status === 'Error') {\r\n        return undefined;\r\n    }\r\n    return supabaseResult;\r\n}\r\n// Helper function to handle the result of the Gemini stage\r\nfunction handleGeminiStageResult(geminiStage, firecrawlResult, logs) {\r\n    if (geminiStage === undefined) {\r\n        return {\r\n            status: 'Error',\r\n            result: handleStageErrorAndReturn(firecrawlResult, { status: 'Error', error: 'Gemini stage failed' }, undefined, logs),\r\n        };\r\n    }\r\n    const { geminiResult, extractedData } = geminiStage;\r\n    if (extractedData === undefined) {\r\n        return {\r\n            status: 'Error',\r\n            result: handleStageErrorAndReturn(firecrawlResult, geminiResult, { status: 'Error', error: 'Extracted data is undefined after Gemini stage' }, logs),\r\n        };\r\n    }\r\n    return { status: 'Success', geminiResult, extractedData };\r\n}\r\n// Type guard for PipelineRunResult\r\nfunction isPipelineRunResult(obj) {\r\n    return (typeof obj === 'object' &&\r\n        obj !== null &&\r\n        'overallStatus' in obj &&\r\n        obj.overallStatus === 'Error');\r\n}\r\n// Define Gemini and Supabase stage helpers before runTestPipeline and ensure they are async if needed\r\nasync function handleGeminiStagePipeline(contentToProcess, sourceUrlForProcessing, logs, firecrawlResult) {\r\n    const geminiStage = await processGeminiStage(contentToProcess, sourceUrlForProcessing, logs);\r\n    const geminiStageHandled = handleGeminiStageResult(geminiStage, firecrawlResult, logs);\r\n    if (geminiStageHandled.status === 'Error') {\r\n        return geminiStageHandled.result;\r\n    }\r\n    return geminiStageHandled;\r\n}\r\n// Make handleSupabaseStagePipeline async and ensure it is awaited in runTestPipeline\r\nasync function handleSupabaseStagePipeline(config) {\r\n    const { extractedData, sourceUrlForProcessing, isDryRun, logs, firecrawlResult, geminiResult } = config;\r\n    const supabaseStage = await processSupabaseStage(extractedData, sourceUrlForProcessing, isDryRun, logs);\r\n    if (supabaseStage === undefined) {\r\n        return handleStageErrorAndReturn(firecrawlResult, geminiResult, { status: 'Error', error: 'Supabase stage failed' }, logs);\r\n    }\r\n    return supabaseStage;\r\n}\r\n// Helper function to handle the Firecrawl stage within the pipeline\r\nasync function executeFirecrawlStage(url, rawText, logs) {\r\n    const firecrawlStageOutput = await processFirecrawlStage(url ?? '', rawText, logs);\r\n    if (!firecrawlStageOutput) {\r\n        return handleStageErrorAndReturn({ status: 'Error', error: 'Firecrawl stage failed' }, undefined, undefined, logs);\r\n    }\r\n    return firecrawlStageOutput;\r\n}\r\n// Helper function to handle the Gemini stage within the pipeline\r\nasync function executeGeminiStage(contentToProcess, sourceUrlForProcessing, logs, firecrawlResult) {\r\n    const geminiStageHandled = await handleGeminiStagePipeline(contentToProcess, sourceUrlForProcessing, logs, firecrawlResult);\r\n    if ('overallStatus' in geminiStageHandled) {\r\n        return geminiStageHandled;\r\n    }\r\n    return geminiStageHandled;\r\n}\r\n// Helper function to handle the Supabase stage within the pipeline\r\nasync function executeSupabaseStage(config) {\r\n    const supabaseStage = await handleSupabaseStagePipeline(config);\r\n    return supabaseStage;\r\n}\r\n// Generic helper to execute a pipeline stage and handle its result\r\nasync function executePipelineStage(stageFunction, args) {\r\n    const output = await stageFunction(...args);\r\n    return output;\r\n}\r\n// Extracted helper function for pipeline execution\r\nexport async function executePipeline(url, rawText, isDryRun, logs) {\r\n    const firecrawlOutput = await executePipelineStage(executeFirecrawlStage, [\r\n        url ?? '',\r\n        rawText,\r\n        logs,\r\n    ]);\r\n    if (isPipelineRunResult(firecrawlOutput)) {\r\n        return firecrawlOutput;\r\n    }\r\n    const { firecrawlResult, contentToProcess, sourceUrlForProcessing } = firecrawlOutput;\r\n    const geminiResultObject = await executeGeminiStage(contentToProcess, sourceUrlForProcessing, logs, firecrawlResult);\r\n    if (isPipelineRunResult(geminiResultObject)) {\r\n        return geminiResultObject;\r\n    }\r\n    const { geminiResult, extractedData } = geminiResultObject;\r\n    const supabaseOutput = await executePipelineStage(executeSupabaseStage, [\r\n        {\r\n            extractedData,\r\n            sourceUrlForProcessing,\r\n            isDryRun,\r\n            logs,\r\n            firecrawlResult,\r\n            geminiResult,\r\n        },\r\n    ]);\r\n    if (isPipelineRunResult(supabaseOutput)) {\r\n        return supabaseOutput;\r\n    }\r\n    return {\r\n        firecrawl: firecrawlResult,\r\n        gemini: geminiResult,\r\n        supabase: supabaseOutput,\r\n        logs: [...logs, 'Test pipeline run completed successfully.'],\r\n        overallStatus: 'Success',\r\n    };\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\api\\test-integration\\pipelineRunnerHelpers.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\api\\test-integration\\schemaMapper.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\api\\test-integration\\schemaMapper.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":8,"column":8,"nodeType":"Identifier","messageId":"conditionErrorObject","endLine":8,"endColumn":21}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { ExtractedFoodTruckDetails, FoodTruckSchema, MenuCategory, MenuItem } from '@/lib/types';\r\n\r\nexport function mapExtractedDataToTruckSchema(\r\n  extractedData: ExtractedFoodTruckDetails,\r\n  sourceUrl: string,\r\n  isDryRun: boolean,\r\n): FoodTruckSchema {\r\n  if (!extractedData || typeof extractedData !== 'object') {\r\n    throw new Error('Invalid extractedData for mapping.');\r\n  }\r\n\r\n  const name = extractedData.name ?? 'Unknown Test Truck';\r\n  const locationData = extractedData.current_location ?? {};\r\n  const fullAddress = [\r\n    locationData.address,\r\n    locationData.city,\r\n    locationData.state,\r\n    locationData.zip_code,\r\n  ]\r\n    .filter(Boolean)\r\n    .join(', ');\r\n\r\n  return {\r\n    name: name,\r\n    description: extractedData.description ?? undefined,\r\n    current_location: {\r\n      lat: locationData.lat ?? 0,\r\n      lng: locationData.lng ?? 0,\r\n      address: fullAddress ?? locationData.raw_text ?? undefined,\r\n      timestamp: new Date().toISOString(),\r\n    },\r\n    scheduled_locations: extractedData.scheduled_locations ?? undefined,\r\n    operating_hours: extractedData.operating_hours ?? undefined,\r\n    menu: (extractedData.menu ?? []).map((category: MenuCategory) => ({\r\n      name: category.name ?? 'Uncategorized',\r\n      items: (category.items ?? []).map((item: MenuItem) => ({\r\n        name: item.name ?? 'Unknown Item',\r\n        description: item.description ?? undefined,\r\n        price:\r\n          typeof item.price === 'number' || typeof item.price === 'string' ? item.price : undefined,\r\n        dietary_tags: item.dietary_tags ?? [],\r\n      })),\r\n    })),\r\n    contact_info: extractedData.contact_info ?? undefined,\r\n    social_media: extractedData.social_media ?? undefined,\r\n    cuisine_type: extractedData.cuisine_type ?? [],\r\n    price_range: extractedData.price_range ?? undefined,\r\n    specialties: extractedData.specialties ?? [],\r\n    data_quality_score: isDryRun ? 0.5 : 0.6, // Differentiate test/dry run\r\n    verification_status: 'pending',\r\n    source_urls: [sourceUrl].filter(Boolean),\r\n    last_scraped_at: new Date().toISOString(),\r\n    ...(isDryRun && { test_run_flag: true }), // Add a flag for actual test saves if needed\r\n  };\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\api\\test-integration\\stageHandlers.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\api\\test-integration\\stageHandlers.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\api\\trucks\\handlers.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\api\\trucks\\handlers.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\auth\\authHelpers.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\auth\\authHelpers.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":6,"column":10,"nodeType":"Identifier","messageId":"conditionErrorNullableString","endLine":6,"endColumn":20,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[204,215],"text":"authHeader == null"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[205,215],"text":"(authHeader ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[204,215],"text":"!Boolean(authHeader)"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { supabase } from '@/lib/supabase';\r\n\r\nexport async function verifyAdminAccess(request: Request): Promise<boolean> {\r\n  try {\r\n    const authHeader = request.headers.get('authorization');\r\n    if (!authHeader) return false;\r\n\r\n    const token = authHeader.replace('Bearer ', '');\r\n    const { data, error } = await supabase.auth.getUser(token);\r\n    const user = data?.user;\r\n\r\n    if (error || !user) return false;\r\n\r\n    const { data: profile } = await supabase\r\n      .from('profiles')\r\n      .select('role')\r\n      .eq('id', user.id)\r\n      .single();\r\n\r\n    return profile?.role === 'admin';\r\n  } catch {\r\n    return false;\r\n  }\r\n}","usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\autoScraper.js","messages":[{"ruleId":"sonarjs/unused-import","severity":2,"message":"Remove this unused import of 'processScrapingJob'.","line":4,"column":10,"nodeType":"Identifier","messageId":"removeUnusedImport","endLine":4,"endColumn":28,"suggestions":[{"messageId":"suggestRemoveWholeStatement","fix":{"range":[175,242],"text":""},"desc":"Remove this import statement"}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// lib/autoScraper.ts\r\nimport { DEFAULT_SCRAPE_URLS, DEFAULT_STALENESS_THRESHOLD_DAYS } from './config.js';\r\nimport { supabaseAdmin, ScrapingJobService } from './supabase.js';\r\nimport { processScrapingJob } from '../lib/pipelineProcessor.js';\r\nimport { dispatchGeminiOperation } from './gemini.js';\r\n/*\r\nFood Truck Scraping Strategy (wbs 2.1.2)\r\n----------------------------------------\r\nGoal: Extract structured data for food trucks (description, menu, prices, locations, events) from web sources.\r\n\r\n1. Discovery:\r\n   - Use internal API endpoints that leverage Tavily MCP tools to find food truck directories and individual truck sites.\r\n   - Filter urls to target only likely food truck homepages or menu/schedule pages.\r\n\r\n2. Content Extraction:\r\n   - For each truck site, extract:\r\n     - Description: Look for about/landing page text, business summary, or meta description.\r\n     - Menu: Scrape menu sections, parse categories, items, prices, and dietary tags.\r\n     - Prices: Extract explicit prices as numbers; fallback to price range if only text is available.\r\n     - Locations: Parse current and scheduled locations, addresses, and geocoordinates if present.\r\n     - Events: Identify event/calendar/schedule sections for upcoming appearances.\r\n\r\n3. Data Mapping:\r\n   - Map extracted fields to Supabase schema:\r\n     - name, description, cuisine_type, specialties\r\n     - menu (categories/items/prices/dietary_tags)\r\n     - current_location, scheduled_locations, exact_location, city_location\r\n     - events (future: event table)\r\n\r\n4. Quality & Validation:\r\n   - Use Gemini to summarize/clean descriptions and standardize menu/locations.\r\n   - Validate extracted data types and required fields before db insert.\r\n   - Log and skip/flag incomplete or ambiguous records for review.\r\n\r\n5. Ingestion:\r\n   - Upsert into Supabase using unique identifier (e.g., website url or business name).\r\n   - Avoid duplicates and resolve conflicts by preferring most recent or most complete data.\r\n\r\n6. Automation:\r\n   - Schedule regular crawls and re-scrapes.\r\n   - Track api usage and cache results to stay within rate limits.\r\n   - Monitor for site changes and trigger updates as needed.\r\n*/\r\n// Helper to trigger a scraping process for a given url\r\n/**\r\n * Initiates a web scraping process for a given target URL.\r\n * @example\r\n * triggerScrapingProcess('https://example.com')\r\n * { success: true, jobId: '12345', message: 'Scraping job created and processing initiated for https://example.com.' }\r\n * @param {string} targetUrl - The URL of the website to be scraped.\r\n * @returns {Promise<TriggerScrapingProcessResult>} Result of the attempt to trigger the scraping process, including success status, job ID, and message or error.\r\n * @description\r\n *   - Creates a web scraping job with a priority of 5 and triggers its processing.\r\n *   - Handles errors during job creation or processing gracefully.\r\n *   - Uses the current timestamp to schedule the job.\r\n */\r\nasync function triggerScrapingProcess(targetUrl) {\r\n    try {\r\n        const job = await ScrapingJobService.createJob({\r\n            job_type: 'website_auto',\r\n            target_url: targetUrl,\r\n            priority: 5,\r\n            status: 'pending', // Explicitly set status to pending\r\n            scheduled_at: new Date().toISOString(),\r\n        });\r\n        // processScrapingJob(job.id).catch((error) => {\r\n        //     console.error('Failed to process scraping job:', error);\r\n        // });\r\n        return {\r\n            success: true,\r\n            jobId: job.id,\r\n            message: `Scraping job created for ${targetUrl}.`,\r\n        };\r\n    }\r\n    catch (error) {\r\n        return {\r\n            success: false,\r\n            error: error instanceof Error ? error.message : 'Failed to create job',\r\n        };\r\n    }\r\n}\r\n// Helper function to process existing truck results\r\n/**\r\n * Processes the result of an existing truck scraping operation.\r\n * @example\r\n * processExistingTruckResult('http://example.com', { status: 'fresh' }, { trucksProcessed: 1, newTrucksFound: 0 }, []);\r\n * // no return value, updates states and logs errors if any\r\n * @param {string} url - The URL of the truck to process.\r\n * @param {{ status: string; details?: string }} result - The result of the truck scraping operation, including status and optional details.\r\n * @param {{ trucksProcessed: number; newTrucksFound: number }} counters - Trackers for counting processed and newly found trucks.\r\n * @param {Array<{ url: string; details?: string }>} errors - A list to record any URLs that result in errors, along with optional error details.\r\n * @returns {Promise<void>} Resolves when processing is complete, performing status updates.\r\n * @description\r\n *   - Updates the status of the URL based on the result: either processing, processed, or irrelevant.\r\n *   - Pushes any error information to the errors array for further processing or logging.\r\n *   - Utilizes different status handling depending on the freshness or error state of the data.\r\n */\r\nasync function processExistingTruckResult(url, result, counters, errors) {\r\n    switch (result.status) {\r\n        case 're-scraping_triggered': {\r\n            counters.trucksProcessed += 1;\r\n            await updateDiscoveredUrlStatus(url, 'processing', 'Re-scraping triggered due to stale data');\r\n            break;\r\n        }\r\n        case 'fresh': {\r\n            await updateDiscoveredUrlStatus(url, 'processed', 'Data is fresh, no action needed');\r\n            break;\r\n        }\r\n        case 'error': {\r\n            errors.push({ url, details: result.details });\r\n            await updateDiscoveredUrlStatus(url, 'irrelevant', `Error: ${result.details}`);\r\n            break;\r\n        }\r\n        // No default\r\n    }\r\n}\r\n// Helper function to process new truck results\r\n/**\r\n * Processes the result of a new truck resource and updates the counters accordingly.\r\n * @example\r\n * processNewTruckResult('https://example.com/truck', { status: 'initial_scrape_triggered' }, { trucksProcessed: 5, newTrucksFound: 2 }, []);\r\n * // Updates counters and changes URL status to 'processing'.\r\n * @param {string} url - The URL of the new truck resource to be processed.\r\n * @param {Object} result - The result object containing the status and optional details of the process.\r\n * @param {string} result.status - The status of the truck processing result.\r\n * @param {string} [result.details] - Optional detailed message about the result.\r\n * @param {Object} counters - An object keeping count of processed trucks and newly found trucks.\r\n * @param {number} counters.trucksProcessed - The current count of processed trucks.\r\n * @param {number} counters.newTrucksFound - The count of newly found trucks.\r\n * @param {Array<Object>} errors - A list of error objects for unsuccessful processing attempts.\r\n * @param {string} errors.url - The URL of the truck resource that encountered an error.\r\n * @param {string} [errors.details] - Optional error details associated with the URL.\r\n * @returns {Promise<void>} This function returns nothing but performs asynchronous URL status updates and error logging.\r\n * @description\r\n *   - The function distinguishes between two specific statuses: 'initial_scrape_triggered' and 'error'.\r\n *   - For 'initial_scrape_triggered', it updates the counters and marks the URL as 'processing'.\r\n *   - For 'error', it logs the error details and marks the URL as 'irrelevant'.\r\n */\r\nasync function processNewTruckResult(url, result, counters, errors) {\r\n    if (result.status === 'initial_scrape_triggered') {\r\n        counters.newTrucksFound += 1;\r\n        counters.trucksProcessed += 1;\r\n        await updateDiscoveredUrlStatus(url, 'processing', 'Initial scraping triggered');\r\n    }\r\n    else if (result.status === 'error') {\r\n        errors.push({ url, details: result.details });\r\n        await updateDiscoveredUrlStatus(url, 'irrelevant', `Error: ${result.details}`);\r\n    }\r\n}\r\n// Helper function to find existing truck for URL\r\n/**\r\n* Find an existing food truck based on the provided source URL.\r\n* @example\r\n* findExistingTruck('https://foodtruck.com/123')\r\n* { truck: { id: 1, last_scraped_at: '2023-09-16T00:00:00Z', source_urls: ['https://foodtruck.com'] } }\r\n* @param {string} url - The source URL used to search for an existing truck in the database.\r\n* @returns {Promise<{ truck?: FoodTruck; error?: string }>} An object containing either the existing truck data or an error message.\r\n* @description\r\n*   - Utilizes Supabase admin client to query the 'food_trucks' database table.\r\n*   - Warns in the console when a query error occurs during the database lookup.\r\n*   - Limits the query results to a single truck that matches the URL criteria.\r\n*/\r\nasync function findExistingTruck(url) {\r\n    if (!supabaseAdmin) {\r\n        return { error: 'Supabase admin client not available' };\r\n    }\r\n    const { data: existingTrucks, error: truckQueryError } = await supabaseAdmin\r\n        .from('food_trucks')\r\n        .select('id, last_scraped_at, source_urls')\r\n        .or(`source_urls.cs.{\"${url}\"}`)\r\n        .limit(1);\r\n    if (truckQueryError) {\r\n        console.warn(`AutoScraper: Error querying for existing truck for url ${url}:`, truckQueryError.message);\r\n        return { error: `Supabase query error: ${truckQueryError.message}` };\r\n    }\r\n    const truck = existingTrucks != undefined && existingTrucks.length > 0\r\n        ? existingTrucks[0]\r\n        : undefined;\r\n    return { truck };\r\n}\r\n/**\r\n * Initiates the autonomous scraping process and ensures default trucks data is fetched.\r\n * @example\r\n * ensureDefaultTrucksAreScraped()\r\n * Returns a result object containing the number of trucks processed, new trucks found, and any errors encountered.\r\n * @returns {Promise<AutoScrapeResult>} An object containing the results of the scraping process, including processed trucks count, new trucks discovered count, and encountered errors.\r\n * @description\r\n *   - Combines static default URLs with dynamically discovered URLs for scraping.\r\n *   - Handles both existing and new trucks, updating counters and tracking errors.\r\n *   - Logs process information and warnings for unexpected errors during execution.\r\n */\r\nexport async function ensureDefaultTrucksAreScraped() {\r\n    console.info('AutoScraper: Starting autonomous scraping process...');\r\n    const counters = { trucksProcessed: 0, newTrucksFound: 0 };\r\n    const errors = [];\r\n    // Get URLs to scrape - combine static defaults with dynamically discovered URLs\r\n    const urlsToScrape = await getUrlsToScrape();\r\n    console.info(`AutoScraper: Found ${urlsToScrape.length} URLs to process`);\r\n    for (const url of urlsToScrape) {\r\n        try {\r\n            console.info(`AutoScraper: Checking url: ${url}`);\r\n            const { truck, error } = await findExistingTruck(url);\r\n            if (error != undefined) {\r\n                errors.push({ url, details: error });\r\n                continue;\r\n            }\r\n            if (truck) {\r\n                const result = await handleExistingTruck(url, truck);\r\n                await processExistingTruckResult(url, result, counters, errors);\r\n            }\r\n            else {\r\n                const result = await handleNewTruck(url);\r\n                await processNewTruckResult(url, result, counters, errors);\r\n            }\r\n        }\r\n        catch (error) {\r\n            console.warn(`AutoScraper: Unexpected error processing url ${url}:`, error);\r\n            errors.push({\r\n                url,\r\n                details: error instanceof Error ? error.message : 'Unknown error',\r\n            });\r\n        }\r\n    }\r\n    console.info('AutoScraper: Finished autonomous scraping process.');\r\n    return {\r\n        trucksProcessed: counters.trucksProcessed,\r\n        newTrucksFound: counters.newTrucksFound,\r\n        errors,\r\n    };\r\n}\r\n/**\r\n* Handles the existing truck data by checking staleness and potentially triggering a re-scrape process.\r\n* @example\r\n* handleExistingTruck('https://example.com/truck', { id: '123', last_scraped_at: '2023-09-01T00:00:00Z' })\r\n* { url: 'https://example.com/truck', status: 'fresh', details: 'Last scraped at 2023-09-01T00:00:00Z' }\r\n* @param {string} url - The URL of the food truck to check for staleness.\r\n* @param {FoodTruck} truck - The food truck object containing its ID and last scrape date.\r\n* @returns {Promise<{url: string; status: string; details?: string; jobId?: string}>} Returns the status and additional detail about the scraping process.\r\n* @description\r\n*   - Only triggers the re-scraping process if the data is considered stale based on a predefined threshold.\r\n*   - Logs information about the current state of the truck's data freshness.\r\n*   - Utilizes an asynchronous operation to potentially trigger a re-scrape.\r\n*   - Returns an object indicating whether action was taken or not.\r\n*/\r\nasync function handleExistingTruck(url, truck) {\r\n    console.info(`AutoScraper: Found existing truck for ${url} (id: ${truck.id}). Last scraped: ${truck.last_scraped_at}`);\r\n    const lastScrapedDate = new Date(truck.last_scraped_at);\r\n    const stalenessLimit = new Date();\r\n    stalenessLimit.setDate(stalenessLimit.getDate() - DEFAULT_STALENESS_THRESHOLD_DAYS);\r\n    if (lastScrapedDate < stalenessLimit) {\r\n        console.info(`AutoScraper: Data for ${url} is stale. Triggering re-scrape.`);\r\n        const triggerResult = await triggerScrapingProcess(url);\r\n        return {\r\n            url,\r\n            status: triggerResult.success ? 're-scraping_triggered' : 'error',\r\n            details: triggerResult.error ?? triggerResult.message,\r\n            jobId: triggerResult.jobId,\r\n        };\r\n    }\r\n    console.info(`AutoScraper: Data for ${url} is fresh. No action needed.`);\r\n    return { url, status: 'fresh', details: `Last scraped at ${truck.last_scraped_at}` };\r\n}\r\n/**\r\n * Initiates a scraping process for a new truck based on the given URL and returns the scraping status.\r\n * @example\r\n * handleNewTruck(\"https://example.com/truck-detail\")\r\n * // Returns: { url: \"https://example.com/truck-detail\", status: \"initial_scrape_triggered\", details: \"Scraping initiated\", jobId: \"12345\" }\r\n * @param {string} url - The URL of the truck details page to be scraped.\r\n * @returns {Promise<{ url: string; status: string; details?: string; jobId?: string }>} An object containing the URL, status of the scraping attempt, optional details message, and optional job ID.\r\n * @description\r\n *   - Uses an asynchronous function to trigger the scraping process.\r\n *   - Logs an informational message when no existing truck is found for the given URL.\r\n *   - Returns a status indicating whether the scrape was successfully triggered or if there was an error.\r\n */\r\nasync function handleNewTruck(url) {\r\n    console.info(`AutoScraper: No existing truck found for ${url}. Triggering initial scrape.`);\r\n    const triggerResult = await triggerScrapingProcess(url);\r\n    return {\r\n        url,\r\n        status: triggerResult.success ? 'initial_scrape_triggered' : 'error',\r\n        details: triggerResult.error ?? triggerResult.message,\r\n        jobId: triggerResult.jobId,\r\n    };\r\n}\r\n// --- Gemini API Rate Limiting & Caching ---\r\nconst GEMINI_CACHE_TTL_MS = 1000 * 60 * 60 * 6; // 6 hours\r\nconst geminiCache = {};\r\n/**\r\n * Makes a call to Gemini service and caches the result to optimize performance.\r\n * @example\r\n * callGeminiWithCache('getData', { id: 123 }, geminiInstance)\r\n * // returns the result from the Gemini service or cache\r\n * @param {string} type - The type of operation to perform with Gemini.\r\n * @param {unknown} input - The input data required for the Gemini operation.\r\n * @param {GeminiService} gemini - The instance of GeminiService to interact with.\r\n * @returns {Promise<unknown>} Returns a promise that resolves to the result of the Gemini operation.\r\n * @description\r\n *   - Caches the result of Gemini service calls to avoid redundant requests.\r\n *   - Automatically cleans up expired cache entries based on a specified TTL.\r\n *   - Checks Gemini usage limits before making API calls to prevent exceeding the daily cap.\r\n *   - Constructs a unique cache key for each request using the operation type and input.\r\n */\r\nexport async function callGeminiWithCache(type, input, gemini) {\r\n    const cacheKey = `${type}:${JSON.stringify(input)}`;\r\n    const now = Date.now();\r\n    // Clean up expired cache\r\n    for (const key in geminiCache) {\r\n        if (Object.prototype.hasOwnProperty.call(geminiCache, key) &&\r\n            now - geminiCache[key].timestamp > GEMINI_CACHE_TTL_MS) {\r\n            delete geminiCache[key];\r\n        }\r\n    }\r\n    if (geminiCache[cacheKey] != undefined &&\r\n        now - geminiCache[cacheKey].timestamp < GEMINI_CACHE_TTL_MS) {\r\n        return geminiCache[cacheKey].data;\r\n    }\r\n    // Check Gemini usage limits before making a call\r\n    const usage = await gemini.checkUsageLimits();\r\n    if (!usage.canMakeRequest) {\r\n        throw new Error('Gemini API daily limit reached. Try again tomorrow.');\r\n    }\r\n    // @ts-expect-error TS(2345): Argument of type 'string' is not assignable to par... Remove this comment to see the full error message\r\n    const result = await dispatchGeminiOperation(type, input);\r\n    geminiCache[cacheKey] = { data: result, timestamp: now };\r\n    return result;\r\n}\r\n// Helper to get URLs to scrape from both static defaults and dynamic discovery\r\n/**\r\n* Retrieves a list of URLs that are ready for scraping.\r\n* @example\r\n* getUrlsToScrape()\r\n* // Returns a Promise that resolves to an array of URLs\r\n* @param {void} - This function does not take any arguments.\r\n* @returns {Promise<string[]>} A promise that resolves to an array of URLs to be scraped.\r\n* @description\r\n*   - The function returns a combination of default URLs and dynamically discovered URLs.\r\n*   - Utilizes Supabase to fetch URLs marked with 'new' or 'processed' status.\r\n*   - Limits results to prevent system overload, fetching a maximum of 100 URLs.\r\n*   - Handles errors gracefully, logging warnings if the Supabase client is not available or if there is an error in fetching URLs.\r\n*/\r\nasync function getUrlsToScrape() {\r\n    const urls = new Set();\r\n    // Add static default URLs\r\n    for (const url of DEFAULT_SCRAPE_URLS)\r\n        urls.add(url);\r\n    // Add dynamically discovered URLs that are ready for processing\r\n    try {\r\n        if (!supabaseAdmin) {\r\n            console.warn('AutoScraper: Supabase admin client not available for discovered URLs');\r\n            return [...urls];\r\n        }\r\n        const { data: discoveredUrls, error } = await supabaseAdmin\r\n            .from('discovered_urls')\r\n            .select('url')\r\n            .in('status', ['new', 'processed']) // Include both new and previously processed URLs\r\n            .order('discovered_at', { ascending: false })\r\n            .limit(100); // Limit to prevent overwhelming the system\r\n        if (error) {\r\n            console.warn('AutoScraper: Error fetching discovered URLs:', error.message);\r\n        }\r\n        else if (discoveredUrls != undefined) {\r\n            for (const { url } of discoveredUrls)\r\n                urls.add(url);\r\n            console.info(`AutoScraper: Added ${discoveredUrls.length} discovered URLs to scraping queue`);\r\n        }\r\n    }\r\n    catch (error) {\r\n        console.warn('AutoScraper: Failed to fetch discovered URLs:', error);\r\n    }\r\n    return [...urls];\r\n}\r\n// Helper to update discovered URL status after processing\r\n/**\r\n * Updates the status of a discovered URL in the database.\r\n * @example\r\n * updateDiscoveredUrlStatus('http://example.com', 'processed', 'Page successfully processed')\r\n * // Returns: void\r\n * @param {string} url - The URL whose status needs updating.\r\n * @param {'processing' | 'processed' | 'irrelevant'} status - The new status for the URL.\r\n * @param {string} [notes] - Optional notes regarding the URL status update.\r\n * @returns {Promise<void>} Resolves when the update operation is complete.\r\n * @description\r\n *   - Logs a warning if the Supabase admin client is not available.\r\n *   - Uses Supabase to update the status and logs an error if the operation fails.\r\n *   - Assumes the existence of a 'discovered_urls' table in the database.\r\n */\r\nasync function updateDiscoveredUrlStatus(url, status, notes) {\r\n    try {\r\n        if (!supabaseAdmin) {\r\n            console.warn(`AutoScraper: Cannot update status for ${url} - Supabase admin client not available`);\r\n            return;\r\n        }\r\n        const { error } = await supabaseAdmin\r\n            .from('discovered_urls')\r\n            .update({\r\n            status,\r\n            last_processed_at: new Date().toISOString(),\r\n            notes: notes ?? undefined,\r\n        })\r\n            .eq('url', url);\r\n        if (error != undefined) {\r\n            console.warn(`AutoScraper: Failed to update status for ${url}:`, error.message);\r\n        }\r\n    }\r\n    catch (error) {\r\n        console.warn(`AutoScraper: Error updating discovered URL status for ${url}:`, error);\r\n    }\r\n}\r\n// Note on processScrapingJob import:\r\n// The direct import of `processScrapingJob` from `@/app/api/scrape/route.ts` can be problematic\r\n// if `route.ts` has side effects or dependencies not suitable for a library context (like NextRequest/Response).\r\n// A cleaner way would be to refactor `processScrapingJob` into a shared utility if it's to be called directly,\r\n// or for `triggerScrapingProcess` to make an internal http post request to `/api/scrape`.\r\n// For this iteration, we are attempting direct call, assuming it's manageable.\r\n// Export autoScraper object for use in cron jobs\r\nexport const autoScraper = {\r\n    runAutoScraping: ensureDefaultTrucksAreScraped,\r\n    triggerScrapingProcess,\r\n    callGeminiWithCache,\r\n    getUrlsToScrape,\r\n    updateDiscoveredUrlStatus,\r\n};\r\n// Main autonomous scraping function that combines discovery and scraping\r\nexport async function runAutonomousScraping() {\r\n    console.info('AutoScraper: Starting fully autonomous scraping cycle...');\r\n    // This function can be called by the autonomous scheduler\r\n    // It uses the updated ensureDefaultTrucksAreScraped which now pulls from discovered_urls\r\n    return await ensureDefaultTrucksAreScraped();\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\autoScraper.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\config.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\cva.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\cva.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\data-quality\\batchCleanup.js","messages":[{"ruleId":null,"nodeType":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token =","line":126,"column":34}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * SOTA Batch Data Cleanup System\r\n * Implements automated data quality improvements and cleanup operations\r\n */\r\nimport { FoodTruckService, DataQualityService } from '../../lib/supabase.js';\r\nimport { DuplicatePreventionService } from './duplicatePrevention.js';\r\nimport { getPlaceholderPatterns, processTruckForPlaceholders } from './placeholderUtils.js';\r\n/**\r\n * Automated Data Quality Cleanup Service\r\n */\r\nexport class BatchCleanupService {\r\n    /**\r\n     * Run comprehensive data cleanup operations\r\n     */\r\n    static async runFullCleanup(options = {}) {\r\n        const startTime = Date.now();\r\n        const { batchSize = 50, dryRun = false, operations = [\r\n            'remove_placeholders',\r\n            'normalize_phone',\r\n            'fix_coordinates',\r\n            'update_quality_scores',\r\n            'merge_duplicates',\r\n        ], } = options;\r\n        console.info(`Starting batch cleanup (${dryRun ? 'DRY RUN' : 'LIVE'})...`);\r\n        const result = this.initializeCleanupResult();\r\n        try {\r\n            const allTrucks = await FoodTruckService.getAllTrucks();\r\n            result.totalProcessed = allTrucks.total;\r\n            await this.processTrucksInBatches(allTrucks.trucks, {\r\n                batchSize,\r\n                operations,\r\n                dryRun,\r\n                result,\r\n            });\r\n            return this.finalizeCleanupResult(result, startTime);\r\n        }\r\n        catch (error) {\r\n            console.error('Batch cleanup failed:', error);\r\n            throw error;\r\n        }\r\n    }\r\n    /**\r\n    * Initializes and returns a new BatchCleanupResult object with default values.\r\n    * @example\r\n    * initializeCleanupResult()\r\n    * { totalProcessed: 0, operations: [], summary: { trucksImproved: 0, duplicatesRemoved: 0, qualityScoreImprovement: 0, placeholdersRemoved: 0 }, duration: 0 }\r\n    * @returns {BatchCleanupResult} A new BatchCleanupResult object with all properties set to initial default values.\r\n    */\r\n    static initializeCleanupResult() {\r\n        return {\r\n            totalProcessed: 0,\r\n            operations: [],\r\n            summary: {\r\n                trucksImproved: 0,\r\n                duplicatesRemoved: 0,\r\n                qualityScoreImprovement: 0,\r\n                placeholdersRemoved: 0,\r\n            },\r\n            duration: 0,\r\n        };\r\n    }\r\n    static finalizeCleanupResult(result, startTime) {\r\n        result.summary = this.calculateSummary(result.operations);\r\n        result.duration = Date.now() - startTime;\r\n        console.info(`Batch cleanup completed in ${result.duration}ms`);\r\n        return result;\r\n    }\r\n    /**\r\n     * Processes food trucks in batches, executing specified operations on each batch.\r\n     * @example\r\n     * processTrucksInBatches(truckList, { batchSize: 10, operations: ['clean'], dryRun: true, result: batchResult })\r\n     * // It executes 'clean' operation on batches of 10 trucks without making permanent changes.\r\n     * @param {FoodTruck[]} trucks - Array of food trucks to be processed in batches.\r\n     * @param {object} options - Options object containing batchSize, operations, dryRun, and result.\r\n     * @param {number} options.batchSize - Number of trucks in each batch.\r\n     * @param {CleanupOperation['type'][]} options.operations - Array of operation types to be executed on each batch.\r\n     * @param {boolean} options.dryRun - If true, operations are executed in simulation mode without permanent changes.\r\n     * @param {BatchCleanupResult} options.result - Stores the results of operations performed on batches.\r\n     * @returns {Promise<void>} Completes processing batches without a return value.\r\n     * @description\r\n     *   - Uses async function to allow non-blocking execution of operations.\r\n     *   - Collects and stores results of batch operations separately, keeping track of each operation's outcome.\r\n     *   - Iterates over arrays using slicing to dynamically create batches for processing.\r\n     */\r\n    static async processTrucksInBatches(trucks, { batchSize, operations, dryRun, result, }) {\r\n        for (let i = 0; i < trucks.length; i += batchSize) {\r\n            const batch = trucks.slice(i, i + batchSize);\r\n            for (const op of operations) {\r\n                const opResult = await this.runOperation(op, batch, dryRun);\r\n                result.operations.push(opResult);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Run a specific cleanup operation\r\n     */\r\n    static async runOperation(type, trucks, dryRun) {\r\n        const operation = {\r\n            type,\r\n            description: this.getOperationDescription(type),\r\n            affectedCount: 0,\r\n            successCount: 0,\r\n            errorCount: 0,\r\n            errors: [],\r\n        };\r\n        const operationRunners = {\r\n            remove_placeholders: this.runRemovePlaceholders,\r\n            normalize_phone: this.runNormalizePhoneNumbers,\r\n            fix_coordinates: this.runFixCoordinates,\r\n            update_quality_scores: this.runUpdateQualityScores,\r\n            merge_duplicates: this.runMergeDuplicates,\r\n        };\r\n        try {\r\n            const runner = operationRunners[type];\r\n            if (runner) {\r\n                return await runner.call(this, trucks, dryRun, operation);\r\n            }\r\n            operation.errors.push(`Unknown operation type: ${String(type)}`);\r\n            return operation;\r\n        }\r\n        catch (error) {\r\n            operation.errors.push(`Operation failed: ${error instanceof Error ? error.message : String(error)}`);\r\n            return operation;\r\n        }\r\n    }\r\n    static runRemovePlaceholders = async (trucks, dryRun, operation) => {\r\n        return await this.removePlaceholders(trucks, dryRun, operation);\r\n    };\r\n    static runNormalizePhoneNumbers = async (trucks, dryRun, operation) => {\r\n        return await this.normalizePhoneNumbers(trucks, dryRun, operation);\r\n    };\r\n    static runFixCoordinates = async (trucks, dryRun, operation) => {\r\n        return await this.fixCoordinates(trucks, dryRun, operation);\r\n    };\r\n    static runUpdateQualityScores = async (trucks, dryRun, operation) => {\r\n        return await this.updateQualityScores(trucks, dryRun, operation);\r\n    };\r\n    static runMergeDuplicates = async (trucks, dryRun, operation) => {\r\n        return await this.mergeDuplicates(trucks, dryRun, operation);\r\n    };\r\n    /**\r\n     * Remove placeholder and mock data\r\n     */\r\n    static async removePlaceholders(trucks, dryRun, operation) {\r\n        const placeholderPatterns = getPlaceholderPatterns();\r\n        const promises = trucks.map((truck) => this.processSingleTruckForPlaceholders(truck, placeholderPatterns, dryRun, operation));\r\n        await Promise.all(promises);\r\n        return operation;\r\n    }\r\n    static async processSingleTruckForPlaceholders(truck, patterns, dryRun, operation) {\r\n        const updates = processTruckForPlaceholders(truck, patterns);\r\n        if (updates && Object.keys(updates).length > 0) {\r\n            await this.performUpdateOperation(truck.id, updates, dryRun, operation);\r\n        }\r\n    }\r\n    /**\r\n     * Perform an update operation on a specified food truck.\r\n     * @example\r\n     * performUpdateOperation('truck123', { name: 'New Name' }, true, cleanupOperation)\r\n     * // No direct return value; operation may log errors.\r\n     * @param {string} truckId - The unique identifier of the food truck to be updated.\r\n     * @param {Partial<FoodTruck>} updates - An object containing the fields to be updated.\r\n     * @param {boolean} dryRun - Flag indicating whether the operation should be a simulation without actual changes.\r\n     * @param {CleanupOperation} operation - An operation object that logs errors encountered during update.\r\n     * @returns {Promise<void>} A promise that resolves when the update operation is complete.\r\n     * @description\r\n     *   - If 'dryRun' is true, no updates are applied but actions are logged.\r\n     *   - Errors during update are caught and logged in the 'operation.errors' array.\r\n     */\r\n    static async performUpdateOperation(truckId, updates, dryRun, operation) {\r\n        operation.affectedCount += 1;\r\n        if (dryRun) {\r\n            operation.successCount += 1;\r\n        }\r\n        else {\r\n            try {\r\n                await FoodTruckService.updateTruck(truckId, updates);\r\n                operation.successCount += 1;\r\n            }\r\n            catch (error) {\r\n                operation.errorCount += 1;\r\n                operation.errors.push(`Failed to update truck ${truckId}: ${error instanceof Error ? error.message : String(error)}`);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Normalize phone numbers to consistent format\r\n     */\r\n    static async normalizePhoneNumbers(trucks, dryRun, operation) {\r\n        const promises = trucks.map((truck) => {\r\n            if (truck.contact_info?.phone !== undefined) {\r\n                const originalPhone = truck.contact_info.phone;\r\n                const normalizedPhone = this.normalizePhone(originalPhone);\r\n                if (normalizedPhone !== undefined && normalizedPhone !== originalPhone) {\r\n                    return this.applyPhoneNormalizationUpdate(truck, normalizedPhone, dryRun, operation);\r\n                }\r\n            }\r\n            return Promise.resolve();\r\n        });\r\n        await Promise.all(promises);\r\n        return operation;\r\n    }\r\n    /**\r\n     * Apply phone normalization update to a food truck's contact information.\r\n     * @example\r\n     * applyPhoneNormalizationUpdate(truckInstance, '+1234567890', false, operationInstance)\r\n     * // Normalizes and updates phone number of given truckInstance.\r\n     * @param {FoodTruck} truck - The food truck object whose phone number needs normalization.\r\n     * @param {string} normalizedPhone - The normalized phone number to update to the food truck's contact information.\r\n     * @param {boolean} dryRun - Flag indicating whether the operation is a dry run; updates are skipped if true.\r\n     * @param {CleanupOperation} operation - Object containing cleanup operation context including a record of errors.\r\n     * @returns {Promise<void>} Does not return a value, but potentially modifies the truck and operation objects.\r\n     * @description\r\n     *   - Executes the update operation only if `dryRun` is false.\r\n     *   - Pushes error messages to `operation.errors` on failure during the update process.\r\n     *   - Uses `FoodTruckService.updateTruck` for updating the contact information.\r\n     */\r\n    static async applyPhoneNormalizationUpdate(truck, normalizedPhone, dryRun, operation) {\r\n        operation.affectedCount += 1;\r\n        if (dryRun) {\r\n            operation.successCount += 1;\r\n        }\r\n        else {\r\n            try {\r\n                await FoodTruckService.updateTruck(truck.id, {\r\n                    contact_info: {\r\n                        ...truck.contact_info,\r\n                        phone: normalizedPhone,\r\n                    },\r\n                });\r\n                operation.successCount += 1;\r\n            }\r\n            catch (error) {\r\n                operation.errorCount += 1;\r\n                operation.errors.push(`Failed to normalize phone for truck ${truck.id}: ${error instanceof Error ? error.message : String(error)}`);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Helper to determine if coordinates need fixing and provide updates\r\n     */\r\n    static getFixedCoordinates(lat, lng, defaultLat, defaultLng) {\r\n        // Fix invalid coordinates (0,0 or undefined)\r\n        if (lat === undefined || lng === undefined || lat === 0 || lng === 0) {\r\n            return { lat: defaultLat, lng: defaultLng };\r\n        }\r\n        // Fix coordinates outside reasonable bounds for Charleston area\r\n        if (lat < 32 || lat > 34 || lng > -79 || lng < -81) {\r\n            return { lat: defaultLat, lng: defaultLng };\r\n        }\r\n        return undefined;\r\n    }\r\n    /**\r\n     * Fix invalid GPS coordinates\r\n     */\r\n    static async fixCoordinates(trucks, dryRun, operation) {\r\n        const context = {\r\n            defaultLat: 32.7767,\r\n            defaultLng: -79.9311,\r\n            dryRun,\r\n        };\r\n        const promises = trucks.map((truck) => this.processSingleTruckCoordinates(truck, { ...context, operation }));\r\n        await Promise.all(promises);\r\n        return operation;\r\n    }\r\n    /**\r\n     * Processes coordinates for a single food truck, applying any necessary fixes.\r\n     * @example\r\n     * processSingleTruckCoordinates(truck, context)\r\n     * // No return value, function completes silently\r\n     * @param {FoodTruck} truck - The food truck whose coordinates are to be processed.\r\n     * @param {CoordinateProcessContext} context - Contains configuration and operation context for processing coordinates.\r\n     * @returns {Promise<void>} Returns a promise that resolves when the processing and possible updates are complete.\r\n     * @description\r\n     *   - Skips processing if the truck's current location is not available.\r\n     *   - Retrieves updates for fixed coordinates based on truck's current and default locations.\r\n     *   - Applies updates conditionally based on context settings such as `dryRun` and `operation`.\r\n     */\r\n    static async processSingleTruckCoordinates(truck, context) {\r\n        if (!truck.current_location)\r\n            return;\r\n        const { defaultLat, defaultLng, dryRun, operation } = context;\r\n        const { lat, lng } = truck.current_location;\r\n        const updates = this.getFixedCoordinates(lat, lng, defaultLat, defaultLng);\r\n        if (updates) {\r\n            await this.applyCoordinateFixUpdate(truck, updates, dryRun, operation);\r\n        }\r\n    }\r\n    /**\r\n     * Applies coordinate updates for a food truck's current location.\r\n     * @example\r\n     * applyCoordinateFixUpdate(truck, { lat: 34.05, lng: -118.25 }, false, operation)\r\n     * // Updates the coordinates of the truck's location asynchronously.\r\n     * @param {FoodTruck} truck - The food truck object whose coordinates need correction.\r\n     * @param {Partial<FoodTruck['current_location']>} updates - The latitude and longitude updates to be applied.\r\n     * @param {boolean} dryRun - Flag to simulate the update without altering data.\r\n     * @param {CleanupOperation} operation - The cleanup operation instance used for error tracking.\r\n     * @returns {Promise<void>} Resolves when the coordinate update process is complete.\r\n     * @description\r\n     *   - Executes the update operation only if the dryRun flag is false.\r\n     *   - If the update fails, logs the error details into the operation's error array.\r\n     */\r\n    static async applyCoordinateFixUpdate(truck, updates, dryRun, operation) {\r\n        operation.affectedCount += 1;\r\n        if (dryRun) {\r\n            operation.successCount += 1;\r\n        }\r\n        else {\r\n            try {\r\n                await FoodTruckService.updateTruck(truck.id, {\r\n                    current_location: {\r\n                        ...truck.current_location,\r\n                        ...updates,\r\n                    },\r\n                });\r\n                operation.successCount += 1;\r\n            }\r\n            catch (error) {\r\n                operation.errorCount += 1;\r\n                operation.errors.push(`Failed to fix coordinates for truck ${truck.id}: ${error instanceof Error ? error.message : String(error)}`);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Update quality scores for all trucks\r\n     */\r\n    static async updateQualityScores(trucks, dryRun, operation) {\r\n        const promises = trucks.map((truck) => this.processSingleTruckForQualityScore(truck, dryRun, operation));\r\n        await Promise.all(promises);\r\n        return operation;\r\n    }\r\n    /**\r\n    * Processes a single food truck for an updated quality score assessment.\r\n    * @example\r\n    * processSingleTruckForQualityScore(truckInstance, false, cleanupOperationInstance)\r\n    * // No return value\r\n    * @param {FoodTruck} truck - The food truck instance to assess and potentially update.\r\n    * @param {boolean} dryRun - Specifies whether this is a dry run (no actual data updates).\r\n    * @param {CleanupOperation} operation - The cleanup operation context for processing.\r\n    * @returns {Promise<void>} No return value; operation is performed asynchronously.\r\n    * @description\r\n    *   - Computes the quality score using data from DataQualityService.\r\n    *   - Updates the quality score only if the score changes significantly (>5% difference).\r\n    *   - Assumes `truck.data_quality_score` might be undefined, defaulting to 0.\r\n    *   - Handles asynchronous processing of the update application if conditions are met.\r\n    */\r\n    static async processSingleTruckForQualityScore(truck, dryRun, operation) {\r\n        const qualityAssessment = DataQualityService.calculateQualityScore(truck);\r\n        if (qualityAssessment) {\r\n            const newScore = qualityAssessment.score;\r\n            const currentScore = truck.data_quality_score ?? 0;\r\n            // Only update if score changed significantly (>5% difference)\r\n            if (typeof newScore === 'number' && Math.abs(newScore - currentScore) > 0.05) {\r\n                await this.applyQualityScoreUpdate(truck, dryRun, operation);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Updates the quality score of a specified food truck and handles errors during the update process.\r\n     * @example\r\n     * applyQualityScoreUpdate(foodTruckInstance, false, cleanupOperationInstance)\r\n     * void\r\n     * @param {FoodTruck} truck - The food truck for which the quality score will be updated.\r\n     * @param {boolean} dryRun - Flag indicating whether the function should perform the update or just simulate it.\r\n     * @param {CleanupOperation} operation - The cleanup operation containing possible error records.\r\n     * @returns {Promise<void>} Resolves with no value when the update completes. Errors are recorded in the `operation` if thrown.\r\n     * @description\r\n     *   - Throws an error if the quality score update fails.\r\n     *   - If `dryRun` is true, the function simulates the update without changing any data.\r\n     *   - Errors occurring during the update are appended to the `operation.errors` array.\r\n     */\r\n    static async applyQualityScoreUpdate(truck, dryRun, operation) {\r\n        operation.affectedCount += 1;\r\n        if (dryRun) {\r\n            operation.successCount += 1;\r\n        }\r\n        else {\r\n            try {\r\n                const updateResult = await DataQualityService.updateTruckQualityScore(truck.id);\r\n                if ('error' in updateResult) {\r\n                    throw new Error(updateResult.error);\r\n                }\r\n                operation.successCount += 1;\r\n            }\r\n            catch (error) {\r\n                operation.errorCount += 1;\r\n                operation.errors.push(`Failed to update quality score for truck ${truck.id}: ${error instanceof Error ? error.message : String(error)}`);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Identify and merge duplicate trucks\r\n     */\r\n    static async mergeDuplicates(trucks, dryRun, operation) {\r\n        const processedIds = new Set();\r\n        for (const truck of trucks) {\r\n            await this.processSingleTruckForDuplicates(truck, dryRun, { operation, processedIds });\r\n        }\r\n        return operation;\r\n    }\r\n    /**\r\n     * Processes a single food truck to detect and handle duplicates in the dataset.\r\n     * @example\r\n     * processSingleTruckForDuplicates(foodTruck, true, mergeContext)\r\n     * // No return value. Performs operations as a side effect.\r\n     * @param {FoodTruck} truck - An instance of FoodTruck to process for duplicates.\r\n     * @param {boolean} dryRun - Flag indicating if the operation should be executed in dry run mode.\r\n     * @param {MergeOperationContext} context - Operational context that carries state and configurations for the merge operation.\r\n     * @returns {Promise<void>} Executes a set of operations for handling duplicate records, does not return any value.\r\n     * @description\r\n     *   - Ensures a food truck is only processed once by maintaining a set of processed IDs.\r\n     *   - Uses DuplicatePreventionService to assess whether the given truck is a duplicate.\r\n     *   - Applies a merge operation if a duplicate truck is confidently identified.\r\n     */\r\n    static async processSingleTruckForDuplicates(truck, dryRun, context) {\r\n        const { processedIds } = context;\r\n        if (processedIds.has(truck.id))\r\n            return;\r\n        const duplicateCheck = await DuplicatePreventionService.checkForDuplicates(truck);\r\n        if (duplicateCheck.isDuplicate &&\r\n            duplicateCheck.bestMatch?.confidence === 'high' &&\r\n            duplicateCheck.bestMatch.recommendation === 'merge') {\r\n            await this.applyMergeOperation(truck, duplicateCheck.bestMatch.existingTruck, dryRun, context);\r\n        }\r\n        processedIds.add(truck.id);\r\n    }\r\n    /**\r\n     * Applies a merge operation between two food trucks and updates the context.\r\n     * @example\r\n     * applyMergeOperation(truck, existingTruck, true, context)\r\n     * // Executes a dry run of the merge operation without affecting data\r\n     * @param {FoodTruck} truck - The food truck that is being merged.\r\n     * @param {FoodTruck} existingTruck - The existing food truck to merge with.\r\n     * @param {boolean} dryRun - Indicates if the merge operation should be simulated.\r\n     * @param {MergeOperationContext} context - Context containing details and state of the merge operation.\r\n     * @returns {Promise<void>} Promise representing the completion of the merge operation.\r\n     * @description\r\n     *   - Updates the list of processed IDs in the context upon successful merge.\r\n     *   - Throws and records an error if the merge operation fails.\r\n     *   - Utilizes the DuplicatePreventionService for performing the merge.\r\n     */\r\n    static async applyMergeOperation(truck, existingTruck, dryRun, context) {\r\n        const { operation, processedIds } = context;\r\n        operation.affectedCount += 1;\r\n        if (dryRun) {\r\n            operation.successCount += 1;\r\n        }\r\n        else {\r\n            try {\r\n                const mergeResult = await DuplicatePreventionService.mergeDuplicates(truck.id, existingTruck.id);\r\n                if ('error' in mergeResult) {\r\n                    throw new Error(mergeResult.error);\r\n                }\r\n                processedIds.add(existingTruck.id);\r\n                operation.successCount += 1;\r\n            }\r\n            catch (error) {\r\n                operation.errorCount += 1;\r\n                operation.errors.push(`Failed to merge duplicates ${truck.id} and ${existingTruck.id}: ${error instanceof Error ? error.message : String(error)}`);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Normalize phone number format\r\n     */\r\n    static normalizePhone(phone) {\r\n        if (!phone)\r\n            return undefined;\r\n        // Remove all non-digit characters\r\n        const digits = phone.replaceAll(/\\D/g, '');\r\n        // Handle US phone numbers\r\n        if (digits.length === 10) {\r\n            return `(${digits.slice(0, 3)}) ${digits.slice(3, 6)}-${digits.slice(6)}`;\r\n        }\r\n        if (digits.length === 11 && digits.startsWith('1')) {\r\n            return `+1 (${digits.slice(1, 4)}) ${digits.slice(4, 7)}-${digits.slice(7)}`;\r\n        }\r\n        // Return original if can't normalize\r\n        return phone;\r\n    }\r\n    /**\r\n     * Get operation description\r\n     */\r\n    static getOperationDescription(type) {\r\n        const descriptions = {\r\n            remove_placeholders: 'Remove placeholder and mock data values',\r\n            normalize_phone: 'Normalize phone numbers to consistent format',\r\n            fix_coordinates: 'Fix invalid GPS coordinates',\r\n            update_quality_scores: 'Recalculate data quality scores',\r\n            merge_duplicates: 'Identify and merge duplicate truck entries',\r\n        };\r\n        return descriptions[type] ?? 'Unknown operation';\r\n    }\r\n    /**\r\n     * Calculate cleanup summary\r\n     */\r\n    static calculateSummary(operations) {\r\n        return {\r\n            trucksImproved: operations.reduce((sum, op) => sum + op.successCount, 0),\r\n            duplicatesRemoved: operations.find((op) => op.type === 'merge_duplicates')?.successCount ?? 0,\r\n            qualityScoreImprovement: operations.find((op) => op.type === 'update_quality_scores')?.successCount ?? 0,\r\n            placeholdersRemoved: operations.find((op) => op.type === 'remove_placeholders')?.successCount ?? 0,\r\n        };\r\n    }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\data-quality\\batchCleanup.ts","messages":[{"ruleId":"unicorn/prefer-export-from","severity":2,"message":"Use `export…from` to re-export `CleanupOperation`.","line":12,"column":15,"nodeType":"ExportSpecifier","messageId":"error","endLine":12,"endColumn":31,"fix":{"range":[527,26192],"text":" CleanupOperationType, BatchCleanupResult };\r\n\r\ninterface MergeOperationContext {\r\n  operation: CleanupOperation;\r\n  processedIds: Set<string>;\r\n}\r\n\r\ninterface CoordinateProcessContext {\r\n  defaultLat: number;\r\n  defaultLng: number;\r\n  dryRun: boolean;\r\n  operation: CleanupOperation;\r\n}\r\n\r\n/**\r\n * Automated Data Quality Cleanup Service\r\n */\r\nexport class BatchCleanupService {\r\n  /**\r\n   * Run comprehensive data cleanup operations\r\n   */\r\n  static async runFullCleanup(\r\n    options: {\r\n      batchSize?: number;\r\n      dryRun?: boolean;\r\n      operations?: CleanupOperation['type'][];\r\n    } = {},\r\n  ): Promise<BatchCleanupResult> {\r\n    const startTime = Date.now();\r\n    const {\r\n      batchSize = 50,\r\n      dryRun = false,\r\n      operations = [\r\n        'remove_placeholders',\r\n        'normalize_phone',\r\n        'fix_coordinates',\r\n        'update_quality_scores',\r\n        'merge_duplicates',\r\n      ],\r\n    } = options;\r\n\r\n    console.info(`Starting batch cleanup (${dryRun ? 'DRY RUN' : 'LIVE'})...`);\r\n    const result = this.initializeCleanupResult();\r\n    try {\r\n      const allTrucks = await FoodTruckService.getAllTrucks();\r\n      result.totalProcessed = allTrucks.total;\r\n      await this.processTrucksInBatches(allTrucks.trucks, {\r\n        batchSize,\r\n        operations,\r\n        dryRun,\r\n        result,\r\n      });\r\n      return this.finalizeCleanupResult(result, startTime);\r\n    } catch (error) {\r\n      console.error('Batch cleanup failed:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n  * Initializes and returns a new BatchCleanupResult object with default values.\r\n  * @example\r\n  * initializeCleanupResult()\r\n  * { totalProcessed: 0, operations: [], summary: { trucksImproved: 0, duplicatesRemoved: 0, qualityScoreImprovement: 0, placeholdersRemoved: 0 }, duration: 0 }\r\n  * @returns {BatchCleanupResult} A new BatchCleanupResult object with all properties set to initial default values.\r\n  */\r\n  private static initializeCleanupResult(): BatchCleanupResult {\r\n    return {\r\n      totalProcessed: 0,\r\n      operations: [],\r\n      summary: {\r\n        trucksImproved: 0,\r\n        duplicatesRemoved: 0,\r\n        qualityScoreImprovement: 0,\r\n        placeholdersRemoved: 0,\r\n      },\r\n      duration: 0,\r\n    };\r\n  }\r\n\r\n  private static finalizeCleanupResult(\r\n    result: BatchCleanupResult,\r\n    startTime: number,\r\n  ): BatchCleanupResult {\r\n    result.summary = this.calculateSummary(result.operations);\r\n    result.duration = Date.now() - startTime;\r\n\r\n    console.info(`Batch cleanup completed in ${result.duration}ms`);\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Processes food trucks in batches, executing specified operations on each batch.\r\n   * @example\r\n   * processTrucksInBatches(truckList, { batchSize: 10, operations: ['clean'], dryRun: true, result: batchResult })\r\n   * // It executes 'clean' operation on batches of 10 trucks without making permanent changes.\r\n   * @param {FoodTruck[]} trucks - Array of food trucks to be processed in batches.\r\n   * @param {object} options - Options object containing batchSize, operations, dryRun, and result.\r\n   * @param {number} options.batchSize - Number of trucks in each batch.\r\n   * @param {CleanupOperation['type'][]} options.operations - Array of operation types to be executed on each batch.\r\n   * @param {boolean} options.dryRun - If true, operations are executed in simulation mode without permanent changes.\r\n   * @param {BatchCleanupResult} options.result - Stores the results of operations performed on batches.\r\n   * @returns {Promise<void>} Completes processing batches without a return value.\r\n   * @description\r\n   *   - Uses async function to allow non-blocking execution of operations.\r\n   *   - Collects and stores results of batch operations separately, keeping track of each operation's outcome.\r\n   *   - Iterates over arrays using slicing to dynamically create batches for processing.\r\n   */\r\n  private static async processTrucksInBatches(\r\n    trucks: FoodTruck[],\r\n    {\r\n      batchSize,\r\n      operations,\r\n      dryRun,\r\n      result,\r\n    }: {\r\n      batchSize: number;\r\n      operations: CleanupOperation['type'][];\r\n      dryRun: boolean;\r\n      result: BatchCleanupResult;\r\n    },\r\n  ): Promise<void> {\r\n    for (let i = 0; i < trucks.length; i += batchSize) {\r\n      const batch = trucks.slice(i, i + batchSize);\r\n      for (const op of operations) {\r\n        const opResult = await this.runOperation(op, batch, dryRun);\r\n        result.operations.push(opResult);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Run a specific cleanup operation\r\n   */\r\n  private static async runOperation(\r\n    type: CleanupOperation['type'],\r\n    trucks: FoodTruck[],\r\n    dryRun: boolean,\r\n  ): Promise<CleanupOperation> {\r\n    const operation: CleanupOperation = {\r\n      type,\r\n      description: this.getOperationDescription(type),\r\n      affectedCount: 0,\r\n      successCount: 0,\r\n      errorCount: 0,\r\n      errors: [],\r\n    };\r\n\r\n    const operationRunners = {\r\n      remove_placeholders: this.runRemovePlaceholders,\r\n      normalize_phone: this.runNormalizePhoneNumbers,\r\n      fix_coordinates: this.runFixCoordinates,\r\n      update_quality_scores: this.runUpdateQualityScores,\r\n      merge_duplicates: this.runMergeDuplicates,\r\n    };\r\n\r\n    try {\r\n      const runner = operationRunners[type];\r\n      if (runner) {\r\n        return await runner.call(this, trucks, dryRun, operation);\r\n      } \r\n        operation.errors.push(`Unknown operation type: ${String(type)}`);\r\n        return operation;\r\n      \r\n    } catch (error) {\r\n      operation.errors.push(\r\n        `Operation failed: ${error instanceof Error ? error.message : String(error)}`,\r\n      );\r\n      return operation;\r\n    }\r\n  }\r\n\r\n  private static runRemovePlaceholders = async (\r\n    trucks: FoodTruck[],\r\n    dryRun: boolean,\r\n    operation: CleanupOperation,\r\n  ): Promise<CleanupOperation> => {\r\n    return await this.removePlaceholders(trucks, dryRun, operation);\r\n  };\r\n\r\n  private static runNormalizePhoneNumbers = async (\r\n    trucks: FoodTruck[],\r\n    dryRun: boolean,\r\n    operation: CleanupOperation,\r\n  ): Promise<CleanupOperation> => {\r\n    return await this.normalizePhoneNumbers(trucks, dryRun, operation);\r\n  };\r\n\r\n  private static runFixCoordinates = async (\r\n    trucks: FoodTruck[],\r\n    dryRun: boolean,\r\n    operation: CleanupOperation,\r\n  ): Promise<CleanupOperation> => {\r\n    return await this.fixCoordinates(trucks, dryRun, operation);\r\n  };\r\n\r\n  private static runUpdateQualityScores = async (\r\n    trucks: FoodTruck[],\r\n    dryRun: boolean,\r\n    operation: CleanupOperation,\r\n  ): Promise<CleanupOperation> => {\r\n    return await this.updateQualityScores(trucks, dryRun, operation);\r\n  };\r\n\r\n  private static runMergeDuplicates = async (\r\n    trucks: FoodTruck[],\r\n    dryRun: boolean,\r\n    operation: CleanupOperation,\r\n  ): Promise<CleanupOperation> => {\r\n    return await this.mergeDuplicates(trucks, dryRun, operation);\r\n  };\r\n\r\n  /**\r\n   * Remove placeholder and mock data\r\n   */\r\n  private static async removePlaceholders(\r\n    trucks: FoodTruck[],\r\n    dryRun: boolean,\r\n    operation: CleanupOperation,\r\n  ): Promise<CleanupOperation> {\r\n    const placeholderPatterns = getPlaceholderPatterns();\r\n    const promises = trucks.map((truck) =>\r\n      this.processSingleTruckForPlaceholders(truck, placeholderPatterns, dryRun, operation),\r\n    );\r\n    await Promise.all(promises);\r\n    return operation;\r\n  }\r\n\r\n  private static async processSingleTruckForPlaceholders(\r\n    truck: FoodTruck,\r\n    patterns: RegExp[],\r\n    dryRun: boolean,\r\n    operation: CleanupOperation,\r\n  ): Promise<void> {\r\n    const updates = processTruckForPlaceholders(truck, patterns);\r\n    if (updates && Object.keys(updates).length > 0) {\r\n      await this.performUpdateOperation(truck.id, updates, dryRun, operation);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Perform an update operation on a specified food truck.\r\n   * @example\r\n   * performUpdateOperation('truck123', { name: 'New Name' }, true, cleanupOperation)\r\n   * // No direct return value; operation may log errors.\r\n   * @param {string} truckId - The unique identifier of the food truck to be updated.\r\n   * @param {Partial<FoodTruck>} updates - An object containing the fields to be updated.\r\n   * @param {boolean} dryRun - Flag indicating whether the operation should be a simulation without actual changes.\r\n   * @param {CleanupOperation} operation - An operation object that logs errors encountered during update.\r\n   * @returns {Promise<void>} A promise that resolves when the update operation is complete.\r\n   * @description\r\n   *   - If 'dryRun' is true, no updates are applied but actions are logged.\r\n   *   - Errors during update are caught and logged in the 'operation.errors' array.\r\n   */\r\n  private static async performUpdateOperation(\r\n    truckId: string,\r\n    updates: Partial<FoodTruck>,\r\n    dryRun: boolean,\r\n    operation: CleanupOperation,\r\n  ): Promise<void> {\r\n    operation.affectedCount += 1;\r\n    if (dryRun) {\r\n      operation.successCount += 1;\r\n    } else {\r\n      try {\r\n        await FoodTruckService.updateTruck(truckId, updates);\r\n        operation.successCount += 1;\r\n      } catch (error) {\r\n        operation.errorCount += 1;\r\n        operation.errors.push(\r\n          `Failed to update truck ${truckId}: ${error instanceof Error ? error.message : String(error)}`,\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Normalize phone numbers to consistent format\r\n   */\r\n  private static async normalizePhoneNumbers(\r\n    trucks: FoodTruck[],\r\n    dryRun: boolean,\r\n    operation: CleanupOperation,\r\n  ): Promise<CleanupOperation> {\r\n    const promises = trucks.map((truck) => {\r\n      if (truck.contact_info?.phone !== undefined) {\r\n        const originalPhone = truck.contact_info.phone;\r\n        const normalizedPhone = this.normalizePhone(originalPhone);\r\n\r\n        if (normalizedPhone !== undefined && normalizedPhone !== originalPhone) {\r\n          return this.applyPhoneNormalizationUpdate(truck, normalizedPhone, dryRun, operation);\r\n        }\r\n      }\r\n      return Promise.resolve();\r\n    });\r\n    await Promise.all(promises);\r\n    return operation;\r\n  }\r\n\r\n  /**\r\n   * Apply phone normalization update to a food truck's contact information.\r\n   * @example\r\n   * applyPhoneNormalizationUpdate(truckInstance, '+1234567890', false, operationInstance)\r\n   * // Normalizes and updates phone number of given truckInstance.\r\n   * @param {FoodTruck} truck - The food truck object whose phone number needs normalization.\r\n   * @param {string} normalizedPhone - The normalized phone number to update to the food truck's contact information.\r\n   * @param {boolean} dryRun - Flag indicating whether the operation is a dry run; updates are skipped if true.\r\n   * @param {CleanupOperation} operation - Object containing cleanup operation context including a record of errors.\r\n   * @returns {Promise<void>} Does not return a value, but potentially modifies the truck and operation objects.\r\n   * @description\r\n   *   - Executes the update operation only if `dryRun` is false.\r\n   *   - Pushes error messages to `operation.errors` on failure during the update process.\r\n   *   - Uses `FoodTruckService.updateTruck` for updating the contact information.\r\n   */\r\n  private static async applyPhoneNormalizationUpdate(\r\n    truck: FoodTruck,\r\n    normalizedPhone: string,\r\n    dryRun: boolean,\r\n    operation: CleanupOperation,\r\n  ): Promise<void> {\r\n    operation.affectedCount += 1;\r\n    if (dryRun) {\r\n      operation.successCount += 1;\r\n    } else {\r\n      try {\r\n        await FoodTruckService.updateTruck(truck.id, {\r\n          contact_info: {\r\n            ...truck.contact_info,\r\n            phone: normalizedPhone,\r\n          },\r\n        });\r\n        operation.successCount += 1;\r\n      } catch (error) {\r\n        operation.errorCount += 1;\r\n        operation.errors.push(\r\n          `Failed to normalize phone for truck ${truck.id}: ${error instanceof Error ? error.message : String(error)}`,\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Helper to determine if coordinates need fixing and provide updates\r\n   */\r\n  private static getFixedCoordinates(\r\n    lat: number | undefined,\r\n    lng: number | undefined,\r\n    defaultLat: number,\r\n    defaultLng: number,\r\n  ): Partial<FoodTruck['current_location']> | undefined {\r\n    // Fix invalid coordinates (0,0 or undefined)\r\n    if (lat === undefined || lng === undefined || lat === 0 || lng === 0) {\r\n      return { lat: defaultLat, lng: defaultLng };\r\n    }\r\n    // Fix coordinates outside reasonable bounds for Charleston area\r\n    if (lat < 32 || lat > 34 || lng > -79 || lng < -81) {\r\n      return { lat: defaultLat, lng: defaultLng };\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * Fix invalid GPS coordinates\r\n   */\r\n  private static async fixCoordinates(\r\n    trucks: FoodTruck[],\r\n    dryRun: boolean,\r\n    operation: CleanupOperation,\r\n  ): Promise<CleanupOperation> {\r\n    const context: Omit<CoordinateProcessContext, 'operation'> = {\r\n      defaultLat: 32.7767,\r\n      defaultLng: -79.9311,\r\n      dryRun,\r\n    };\r\n\r\n    const promises = trucks.map((truck) =>\r\n      this.processSingleTruckCoordinates(truck, { ...context, operation }),\r\n    );\r\n    await Promise.all(promises);\r\n    return operation;\r\n  }\r\n\r\n  /**\r\n   * Processes coordinates for a single food truck, applying any necessary fixes.\r\n   * @example\r\n   * processSingleTruckCoordinates(truck, context)\r\n   * // No return value, function completes silently\r\n   * @param {FoodTruck} truck - The food truck whose coordinates are to be processed.\r\n   * @param {CoordinateProcessContext} context - Contains configuration and operation context for processing coordinates.\r\n   * @returns {Promise<void>} Returns a promise that resolves when the processing and possible updates are complete.\r\n   * @description\r\n   *   - Skips processing if the truck's current location is not available.\r\n   *   - Retrieves updates for fixed coordinates based on truck's current and default locations.\r\n   *   - Applies updates conditionally based on context settings such as `dryRun` and `operation`.\r\n   */\r\n  private static async processSingleTruckCoordinates(\r\n    truck: FoodTruck,\r\n    context: CoordinateProcessContext,\r\n  ): Promise<void> {\r\n    if (!truck.current_location) return;\r\n    const { defaultLat, defaultLng, dryRun, operation } = context;\r\n    const { lat, lng } = truck.current_location;\r\n    const updates = this.getFixedCoordinates(lat, lng, defaultLat, defaultLng);\r\n    if (updates) {\r\n      await this.applyCoordinateFixUpdate(truck, updates, dryRun, operation);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Applies coordinate updates for a food truck's current location.\r\n   * @example\r\n   * applyCoordinateFixUpdate(truck, { lat: 34.05, lng: -118.25 }, false, operation)\r\n   * // Updates the coordinates of the truck's location asynchronously.\r\n   * @param {FoodTruck} truck - The food truck object whose coordinates need correction.\r\n   * @param {Partial<FoodTruck['current_location']>} updates - The latitude and longitude updates to be applied.\r\n   * @param {boolean} dryRun - Flag to simulate the update without altering data.\r\n   * @param {CleanupOperation} operation - The cleanup operation instance used for error tracking.\r\n   * @returns {Promise<void>} Resolves when the coordinate update process is complete.\r\n   * @description\r\n   *   - Executes the update operation only if the dryRun flag is false.\r\n   *   - If the update fails, logs the error details into the operation's error array.\r\n   */\r\n  private static async applyCoordinateFixUpdate(\r\n    truck: FoodTruck,\r\n    updates: Partial<FoodTruck['current_location']>,\r\n    dryRun: boolean,\r\n    operation: CleanupOperation,\r\n  ): Promise<void> {\r\n    operation.affectedCount += 1;\r\n    if (dryRun) {\r\n      operation.successCount += 1;\r\n    } else {\r\n      try {\r\n        await FoodTruckService.updateTruck(truck.id, {\r\n          current_location: {\r\n            ...truck.current_location,\r\n            ...updates,\r\n          },\r\n        });\r\n        operation.successCount += 1;\r\n      } catch (error) {\r\n        operation.errorCount += 1;\r\n        operation.errors.push(\r\n          `Failed to fix coordinates for truck ${truck.id}: ${error instanceof Error ? error.message : String(error)}`,\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update quality scores for all trucks\r\n   */\r\n  private static async updateQualityScores(\r\n    trucks: FoodTruck[],\r\n    dryRun: boolean,\r\n    operation: CleanupOperation,\r\n  ): Promise<CleanupOperation> {\r\n    const promises = trucks.map((truck) =>\r\n      this.processSingleTruckForQualityScore(truck, dryRun, operation),\r\n    );\r\n    await Promise.all(promises);\r\n    return operation;\r\n  }\r\n\r\n  /**\r\n  * Processes a single food truck for an updated quality score assessment.\r\n  * @example\r\n  * processSingleTruckForQualityScore(truckInstance, false, cleanupOperationInstance)\r\n  * // No return value\r\n  * @param {FoodTruck} truck - The food truck instance to assess and potentially update.\r\n  * @param {boolean} dryRun - Specifies whether this is a dry run (no actual data updates).\r\n  * @param {CleanupOperation} operation - The cleanup operation context for processing.\r\n  * @returns {Promise<void>} No return value; operation is performed asynchronously.\r\n  * @description\r\n  *   - Computes the quality score using data from DataQualityService.\r\n  *   - Updates the quality score only if the score changes significantly (>5% difference).\r\n  *   - Assumes `truck.data_quality_score` might be undefined, defaulting to 0.\r\n  *   - Handles asynchronous processing of the update application if conditions are met.\r\n  */\r\n  private static async processSingleTruckForQualityScore(\r\n    truck: FoodTruck,\r\n    dryRun: boolean,\r\n    operation: CleanupOperation,\r\n  ): Promise<void> {\r\n    const qualityAssessment = DataQualityService.calculateQualityScore(truck);\r\n    if (qualityAssessment) {\r\n      const newScore = qualityAssessment.score;\r\n      const currentScore = truck.data_quality_score ?? 0;\r\n      // Only update if score changed significantly (>5% difference)\r\n      if (typeof newScore === 'number' && Math.abs(newScore - currentScore) > 0.05) {\r\n        await this.applyQualityScoreUpdate(truck, dryRun, operation);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Updates the quality score of a specified food truck and handles errors during the update process.\r\n   * @example\r\n   * applyQualityScoreUpdate(foodTruckInstance, false, cleanupOperationInstance)\r\n   * void\r\n   * @param {FoodTruck} truck - The food truck for which the quality score will be updated.\r\n   * @param {boolean} dryRun - Flag indicating whether the function should perform the update or just simulate it.\r\n   * @param {CleanupOperation} operation - The cleanup operation containing possible error records.\r\n   * @returns {Promise<void>} Resolves with no value when the update completes. Errors are recorded in the `operation` if thrown.\r\n   * @description\r\n   *   - Throws an error if the quality score update fails.\r\n   *   - If `dryRun` is true, the function simulates the update without changing any data.\r\n   *   - Errors occurring during the update are appended to the `operation.errors` array.\r\n   */\r\n  private static async applyQualityScoreUpdate(\r\n    truck: FoodTruck,\r\n    dryRun: boolean,\r\n    operation: CleanupOperation,\r\n  ): Promise<void> {\r\n    operation.affectedCount += 1;\r\n    if (dryRun) {\r\n      operation.successCount += 1;\r\n    } else {\r\n      try {\r\n        const updateResult = await DataQualityService.updateTruckQualityScore(truck.id);\r\n        if ('error' in updateResult) {\r\n          throw new Error(updateResult.error);\r\n        }\r\n        operation.successCount += 1;\r\n      } catch (error) {\r\n        operation.errorCount += 1;\r\n        operation.errors.push(\r\n          `Failed to update quality score for truck ${truck.id}: ${error instanceof Error ? error.message : String(error)}`,\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Identify and merge duplicate trucks\r\n   */\r\n  private static async mergeDuplicates(\r\n    trucks: FoodTruck[],\r\n    dryRun: boolean,\r\n    operation: CleanupOperation,\r\n  ): Promise<CleanupOperation> {\r\n    const processedIds = new Set<string>();\r\n    for (const truck of trucks) {\r\n      await this.processSingleTruckForDuplicates(truck, dryRun, { operation, processedIds });\r\n    }\r\n    return operation;\r\n  }\r\n\r\n  /**\r\n   * Processes a single food truck to detect and handle duplicates in the dataset.\r\n   * @example\r\n   * processSingleTruckForDuplicates(foodTruck, true, mergeContext)\r\n   * // No return value. Performs operations as a side effect.\r\n   * @param {FoodTruck} truck - An instance of FoodTruck to process for duplicates.\r\n   * @param {boolean} dryRun - Flag indicating if the operation should be executed in dry run mode.\r\n   * @param {MergeOperationContext} context - Operational context that carries state and configurations for the merge operation.\r\n   * @returns {Promise<void>} Executes a set of operations for handling duplicate records, does not return any value.\r\n   * @description\r\n   *   - Ensures a food truck is only processed once by maintaining a set of processed IDs.\r\n   *   - Uses DuplicatePreventionService to assess whether the given truck is a duplicate.\r\n   *   - Applies a merge operation if a duplicate truck is confidently identified.\r\n   */\r\n  private static async processSingleTruckForDuplicates(\r\n    truck: FoodTruck,\r\n    dryRun: boolean,\r\n    context: MergeOperationContext,\r\n  ): Promise<void> {\r\n    const { processedIds } = context;\r\n    if (processedIds.has(truck.id)) return;\r\n\r\n    const duplicateCheck = await DuplicatePreventionService.checkForDuplicates(truck);\r\n    if (\r\n      duplicateCheck.isDuplicate &&\r\n      duplicateCheck.bestMatch?.confidence === 'high' &&\r\n      duplicateCheck.bestMatch.recommendation === 'merge'\r\n    ) {\r\n      await this.applyMergeOperation(\r\n        truck,\r\n        duplicateCheck.bestMatch.existingTruck,\r\n        dryRun,\r\n        context,\r\n      );\r\n    }\r\n    processedIds.add(truck.id);\r\n  }\r\n\r\n  /**\r\n   * Applies a merge operation between two food trucks and updates the context.\r\n   * @example\r\n   * applyMergeOperation(truck, existingTruck, true, context)\r\n   * // Executes a dry run of the merge operation without affecting data\r\n   * @param {FoodTruck} truck - The food truck that is being merged.\r\n   * @param {FoodTruck} existingTruck - The existing food truck to merge with.\r\n   * @param {boolean} dryRun - Indicates if the merge operation should be simulated.\r\n   * @param {MergeOperationContext} context - Context containing details and state of the merge operation.\r\n   * @returns {Promise<void>} Promise representing the completion of the merge operation.\r\n   * @description\r\n   *   - Updates the list of processed IDs in the context upon successful merge.\r\n   *   - Throws and records an error if the merge operation fails.\r\n   *   - Utilizes the DuplicatePreventionService for performing the merge.\r\n   */\r\n  private static async applyMergeOperation(\r\n    truck: FoodTruck,\r\n    existingTruck: FoodTruck,\r\n    dryRun: boolean,\r\n    context: MergeOperationContext,\r\n  ): Promise<void> {\r\n    const { operation, processedIds } = context;\r\n    operation.affectedCount += 1;\r\n    if (dryRun) {\r\n      operation.successCount += 1;\r\n    } else {\r\n      try {\r\n        const mergeResult = await DuplicatePreventionService.mergeDuplicates(\r\n          truck.id,\r\n          existingTruck.id,\r\n        );\r\n        if ('error' in mergeResult) {\r\n          throw new Error(mergeResult.error);\r\n        }\r\n        processedIds.add(existingTruck.id);\r\n        operation.successCount += 1;\r\n      } catch (error) {\r\n        operation.errorCount += 1;\r\n        operation.errors.push(\r\n          `Failed to merge duplicates ${truck.id} and ${existingTruck.id}: ${error instanceof Error ? error.message : String(error)}`,\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Normalize phone number format\r\n   */\r\n  private static normalizePhone(phone: string): string | undefined {\r\n    if (!phone) return undefined;\r\n\r\n    // Remove all non-digit characters\r\n    const digits = phone.replaceAll(/\\D/g, '');\r\n\r\n    // Handle US phone numbers\r\n    if (digits.length === 10) {\r\n      return `(${digits.slice(0, 3)}) ${digits.slice(3, 6)}-${digits.slice(6)}`;\r\n    }\r\n    if (digits.length === 11 && digits.startsWith('1')) {\r\n      return `+1 (${digits.slice(1, 4)}) ${digits.slice(4, 7)}-${digits.slice(7)}`;\r\n    }\r\n\r\n    // Return original if can't normalize\r\n    return phone;\r\n  }\r\n\r\n  /**\r\n   * Get operation description\r\n   */\r\n  private static getOperationDescription(type: CleanupOperation['type']): string {\r\n    const descriptions = {\r\n      remove_placeholders: 'Remove placeholder and mock data values',\r\n      normalize_phone: 'Normalize phone numbers to consistent format',\r\n      fix_coordinates: 'Fix invalid GPS coordinates',\r\n      update_quality_scores: 'Recalculate data quality scores',\r\n      merge_duplicates: 'Identify and merge duplicate truck entries',\r\n    };\r\n\r\n    return descriptions[type] ?? 'Unknown operation';\r\n  }\r\n\r\n  /**\r\n   * Calculate cleanup summary\r\n   */\r\n  private static calculateSummary(operations: CleanupOperation[]): BatchCleanupResult['summary'] {\r\n    return {\r\n      trucksImproved: operations.reduce((sum, op) => sum + op.successCount, 0),\r\n      duplicatesRemoved: operations.find((op) => op.type === 'merge_duplicates')?.successCount ?? 0,\r\n      qualityScoreImprovement:\r\n        operations.find((op) => op.type === 'update_quality_scores')?.successCount ?? 0,\r\n      placeholdersRemoved:\r\n        operations.find((op) => op.type === 'remove_placeholders')?.successCount ?? 0,\r\n    };\r\n  }\r\n}\r\n\nexport {type CleanupOperation} from '@/lib/types';"}},{"ruleId":"unicorn/prefer-export-from","severity":2,"message":"Use `export…from` to re-export `CleanupOperationType`.","line":12,"column":33,"nodeType":"ExportSpecifier","messageId":"error","endLine":12,"endColumn":53,"fix":{"range":[236,26192],"text":" BatchCleanupResult } from '@/lib/types';\r\nimport { DuplicatePreventionService } from './duplicatePrevention';\r\nimport { getPlaceholderPatterns, processTruckForPlaceholders } from './placeholderUtils';\r\n\r\n// Re-export the types for backward compatibility\r\nexport type { CleanupOperation,  BatchCleanupResult };\r\n\r\ninterface MergeOperationContext {\r\n  operation: CleanupOperation;\r\n  processedIds: Set<string>;\r\n}\r\n\r\ninterface CoordinateProcessContext {\r\n  defaultLat: number;\r\n  defaultLng: number;\r\n  dryRun: boolean;\r\n  operation: CleanupOperation;\r\n}\r\n\r\n/**\r\n * Automated Data Quality Cleanup Service\r\n */\r\nexport class BatchCleanupService {\r\n  /**\r\n   * Run comprehensive data cleanup operations\r\n   */\r\n  static async runFullCleanup(\r\n    options: {\r\n      batchSize?: number;\r\n      dryRun?: boolean;\r\n      operations?: CleanupOperation['type'][];\r\n    } = {},\r\n  ): Promise<BatchCleanupResult> {\r\n    const startTime = Date.now();\r\n    const {\r\n      batchSize = 50,\r\n      dryRun = false,\r\n      operations = [\r\n        'remove_placeholders',\r\n        'normalize_phone',\r\n        'fix_coordinates',\r\n        'update_quality_scores',\r\n        'merge_duplicates',\r\n      ],\r\n    } = options;\r\n\r\n    console.info(`Starting batch cleanup (${dryRun ? 'DRY RUN' : 'LIVE'})...`);\r\n    const result = this.initializeCleanupResult();\r\n    try {\r\n      const allTrucks = await FoodTruckService.getAllTrucks();\r\n      result.totalProcessed = allTrucks.total;\r\n      await this.processTrucksInBatches(allTrucks.trucks, {\r\n        batchSize,\r\n        operations,\r\n        dryRun,\r\n        result,\r\n      });\r\n      return this.finalizeCleanupResult(result, startTime);\r\n    } catch (error) {\r\n      console.error('Batch cleanup failed:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n  * Initializes and returns a new BatchCleanupResult object with default values.\r\n  * @example\r\n  * initializeCleanupResult()\r\n  * { totalProcessed: 0, operations: [], summary: { trucksImproved: 0, duplicatesRemoved: 0, qualityScoreImprovement: 0, placeholdersRemoved: 0 }, duration: 0 }\r\n  * @returns {BatchCleanupResult} A new BatchCleanupResult object with all properties set to initial default values.\r\n  */\r\n  private static initializeCleanupResult(): BatchCleanupResult {\r\n    return {\r\n      totalProcessed: 0,\r\n      operations: [],\r\n      summary: {\r\n        trucksImproved: 0,\r\n        duplicatesRemoved: 0,\r\n        qualityScoreImprovement: 0,\r\n        placeholdersRemoved: 0,\r\n      },\r\n      duration: 0,\r\n    };\r\n  }\r\n\r\n  private static finalizeCleanupResult(\r\n    result: BatchCleanupResult,\r\n    startTime: number,\r\n  ): BatchCleanupResult {\r\n    result.summary = this.calculateSummary(result.operations);\r\n    result.duration = Date.now() - startTime;\r\n\r\n    console.info(`Batch cleanup completed in ${result.duration}ms`);\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Processes food trucks in batches, executing specified operations on each batch.\r\n   * @example\r\n   * processTrucksInBatches(truckList, { batchSize: 10, operations: ['clean'], dryRun: true, result: batchResult })\r\n   * // It executes 'clean' operation on batches of 10 trucks without making permanent changes.\r\n   * @param {FoodTruck[]} trucks - Array of food trucks to be processed in batches.\r\n   * @param {object} options - Options object containing batchSize, operations, dryRun, and result.\r\n   * @param {number} options.batchSize - Number of trucks in each batch.\r\n   * @param {CleanupOperation['type'][]} options.operations - Array of operation types to be executed on each batch.\r\n   * @param {boolean} options.dryRun - If true, operations are executed in simulation mode without permanent changes.\r\n   * @param {BatchCleanupResult} options.result - Stores the results of operations performed on batches.\r\n   * @returns {Promise<void>} Completes processing batches without a return value.\r\n   * @description\r\n   *   - Uses async function to allow non-blocking execution of operations.\r\n   *   - Collects and stores results of batch operations separately, keeping track of each operation's outcome.\r\n   *   - Iterates over arrays using slicing to dynamically create batches for processing.\r\n   */\r\n  private static async processTrucksInBatches(\r\n    trucks: FoodTruck[],\r\n    {\r\n      batchSize,\r\n      operations,\r\n      dryRun,\r\n      result,\r\n    }: {\r\n      batchSize: number;\r\n      operations: CleanupOperation['type'][];\r\n      dryRun: boolean;\r\n      result: BatchCleanupResult;\r\n    },\r\n  ): Promise<void> {\r\n    for (let i = 0; i < trucks.length; i += batchSize) {\r\n      const batch = trucks.slice(i, i + batchSize);\r\n      for (const op of operations) {\r\n        const opResult = await this.runOperation(op, batch, dryRun);\r\n        result.operations.push(opResult);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Run a specific cleanup operation\r\n   */\r\n  private static async runOperation(\r\n    type: CleanupOperation['type'],\r\n    trucks: FoodTruck[],\r\n    dryRun: boolean,\r\n  ): Promise<CleanupOperation> {\r\n    const operation: CleanupOperation = {\r\n      type,\r\n      description: this.getOperationDescription(type),\r\n      affectedCount: 0,\r\n      successCount: 0,\r\n      errorCount: 0,\r\n      errors: [],\r\n    };\r\n\r\n    const operationRunners = {\r\n      remove_placeholders: this.runRemovePlaceholders,\r\n      normalize_phone: this.runNormalizePhoneNumbers,\r\n      fix_coordinates: this.runFixCoordinates,\r\n      update_quality_scores: this.runUpdateQualityScores,\r\n      merge_duplicates: this.runMergeDuplicates,\r\n    };\r\n\r\n    try {\r\n      const runner = operationRunners[type];\r\n      if (runner) {\r\n        return await runner.call(this, trucks, dryRun, operation);\r\n      } \r\n        operation.errors.push(`Unknown operation type: ${String(type)}`);\r\n        return operation;\r\n      \r\n    } catch (error) {\r\n      operation.errors.push(\r\n        `Operation failed: ${error instanceof Error ? error.message : String(error)}`,\r\n      );\r\n      return operation;\r\n    }\r\n  }\r\n\r\n  private static runRemovePlaceholders = async (\r\n    trucks: FoodTruck[],\r\n    dryRun: boolean,\r\n    operation: CleanupOperation,\r\n  ): Promise<CleanupOperation> => {\r\n    return await this.removePlaceholders(trucks, dryRun, operation);\r\n  };\r\n\r\n  private static runNormalizePhoneNumbers = async (\r\n    trucks: FoodTruck[],\r\n    dryRun: boolean,\r\n    operation: CleanupOperation,\r\n  ): Promise<CleanupOperation> => {\r\n    return await this.normalizePhoneNumbers(trucks, dryRun, operation);\r\n  };\r\n\r\n  private static runFixCoordinates = async (\r\n    trucks: FoodTruck[],\r\n    dryRun: boolean,\r\n    operation: CleanupOperation,\r\n  ): Promise<CleanupOperation> => {\r\n    return await this.fixCoordinates(trucks, dryRun, operation);\r\n  };\r\n\r\n  private static runUpdateQualityScores = async (\r\n    trucks: FoodTruck[],\r\n    dryRun: boolean,\r\n    operation: CleanupOperation,\r\n  ): Promise<CleanupOperation> => {\r\n    return await this.updateQualityScores(trucks, dryRun, operation);\r\n  };\r\n\r\n  private static runMergeDuplicates = async (\r\n    trucks: FoodTruck[],\r\n    dryRun: boolean,\r\n    operation: CleanupOperation,\r\n  ): Promise<CleanupOperation> => {\r\n    return await this.mergeDuplicates(trucks, dryRun, operation);\r\n  };\r\n\r\n  /**\r\n   * Remove placeholder and mock data\r\n   */\r\n  private static async removePlaceholders(\r\n    trucks: FoodTruck[],\r\n    dryRun: boolean,\r\n    operation: CleanupOperation,\r\n  ): Promise<CleanupOperation> {\r\n    const placeholderPatterns = getPlaceholderPatterns();\r\n    const promises = trucks.map((truck) =>\r\n      this.processSingleTruckForPlaceholders(truck, placeholderPatterns, dryRun, operation),\r\n    );\r\n    await Promise.all(promises);\r\n    return operation;\r\n  }\r\n\r\n  private static async processSingleTruckForPlaceholders(\r\n    truck: FoodTruck,\r\n    patterns: RegExp[],\r\n    dryRun: boolean,\r\n    operation: CleanupOperation,\r\n  ): Promise<void> {\r\n    const updates = processTruckForPlaceholders(truck, patterns);\r\n    if (updates && Object.keys(updates).length > 0) {\r\n      await this.performUpdateOperation(truck.id, updates, dryRun, operation);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Perform an update operation on a specified food truck.\r\n   * @example\r\n   * performUpdateOperation('truck123', { name: 'New Name' }, true, cleanupOperation)\r\n   * // No direct return value; operation may log errors.\r\n   * @param {string} truckId - The unique identifier of the food truck to be updated.\r\n   * @param {Partial<FoodTruck>} updates - An object containing the fields to be updated.\r\n   * @param {boolean} dryRun - Flag indicating whether the operation should be a simulation without actual changes.\r\n   * @param {CleanupOperation} operation - An operation object that logs errors encountered during update.\r\n   * @returns {Promise<void>} A promise that resolves when the update operation is complete.\r\n   * @description\r\n   *   - If 'dryRun' is true, no updates are applied but actions are logged.\r\n   *   - Errors during update are caught and logged in the 'operation.errors' array.\r\n   */\r\n  private static async performUpdateOperation(\r\n    truckId: string,\r\n    updates: Partial<FoodTruck>,\r\n    dryRun: boolean,\r\n    operation: CleanupOperation,\r\n  ): Promise<void> {\r\n    operation.affectedCount += 1;\r\n    if (dryRun) {\r\n      operation.successCount += 1;\r\n    } else {\r\n      try {\r\n        await FoodTruckService.updateTruck(truckId, updates);\r\n        operation.successCount += 1;\r\n      } catch (error) {\r\n        operation.errorCount += 1;\r\n        operation.errors.push(\r\n          `Failed to update truck ${truckId}: ${error instanceof Error ? error.message : String(error)}`,\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Normalize phone numbers to consistent format\r\n   */\r\n  private static async normalizePhoneNumbers(\r\n    trucks: FoodTruck[],\r\n    dryRun: boolean,\r\n    operation: CleanupOperation,\r\n  ): Promise<CleanupOperation> {\r\n    const promises = trucks.map((truck) => {\r\n      if (truck.contact_info?.phone !== undefined) {\r\n        const originalPhone = truck.contact_info.phone;\r\n        const normalizedPhone = this.normalizePhone(originalPhone);\r\n\r\n        if (normalizedPhone !== undefined && normalizedPhone !== originalPhone) {\r\n          return this.applyPhoneNormalizationUpdate(truck, normalizedPhone, dryRun, operation);\r\n        }\r\n      }\r\n      return Promise.resolve();\r\n    });\r\n    await Promise.all(promises);\r\n    return operation;\r\n  }\r\n\r\n  /**\r\n   * Apply phone normalization update to a food truck's contact information.\r\n   * @example\r\n   * applyPhoneNormalizationUpdate(truckInstance, '+1234567890', false, operationInstance)\r\n   * // Normalizes and updates phone number of given truckInstance.\r\n   * @param {FoodTruck} truck - The food truck object whose phone number needs normalization.\r\n   * @param {string} normalizedPhone - The normalized phone number to update to the food truck's contact information.\r\n   * @param {boolean} dryRun - Flag indicating whether the operation is a dry run; updates are skipped if true.\r\n   * @param {CleanupOperation} operation - Object containing cleanup operation context including a record of errors.\r\n   * @returns {Promise<void>} Does not return a value, but potentially modifies the truck and operation objects.\r\n   * @description\r\n   *   - Executes the update operation only if `dryRun` is false.\r\n   *   - Pushes error messages to `operation.errors` on failure during the update process.\r\n   *   - Uses `FoodTruckService.updateTruck` for updating the contact information.\r\n   */\r\n  private static async applyPhoneNormalizationUpdate(\r\n    truck: FoodTruck,\r\n    normalizedPhone: string,\r\n    dryRun: boolean,\r\n    operation: CleanupOperation,\r\n  ): Promise<void> {\r\n    operation.affectedCount += 1;\r\n    if (dryRun) {\r\n      operation.successCount += 1;\r\n    } else {\r\n      try {\r\n        await FoodTruckService.updateTruck(truck.id, {\r\n          contact_info: {\r\n            ...truck.contact_info,\r\n            phone: normalizedPhone,\r\n          },\r\n        });\r\n        operation.successCount += 1;\r\n      } catch (error) {\r\n        operation.errorCount += 1;\r\n        operation.errors.push(\r\n          `Failed to normalize phone for truck ${truck.id}: ${error instanceof Error ? error.message : String(error)}`,\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Helper to determine if coordinates need fixing and provide updates\r\n   */\r\n  private static getFixedCoordinates(\r\n    lat: number | undefined,\r\n    lng: number | undefined,\r\n    defaultLat: number,\r\n    defaultLng: number,\r\n  ): Partial<FoodTruck['current_location']> | undefined {\r\n    // Fix invalid coordinates (0,0 or undefined)\r\n    if (lat === undefined || lng === undefined || lat === 0 || lng === 0) {\r\n      return { lat: defaultLat, lng: defaultLng };\r\n    }\r\n    // Fix coordinates outside reasonable bounds for Charleston area\r\n    if (lat < 32 || lat > 34 || lng > -79 || lng < -81) {\r\n      return { lat: defaultLat, lng: defaultLng };\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * Fix invalid GPS coordinates\r\n   */\r\n  private static async fixCoordinates(\r\n    trucks: FoodTruck[],\r\n    dryRun: boolean,\r\n    operation: CleanupOperation,\r\n  ): Promise<CleanupOperation> {\r\n    const context: Omit<CoordinateProcessContext, 'operation'> = {\r\n      defaultLat: 32.7767,\r\n      defaultLng: -79.9311,\r\n      dryRun,\r\n    };\r\n\r\n    const promises = trucks.map((truck) =>\r\n      this.processSingleTruckCoordinates(truck, { ...context, operation }),\r\n    );\r\n    await Promise.all(promises);\r\n    return operation;\r\n  }\r\n\r\n  /**\r\n   * Processes coordinates for a single food truck, applying any necessary fixes.\r\n   * @example\r\n   * processSingleTruckCoordinates(truck, context)\r\n   * // No return value, function completes silently\r\n   * @param {FoodTruck} truck - The food truck whose coordinates are to be processed.\r\n   * @param {CoordinateProcessContext} context - Contains configuration and operation context for processing coordinates.\r\n   * @returns {Promise<void>} Returns a promise that resolves when the processing and possible updates are complete.\r\n   * @description\r\n   *   - Skips processing if the truck's current location is not available.\r\n   *   - Retrieves updates for fixed coordinates based on truck's current and default locations.\r\n   *   - Applies updates conditionally based on context settings such as `dryRun` and `operation`.\r\n   */\r\n  private static async processSingleTruckCoordinates(\r\n    truck: FoodTruck,\r\n    context: CoordinateProcessContext,\r\n  ): Promise<void> {\r\n    if (!truck.current_location) return;\r\n    const { defaultLat, defaultLng, dryRun, operation } = context;\r\n    const { lat, lng } = truck.current_location;\r\n    const updates = this.getFixedCoordinates(lat, lng, defaultLat, defaultLng);\r\n    if (updates) {\r\n      await this.applyCoordinateFixUpdate(truck, updates, dryRun, operation);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Applies coordinate updates for a food truck's current location.\r\n   * @example\r\n   * applyCoordinateFixUpdate(truck, { lat: 34.05, lng: -118.25 }, false, operation)\r\n   * // Updates the coordinates of the truck's location asynchronously.\r\n   * @param {FoodTruck} truck - The food truck object whose coordinates need correction.\r\n   * @param {Partial<FoodTruck['current_location']>} updates - The latitude and longitude updates to be applied.\r\n   * @param {boolean} dryRun - Flag to simulate the update without altering data.\r\n   * @param {CleanupOperation} operation - The cleanup operation instance used for error tracking.\r\n   * @returns {Promise<void>} Resolves when the coordinate update process is complete.\r\n   * @description\r\n   *   - Executes the update operation only if the dryRun flag is false.\r\n   *   - If the update fails, logs the error details into the operation's error array.\r\n   */\r\n  private static async applyCoordinateFixUpdate(\r\n    truck: FoodTruck,\r\n    updates: Partial<FoodTruck['current_location']>,\r\n    dryRun: boolean,\r\n    operation: CleanupOperation,\r\n  ): Promise<void> {\r\n    operation.affectedCount += 1;\r\n    if (dryRun) {\r\n      operation.successCount += 1;\r\n    } else {\r\n      try {\r\n        await FoodTruckService.updateTruck(truck.id, {\r\n          current_location: {\r\n            ...truck.current_location,\r\n            ...updates,\r\n          },\r\n        });\r\n        operation.successCount += 1;\r\n      } catch (error) {\r\n        operation.errorCount += 1;\r\n        operation.errors.push(\r\n          `Failed to fix coordinates for truck ${truck.id}: ${error instanceof Error ? error.message : String(error)}`,\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update quality scores for all trucks\r\n   */\r\n  private static async updateQualityScores(\r\n    trucks: FoodTruck[],\r\n    dryRun: boolean,\r\n    operation: CleanupOperation,\r\n  ): Promise<CleanupOperation> {\r\n    const promises = trucks.map((truck) =>\r\n      this.processSingleTruckForQualityScore(truck, dryRun, operation),\r\n    );\r\n    await Promise.all(promises);\r\n    return operation;\r\n  }\r\n\r\n  /**\r\n  * Processes a single food truck for an updated quality score assessment.\r\n  * @example\r\n  * processSingleTruckForQualityScore(truckInstance, false, cleanupOperationInstance)\r\n  * // No return value\r\n  * @param {FoodTruck} truck - The food truck instance to assess and potentially update.\r\n  * @param {boolean} dryRun - Specifies whether this is a dry run (no actual data updates).\r\n  * @param {CleanupOperation} operation - The cleanup operation context for processing.\r\n  * @returns {Promise<void>} No return value; operation is performed asynchronously.\r\n  * @description\r\n  *   - Computes the quality score using data from DataQualityService.\r\n  *   - Updates the quality score only if the score changes significantly (>5% difference).\r\n  *   - Assumes `truck.data_quality_score` might be undefined, defaulting to 0.\r\n  *   - Handles asynchronous processing of the update application if conditions are met.\r\n  */\r\n  private static async processSingleTruckForQualityScore(\r\n    truck: FoodTruck,\r\n    dryRun: boolean,\r\n    operation: CleanupOperation,\r\n  ): Promise<void> {\r\n    const qualityAssessment = DataQualityService.calculateQualityScore(truck);\r\n    if (qualityAssessment) {\r\n      const newScore = qualityAssessment.score;\r\n      const currentScore = truck.data_quality_score ?? 0;\r\n      // Only update if score changed significantly (>5% difference)\r\n      if (typeof newScore === 'number' && Math.abs(newScore - currentScore) > 0.05) {\r\n        await this.applyQualityScoreUpdate(truck, dryRun, operation);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Updates the quality score of a specified food truck and handles errors during the update process.\r\n   * @example\r\n   * applyQualityScoreUpdate(foodTruckInstance, false, cleanupOperationInstance)\r\n   * void\r\n   * @param {FoodTruck} truck - The food truck for which the quality score will be updated.\r\n   * @param {boolean} dryRun - Flag indicating whether the function should perform the update or just simulate it.\r\n   * @param {CleanupOperation} operation - The cleanup operation containing possible error records.\r\n   * @returns {Promise<void>} Resolves with no value when the update completes. Errors are recorded in the `operation` if thrown.\r\n   * @description\r\n   *   - Throws an error if the quality score update fails.\r\n   *   - If `dryRun` is true, the function simulates the update without changing any data.\r\n   *   - Errors occurring during the update are appended to the `operation.errors` array.\r\n   */\r\n  private static async applyQualityScoreUpdate(\r\n    truck: FoodTruck,\r\n    dryRun: boolean,\r\n    operation: CleanupOperation,\r\n  ): Promise<void> {\r\n    operation.affectedCount += 1;\r\n    if (dryRun) {\r\n      operation.successCount += 1;\r\n    } else {\r\n      try {\r\n        const updateResult = await DataQualityService.updateTruckQualityScore(truck.id);\r\n        if ('error' in updateResult) {\r\n          throw new Error(updateResult.error);\r\n        }\r\n        operation.successCount += 1;\r\n      } catch (error) {\r\n        operation.errorCount += 1;\r\n        operation.errors.push(\r\n          `Failed to update quality score for truck ${truck.id}: ${error instanceof Error ? error.message : String(error)}`,\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Identify and merge duplicate trucks\r\n   */\r\n  private static async mergeDuplicates(\r\n    trucks: FoodTruck[],\r\n    dryRun: boolean,\r\n    operation: CleanupOperation,\r\n  ): Promise<CleanupOperation> {\r\n    const processedIds = new Set<string>();\r\n    for (const truck of trucks) {\r\n      await this.processSingleTruckForDuplicates(truck, dryRun, { operation, processedIds });\r\n    }\r\n    return operation;\r\n  }\r\n\r\n  /**\r\n   * Processes a single food truck to detect and handle duplicates in the dataset.\r\n   * @example\r\n   * processSingleTruckForDuplicates(foodTruck, true, mergeContext)\r\n   * // No return value. Performs operations as a side effect.\r\n   * @param {FoodTruck} truck - An instance of FoodTruck to process for duplicates.\r\n   * @param {boolean} dryRun - Flag indicating if the operation should be executed in dry run mode.\r\n   * @param {MergeOperationContext} context - Operational context that carries state and configurations for the merge operation.\r\n   * @returns {Promise<void>} Executes a set of operations for handling duplicate records, does not return any value.\r\n   * @description\r\n   *   - Ensures a food truck is only processed once by maintaining a set of processed IDs.\r\n   *   - Uses DuplicatePreventionService to assess whether the given truck is a duplicate.\r\n   *   - Applies a merge operation if a duplicate truck is confidently identified.\r\n   */\r\n  private static async processSingleTruckForDuplicates(\r\n    truck: FoodTruck,\r\n    dryRun: boolean,\r\n    context: MergeOperationContext,\r\n  ): Promise<void> {\r\n    const { processedIds } = context;\r\n    if (processedIds.has(truck.id)) return;\r\n\r\n    const duplicateCheck = await DuplicatePreventionService.checkForDuplicates(truck);\r\n    if (\r\n      duplicateCheck.isDuplicate &&\r\n      duplicateCheck.bestMatch?.confidence === 'high' &&\r\n      duplicateCheck.bestMatch.recommendation === 'merge'\r\n    ) {\r\n      await this.applyMergeOperation(\r\n        truck,\r\n        duplicateCheck.bestMatch.existingTruck,\r\n        dryRun,\r\n        context,\r\n      );\r\n    }\r\n    processedIds.add(truck.id);\r\n  }\r\n\r\n  /**\r\n   * Applies a merge operation between two food trucks and updates the context.\r\n   * @example\r\n   * applyMergeOperation(truck, existingTruck, true, context)\r\n   * // Executes a dry run of the merge operation without affecting data\r\n   * @param {FoodTruck} truck - The food truck that is being merged.\r\n   * @param {FoodTruck} existingTruck - The existing food truck to merge with.\r\n   * @param {boolean} dryRun - Indicates if the merge operation should be simulated.\r\n   * @param {MergeOperationContext} context - Context containing details and state of the merge operation.\r\n   * @returns {Promise<void>} Promise representing the completion of the merge operation.\r\n   * @description\r\n   *   - Updates the list of processed IDs in the context upon successful merge.\r\n   *   - Throws and records an error if the merge operation fails.\r\n   *   - Utilizes the DuplicatePreventionService for performing the merge.\r\n   */\r\n  private static async applyMergeOperation(\r\n    truck: FoodTruck,\r\n    existingTruck: FoodTruck,\r\n    dryRun: boolean,\r\n    context: MergeOperationContext,\r\n  ): Promise<void> {\r\n    const { operation, processedIds } = context;\r\n    operation.affectedCount += 1;\r\n    if (dryRun) {\r\n      operation.successCount += 1;\r\n    } else {\r\n      try {\r\n        const mergeResult = await DuplicatePreventionService.mergeDuplicates(\r\n          truck.id,\r\n          existingTruck.id,\r\n        );\r\n        if ('error' in mergeResult) {\r\n          throw new Error(mergeResult.error);\r\n        }\r\n        processedIds.add(existingTruck.id);\r\n        operation.successCount += 1;\r\n      } catch (error) {\r\n        operation.errorCount += 1;\r\n        operation.errors.push(\r\n          `Failed to merge duplicates ${truck.id} and ${existingTruck.id}: ${error instanceof Error ? error.message : String(error)}`,\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Normalize phone number format\r\n   */\r\n  private static normalizePhone(phone: string): string | undefined {\r\n    if (!phone) return undefined;\r\n\r\n    // Remove all non-digit characters\r\n    const digits = phone.replaceAll(/\\D/g, '');\r\n\r\n    // Handle US phone numbers\r\n    if (digits.length === 10) {\r\n      return `(${digits.slice(0, 3)}) ${digits.slice(3, 6)}-${digits.slice(6)}`;\r\n    }\r\n    if (digits.length === 11 && digits.startsWith('1')) {\r\n      return `+1 (${digits.slice(1, 4)}) ${digits.slice(4, 7)}-${digits.slice(7)}`;\r\n    }\r\n\r\n    // Return original if can't normalize\r\n    return phone;\r\n  }\r\n\r\n  /**\r\n   * Get operation description\r\n   */\r\n  private static getOperationDescription(type: CleanupOperation['type']): string {\r\n    const descriptions = {\r\n      remove_placeholders: 'Remove placeholder and mock data values',\r\n      normalize_phone: 'Normalize phone numbers to consistent format',\r\n      fix_coordinates: 'Fix invalid GPS coordinates',\r\n      update_quality_scores: 'Recalculate data quality scores',\r\n      merge_duplicates: 'Identify and merge duplicate truck entries',\r\n    };\r\n\r\n    return descriptions[type] ?? 'Unknown operation';\r\n  }\r\n\r\n  /**\r\n   * Calculate cleanup summary\r\n   */\r\n  private static calculateSummary(operations: CleanupOperation[]): BatchCleanupResult['summary'] {\r\n    return {\r\n      trucksImproved: operations.reduce((sum, op) => sum + op.successCount, 0),\r\n      duplicatesRemoved: operations.find((op) => op.type === 'merge_duplicates')?.successCount ?? 0,\r\n      qualityScoreImprovement:\r\n        operations.find((op) => op.type === 'update_quality_scores')?.successCount ?? 0,\r\n      placeholdersRemoved:\r\n        operations.find((op) => op.type === 'remove_placeholders')?.successCount ?? 0,\r\n    };\r\n  }\r\n}\r\n\nexport {type CleanupOperationType} from '@/lib/types';"}},{"ruleId":"unicorn/prefer-export-from","severity":2,"message":"Use `export…from` to re-export `BatchCleanupResult`.","line":12,"column":55,"nodeType":"ExportSpecifier","messageId":"error","endLine":12,"endColumn":73,"fix":{"range":[567,26192],"text":" };\r\n\r\ninterface MergeOperationContext {\r\n  operation: CleanupOperation;\r\n  processedIds: Set<string>;\r\n}\r\n\r\ninterface CoordinateProcessContext {\r\n  defaultLat: number;\r\n  defaultLng: number;\r\n  dryRun: boolean;\r\n  operation: CleanupOperation;\r\n}\r\n\r\n/**\r\n * Automated Data Quality Cleanup Service\r\n */\r\nexport class BatchCleanupService {\r\n  /**\r\n   * Run comprehensive data cleanup operations\r\n   */\r\n  static async runFullCleanup(\r\n    options: {\r\n      batchSize?: number;\r\n      dryRun?: boolean;\r\n      operations?: CleanupOperation['type'][];\r\n    } = {},\r\n  ): Promise<BatchCleanupResult> {\r\n    const startTime = Date.now();\r\n    const {\r\n      batchSize = 50,\r\n      dryRun = false,\r\n      operations = [\r\n        'remove_placeholders',\r\n        'normalize_phone',\r\n        'fix_coordinates',\r\n        'update_quality_scores',\r\n        'merge_duplicates',\r\n      ],\r\n    } = options;\r\n\r\n    console.info(`Starting batch cleanup (${dryRun ? 'DRY RUN' : 'LIVE'})...`);\r\n    const result = this.initializeCleanupResult();\r\n    try {\r\n      const allTrucks = await FoodTruckService.getAllTrucks();\r\n      result.totalProcessed = allTrucks.total;\r\n      await this.processTrucksInBatches(allTrucks.trucks, {\r\n        batchSize,\r\n        operations,\r\n        dryRun,\r\n        result,\r\n      });\r\n      return this.finalizeCleanupResult(result, startTime);\r\n    } catch (error) {\r\n      console.error('Batch cleanup failed:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n  * Initializes and returns a new BatchCleanupResult object with default values.\r\n  * @example\r\n  * initializeCleanupResult()\r\n  * { totalProcessed: 0, operations: [], summary: { trucksImproved: 0, duplicatesRemoved: 0, qualityScoreImprovement: 0, placeholdersRemoved: 0 }, duration: 0 }\r\n  * @returns {BatchCleanupResult} A new BatchCleanupResult object with all properties set to initial default values.\r\n  */\r\n  private static initializeCleanupResult(): BatchCleanupResult {\r\n    return {\r\n      totalProcessed: 0,\r\n      operations: [],\r\n      summary: {\r\n        trucksImproved: 0,\r\n        duplicatesRemoved: 0,\r\n        qualityScoreImprovement: 0,\r\n        placeholdersRemoved: 0,\r\n      },\r\n      duration: 0,\r\n    };\r\n  }\r\n\r\n  private static finalizeCleanupResult(\r\n    result: BatchCleanupResult,\r\n    startTime: number,\r\n  ): BatchCleanupResult {\r\n    result.summary = this.calculateSummary(result.operations);\r\n    result.duration = Date.now() - startTime;\r\n\r\n    console.info(`Batch cleanup completed in ${result.duration}ms`);\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Processes food trucks in batches, executing specified operations on each batch.\r\n   * @example\r\n   * processTrucksInBatches(truckList, { batchSize: 10, operations: ['clean'], dryRun: true, result: batchResult })\r\n   * // It executes 'clean' operation on batches of 10 trucks without making permanent changes.\r\n   * @param {FoodTruck[]} trucks - Array of food trucks to be processed in batches.\r\n   * @param {object} options - Options object containing batchSize, operations, dryRun, and result.\r\n   * @param {number} options.batchSize - Number of trucks in each batch.\r\n   * @param {CleanupOperation['type'][]} options.operations - Array of operation types to be executed on each batch.\r\n   * @param {boolean} options.dryRun - If true, operations are executed in simulation mode without permanent changes.\r\n   * @param {BatchCleanupResult} options.result - Stores the results of operations performed on batches.\r\n   * @returns {Promise<void>} Completes processing batches without a return value.\r\n   * @description\r\n   *   - Uses async function to allow non-blocking execution of operations.\r\n   *   - Collects and stores results of batch operations separately, keeping track of each operation's outcome.\r\n   *   - Iterates over arrays using slicing to dynamically create batches for processing.\r\n   */\r\n  private static async processTrucksInBatches(\r\n    trucks: FoodTruck[],\r\n    {\r\n      batchSize,\r\n      operations,\r\n      dryRun,\r\n      result,\r\n    }: {\r\n      batchSize: number;\r\n      operations: CleanupOperation['type'][];\r\n      dryRun: boolean;\r\n      result: BatchCleanupResult;\r\n    },\r\n  ): Promise<void> {\r\n    for (let i = 0; i < trucks.length; i += batchSize) {\r\n      const batch = trucks.slice(i, i + batchSize);\r\n      for (const op of operations) {\r\n        const opResult = await this.runOperation(op, batch, dryRun);\r\n        result.operations.push(opResult);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Run a specific cleanup operation\r\n   */\r\n  private static async runOperation(\r\n    type: CleanupOperation['type'],\r\n    trucks: FoodTruck[],\r\n    dryRun: boolean,\r\n  ): Promise<CleanupOperation> {\r\n    const operation: CleanupOperation = {\r\n      type,\r\n      description: this.getOperationDescription(type),\r\n      affectedCount: 0,\r\n      successCount: 0,\r\n      errorCount: 0,\r\n      errors: [],\r\n    };\r\n\r\n    const operationRunners = {\r\n      remove_placeholders: this.runRemovePlaceholders,\r\n      normalize_phone: this.runNormalizePhoneNumbers,\r\n      fix_coordinates: this.runFixCoordinates,\r\n      update_quality_scores: this.runUpdateQualityScores,\r\n      merge_duplicates: this.runMergeDuplicates,\r\n    };\r\n\r\n    try {\r\n      const runner = operationRunners[type];\r\n      if (runner) {\r\n        return await runner.call(this, trucks, dryRun, operation);\r\n      } \r\n        operation.errors.push(`Unknown operation type: ${String(type)}`);\r\n        return operation;\r\n      \r\n    } catch (error) {\r\n      operation.errors.push(\r\n        `Operation failed: ${error instanceof Error ? error.message : String(error)}`,\r\n      );\r\n      return operation;\r\n    }\r\n  }\r\n\r\n  private static runRemovePlaceholders = async (\r\n    trucks: FoodTruck[],\r\n    dryRun: boolean,\r\n    operation: CleanupOperation,\r\n  ): Promise<CleanupOperation> => {\r\n    return await this.removePlaceholders(trucks, dryRun, operation);\r\n  };\r\n\r\n  private static runNormalizePhoneNumbers = async (\r\n    trucks: FoodTruck[],\r\n    dryRun: boolean,\r\n    operation: CleanupOperation,\r\n  ): Promise<CleanupOperation> => {\r\n    return await this.normalizePhoneNumbers(trucks, dryRun, operation);\r\n  };\r\n\r\n  private static runFixCoordinates = async (\r\n    trucks: FoodTruck[],\r\n    dryRun: boolean,\r\n    operation: CleanupOperation,\r\n  ): Promise<CleanupOperation> => {\r\n    return await this.fixCoordinates(trucks, dryRun, operation);\r\n  };\r\n\r\n  private static runUpdateQualityScores = async (\r\n    trucks: FoodTruck[],\r\n    dryRun: boolean,\r\n    operation: CleanupOperation,\r\n  ): Promise<CleanupOperation> => {\r\n    return await this.updateQualityScores(trucks, dryRun, operation);\r\n  };\r\n\r\n  private static runMergeDuplicates = async (\r\n    trucks: FoodTruck[],\r\n    dryRun: boolean,\r\n    operation: CleanupOperation,\r\n  ): Promise<CleanupOperation> => {\r\n    return await this.mergeDuplicates(trucks, dryRun, operation);\r\n  };\r\n\r\n  /**\r\n   * Remove placeholder and mock data\r\n   */\r\n  private static async removePlaceholders(\r\n    trucks: FoodTruck[],\r\n    dryRun: boolean,\r\n    operation: CleanupOperation,\r\n  ): Promise<CleanupOperation> {\r\n    const placeholderPatterns = getPlaceholderPatterns();\r\n    const promises = trucks.map((truck) =>\r\n      this.processSingleTruckForPlaceholders(truck, placeholderPatterns, dryRun, operation),\r\n    );\r\n    await Promise.all(promises);\r\n    return operation;\r\n  }\r\n\r\n  private static async processSingleTruckForPlaceholders(\r\n    truck: FoodTruck,\r\n    patterns: RegExp[],\r\n    dryRun: boolean,\r\n    operation: CleanupOperation,\r\n  ): Promise<void> {\r\n    const updates = processTruckForPlaceholders(truck, patterns);\r\n    if (updates && Object.keys(updates).length > 0) {\r\n      await this.performUpdateOperation(truck.id, updates, dryRun, operation);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Perform an update operation on a specified food truck.\r\n   * @example\r\n   * performUpdateOperation('truck123', { name: 'New Name' }, true, cleanupOperation)\r\n   * // No direct return value; operation may log errors.\r\n   * @param {string} truckId - The unique identifier of the food truck to be updated.\r\n   * @param {Partial<FoodTruck>} updates - An object containing the fields to be updated.\r\n   * @param {boolean} dryRun - Flag indicating whether the operation should be a simulation without actual changes.\r\n   * @param {CleanupOperation} operation - An operation object that logs errors encountered during update.\r\n   * @returns {Promise<void>} A promise that resolves when the update operation is complete.\r\n   * @description\r\n   *   - If 'dryRun' is true, no updates are applied but actions are logged.\r\n   *   - Errors during update are caught and logged in the 'operation.errors' array.\r\n   */\r\n  private static async performUpdateOperation(\r\n    truckId: string,\r\n    updates: Partial<FoodTruck>,\r\n    dryRun: boolean,\r\n    operation: CleanupOperation,\r\n  ): Promise<void> {\r\n    operation.affectedCount += 1;\r\n    if (dryRun) {\r\n      operation.successCount += 1;\r\n    } else {\r\n      try {\r\n        await FoodTruckService.updateTruck(truckId, updates);\r\n        operation.successCount += 1;\r\n      } catch (error) {\r\n        operation.errorCount += 1;\r\n        operation.errors.push(\r\n          `Failed to update truck ${truckId}: ${error instanceof Error ? error.message : String(error)}`,\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Normalize phone numbers to consistent format\r\n   */\r\n  private static async normalizePhoneNumbers(\r\n    trucks: FoodTruck[],\r\n    dryRun: boolean,\r\n    operation: CleanupOperation,\r\n  ): Promise<CleanupOperation> {\r\n    const promises = trucks.map((truck) => {\r\n      if (truck.contact_info?.phone !== undefined) {\r\n        const originalPhone = truck.contact_info.phone;\r\n        const normalizedPhone = this.normalizePhone(originalPhone);\r\n\r\n        if (normalizedPhone !== undefined && normalizedPhone !== originalPhone) {\r\n          return this.applyPhoneNormalizationUpdate(truck, normalizedPhone, dryRun, operation);\r\n        }\r\n      }\r\n      return Promise.resolve();\r\n    });\r\n    await Promise.all(promises);\r\n    return operation;\r\n  }\r\n\r\n  /**\r\n   * Apply phone normalization update to a food truck's contact information.\r\n   * @example\r\n   * applyPhoneNormalizationUpdate(truckInstance, '+1234567890', false, operationInstance)\r\n   * // Normalizes and updates phone number of given truckInstance.\r\n   * @param {FoodTruck} truck - The food truck object whose phone number needs normalization.\r\n   * @param {string} normalizedPhone - The normalized phone number to update to the food truck's contact information.\r\n   * @param {boolean} dryRun - Flag indicating whether the operation is a dry run; updates are skipped if true.\r\n   * @param {CleanupOperation} operation - Object containing cleanup operation context including a record of errors.\r\n   * @returns {Promise<void>} Does not return a value, but potentially modifies the truck and operation objects.\r\n   * @description\r\n   *   - Executes the update operation only if `dryRun` is false.\r\n   *   - Pushes error messages to `operation.errors` on failure during the update process.\r\n   *   - Uses `FoodTruckService.updateTruck` for updating the contact information.\r\n   */\r\n  private static async applyPhoneNormalizationUpdate(\r\n    truck: FoodTruck,\r\n    normalizedPhone: string,\r\n    dryRun: boolean,\r\n    operation: CleanupOperation,\r\n  ): Promise<void> {\r\n    operation.affectedCount += 1;\r\n    if (dryRun) {\r\n      operation.successCount += 1;\r\n    } else {\r\n      try {\r\n        await FoodTruckService.updateTruck(truck.id, {\r\n          contact_info: {\r\n            ...truck.contact_info,\r\n            phone: normalizedPhone,\r\n          },\r\n        });\r\n        operation.successCount += 1;\r\n      } catch (error) {\r\n        operation.errorCount += 1;\r\n        operation.errors.push(\r\n          `Failed to normalize phone for truck ${truck.id}: ${error instanceof Error ? error.message : String(error)}`,\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Helper to determine if coordinates need fixing and provide updates\r\n   */\r\n  private static getFixedCoordinates(\r\n    lat: number | undefined,\r\n    lng: number | undefined,\r\n    defaultLat: number,\r\n    defaultLng: number,\r\n  ): Partial<FoodTruck['current_location']> | undefined {\r\n    // Fix invalid coordinates (0,0 or undefined)\r\n    if (lat === undefined || lng === undefined || lat === 0 || lng === 0) {\r\n      return { lat: defaultLat, lng: defaultLng };\r\n    }\r\n    // Fix coordinates outside reasonable bounds for Charleston area\r\n    if (lat < 32 || lat > 34 || lng > -79 || lng < -81) {\r\n      return { lat: defaultLat, lng: defaultLng };\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * Fix invalid GPS coordinates\r\n   */\r\n  private static async fixCoordinates(\r\n    trucks: FoodTruck[],\r\n    dryRun: boolean,\r\n    operation: CleanupOperation,\r\n  ): Promise<CleanupOperation> {\r\n    const context: Omit<CoordinateProcessContext, 'operation'> = {\r\n      defaultLat: 32.7767,\r\n      defaultLng: -79.9311,\r\n      dryRun,\r\n    };\r\n\r\n    const promises = trucks.map((truck) =>\r\n      this.processSingleTruckCoordinates(truck, { ...context, operation }),\r\n    );\r\n    await Promise.all(promises);\r\n    return operation;\r\n  }\r\n\r\n  /**\r\n   * Processes coordinates for a single food truck, applying any necessary fixes.\r\n   * @example\r\n   * processSingleTruckCoordinates(truck, context)\r\n   * // No return value, function completes silently\r\n   * @param {FoodTruck} truck - The food truck whose coordinates are to be processed.\r\n   * @param {CoordinateProcessContext} context - Contains configuration and operation context for processing coordinates.\r\n   * @returns {Promise<void>} Returns a promise that resolves when the processing and possible updates are complete.\r\n   * @description\r\n   *   - Skips processing if the truck's current location is not available.\r\n   *   - Retrieves updates for fixed coordinates based on truck's current and default locations.\r\n   *   - Applies updates conditionally based on context settings such as `dryRun` and `operation`.\r\n   */\r\n  private static async processSingleTruckCoordinates(\r\n    truck: FoodTruck,\r\n    context: CoordinateProcessContext,\r\n  ): Promise<void> {\r\n    if (!truck.current_location) return;\r\n    const { defaultLat, defaultLng, dryRun, operation } = context;\r\n    const { lat, lng } = truck.current_location;\r\n    const updates = this.getFixedCoordinates(lat, lng, defaultLat, defaultLng);\r\n    if (updates) {\r\n      await this.applyCoordinateFixUpdate(truck, updates, dryRun, operation);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Applies coordinate updates for a food truck's current location.\r\n   * @example\r\n   * applyCoordinateFixUpdate(truck, { lat: 34.05, lng: -118.25 }, false, operation)\r\n   * // Updates the coordinates of the truck's location asynchronously.\r\n   * @param {FoodTruck} truck - The food truck object whose coordinates need correction.\r\n   * @param {Partial<FoodTruck['current_location']>} updates - The latitude and longitude updates to be applied.\r\n   * @param {boolean} dryRun - Flag to simulate the update without altering data.\r\n   * @param {CleanupOperation} operation - The cleanup operation instance used for error tracking.\r\n   * @returns {Promise<void>} Resolves when the coordinate update process is complete.\r\n   * @description\r\n   *   - Executes the update operation only if the dryRun flag is false.\r\n   *   - If the update fails, logs the error details into the operation's error array.\r\n   */\r\n  private static async applyCoordinateFixUpdate(\r\n    truck: FoodTruck,\r\n    updates: Partial<FoodTruck['current_location']>,\r\n    dryRun: boolean,\r\n    operation: CleanupOperation,\r\n  ): Promise<void> {\r\n    operation.affectedCount += 1;\r\n    if (dryRun) {\r\n      operation.successCount += 1;\r\n    } else {\r\n      try {\r\n        await FoodTruckService.updateTruck(truck.id, {\r\n          current_location: {\r\n            ...truck.current_location,\r\n            ...updates,\r\n          },\r\n        });\r\n        operation.successCount += 1;\r\n      } catch (error) {\r\n        operation.errorCount += 1;\r\n        operation.errors.push(\r\n          `Failed to fix coordinates for truck ${truck.id}: ${error instanceof Error ? error.message : String(error)}`,\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update quality scores for all trucks\r\n   */\r\n  private static async updateQualityScores(\r\n    trucks: FoodTruck[],\r\n    dryRun: boolean,\r\n    operation: CleanupOperation,\r\n  ): Promise<CleanupOperation> {\r\n    const promises = trucks.map((truck) =>\r\n      this.processSingleTruckForQualityScore(truck, dryRun, operation),\r\n    );\r\n    await Promise.all(promises);\r\n    return operation;\r\n  }\r\n\r\n  /**\r\n  * Processes a single food truck for an updated quality score assessment.\r\n  * @example\r\n  * processSingleTruckForQualityScore(truckInstance, false, cleanupOperationInstance)\r\n  * // No return value\r\n  * @param {FoodTruck} truck - The food truck instance to assess and potentially update.\r\n  * @param {boolean} dryRun - Specifies whether this is a dry run (no actual data updates).\r\n  * @param {CleanupOperation} operation - The cleanup operation context for processing.\r\n  * @returns {Promise<void>} No return value; operation is performed asynchronously.\r\n  * @description\r\n  *   - Computes the quality score using data from DataQualityService.\r\n  *   - Updates the quality score only if the score changes significantly (>5% difference).\r\n  *   - Assumes `truck.data_quality_score` might be undefined, defaulting to 0.\r\n  *   - Handles asynchronous processing of the update application if conditions are met.\r\n  */\r\n  private static async processSingleTruckForQualityScore(\r\n    truck: FoodTruck,\r\n    dryRun: boolean,\r\n    operation: CleanupOperation,\r\n  ): Promise<void> {\r\n    const qualityAssessment = DataQualityService.calculateQualityScore(truck);\r\n    if (qualityAssessment) {\r\n      const newScore = qualityAssessment.score;\r\n      const currentScore = truck.data_quality_score ?? 0;\r\n      // Only update if score changed significantly (>5% difference)\r\n      if (typeof newScore === 'number' && Math.abs(newScore - currentScore) > 0.05) {\r\n        await this.applyQualityScoreUpdate(truck, dryRun, operation);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Updates the quality score of a specified food truck and handles errors during the update process.\r\n   * @example\r\n   * applyQualityScoreUpdate(foodTruckInstance, false, cleanupOperationInstance)\r\n   * void\r\n   * @param {FoodTruck} truck - The food truck for which the quality score will be updated.\r\n   * @param {boolean} dryRun - Flag indicating whether the function should perform the update or just simulate it.\r\n   * @param {CleanupOperation} operation - The cleanup operation containing possible error records.\r\n   * @returns {Promise<void>} Resolves with no value when the update completes. Errors are recorded in the `operation` if thrown.\r\n   * @description\r\n   *   - Throws an error if the quality score update fails.\r\n   *   - If `dryRun` is true, the function simulates the update without changing any data.\r\n   *   - Errors occurring during the update are appended to the `operation.errors` array.\r\n   */\r\n  private static async applyQualityScoreUpdate(\r\n    truck: FoodTruck,\r\n    dryRun: boolean,\r\n    operation: CleanupOperation,\r\n  ): Promise<void> {\r\n    operation.affectedCount += 1;\r\n    if (dryRun) {\r\n      operation.successCount += 1;\r\n    } else {\r\n      try {\r\n        const updateResult = await DataQualityService.updateTruckQualityScore(truck.id);\r\n        if ('error' in updateResult) {\r\n          throw new Error(updateResult.error);\r\n        }\r\n        operation.successCount += 1;\r\n      } catch (error) {\r\n        operation.errorCount += 1;\r\n        operation.errors.push(\r\n          `Failed to update quality score for truck ${truck.id}: ${error instanceof Error ? error.message : String(error)}`,\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Identify and merge duplicate trucks\r\n   */\r\n  private static async mergeDuplicates(\r\n    trucks: FoodTruck[],\r\n    dryRun: boolean,\r\n    operation: CleanupOperation,\r\n  ): Promise<CleanupOperation> {\r\n    const processedIds = new Set<string>();\r\n    for (const truck of trucks) {\r\n      await this.processSingleTruckForDuplicates(truck, dryRun, { operation, processedIds });\r\n    }\r\n    return operation;\r\n  }\r\n\r\n  /**\r\n   * Processes a single food truck to detect and handle duplicates in the dataset.\r\n   * @example\r\n   * processSingleTruckForDuplicates(foodTruck, true, mergeContext)\r\n   * // No return value. Performs operations as a side effect.\r\n   * @param {FoodTruck} truck - An instance of FoodTruck to process for duplicates.\r\n   * @param {boolean} dryRun - Flag indicating if the operation should be executed in dry run mode.\r\n   * @param {MergeOperationContext} context - Operational context that carries state and configurations for the merge operation.\r\n   * @returns {Promise<void>} Executes a set of operations for handling duplicate records, does not return any value.\r\n   * @description\r\n   *   - Ensures a food truck is only processed once by maintaining a set of processed IDs.\r\n   *   - Uses DuplicatePreventionService to assess whether the given truck is a duplicate.\r\n   *   - Applies a merge operation if a duplicate truck is confidently identified.\r\n   */\r\n  private static async processSingleTruckForDuplicates(\r\n    truck: FoodTruck,\r\n    dryRun: boolean,\r\n    context: MergeOperationContext,\r\n  ): Promise<void> {\r\n    const { processedIds } = context;\r\n    if (processedIds.has(truck.id)) return;\r\n\r\n    const duplicateCheck = await DuplicatePreventionService.checkForDuplicates(truck);\r\n    if (\r\n      duplicateCheck.isDuplicate &&\r\n      duplicateCheck.bestMatch?.confidence === 'high' &&\r\n      duplicateCheck.bestMatch.recommendation === 'merge'\r\n    ) {\r\n      await this.applyMergeOperation(\r\n        truck,\r\n        duplicateCheck.bestMatch.existingTruck,\r\n        dryRun,\r\n        context,\r\n      );\r\n    }\r\n    processedIds.add(truck.id);\r\n  }\r\n\r\n  /**\r\n   * Applies a merge operation between two food trucks and updates the context.\r\n   * @example\r\n   * applyMergeOperation(truck, existingTruck, true, context)\r\n   * // Executes a dry run of the merge operation without affecting data\r\n   * @param {FoodTruck} truck - The food truck that is being merged.\r\n   * @param {FoodTruck} existingTruck - The existing food truck to merge with.\r\n   * @param {boolean} dryRun - Indicates if the merge operation should be simulated.\r\n   * @param {MergeOperationContext} context - Context containing details and state of the merge operation.\r\n   * @returns {Promise<void>} Promise representing the completion of the merge operation.\r\n   * @description\r\n   *   - Updates the list of processed IDs in the context upon successful merge.\r\n   *   - Throws and records an error if the merge operation fails.\r\n   *   - Utilizes the DuplicatePreventionService for performing the merge.\r\n   */\r\n  private static async applyMergeOperation(\r\n    truck: FoodTruck,\r\n    existingTruck: FoodTruck,\r\n    dryRun: boolean,\r\n    context: MergeOperationContext,\r\n  ): Promise<void> {\r\n    const { operation, processedIds } = context;\r\n    operation.affectedCount += 1;\r\n    if (dryRun) {\r\n      operation.successCount += 1;\r\n    } else {\r\n      try {\r\n        const mergeResult = await DuplicatePreventionService.mergeDuplicates(\r\n          truck.id,\r\n          existingTruck.id,\r\n        );\r\n        if ('error' in mergeResult) {\r\n          throw new Error(mergeResult.error);\r\n        }\r\n        processedIds.add(existingTruck.id);\r\n        operation.successCount += 1;\r\n      } catch (error) {\r\n        operation.errorCount += 1;\r\n        operation.errors.push(\r\n          `Failed to merge duplicates ${truck.id} and ${existingTruck.id}: ${error instanceof Error ? error.message : String(error)}`,\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Normalize phone number format\r\n   */\r\n  private static normalizePhone(phone: string): string | undefined {\r\n    if (!phone) return undefined;\r\n\r\n    // Remove all non-digit characters\r\n    const digits = phone.replaceAll(/\\D/g, '');\r\n\r\n    // Handle US phone numbers\r\n    if (digits.length === 10) {\r\n      return `(${digits.slice(0, 3)}) ${digits.slice(3, 6)}-${digits.slice(6)}`;\r\n    }\r\n    if (digits.length === 11 && digits.startsWith('1')) {\r\n      return `+1 (${digits.slice(1, 4)}) ${digits.slice(4, 7)}-${digits.slice(7)}`;\r\n    }\r\n\r\n    // Return original if can't normalize\r\n    return phone;\r\n  }\r\n\r\n  /**\r\n   * Get operation description\r\n   */\r\n  private static getOperationDescription(type: CleanupOperation['type']): string {\r\n    const descriptions = {\r\n      remove_placeholders: 'Remove placeholder and mock data values',\r\n      normalize_phone: 'Normalize phone numbers to consistent format',\r\n      fix_coordinates: 'Fix invalid GPS coordinates',\r\n      update_quality_scores: 'Recalculate data quality scores',\r\n      merge_duplicates: 'Identify and merge duplicate truck entries',\r\n    };\r\n\r\n    return descriptions[type] ?? 'Unknown operation';\r\n  }\r\n\r\n  /**\r\n   * Calculate cleanup summary\r\n   */\r\n  private static calculateSummary(operations: CleanupOperation[]): BatchCleanupResult['summary'] {\r\n    return {\r\n      trucksImproved: operations.reduce((sum, op) => sum + op.successCount, 0),\r\n      duplicatesRemoved: operations.find((op) => op.type === 'merge_duplicates')?.successCount ?? 0,\r\n      qualityScoreImprovement:\r\n        operations.find((op) => op.type === 'update_quality_scores')?.successCount ?? 0,\r\n      placeholdersRemoved:\r\n        operations.find((op) => op.type === 'remove_placeholders')?.successCount ?? 0,\r\n    };\r\n  }\r\n}\r\n\nexport {type BatchCleanupResult} from '@/lib/types';"}},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":170,"column":11,"nodeType":"Identifier","messageId":"conditionErrorObject","endLine":170,"endColumn":17},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":247,"column":9,"nodeType":"Identifier","messageId":"conditionErrorObject","endLine":247,"endColumn":16},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":411,"column":10,"nodeType":"MemberExpression","messageId":"conditionErrorObject","endLine":411,"endColumn":32},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":497,"column":9,"nodeType":"Identifier","messageId":"conditionErrorObject","endLine":497,"endColumn":26}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":3,"fixableWarningCount":0,"source":"/**\r\n * SOTA Batch Data Cleanup System\r\n * Implements automated data quality improvements and cleanup operations\r\n */\r\n\r\nimport { FoodTruckService, DataQualityService } from '@/lib/supabase';\r\nimport type { FoodTruck, CleanupOperation, CleanupOperationType, BatchCleanupResult } from '@/lib/types';\r\nimport { DuplicatePreventionService } from './duplicatePrevention';\r\nimport { getPlaceholderPatterns, processTruckForPlaceholders } from './placeholderUtils';\r\n\r\n// Re-export the types for backward compatibility\r\nexport type { CleanupOperation, CleanupOperationType, BatchCleanupResult };\r\n\r\ninterface MergeOperationContext {\r\n  operation: CleanupOperation;\r\n  processedIds: Set<string>;\r\n}\r\n\r\ninterface CoordinateProcessContext {\r\n  defaultLat: number;\r\n  defaultLng: number;\r\n  dryRun: boolean;\r\n  operation: CleanupOperation;\r\n}\r\n\r\n/**\r\n * Automated Data Quality Cleanup Service\r\n */\r\nexport class BatchCleanupService {\r\n  /**\r\n   * Run comprehensive data cleanup operations\r\n   */\r\n  static async runFullCleanup(\r\n    options: {\r\n      batchSize?: number;\r\n      dryRun?: boolean;\r\n      operations?: CleanupOperation['type'][];\r\n    } = {},\r\n  ): Promise<BatchCleanupResult> {\r\n    const startTime = Date.now();\r\n    const {\r\n      batchSize = 50,\r\n      dryRun = false,\r\n      operations = [\r\n        'remove_placeholders',\r\n        'normalize_phone',\r\n        'fix_coordinates',\r\n        'update_quality_scores',\r\n        'merge_duplicates',\r\n      ],\r\n    } = options;\r\n\r\n    console.info(`Starting batch cleanup (${dryRun ? 'DRY RUN' : 'LIVE'})...`);\r\n    const result = this.initializeCleanupResult();\r\n    try {\r\n      const allTrucks = await FoodTruckService.getAllTrucks();\r\n      result.totalProcessed = allTrucks.total;\r\n      await this.processTrucksInBatches(allTrucks.trucks, {\r\n        batchSize,\r\n        operations,\r\n        dryRun,\r\n        result,\r\n      });\r\n      return this.finalizeCleanupResult(result, startTime);\r\n    } catch (error) {\r\n      console.error('Batch cleanup failed:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n  * Initializes and returns a new BatchCleanupResult object with default values.\r\n  * @example\r\n  * initializeCleanupResult()\r\n  * { totalProcessed: 0, operations: [], summary: { trucksImproved: 0, duplicatesRemoved: 0, qualityScoreImprovement: 0, placeholdersRemoved: 0 }, duration: 0 }\r\n  * @returns {BatchCleanupResult} A new BatchCleanupResult object with all properties set to initial default values.\r\n  */\r\n  private static initializeCleanupResult(): BatchCleanupResult {\r\n    return {\r\n      totalProcessed: 0,\r\n      operations: [],\r\n      summary: {\r\n        trucksImproved: 0,\r\n        duplicatesRemoved: 0,\r\n        qualityScoreImprovement: 0,\r\n        placeholdersRemoved: 0,\r\n      },\r\n      duration: 0,\r\n    };\r\n  }\r\n\r\n  private static finalizeCleanupResult(\r\n    result: BatchCleanupResult,\r\n    startTime: number,\r\n  ): BatchCleanupResult {\r\n    result.summary = this.calculateSummary(result.operations);\r\n    result.duration = Date.now() - startTime;\r\n\r\n    console.info(`Batch cleanup completed in ${result.duration}ms`);\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Processes food trucks in batches, executing specified operations on each batch.\r\n   * @example\r\n   * processTrucksInBatches(truckList, { batchSize: 10, operations: ['clean'], dryRun: true, result: batchResult })\r\n   * // It executes 'clean' operation on batches of 10 trucks without making permanent changes.\r\n   * @param {FoodTruck[]} trucks - Array of food trucks to be processed in batches.\r\n   * @param {object} options - Options object containing batchSize, operations, dryRun, and result.\r\n   * @param {number} options.batchSize - Number of trucks in each batch.\r\n   * @param {CleanupOperation['type'][]} options.operations - Array of operation types to be executed on each batch.\r\n   * @param {boolean} options.dryRun - If true, operations are executed in simulation mode without permanent changes.\r\n   * @param {BatchCleanupResult} options.result - Stores the results of operations performed on batches.\r\n   * @returns {Promise<void>} Completes processing batches without a return value.\r\n   * @description\r\n   *   - Uses async function to allow non-blocking execution of operations.\r\n   *   - Collects and stores results of batch operations separately, keeping track of each operation's outcome.\r\n   *   - Iterates over arrays using slicing to dynamically create batches for processing.\r\n   */\r\n  private static async processTrucksInBatches(\r\n    trucks: FoodTruck[],\r\n    {\r\n      batchSize,\r\n      operations,\r\n      dryRun,\r\n      result,\r\n    }: {\r\n      batchSize: number;\r\n      operations: CleanupOperation['type'][];\r\n      dryRun: boolean;\r\n      result: BatchCleanupResult;\r\n    },\r\n  ): Promise<void> {\r\n    for (let i = 0; i < trucks.length; i += batchSize) {\r\n      const batch = trucks.slice(i, i + batchSize);\r\n      for (const op of operations) {\r\n        const opResult = await this.runOperation(op, batch, dryRun);\r\n        result.operations.push(opResult);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Run a specific cleanup operation\r\n   */\r\n  private static async runOperation(\r\n    type: CleanupOperation['type'],\r\n    trucks: FoodTruck[],\r\n    dryRun: boolean,\r\n  ): Promise<CleanupOperation> {\r\n    const operation: CleanupOperation = {\r\n      type,\r\n      description: this.getOperationDescription(type),\r\n      affectedCount: 0,\r\n      successCount: 0,\r\n      errorCount: 0,\r\n      errors: [],\r\n    };\r\n\r\n    const operationRunners = {\r\n      remove_placeholders: this.runRemovePlaceholders,\r\n      normalize_phone: this.runNormalizePhoneNumbers,\r\n      fix_coordinates: this.runFixCoordinates,\r\n      update_quality_scores: this.runUpdateQualityScores,\r\n      merge_duplicates: this.runMergeDuplicates,\r\n    };\r\n\r\n    try {\r\n      const runner = operationRunners[type];\r\n      if (runner) {\r\n        return await runner.call(this, trucks, dryRun, operation);\r\n      } \r\n        operation.errors.push(`Unknown operation type: ${String(type)}`);\r\n        return operation;\r\n      \r\n    } catch (error) {\r\n      operation.errors.push(\r\n        `Operation failed: ${error instanceof Error ? error.message : String(error)}`,\r\n      );\r\n      return operation;\r\n    }\r\n  }\r\n\r\n  private static runRemovePlaceholders = async (\r\n    trucks: FoodTruck[],\r\n    dryRun: boolean,\r\n    operation: CleanupOperation,\r\n  ): Promise<CleanupOperation> => {\r\n    return await this.removePlaceholders(trucks, dryRun, operation);\r\n  };\r\n\r\n  private static runNormalizePhoneNumbers = async (\r\n    trucks: FoodTruck[],\r\n    dryRun: boolean,\r\n    operation: CleanupOperation,\r\n  ): Promise<CleanupOperation> => {\r\n    return await this.normalizePhoneNumbers(trucks, dryRun, operation);\r\n  };\r\n\r\n  private static runFixCoordinates = async (\r\n    trucks: FoodTruck[],\r\n    dryRun: boolean,\r\n    operation: CleanupOperation,\r\n  ): Promise<CleanupOperation> => {\r\n    return await this.fixCoordinates(trucks, dryRun, operation);\r\n  };\r\n\r\n  private static runUpdateQualityScores = async (\r\n    trucks: FoodTruck[],\r\n    dryRun: boolean,\r\n    operation: CleanupOperation,\r\n  ): Promise<CleanupOperation> => {\r\n    return await this.updateQualityScores(trucks, dryRun, operation);\r\n  };\r\n\r\n  private static runMergeDuplicates = async (\r\n    trucks: FoodTruck[],\r\n    dryRun: boolean,\r\n    operation: CleanupOperation,\r\n  ): Promise<CleanupOperation> => {\r\n    return await this.mergeDuplicates(trucks, dryRun, operation);\r\n  };\r\n\r\n  /**\r\n   * Remove placeholder and mock data\r\n   */\r\n  private static async removePlaceholders(\r\n    trucks: FoodTruck[],\r\n    dryRun: boolean,\r\n    operation: CleanupOperation,\r\n  ): Promise<CleanupOperation> {\r\n    const placeholderPatterns = getPlaceholderPatterns();\r\n    const promises = trucks.map((truck) =>\r\n      this.processSingleTruckForPlaceholders(truck, placeholderPatterns, dryRun, operation),\r\n    );\r\n    await Promise.all(promises);\r\n    return operation;\r\n  }\r\n\r\n  private static async processSingleTruckForPlaceholders(\r\n    truck: FoodTruck,\r\n    patterns: RegExp[],\r\n    dryRun: boolean,\r\n    operation: CleanupOperation,\r\n  ): Promise<void> {\r\n    const updates = processTruckForPlaceholders(truck, patterns);\r\n    if (updates && Object.keys(updates).length > 0) {\r\n      await this.performUpdateOperation(truck.id, updates, dryRun, operation);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Perform an update operation on a specified food truck.\r\n   * @example\r\n   * performUpdateOperation('truck123', { name: 'New Name' }, true, cleanupOperation)\r\n   * // No direct return value; operation may log errors.\r\n   * @param {string} truckId - The unique identifier of the food truck to be updated.\r\n   * @param {Partial<FoodTruck>} updates - An object containing the fields to be updated.\r\n   * @param {boolean} dryRun - Flag indicating whether the operation should be a simulation without actual changes.\r\n   * @param {CleanupOperation} operation - An operation object that logs errors encountered during update.\r\n   * @returns {Promise<void>} A promise that resolves when the update operation is complete.\r\n   * @description\r\n   *   - If 'dryRun' is true, no updates are applied but actions are logged.\r\n   *   - Errors during update are caught and logged in the 'operation.errors' array.\r\n   */\r\n  private static async performUpdateOperation(\r\n    truckId: string,\r\n    updates: Partial<FoodTruck>,\r\n    dryRun: boolean,\r\n    operation: CleanupOperation,\r\n  ): Promise<void> {\r\n    operation.affectedCount += 1;\r\n    if (dryRun) {\r\n      operation.successCount += 1;\r\n    } else {\r\n      try {\r\n        await FoodTruckService.updateTruck(truckId, updates);\r\n        operation.successCount += 1;\r\n      } catch (error) {\r\n        operation.errorCount += 1;\r\n        operation.errors.push(\r\n          `Failed to update truck ${truckId}: ${error instanceof Error ? error.message : String(error)}`,\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Normalize phone numbers to consistent format\r\n   */\r\n  private static async normalizePhoneNumbers(\r\n    trucks: FoodTruck[],\r\n    dryRun: boolean,\r\n    operation: CleanupOperation,\r\n  ): Promise<CleanupOperation> {\r\n    const promises = trucks.map((truck) => {\r\n      if (truck.contact_info?.phone !== undefined) {\r\n        const originalPhone = truck.contact_info.phone;\r\n        const normalizedPhone = this.normalizePhone(originalPhone);\r\n\r\n        if (normalizedPhone !== undefined && normalizedPhone !== originalPhone) {\r\n          return this.applyPhoneNormalizationUpdate(truck, normalizedPhone, dryRun, operation);\r\n        }\r\n      }\r\n      return Promise.resolve();\r\n    });\r\n    await Promise.all(promises);\r\n    return operation;\r\n  }\r\n\r\n  /**\r\n   * Apply phone normalization update to a food truck's contact information.\r\n   * @example\r\n   * applyPhoneNormalizationUpdate(truckInstance, '+1234567890', false, operationInstance)\r\n   * // Normalizes and updates phone number of given truckInstance.\r\n   * @param {FoodTruck} truck - The food truck object whose phone number needs normalization.\r\n   * @param {string} normalizedPhone - The normalized phone number to update to the food truck's contact information.\r\n   * @param {boolean} dryRun - Flag indicating whether the operation is a dry run; updates are skipped if true.\r\n   * @param {CleanupOperation} operation - Object containing cleanup operation context including a record of errors.\r\n   * @returns {Promise<void>} Does not return a value, but potentially modifies the truck and operation objects.\r\n   * @description\r\n   *   - Executes the update operation only if `dryRun` is false.\r\n   *   - Pushes error messages to `operation.errors` on failure during the update process.\r\n   *   - Uses `FoodTruckService.updateTruck` for updating the contact information.\r\n   */\r\n  private static async applyPhoneNormalizationUpdate(\r\n    truck: FoodTruck,\r\n    normalizedPhone: string,\r\n    dryRun: boolean,\r\n    operation: CleanupOperation,\r\n  ): Promise<void> {\r\n    operation.affectedCount += 1;\r\n    if (dryRun) {\r\n      operation.successCount += 1;\r\n    } else {\r\n      try {\r\n        await FoodTruckService.updateTruck(truck.id, {\r\n          contact_info: {\r\n            ...truck.contact_info,\r\n            phone: normalizedPhone,\r\n          },\r\n        });\r\n        operation.successCount += 1;\r\n      } catch (error) {\r\n        operation.errorCount += 1;\r\n        operation.errors.push(\r\n          `Failed to normalize phone for truck ${truck.id}: ${error instanceof Error ? error.message : String(error)}`,\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Helper to determine if coordinates need fixing and provide updates\r\n   */\r\n  private static getFixedCoordinates(\r\n    lat: number | undefined,\r\n    lng: number | undefined,\r\n    defaultLat: number,\r\n    defaultLng: number,\r\n  ): Partial<FoodTruck['current_location']> | undefined {\r\n    // Fix invalid coordinates (0,0 or undefined)\r\n    if (lat === undefined || lng === undefined || lat === 0 || lng === 0) {\r\n      return { lat: defaultLat, lng: defaultLng };\r\n    }\r\n    // Fix coordinates outside reasonable bounds for Charleston area\r\n    if (lat < 32 || lat > 34 || lng > -79 || lng < -81) {\r\n      return { lat: defaultLat, lng: defaultLng };\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * Fix invalid GPS coordinates\r\n   */\r\n  private static async fixCoordinates(\r\n    trucks: FoodTruck[],\r\n    dryRun: boolean,\r\n    operation: CleanupOperation,\r\n  ): Promise<CleanupOperation> {\r\n    const context: Omit<CoordinateProcessContext, 'operation'> = {\r\n      defaultLat: 32.7767,\r\n      defaultLng: -79.9311,\r\n      dryRun,\r\n    };\r\n\r\n    const promises = trucks.map((truck) =>\r\n      this.processSingleTruckCoordinates(truck, { ...context, operation }),\r\n    );\r\n    await Promise.all(promises);\r\n    return operation;\r\n  }\r\n\r\n  /**\r\n   * Processes coordinates for a single food truck, applying any necessary fixes.\r\n   * @example\r\n   * processSingleTruckCoordinates(truck, context)\r\n   * // No return value, function completes silently\r\n   * @param {FoodTruck} truck - The food truck whose coordinates are to be processed.\r\n   * @param {CoordinateProcessContext} context - Contains configuration and operation context for processing coordinates.\r\n   * @returns {Promise<void>} Returns a promise that resolves when the processing and possible updates are complete.\r\n   * @description\r\n   *   - Skips processing if the truck's current location is not available.\r\n   *   - Retrieves updates for fixed coordinates based on truck's current and default locations.\r\n   *   - Applies updates conditionally based on context settings such as `dryRun` and `operation`.\r\n   */\r\n  private static async processSingleTruckCoordinates(\r\n    truck: FoodTruck,\r\n    context: CoordinateProcessContext,\r\n  ): Promise<void> {\r\n    if (!truck.current_location) return;\r\n    const { defaultLat, defaultLng, dryRun, operation } = context;\r\n    const { lat, lng } = truck.current_location;\r\n    const updates = this.getFixedCoordinates(lat, lng, defaultLat, defaultLng);\r\n    if (updates) {\r\n      await this.applyCoordinateFixUpdate(truck, updates, dryRun, operation);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Applies coordinate updates for a food truck's current location.\r\n   * @example\r\n   * applyCoordinateFixUpdate(truck, { lat: 34.05, lng: -118.25 }, false, operation)\r\n   * // Updates the coordinates of the truck's location asynchronously.\r\n   * @param {FoodTruck} truck - The food truck object whose coordinates need correction.\r\n   * @param {Partial<FoodTruck['current_location']>} updates - The latitude and longitude updates to be applied.\r\n   * @param {boolean} dryRun - Flag to simulate the update without altering data.\r\n   * @param {CleanupOperation} operation - The cleanup operation instance used for error tracking.\r\n   * @returns {Promise<void>} Resolves when the coordinate update process is complete.\r\n   * @description\r\n   *   - Executes the update operation only if the dryRun flag is false.\r\n   *   - If the update fails, logs the error details into the operation's error array.\r\n   */\r\n  private static async applyCoordinateFixUpdate(\r\n    truck: FoodTruck,\r\n    updates: Partial<FoodTruck['current_location']>,\r\n    dryRun: boolean,\r\n    operation: CleanupOperation,\r\n  ): Promise<void> {\r\n    operation.affectedCount += 1;\r\n    if (dryRun) {\r\n      operation.successCount += 1;\r\n    } else {\r\n      try {\r\n        await FoodTruckService.updateTruck(truck.id, {\r\n          current_location: {\r\n            ...truck.current_location,\r\n            ...updates,\r\n          },\r\n        });\r\n        operation.successCount += 1;\r\n      } catch (error) {\r\n        operation.errorCount += 1;\r\n        operation.errors.push(\r\n          `Failed to fix coordinates for truck ${truck.id}: ${error instanceof Error ? error.message : String(error)}`,\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update quality scores for all trucks\r\n   */\r\n  private static async updateQualityScores(\r\n    trucks: FoodTruck[],\r\n    dryRun: boolean,\r\n    operation: CleanupOperation,\r\n  ): Promise<CleanupOperation> {\r\n    const promises = trucks.map((truck) =>\r\n      this.processSingleTruckForQualityScore(truck, dryRun, operation),\r\n    );\r\n    await Promise.all(promises);\r\n    return operation;\r\n  }\r\n\r\n  /**\r\n  * Processes a single food truck for an updated quality score assessment.\r\n  * @example\r\n  * processSingleTruckForQualityScore(truckInstance, false, cleanupOperationInstance)\r\n  * // No return value\r\n  * @param {FoodTruck} truck - The food truck instance to assess and potentially update.\r\n  * @param {boolean} dryRun - Specifies whether this is a dry run (no actual data updates).\r\n  * @param {CleanupOperation} operation - The cleanup operation context for processing.\r\n  * @returns {Promise<void>} No return value; operation is performed asynchronously.\r\n  * @description\r\n  *   - Computes the quality score using data from DataQualityService.\r\n  *   - Updates the quality score only if the score changes significantly (>5% difference).\r\n  *   - Assumes `truck.data_quality_score` might be undefined, defaulting to 0.\r\n  *   - Handles asynchronous processing of the update application if conditions are met.\r\n  */\r\n  private static async processSingleTruckForQualityScore(\r\n    truck: FoodTruck,\r\n    dryRun: boolean,\r\n    operation: CleanupOperation,\r\n  ): Promise<void> {\r\n    const qualityAssessment = DataQualityService.calculateQualityScore(truck);\r\n    if (qualityAssessment) {\r\n      const newScore = qualityAssessment.score;\r\n      const currentScore = truck.data_quality_score ?? 0;\r\n      // Only update if score changed significantly (>5% difference)\r\n      if (typeof newScore === 'number' && Math.abs(newScore - currentScore) > 0.05) {\r\n        await this.applyQualityScoreUpdate(truck, dryRun, operation);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Updates the quality score of a specified food truck and handles errors during the update process.\r\n   * @example\r\n   * applyQualityScoreUpdate(foodTruckInstance, false, cleanupOperationInstance)\r\n   * void\r\n   * @param {FoodTruck} truck - The food truck for which the quality score will be updated.\r\n   * @param {boolean} dryRun - Flag indicating whether the function should perform the update or just simulate it.\r\n   * @param {CleanupOperation} operation - The cleanup operation containing possible error records.\r\n   * @returns {Promise<void>} Resolves with no value when the update completes. Errors are recorded in the `operation` if thrown.\r\n   * @description\r\n   *   - Throws an error if the quality score update fails.\r\n   *   - If `dryRun` is true, the function simulates the update without changing any data.\r\n   *   - Errors occurring during the update are appended to the `operation.errors` array.\r\n   */\r\n  private static async applyQualityScoreUpdate(\r\n    truck: FoodTruck,\r\n    dryRun: boolean,\r\n    operation: CleanupOperation,\r\n  ): Promise<void> {\r\n    operation.affectedCount += 1;\r\n    if (dryRun) {\r\n      operation.successCount += 1;\r\n    } else {\r\n      try {\r\n        const updateResult = await DataQualityService.updateTruckQualityScore(truck.id);\r\n        if ('error' in updateResult) {\r\n          throw new Error(updateResult.error);\r\n        }\r\n        operation.successCount += 1;\r\n      } catch (error) {\r\n        operation.errorCount += 1;\r\n        operation.errors.push(\r\n          `Failed to update quality score for truck ${truck.id}: ${error instanceof Error ? error.message : String(error)}`,\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Identify and merge duplicate trucks\r\n   */\r\n  private static async mergeDuplicates(\r\n    trucks: FoodTruck[],\r\n    dryRun: boolean,\r\n    operation: CleanupOperation,\r\n  ): Promise<CleanupOperation> {\r\n    const processedIds = new Set<string>();\r\n    for (const truck of trucks) {\r\n      await this.processSingleTruckForDuplicates(truck, dryRun, { operation, processedIds });\r\n    }\r\n    return operation;\r\n  }\r\n\r\n  /**\r\n   * Processes a single food truck to detect and handle duplicates in the dataset.\r\n   * @example\r\n   * processSingleTruckForDuplicates(foodTruck, true, mergeContext)\r\n   * // No return value. Performs operations as a side effect.\r\n   * @param {FoodTruck} truck - An instance of FoodTruck to process for duplicates.\r\n   * @param {boolean} dryRun - Flag indicating if the operation should be executed in dry run mode.\r\n   * @param {MergeOperationContext} context - Operational context that carries state and configurations for the merge operation.\r\n   * @returns {Promise<void>} Executes a set of operations for handling duplicate records, does not return any value.\r\n   * @description\r\n   *   - Ensures a food truck is only processed once by maintaining a set of processed IDs.\r\n   *   - Uses DuplicatePreventionService to assess whether the given truck is a duplicate.\r\n   *   - Applies a merge operation if a duplicate truck is confidently identified.\r\n   */\r\n  private static async processSingleTruckForDuplicates(\r\n    truck: FoodTruck,\r\n    dryRun: boolean,\r\n    context: MergeOperationContext,\r\n  ): Promise<void> {\r\n    const { processedIds } = context;\r\n    if (processedIds.has(truck.id)) return;\r\n\r\n    const duplicateCheck = await DuplicatePreventionService.checkForDuplicates(truck);\r\n    if (\r\n      duplicateCheck.isDuplicate &&\r\n      duplicateCheck.bestMatch?.confidence === 'high' &&\r\n      duplicateCheck.bestMatch.recommendation === 'merge'\r\n    ) {\r\n      await this.applyMergeOperation(\r\n        truck,\r\n        duplicateCheck.bestMatch.existingTruck,\r\n        dryRun,\r\n        context,\r\n      );\r\n    }\r\n    processedIds.add(truck.id);\r\n  }\r\n\r\n  /**\r\n   * Applies a merge operation between two food trucks and updates the context.\r\n   * @example\r\n   * applyMergeOperation(truck, existingTruck, true, context)\r\n   * // Executes a dry run of the merge operation without affecting data\r\n   * @param {FoodTruck} truck - The food truck that is being merged.\r\n   * @param {FoodTruck} existingTruck - The existing food truck to merge with.\r\n   * @param {boolean} dryRun - Indicates if the merge operation should be simulated.\r\n   * @param {MergeOperationContext} context - Context containing details and state of the merge operation.\r\n   * @returns {Promise<void>} Promise representing the completion of the merge operation.\r\n   * @description\r\n   *   - Updates the list of processed IDs in the context upon successful merge.\r\n   *   - Throws and records an error if the merge operation fails.\r\n   *   - Utilizes the DuplicatePreventionService for performing the merge.\r\n   */\r\n  private static async applyMergeOperation(\r\n    truck: FoodTruck,\r\n    existingTruck: FoodTruck,\r\n    dryRun: boolean,\r\n    context: MergeOperationContext,\r\n  ): Promise<void> {\r\n    const { operation, processedIds } = context;\r\n    operation.affectedCount += 1;\r\n    if (dryRun) {\r\n      operation.successCount += 1;\r\n    } else {\r\n      try {\r\n        const mergeResult = await DuplicatePreventionService.mergeDuplicates(\r\n          truck.id,\r\n          existingTruck.id,\r\n        );\r\n        if ('error' in mergeResult) {\r\n          throw new Error(mergeResult.error);\r\n        }\r\n        processedIds.add(existingTruck.id);\r\n        operation.successCount += 1;\r\n      } catch (error) {\r\n        operation.errorCount += 1;\r\n        operation.errors.push(\r\n          `Failed to merge duplicates ${truck.id} and ${existingTruck.id}: ${error instanceof Error ? error.message : String(error)}`,\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Normalize phone number format\r\n   */\r\n  private static normalizePhone(phone: string): string | undefined {\r\n    if (!phone) return undefined;\r\n\r\n    // Remove all non-digit characters\r\n    const digits = phone.replaceAll(/\\D/g, '');\r\n\r\n    // Handle US phone numbers\r\n    if (digits.length === 10) {\r\n      return `(${digits.slice(0, 3)}) ${digits.slice(3, 6)}-${digits.slice(6)}`;\r\n    }\r\n    if (digits.length === 11 && digits.startsWith('1')) {\r\n      return `+1 (${digits.slice(1, 4)}) ${digits.slice(4, 7)}-${digits.slice(7)}`;\r\n    }\r\n\r\n    // Return original if can't normalize\r\n    return phone;\r\n  }\r\n\r\n  /**\r\n   * Get operation description\r\n   */\r\n  private static getOperationDescription(type: CleanupOperation['type']): string {\r\n    const descriptions = {\r\n      remove_placeholders: 'Remove placeholder and mock data values',\r\n      normalize_phone: 'Normalize phone numbers to consistent format',\r\n      fix_coordinates: 'Fix invalid GPS coordinates',\r\n      update_quality_scores: 'Recalculate data quality scores',\r\n      merge_duplicates: 'Identify and merge duplicate truck entries',\r\n    };\r\n\r\n    return descriptions[type] ?? 'Unknown operation';\r\n  }\r\n\r\n  /**\r\n   * Calculate cleanup summary\r\n   */\r\n  private static calculateSummary(operations: CleanupOperation[]): BatchCleanupResult['summary'] {\r\n    return {\r\n      trucksImproved: operations.reduce((sum, op) => sum + op.successCount, 0),\r\n      duplicatesRemoved: operations.find((op) => op.type === 'merge_duplicates')?.successCount ?? 0,\r\n      qualityScoreImprovement:\r\n        operations.find((op) => op.type === 'update_quality_scores')?.successCount ?? 0,\r\n      placeholdersRemoved:\r\n        operations.find((op) => op.type === 'remove_placeholders')?.successCount ?? 0,\r\n    };\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\data-quality\\duplicatePrevention.js","messages":[{"ruleId":"unicorn/no-static-only-class","severity":2,"message":"Use an object instead of a class with only static members.","line":27,"column":8,"nodeType":"ClassDeclaration","messageId":"no-static-only-class","endLine":27,"endColumn":40,"fix":{"range":[1005,17109],"text":"const DuplicatePreventionService = {\n    /**\n     * Check if a food truck is a duplicate of existing trucks\n     */\n    async checkForDuplicates(candidateTruck) {\n        try {\n            // Get all existing trucks for comparison\n            const existingTrucksResult = await FoodTruckService.getAllTrucks();\n            if ('error' in existingTrucksResult) {\n                console.error('Error fetching existing trucks:', existingTrucksResult.error);\n                return {\n                    isDuplicate: false,\n                    matches: [],\n                    action: 'create',\n                    reason: `Error fetching existing trucks: ${existingTrucksResult.error}`,\n                };\n            }\n            const existingTrucks = existingTrucksResult.trucks;\n            const matches = [];\n            for (const existingTruck of existingTrucks) {\n                console.log(`Checking existing truck with ID: ${existingTruck.id}`);\n                const similarity = this.calculateSimilarity(candidateTruck, existingTruck);\n                if (similarity.overall >= DUPLICATE_DETECTION_CONFIG.thresholds.overall) {\n                    matches.push({\n                        existingTruck,\n                        similarity: similarity.overall,\n                        matchedFields: similarity.matchedFields,\n                        confidence: this.getConfidenceLevel(similarity.overall),\n                        recommendation: this.getRecommendation(similarity),\n                    });\n                }\n            }\n            return this.processDuplicateMatches(matches, candidateTruck);\n        }\n        catch (error) {\n            console.error('Error checking for duplicates:', error);\n            return {\n                isDuplicate: false,\n                matches: [],\n                action: 'create',\n                reason: 'An unexpected error occurred during duplicate detection - proceeding with creation',\n            };\n        }\n    },\n    /**\n     * Processes the matches found during duplicate detection and returns the result.\n     */\n    processDuplicateMatches(matches, candidateTruck) {\n        // Sort matches by similarity (highest first)\n        matches.sort((a, b) => b.similarity - a.similarity);\n        const bestMatch = matches.length > 0 ? matches[0] : undefined;\n        const isDuplicate = matches.length > 0;\n        return {\n            isDuplicate,\n            matches,\n            bestMatch,\n            action: this.determineAction(matches, candidateTruck),\n            reason: this.generateReason(matches, candidateTruck),\n        };\n    },\n    /**\n     * Calculate similarity between two food trucks\n     */\n    calculateSimilarity(candidate, existing) {\n        const breakdown = {};\n        const matchedFields = [];\n        // Name similarity\n        const nameSimilarity = this.calculateStringSimilarity(candidate.name ?? '', existing.name ?? '');\n        breakdown.name = nameSimilarity;\n        if (nameSimilarity >= DUPLICATE_DETECTION_CONFIG.thresholds.name) {\n            matchedFields.push('name');\n        }\n        // Location similarity\n        const locationSimilarity = this.calculateLocationSimilarity(candidate.current_location, existing.current_location);\n        breakdown.location = locationSimilarity;\n        if (locationSimilarity >= DUPLICATE_DETECTION_CONFIG.thresholds.location) {\n            matchedFields.push('location');\n        }\n        // Contact similarity\n        const contactSimilarity = this.calculateContactSimilarity(candidate.contact_info, existing.contact_info);\n        breakdown.contact = contactSimilarity;\n        if (contactSimilarity >= DUPLICATE_DETECTION_CONFIG.thresholds.phone) {\n            matchedFields.push('contact');\n        }\n        // Menu similarity (basic)\n        const menuSimilarity = this.calculateMenuSimilarity(candidate.menu, existing.menu);\n        breakdown.menu = menuSimilarity;\n        if (menuSimilarity > 0.7) {\n            matchedFields.push('menu');\n        }\n        // Calculate weighted overall similarity\n        const overall = nameSimilarity * DUPLICATE_DETECTION_CONFIG.weights.name +\n            locationSimilarity * DUPLICATE_DETECTION_CONFIG.weights.location +\n            contactSimilarity * DUPLICATE_DETECTION_CONFIG.weights.contact +\n            menuSimilarity * DUPLICATE_DETECTION_CONFIG.weights.menu;\n        return { overall, matchedFields, breakdown };\n    },\n    /**\n     * Normalize food truck names for better comparison\n     * Removes common suffixes, normalizes case, handles punctuation variations\n     */\n    normalizeFoodTruckName(name) {\n        if (!name)\n            return '';\n        \n        return name\n            .toLowerCase()\n            .trim()\n            // Normalize apostrophes (handle different Unicode apostrophes)\n            .replace(/[\\u2018\\u2019\\u0060\\u00B4]/g, \"'\")\n            // Remove common food truck suffixes/prefixes\n            .replace(/\\s*\\b(food\\s+truck|food\\s+trailer|mobile\\s+kitchen|street\\s+food|food\\s+cart)\\b\\s*/gi, '')\n            // Remove extra whitespace and normalize punctuation\n            .replace(/\\s+/g, ' ')\n            .replace(/[^\\w\\s&'-]/g, '')\n            .trim();\n    },\n\n    /**\n     * Calculate string similarity using Levenshtein distance with enhanced food truck name handling\n     */\n    calculateStringSimilarity(str1, str2) {\n        if (!str1 || !str2)\n            return 0;\n        \n        // Normalize food truck names for better comparison\n        const normalized1 = this.normalizeFoodTruckName(str1);\n        const normalized2 = this.normalizeFoodTruckName(str2);\n        \n        if (normalized1 === normalized2)\n            return 1;\n            \n        // Also check if one is a substring of the other (for cases like \"Page's Okra Grill\" vs \"Page's Okra Grill Food Truck\")\n        const isSubstring = normalized1.includes(normalized2) || normalized2.includes(normalized1);\n        if (isSubstring && (normalized1.length > 0 && normalized2.length > 0)) {\n            const minLength = Math.min(normalized1.length, normalized2.length);\n            const maxLength = Math.max(normalized1.length, normalized2.length);\n            // High similarity for substring matches (0.8 to 0.95 based on length ratio)\n            return 0.8 + (0.15 * (minLength / maxLength));\n        }\n        \n        // Calculate Levenshtein distance on normalized strings\n        const matrix = [];\n        const len1 = normalized1.length;\n        const len2 = normalized2.length;\n        for (let i = 0; i <= len1; i += 1) {\n            matrix[i] = [i];\n        }\n        for (let j = 0; j <= len2; j += 1) {\n            matrix[0][j] = j;\n        }\n        for (let i = 1; i <= len1; i += 1) {\n            // eslint-disable-next-line sonarjs/no-redundant-assignments\n            for (let j = 1; j <= len2; j += 1) {\n                const cost = normalized1[i - 1] === normalized2[j - 1] ? 0 : 1;\n                matrix[i][j] = Math.min(matrix[i - 1][j] + 1, // deletion\n                matrix[i][j - 1] + 1, // insertion\n                matrix[i - 1][j - 1] + cost);\n            }\n        }\n        const distance = matrix[len1][len2];\n        const maxLength = Math.max(len1, len2);\n        return maxLength === 0 ? 1 : 1 - distance / maxLength;\n    },\n    /**\n     * Calculate location similarity\n     */\n    calculateLocationSimilarity(loc1, loc2) {\n        if (!loc1 || !loc2)\n            return 0;\n        let similarity = 0;\n        let factors = 0;\n        // Address similarity\n        if (loc1.address && loc2.address) {\n            similarity += this.calculateStringSimilarity(loc1.address, loc2.address);\n            factors += 1;\n        }\n        // GPS coordinate similarity (within 100 meters = high similarity)\n        if (loc1.lat && loc1.lng && loc2.lat && loc2.lng) {\n            const distance = this.calculateGPSDistance(loc1.lat, loc1.lng, loc2.lat, loc2.lng);\n            // Distance similarity (closer = higher similarity)\n            const distanceSimilarity = distance <= 0.1 ? 1 : Math.max(0, 1 - distance / 1); // 1km max\n            similarity += distanceSimilarity;\n            factors += 1;\n        }\n        return factors > 0 ? similarity / factors : 0;\n    },\n    /**\n     * Calculate GPS distance in kilometers\n     */\n    calculateGPSDistance(lat1, lng1, lat2, lng2) {\n        const R = 6371; // Earth's radius in kilometers\n        const dLat = ((lat2 - lat1) * Math.PI) / 180;\n        const dLng = ((lng2 - lng1) * Math.PI) / 180;\n        const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +\n            Math.cos((lat1 * Math.PI) / 180) *\n                Math.cos((lat2 * Math.PI) / 180) *\n                Math.sin(dLng / 2) *\n                Math.sin(dLng / 2);\n        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n        return R * c;\n    },\n    /**\n     * Calculate contact similarity\n     */\n    calculateContactSimilarity(contact1, contact2) {\n        if (!contact1 || !contact2)\n            return 0;\n        let matches = 0;\n        let total = 0;\n        // Phone number exact match\n        if (contact1.phone != undefined && contact2.phone != undefined) {\n            const phone1 = contact1.phone.replaceAll(/\\D/g, ''); // Remove non-digits\n            const phone2 = contact2.phone.replaceAll(/\\D/g, '');\n            if (phone1 === phone2)\n                matches += 1;\n            total += 1;\n        }\n        // Website exact match\n        if (contact1.website != undefined && contact2.website != undefined) {\n            const url1 = contact1.website\n                .toLowerCase()\n                .replace(/^https?:\\/\\//, '')\n                .replace(/\\/$/, '');\n            const url2 = contact2.website\n                .toLowerCase()\n                .replace(/^https?:\\/\\//, '')\n                .replace(/\\/$/, '');\n            if (url1 === url2)\n                matches += 1;\n            total += 1;\n        }\n        // Email similarity\n        if (contact1.email != undefined && contact2.email != undefined) {\n            if (contact1.email.toLowerCase() === contact2.email.toLowerCase())\n                matches += 1;\n            total += 1;\n        }\n        return total > 0 ? matches / total : 0;\n    },\n    /**\n     * Calculate menu similarity (basic implementation)\n     */\n    calculateMenuSimilarity(menu1, menu2) {\n        if (!menu1 || !menu2 || menu1.length === 0 || menu2.length === 0)\n            return 0;\n        // Simple category name matching\n        const categories1 = menu1\n            .map((cat) => cat.category?.toLowerCase() ?? '')\n            .filter(Boolean);\n        const categories2 = menu2\n            .map((cat) => cat.category?.toLowerCase() ?? '')\n            .filter(Boolean);\n        const commonCategories = categories1.filter((cat) => categories2.includes(cat));\n        const totalCategories = new Set([...categories1, ...categories2]).size;\n        return totalCategories > 0 ? commonCategories.length / totalCategories : 0;\n    },\n    /**\n     * Get confidence level based on similarity score\n     */\n    getConfidenceLevel(similarity) {\n        if (similarity >= 0.95)\n            return 'high';\n        if (similarity >= 0.85)\n            return 'medium';\n        return 'low';\n    },\n    /**\n     * Get recommendation based on similarity analysis\n     */\n    getRecommendation(similarity) {\n        if (similarity.overall >= 0.95)\n            return 'merge';\n        if (similarity.overall >= 0.9)\n            return 'update';\n        if (similarity.overall >= 0.8)\n            return 'manual_review';\n        return 'skip';\n    },\n    /**\n     * Determine action based on matches\n     */\n    determineAction(matches, _candidate) {\n        if (matches.length === 0)\n            return 'create';\n        const bestMatch = matches[0];\n        if (bestMatch.confidence === 'high') {\n            const { recommendation } = bestMatch;\n            if (recommendation === 'merge' || recommendation === 'update') {\n                return recommendation;\n            }\n            return 'manual_review';\n        }\n        return 'manual_review';\n    },\n    /**\n     * Generate human-readable reason\n     */\n    generateReason(matches, _candidate) {\n        if (matches.length === 0) {\n            return 'No duplicates found - safe to create new truck entry';\n        }\n        const bestMatch = matches[0];\n        const similarity = Math.round(bestMatch.similarity * 100);\n        return `Found ${matches.length} potential duplicate(s). Best match: ${similarity}% similarity with \"${bestMatch.existingTruck.name}\" (matched: ${bestMatch.matchedFields.join(', ')})`;\n    },\n    async isDuplicateUrl(url) {\n        if (!url) {\n            return { isDuplicate: false, reason: 'URL is empty' };\n        }\n\n        try {\n            const { trucks, error } = await FoodTruckService.getAllTrucks();\n            if (error) {\n                console.error('Error fetching existing trucks for URL check:', error);\n                // Fail open - if we can't check, assume it's not a duplicate to allow processing\n                return { isDuplicate: false, reason: 'Could not verify existing trucks.' };\n            }\n\n            for (const truck of trucks) {\n                if (truck.source_urls && truck.source_urls.includes(url)) {\n                    return {\n                        isDuplicate: true,\n                        reason: `URL already exists for truck: ${truck.name} (ID: ${truck.id})`,\n                    };\n                }\n            }\n\n            return { isDuplicate: false, reason: 'URL not found in any existing truck.' };\n        } catch (error) {\n            console.error('Error checking for duplicate URL:', error);\n            return { isDuplicate: false, reason: 'An unexpected error occurred during URL duplicate check.' };\n        }\n    },\n\n    /**\n     * Merge duplicate truck data intelligently\n     */\n    async mergeDuplicates(targetId, sourceId) {\n        const targetResult = await FoodTruckService.getTruckById(targetId);\n        const sourceResult = await FoodTruckService.getTruckById(sourceId);\n        if ('error' in targetResult) {\n            return {\n                error: `Failed to retrieve target truck with ID ${targetId}: ${targetResult.error}`,\n            };\n        }\n        if ('error' in sourceResult) {\n            return {\n                error: `Failed to retrieve source truck with ID ${sourceId}: ${sourceResult.error}`,\n            };\n        }\n        const target = targetResult;\n        const source = sourceResult;\n        // Merge logic: prefer non-null, more complete data\n        const mergedData = {\n            name: target.name ?? source.name,\n            description: target.description ?? source.description,\n            cuisine_type: (target.cuisine_type?.length ?? 0) > 0 ? target.cuisine_type : source.cuisine_type,\n            price_range: target.price_range ?? source.price_range,\n            current_location: target.current_location ?? source.current_location,\n            contact_info: {\n                ...source.contact_info,\n                ...target.contact_info, // Target takes precedence\n            },\n            operating_hours: target.operating_hours ?? source.operating_hours,\n            menu: (target.menu?.length ?? 0) > 0 ? target.menu : source.menu,\n            social_media: {\n                ...source.social_media,\n                ...target.social_media,\n            },\n            source_urls: [...new Set([...(target.source_urls ?? []), ...(source.source_urls ?? [])])],\n            last_scraped_at: new Date().toISOString(),\n        };\n        // Update target with merged data\n        const updatedTruckResult = await FoodTruckService.updateTruck(targetId, mergedData);\n        if ('error' in updatedTruckResult) {\n            return {\n                error: `Failed to update target truck with merged data: ${updatedTruckResult.error}`,\n            };\n        }\n        console.info(`Merged truck ${sourceId} into ${targetId}`);\n        return updatedTruckResult;\n    },\n};"}},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error, info.","line":47,"column":17,"nodeType":"MemberExpression","messageId":"limited","endLine":47,"endColumn":28,"suggestions":[{"fix":{"range":[1898,1966],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"unicorn/prefer-string-replace-all","severity":2,"message":"Prefer `String#replaceAll()` over `String#replace()`.","line":136,"column":14,"nodeType":"Identifier","messageId":"method","endLine":136,"endColumn":21,"fix":{"range":[5861,5861],"text":"All"}},{"ruleId":"unicorn/prefer-string-replace-all","severity":2,"message":"Prefer `String#replaceAll()` over `String#replace()`.","line":138,"column":14,"nodeType":"Identifier","messageId":"method","endLine":138,"endColumn":21,"fix":{"range":[5976,5976],"text":"All"}},{"ruleId":"sonarjs/slow-regex","severity":2,"message":"Make sure the regex used here, which is vulnerable to super-linear runtime due to backtracking, cannot lead to denial of service.","line":138,"column":22,"nodeType":"Literal","endLine":138,"endColumn":108},{"ruleId":"unicorn/prefer-string-replace-all","severity":2,"message":"Prefer `String#replaceAll()` over `String#replace()`.","line":140,"column":14,"nodeType":"Identifier","messageId":"method","endLine":140,"endColumn":21,"fix":{"range":[6154,6154],"text":"All"}},{"ruleId":"unicorn/prefer-string-replace-all","severity":2,"message":"Prefer `String#replaceAll()` over `String#replace()`.","line":141,"column":14,"nodeType":"Identifier","messageId":"method","endLine":141,"endColumn":21,"fix":{"range":[6188,6188],"text":"All"}}],"suppressedMessages":[{"ruleId":"sonarjs/no-redundant-assignments","severity":2,"message":"Review this redundant assignment: \"j\" already holds the assigned value along all execution paths.","line":180,"column":26,"nodeType":"Literal","messageId":"reviewAssignment","endLine":180,"endColumn":27,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":6,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":5,"fixableWarningCount":0,"source":"/**\n * SOTA Duplicate Prevention System\n * Implements intelligent duplicate detection and prevention for food truck data\n */\nimport { FoodTruckService } from '../supabase/services/foodTruckService.js';\n// Duplicate detection configuration\nexport const DUPLICATE_DETECTION_CONFIG = {\n    // Similarity thresholds (0.0 = no match, 1.0 = exact match)\n    thresholds: {\n        name: 0.85, // High threshold for name matching\n        location: 0.9, // Very high threshold for location matching\n        phone: 1, // Exact match for phone numbers\n        website: 1, // Exact match for websites\n        overall: 0.8, // Overall similarity threshold\n    },\n    // Weight factors for different fields\n    weights: {\n        name: 0.4, // 40% weight for name similarity\n        location: 0.3, // 30% weight for location similarity\n        contact: 0.2, // 20% weight for contact info similarity\n        menu: 0.1, // 10% weight for menu similarity\n    },\n};\n/**\n * Advanced Duplicate Prevention Service\n */\nexport class DuplicatePreventionService {\n    /**\n     * Check if a food truck is a duplicate of existing trucks\n     */\n    static async checkForDuplicates(candidateTruck) {\n        try {\n            // Get all existing trucks for comparison\n            const existingTrucksResult = await FoodTruckService.getAllTrucks();\n            if ('error' in existingTrucksResult) {\n                console.error('Error fetching existing trucks:', existingTrucksResult.error);\n                return {\n                    isDuplicate: false,\n                    matches: [],\n                    action: 'create',\n                    reason: `Error fetching existing trucks: ${existingTrucksResult.error}`,\n                };\n            }\n            const existingTrucks = existingTrucksResult.trucks;\n            const matches = [];\n            for (const existingTruck of existingTrucks) {\n                console.log(`Checking existing truck with ID: ${existingTruck.id}`);\n                const similarity = this.calculateSimilarity(candidateTruck, existingTruck);\n                if (similarity.overall >= DUPLICATE_DETECTION_CONFIG.thresholds.overall) {\n                    matches.push({\n                        existingTruck,\n                        similarity: similarity.overall,\n                        matchedFields: similarity.matchedFields,\n                        confidence: this.getConfidenceLevel(similarity.overall),\n                        recommendation: this.getRecommendation(similarity),\n                    });\n                }\n            }\n            return this.processDuplicateMatches(matches, candidateTruck);\n        }\n        catch (error) {\n            console.error('Error checking for duplicates:', error);\n            return {\n                isDuplicate: false,\n                matches: [],\n                action: 'create',\n                reason: 'An unexpected error occurred during duplicate detection - proceeding with creation',\n            };\n        }\n    }\n    /**\n     * Processes the matches found during duplicate detection and returns the result.\n     */\n    static processDuplicateMatches(matches, candidateTruck) {\n        // Sort matches by similarity (highest first)\n        matches.sort((a, b) => b.similarity - a.similarity);\n        const bestMatch = matches.length > 0 ? matches[0] : undefined;\n        const isDuplicate = matches.length > 0;\n        return {\n            isDuplicate,\n            matches,\n            bestMatch,\n            action: this.determineAction(matches, candidateTruck),\n            reason: this.generateReason(matches, candidateTruck),\n        };\n    }\n    /**\n     * Calculate similarity between two food trucks\n     */\n    static calculateSimilarity(candidate, existing) {\n        const breakdown = {};\n        const matchedFields = [];\n        // Name similarity\n        const nameSimilarity = this.calculateStringSimilarity(candidate.name ?? '', existing.name ?? '');\n        breakdown.name = nameSimilarity;\n        if (nameSimilarity >= DUPLICATE_DETECTION_CONFIG.thresholds.name) {\n            matchedFields.push('name');\n        }\n        // Location similarity\n        const locationSimilarity = this.calculateLocationSimilarity(candidate.current_location, existing.current_location);\n        breakdown.location = locationSimilarity;\n        if (locationSimilarity >= DUPLICATE_DETECTION_CONFIG.thresholds.location) {\n            matchedFields.push('location');\n        }\n        // Contact similarity\n        const contactSimilarity = this.calculateContactSimilarity(candidate.contact_info, existing.contact_info);\n        breakdown.contact = contactSimilarity;\n        if (contactSimilarity >= DUPLICATE_DETECTION_CONFIG.thresholds.phone) {\n            matchedFields.push('contact');\n        }\n        // Menu similarity (basic)\n        const menuSimilarity = this.calculateMenuSimilarity(candidate.menu, existing.menu);\n        breakdown.menu = menuSimilarity;\n        if (menuSimilarity > 0.7) {\n            matchedFields.push('menu');\n        }\n        // Calculate weighted overall similarity\n        const overall = nameSimilarity * DUPLICATE_DETECTION_CONFIG.weights.name +\n            locationSimilarity * DUPLICATE_DETECTION_CONFIG.weights.location +\n            contactSimilarity * DUPLICATE_DETECTION_CONFIG.weights.contact +\n            menuSimilarity * DUPLICATE_DETECTION_CONFIG.weights.menu;\n        return { overall, matchedFields, breakdown };\n    }\n    /**\n     * Normalize food truck names for better comparison\n     * Removes common suffixes, normalizes case, handles punctuation variations\n     */\n    static normalizeFoodTruckName(name) {\n        if (!name)\n            return '';\n        \n        return name\n            .toLowerCase()\n            .trim()\n            // Normalize apostrophes (handle different Unicode apostrophes)\n            .replace(/[\\u2018\\u2019\\u0060\\u00B4]/g, \"'\")\n            // Remove common food truck suffixes/prefixes\n            .replace(/\\s*\\b(food\\s+truck|food\\s+trailer|mobile\\s+kitchen|street\\s+food|food\\s+cart)\\b\\s*/gi, '')\n            // Remove extra whitespace and normalize punctuation\n            .replace(/\\s+/g, ' ')\n            .replace(/[^\\w\\s&'-]/g, '')\n            .trim();\n    }\n\n    /**\n     * Calculate string similarity using Levenshtein distance with enhanced food truck name handling\n     */\n    static calculateStringSimilarity(str1, str2) {\n        if (!str1 || !str2)\n            return 0;\n        \n        // Normalize food truck names for better comparison\n        const normalized1 = this.normalizeFoodTruckName(str1);\n        const normalized2 = this.normalizeFoodTruckName(str2);\n        \n        if (normalized1 === normalized2)\n            return 1;\n            \n        // Also check if one is a substring of the other (for cases like \"Page's Okra Grill\" vs \"Page's Okra Grill Food Truck\")\n        const isSubstring = normalized1.includes(normalized2) || normalized2.includes(normalized1);\n        if (isSubstring && (normalized1.length > 0 && normalized2.length > 0)) {\n            const minLength = Math.min(normalized1.length, normalized2.length);\n            const maxLength = Math.max(normalized1.length, normalized2.length);\n            // High similarity for substring matches (0.8 to 0.95 based on length ratio)\n            return 0.8 + (0.15 * (minLength / maxLength));\n        }\n        \n        // Calculate Levenshtein distance on normalized strings\n        const matrix = [];\n        const len1 = normalized1.length;\n        const len2 = normalized2.length;\n        for (let i = 0; i <= len1; i += 1) {\n            matrix[i] = [i];\n        }\n        for (let j = 0; j <= len2; j += 1) {\n            matrix[0][j] = j;\n        }\n        for (let i = 1; i <= len1; i += 1) {\n            // eslint-disable-next-line sonarjs/no-redundant-assignments\n            for (let j = 1; j <= len2; j += 1) {\n                const cost = normalized1[i - 1] === normalized2[j - 1] ? 0 : 1;\n                matrix[i][j] = Math.min(matrix[i - 1][j] + 1, // deletion\n                matrix[i][j - 1] + 1, // insertion\n                matrix[i - 1][j - 1] + cost);\n            }\n        }\n        const distance = matrix[len1][len2];\n        const maxLength = Math.max(len1, len2);\n        return maxLength === 0 ? 1 : 1 - distance / maxLength;\n    }\n    /**\n     * Calculate location similarity\n     */\n    static calculateLocationSimilarity(loc1, loc2) {\n        if (!loc1 || !loc2)\n            return 0;\n        let similarity = 0;\n        let factors = 0;\n        // Address similarity\n        if (loc1.address && loc2.address) {\n            similarity += this.calculateStringSimilarity(loc1.address, loc2.address);\n            factors += 1;\n        }\n        // GPS coordinate similarity (within 100 meters = high similarity)\n        if (loc1.lat && loc1.lng && loc2.lat && loc2.lng) {\n            const distance = this.calculateGPSDistance(loc1.lat, loc1.lng, loc2.lat, loc2.lng);\n            // Distance similarity (closer = higher similarity)\n            const distanceSimilarity = distance <= 0.1 ? 1 : Math.max(0, 1 - distance / 1); // 1km max\n            similarity += distanceSimilarity;\n            factors += 1;\n        }\n        return factors > 0 ? similarity / factors : 0;\n    }\n    /**\n     * Calculate GPS distance in kilometers\n     */\n    static calculateGPSDistance(lat1, lng1, lat2, lng2) {\n        const R = 6371; // Earth's radius in kilometers\n        const dLat = ((lat2 - lat1) * Math.PI) / 180;\n        const dLng = ((lng2 - lng1) * Math.PI) / 180;\n        const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +\n            Math.cos((lat1 * Math.PI) / 180) *\n                Math.cos((lat2 * Math.PI) / 180) *\n                Math.sin(dLng / 2) *\n                Math.sin(dLng / 2);\n        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n        return R * c;\n    }\n    /**\n     * Calculate contact similarity\n     */\n    static calculateContactSimilarity(contact1, contact2) {\n        if (!contact1 || !contact2)\n            return 0;\n        let matches = 0;\n        let total = 0;\n        // Phone number exact match\n        if (contact1.phone != undefined && contact2.phone != undefined) {\n            const phone1 = contact1.phone.replaceAll(/\\D/g, ''); // Remove non-digits\n            const phone2 = contact2.phone.replaceAll(/\\D/g, '');\n            if (phone1 === phone2)\n                matches += 1;\n            total += 1;\n        }\n        // Website exact match\n        if (contact1.website != undefined && contact2.website != undefined) {\n            const url1 = contact1.website\n                .toLowerCase()\n                .replace(/^https?:\\/\\//, '')\n                .replace(/\\/$/, '');\n            const url2 = contact2.website\n                .toLowerCase()\n                .replace(/^https?:\\/\\//, '')\n                .replace(/\\/$/, '');\n            if (url1 === url2)\n                matches += 1;\n            total += 1;\n        }\n        // Email similarity\n        if (contact1.email != undefined && contact2.email != undefined) {\n            if (contact1.email.toLowerCase() === contact2.email.toLowerCase())\n                matches += 1;\n            total += 1;\n        }\n        return total > 0 ? matches / total : 0;\n    }\n    /**\n     * Calculate menu similarity (basic implementation)\n     */\n    static calculateMenuSimilarity(menu1, menu2) {\n        if (!menu1 || !menu2 || menu1.length === 0 || menu2.length === 0)\n            return 0;\n        // Simple category name matching\n        const categories1 = menu1\n            .map((cat) => cat.category?.toLowerCase() ?? '')\n            .filter(Boolean);\n        const categories2 = menu2\n            .map((cat) => cat.category?.toLowerCase() ?? '')\n            .filter(Boolean);\n        const commonCategories = categories1.filter((cat) => categories2.includes(cat));\n        const totalCategories = new Set([...categories1, ...categories2]).size;\n        return totalCategories > 0 ? commonCategories.length / totalCategories : 0;\n    }\n    /**\n     * Get confidence level based on similarity score\n     */\n    static getConfidenceLevel(similarity) {\n        if (similarity >= 0.95)\n            return 'high';\n        if (similarity >= 0.85)\n            return 'medium';\n        return 'low';\n    }\n    /**\n     * Get recommendation based on similarity analysis\n     */\n    static getRecommendation(similarity) {\n        if (similarity.overall >= 0.95)\n            return 'merge';\n        if (similarity.overall >= 0.9)\n            return 'update';\n        if (similarity.overall >= 0.8)\n            return 'manual_review';\n        return 'skip';\n    }\n    /**\n     * Determine action based on matches\n     */\n    static determineAction(matches, _candidate) {\n        if (matches.length === 0)\n            return 'create';\n        const bestMatch = matches[0];\n        if (bestMatch.confidence === 'high') {\n            const { recommendation } = bestMatch;\n            if (recommendation === 'merge' || recommendation === 'update') {\n                return recommendation;\n            }\n            return 'manual_review';\n        }\n        return 'manual_review';\n    }\n    /**\n     * Generate human-readable reason\n     */\n    static generateReason(matches, _candidate) {\n        if (matches.length === 0) {\n            return 'No duplicates found - safe to create new truck entry';\n        }\n        const bestMatch = matches[0];\n        const similarity = Math.round(bestMatch.similarity * 100);\n        return `Found ${matches.length} potential duplicate(s). Best match: ${similarity}% similarity with \"${bestMatch.existingTruck.name}\" (matched: ${bestMatch.matchedFields.join(', ')})`;\n    }\n    static async isDuplicateUrl(url) {\n        if (!url) {\n            return { isDuplicate: false, reason: 'URL is empty' };\n        }\n\n        try {\n            const { trucks, error } = await FoodTruckService.getAllTrucks();\n            if (error) {\n                console.error('Error fetching existing trucks for URL check:', error);\n                // Fail open - if we can't check, assume it's not a duplicate to allow processing\n                return { isDuplicate: false, reason: 'Could not verify existing trucks.' };\n            }\n\n            for (const truck of trucks) {\n                if (truck.source_urls && truck.source_urls.includes(url)) {\n                    return {\n                        isDuplicate: true,\n                        reason: `URL already exists for truck: ${truck.name} (ID: ${truck.id})`,\n                    };\n                }\n            }\n\n            return { isDuplicate: false, reason: 'URL not found in any existing truck.' };\n        } catch (error) {\n            console.error('Error checking for duplicate URL:', error);\n            return { isDuplicate: false, reason: 'An unexpected error occurred during URL duplicate check.' };\n        }\n    }\n\n    /**\n     * Merge duplicate truck data intelligently\n     */\n    static async mergeDuplicates(targetId, sourceId) {\n        const targetResult = await FoodTruckService.getTruckById(targetId);\n        const sourceResult = await FoodTruckService.getTruckById(sourceId);\n        if ('error' in targetResult) {\n            return {\n                error: `Failed to retrieve target truck with ID ${targetId}: ${targetResult.error}`,\n            };\n        }\n        if ('error' in sourceResult) {\n            return {\n                error: `Failed to retrieve source truck with ID ${sourceId}: ${sourceResult.error}`,\n            };\n        }\n        const target = targetResult;\n        const source = sourceResult;\n        // Merge logic: prefer non-null, more complete data\n        const mergedData = {\n            name: target.name ?? source.name,\n            description: target.description ?? source.description,\n            cuisine_type: (target.cuisine_type?.length ?? 0) > 0 ? target.cuisine_type : source.cuisine_type,\n            price_range: target.price_range ?? source.price_range,\n            current_location: target.current_location ?? source.current_location,\n            contact_info: {\n                ...source.contact_info,\n                ...target.contact_info, // Target takes precedence\n            },\n            operating_hours: target.operating_hours ?? source.operating_hours,\n            menu: (target.menu?.length ?? 0) > 0 ? target.menu : source.menu,\n            social_media: {\n                ...source.social_media,\n                ...target.social_media,\n            },\n            source_urls: [...new Set([...(target.source_urls ?? []), ...(source.source_urls ?? [])])],\n            last_scraped_at: new Date().toISOString(),\n        };\n        // Update target with merged data\n        const updatedTruckResult = await FoodTruckService.updateTruck(targetId, mergedData);\n        if ('error' in updatedTruckResult) {\n            return {\n                error: `Failed to update target truck with merged data: ${updatedTruckResult.error}`,\n            };\n        }\n        console.info(`Merged truck ${sourceId} into ${targetId}`);\n        return updatedTruckResult;\n    }\n}\n","usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\data-quality\\duplicatePrevention.ts","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error, info.","line":72,"column":9,"nodeType":"MemberExpression","messageId":"limited","endLine":72,"endColumn":20,"suggestions":[{"fix":{"range":[2310,2378],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"unicorn/prefer-string-replace-all","severity":2,"message":"Prefer `String#replaceAll()` over `String#replace()`.","line":189,"column":8,"nodeType":"Identifier","messageId":"method","endLine":189,"endColumn":15,"fix":{"range":[6290,6290],"text":"All"}},{"ruleId":"unicorn/prefer-string-replace-all","severity":2,"message":"Prefer `String#replaceAll()` over `String#replace()`.","line":191,"column":8,"nodeType":"Identifier","messageId":"method","endLine":191,"endColumn":15,"fix":{"range":[6395,6395],"text":"All"}},{"ruleId":"sonarjs/slow-regex","severity":2,"message":"Make sure the regex used here, which is vulnerable to super-linear runtime due to backtracking, cannot lead to denial of service.","line":191,"column":16,"nodeType":"Literal","endLine":191,"endColumn":102},{"ruleId":"unicorn/prefer-string-replace-all","severity":2,"message":"Prefer `String#replaceAll()` over `String#replace()`.","line":193,"column":8,"nodeType":"Identifier","messageId":"method","endLine":193,"endColumn":15,"fix":{"range":[6563,6563],"text":"All"}},{"ruleId":"unicorn/prefer-string-replace-all","severity":2,"message":"Prefer `String#replaceAll()` over `String#replace()`.","line":194,"column":8,"nodeType":"Identifier","messageId":"method","endLine":194,"endColumn":15,"fix":{"range":[6592,6592],"text":"All"}},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":263,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":263,"endColumn":21,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[8962,8974],"text":"(loc1.address != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[8962,8974],"text":"(loc1.address ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[8962,8974],"text":"(Boolean(loc1.address))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":263,"column":25,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":263,"endColumn":37,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[8978,8990],"text":"(loc2.address != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[8978,8990],"text":"(loc2.address ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[8978,8990],"text":"(Boolean(loc2.address))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]}],"suppressedMessages":[{"ruleId":"sonarjs/no-redundant-assignments","severity":2,"message":"Review this redundant assignment: \"j\" already holds the assigned value along all execution paths.","line":234,"column":20,"nodeType":"Literal","messageId":"reviewAssignment","endLine":234,"endColumn":21,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":5,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":4,"fixableWarningCount":0,"source":"/**\r\n * SOTA Duplicate Prevention System\r\n * Implements intelligent duplicate detection and prevention for food truck data\r\n */\r\n\r\nimport { FoodTruckService, type FoodTruck } from '@/lib/supabase';\r\n\r\n// Duplicate detection configuration\r\nexport const DUPLICATE_DETECTION_CONFIG = {\r\n  // Similarity thresholds (0.0 = no match, 1.0 = exact match)\r\n  thresholds: {\r\n    name: 0.85, // High threshold for name matching\r\n    location: 0.9, // Very high threshold for location matching\r\n    phone: 1, // Exact match for phone numbers\r\n    website: 1, // Exact match for websites\r\n    overall: 0.8, // Overall similarity threshold\r\n  },\r\n\r\n  // Weight factors for different fields\r\n  weights: {\r\n    name: 0.4, // 40% weight for name similarity\r\n    location: 0.3, // 30% weight for location similarity\r\n    contact: 0.2, // 20% weight for contact info similarity\r\n    menu: 0.1, // 10% weight for menu similarity\r\n  },\r\n} as const;\r\n\r\nexport interface DuplicateMatch {\r\n  existingTruck: FoodTruck;\r\n  similarity: number;\r\n  matchedFields: string[];\r\n  confidence: 'high' | 'medium' | 'low';\r\n  recommendation: 'merge' | 'update' | 'skip' | 'manual_review';\r\n}\r\n\r\nexport interface DuplicateDetectionResult {\r\n  isDuplicate: boolean;\r\n  matches: DuplicateMatch[];\r\n  bestMatch?: DuplicateMatch;\r\n  action: 'create' | 'update' | 'merge' | 'manual_review';\r\n  reason: string;\r\n}\r\n\r\n/**\r\n * Advanced Duplicate Prevention Service\r\n */\r\nexport class DuplicatePreventionService {\r\n  /**\r\n   * Check if a food truck is a duplicate of existing trucks\r\n   */\r\n  static async checkForDuplicates(\r\n    candidateTruck: Partial<FoodTruck>,\r\n  ): Promise<DuplicateDetectionResult> {\r\n    try {\r\n      // Get all existing trucks for comparison\r\n      const existingTrucksResult = await FoodTruckService.getAllTrucks();\r\n\r\n      if ('error' in existingTrucksResult) {\r\n        console.error('Error fetching existing trucks:', existingTrucksResult.error);\r\n        return {\r\n          isDuplicate: false,\r\n          matches: [],\r\n          action: 'create',\r\n          reason: `Error fetching existing trucks: ${existingTrucksResult.error}`,\r\n        };\r\n      }\r\n\r\n      const existingTrucks = existingTrucksResult.trucks;\r\n      const matches: DuplicateMatch[] = [];\r\n\r\n      for (const existingTruck of existingTrucks) {\r\n        console.log(`Checking existing truck with ID: ${existingTruck.id}`);\r\n        const similarity = this.calculateSimilarity(candidateTruck, existingTruck);\r\n\r\n        if (similarity.overall >= DUPLICATE_DETECTION_CONFIG.thresholds.overall) {\r\n          matches.push({\r\n            existingTruck,\r\n            similarity: similarity.overall,\r\n            matchedFields: similarity.matchedFields,\r\n            confidence: this.getConfidenceLevel(similarity.overall),\r\n            recommendation: this.getRecommendation(similarity),\r\n          });\r\n        }\r\n      }\r\n\r\n      return this.processDuplicateMatches(matches, candidateTruck);\r\n    } catch (error) {\r\n      console.error('Error checking for duplicates:', error);\r\n      return {\r\n        isDuplicate: false,\r\n        matches: [],\r\n        action: 'create',\r\n        reason:\r\n          'An unexpected error occurred during duplicate detection - proceeding with creation',\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Processes the matches found during duplicate detection and returns the result.\r\n   */\r\n  private static processDuplicateMatches(\r\n    matches: DuplicateMatch[],\r\n    candidateTruck: Partial<FoodTruck>,\r\n  ): DuplicateDetectionResult {\r\n    // Sort matches by similarity (highest first)\r\n    matches.sort((a, b) => b.similarity - a.similarity);\r\n\r\n    const bestMatch = matches.length > 0 ? matches[0] : undefined;\r\n    const isDuplicate = matches.length > 0;\r\n\r\n    return {\r\n      isDuplicate,\r\n      matches,\r\n      bestMatch,\r\n      action: this.determineAction(matches, candidateTruck),\r\n      reason: this.generateReason(matches, candidateTruck),\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Calculate similarity between two food trucks\r\n   */\r\n  private static calculateSimilarity(\r\n    candidate: Partial<FoodTruck>,\r\n    existing: FoodTruck,\r\n  ): { overall: number; matchedFields: string[]; breakdown: Record<string, number> } {\r\n    const breakdown: Record<string, number> = {};\r\n    const matchedFields: string[] = [];\r\n\r\n    // Name similarity\r\n    const nameSimilarity = this.calculateStringSimilarity(\r\n      candidate.name ?? '',\r\n      existing.name ?? '',\r\n    );\r\n    breakdown.name = nameSimilarity;\r\n    if (nameSimilarity >= DUPLICATE_DETECTION_CONFIG.thresholds.name) {\r\n      matchedFields.push('name');\r\n    }\r\n\r\n    // Location similarity\r\n    const locationSimilarity = this.calculateLocationSimilarity(\r\n      candidate.current_location,\r\n      existing.current_location,\r\n    );\r\n    breakdown.location = locationSimilarity;\r\n    if (locationSimilarity >= DUPLICATE_DETECTION_CONFIG.thresholds.location) {\r\n      matchedFields.push('location');\r\n    }\r\n\r\n    // Contact similarity\r\n    const contactSimilarity = this.calculateContactSimilarity(\r\n      candidate.contact_info,\r\n      existing.contact_info,\r\n    );\r\n    breakdown.contact = contactSimilarity;\r\n    if (contactSimilarity >= DUPLICATE_DETECTION_CONFIG.thresholds.phone) {\r\n      matchedFields.push('contact');\r\n    }\r\n\r\n    // Menu similarity (basic)\r\n    const menuSimilarity = this.calculateMenuSimilarity(candidate.menu, existing.menu);\r\n    breakdown.menu = menuSimilarity;\r\n    if (menuSimilarity > 0.7) {\r\n      matchedFields.push('menu');\r\n    }\r\n\r\n    // Calculate weighted overall similarity\r\n    const overall =\r\n      nameSimilarity * DUPLICATE_DETECTION_CONFIG.weights.name +\r\n      locationSimilarity * DUPLICATE_DETECTION_CONFIG.weights.location +\r\n      contactSimilarity * DUPLICATE_DETECTION_CONFIG.weights.contact +\r\n      menuSimilarity * DUPLICATE_DETECTION_CONFIG.weights.menu;\r\n\r\n    return { overall, matchedFields, breakdown };\r\n  }\r\n\r\n  /**\r\n   * Normalize food truck names for better comparison\r\n   * Removes common suffixes, normalizes case, handles punctuation variations\r\n   */\r\n  private static normalizeFoodTruckName(name: string): string {\r\n    if (!name) return '';\r\n\r\n    return name\r\n      .toLowerCase()\r\n      .trim()\r\n      // Normalize apostrophes (handle different Unicode apostrophes)\r\n      .replace(/[\\u2018\\u2019\\u0060\\u00B4]/g, \"'\")\r\n      // Remove common food truck suffixes/prefixes\r\n      .replace(/\\s*\\b(food\\s+truck|food\\s+trailer|mobile\\s+kitchen|street\\s+food|food\\s+cart)\\b\\s*/gi, '')\r\n      // Remove extra whitespace and normalize punctuation\r\n      .replace(/\\s+/g, ' ')\r\n      .replace(/[^\\w\\s&'-]/g, '')\r\n      .trim();\r\n  }\r\n\r\n  /**\r\n   * Calculate string similarity using Levenshtein distance with enhanced food truck name handling\r\n   */\r\n  private static calculateStringSimilarity(str1: string, str2: string): number {\r\n    if (!str1 || !str2) return 0;\r\n\r\n    // Normalize food truck names for better comparison\r\n    const normalized1 = this.normalizeFoodTruckName(str1);\r\n    const normalized2 = this.normalizeFoodTruckName(str2);\r\n\r\n    if (normalized1 === normalized2) return 1;\r\n\r\n    // Also check if one is a substring of the other (for cases like \"Page's Okra Grill\" vs \"Page's Okra Grill Food Truck\")\r\n    const isSubstring = normalized1.includes(normalized2) || normalized2.includes(normalized1);\r\n    if (isSubstring && (normalized1.length > 0 && normalized2.length > 0)) {\r\n      const minLength = Math.min(normalized1.length, normalized2.length);\r\n      const maxLength = Math.max(normalized1.length, normalized2.length);\r\n      // High similarity for substring matches (0.8 to 0.95 based on length ratio)\r\n      return 0.8 + (0.15 * (minLength / maxLength));\r\n    }\r\n\r\n    // Calculate Levenshtein distance on normalized strings\r\n    const matrix: number[][] = [];\r\n    const len1 = normalized1.length;\r\n    const len2 = normalized2.length;\r\n\r\n    for (let i = 0; i <= len1; i+=1) {\r\n      matrix[i] = [i];\r\n    }\r\n\r\n    for (let j = 0; j <= len2; j+=1) {\r\n      matrix[0][j] = j;\r\n    }\r\n\r\n    for (let i = 1; i <= len1; i+=1) {\r\n      // eslint-disable-next-line sonarjs/no-redundant-assignments\r\n      for (let j = 1; j <= len2; j+=1) {\r\n        const cost = normalized1[i - 1] === normalized2[j - 1] ? 0 : 1;\r\n        matrix[i][j] = Math.min(\r\n          matrix[i - 1][j] + 1, // deletion\r\n          matrix[i][j - 1] + 1, // insertion\r\n          matrix[i - 1][j - 1] + cost, // substitution\r\n        );\r\n      }\r\n    }\r\n\r\n    const distance = matrix[len1][len2];\r\n    const maxLength = Math.max(len1, len2);\r\n\r\n    return maxLength === 0 ? 1 : 1 - distance / maxLength;\r\n  }\r\n\r\n  /**\r\n   * Calculate location similarity\r\n   */\r\n  private static calculateLocationSimilarity(\r\n    loc1: FoodTruck['current_location'] | undefined | null,\r\n    loc2: FoodTruck['current_location'] | undefined | null,\r\n  ): number {\r\n    if (!loc1 || !loc2) return 0;\r\n\r\n    let similarity = 0;\r\n    let factors = 0;\r\n\r\n    // Address similarity\r\n    if (loc1.address && loc2.address) {\r\n      similarity += this.calculateStringSimilarity(loc1.address, loc2.address);\r\n      factors+=1;\r\n    }\r\n\r\n    // GPS coordinate similarity (within 100 meters = high similarity)\r\n    if (loc1.lat && loc1.lng && loc2.lat && loc2.lng) {\r\n      const distance = this.calculateGPSDistance(loc1.lat, loc1.lng, loc2.lat, loc2.lng);\r\n\r\n      // Distance similarity (closer = higher similarity)\r\n      const distanceSimilarity = distance <= 0.1 ? 1 : Math.max(0, 1 - distance / 1); // 1km max\r\n      similarity += distanceSimilarity;\r\n      factors+=1;\r\n    }\r\n\r\n    return factors > 0 ? similarity / factors : 0;\r\n  }\r\n\r\n  /**\r\n   * Calculate GPS distance in kilometers\r\n   */\r\n  private static calculateGPSDistance(\r\n    lat1: number,\r\n    lng1: number,\r\n    lat2: number,\r\n    lng2: number,\r\n  ): number {\r\n    const R = 6371; // Earth's radius in kilometers\r\n    const dLat = ((lat2 - lat1) * Math.PI) / 180;\r\n    const dLng = ((lng2 - lng1) * Math.PI) / 180;\r\n    const a =\r\n      Math.sin(dLat / 2) * Math.sin(dLat / 2) +\r\n      Math.cos((lat1 * Math.PI) / 180) *\r\n        Math.cos((lat2 * Math.PI) / 180) *\r\n        Math.sin(dLng / 2) *\r\n        Math.sin(dLng / 2);\r\n    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\r\n    return R * c;\r\n  }\r\n\r\n  /**\r\n   * Calculate contact similarity\r\n   */\r\n  private static calculateContactSimilarity(\r\n    contact1: FoodTruck['contact_info'] | undefined | null,\r\n    contact2: FoodTruck['contact_info'] | undefined | null,\r\n  ): number {\r\n    if (!contact1 || !contact2) return 0;\r\n\r\n    let matches = 0;\r\n    let total = 0;\r\n\r\n    // Phone number exact match\r\n    if (contact1.phone != undefined && contact2.phone != undefined) {\r\n      const phone1 = contact1.phone.replaceAll(/\\D/g, ''); // Remove non-digits\r\n      const phone2 = contact2.phone.replaceAll(/\\D/g, '');\r\n      if (phone1 === phone2) matches+=1;\r\n      total+=1;\r\n    }\r\n\r\n    // Website exact match\r\n    if (contact1.website != undefined && contact2.website != undefined) {\r\n      const url1 = contact1.website\r\n        .toLowerCase()\r\n        .replace(/^https?:\\/\\//, '')\r\n        .replace(/\\/$/, '');\r\n      const url2 = contact2.website\r\n        .toLowerCase()\r\n        .replace(/^https?:\\/\\//, '')\r\n        .replace(/\\/$/, '');\r\n      if (url1 === url2) matches+=1;\r\n      total+=1;\r\n    }\r\n\r\n    // Email similarity\r\n    if (contact1.email != undefined && contact2.email != undefined) {\r\n      if (contact1.email.toLowerCase() === contact2.email.toLowerCase()) matches+=1;\r\n      total+=1;\r\n    }\r\n\r\n    return total > 0 ? matches / total : 0;\r\n  }\r\n\r\n  /**\r\n   * Calculate menu similarity (basic implementation)\r\n   */\r\n  private static calculateMenuSimilarity(\r\n    menu1: FoodTruck['menu'] | undefined | null,\r\n    menu2: FoodTruck['menu'] | undefined | null,\r\n  ): number {\r\n    if (!menu1 || !menu2 || menu1.length === 0 || menu2.length === 0) return 0;\r\n\r\n    // Simple category name matching\r\n    const categories1 = menu1\r\n      .map((cat) => (cat as { category?: string }).category?.toLowerCase() ?? '')\r\n      .filter(Boolean);\r\n    const categories2 = menu2\r\n      .map((cat) => (cat as { category?: string }).category?.toLowerCase() ?? '')\r\n      .filter(Boolean);\r\n\r\n    const commonCategories = categories1.filter((cat) => categories2.includes(cat));\r\n    const totalCategories = new Set([...categories1, ...categories2]).size;\r\n\r\n    return totalCategories > 0 ? commonCategories.length / totalCategories : 0;\r\n  }\r\n\r\n  /**\r\n   * Get confidence level based on similarity score\r\n   */\r\n  private static getConfidenceLevel(similarity: number): 'high' | 'medium' | 'low' {\r\n    if (similarity >= 0.95) return 'high';\r\n    if (similarity >= 0.85) return 'medium';\r\n    return 'low';\r\n  }\r\n\r\n  /**\r\n   * Get recommendation based on similarity analysis\r\n   */\r\n  private static getRecommendation(similarity: {\r\n    overall: number;\r\n    matchedFields: string[];\r\n  }): 'merge' | 'update' | 'skip' | 'manual_review' {\r\n    if (similarity.overall >= 0.95) return 'merge';\r\n    if (similarity.overall >= 0.9) return 'update';\r\n    if (similarity.overall >= 0.8) return 'manual_review';\r\n    return 'skip';\r\n  }\r\n\r\n  /**\r\n   * Determine action based on matches\r\n   */\r\n  private static determineAction(\r\n    matches: DuplicateMatch[],\r\n    _candidate: Partial<FoodTruck>,\r\n  ): 'create' | 'update' | 'merge' | 'manual_review' {\r\n    if (matches.length === 0) return 'create';\r\n\r\n    const bestMatch = matches[0];\r\n\r\n    if (bestMatch.confidence === 'high') {\r\n      const {recommendation} = bestMatch;\r\n      if (recommendation === 'merge' || recommendation === 'update') {\r\n        return recommendation;\r\n      }\r\n      return 'manual_review';\r\n    }\r\n\r\n    return 'manual_review';\r\n  }\r\n\r\n  /**\r\n   * Generate human-readable reason\r\n   */\r\n  private static generateReason(matches: DuplicateMatch[], _candidate: Partial<FoodTruck>): string {\r\n    if (matches.length === 0) {\r\n      return 'No duplicates found - safe to create new truck entry';\r\n    }\r\n\r\n    const bestMatch = matches[0];\r\n    const similarity = Math.round(bestMatch.similarity * 100);\r\n\r\n    return `Found ${matches.length} potential duplicate(s). Best match: ${similarity}% similarity with \"${bestMatch.existingTruck.name}\" (matched: ${bestMatch.matchedFields.join(', ')})`;\r\n  }\r\n\r\n  /**\r\n   * Merge duplicate truck data intelligently\r\n   */\r\n  static async mergeDuplicates(\r\n    targetId: string,\r\n    sourceId: string,\r\n  ): Promise<FoodTruck | { error: string }> {\r\n    const targetResult = await FoodTruckService.getTruckById(targetId);\r\n    const sourceResult = await FoodTruckService.getTruckById(sourceId);\r\n\r\n    if ('error' in targetResult) {\r\n      return {\r\n        error: `Failed to retrieve target truck with ID ${targetId}: ${targetResult.error}`,\r\n      };\r\n    }\r\n    if ('error' in sourceResult) {\r\n      return {\r\n        error: `Failed to retrieve source truck with ID ${sourceId}: ${sourceResult.error}`,\r\n      };\r\n    }\r\n\r\n    const target = targetResult;\r\n    const source = sourceResult;\r\n\r\n    // Merge logic: prefer non-null, more complete data\r\n    const mergedData: Partial<FoodTruck> = {\r\n      name: target.name ?? source.name,\r\n      description: target.description ?? source.description,\r\n      cuisine_type:\r\n        (target.cuisine_type?.length ?? 0) > 0 ? target.cuisine_type : source.cuisine_type,\r\n      price_range: target.price_range ?? source.price_range,\r\n      current_location: target.current_location ?? source.current_location,\r\n      contact_info: {\r\n        ...source.contact_info,\r\n        ...target.contact_info, // Target takes precedence\r\n      },\r\n      operating_hours: target.operating_hours ?? source.operating_hours,\r\n      menu: (target.menu?.length ?? 0) > 0 ? target.menu : source.menu,\r\n      social_media: {\r\n        ...source.social_media,\r\n        ...target.social_media,\r\n      },\r\n      source_urls: [...new Set([...(target.source_urls ?? []), ...(source.source_urls ?? [])])],\r\n      last_scraped_at: new Date().toISOString(),\r\n    };\r\n\r\n    // Update target with merged data\r\n    const updatedTruckResult = await FoodTruckService.updateTruck(targetId, mergedData);\r\n\r\n    if ('error' in updatedTruckResult) {\r\n      return {\r\n        error: `Failed to update target truck with merged data: ${updatedTruckResult.error}`,\r\n      };\r\n    }\r\n\r\n    console.info(`Merged truck ${sourceId} into ${targetId}`);\r\n\r\n    return updatedTruckResult;\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\data-quality\\placeholderUtils.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\data-quality\\placeholderUtils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\data\\placeholderTrucks.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\data\\placeholderTrucks.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\database.types.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\discoveryEngine.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\discoveryEngine.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\fallback\\supabaseFallback.js","messages":[{"ruleId":null,"nodeType":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token =","line":38,"column":15}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// lib/fallback/supabaseFallback.tsx\n// This creates a resilient data layer that gracefully handles Supabase outages\nimport { createClient } from '@supabase/supabase-js';\nfunction isFoodTruckData(obj) {\n    return (typeof obj === 'object' &&\n        obj !== null &&\n        'id' in obj &&\n        'name' in obj &&\n        'cuisine_type' in obj &&\n        'price_range' in obj);\n}\nfunction isCachedData(obj) {\n    return (typeof obj === 'object' &&\n        obj !== null &&\n        'trucks' in obj &&\n        Array.isArray(obj.trucks) &&\n        'timestamp' in obj &&\n        'lastSuccessfulUpdate' in obj);\n}\n// Helper function to safely parse JSON with type validation\nfunction safeJsonParse(jsonString, typeGuard) {\n    try {\n        const parsed = JSON.parse(jsonString);\n        return typeGuard(parsed) ? parsed : undefined;\n    }\n    catch {\n        return undefined;\n    }\n}\n// Helper function to check if we're in a browser environment\nfunction isBrowserEnvironment() {\n    // Fixed: Use direct comparison with undefined instead of typeof\n    return typeof globalThis !== 'undefined' &&\n        globalThis.window != undefined &&\n        globalThis.window === globalThis;\n}\nclass SupabaseFallbackManager {\n    CACHE_KEY = 'food-trucks-cache';\n    TRUCK_CACHE_KEY_PREFIX = 'food-truck-';\n    CACHE_DURATION = 24 * 60 * 60 * 1000; // 24 hours in milliseconds\n    supabase;\n    constructor() {\n        if (process.env.NEXT_PUBLIC_SUPABASE_URL === undefined || process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY === undefined) {\n            throw new Error('Supabase URL and Anon Key are required!');\n        }\n        this.supabase = createClient(process.env.NEXT_PUBLIC_SUPABASE_URL, process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY);\n    }\n    /**\n     * This is your main data fetching function that handles all the fallback logic\n     * Think of it as your \"smart\" data fetcher that adapts to different situations\n     */\n    async getFoodTrucks() {\n        try {\n            // First, try to get fresh data from Supabase\n            const freshData = await this.fetchFromSupabase();\n            if (freshData.length > 0) {\n                // Success! Cache this data for future fallback use\n                this.cacheData(freshData);\n                return {\n                    trucks: freshData,\n                    isFromCache: false,\n                    lastUpdate: 'Just now',\n                    status: 'fresh'\n                };\n            }\n            // If we reach here, Supabase returned empty results\n            // This might mean no trucks are available, or there's a data issue\n            return this.handleFallbackScenario();\n        }\n        catch (error) {\n            // Supabase is definitely having issues - engage fallback mode\n            console.warn('Supabase unavailable, using fallback strategy:', error);\n            return this.handleFallbackScenario();\n        }\n    }\n    async getFoodTruckById(id) {\n        const cachedTruck = this.getCachedTruck(id);\n        if (cachedTruck !== null) {\n            return cachedTruck;\n        }\n        try {\n            const { data, error } = await this.supabase\n                .from('food_trucks')\n                .select('*')\n                .eq('id', id)\n                .single();\n            if (error !== null) {\n                throw new Error(`Supabase error: ${error.message}`);\n            }\n            // Fixed: Properly handle the data assignment with type checking\n            if (data !== null && isFoodTruckData(data)) {\n                this.cacheTruck(data);\n                return data;\n            }\n            return null;\n        }\n        catch (error) {\n            console.warn(`Failed to fetch truck with id ${id} from Supabase, returning null.`, error);\n            return null;\n        }\n    }\n    /**\n     * This handles the actual Supabase communication\n     * Separated so you can easily modify your existing query logic\n     */\n    async fetchFromSupabase() {\n        console.log('🔌 Connecting to Supabase...');\n        console.log('📊 Supabase URL:', process.env.NEXT_PUBLIC_SUPABASE_URL);\n        console.log('🔑 Anon key present:', !!process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY);\n        try {\n            // The key is to set a reasonable timeout so we don't wait forever\n            const response = await this.supabase\n                .from('food_trucks')\n                .select('*')\n                .abortSignal(AbortSignal.timeout(10000)); // 10 second timeout\n            console.log('📡 Raw Supabase response:', response);\n            console.log('❌ Response error:', response.error);\n            console.log('📋 Response data type:', typeof response.data);\n            console.log('📊 Response data length:', Array.isArray(response.data) ? response.data.length : 'Not an array');\n            if (response.error !== null) {\n                console.error('💥 Supabase query error details:', {\n                    message: response.error.message,\n                    details: response.error.details,\n                    hint: response.error.hint,\n                    code: response.error.code\n                });\n                throw new Error(`Supabase error: ${response.error.message}`);\n            }\n            // Fixed: Properly handle the data with explicit null checking\n            if (response.data != undefined && Array.isArray(response.data)) {\n                console.log('✅ Found', response.data.length, 'raw records from Supabase');\n                if (response.data.length > 0) {\n                    console.log('👀 Sample record:', JSON.stringify(response.data[0], null, 2));\n                }\n                const filteredData = response.data.filter((item) => {\n                    const isValid = isFoodTruckData(item);\n                    if (!isValid) {\n                        console.warn('⚠️ Invalid food truck data found:', item);\n                    }\n                    return isValid;\n                });\n                console.log('✅ Filtered to', filteredData.length, 'valid food trucks');\n                return filteredData;\n            }\n            console.warn('⚠️ No data returned from Supabase or data is not an array');\n            return [];\n        }\n        catch (error) {\n            console.error('💥 Error in fetchFromSupabase:', error);\n            throw error;\n        }\n    }\n    /**\n     * This is where the magic happens - graceful degradation\n     * When Supabase fails, we still provide value to users\n     */\n    handleFallbackScenario() {\n        const cachedData = this.getCachedData();\n        if (cachedData !== null) {\n            const age = Date.now() - cachedData.timestamp;\n            const isStale = age > this.CACHE_DURATION;\n            return {\n                trucks: cachedData.trucks,\n                isFromCache: true,\n                lastUpdate: cachedData.lastSuccessfulUpdate,\n                status: isStale ? 'stale' : 'cached'\n            };\n        }\n        // No cached data available - this is the worst case scenario\n        return {\n            trucks: [],\n            isFromCache: false,\n            lastUpdate: 'Never',\n            status: 'unavailable'\n        };\n    }\n    /**\n     * Stores successful data fetches for later use\n     * This runs every time we successfully get data from Supabase\n     */\n    cacheData(trucks) {\n        const cacheData = {\n            trucks,\n            timestamp: Date.now(),\n            lastSuccessfulUpdate: new Date().toLocaleString()\n        };\n        try {\n            // In a browser environment, use localStorage\n            if (isBrowserEnvironment()) {\n                globalThis.window.localStorage.setItem(this.CACHE_KEY, JSON.stringify(cacheData));\n            }\n            // In a server environment, you might use a file or Redis\n            // For now, we'll just log that we would cache this data\n            console.info(`Cached ${trucks.length} trucks at ${cacheData.lastSuccessfulUpdate}`);\n        }\n        catch (error) {\n            // Caching failed, but that's not critical - log and continue\n            console.warn('Failed to cache data:', error);\n        }\n    }\n    cacheTruck(truck) {\n        try {\n            if (isBrowserEnvironment()) {\n                const cacheKey = `${this.TRUCK_CACHE_KEY_PREFIX}${truck.id}`;\n                globalThis.window.localStorage.setItem(cacheKey, JSON.stringify(truck));\n            }\n        }\n        catch (error) {\n            console.warn(`Failed to cache truck with id ${truck.id}:`, error);\n        }\n    }\n    getCachedTruck(id) {\n        try {\n            if (isBrowserEnvironment()) {\n                const cacheKey = `${this.TRUCK_CACHE_KEY_PREFIX}${id}`;\n                const cached = globalThis.window.localStorage.getItem(cacheKey);\n                if (cached !== null) {\n                    // Fixed: Return the parsed result or null instead of undefined\n                    return safeJsonParse(cached, isFoodTruckData) ?? null;\n                }\n            }\n            return null;\n        }\n        catch (error) {\n            console.warn(`Failed to retrieve cached truck with id ${id}:`, error);\n            return null;\n        }\n    }\n    /**\n     * Retrieves cached data when Supabase is unavailable\n     * This is your safety net\n     */\n    getCachedData() {\n        try {\n            if (isBrowserEnvironment()) {\n                const cached = globalThis.window.localStorage.getItem(this.CACHE_KEY);\n                if (cached !== null) {\n                    // Fixed: Return the parsed result or null instead of undefined\n                    return safeJsonParse(cached, isCachedData) ?? null;\n                }\n            }\n            return null;\n        }\n        catch (error) {\n            console.warn('Failed to retrieve cached data:', error);\n            return null;\n        }\n    }\n}\n// Usage in your components - this replaces your direct Supabase calls\nexport const supabaseFallback = new SupabaseFallbackManager();\n// Example React hook that uses the fallback system\nimport { useState, useEffect } from 'react';\nexport function useFoodTrucks() {\n    const [trucks, setTrucks] = useState([]);\n    const [loading, setLoading] = useState(true);\n    const [dataStatus, setDataStatus] = useState({\n        isFromCache: false,\n        lastUpdate: '',\n        status: 'fresh'\n    });\n    useEffect(() => {\n        const loadTrucks = async () => {\n            try {\n                const result = await supabaseFallback.getFoodTrucks();\n                setTrucks(result.trucks);\n                setDataStatus({\n                    isFromCache: result.isFromCache,\n                    lastUpdate: result.lastUpdate,\n                    status: result.status\n                });\n            }\n            catch (error) {\n                console.error('Failed to load trucks:', error);\n                // Even this fails, we still want to show something\n                setDataStatus({\n                    isFromCache: false,\n                    lastUpdate: 'Error',\n                    status: 'unavailable'\n                });\n            }\n            finally {\n                setLoading(false);\n            }\n        };\n        void loadTrucks(); // Use void to explicitly ignore the Promise\n    }, []);\n    return { trucks, loading, dataStatus };\n}\n// Component that displays appropriate messages based on data status\nexport function DataStatusIndicator({ status, }) {\n    if (status.status === 'fresh') {\n        // Fixed: Return null instead of undefined when no component should render\n        return;\n    }\n    if (status.status === 'cached') {\n        return (<div className=\"bg-blue-100 border border-blue-300 text-blue-800 px-4 py-2 rounded\">\r\n        Showing cached data from {status.lastUpdate}. Live data temporarily unavailable.\r\n      </div>);\n    }\n    if (status.status === 'stale') {\n        return (<div className=\"bg-yellow-100 border border-yellow-300 text-yellow-800 px-4 py-2 rounded\">\r\n        Showing older data from {status.lastUpdate}. We're working to restore live updates.\r\n      </div>);\n    }\n    if (status.status === 'unavailable') {\n        return (<div className=\"bg-red-100 border border-red-300 text-red-800 px-4 py-2 rounded\">\r\n        Service temporarily unavailable. Please check back in a few minutes.\r\n      </div>);\n    }\n    // Fixed: Return null instead of undefined for the fallback case\n}\n","usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\fallback\\supabaseFallback.tsx","messages":[{"ruleId":"unicorn/no-null","severity":1,"message":"Use `undefined` instead of `null`.","line":136,"column":14,"nodeType":"Literal","messageId":"error","endLine":136,"endColumn":18,"suggestions":[{"messageId":"remove","fix":{"range":[4353,4357],"text":""},"data":{},"desc":"Remove `null`."},{"messageId":"replace","fix":{"range":[4353,4357],"text":"undefined"},"data":{},"desc":"Replace `null` with `undefined`."}]},{"ruleId":"unicorn/no-null","severity":1,"message":"Use `undefined` instead of `null`.","line":139,"column":14,"nodeType":"Literal","messageId":"error","endLine":139,"endColumn":18,"suggestions":[{"messageId":"remove","fix":{"range":[4494,4498],"text":""},"data":{},"desc":"Remove `null`."},{"messageId":"replace","fix":{"range":[4494,4498],"text":"undefined"},"data":{},"desc":"Replace `null` with `undefined`."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error, info.","line":148,"column":5,"nodeType":"MemberExpression","messageId":"limited","endLine":148,"endColumn":16,"suggestions":[{"fix":{"range":[4714,4758],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error, info.","line":149,"column":5,"nodeType":"MemberExpression","messageId":"limited","endLine":149,"endColumn":16,"suggestions":[{"fix":{"range":[4764,4834],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error, info.","line":150,"column":5,"nodeType":"MemberExpression","messageId":"limited","endLine":150,"endColumn":16,"suggestions":[{"fix":{"range":[4840,4921],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":150,"column":43,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":150,"endColumn":84,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[4877,4919],"text":"(process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[4878,4919],"text":"(process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[4877,4919],"text":"(!Boolean(process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"unicorn/numeric-separators-style","severity":2,"message":"Invalid group length in numeric value.","line":157,"column":42,"nodeType":"Literal","messageId":"numeric-separators-style","endLine":157,"endColumn":47,"fix":{"range":[5151,5156],"text":"10_000"}},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error, info.","line":159,"column":7,"nodeType":"MemberExpression","messageId":"limited","endLine":159,"endColumn":18,"suggestions":[{"fix":{"range":[5190,5241],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error, info.","line":160,"column":7,"nodeType":"MemberExpression","messageId":"limited","endLine":160,"endColumn":18,"suggestions":[{"fix":{"range":[5249,5298],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error, info.","line":161,"column":7,"nodeType":"MemberExpression","messageId":"limited","endLine":161,"endColumn":18,"suggestions":[{"fix":{"range":[5306,5366],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error, info.","line":162,"column":7,"nodeType":"MemberExpression","messageId":"limited","endLine":162,"endColumn":18,"suggestions":[{"fix":{"range":[5374,5484],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error, info.","line":176,"column":9,"nodeType":"MemberExpression","messageId":"limited","endLine":176,"endColumn":20,"suggestions":[{"fix":{"range":[6002,6076],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error, info.","line":178,"column":11,"nodeType":"MemberExpression","messageId":"limited","endLine":178,"endColumn":22,"suggestions":[{"fix":{"range":[6129,6205],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"unicorn/no-null","severity":1,"message":"Use `undefined` instead of `null`.","line":178,"column":77,"nodeType":"Literal","messageId":"error","endLine":178,"endColumn":81,"suggestions":[{"messageId":"replace","fix":{"range":[6195,6199],"text":"undefined"},"data":{},"desc":"Replace `null` with `undefined`."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error, info.","line":187,"column":9,"nodeType":"MemberExpression","messageId":"limited","endLine":187,"endColumn":20,"suggestions":[{"fix":{"range":[6508,6579],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"unicorn/no-null","severity":1,"message":"Use `undefined` instead of `null`.","line":270,"column":60,"nodeType":"Literal","messageId":"error","endLine":270,"endColumn":64,"suggestions":[{"messageId":"replace","fix":{"range":[9315,9319],"text":"undefined"},"data":{},"desc":"Replace `null` with `undefined`."}]},{"ruleId":"unicorn/no-null","severity":1,"message":"Use `undefined` instead of `null`.","line":273,"column":14,"nodeType":"Literal","messageId":"error","endLine":273,"endColumn":18,"suggestions":[{"messageId":"remove","fix":{"range":[9355,9359],"text":""},"data":{},"desc":"Remove `null`."},{"messageId":"replace","fix":{"range":[9355,9359],"text":"undefined"},"data":{},"desc":"Replace `null` with `undefined`."}]},{"ruleId":"unicorn/no-null","severity":1,"message":"Use `undefined` instead of `null`.","line":276,"column":14,"nodeType":"Literal","messageId":"error","endLine":276,"endColumn":18,"suggestions":[{"messageId":"remove","fix":{"range":[9476,9480],"text":""},"data":{},"desc":"Remove `null`."},{"messageId":"replace","fix":{"range":[9476,9480],"text":"undefined"},"data":{},"desc":"Replace `null` with `undefined`."}]},{"ruleId":"unicorn/no-null","severity":1,"message":"Use `undefined` instead of `null`.","line":290,"column":57,"nodeType":"Literal","messageId":"error","endLine":290,"endColumn":61,"suggestions":[{"messageId":"replace","fix":{"range":[9937,9941],"text":"undefined"},"data":{},"desc":"Replace `null` with `undefined`."}]},{"ruleId":"unicorn/no-null","severity":1,"message":"Use `undefined` instead of `null`.","line":293,"column":14,"nodeType":"Literal","messageId":"error","endLine":293,"endColumn":18,"suggestions":[{"messageId":"remove","fix":{"range":[9977,9981],"text":""},"data":{},"desc":"Remove `null`."},{"messageId":"replace","fix":{"range":[9977,9981],"text":"undefined"},"data":{},"desc":"Replace `null` with `undefined`."}]},{"ruleId":"unicorn/no-null","severity":1,"message":"Use `undefined` instead of `null`.","line":296,"column":14,"nodeType":"Literal","messageId":"error","endLine":296,"endColumn":18,"suggestions":[{"messageId":"remove","fix":{"range":[10092,10096],"text":""},"data":{},"desc":"Remove `null`."},{"messageId":"replace","fix":{"range":[10092,10096],"text":"undefined"},"data":{},"desc":"Replace `null` with `undefined`."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":20,"fixableErrorCount":1,"fixableWarningCount":0,"source":"// lib/fallback/supabaseFallback.tsx\r\n// This creates a resilient data layer that gracefully handles Supabase outages\r\n\r\nimport { createClient, SupabaseClient } from '@supabase/supabase-js';\r\nimport type { Database } from '@/lib/database.types'; // Assuming this is your Supabase database types\r\nimport type { FoodTruck } from '@/lib/types';\r\n\r\n// Create a type alias for the complex union type to improve readability\r\ntype FallbackResult = {\r\n  readonly trucks: FoodTruck[];\r\n  readonly isFromCache: boolean;\r\n  readonly lastUpdate: string;\r\n  readonly status: 'fresh' | 'cached' | 'stale' | 'unavailable';\r\n};\r\n\r\nfunction isFoodTruckData(obj: unknown): obj is FoodTruck {\r\n  return (\r\n    typeof obj === 'object' &&\r\n    obj !== null &&\r\n    'id' in obj &&\r\n    'name' in obj &&\r\n    'cuisine_type' in obj &&\r\n    'price_range' in obj\r\n  );\r\n}\r\n\r\ninterface CachedData {\r\n  readonly trucks: FoodTruck[];\r\n  readonly timestamp: number;\r\n  readonly lastSuccessfulUpdate: string;\r\n}\r\n\r\nfunction isCachedData(obj: unknown): obj is CachedData {\r\n  return (\r\n    typeof obj === 'object' &&\r\n    obj !== null &&\r\n    'trucks' in obj &&\r\n    Array.isArray((obj as CachedData).trucks) &&\r\n    'timestamp' in obj &&\r\n    'lastSuccessfulUpdate' in obj\r\n  );\r\n}\r\n\r\n// Helper function to safely parse JSON with type validation\r\nfunction safeJsonParse<T>(\r\n  jsonString: string,\r\n  typeGuard: (obj: unknown) => obj is T\r\n): T | undefined {\r\n  try {\r\n    const parsed: unknown = JSON.parse(jsonString);\r\n    return typeGuard(parsed) ? parsed : undefined;\r\n  } catch {\r\n    return undefined;\r\n  }\r\n}\r\n\r\n// Helper function to check if we're in a browser environment\r\nfunction isBrowserEnvironment(): boolean {\r\n  // Fixed: Use direct comparison with undefined instead of typeof\r\n  return typeof globalThis !== 'undefined' && \r\n         globalThis.window != undefined && \r\n         globalThis.window === globalThis;\r\n}\r\n\r\nclass SupabaseFallbackManager {\r\n  private readonly CACHE_KEY = 'food-trucks-cache';\r\n  private readonly TRUCK_CACHE_KEY_PREFIX = 'food-truck-';\r\n  private readonly CACHE_DURATION = 24 * 60 * 60 * 1000; // 24 hours in milliseconds\r\n  private readonly supabase: SupabaseClient<Database>;\r\n\r\n  constructor() {\r\n    if (process.env.NEXT_PUBLIC_SUPABASE_URL === undefined || process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY === undefined) {\r\n      throw new Error('Supabase URL and Anon Key are required!');\r\n    }\r\n    this.supabase = createClient<Database>(\r\n      process.env.NEXT_PUBLIC_SUPABASE_URL,\r\n      process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY\r\n    );\r\n  }\r\n\r\n  /**\r\n   * This is your main data fetching function that handles all the fallback logic\r\n   * Think of it as your \"smart\" data fetcher that adapts to different situations\r\n   */\r\n  public async getFoodTrucks(): Promise<FallbackResult> {\r\n    try {\r\n      // First, try to get fresh data from Supabase\r\n      const freshData = await this.fetchFromSupabase();\r\n\r\n      if (freshData.length > 0) {\r\n        // Success! Cache this data for future fallback use\r\n        this.cacheData(freshData);\r\n\r\n        return {\r\n          trucks: freshData,\r\n          isFromCache: false,\r\n          lastUpdate: 'Just now',\r\n          status: 'fresh'\r\n        };\r\n      }\r\n\r\n      // If we reach here, Supabase returned empty results\r\n      // This might mean no trucks are available, or there's a data issue\r\n      return this.handleFallbackScenario();\r\n\r\n    } catch (error: unknown) {\r\n      // Supabase is definitely having issues - engage fallback mode\r\n      console.warn('Supabase unavailable, using fallback strategy:', error);\r\n      return this.handleFallbackScenario();\r\n    }\r\n  }\r\n\r\n  public async getFoodTruckById(id: string): Promise<FoodTruck | null> {\r\n    const cachedTruck = this.getCachedTruck(id);\r\n    if (cachedTruck !== null) {\r\n      return cachedTruck;\r\n    }\r\n\r\n    try {\r\n      const { data, error }: { data: FoodTruck[] | null; error: Error | null } = await this.supabase\r\n        .from('food_trucks')\r\n        .select('*')\r\n        .eq('id', id)\r\n        .single();\r\n\r\n      if (error !== null) {\r\n        throw new Error(`Supabase error: ${error.message}`);\r\n      }\r\n\r\n      // Fixed: Properly handle the data assignment with type checking\r\n      if (data !== null && isFoodTruckData(data)) {\r\n        this.cacheTruck(data);\r\n        return data;\r\n      }\r\n\r\n      return null;\r\n    } catch (error) {\r\n      console.warn(`Failed to fetch truck with id ${id} from Supabase, returning null.`, error);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * This handles the actual Supabase communication\r\n   * Separated so you can easily modify your existing query logic\r\n   */\r\n  private async fetchFromSupabase(): Promise<FoodTruck[]> {\r\n    console.log('🔌 Connecting to Supabase...');\r\n    console.log('📊 Supabase URL:', process.env.NEXT_PUBLIC_SUPABASE_URL);\r\n    console.log('🔑 Anon key present:', !!process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY);\r\n    \r\n    try {\r\n      // The key is to set a reasonable timeout so we don't wait forever\r\n      const response = await this.supabase\r\n        .from('food_trucks')\r\n        .select('*')\r\n        .abortSignal(AbortSignal.timeout(10000)); // 10 second timeout\r\n\r\n      console.log('📡 Raw Supabase response:', response);\r\n      console.log('❌ Response error:', response.error);\r\n      console.log('📋 Response data type:', typeof response.data);\r\n      console.log('📊 Response data length:', Array.isArray(response.data) ? response.data.length : 'Not an array');\r\n      \r\n      if (response.error !== null) {\r\n        console.error('💥 Supabase query error details:', {\r\n          message: response.error.message,\r\n          details: response.error.details,\r\n          hint: response.error.hint,\r\n          code: response.error.code\r\n        });\r\n        throw new Error(`Supabase error: ${response.error.message}`);\r\n      }\r\n\r\n      // Fixed: Properly handle the data with explicit null checking\r\n      if (response.data != undefined && Array.isArray(response.data)) {\r\n        console.log('✅ Found', response.data.length, 'raw records from Supabase');\r\n        if (response.data.length > 0) {\r\n          console.log('👀 Sample record:', JSON.stringify(response.data[0], null, 2));\r\n        }\r\n        const filteredData = response.data.filter((item): item is FoodTruck => {\r\n          const isValid = isFoodTruckData(item);\r\n          if (!isValid) {\r\n            console.warn('⚠️ Invalid food truck data found:', item);\r\n          }\r\n          return isValid;\r\n        });\r\n        console.log('✅ Filtered to', filteredData.length, 'valid food trucks');\r\n        return filteredData;\r\n      }\r\n      console.warn('⚠️ No data returned from Supabase or data is not an array');\r\n      return [];\r\n    } catch (error) {\r\n      console.error('💥 Error in fetchFromSupabase:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * This is where the magic happens - graceful degradation\r\n   * When Supabase fails, we still provide value to users\r\n   */\r\n  private handleFallbackScenario(): FallbackResult {\r\n    const cachedData = this.getCachedData();\r\n\r\n    if (cachedData !== null) {\r\n      const age = Date.now() - cachedData.timestamp;\r\n      const isStale = age > this.CACHE_DURATION;\r\n\r\n      return {\r\n        trucks: cachedData.trucks,\r\n        isFromCache: true,\r\n        lastUpdate: cachedData.lastSuccessfulUpdate,\r\n        status: isStale ? 'stale' : 'cached'\r\n      };\r\n    }\r\n\r\n    // No cached data available - this is the worst case scenario\r\n    return {\r\n      trucks: [],\r\n      isFromCache: false,\r\n      lastUpdate: 'Never',\r\n      status: 'unavailable'\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Stores successful data fetches for later use\r\n   * This runs every time we successfully get data from Supabase\r\n   */\r\n  private cacheData(trucks: FoodTruck[]): void {\r\n    const cacheData: CachedData = {\r\n      trucks,\r\n      timestamp: Date.now(),\r\n      lastSuccessfulUpdate: new Date().toLocaleString()\r\n    };\r\n\r\n    try {\r\n      // In a browser environment, use localStorage\r\n      if (isBrowserEnvironment()) {\r\n        globalThis.window.localStorage.setItem(this.CACHE_KEY, JSON.stringify(cacheData));\r\n      }\r\n\r\n      // In a server environment, you might use a file or Redis\r\n      // For now, we'll just log that we would cache this data\r\n      console.info(`Cached ${trucks.length} trucks at ${cacheData.lastSuccessfulUpdate}`);\r\n    } catch (error: unknown) {\r\n      // Caching failed, but that's not critical - log and continue\r\n      console.warn('Failed to cache data:', error);\r\n    }\r\n  }\r\n\r\n  private cacheTruck(truck: FoodTruck): void {\r\n    try {\r\n      if (isBrowserEnvironment()) {\r\n        const cacheKey = `${this.TRUCK_CACHE_KEY_PREFIX}${truck.id}`;\r\n        globalThis.window.localStorage.setItem(cacheKey, JSON.stringify(truck));\r\n      }\r\n    } catch (error) {\r\n      console.warn(`Failed to cache truck with id ${truck.id}:`, error);\r\n    }\r\n  }\r\n\r\n  private getCachedTruck(id: string): FoodTruck | null {\r\n    try {\r\n      if (isBrowserEnvironment()) {\r\n        const cacheKey = `${this.TRUCK_CACHE_KEY_PREFIX}${id}`;\r\n        const cached = globalThis.window.localStorage.getItem(cacheKey);\r\n        if (cached !== null) {\r\n          // Fixed: Return the parsed result or null instead of undefined\r\n          return safeJsonParse(cached, isFoodTruckData) ?? null;\r\n        }\r\n      }\r\n      return null;\r\n    } catch (error) {\r\n      console.warn(`Failed to retrieve cached truck with id ${id}:`, error);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Retrieves cached data when Supabase is unavailable\r\n   * This is your safety net\r\n   */\r\n  private getCachedData(): CachedData | null {\r\n    try {\r\n      if (isBrowserEnvironment()) {\r\n        const cached = globalThis.window.localStorage.getItem(this.CACHE_KEY);\r\n        if (cached !== null) {\r\n          // Fixed: Return the parsed result or null instead of undefined\r\n          return safeJsonParse(cached, isCachedData) ?? null;\r\n        }\r\n      }\r\n      return null;\r\n    } catch (error: unknown) {\r\n      console.warn('Failed to retrieve cached data:', error);\r\n      return null;\r\n    }\r\n  }\r\n}\r\n\r\n// Usage in your components - this replaces your direct Supabase calls\r\nexport const supabaseFallback = new SupabaseFallbackManager();\r\n\r\n// Example React hook that uses the fallback system\r\nimport { useState, useEffect } from 'react';\r\n\r\nexport function useFoodTrucks() {\r\n  const [trucks, setTrucks] = useState<FoodTruck[]>([]);\r\n  const [loading, setLoading] = useState<boolean>(true);\r\n  const [dataStatus, setDataStatus] = useState<{\r\n    readonly isFromCache: boolean;\r\n    readonly lastUpdate: string;\r\n    readonly status: 'fresh' | 'cached' | 'stale' | 'unavailable';\r\n  }>({\r\n    isFromCache: false,\r\n    lastUpdate: '',\r\n    status: 'fresh'\r\n  });\r\n\r\n  useEffect(() => {\r\n    const loadTrucks = async (): Promise<void> => {\r\n      try {\r\n        const result = await supabaseFallback.getFoodTrucks();\r\n        setTrucks(result.trucks);\r\n        setDataStatus({\r\n          isFromCache: result.isFromCache,\r\n          lastUpdate: result.lastUpdate,\r\n          status: result.status\r\n        });\r\n      } catch (error: unknown) {\r\n        console.error('Failed to load trucks:', error);\r\n        // Even this fails, we still want to show something\r\n        setDataStatus({\r\n          isFromCache: false,\r\n          lastUpdate: 'Error',\r\n          status: 'unavailable'\r\n        });\r\n      } finally {\r\n        setLoading(false);\r\n      }\r\n    };\r\n\r\n    void loadTrucks(); // Use void to explicitly ignore the Promise\r\n  }, []);\r\n\r\n  return { trucks, loading, dataStatus };\r\n}\r\n\r\n// Component that displays appropriate messages based on data status\r\nexport function DataStatusIndicator({\r\n  status,\r\n}: {\r\n  readonly status: {\r\n    isFromCache: boolean;\r\n    lastUpdate: string;\r\n    status: 'fresh' | 'cached' | 'stale' | 'unavailable';\r\n  };\r\n}) {\r\n  if (status.status === 'fresh') {\r\n    // Fixed: Return null instead of undefined when no component should render\r\n    return;\r\n  }\r\n\r\n  if (status.status === 'cached') {\r\n    return (\r\n      <div className=\"bg-blue-100 border border-blue-300 text-blue-800 px-4 py-2 rounded\">\r\n        Showing cached data from {status.lastUpdate}. Live data temporarily unavailable.\r\n      </div>\r\n    );\r\n  }\r\n\r\n  if (status.status === 'stale') {\r\n    return (\r\n      <div className=\"bg-yellow-100 border border-yellow-300 text-yellow-800 px-4 py-2 rounded\">\r\n        Showing older data from {status.lastUpdate}. We're working to restore live updates.\r\n      </div>\r\n    );\r\n  }\r\n\r\n  if (status.status === 'unavailable') {\r\n    return (\r\n      <div className=\"bg-red-100 border border-red-300 text-red-800 px-4 py-2 rounded\">\r\n        Service temporarily unavailable. Please check back in a few minutes.\r\n      </div>\r\n    );\r\n  }\r\n\r\n  // Fixed: Return null instead of undefined for the fallback case\r\n}","usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\firecrawl.js","messages":[{"ruleId":null,"nodeType":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token ;","line":4,"column":11}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"const FIRECRAWL_CACHE_TTL_MS = 1000 * 60 * 60 * 12; // 12 hours\nconst firecrawlCache = {};\nexport class FirecrawlService {\n    apiKey;\n    baseUrl;\n    constructor() {\n        this.apiKey = process.env.FIRECRAWL_API_KEY;\n        this.baseUrl = 'https://api.firecrawl.dev/v0';\n    }\n    /**\n     * Retrieves a cached result based on the given cache key if it hasn't expired.\n     * @example\n     * getCachedResult('uniqueCacheKey')\n     * FirecrawlResponse or undefined\n     * @param {string} cacheKey - The unique identifier for the cached result.\n     * @returns {FirecrawlResponse | CrawlJobResponse | CrawlStatusResponse | undefined} The cached data if available and valid, otherwise undefined.\n     * @description\n     *   - Cleans up expired cache entries before attempting to return a cached result.\n     *   - Logs a message when a cache hit occurs.\n     */\n    getCachedResult(cacheKey) {\n        const now = Date.now();\n        // Clean up expired cache\n        for (const key in firecrawlCache) {\n            if (Object.prototype.hasOwnProperty.call(firecrawlCache, key) &&\n                now - firecrawlCache[key].timestamp > FIRECRAWL_CACHE_TTL_MS) {\n                delete firecrawlCache[key];\n            }\n        }\n        if (firecrawlCache[cacheKey] != undefined &&\n            now - firecrawlCache[cacheKey].timestamp < FIRECRAWL_CACHE_TTL_MS) {\n            console.info(`FirecrawlService: Cache hit for ${cacheKey}`);\n            return firecrawlCache[cacheKey].data;\n        }\n        return undefined;\n    }\n    setCacheResult(cacheKey, data) {\n        firecrawlCache[cacheKey] = { data, timestamp: Date.now() };\n    }\n    /**\n    * Fetches and processes content from a specified URL, optionally customizing the output format and content inclusion/exclusion via provided options.\n    * @example\n    * scrapeUrl('https://example.com', { formats: ['html'], includeTags: ['h1', 'p'] })\n    * Returns a FirecrawlResponse object containing the scraped data.\n    * @param {string} url - The URL from which content will be scraped.\n    * @param {Object} options - Optional parameters to customize the scraping process.\n    * @param {(string[]|undefined)} options.formats - Specifies the desired output formats: 'markdown' or 'html'.\n    * @param {(string[]|undefined)} options.includeTags - Tags to specifically include in the scraping results.\n    * @param {(string[]|undefined)} options.excludeTags - Tags to exclude from the scraping results.\n    * @param {(boolean|undefined)} options.onlyMainContent - If true, extracts only the main content from the URL.\n    * @param {(number|undefined)} options.waitFor - Time in milliseconds to wait before starting the scraping process.\n    * @returns {Promise<FirecrawlResponse>} A promise resolving to a FirecrawlResponse containing either the successful scraping results or error details.\n    * @description\n    *   - Utilizes caching to store and retrieve previously fetched data to minimize repeated requests.\n    *   - Sends API requests with authentication headers using the instance's API key.\n    *   - Handles errors gracefully, returning a descriptive error message if the scraping process fails.\n    */\n    async scrapeUrl(url, options = {}) {\n        const cacheKey = `scrape:${url}:${JSON.stringify(options)}`;\n        const cached = this.getCachedResult(cacheKey);\n        if (cached) {\n            return cached;\n        }\n        try {\n            const response = await fetch(`${this.baseUrl}/scrape`, {\n                method: 'POST',\n                headers: {\n                    Authorization: `Bearer ${this.apiKey}`,\n                    'Content-Type': 'application/json',\n                },\n                body: JSON.stringify({\n                    url,\n                    formats: options.formats ?? ['markdown'],\n                    includeTags: options.includeTags,\n                    excludeTags: options.excludeTags,\n                    onlyMainContent: options.onlyMainContent ?? true,\n                    waitFor: options.waitFor ?? 0,\n                }),\n            });\n            const data = await response.json();\n            if (!response.ok) {\n                const errorData = data;\n                throw new Error(errorData.error ?? `HTTP ${response.status}`);\n            }\n            this.setCacheResult(cacheKey, data);\n            return data;\n        }\n        catch (error) {\n            console.warn('Firecrawl scrape error:', error);\n            return {\n                success: false,\n                error: error instanceof Error ? error.message : 'Unknown error',\n            };\n        }\n    }\n    /**\n     * Initiates a web crawling process for a specified URL with given options.\n     * @example\n     * crawlWebsite('https://example.com', { crawlerOptions: { includes: ['.html'] }, pageOptions: { formats: ['markdown'] } })\n     * // Returns a promise that resolves to a CrawlJobResponse object\n     * @param {string} url - The URL of the website to be crawled.\n     * @param {Object} options - Configuration options for the crawling process.\n     * @param {Object} [options.crawlerOptions] - Specific options for controlling the crawler behavior.\n     * @param {string[]} [options.crawlerOptions.includes] - List of patterns to include in the crawl.\n     * @param {string[]} [options.crawlerOptions.excludes] - List of patterns to exclude from the crawl.\n     * @param {number} [options.crawlerOptions.maxDepth] - Maximum depth the crawler should reach.\n     * @param {number} [options.crawlerOptions.limit] - Limit to the number of pages to crawl.\n     * @param {Object} [options.pageOptions] - Options for the page content format and selection.\n     * @param {string[]} [options.pageOptions.formats] - Desired formats for the crawled page content.\n     * @param {boolean} [options.pageOptions.onlyMainContent] - Whether to include only the main content of the pages.\n     * @returns {Promise<CrawlJobResponse>} A promise that resolves with the results of the crawl job including success and potential errors.\n     * @description\n     *   - Performs a POST request to the Firecrawl service to crawl pages.\n     *   - Uses caching to avoid redundant web crawling operations.\n     *   - Handles errors gracefully, returning an appropriate error message if the fetch operation fails.\n     *   - Crawls with default options which include markdown format and filtering for main content.\n     */\n    async crawlWebsite(url, options = {}) {\n        const cacheKey = `crawl:${url}:${JSON.stringify(options)}`;\n        const cached = this.getCachedResult(cacheKey);\n        if (cached) {\n            return cached;\n        }\n        try {\n            const response = await fetch(`${this.baseUrl}/crawl`, {\n                method: 'POST',\n                headers: {\n                    Authorization: `Bearer ${this.apiKey}`,\n                    'Content-Type': 'application/json',\n                },\n                body: JSON.stringify({\n                    url,\n                    crawlerOptions: {\n                        maxDepth: 2,\n                        limit: 10,\n                        ...options.crawlerOptions,\n                    },\n                    pageOptions: {\n                        formats: ['markdown'],\n                        onlyMainContent: true,\n                        ...options.pageOptions,\n                    },\n                }),\n            });\n            const data = await response.json();\n            if (!response.ok) {\n                const errorData = data;\n                throw new Error(errorData.error ?? `HTTP ${response.status}`);\n            }\n            this.setCacheResult(cacheKey, data);\n            return data;\n        }\n        catch (error) {\n            console.warn('Firecrawl crawl error:', error);\n            return {\n                success: false,\n                error: error instanceof Error ? error.message : 'Unknown error',\n            };\n        }\n    }\n    /**\n     * Retrieves the crawl status for a given job by its ID.\n     * @example\n     * getCrawlStatus('12345')\n     * { success: true, status: 'completed' }\n     * @param {string} jobId - The ID of the job for which the crawl status is requested.\n     * @returns {Promise<CrawlStatusResponse>} Resolves to a `CrawlStatusResponse` object containing the crawl status or an error.\n     * @description\n     *   - Attempts to retrieve the crawl status from a cache before making an HTTP request.\n     *   - Fetches crawl status using an authenticated request to the API.\n     *   - Caches the crawl status response data to minimize redundant network calls.\n     *   - Handles errors gracefully, returning a standardized error response.\n     */\n    async getCrawlStatus(jobId) {\n        const cacheKey = `crawlStatus:${jobId}`;\n        const cached = this.getCachedResult(cacheKey);\n        if (cached) {\n            return cached;\n        }\n        try {\n            const response = await fetch(`${this.baseUrl}/crawl/status/${jobId}`, {\n                headers: {\n                    Authorization: `Bearer ${this.apiKey}`,\n                },\n            });\n            const data = await response.json();\n            if (!response.ok) {\n                const errorData = data;\n                throw new Error(errorData.error ?? `HTTP ${response.status}`);\n            }\n            this.setCacheResult(cacheKey, data);\n            return data;\n        }\n        catch (error) {\n            console.warn('Firecrawl status error:', error);\n            return {\n                success: false,\n                error: error instanceof Error ? error.message : 'Unknown error',\n            };\n        }\n    }\n    // Specialized methods for food truck data\n    /**\n     * Scrapes a food truck website and retrieves its main content in markdown format.\n     * @example\n     * scrapeFoodTruckWebsite('https://example.com/food-truck')\n     * // Returns: Promise<{ success: true, data: { markdown: '...', name: 'Example Food Truck', source_url: 'https://example.com/food-truck' } }>\n     * @param {string} url - The URL of the food truck website to scrape.\n     * @returns {Promise<{ success: boolean, data?: { markdown: string, name?: string, source_url?: string }, error?: string }>} The result of the scrape operation, including markdown content and metadata if successful, or an error message if not.\n     * @description\n     *   - Configured to wait 2000 milliseconds to ensure all content is loaded.\n     *   - Uses 'markdown' format for content extraction to maintain text structure.\n     *   - Extracts metadata such as the title and source URL if available.\n     */\n    async scrapeFoodTruckWebsite(url) {\n        const result = await this.scrapeUrl(url, {\n            formats: ['markdown'],\n            onlyMainContent: true,\n            waitFor: 2000,\n        });\n        return result.success && result.data?.markdown != undefined\n            ? {\n                success: true,\n                data: {\n                    markdown: result.data.markdown,\n                    name: result.data.metadata?.title,\n                    source_url: result.data.metadata?.sourceURL,\n                },\n            }\n            : { success: false, error: result.error ?? 'Markdown content not found' };\n    }\n    extractPattern(text, pattern) {\n        const match = pattern.exec(text);\n        return match ? match[1].trim() : undefined;\n    }\n    /**\n    * Extracts a menu section from a given markdown string based on specific keywords.\n    * @example\n    * extractMenuSection(\"menu: Pizza, Pasta, Salad\")\n    * // Returns \"Pizza, Pasta, Salad\"\n    * @param {string} markdown - The markdown string to search for menu-related content.\n    * @returns {string | undefined} The extracted menu section if found, otherwise undefined.\n    * @description\n    *   - Searches for menu-related phrases like \"menu\", \"food\", \"items\" up to a maximum of 50 characters.\n    *   - Implements case-insensitive search patterns.\n    *   - Returns the portion of the markdown line following the specific keywords.\n    */\n    extractMenuSection(markdown) {\n        // Use simpler, more efficient regex patterns with fixed max length\n        const menuPatterns = [\n            /menu\\s*:\\s*([^\\n]{1,50})/i,\n            /food\\s*:\\s*([^\\n]{1,50})/i,\n            /items?\\s*:\\s*([^\\n]{1,50})/i,\n            /what we serve\\s*:\\s*([^\\n]{1,50})/i,\n            /our food\\s*:\\s*([^\\n]{1,50})/i,\n        ];\n        for (const pattern of menuPatterns) {\n            const match = pattern.exec(markdown);\n            if (match) {\n                return match[1].trim();\n            }\n        }\n        return undefined;\n    }\n    /**\n     * Extracts phone and email contact information from a markdown string.\n     * @example\n     * extractContactInfo(\"Contact: +123-456-7890, email: example@test.com\")\n     * { phone: \"+123-456-7890\", email: \"example@test.com\" }\n     * @param {string} markdown - A markdown string potentially containing contact information.\n     * @returns {ContactInfo | undefined} An object containing extracted phone and email, or undefined if none are found.\n     * @description\n     *   - Utilizes regular expressions to identify phone numbers and email addresses within the markdown.\n     *   - Returns an object only when at least one type of contact information is successfully extracted.\n     */\n    extractContactInfo(markdown) {\n        const contact = {}; // Phone number - Use specific patterns to prevent backtracking\n        const phoneRegex = /(?:phone|call|contact)(?:\\s*:\\s*)?([+]?\\d{3,4}[.\\s-]\\d{3}[.\\s-]\\d{3,4})/i;\n        const phoneMatch = phoneRegex.exec(markdown);\n        if (phoneMatch) {\n            contact.phone = phoneMatch[1].trim();\n        } // Email - Use specific pattern to avoid backtracking\n        const emailRegex = /([a-zA-Z0-9._%-]{1,64}@[a-zA-Z0-9-]{1,63}\\.[a-zA-Z]{2,6})/;\n        const emailMatch = emailRegex.exec(markdown);\n        if (emailMatch) {\n            contact.email = emailMatch[1].trim();\n        }\n        return Object.keys(contact).length > 0 ? contact : undefined;\n    }\n    /**\n    * Extracts social media profile names from a given markdown string.\n    * @example\n    * extractSocialMedia(\"@john_doe instagram.com/jane Facebook.com/joe\")\n    * { instagram: 'john_doe', facebook: 'jane', twitter: 'joe' }\n    * @param {string} markdown - A string containing markdown text to parse for social media information.\n    * @returns {SocialMediaInfo | undefined} An object containing social media profiles if any are found, otherwise undefined.\n    * @description\n    *   - Supports extracting profiles for Instagram, Facebook, and Twitter.\n    *   - Uses regular expressions to match social media patterns.\n    *   - Returns the trimmed username of identified social media profiles.\n    *   - Returns undefined if no social media profiles are found in the input.\n    */\n    extractSocialMedia(markdown) {\n        const social = {};\n        // Instagram - Use concise character class\n        const instagramRegex = /(?:instagram|@)\\s*([\\w.]+)/i;\n        const instagramMatch = instagramRegex.exec(markdown);\n        if (instagramMatch) {\n            social.instagram = instagramMatch[1].trim();\n        }\n        // Facebook - With fixed character class\n        const facebookRegex = /facebook\\.com\\/([\\w.-]+)/i;\n        const facebookMatch = facebookRegex.exec(markdown);\n        if (facebookMatch) {\n            social.facebook = facebookMatch[1].trim();\n        }\n        // Twitter - Use concise character class\n        const twitterRegex = /(?:twitter|@)\\s*([\\w.]+)/i; // Changed \\w+ to [\\w.]+ to allow dots in usernames\n        const twitterMatch = twitterRegex.exec(markdown);\n        if (twitterMatch) {\n            social.twitter = twitterMatch[1].trim();\n        }\n        return Object.keys(social).length > 0 ? social : undefined;\n    }\n    /**\n     * Performs web scraping on multiple URLs with batching and delay options.\n     * @example\n     * scrapeMultipleUrls(['http://example.com', 'http://another.com'], { batchSize: 2, delay: 1500 })\n     * Returns: Promise resolving to an array containing the results of the scraped URLs.\n     * @param {string[]} urls - Array of URLs to be scraped.\n     * @param {Object} options - Options object for configuring the scraping process.\n     * @param {number} [options.batchSize=5] - Size of each batch in which URLs are processed.\n     * @param {number} [options.delay=1000] - Delay between processing each batch in milliseconds.\n     * @returns {Promise<Array<{ url: string; result: FirecrawlResponse }>>} Promise resolving to an array of objects, each containing a URL and its corresponding scrape result.\n     * @description\n     *   - Utilizes a batch mechanism to efficiently handle large sets of URLs.\n     *   - Incorporates a delay between batches to comply with potential rate limits.\n     */\n    async scrapeMultipleUrls(urls, options = {}) {\n        const batchSize = options.batchSize ?? 5;\n        const delay = options.delay ?? 1000;\n        const results = [];\n        for (let i = 0; i < urls.length; i += batchSize) {\n            const batch = urls.slice(i, i + batchSize);\n            const batchPromises = batch.map(async (url) => {\n                const result = await this.scrapeUrl(url);\n                return { url, result };\n            });\n            const batchResults = await Promise.all(batchPromises);\n            results.push(...batchResults);\n            // Add delay between batches to respect rate limits\n            if (i + batchSize < urls.length) {\n                await new Promise((resolve) => { setTimeout(resolve, delay); });\n            }\n        }\n        return results;\n    }\n    // Rate limiting and error handling\n    /**\n     * Attempts to scrape content from a given URL with retries in case of failure.\n     * @example\n     * scrapeWithRetry('https://example.com', 3, 1000)\n     * { success: true, data: {...} }\n     * @param {string} url - The URL to scrape.\n     * @param {number} maxRetries - Maximum number of retry attempts. Defaults to 3.\n     * @param {number} backoffMs - Initial wait time before retrying in milliseconds. Defaults to 1000ms.\n     * @returns {Promise<FirecrawlResponse>} Promise resolving to a FirecrawlResponse object indicating success or failure.\n     * @description\n     *   - Implements exponential backoff strategy for rate limit errors.\n     *   - Logs attempt details and waiting times between retries.\n     *   - Returns last error message if all retry attempts fail.\n     */\n    async scrapeWithRetry(url, maxRetries = 3, backoffMs = 1000) {\n        let lastError;\n        for (let attempt = 1; attempt <= maxRetries; attempt += 1) {\n            try {\n                const result = await this.scrapeUrl(url);\n                if (result.success) {\n                    return result;\n                }\n                // If it's a rate limit error, wait longer\n                if (result.error?.includes('rate limit') === true) {\n                    const waitTime = backoffMs * 2 ** attempt;\n                    console.info(`Rate limited. Waiting ${waitTime}ms before retry ${attempt}/${maxRetries}`);\n                    await new Promise((resolve) => { setTimeout(resolve, waitTime); });\n                    continue;\n                }\n                throw new Error(result.error);\n            }\n            catch (error) {\n                lastError = error instanceof Error ? error : new Error(String(error));\n                if (attempt === maxRetries) {\n                    break;\n                }\n                const waitTime = backoffMs * 2 ** attempt;\n                console.info(`Attempt ${attempt} failed. Retrying in ${waitTime}ms...`);\n                await new Promise((resolve) => { setTimeout(resolve, waitTime); });\n            }\n        }\n        return {\n            success: false,\n            error: lastError.message,\n        };\n    }\n}\n// Export singleton instance\nexport const firecrawl = new FirecrawlService();\n","usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\firecrawl.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\gemini.js","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Async method 'extractFoodTruckDetailsFromMarkdown' has too many lines (239). Maximum allowed is 120.","line":124,"column":5,"nodeType":"MethodDefinition","messageId":"exceed","endLine":362,"endColumn":6},{"ruleId":"unicorn/no-null","severity":1,"message":"Use `undefined` instead of `null`.","line":339,"column":36,"nodeType":"Literal","messageId":"error","endLine":339,"endColumn":40,"suggestions":[{"messageId":"replace","fix":{"range":[14564,14568],"text":"undefined"},"data":{},"desc":"Replace `null` with `undefined`."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { APIUsageService } from './supabase/services/apiUsageService.js';\r\nimport { GeminiApiClient } from './gemini/geminiApiClient.js';\r\nimport { GeminiUsageLimits } from './gemini/usageLimits.js';\r\nimport { PromptTemplates } from './gemini/promptTemplates.js';\r\nimport { GeminiResponseParser } from './gemini/responseParser.js';\r\nexport class GeminiService {\r\n    constructor() {\r\n        this.apiClient = new GeminiApiClient();\r\n        this.dailyRequestLimit = 1500;\r\n        this.dailyTokenLimit = 32_000;\r\n    }\r\n    checkUsageLimits() {\r\n        return GeminiUsageLimits.checkUsageLimits({\r\n            dailyRequestLimit: this.dailyRequestLimit,\r\n            dailyTokenLimit: this.dailyTokenLimit,\r\n        });\r\n    }\r\n    async makeGeminiRequest(prompt, parser) {\r\n        return this.apiClient.makeRequestWithParsing(prompt, parser);\r\n    }\r\n    async processMenuData(rawMenuText) {\r\n        const estimatedTokens = Math.ceil(rawMenuText.length / 4) + 500;\r\n        const usageCheck = await GeminiUsageLimits.checkWithMonitoring(estimatedTokens);\r\n        if (!usageCheck.allowed) {\r\n            console.error('Gemini API usage limit error:', usageCheck.reason);\r\n            return {\r\n                success: false,\r\n                error: \"That didn't work, please try again later.\",\r\n            };\r\n        }\r\n        const prompt = PromptTemplates.menuProcessing(rawMenuText);\r\n        return this.makeGeminiRequest(prompt, (text) => {\r\n            const parsedData = JSON.parse(text);\r\n            return parsedData.categories;\r\n        });\r\n    }\r\n    async extractLocationFromText(textInput) {\r\n        const usageCheck = await this.checkUsageLimits();\r\n        if (!usageCheck.canMakeRequest) {\r\n            console.error('Gemini API usage limit error: Daily API limits exceeded');\r\n            return {\r\n                success: false,\r\n                error: \"That didn't work, please try again later.\",\r\n            };\r\n        }\r\n        const prompt = PromptTemplates.locationExtraction(textInput);\r\n        return this.makeGeminiRequest(prompt, (text) => GeminiResponseParser.parseLocationData(text));\r\n    }\r\n    async standardizeOperatingHours(hoursText) {\r\n        const usageCheck = await this.checkUsageLimits();\r\n        if (!usageCheck.canMakeRequest) {\r\n            console.error('Gemini API usage limit error: Daily API limits exceeded');\r\n            return {\r\n                success: false,\r\n                error: \"That didn't work, please try again later.\",\r\n            };\r\n        }\r\n        const prompt = PromptTemplates.operatingHours(hoursText);\r\n        return this.makeGeminiRequest(prompt, (text) => GeminiResponseParser.parseOperatingHours(text));\r\n    }\r\n    async analyzeSentiment(reviewText) {\r\n        const usageCheck = await this.checkUsageLimits();\r\n        if (!usageCheck.canMakeRequest) {\r\n            console.error('Gemini API usage limit error: Daily API limits exceeded');\r\n            return {\r\n                success: false,\r\n                error: \"That didn't work, please try again later.\",\r\n            };\r\n        }\r\n        const prompt = PromptTemplates.sentimentAnalysis(reviewText);\r\n        return this.makeGeminiRequest(prompt, (text) => GeminiResponseParser.parseSentimentAnalysis(text));\r\n    }\r\n    async enhanceFoodTruckData(rawData) {\r\n        const usageCheck = await this.checkUsageLimits();\r\n        if (!usageCheck.canMakeRequest) {\r\n            console.error('Gemini API usage limit error: Daily API limits exceeded');\r\n            return {\r\n                success: false,\r\n                error: \"That didn't work, please try again later.\",\r\n            };\r\n        }\r\n        const prompt = PromptTemplates.dataEnhancement(rawData);\r\n        return this.makeGeminiRequest(prompt, (text) => GeminiResponseParser.parseEnhancedFoodTruckData(text));\r\n    }\r\n    async batchProcess(items) {\r\n        const results = [];\r\n        for (const item of items) {\r\n            let result;\r\n            switch (item.type) {\r\n                case 'menu': {\r\n                    result = await this.processMenuData(item.data);\r\n                    break;\r\n                }\r\n                case 'location': {\r\n                    result = await this.extractLocationFromText(item.data);\r\n                    break;\r\n                }\r\n                case 'hours': {\r\n                    result = await this.standardizeOperatingHours(item.data);\r\n                    break;\r\n                }\r\n                case 'sentiment': {\r\n                    result = await this.analyzeSentiment(item.data);\r\n                    break;\r\n                }\r\n                case 'enhance': {\r\n                    result = await this.enhanceFoodTruckData(item.data); // item.data is already unknown\r\n                    break;\r\n                }\r\n                default: {\r\n                    console.error('Unknown processing type in Gemini batchProcess:', item.type);\r\n                    result = { success: false, error: \"That didn't work, please try again later.\" };\r\n                    break;\r\n                }\r\n            }\r\n            results.push(result);\r\n        }\r\n        return results;\r\n    }\r\n    async getUsageStats() {\r\n        const usage = await APIUsageService.getTodayUsage('gemini');\r\n        return usage ?? undefined;\r\n    }\r\n    async extractFoodTruckDetailsFromMarkdown(markdownContent, sourceUrl) {\r\n        const usageCheck = await this.checkUsageLimits();\r\n        if (!usageCheck.canMakeRequest) {\r\n            console.error('Gemini API usage limit error: Daily API limits exceeded for Gemini');\r\n            return {\r\n                success: false,\r\n                error: \"That didn't work, please try again later.\",\r\n            };\r\n        }\r\n        \r\n        const prompt = PromptTemplates.foodTruckExtraction(markdownContent, sourceUrl);\r\n        \r\n        // Define JSON schema for structured output\r\n        const foodTruckSchema = {\r\n            type: 'object',\r\n            properties: {\r\n                name: {\r\n                    type: ['string', 'null'],\r\n                    description: 'Food truck name or null if not confidently extractable'\r\n                },\r\n                description: {\r\n                    type: ['string', 'null'],\r\n                    description: 'Brief description of the food truck'\r\n                },\r\n                cuisine_type: {\r\n                    type: ['array', 'null'],\r\n                    items: {\r\n                        type: 'string'\r\n                    },\r\n                    description: 'Types of cuisine served'\r\n                },\r\n                contact_info: {\r\n                    type: ['object', 'null'],\r\n                    properties: {\r\n                        phone: {\r\n                            type: ['string', 'null']\r\n                        },\r\n                        email: {\r\n                            type: ['string', 'null']\r\n                        },\r\n                        website: {\r\n                            type: ['string', 'null']\r\n                        },\r\n                        social_media: {\r\n                            type: ['object', 'null'],\r\n                            properties: {\r\n                                facebook: {\r\n                                    type: ['string', 'null']\r\n                                },\r\n                                instagram: {\r\n                                    type: ['string', 'null']\r\n                                },\r\n                                twitter: {\r\n                                    type: ['string', 'null']\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                },\r\n                operating_hours: {\r\n                    type: ['object', 'null'],\r\n                    properties: {\r\n                        monday: {\r\n                            type: ['object', 'null'],\r\n                            properties: {\r\n                                open: {\r\n                                    type: ['string', 'null']\r\n                                },\r\n                                close: {\r\n                                    type: ['string', 'null']\r\n                                },\r\n                                closed: {\r\n                                    type: 'boolean'\r\n                                }\r\n                            },\r\n                            required: ['closed']\r\n                        },\r\n                        tuesday: {\r\n                            type: ['object', 'null'],\r\n                            properties: {\r\n                                open: {\r\n                                    type: ['string', 'null']\r\n                                },\r\n                                close: {\r\n                                    type: ['string', 'null']\r\n                                },\r\n                                closed: {\r\n                                    type: 'boolean'\r\n                                }\r\n                            },\r\n                            required: ['closed']\r\n                        },\r\n                        wednesday: {\r\n                            type: ['object', 'null'],\r\n                            properties: {\r\n                                open: {\r\n                                    type: ['string', 'null']\r\n                                },\r\n                                close: {\r\n                                    type: ['string', 'null']\r\n                                },\r\n                                closed: {\r\n                                    type: 'boolean'\r\n                                }\r\n                            },\r\n                            required: ['closed']\r\n                        },\r\n                        thursday: {\r\n                            type: ['object', 'null'],\r\n                            properties: {\r\n                                open: {\r\n                                    type: ['string', 'null']\r\n                                },\r\n                                close: {\r\n                                    type: ['string', 'null']\r\n                                },\r\n                                closed: {\r\n                                    type: 'boolean'\r\n                                }\r\n                            },\r\n                            required: ['closed']\r\n                        },\r\n                        friday: {\r\n                            type: ['object', 'null'],\r\n                            properties: {\r\n                                open: {\r\n                                    type: ['string', 'null']\r\n                                },\r\n                                close: {\r\n                                    type: ['string', 'null']\r\n                                },\r\n                                closed: {\r\n                                    type: 'boolean'\r\n                                }\r\n                            },\r\n                            required: ['closed']\r\n                        },\r\n                        saturday: {\r\n                            type: ['object', 'null'],\r\n                            properties: {\r\n                                open: {\r\n                                    type: ['string', 'null']\r\n                                },\r\n                                close: {\r\n                                    type: ['string', 'null']\r\n                                },\r\n                                closed: {\r\n                                    type: 'boolean'\r\n                                }\r\n                            },\r\n                            required: ['closed']\r\n                        },\r\n                        sunday: {\r\n                            type: ['object', 'null'],\r\n                            properties: {\r\n                                open: {\r\n                                    type: ['string', 'null']\r\n                                },\r\n                                close: {\r\n                                    type: ['string', 'null']\r\n                                },\r\n                                closed: {\r\n                                    type: 'boolean'\r\n                                }\r\n                            },\r\n                            required: ['closed']\r\n                        }\r\n                    }\r\n                },\r\n                menu: {\r\n                    type: ['array', 'null'],\r\n                    items: {\r\n                        type: 'object',\r\n                        properties: {\r\n                            category: {\r\n                                type: 'string'\r\n                            },\r\n                            items: {\r\n                                type: 'array',\r\n                                items: {\r\n                                    type: 'object',\r\n                                    properties: {\r\n                                        name: {\r\n                                            type: 'string'\r\n                                        },\r\n                                        description: {\r\n                                            type: ['string', 'null']\r\n                                        },\r\n                                        price: {\r\n                                            type: ['number', 'null']\r\n                                        },\r\n                                        dietary_tags: {\r\n                                            type: ['array', 'null'],\r\n                                            items: {\r\n                                                type: 'string'\r\n                                            }\r\n                                        }\r\n                                    },\r\n                                    required: ['name']\r\n                                }\r\n                            }\r\n                        },\r\n                        required: ['category', 'items']\r\n                    }\r\n                }\r\n            },\r\n            required: ['name']\r\n        };\r\n\r\n        const response = await this.apiClient.makeRequestWithParsing(\r\n            prompt,\r\n            (text) => {\r\n                const cleanedText = text.trim();\r\n                // Handle the case where name is null (should discard the truck)\r\n                if (cleanedText === '{\"name\":null}' || cleanedText === '{\"name\": null}') {\r\n                    return { name: null };\r\n                }\r\n                // Try to parse as JSON\r\n                try {\r\n                    return JSON.parse(cleanedText);\r\n                } catch {\r\n                    // If JSON parsing fails, try the response parser\r\n                    return GeminiResponseParser.parseExtractedFoodTruckDetails(cleanedText);\r\n                }\r\n            },\r\n            {\r\n                generationConfig: {\r\n                    responseMimeType: 'application/json',\r\n                    responseJsonSchema: foodTruckSchema\r\n                }\r\n            }\r\n        );\r\n\r\n        // Add promptSent to response for this specific method\r\n        return {\r\n            ...response,\r\n            promptSent: prompt,\r\n        };\r\n    }\r\n}\r\n/**\r\n* Dispatches the appropriate Gemini operation based on the provided type.\r\n* @example\r\n* dispatchGeminiOperation('menu', 'data')\r\n* Returns a promise with processed menu data response\r\n* @param {'menu' | 'location' | 'hours' | 'sentiment' | 'enhance' | 'foodTruckExtraction'} type - The type of Gemini operation to dispatch.\r\n* @param {unknown} data - Data relevant to the specified Gemini operation type.\r\n* @returns {Promise<GeminiResponse<unknown>>} Returns a promise that resolves to the Gemini operation's response.\r\n* @description\r\n*   - Operates asynchronously, ensuring the flexibility and responsiveness of Gemini processing.\r\n*   - Utilizes type assertion to correctly handle various data types pertinent to the operation.\r\n*   - If the operation type is unrecognized, the function returns an error response.\r\n*/\r\nexport async function dispatchGeminiOperation(type, data) {\r\n    switch (type) {\r\n        case 'menu': {\r\n            return gemini.processMenuData(data);\r\n        }\r\n        case 'location': {\r\n            return gemini.extractLocationFromText(data);\r\n        }\r\n        case 'hours': {\r\n            return gemini.standardizeOperatingHours(data);\r\n        }\r\n        case 'sentiment': {\r\n            return gemini.analyzeSentiment(data);\r\n        }\r\n        case 'enhance': {\r\n            return gemini.enhanceFoodTruckData(data);\r\n        }\r\n        case 'foodTruckExtraction': {\r\n            const { markdownContent, sourceUrl } = data;\r\n            return gemini.extractFoodTruckDetailsFromMarkdown(markdownContent, sourceUrl);\r\n        }\r\n        default: {\r\n            return { success: false, error: `Unknown Gemini operation type: ${String(type)}` };\r\n        }\r\n    }\r\n}\r\n// Export singleton instance\r\nexport const gemini = new GeminiService();\r\n","usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\gemini.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\gemini\\geminiApiClient.js","messages":[{"ruleId":"unicorn/no-null","severity":1,"message":"Use `undefined` instead of `null`.","line":33,"column":33,"nodeType":"Literal","messageId":"error","endLine":33,"endColumn":37,"suggestions":[{"messageId":"replace","fix":{"range":[1225,1229],"text":"undefined"},"data":{},"desc":"Replace `null` with `undefined`."}]},{"ruleId":"unicorn/no-null","severity":1,"message":"Use `undefined` instead of `null`.","line":41,"column":25,"nodeType":"Literal","messageId":"error","endLine":41,"endColumn":29,"suggestions":[{"messageId":"replace","fix":{"range":[1445,1449],"text":"undefined"},"data":{},"desc":"Replace `null` with `undefined`."}]},{"ruleId":"sonarjs/prefer-single-boolean-return","severity":2,"message":"Replace this if-then-else flow by a single return statement.","line":53,"column":9,"nodeType":"IfStatement","messageId":"replaceIfThenElseByReturn","endLine":53,"endColumn":59,"suggestions":[{"messageId":"suggest","fix":{"range":[1882,1978],"text":"return errorInfo.type === 'PARSE_ERROR';"},"desc":"Replace with single return statement"}]},{"ruleId":"sonarjs/pseudo-random","severity":2,"message":"Make sure that using this pseudorandom number generator is safe here.","line":64,"column":24,"nodeType":"CallExpression","messageId":"safeGenerator","endLine":64,"endColumn":37},{"ruleId":"unicorn/numeric-separators-style","severity":2,"message":"Invalid group length in numeric value.","line":69,"column":52,"nodeType":"Literal","messageId":"numeric-separators-style","endLine":69,"endColumn":57,"fix":{"range":[2500,2505],"text":"30_000"}},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error, info.","line":89,"column":17,"nodeType":"MemberExpression","messageId":"limited","endLine":89,"endColumn":28,"suggestions":[{"fix":{"range":[3019,3094],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error, info.","line":122,"column":21,"nodeType":"MemberExpression","messageId":"limited","endLine":122,"endColumn":34,"suggestions":[{"fix":{"range":[4742,4814],"text":""},"messageId":"removeConsole","data":{"propertyName":"debug"},"desc":"Remove the console.debug()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error, info.","line":125,"column":17,"nodeType":"MemberExpression","messageId":"limited","endLine":125,"endColumn":28,"suggestions":[{"fix":{"range":[4869,4946],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error, info.","line":141,"column":21,"nodeType":"MemberExpression","messageId":"limited","endLine":141,"endColumn":32,"suggestions":[{"fix":{"range":[5598,5682],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"sonarjs/slow-regex","severity":2,"message":"Make sure the regex used here, which is vulnerable to super-linear runtime due to backtracking, cannot lead to denial of service.","line":169,"column":22,"nodeType":"Literal","endLine":169,"endColumn":35},{"ruleId":"unicorn/prefer-string-replace-all","severity":2,"message":"Prefer `String#replaceAll()` over `String#replace()`.","line":175,"column":14,"nodeType":"Identifier","messageId":"method","endLine":175,"endColumn":21,"fix":{"range":[6794,6801],"text":"All('\\\\\\''"}},{"ruleId":"unicorn/prefer-string-replace-all","severity":2,"message":"Prefer `String#replaceAll()` over `String#replace()`.","line":176,"column":14,"nodeType":"Identifier","messageId":"method","endLine":176,"endColumn":21,"fix":{"range":[6859,6859],"text":"All"}},{"ruleId":"unicorn/prefer-string-replace-all","severity":2,"message":"Prefer `String#replaceAll()` over `String#replace()`.","line":177,"column":14,"nodeType":"Identifier","messageId":"method","endLine":177,"endColumn":21,"fix":{"range":[6933,6940],"text":"All('\\\\n'"}},{"ruleId":"unicorn/prefer-string-replace-all","severity":2,"message":"Prefer `String#replaceAll()` over `String#replace()`.","line":178,"column":14,"nodeType":"Identifier","messageId":"method","endLine":178,"endColumn":21,"fix":{"range":[6992,6999],"text":"All('\\\\t'"}}],"suppressedMessages":[],"errorCount":8,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":5,"fixableWarningCount":0,"source":"import { GoogleGenAI } from '@google/genai';\r\n\r\nexport class GeminiApiClient {\r\n    constructor() {\r\n        this.modelName = 'gemini-2.0-flash-lite-001';\r\n        const apiKey = process.env.GEMINI_API_KEY;\r\n        if (apiKey == undefined || apiKey === '') {\r\n            throw new Error('GEMINI_API_KEY environment variable is not set or is empty.');\r\n        }\r\n        this.genAI = new GoogleGenAI(apiKey);\r\n    }\r\n\r\n    /**\r\n     * Classify Gemini API errors for appropriate handling\r\n     */\r\n    classifyError(error) {\r\n        // Check if it's an HTTP error with status code\r\n        if (error && typeof error === 'object') {\r\n            if (error.status) {\r\n                return {\r\n                    type: 'HTTP_ERROR',\r\n                    message: error.message || 'HTTP Error',\r\n                    statusCode: error.status,\r\n                    statusText: error.statusText || 'Unknown status'\r\n                };\r\n            }\r\n            \r\n            // Check for response-related errors\r\n            if (error.message && error.message.includes('JSON')) {\r\n                return {\r\n                    type: 'PARSE_ERROR',\r\n                    message: error.message,\r\n                    statusCode: null\r\n                };\r\n            }\r\n        }\r\n        \r\n        return {\r\n            type: 'UNKNOWN_ERROR',\r\n            message: error instanceof Error ? error.message : 'Unknown error',\r\n            statusCode: null\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Determine if an error should be retried\r\n     */\r\n    shouldRetry(errorInfo) {\r\n        // Retry on rate limits, server errors, and service unavailability\r\n        if (errorInfo.statusCode === 429) return true; // Rate limit\r\n        if (errorInfo.statusCode === 500) return true; // Internal server error\r\n        if (errorInfo.statusCode === 503) return true; // Service unavailable\r\n        if (errorInfo.type === 'PARSE_ERROR') return true; // JSON parsing issues\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Calculate delay with exponential backoff and jitter\r\n     */\r\n    calculateDelay(baseDelay, attempt, errorInfo) {\r\n        const exponentialDelay = baseDelay * Math.pow(2, attempt - 1);\r\n        \r\n        // Add jitter to prevent thundering herd\r\n        const jitter = Math.random() * 0.1 * exponentialDelay;\r\n        \r\n        // For rate limits, use longer delays\r\n        const multiplier = errorInfo.statusCode === 429 ? 2 : 1;\r\n        \r\n        return Math.min(exponentialDelay + jitter, 30000) * multiplier; // Max 30 seconds\r\n    }\r\n\r\n    /**\r\n     * Sleep utility\r\n     */\r\n    sleep(ms) {\r\n        return new Promise(resolve => setTimeout(resolve, ms));\r\n    }\r\n\r\n    /**\r\n     * Enhanced API request with retry logic\r\n     */\r\n    async makeRequest(prompt, config = {}) {\r\n        let attempt = 0;\r\n        const maxRetries = config.maxRetries ?? 3;\r\n        const baseDelay = config.baseDelay ?? 1000; // 1 second\r\n        \r\n        while (attempt <= maxRetries) {\r\n            try {\r\n                console.log(`Gemini API Request attempt ${attempt + 1}/${maxRetries + 1}`);\r\n                \r\n                const generationConfig = {\r\n                    temperature: config.temperature ?? 0,\r\n                    ...config.generationConfig\r\n                };\r\n                \r\n                const result = await this.genAI.models.generateContent({\r\n                    model: this.modelName,\r\n                    contents: [{ role: 'user', parts: [{ text: prompt }] }],\r\n                    config: generationConfig,\r\n                });\r\n                \r\n                // Extract text from the response\r\n                let textOutput = '';\r\n                if (result.candidates && result.candidates.length > 0) {\r\n                    const candidate = result.candidates[0];\r\n                    if (candidate.content && candidate.content.parts && candidate.content.parts.length > 0) {\r\n                        textOutput = candidate.content.parts[0].text ?? '';\r\n                    }\r\n                }\r\n                \r\n                const tokensUsed = result.usageMetadata?.totalTokenCount ??\r\n                    Math.ceil((prompt.length + textOutput.length) / 4);\r\n                \r\n                // Track usage asynchronously (optional)\r\n                try {\r\n                    const { APIUsageService } = await import('../supabase/services/apiUsageService.js');\r\n                    APIUsageService.trackUsage('gemini', 1, tokensUsed).catch((error) => {\r\n                        console.warn('Failed to track API usage:', error);\r\n                    });\r\n                } catch (importError) {\r\n                    // API usage tracking is optional, continue without it\r\n                    console.debug('API usage tracking not available:', importError.message);\r\n                }\r\n                \r\n                console.log(`Gemini API Request successful after ${attempt + 1} attempt(s)`);\r\n                return {\r\n                    success: true,\r\n                    data: textOutput,\r\n                    tokensUsed,\r\n                };\r\n            }\r\n            catch (error) {\r\n                attempt++;\r\n                const errorInfo = this.classifyError(error);\r\n                \r\n                console.error(`Gemini API Request attempt ${attempt} failed:`, errorInfo);\r\n                \r\n                // Check if retry is appropriate\r\n                if (attempt <= maxRetries && this.shouldRetry(errorInfo)) {\r\n                    const delay = this.calculateDelay(baseDelay, attempt, errorInfo);\r\n                    console.log(`Retrying in ${delay}ms... (attempt ${attempt + 1}/${maxRetries + 1})`);\r\n                    await this.sleep(delay);\r\n                    continue;\r\n                }\r\n                \r\n                // Final error handling\r\n                const tokensUsed = Math.ceil((prompt.length + (error instanceof Error ? error.message.length : String(error).length)) / 4);\r\n                return {\r\n                    success: false,\r\n                    error: errorInfo.message,\r\n                    errorType: errorInfo.type,\r\n                    statusCode: errorInfo.statusCode,\r\n                    tokensUsed,\r\n                };\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Clean response data to fix common JSON issues\r\n     */\r\n    cleanResponseData(text) {\r\n        if (!text) return text;\r\n        \r\n        // Remove common problematic patterns\r\n        let cleaned = text\r\n            .trim()\r\n            .replace(/^\\s*```(?:json|yaml)?\\s*/i, '')\r\n            .replace(/\\s*```\\s*$/i, '')\r\n            .replace(/^\\s*(?:json|yaml):\\s*/i, '')\r\n            .trim();\r\n        \r\n        // Fix common JSON escaping issues\r\n        cleaned = cleaned\r\n            .replace(/\\\\'/g, \"'\")  // Fix single quote escaping\r\n            .replace(/([^\\\\])\\\\\"/g, '$1\"')  // Fix double quote escaping\r\n            .replace(/\\\\n/g, '\\n')  // Normalize newlines\r\n            .replace(/\\\\t/g, '\\t'); // Normalize tabs\r\n        \r\n        return cleaned;\r\n    }\r\n\r\n    /**\r\n     * Enhanced request with parsing and retry logic\r\n     */\r\n    async makeRequestWithParsing(prompt, parser, config = {}) {\r\n        const maxParseRetries = 3;\r\n        let parseAttempt = 0;\r\n        \r\n        while (parseAttempt < maxParseRetries) {\r\n            parseAttempt++;\r\n            \r\n            const response = await this.makeRequest(prompt, config);\r\n            if (!response.success) {\r\n                return response;\r\n            }\r\n            \r\n            try {\r\n                if (!response.data) {\r\n                    return {\r\n                        success: false,\r\n                        error: 'No data received from Gemini API',\r\n                        tokensUsed: response.tokensUsed,\r\n                    };\r\n                }\r\n                \r\n                // Clean the response data\r\n                const cleanedData = this.cleanResponseData(response.data);\r\n                const parsedData = parser(cleanedData);\r\n                \r\n                return {\r\n                    success: true,\r\n                    data: parsedData,\r\n                    tokensUsed: response.tokensUsed,\r\n                };\r\n            }\r\n            catch (parseError) {\r\n                console.warn(`Gemini JSON parsing attempt ${parseAttempt} failed:`, parseError);\r\n                \r\n                // If this is the last attempt, return the error\r\n                if (parseAttempt >= maxParseRetries) {\r\n                    console.warn('Problematic Gemini raw response text:', response.data?.trim() ?? 'No data');\r\n                    return {\r\n                        success: false,\r\n                        error: `Failed to parse Gemini response after ${maxParseRetries} attempts: ${parseError instanceof Error ? parseError.message : String(parseError)}. Response text: ${response.data?.trim().slice(0, 200) ?? 'No data'}...`,\r\n                        tokensUsed: response.tokensUsed,\r\n                    };\r\n                }\r\n                \r\n                // Wait before retry\r\n                await this.sleep(1000 * parseAttempt);\r\n            }\r\n        }\r\n    }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\gemini\\geminiApiClient.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":104,"column":6,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":104,"endColumn":19,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[4470,4484],"text":"response.data == null"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[4471,4484],"text":"(response.data ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[4470,4484],"text":"!Boolean(response.data)"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { GoogleGenAI } from '@google/genai';\r\nimport { APIUsageService } from '../supabase';\r\nimport type { GeminiResponse } from '../types';\r\n\r\nexport interface GeminiApiConfig {\r\n  temperature?: number;\r\n  maxTokens?: number;\r\n}\r\n\r\nexport class GeminiApiClient {\r\n  private genAI: GoogleGenAI;\r\n  private modelName: string;\r\n\r\n  constructor() {\r\n    const apiKey = process.env.GEMINI_API_KEY;\r\n    if (apiKey == undefined || apiKey === '') {\r\n      throw new Error('GEMINI_API_KEY environment variable is not set or is empty.');\r\n    }\r\n    this.genAI = new GoogleGenAI({ apiKey });\r\n    this.modelName = 'gemini-2.0-flash-lite-001';\r\n  }\r\n\r\n  /**\r\n  * Makes an API request to generate content based on the provided prompt and configuration.\r\n  * @example\r\n  * makeRequest('Create a poem about nature', { temperature: 0.7 })\r\n  * Returns a promise that resolves to a GeminiResponse containing the generated text and token usage.\r\n  * @param {string} prompt - The input prompt for content generation.\r\n  * @param {GeminiApiConfig} config - Configuration settings for the API request, such as temperature. Defaults to an empty object.\r\n  * @returns {Promise<GeminiResponse<T>>} A promise that resolves to a GeminiResponse with the generated content or an error message.\r\n  * @description\r\n  *   - The function calculates the number of tokens used for tracking purposes, even in case of an error.\r\n  *   - The `temperature` parameter affects the randomness of the content generation, with higher values resulting in more creative outputs.\r\n  *   - API usage is tracked asynchronously, and warnings are logged if tracking fails.\r\n  *   - Returns an object indicating success status, the generated content or error message, and the number of tokens used.\r\n  */\r\n  async makeRequest<T>(prompt: string, config: GeminiApiConfig = {}): Promise<GeminiResponse<T>> {\r\n    let textOutput: string = '';\r\n\r\n    try {\r\n      const sdkResponse = await this.genAI.models.generateContent({\r\n        model: this.modelName,\r\n        contents: [{ role: 'user', parts: [{ text: prompt }] }],\r\n        config: { temperature: config.temperature ?? 0 },\r\n      });\r\n\r\n      textOutput = sdkResponse.text ?? '';\r\n\r\n      const tokensUsed =\r\n        sdkResponse.usageMetadata?.totalTokenCount ??\r\n        Math.ceil((prompt.length + textOutput.length) / 4);\r\n\r\n      // Track usage asynchronously\r\n      APIUsageService.trackUsage('gemini', 1, tokensUsed).catch((error) => {\r\n        console.warn('Failed to track API usage:', error);\r\n      });\r\n\r\n      return {\r\n        success: true,\r\n        data: textOutput,\r\n        tokensUsed,\r\n      } as GeminiResponse<T>;\r\n    } catch (error: unknown) {\r\n      const tokensUsed = Math.ceil(\r\n        (prompt.length + (error instanceof Error ? error.message.length : String(error).length)) /\r\n          4,\r\n      );\r\n\r\n      return {\r\n        success: false,\r\n        error: error instanceof Error ? error.message : 'Unknown error',\r\n        tokensUsed,\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Executes a request using a specified prompt and attempts to parse the response using the provided parser function.\r\n   * @example\r\n   * makeRequestWithParsing(\"example prompt\", (text) => JSON.parse(text))\r\n   * { success: true, data: { key: \"value\" }, tokensUsed: 100 }\r\n   * @param {string} prompt - The prompt used to make the API request.\r\n   * @param {function} parser - A function to parse the response text into the desired format.\r\n   * @param {GeminiApiConfig} config - Optional configuration settings for the Gemini API request.\r\n   * @returns {Promise<GeminiResponse<T>>} A promise resolving to a GeminiResponse object containing either the parsed data or an error description.\r\n   * @description\r\n   *   - The function makes an asynchronous request using a specific prompt string and configuration.\r\n   *   - If the response is unsuccessful, it returns the original response cast to the expected return type.\r\n   *   - Parses the successful response data using the provided parser function.\r\n   *   - Handles parsing errors gracefully, returning a detailed error message and logs the raw problematic response.\r\n   */\r\n  async makeRequestWithParsing<T>(\r\n    prompt: string,\r\n    parser: (text: string) => T,\r\n    config: GeminiApiConfig = {},\r\n  ): Promise<GeminiResponse<T>> {\r\n    const response = await this.makeRequest<string>(prompt, config);\r\n\r\n    if (!response.success) {\r\n      return response as GeminiResponse<T>;\r\n    }\r\n\r\n    try {\r\nif (!response.data) {\r\n        return {\r\n          success: false,\r\n          error: 'No data received from Gemini API',\r\n          tokensUsed: response.tokensUsed,\r\n        };\r\n      }\r\n      const parsedData = parser(response.data);\r\n      return {\r\n        success: true,\r\n        data: parsedData,\r\n        tokensUsed: response.tokensUsed,\r\n      };\r\n    } catch (parseError: unknown) {\r\n      console.warn('Gemini json parsing error:', parseError);\r\n      console.warn('Problematic Gemini raw response text:', response.data?.trim() ?? 'No data');\r\n\r\n      return {\r\n        success: false,\r\n        error: `Failed to parse Gemini response: ${parseError instanceof Error ? parseError.message : String(parseError)}. Response text: ${response.data?.trim().slice(0, 200) ?? 'No data'}...`,\r\n        tokensUsed: response.tokensUsed,\r\n      };\r\n    }\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\gemini\\promptTemplates.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\gemini\\promptTemplates.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":223,"column":3,"nodeType":"Identifier","messageId":"conditionErrorNullableString","endLine":223,"endColumn":12,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[7319,7328],"text":"(sourceUrl != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[7319,7328],"text":"(sourceUrl ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[7319,7328],"text":"(Boolean(sourceUrl))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"export const PromptTemplates = {\r\n  menuProcessing: (rawMenuText: string) => `\r\nParse the following food truck menu text and return a structured JSON format.\r\nExtract menu items with categories, names, descriptions, prices, and dietary tags.\r\n\r\nMenu text:\r\n${rawMenuText}\r\n\r\nExpected JSON format:\r\n[\r\n  {\r\n    \"category\": \"string\",\r\n    \"items\": [\r\n      {\r\n        \"name\": \"string\",\r\n        \"description\": \"string\",\r\n        \"price\": number,\r\n        \"dietary_tags\": [\"string\"]\r\n      }\r\n    ]\r\n  }\r\n]\r\n\r\nRules:\r\n- Extract actual prices as numbers (e.g., 12.99, not \"$12.99\")\r\n- Include dietary restrictions and special tags\r\n- Group items into logical categories\r\n- If no clear categories, use \"Main Items\"\r\n- Return only the json, no additional text\r\n  `,\r\n\r\n  locationExtraction: (textInput: string) => `\r\nExtract location information from the following text and return structured data.\r\nLook for addresses, cross streets, landmarks, or location descriptions.\r\n\r\nText:\r\n${textInput}\r\n\r\nExpected JSON format:\r\n{\r\n  \"address\": \"string or undefined\",\r\n  \"city\": \"string or undefined\", \r\n  \"state\": \"string or undefined\",\r\n  \"zipCode\": \"string or undefined\",\r\n  \"coordinates\": {\"lat\": number, \"lng\": number} or undefined,\r\n  \"confidence\": number,\r\n  \"landmarks\": [\"string\"]\r\n}\r\n\r\nRules:\r\n- Set coordinates to undefined if not explicitly provided\r\n- Confidence should be 0.0 to 1.0 based on clarity\r\n- Include any mentioned landmarks or cross streets\r\n- Return only the json, no additional text\r\n  `,\r\n\r\n  operatingHours: (hoursText: string) => `\r\nParse the following operating hours text and return standardized format.\r\nConvert all times to 24-hour format and handle various input formats.\r\n\r\nHours text:\r\n${hoursText}\r\n\r\nExpected JSON format:\r\n{\r\n  \"monday\": {\"open\": \"HH:MM\", \"close\": \"HH:MM\", \"closed\": false},\r\n  \"tuesday\": {\"open\": \"HH:MM\", \"close\": \"HH:MM\", \"closed\": false},\r\n  \"wednesday\": {\"open\": \"HH:MM\", \"close\": \"HH:MM\", \"closed\": false},\r\n  \"thursday\": {\"open\": \"HH:MM\", \"close\": \"HH:MM\", \"closed\": false},\r\n  \"friday\": {\"open\": \"HH:MM\", \"close\": \"HH:MM\", \"closed\": false},\r\n  \"saturday\": {\"open\": \"HH:MM\", \"close\": \"HH:MM\", \"closed\": false},\r\n  \"sunday\": {\"open\": \"HH:MM\", \"close\": \"HH:MM\", \"closed\": false}\r\n}\r\n\r\nRules:\r\n- Use 24-hour format (e.g., \"14:30\" for 2:30 pm)\r\n- If closed on a day, set \"closed\": true and omit open/close times\r\n- Handle ranges like \"Mon-Fri\" by applying to all days in range\r\n- Default to reasonable hours if ambiguous\r\n- Return only the json, no additional text\r\n  `,\r\n\r\n  sentimentAnalysis: (reviewText: string) => `\r\nAnalyze the sentiment of this food truck review and extract key insights.\r\nFocus on food quality, service, value, and overall experience.\r\n\r\nReview text:\r\n${reviewText}\r\n\r\nExpected JSON format:\r\n{\r\n  \"score\": number,\r\n  \"confidence\": number,\r\n  \"aspects\": {\r\n    \"food_quality\": number,\r\n    \"service\": number,\r\n    \"value\": number,\r\n    \"overall\": number\r\n  },\r\n  \"summary\": \"string\",\r\n  \"keywords\": [\"string\"]\r\n}\r\n\r\nRules:\r\n- Score should be 0.0 (very negative) to 1.0 (very positive)\r\n- Confidence should be 0.0 to 1.0 based on clarity of sentiment\r\n- Include specific aspects mentioned in the review\r\n- Summary should be 1-2 sentences max\r\n- Return only the json, no additional text\r\n  `,\r\n\r\n  dataEnhancement: (rawData: unknown) => `\r\nEnhance and standardize the following food truck data.\r\nFill in missing information where possible and improve data quality.\r\n\r\nRaw data:\r\n${JSON.stringify(rawData, undefined, 2)}\r\n\r\nExpected JSON format:\r\n{\r\n  \"name\": \"string\",\r\n  \"description\": \"string\",\r\n  \"cuisine_type\": \"string\",\r\n  \"price_range\": \"$ | $$ | $$$ | $$$$\",\r\n  \"contact\": {\r\n    \"phone\": \"string\",\r\n    \"email\": \"string\",\r\n    \"website\": \"string\",\r\n    \"social_media\": {}\r\n  },\r\n  \"location\": {\r\n    \"address\": \"string\",\r\n    \"city\": \"string\",\r\n    \"state\": \"string\",\r\n    \"coordinates\": {\"lat\": number, \"lng\": number}\r\n  },\r\n  \"operating_hours\": {},\r\n  \"menu_categories\": [\"string\"],\r\n  \"specialties\": [\"string\"],\r\n  \"dietary_options\": [\"string\"]\r\n}\r\n\r\nRules:\r\n- Preserve all original data while enhancing it\r\n- Standardize naming conventions\r\n- Infer cuisine type from menu items\r\n- Estimate price range from menu prices\r\n- Return only the json, no additional text\r\n  `,\r\n\r\n  foodTruckExtraction: (markdownContent: string, sourceUrl?: string) => {\r\n    const schema = `\r\nExpected JSON schema:\r\n{\r\n  \"name\": \"string (food truck name)\",\r\n  \"description\": \"string (brief description of the food truck)\",\r\n  \"cuisine_type\": \"string (type of cuisine served)\",\r\n  \"contact\": {\r\n    \"phone\": \"string (phone number if found)\",\r\n    \"email\": \"string (email if found)\", \r\n    \"website\": \"string (website URL if found)\",\r\n    \"social_media\": {\r\n      \"facebook\": \"string (Facebook URL if found)\",\r\n      \"instagram\": \"string (Instagram URL if found)\",\r\n      \"twitter\": \"string (Twitter URL if found)\"\r\n    }\r\n  },\r\n  \"location\": {\r\n    \"address\": \"string (physical address if found)\",\r\n    \"city\": \"string (city name)\",\r\n    \"state\": \"string (state abbreviation)\",\r\n    \"coordinates\": {\r\n      \"lat\": \"number (latitude if found)\",\r\n      \"lng\": \"number (longitude if found)\"\r\n    }\r\n  },\r\n  \"operating_hours\": {\r\n    \"monday\": {\"open\": \"string (HH:MM)\", \"close\": \"string (HH:MM)\", \"closed\": \"boolean\"},\r\n    \"tuesday\": {\"open\": \"string (HH:MM)\", \"close\": \"string (HH:MM)\", \"closed\": \"boolean\"},\r\n    \"wednesday\": {\"open\": \"string (HH:MM)\", \"close\": \"string (HH:MM)\", \"closed\": \"boolean\"},\r\n    \"thursday\": {\"open\": \"string (HH:MM)\", \"close\": \"string (HH:MM)\", \"closed\": \"boolean\"},\r\n    \"friday\": {\"open\": \"string (HH:MM)\", \"close\": \"string (HH:MM)\", \"closed\": \"boolean\"},\r\n    \"saturday\": {\"open\": \"string (HH:MM)\", \"close\": \"string (HH:MM)\", \"closed\": \"boolean\"},\r\n    \"sunday\": {\"open\": \"string (HH:MM)\", \"close\": \"string (HH:MM)\", \"closed\": \"boolean\"}\r\n  },\r\n  \"menu\": [\r\n    {\r\n      \"category\": \"string (menu category)\",\r\n      \"items\": [\r\n        {\r\n          \"name\": \"string (item name)\",\r\n          \"description\": \"string (item description)\",\r\n          \"price\": \"number (price as number, not string)\",\r\n          \"dietary_tags\": [\"string (dietary restrictions/tags)\"]\r\n        }\r\n      ]\r\n    }\r\n  ],\r\n  \"specialties\": [\"string (signature dishes or specialties)\"],\r\n  \"dietary_options\": [\"string (dietary accommodations like vegan, gluten-free)\"],\r\n  \"price_range\": \"string ($ for under $10, $$ for $10-20, $$$ for $20-30, $$$$ for over $30)\"\r\n}\r\n`;\r\n\r\n    const instructions = `\r\nInstructions:\r\n- Extract as much information as possible from the provided content\r\n- If information is not available, use null for the field\r\n- For operating hours, use 24-hour format (e.g., \"14:30\" for 2:30 PM)\r\n- If a day is closed, set \"closed\": true and omit open/close times\r\n- For prices, extract numeric values only (e.g., 12.99, not \"$12.99\")\r\n- Be thorough in extracting menu items and their details\r\n- Look for social media links and contact information carefully\r\n- Return only the JSON object, no additional text or formatting\r\n`;\r\n\r\n    return `\r\nYou are an ai assistant tasked with extracting structured information about food trucks from their website content (provided in Markdown format). Your goal is to populate a json object with the following schema. Only return the json object, nothing else.\r\n\r\nWebsite content:\r\n${markdownContent}\r\n\r\n${sourceUrl ? `Source URL: ${sourceUrl}` : ''}\r\n\r\n${schema}\r\n\r\n${instructions}\r\n`;\r\n  },\r\n};\r\n","usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\gemini\\responseParser.js","messages":[{"ruleId":"sonarjs/slow-regex","severity":2,"message":"Make sure the regex used here, which is vulnerable to super-linear runtime due to backtracking, cannot lead to denial of service.","line":30,"column":53,"nodeType":"Literal","endLine":30,"endColumn":82},{"ruleId":"unicorn/catch-error-name","severity":2,"message":"The catch parameter `e` should be named `error`.","line":34,"column":30,"nodeType":"Identifier","messageId":"catch-error-name","endLine":34,"endColumn":31,"fix":{"range":[1402,1489],"text":"error) {\n                        console.error(\"Aggressive JSON extraction also failed.\", error"}}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":1,"fixableWarningCount":0,"source":"import yaml from 'js-yaml';\n\nexport const GeminiResponseParser = {\n    parseStructuredData(text) {\n        // Clean up the response text for YAML\n        let cleanedText = text\n            .replaceAll(/```yaml\\s*/g, '')\n            .replaceAll(/```\\s*/g, '')\n            .replaceAll(/^\\s*yaml\\s*/g, '')\n            .trim();\n\n        try {\n            return yaml.load(cleanedText);\n        } catch (yamlError) {\n            console.warn(\"YAML parse failed. Attempting JSON parse.\", yamlError);\n            // Fallback to JSON parsing if YAML fails\n            cleanedText = text\n                .replaceAll(/```json\\s*/g, '')\n                .replaceAll(/```\\s*/g, '')\n                .replaceAll(/^\\s*json\\s*/g, '')\n                .trim();\n            try {\n                return JSON.parse(cleanedText);\n            } catch (jsonError) {\n                console.error(\"Initial JSON parse failed. Attempting aggressive extraction.\", jsonError);\n                console.error(\"Problematic text:\", cleanedText);\n                console.error(\"Original raw response text:\", text);\n\n                // Attempt to extract JSON using regex for more robustness\n                const jsonMatch = cleanedText.match(/(\\{[\\s\\S]*\\})|(\\[[\\s\\S]*\\])/);\n                if (jsonMatch && jsonMatch[0]) {\n                    try {\n                        return JSON.parse(jsonMatch[0]);\n                    } catch (e) {\n                        console.error(\"Aggressive JSON extraction also failed.\", e);\n                        throw new Error(\"Failed to parse Gemini response even after aggressive extraction.\");\n                    }\n                }\n                throw new Error(\"Failed to parse Gemini response: No valid YAML or JSON structure found.\");\n            }\n        }\n    },\n    parseMenuData(text) {\n        return this.parseStructuredData(text);\n    },\n    parseLocationData(text) {\n        return this.parseStructuredData(text);\n    },\n    parseOperatingHours(text) {\n        return this.parseStructuredData(text);\n    },\n    parseSentimentAnalysis(text) {\n        return this.parseStructuredData(text);\n    },\n    parseEnhancedFoodTruckData(text) {\n        return this.parseStructuredData(text);\n    },\n    parseExtractedFoodTruckDetails(text) {\n        return this.parseStructuredData(text);\n    },\n    cleanMarkdownResponse(text) {\n        // This function is now less critical as parseStructuredData handles cleaning\n        // but keeping it for consistency if other parts of the code use it.\n        return text\n            .replaceAll(/```yaml\\s*/g, '')\n            .replaceAll(/```json\\s*/g, '')\n            .replaceAll(/```\\s*/g, '')\n            .replaceAll(/^\\s*yaml\\s*/g, '')\n            .replaceAll(/^\\s*json\\s*/g, '')\n            .trim();\n    },\n};\n","usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\gemini\\responseParser.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\gemini\\usageLimits.js","messages":[{"ruleId":null,"nodeType":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token =","line":4,"column":27}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { APIUsageService } from '../supabase/services/apiUsageService.js';\r\nimport { APIMonitor } from '../monitoring/apiMonitor.js';\r\nexport class GeminiUsageLimits {\r\n    static DEFAULT_LIMITS = {\r\n        dailyRequestLimit: 1500,\r\n        dailyTokenLimit: 32_000,\r\n    };\r\n    /**\r\n     * Checks the current usage against predefined limits and determines if further requests can be made.\r\n     * @example\r\n     * checkUsageLimits()\r\n     * { canMakeRequest: true, usage: { requests: { used: 50, limit: 1000, remaining: 950 }, tokens: { used: 200, limit: 5000, remaining: 4800 } } }\r\n     * @param {UsageLimits} limits - Object containing usage limits for requests and tokens.\r\n     * @returns {Promise<UsageCheck>} Object indicating if a request can be made and the current usage statistics.\r\n     * @description\r\n     *   - Attempts to fetch today's usage data from the APIUsageService for 'gemini'.\r\n     *   - If the fetch fails, defaults to allowing the request with a warning.\r\n     *   - Maintains a buffer of 100 tokens to ensure requests are not made when limits are too close.\r\n     */\r\n    static async checkUsageLimits(limits = this.DEFAULT_LIMITS) {\r\n        try {\r\n            const usage = await APIUsageService.getTodayUsage('gemini');\r\n            if (!usage) {\r\n                return { canMakeRequest: true };\r\n            }\r\n            const requestsUsed = usage.requests_count ?? 0;\r\n            const tokensUsed = usage.tokens_used ?? 0;\r\n            const requestsRemaining = limits.dailyRequestLimit - requestsUsed;\r\n            const tokensRemaining = limits.dailyTokenLimit - tokensUsed;\r\n            return {\r\n                canMakeRequest: requestsRemaining > 0 && tokensRemaining > 100, // Keep 100 token buffer\r\n                usage: {\r\n                    requests: {\r\n                        used: requestsUsed,\r\n                        limit: limits.dailyRequestLimit,\r\n                        remaining: requestsRemaining,\r\n                    },\r\n                    tokens: {\r\n                        used: tokensUsed,\r\n                        limit: limits.dailyTokenLimit,\r\n                        remaining: tokensRemaining,\r\n                    },\r\n                },\r\n            };\r\n        }\r\n        catch (error) {\r\n            console.warn('Error checking Gemini usage limits:', error);\r\n            return { canMakeRequest: false };\r\n        }\r\n    }\r\n    /**\r\n    * Checks if a request can be made with monitoring and returns whether the operation is allowed.\r\n    * @example\r\n    * checkWithMonitoring(100, DEFAULT_LIMITS)\r\n    * { allowed: true }\r\n    * @param {number} estimatedTokens - Number of estimated tokens for the request.\r\n    * @param {UsageLimits} _limits - Usage limits configuration for requests (default provided internally).\r\n    * @returns {Promise<{ allowed: boolean; reason?: string; waitTime?: number }>} Object indicating if the request is allowed and why not if denied.\r\n    * @description\r\n    *   - Uses an internal API monitor to check if requests can be made based on predefined limits.\r\n    *   - Wait time is converted from milliseconds to minutes before being returned.\r\n    */\r\n    static async checkWithMonitoring(estimatedTokens, _limits = this.DEFAULT_LIMITS) {\r\n        const canMakeRequest = await APIMonitor.canMakeRequest('gemini', 1, estimatedTokens);\r\n        if (!canMakeRequest.allowed) {\r\n            return {\r\n                allowed: false,\r\n                reason: `API limit reached: ${canMakeRequest.reason}. Wait time: ${Math.ceil((canMakeRequest.waitTime ?? 0) / 1000 / 60)} minutes`,\r\n            };\r\n        }\r\n        return { allowed: true };\r\n    }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\gemini\\usageLimits.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\mappers\\uprootedVeganMapper.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\mappers\\uprootedVeganMapper.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":56,"column":53,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":56,"endColumn":56,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1363,1366],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1363,1366],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":57,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":57,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1396,1399],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1396,1399],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected value in conditional. A boolean expression is required.","line":104,"column":8,"nodeType":"Identifier","messageId":"conditionErrorOther","endLine":104,"endColumn":19},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected value in conditional. A boolean expression is required.","line":118,"column":8,"nodeType":"Identifier","messageId":"conditionErrorOther","endLine":118,"endColumn":19},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":147,"column":47,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":147,"endColumn":49,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[3709,3753],"text":"(data.exact_location ?? data.current_location)"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":147,"column":72,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":147,"endColumn":74,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[3754,3756],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":166,"column":18,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":166,"endColumn":43,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[4355,4380],"text":"(primaryLocation.timestamp != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[4355,4380],"text":"(primaryLocation.timestamp ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[4355,4380],"text":"(Boolean(primaryLocation.timestamp))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":166,"column":44,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":166,"endColumn":46,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[4381,4383],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":176,"column":22,"nodeType":"TSAsExpression","messageId":"conditionErrorObject","endLine":176,"endColumn":60},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":177,"column":12,"nodeType":"TSAsExpression","messageId":"conditionErrorObject","endLine":177,"endColumn":39},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":180,"column":37,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":180,"endColumn":39,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[4783,4785],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":181,"column":37,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":181,"endColumn":39,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[4827,4829],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":185,"column":51,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":185,"endColumn":53,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[5010,5012],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":189,"column":22,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":189,"endColumn":42,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[5135,5155],"text":"(data.last_scraped_at != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[5135,5155],"text":"(data.last_scraped_at ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[5135,5155],"text":"(Boolean(data.last_scraped_at))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":189,"column":43,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":189,"endColumn":45,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[5156,5158],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":190,"column":17,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":190,"endColumn":32,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[5181,5196],"text":"(data.created_at != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[5181,5196],"text":"(data.created_at ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[5181,5196],"text":"(Boolean(data.created_at))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":190,"column":33,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":190,"endColumn":35,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[5197,5199],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":191,"column":17,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":191,"endColumn":32,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[5222,5237],"text":"(data.updated_at != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[5222,5237],"text":"(data.updated_at ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[5222,5237],"text":"(Boolean(data.updated_at))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":191,"column":33,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":191,"endColumn":35,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[5238,5240],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected value in conditional. A boolean expression is required.","line":215,"column":8,"nodeType":"MemberExpression","messageId":"conditionErrorOther","endLine":215,"endColumn":25},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":222,"column":7,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":222,"endColumn":17,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[6067,6077],"text":"(data.state != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[6067,6077],"text":"(data.state ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[6067,6077],"text":"(Boolean(data.state))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":227,"column":7,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":227,"endColumn":19,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[6277,6289],"text":"(data.user_id != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[6277,6289],"text":"(data.user_id ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[6277,6289],"text":"(Boolean(data.user_id))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]}],"suppressedMessages":[],"errorCount":9,"fatalErrorCount":0,"warningCount":13,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Data mapper for Uprooted Vegan Cuisine onboarding\r\n * \r\n * This utility handles the transformation of Uprooted Vegan Cuisine data\r\n * to match our FoodTruck schema, including field mappings and defaults.\r\n */\r\n\r\nimport type { FoodTruck, MenuCategory, OperatingHours } from '../types';\r\n\r\nexport interface UprootedVeganData {\r\n  // Core fields\r\n  name: string;\r\n  description?: string;\r\n  cuisine_type: string | string[]; // Handle both single and array formats\r\n  price_range?: '$' | '$$' | '$$$' | '$$$$';\r\n  specialties?: string | string[]; // Handle both single and array formats\r\n  \r\n  // User/ownership fields\r\n  user_id?: string;\r\n  state?: string;\r\n  \r\n  // Location fields\r\n  exact_location?: {\r\n    lat: number;\r\n    lng: number;\r\n    address?: string;\r\n    timestamp?: string;\r\n  };\r\n  city_location?: {\r\n    lat: number;\r\n    lng: number;\r\n    address?: string;\r\n    timestamp?: string;\r\n  };\r\n  current_location?: {\r\n    lat: number;\r\n    lng: number;\r\n    address?: string;\r\n    timestamp?: string;\r\n  };\r\n  \r\n  // Schedule fields\r\n  scheduled_locations?: {\r\n    address?: string;\r\n    city?: string;\r\n    state?: string;\r\n    zip_code?: string;\r\n    lat?: number;\r\n    lng?: number;\r\n    timestamp: string;\r\n    start_time: string;\r\n    end_time: string;\r\n  }[];\r\n  \r\n  // Menu and hours\r\n  operating_hours?: OperatingHours | Record<string, any>;\r\n  menu?: MenuCategory[] | any[];\r\n  \r\n  // Contact information\r\n  contact_info?: {\r\n    phone?: string;\r\n    email?: string;\r\n    website?: string;\r\n  };\r\n  \r\n  // Social media\r\n  social_media?: {\r\n    instagram?: string;\r\n    facebook?: string;\r\n    twitter?: string;\r\n    tiktok?: string;\r\n    yelp?: string;\r\n  };\r\n  \r\n  // Quality and verification\r\n  data_quality_score?: number;\r\n  verification_status?: 'pending' | 'verified' | 'flagged';\r\n  source_urls?: string | string[];\r\n  \r\n  // Timestamps (for mapping purposes)\r\n  last_scraped_at?: string; // Data scraping timestamp\r\n  created_at?: string;\r\n  updated_at?: string;\r\n}\r\n\r\n/**\r\n * Normalizes cuisine_type to always be an array\r\n */\r\nfunction normalizeCuisineType(cuisine_type: string | string[]): string[] {\r\n  if (typeof cuisine_type === 'string') {\r\n    // Split on common separators and clean up\r\n    return cuisine_type\r\n      .split(/[,;&]/)\r\n      .map(c => c.trim())\r\n      .filter(c => c.length > 0);\r\n  }\r\n  return Array.isArray(cuisine_type) ? cuisine_type : [];\r\n}\r\n\r\n/**\r\n * Normalizes specialties to always be an array\r\n */\r\nfunction normalizeSpecialties(specialties?: string | string[]): string[] {\r\n  if (!specialties) return [];\r\n  if (typeof specialties === 'string') {\r\n    return specialties\r\n      .split(/[,;&]/)\r\n      .map(s => s.trim())\r\n      .filter(s => s.length > 0);\r\n  }\r\n  return Array.isArray(specialties) ? specialties : [];\r\n}\r\n\r\n/**\r\n * Normalizes source URLs to always be an array\r\n */\r\nfunction normalizeSourceUrls(source_urls?: string | string[]): string[] {\r\n  if (!source_urls) return [];\r\n  if (typeof source_urls === 'string') {\r\n    return [source_urls];\r\n  }\r\n  return Array.isArray(source_urls) ? source_urls : [];\r\n}\r\n\r\n/**\r\n * Creates default operating hours\r\n */\r\nfunction createDefaultOperatingHours(): OperatingHours {\r\n  return {\r\n    monday: undefined,\r\n    tuesday: undefined,\r\n    wednesday: undefined,\r\n    thursday: undefined,\r\n    friday: undefined,\r\n    saturday: undefined,\r\n    sunday: undefined\r\n  };\r\n}\r\n\r\n/**\r\n * Maps Uprooted Vegan Cuisine data to our FoodTruck schema\r\n */\r\nexport function mapUprootedVeganData(data: UprootedVeganData): Partial<FoodTruck> {\r\n  const now = new Date().toISOString();\r\n  \r\n  // Handle location priority: exact_location > current_location > city_location\r\n  const primaryLocation = data.exact_location || data.current_location || data.city_location;\r\n  \r\n  const mapped: Partial<FoodTruck> = {\r\n    // Core fields\r\n    name: data.name,\r\n    description: data.description,\r\n    cuisine_type: normalizeCuisineType(data.cuisine_type),\r\n    price_range: data.price_range,\r\n    specialties: normalizeSpecialties(data.specialties),\r\n    \r\n    // New fields for Uprooted Vegan support\r\n    user_id: data.user_id,\r\n    state: data.state,\r\n    \r\n    // Location fields\r\n    current_location: primaryLocation ? {\r\n      lat: primaryLocation.lat,\r\n      lng: primaryLocation.lng,\r\n      address: primaryLocation.address,\r\n      timestamp: primaryLocation.timestamp || now,\r\n    } : {\r\n      lat: 0,\r\n      lng: 0,\r\n      address: undefined,\r\n      timestamp: now,\r\n    },\r\n    scheduled_locations: data.scheduled_locations,\r\n    \r\n    // Menu and hours\r\n    operating_hours: data.operating_hours as OperatingHours || createDefaultOperatingHours(),\r\n    menu: (data.menu as MenuCategory[]) || [],\r\n    \r\n    // Contact information\r\n    contact_info: data.contact_info || {},\r\n    social_media: data.social_media || {},\r\n    \r\n    // Quality and verification\r\n    data_quality_score: data.data_quality_score ?? 0.5, // Default to medium quality\r\n    verification_status: data.verification_status || 'pending',\r\n    source_urls: normalizeSourceUrls(data.source_urls),\r\n    \r\n    // Handle timestamps\r\n    last_scraped_at: data.last_scraped_at || now,\r\n    created_at: data.created_at || now,\r\n    updated_at: data.updated_at || now,\r\n    \r\n    // Additional helpful defaults\r\n    is_active: true, // Assume new entries are active\r\n    test_run_flag: false // Not a test import\r\n  };\r\n  \r\n  return mapped;\r\n}\r\n\r\n/**\r\n * Validates that required fields are present\r\n */\r\nexport function validateUprootedVeganData(data: UprootedVeganData): { \r\n  isValid: boolean; \r\n  errors: string[] \r\n} {\r\n  const errors: string[] = [];\r\n  \r\n  // Check required fields\r\n  if (!data.name || data.name.trim().length === 0) {\r\n    errors.push('name is required');\r\n  }\r\n  \r\n  if (!data.cuisine_type || \r\n      (Array.isArray(data.cuisine_type) && data.cuisine_type.length === 0) ||\r\n      (typeof data.cuisine_type === 'string' && data.cuisine_type.trim().length === 0)) {\r\n    errors.push('cuisine_type is required');\r\n  }\r\n  \r\n  // Validate state format if provided\r\n  if (data.state && (typeof data.state !== 'string' || data.state.length !== 2)) {\r\n    errors.push('state must be a 2-character string (e.g., CA, NY, TX)');\r\n  }\r\n  \r\n  // Validate user_id format if provided\r\n  if (data.user_id && typeof data.user_id !== 'string') {\r\n    errors.push('user_id must be a valid UUID string');\r\n  }\r\n  \r\n  // Validate price range if provided\r\n  if (data.price_range && !['$', '$$', '$$$', '$$$$'].includes(data.price_range)) {\r\n    errors.push('price_range must be one of: $, $$, $$$, $$$$');\r\n  }\r\n  \r\n  return {\r\n    isValid: errors.length === 0,\r\n    errors\r\n  };\r\n}\r\n\r\n/**\r\n * Example usage and testing function\r\n */\r\nexport function createUprootedVeganExample(): UprootedVeganData {\r\n  return {\r\n    name: \"Uprooted Vegan Cuisine\",\r\n    description: \"Plant-based comfort food truck serving delicious vegan alternatives\",\r\n    cuisine_type: [\"Vegan\", \"American\", \"Comfort Food\"],\r\n    price_range: \"$$\",\r\n    specialties: [\"Vegan Burgers\", \"Plant-Based Mac & Cheese\", \"Cashew-Based Desserts\"],\r\n    user_id: \"123e4567-e89b-12d3-a456-426614174000\", // Example UUID\r\n    state: \"CA\",\r\n    current_location: {\r\n      lat: 37.7749,\r\n      lng: -122.4194,\r\n      address: \"San Francisco, CA\",\r\n      timestamp: new Date().toISOString()\r\n    },\r\n    operating_hours: {\r\n      monday: { open: \"11:00 AM\", close: \"8:00 PM\" },\r\n      tuesday: { open: \"11:00 AM\", close: \"8:00 PM\" },\r\n      wednesday: { open: \"11:00 AM\", close: \"8:00 PM\" },\r\n      thursday: { open: \"11:00 AM\", close: \"8:00 PM\" },\r\n      friday: { open: \"11:00 AM\", close: \"9:00 PM\" },\r\n      saturday: { open: \"10:00 AM\", close: \"9:00 PM\" },\r\n      sunday: { closed: true }\r\n    },\r\n    contact_info: {\r\n      phone: \"(415) 555-0123\",\r\n      email: \"hello@uprootedvegan.com\",\r\n      website: \"https://uprootedvegan.com\"\r\n    },\r\n    social_media: {\r\n      instagram: \"@uprootedvegan\",\r\n      facebook: \"UprootedVeganCuisine\"\r\n    },\r\n    verification_status: \"pending\",\r\n    data_quality_score: 0.8,\r\n    source_urls: [\"https://uprootedvegan.com\"]\r\n  };\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\middleware\\middlewareHelpers.js","messages":[{"ruleId":"unicorn/no-null","severity":1,"message":"Use `undefined` instead of `null`.","line":158,"column":33,"nodeType":"Literal","messageId":"error","endLine":158,"endColumn":37,"suggestions":[{"messageId":"replace","fix":{"range":[7588,7592],"text":"undefined"},"data":{},"desc":"Replace `null` with `undefined`."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { NextResponse } from 'next/server';\r\nimport { AuditLogger } from '../../lib/security/auditLogger.js';\r\nimport { createSupabaseMiddlewareClient } from '../../lib/supabaseMiddleware.js';\r\n/**\r\n * Logs a security event and redirects the request to a specified path.\r\n * @example\r\n * logSecurityEventAndRedirect({ req, res, logParams, redirectPath, redirectFromPath })\r\n * NextResponse with redirect to the target path\r\n * @param {Object} params - The parameters for the function.\r\n * @param {Request} params.req - The original request object containing the URL to clone for redirection.\r\n * @param {Response} params._res - The original response object (unused in function, but part of expected parameters).\r\n * @param {Object} params.logParams - Parameters required by the AuditLogger to log the security event.\r\n * @param {string} params.redirectPath - The pathname where the request should be redirected.\r\n * @param {string} [params.redirectFromPath] - Optional pathname indicating where the redirect originated from.\r\n * @returns {NextResponse} A response that performs a redirect to the specified path.\r\n * @description\r\n *   - The function uses AuditLogger to record the security event.\r\n *   - It clones the current URL from the request to ensure original query parameters are preserved.\r\n *   - Redirect path can optionally include info on where the redirect originated via a search parameter.\r\n */\r\nasync function logSecurityEventAndRedirect({ req, res: _res, logParams, redirectPath, redirectFromPath, }) {\r\n    await AuditLogger.logSecurityEvent(logParams);\r\n    const redirectUrl = req.nextUrl.clone();\r\n    redirectUrl.pathname = redirectPath;\r\n    if (redirectFromPath) {\r\n        redirectUrl.searchParams.set(`redirectedFrom`, redirectFromPath);\r\n    }\r\n    return NextResponse.redirect(redirectUrl);\r\n}\r\n/**\r\n * Logs a security event and redirects the user to the login page.\r\n * @example\r\n * logAndRedirect({\r\n *   req: requestObject,\r\n *   res: responseObject,\r\n *   requestMetadata: { ip: '192.168.1.1', userAgent: 'Mozilla/5.0', url: '/dashboard' },\r\n *   reason: 'Session Expired',\r\n *   userError: new Error('User authentication failed')\r\n * })\r\n * // Redirects user to login page and logs the event\r\n * @param {Object} req - Express request object containing details of the incoming request.\r\n * @param {Object} res - Express response object used to send a response to the client.\r\n * @param {Object} requestMetadata - Metadata associated with the request, including IP and user agent.\r\n * @param {string} reason - The reason for redirect, generally describing why access was denied.\r\n * @param {Error} userError - Optional error object that provides additional context about the user error.\r\n * @returns {Promise<void>} Returns a promise that resolves once the security event is logged and redirect is completed.\r\n * @description\r\n *   - Utilizes a severity of 'warning' when logging security events.\r\n *   - Redirects users from the attempted URL to the login page.\r\n *   - Captures detailed information about the request including attempted URL and user agent.\r\n */\r\nasync function logAndRedirect({ req, res, requestMetadata, reason, userError, }) {\r\n    return logSecurityEventAndRedirect({\r\n        req,\r\n        res,\r\n        logParams: {\r\n            event_type: 'permission_denied',\r\n            ip_address: requestMetadata.ip,\r\n            user_agent: requestMetadata.userAgent,\r\n            details: {\r\n                attempted_url: requestMetadata.url,\r\n                reason,\r\n                error: userError?.message,\r\n            },\r\n            severity: 'warning',\r\n        },\r\n        redirectPath: '/login',\r\n        redirectFromPath: req.nextUrl.pathname,\r\n    });\r\n}\r\n/**\r\n * Logs a security event and redirects to an access-denied page.\r\n * @example\r\n * logAndRedirectDenied({\r\n *   req: requestObject,\r\n *   res: responseObject,\r\n *   requestMetadata: metadataObject,\r\n *   user: userObject,\r\n *   profile: profileObject,\r\n *   profileQueryError: errorObject\r\n * })\r\n * // Redirects user and logs the event with relevant details\r\n * @param {Object} params - Contains necessary parameters for the function.\r\n * @param {Object} params.req - The HTTP request object.\r\n * @param {Object} params.res - The HTTP response object.\r\n * @param {Object} params.requestMetadata - Metadata related to the request.\r\n * @param {Object} params.user - User information object.\r\n * @param {Object} params.profile - Profile object related to the user.\r\n * @param {Object} params.profileQueryError - Error object if querying profile fails.\r\n * @returns {Promise<void>} Returns a promise that resolves after logging and redirecting.\r\n * @description\r\n *   - Utilizes `logSecurityEventAndRedirect` to perform logging and redirect operations.\r\n *   - The function assumes a structure for the user object, expecting 'id' and 'email' properties.\r\n *   - Redirects to '/access-denied' path by default.\r\n *   - Sets event severity as 'error' when logging the security event.\r\n */\r\nasync function logAndRedirectDenied({ req, res, requestMetadata, user, profile, profileQueryError, }) {\r\n    return logSecurityEventAndRedirect({\r\n        req,\r\n        res,\r\n        logParams: {\r\n            event_type: 'permission_denied',\r\n            user_id: user.id,\r\n            user_email: user.email ?? undefined,\r\n            ip_address: requestMetadata.ip,\r\n            user_agent: requestMetadata.userAgent,\r\n            details: {\r\n                attempted_url: requestMetadata.url,\r\n                user_role: profile?.role ?? 'none',\r\n                reason: 'insufficient_privileges',\r\n                error: profileQueryError?.message,\r\n            },\r\n            severity: 'error',\r\n        },\r\n        redirectPath: '/access-denied',\r\n    });\r\n}\r\n/**\r\n * Protects admin routes by verifying user authentication and authorization.\r\n * @example\r\n * protectAdminRoutes(req, res, requestMetadata)\r\n * returns NextResponse or redirects depending on user authentication status.\r\n * @param {NextRequest} req - The incoming request object.\r\n * @param {NextResponse} res - The response object to send back to the client.\r\n * @param {RequestMetadata} requestMetadata - Metadata about the request for logging purposes.\r\n * @returns {NextResponse} Returns the response object or redirects to an error page.\r\n * @description\r\n *   - Fetches and verifies the user's session from Supabase.\r\n *   - Checks if the user is an admin based on the profile 'role' from the database.\r\n *   - Logs access attempts to the admin panel for auditing purposes.\r\n *   - Redirects to an appropriate error handler if the user isn't authenticated or authorized.\r\n */\r\nexport async function protectAdminRoutes(req, res, requestMetadata) {\r\n    const supabase = createSupabaseMiddlewareClient(req, res);\r\n    const { data, error: userError } = await supabase.auth.getUser();\r\n    const user = data?.user;\r\n    if (userError || !user) {\r\n        return logAndRedirect({\r\n            req,\r\n            res,\r\n            requestMetadata,\r\n            reason: 'no_session',\r\n            userError: userError ?? undefined,\r\n        });\r\n    }\r\n    // Explicitly type the result of the Supabase query\r\n    const { data: profile, error: profileQueryError } = (await supabase\r\n        .from('profiles')\r\n        .select('role')\r\n        .eq('id', user.id)\r\n        .single());\r\n    if (profileQueryError || (profile && profile.role !== 'admin')) {\r\n        return logAndRedirectDenied({\r\n            req,\r\n            res,\r\n            requestMetadata,\r\n            user,\r\n            profile: profile ?? null,\r\n            profileQueryError: profileQueryError ?? undefined,\r\n        });\r\n    }\r\n    if (req.method !== 'GET' || req.nextUrl.pathname.includes('/api/')) {\r\n        await AuditLogger.logDataAccess({\r\n            userId: user.id,\r\n            userEmail: user.email ?? 'unknown',\r\n            resourceType: 'admin_panel',\r\n            resourceId: req.nextUrl.pathname,\r\n            action: req.method === 'GET' ? 'read' : 'admin_access',\r\n            request: {\r\n                ip: requestMetadata.ip,\r\n                userAgent: requestMetadata.userAgent,\r\n            },\r\n        });\r\n    }\r\n    return res;\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\middleware\\middlewareHelpers.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":33,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":33,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[765,768],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[765,768],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":74,"column":7,"nodeType":"Identifier","messageId":"conditionErrorNullableString","endLine":74,"endColumn":23,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[2569,2585],"text":"redirectFromPath != null"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[2569,2585],"text":"redirectFromPath ?? \"\""},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[2569,2585],"text":"Boolean(redirectFromPath)"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"unicorn/no-null","severity":1,"message":"Use `undefined` instead of `null`.","line":237,"column":21,"nodeType":"Literal","messageId":"error","endLine":237,"endColumn":25,"suggestions":[{"messageId":"replace","fix":{"range":[8664,8668],"text":"undefined"},"data":{},"desc":"Replace `null` with `undefined`."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { NextRequest, NextResponse } from 'next/server';\r\nimport { AuditLogger, type SecurityEvent } from '@/lib/security/auditLogger';\r\nimport { createSupabaseMiddlewareClient } from '@/lib/supabaseMiddleware';\r\n\r\ninterface RequestMetadata {\r\n  ip: string;\r\n  userAgent: string;\r\n  url: string;\r\n  method: string;\r\n}\r\n\r\ninterface SupabaseUser {\r\n  id: string;\r\n  email?: string;\r\n}\r\n\r\ninterface SupabaseProfile {\r\n  role?: string;\r\n}\r\n\r\ninterface LogAndRedirectParams {\r\n  req: NextRequest;\r\n  res: NextResponse;\r\n  requestMetadata: RequestMetadata;\r\n  reason: string;\r\n  userError?: { message?: string };\r\n}\r\n\r\ninterface LogSecurityEventParams {\r\n  event_type: SecurityEvent['event_type'];\r\n  ip_address: string;\r\n  user_agent: string;\r\n  details: Record<string, any>;\r\n  severity: SecurityEvent['severity'];\r\n  user_id?: string;\r\n  user_email?: string;\r\n}\r\n\r\ninterface LogSecurityEventAndRedirectParams {\r\n  req: NextRequest;\r\n  res: NextResponse;\r\n  logParams: LogSecurityEventParams;\r\n  redirectPath: string;\r\n  redirectFromPath?: string;\r\n}\r\n\r\n/**\r\n * Logs a security event and redirects the request to a specified path.\r\n * @example\r\n * logSecurityEventAndRedirect({ req, res, logParams, redirectPath, redirectFromPath })\r\n * NextResponse with redirect to the target path\r\n * @param {Object} params - The parameters for the function.\r\n * @param {Request} params.req - The original request object containing the URL to clone for redirection.\r\n * @param {Response} params._res - The original response object (unused in function, but part of expected parameters).\r\n * @param {Object} params.logParams - Parameters required by the AuditLogger to log the security event.\r\n * @param {string} params.redirectPath - The pathname where the request should be redirected.\r\n * @param {string} [params.redirectFromPath] - Optional pathname indicating where the redirect originated from.\r\n * @returns {NextResponse} A response that performs a redirect to the specified path.\r\n * @description\r\n *   - The function uses AuditLogger to record the security event.\r\n *   - It clones the current URL from the request to ensure original query parameters are preserved.\r\n *   - Redirect path can optionally include info on where the redirect originated via a search parameter.\r\n */\r\nasync function logSecurityEventAndRedirect({\r\n  req,\r\n  res: _res,\r\n  logParams,\r\n  redirectPath,\r\n  redirectFromPath,\r\n}: LogSecurityEventAndRedirectParams) {\r\n  await AuditLogger.logSecurityEvent(logParams);\r\n  const redirectUrl = req.nextUrl.clone();\r\n  redirectUrl.pathname = redirectPath;\r\n  if (redirectFromPath) {\r\n    redirectUrl.searchParams.set(`redirectedFrom`, redirectFromPath);\r\n  }\r\n  return NextResponse.redirect(redirectUrl);\r\n}\r\n\r\n/**\r\n * Logs a security event and redirects the user to the login page.\r\n * @example\r\n * logAndRedirect({\r\n *   req: requestObject, \r\n *   res: responseObject, \r\n *   requestMetadata: { ip: '192.168.1.1', userAgent: 'Mozilla/5.0', url: '/dashboard' }, \r\n *   reason: 'Session Expired', \r\n *   userError: new Error('User authentication failed')\r\n * })\r\n * // Redirects user to login page and logs the event\r\n * @param {Object} req - Express request object containing details of the incoming request.\r\n * @param {Object} res - Express response object used to send a response to the client.\r\n * @param {Object} requestMetadata - Metadata associated with the request, including IP and user agent.\r\n * @param {string} reason - The reason for redirect, generally describing why access was denied.\r\n * @param {Error} userError - Optional error object that provides additional context about the user error.\r\n * @returns {Promise<void>} Returns a promise that resolves once the security event is logged and redirect is completed.\r\n * @description\r\n *   - Utilizes a severity of 'warning' when logging security events.\r\n *   - Redirects users from the attempted URL to the login page.\r\n *   - Captures detailed information about the request including attempted URL and user agent.\r\n */\r\nasync function logAndRedirect({\r\n  req,\r\n  res,\r\n  requestMetadata,\r\n  reason,\r\n  userError,\r\n}: LogAndRedirectParams) {\r\n  return logSecurityEventAndRedirect({\r\n    req,\r\n    res,\r\n    logParams: {\r\n      event_type: 'permission_denied',\r\n      ip_address: requestMetadata.ip,\r\n      user_agent: requestMetadata.userAgent,\r\n      details: {\r\n        attempted_url: requestMetadata.url,\r\n        reason,\r\n        error: userError?.message,\r\n      },\r\n      severity: 'warning',\r\n    },\r\n    redirectPath: '/login',\r\n    redirectFromPath: req.nextUrl.pathname,\r\n  });\r\n}\r\n\r\ninterface LogAndRedirectDeniedParams {\r\n  req: NextRequest;\r\n  res: NextResponse;\r\n  requestMetadata: RequestMetadata;\r\n  user: SupabaseUser;\r\n  profile: SupabaseProfile | null;\r\n  profileQueryError?: { message?: string } | null; // Changed to allow null\r\n}\r\n\r\n/**\r\n * Logs a security event and redirects to an access-denied page.\r\n * @example\r\n * logAndRedirectDenied({\r\n *   req: requestObject,\r\n *   res: responseObject,\r\n *   requestMetadata: metadataObject,\r\n *   user: userObject,\r\n *   profile: profileObject,\r\n *   profileQueryError: errorObject\r\n * })\r\n * // Redirects user and logs the event with relevant details\r\n * @param {Object} params - Contains necessary parameters for the function.\r\n * @param {Object} params.req - The HTTP request object.\r\n * @param {Object} params.res - The HTTP response object.\r\n * @param {Object} params.requestMetadata - Metadata related to the request.\r\n * @param {Object} params.user - User information object.\r\n * @param {Object} params.profile - Profile object related to the user.\r\n * @param {Object} params.profileQueryError - Error object if querying profile fails.\r\n * @returns {Promise<void>} Returns a promise that resolves after logging and redirecting.\r\n * @description\r\n *   - Utilizes `logSecurityEventAndRedirect` to perform logging and redirect operations.\r\n *   - The function assumes a structure for the user object, expecting 'id' and 'email' properties.\r\n *   - Redirects to '/access-denied' path by default.\r\n *   - Sets event severity as 'error' when logging the security event.\r\n */\r\nasync function logAndRedirectDenied({\r\n  req,\r\n  res,\r\n  requestMetadata,\r\n  user,\r\n  profile,\r\n  profileQueryError,\r\n}: LogAndRedirectDeniedParams) {\r\n  return logSecurityEventAndRedirect({\r\n    req,\r\n    res,\r\n    logParams: {\r\n      event_type: 'permission_denied',\r\n      user_id: user.id,\r\n      user_email: user.email ?? undefined,\r\n      ip_address: requestMetadata.ip,\r\n      user_agent: requestMetadata.userAgent,\r\n      details: {\r\n        attempted_url: requestMetadata.url,\r\n        user_role: profile?.role ?? 'none',\r\n        reason: 'insufficient_privileges',\r\n        error: profileQueryError?.message,\r\n      },\r\n      severity: 'error',\r\n    },\r\n    redirectPath: '/access-denied',\r\n  });\r\n}\r\n\r\n/**\r\n * Protects admin routes by verifying user authentication and authorization.\r\n * @example\r\n * protectAdminRoutes(req, res, requestMetadata)\r\n * returns NextResponse or redirects depending on user authentication status.\r\n * @param {NextRequest} req - The incoming request object.\r\n * @param {NextResponse} res - The response object to send back to the client.\r\n * @param {RequestMetadata} requestMetadata - Metadata about the request for logging purposes.\r\n * @returns {NextResponse} Returns the response object or redirects to an error page.\r\n * @description\r\n *   - Fetches and verifies the user's session from Supabase.\r\n *   - Checks if the user is an admin based on the profile 'role' from the database.\r\n *   - Logs access attempts to the admin panel for auditing purposes.\r\n *   - Redirects to an appropriate error handler if the user isn't authenticated or authorized.\r\n */\r\nexport async function protectAdminRoutes(\r\n  req: NextRequest,\r\n  res: NextResponse,\r\n  requestMetadata: RequestMetadata,\r\n) {\r\n  const supabase = createSupabaseMiddlewareClient(req, res);\r\n  const { data, error: userError } = await supabase.auth.getUser();\r\n  const user = data?.user;\r\n\r\n  if (userError || !user) {\r\n    return logAndRedirect({\r\n      req,\r\n      res,\r\n      requestMetadata,\r\n      reason: 'no_session',\r\n      userError: userError ?? undefined,\r\n    });\r\n  }\r\n  // Explicitly type the result of the Supabase query\r\n  const { data: profile, error: profileQueryError } = (await supabase\r\n    .from('profiles')\r\n    .select('role')\r\n    .eq('id', user.id)\r\n    .single()) as { data: SupabaseProfile | null; error: { message?: string } | null };\r\n  if (profileQueryError || (profile && profile.role !== 'admin')) {\r\n    return logAndRedirectDenied({\r\n      req,\r\n      res,\r\n      requestMetadata,\r\n      user,\r\nprofile: profile ?? null,\r\n      profileQueryError: profileQueryError ?? undefined,\r\n    });\r\n  }\r\n  if (req.method !== 'GET' || req.nextUrl.pathname.includes('/api/')) {\r\n    await AuditLogger.logDataAccess({\r\n      userId: user.id,\r\n      userEmail: user.email ?? 'unknown',\r\n      resourceType: 'admin_panel',\r\n      resourceId: req.nextUrl.pathname,\r\n      action: req.method === 'GET' ? 'read' : 'admin_access',\r\n      request: {\r\n        ip: requestMetadata.ip,\r\n        userAgent: requestMetadata.userAgent,\r\n      },\r\n    });\r\n  }\r\n  return res;\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\monitoring\\apiMonitor.js","messages":[{"ruleId":null,"nodeType":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token =","line":33,"column":25}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * SOTA API Usage Monitoring and Alerting System\r\n * Implements proactive monitoring, alerting, and throttling for all external APIs\r\n */\r\nimport { APIUsageService } from '../supabase/services/apiUsageService.js';\r\n// API Rate Limits Configuration\r\nexport const API_LIMITS = {\r\n    gemini: {\r\n        requests: { daily: 1500, hourly: 100 },\r\n        tokens: { daily: 32_000, hourly: 2000 },\r\n        alertThresholds: { warning: 0.8, critical: 0.95 },\r\n    },\r\n    firecrawl: {\r\n        requests: { daily: 500, hourly: 50 },\r\n        tokens: { daily: 0, hourly: 0 },\r\n        alertThresholds: { warning: 0.8, critical: 0.95 },\r\n    },\r\n    tavily: {\r\n        requests: { daily: 1000, hourly: 100 },\r\n        tokens: { daily: 0, hourly: 0 },\r\n        alertThresholds: { warning: 0.8, critical: 0.95 },\r\n    },\r\n    supabase: {\r\n        requests: { daily: 50_000, hourly: 5000 },\r\n        tokens: { daily: 0, hourly: 0 },\r\n        alertThresholds: { warning: 0.9, critical: 0.98 },\r\n    },\r\n};\r\n/**\r\n * Comprehensive API Monitoring Service\r\n */\r\nexport class APIMonitor {\r\n    static alertHistory = [];\r\n    /**\r\n     * Check if API request can be made safely\r\n     */\r\n    static async canMakeRequest(service, requestCount = 1, tokenCount = 0) {\r\n        try {\r\n            const usage = await this.getCurrentUsage(service);\r\n            const limits = API_LIMITS[service];\r\n            // Check daily limits\r\n            const newRequestCount = usage.requests.used + requestCount;\r\n            const newTokenCount = (usage.tokens?.used ?? 0) + tokenCount;\r\n            if (newRequestCount > limits.requests.daily) {\r\n                return {\r\n                    allowed: false,\r\n                    reason: `Daily request limit exceeded (${newRequestCount}/${limits.requests.daily})`,\r\n                    waitTime: this.getTimeUntilReset('daily'),\r\n                };\r\n            }\r\n            if (limits.tokens != undefined && newTokenCount > limits.tokens.daily) {\r\n                return {\r\n                    allowed: false,\r\n                    reason: `Daily token limit exceeded (${newTokenCount}/${limits.tokens.daily})`,\r\n                    waitTime: this.getTimeUntilReset('daily'),\r\n                };\r\n            }\r\n            // Check if approaching critical threshold\r\n            const requestPercentage = newRequestCount / limits.requests.daily;\r\n            if (requestPercentage > limits.alertThresholds.critical) {\r\n                return {\r\n                    allowed: false,\r\n                    reason: `Approaching critical usage threshold (${(requestPercentage * 100).toFixed(1)}%)`,\r\n                    waitTime: this.getTimeUntilReset('daily'),\r\n                };\r\n            }\r\n            return { allowed: true };\r\n        }\r\n        catch (error) {\r\n            console.error(`Error checking API limits for ${service}:`, error);\r\n            // Fail safe - allow request but log error\r\n            return { allowed: true };\r\n        }\r\n    }\r\n    /**\r\n     * Get current usage for a service\r\n     */\r\n    static async getCurrentUsage(service) {\r\n        const todayUsage = await APIUsageService.getTodayUsage(service);\r\n        const limits = API_LIMITS[service];\r\n        const usage = {\r\n            requests: {\r\n                used: todayUsage?.requests_count ?? 0,\r\n                limit: limits.requests.daily,\r\n                percentage: ((todayUsage?.requests_count ?? 0) / limits.requests.daily) * 100,\r\n            },\r\n        };\r\n        if (limits.tokens.daily > 0) {\r\n            usage.tokens = {\r\n                used: todayUsage?.tokens_used ?? 0,\r\n                limit: limits.tokens.daily,\r\n                percentage: ((todayUsage?.tokens_used ?? 0) / limits.tokens.daily) * 100,\r\n            };\r\n        }\r\n        return usage;\r\n    }\r\n    /**\r\n     * Comprehensive monitoring check for all APIs\r\n     */\r\n    static async checkAllAPIs() {\r\n        const alerts = [];\r\n        const usage = {};\r\n        const recommendations = [];\r\n        let canMakeRequest = true;\r\n        for (const service of Object.keys(API_LIMITS)) {\r\n            try {\r\n                const serviceUsage = await this.getCurrentUsage(service);\r\n                usage[service] = serviceUsage;\r\n                // Check for alerts\r\n                const serviceAlerts = this.generateAlerts(service, serviceUsage);\r\n                alerts.push(...serviceAlerts);\r\n                // Check if any service is at critical level\r\n                if (serviceUsage.requests.percentage > API_LIMITS[service].alertThresholds.critical * 100) {\r\n                    canMakeRequest = false;\r\n                }\r\n            }\r\n            catch (error) {\r\n                console.error(`Error monitoring ${service}:`, error);\r\n                alerts.push({\r\n                    service,\r\n                    level: 'warning',\r\n                    message: `Failed to check usage for ${service}`,\r\n                    usage: { current: 0, limit: 0, percentage: 0 },\r\n                    timestamp: new Date().toISOString(),\r\n                    recommendations: ['Check API connectivity', 'Verify credentials'],\r\n                });\r\n            }\r\n        }\r\n        // Generate global recommendations\r\n        recommendations.push(...this.generateRecommendations(usage, alerts));\r\n        return {\r\n            canMakeRequest,\r\n            alerts,\r\n            usage,\r\n            recommendations,\r\n        };\r\n    }\r\n    // Helper for token alerts\r\n    /**\r\n     * Generates token usage alerts based on API usage data and predefined limits.\r\n     * @example\r\n     * generateTokenAlerts(APIServiceInstance, usageData, apiLimits, '2023-10-21T10:20:30Z')\r\n     * [{ service: 'exampleService', level: 'warning', message: 'Warning: exampleService token usage at 75.0%', ... }]\r\n     * @param {APIService} service - The API service for which the alerts are being generated.\r\n     * @param {APIUsageData} usage - Object containing the token usage statistics.\r\n     * @param {Object} limits - Configuration object specifying API limits and alert thresholds.\r\n     * @param {string} timestamp - The timestamp at which the alert is generated.\r\n     * @returns {APIUsageAlert[]} List of alerts generated based on token usage percentage compared to limits.\r\n     * @description\r\n     *   - Generates 'warning' alerts if token usage exceeds the warning threshold.\r\n     *   - Generates 'critical' alerts if token usage exceeds the critical threshold.\r\n     *   - Provides recommendations for optimizing token usage when an alert is generated.\r\n     */\r\n    static generateTokenAlerts(service, usage, limits, timestamp) {\r\n        const alerts = [];\r\n        if (usage.tokens && limits.tokens.daily > 0) {\r\n            const tokenPercentage = usage.tokens.percentage;\r\n            if (tokenPercentage > limits.alertThresholds.critical * 100) {\r\n                alerts.push({\r\n                    service,\r\n                    level: 'critical',\r\n                    message: `Critical: ${service} token usage at ${tokenPercentage.toFixed(1)}%`,\r\n                    usage: {\r\n                        current: usage.tokens.used,\r\n                        limit: usage.tokens.limit,\r\n                        percentage: tokenPercentage,\r\n                    },\r\n                    timestamp,\r\n                    recommendations: [\r\n                        'Reduce prompt complexity',\r\n                        'Implement response caching',\r\n                        'Optimize token usage patterns',\r\n                    ],\r\n                });\r\n            }\r\n            else if (tokenPercentage > limits.alertThresholds.warning * 100) {\r\n                alerts.push({\r\n                    service,\r\n                    level: 'warning',\r\n                    message: `Warning: ${service} token usage at ${tokenPercentage.toFixed(1)}%`,\r\n                    usage: {\r\n                        current: usage.tokens.used,\r\n                        limit: usage.tokens.limit,\r\n                        percentage: tokenPercentage,\r\n                    },\r\n                    timestamp,\r\n                    recommendations: [\r\n                        'Monitor token consumption',\r\n                        'Optimize prompt efficiency',\r\n                        'Consider response caching',\r\n                    ],\r\n                });\r\n            }\r\n        }\r\n        return alerts;\r\n    }\r\n    /**\r\n     * Generates usage alerts based on the service's API usage data.\r\n     * @example\r\n     * generateAlerts(APIService.YOUR_SERVICE, apiUsageData)\r\n     * returns an array of APIUsageAlert objects when usage thresholds are exceeded.\r\n     * @param {APIService} service - The API service being monitored.\r\n     * @param {APIUsageData} usage - The usage data containing request and token information.\r\n     * @returns {APIUsageAlert[]} An array of alert objects representing warning or critical usage states.\r\n     * @description\r\n     *   - Determines alert level based on predefined thresholds in API_LIMITS.\r\n     *   - Generates alerts for both request and token usage.\r\n     *   - Updates alert history, maintaining only the last 100 alerts.\r\n     */\r\n    static generateAlerts(service, usage) {\r\n        const alerts = [];\r\n        const limits = API_LIMITS[service];\r\n        const timestamp = new Date().toISOString();\r\n        // Check request usage\r\n        const requestPercentage = usage.requests.percentage;\r\n        if (requestPercentage > limits.alertThresholds.critical * 100) {\r\n            alerts.push({\r\n                service,\r\n                level: 'critical',\r\n                message: `Critical: ${service} request usage at ${requestPercentage.toFixed(1)}%`,\r\n                usage: {\r\n                    current: usage.requests.used,\r\n                    limit: usage.requests.limit,\r\n                    percentage: requestPercentage,\r\n                },\r\n                timestamp,\r\n                recommendations: [\r\n                    'Immediately reduce API calls',\r\n                    'Implement request queuing',\r\n                    'Consider upgrading API plan',\r\n                ],\r\n            });\r\n        }\r\n        else if (requestPercentage > limits.alertThresholds.warning * 100) {\r\n            alerts.push({\r\n                service,\r\n                level: 'warning',\r\n                message: `Warning: ${service} request usage at ${requestPercentage.toFixed(1)}%`,\r\n                usage: {\r\n                    current: usage.requests.used,\r\n                    limit: usage.requests.limit,\r\n                    percentage: requestPercentage,\r\n                },\r\n                timestamp,\r\n                recommendations: [\r\n                    'Monitor usage closely',\r\n                    'Optimize request patterns',\r\n                    'Enable request caching',\r\n                ],\r\n            });\r\n        }\r\n        // Token alerts\r\n        alerts.push(...this.generateTokenAlerts(service, usage, limits, timestamp));\r\n        // Store alerts in history\r\n        this.alertHistory.push(...alerts);\r\n        // Keep only last 100 alerts\r\n        if (this.alertHistory.length > 100) {\r\n            this.alertHistory = this.alertHistory.slice(-100);\r\n        }\r\n        return alerts;\r\n    }\r\n    /**\r\n     * Generate optimization recommendations\r\n     */\r\n    static generateRecommendations(usage, alerts) {\r\n        const recommendations = [];\r\n        // High-level optimization recommendations\r\n        const criticalAlerts = alerts.filter((a) => a.level === 'critical');\r\n        const warningAlerts = alerts.filter((a) => a.level === 'warning');\r\n        if (criticalAlerts.length > 0) {\r\n            recommendations.push('URGENT: Implement immediate API throttling', 'Enable aggressive caching for all API responses', 'Consider upgrading API plans for critical services');\r\n        }\r\n        if (warningAlerts.length > 0) {\r\n            recommendations.push('Implement request queuing and batching', 'Optimize API call patterns and frequency', 'Enable response caching where possible');\r\n        }\r\n        // Service-specific recommendations\r\n        if (usage.gemini?.requests?.percentage > 70) {\r\n            recommendations.push('Gemini: Optimize prompt length and complexity', 'Gemini: Implement response caching for similar queries');\r\n        }\r\n        if (usage.firecrawl?.requests?.percentage > 70) {\r\n            recommendations.push('Firecrawl: Implement URL deduplication', 'Firecrawl: Cache crawl results for repeated URLs');\r\n        }\r\n        return [...new Set(recommendations)]; // Remove duplicates\r\n    }\r\n    /**\r\n     * Get time until rate limit reset\r\n     */\r\n    static getTimeUntilReset(period) {\r\n        const now = new Date();\r\n        if (period === 'hourly') {\r\n            const nextHour = new Date(now);\r\n            nextHour.setHours(now.getHours() + 1, 0, 0, 0);\r\n            return nextHour.getTime() - now.getTime();\r\n        }\r\n        const nextDay = new Date(now);\r\n        nextDay.setDate(now.getDate() + 1);\r\n        nextDay.setHours(0, 0, 0, 0);\r\n        return nextDay.getTime() - now.getTime();\r\n    }\r\n    /**\r\n     * Get alert history\r\n     */\r\n    static getAlertHistory() {\r\n        return [...this.alertHistory];\r\n    }\r\n    /**\r\n     * Clear alert history\r\n     */\r\n    static clearAlertHistory() {\r\n        this.alertHistory = [];\r\n    }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\monitoring\\apiMonitor.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\performance\\bundleAnalyzer.js","messages":[{"ruleId":null,"nodeType":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token =","line":113,"column":22}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Bundle Size Analysis and Optimization Utilities\n * Provides insights and recommendations for bundle optimization\n */\nimport React from 'react';\n/**\n * Bundle optimization recommendations based on analysis\n */\nexport function getBundleOptimizationRecommendations() {\n    const recommendations = [\n        // Code splitting recommendations\n        'Implement dynamic imports for admin dashboard components',\n        'Split authentication components into separate chunks',\n        'Lazy load chart components (Recharts) only when needed',\n        // Tree shaking recommendations\n        'Use named imports instead of default imports for UI libraries',\n        'Remove unused Lucide React icons',\n        'Optimize Radix UI imports to only include used components',\n        // External dependencies optimization\n        'Consider replacing Recharts with a lighter charting library for simple charts',\n        'Use Next.js Image component instead of external image libraries',\n        'Minimize Supabase client bundle size by importing only needed functions',\n        // Performance optimizations\n        'Enable gzip compression in production',\n        'Use Next.js bundle analyzer to identify large dependencies',\n        'Implement service worker for caching static assets',\n        // Modern JavaScript features\n        'Use ES2020+ features for smaller bundle sizes',\n        'Enable Next.js experimental optimizePackageImports',\n        'Consider using SWC minification for better performance',\n    ];\n    return recommendations;\n}\nexport const PERFORMANCE_BUDGETS = {\n    maxBundleSize: 500, // 500KB total bundle\n    maxChunkSize: 200, // 200KB per chunk\n    maxInitialLoad: 300, // 300KB initial load\n    maxAssetSize: 100, // 100KB per asset\n};\n/**\n * Check if bundle meets performance budgets\n */\nexport function checkPerformanceBudget(analysis) {\n    const violations = [];\n    // Check total bundle size\n    if (analysis.totalSize != undefined &&\n        analysis.totalSize > PERFORMANCE_BUDGETS.maxBundleSize * 1024) {\n        violations.push({\n            metric: 'Total Bundle Size',\n            actual: Math.round(analysis.totalSize / 1024),\n            budget: PERFORMANCE_BUDGETS.maxBundleSize,\n            severity: 'error',\n        });\n    }\n    // Check individual chunk sizes\n    if (analysis.chunks) {\n        for (const chunk of analysis.chunks) {\n            if (chunk.size > PERFORMANCE_BUDGETS.maxChunkSize * 1024) {\n                violations.push({\n                    metric: `Chunk Size (${chunk.name})`,\n                    actual: Math.round(chunk.size / 1024),\n                    budget: PERFORMANCE_BUDGETS.maxChunkSize,\n                    severity: 'warning',\n                });\n            }\n        }\n    }\n    return {\n        passed: violations.length === 0,\n        violations,\n    };\n}\n/**\n * Dynamic import utilities for code splitting\n */\nexport const DynamicImports = {\n    // Admin dashboard components\n    AdminDashboard: () => import('@/app/admin/page'),\n    FoodTruckManagement: () => import('@/app/admin/food-trucks/page'),\n    Analytics: () => import('@/app/admin/analytics/page'),\n    // Chart components (heavy dependencies)\n    Charts: () => import('recharts'),\n    // Authentication components\n    LoginPage: () => import('@/app/login/page'),\n    // Map components - commented out until component exists\n    // MapDisplay: () => import('@/components/MapDisplay'),\n};\n/**\n * Optimized imports for common libraries\n */\nexport const OptimizedImports = {\n    // Lucide React - use standard imports (tree-shaking handled by bundler)\n    icons: {\n        // Use regular lucide-react imports - modern bundlers handle tree-shaking\n        Menu: () => import('lucide-react').then((mod) => ({ Menu: mod.Menu })),\n        Search: () => import('lucide-react').then((mod) => ({ Search: mod.Search })),\n        User: () => import('lucide-react').then((mod) => ({ User: mod.User })),\n        BarChart3: () => import('lucide-react').then((mod) => ({ BarChart3: mod.BarChart3 })),\n        Settings: () => import('lucide-react').then((mod) => ({ Settings: mod.Settings })),\n        Database: () => import('lucide-react').then((mod) => ({ Database: mod.Database })),\n    },\n    // Radix UI - optimized imports\n    ui: {\n        Button: () => import('@radix-ui/react-slot').then((mod) => ({ Slot: mod.Slot })),\n        Dialog: () => import('@radix-ui/react-dialog'),\n        DropdownMenu: () => import('@radix-ui/react-dropdown-menu'),\n    },\n};\n/**\n * Performance monitoring for bundle loading\n */\nexport class BundlePerformanceMonitor {\n    static loadTimes = new Map();\n    /**\n     * Track chunk load time\n     */\n    static trackChunkLoad(chunkName, startTime) {\n        const loadTime = performance.now() - startTime;\n        this.loadTimes.set(chunkName, loadTime);\n        // Log slow loading chunks\n        if (loadTime > 1000) {\n            // More than 1 second\n            console.warn(`Slow chunk load detected: ${chunkName} took ${loadTime.toFixed(2)}ms`);\n        }\n    }\n    /**\n     * Get chunk load statistics\n     */\n    static getLoadStats() {\n        return [...this.loadTimes.entries()].map(([chunk, loadTime]) => ({\n            chunk,\n            loadTime,\n        }));\n    }\n    /**\n     * Get average load time\n     */\n    static getAverageLoadTime() {\n        const times = [...this.loadTimes.values()];\n        return times.length > 0 ? times.reduce((sum, time) => sum + time, 0) / times.length : 0;\n    }\n}\n/**\n * Code splitting helper for React components\n */\nexport function createLazyComponent(importFn, fallback) {\n    const LazyComponent = React.lazy(importFn);\n    /**\n     * Wraps a lazy loaded component with performance monitoring.\n     * @example\n     * WrappedComponent(props);\n     * Returns a React component wrapped with a Suspense fallback and performance tracking.\n     * @param {React.ComponentProps<T>} props - The props for the wrapped lazy component.\n     * @returns {React.ReactElement} A React element that wraps the lazy component within a Suspense fallback.\n     * @description\n     *   - Utilizes React's Suspense to handle lazy loading of components with a fallback UI.\n     *   - Tracks the performance of the component chunk loading using BundlePerformanceMonitor.\n     *   - Analyzes the load-time performance by capturing the start time at component mount.\n     */\n    return function WrappedComponent(props) {\n        const startTime = performance.now();\n        React.useEffect(() => {\n            BundlePerformanceMonitor.trackChunkLoad(importFn.toString().slice(0, 50), // Use function string as identifier\n            startTime);\n        }, []);\n        return (<React.Suspense fallback={fallback ? React.createElement(fallback) : <div>Loading...</div>}>\r\n        <LazyComponent {...props}/>\r\n      </React.Suspense>);\n    };\n}\n/**\n * Bundle size recommendations based on current setup\n */\nexport function getProjectSpecificRecommendations() {\n    return [\n        {\n            category: 'Code Splitting',\n            priority: 'high',\n            recommendations: [\n                'Split admin dashboard into separate route chunks',\n                'Lazy load Recharts components only when analytics page is accessed',\n                'Dynamic import authentication components',\n                'Separate map components into their own chunk',\n            ],\n        },\n        {\n            category: 'Dependency Optimization',\n            priority: 'medium',\n            recommendations: [\n                'Use tree-shaking for Lucide React icons',\n                'Optimize Radix UI imports to only include used components',\n                'Consider lighter alternatives to heavy dependencies',\n                'Use Next.js optimizePackageImports for @radix-ui',\n            ],\n        },\n        {\n            category: 'Asset Optimization',\n            priority: 'medium',\n            recommendations: [\n                'Optimize images with Next.js Image component',\n                'Use WebP/AVIF formats for better compression',\n                'Implement proper caching headers for static assets',\n                'Minimize CSS bundle size with unused CSS removal',\n            ],\n        },\n        {\n            category: 'Runtime Optimization',\n            priority: 'low',\n            recommendations: [\n                'Implement service worker for caching',\n                'Use compression middleware in production',\n                'Enable HTTP/2 server push for critical resources',\n                'Implement resource hints (preload, prefetch)',\n            ],\n        },\n    ];\n}\n","usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\performance\\bundleAnalyzer.tsx","messages":[{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":134,"column":57,"nodeType":"Property","messageId":"anyAssignment","endLine":134,"endColumn":71},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .Menu on an `any` value.","line":134,"column":67,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":134,"endColumn":71},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":135,"column":59,"nodeType":"Property","messageId":"anyAssignment","endLine":135,"endColumn":77},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .Search on an `any` value.","line":135,"column":71,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":135,"endColumn":77},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":136,"column":57,"nodeType":"Property","messageId":"anyAssignment","endLine":136,"endColumn":71},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .User on an `any` value.","line":136,"column":67,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":136,"endColumn":71},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":137,"column":62,"nodeType":"Property","messageId":"anyAssignment","endLine":137,"endColumn":86},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .BarChart3 on an `any` value.","line":137,"column":77,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":137,"endColumn":86},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":138,"column":61,"nodeType":"Property","messageId":"anyAssignment","endLine":138,"endColumn":83},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .Settings on an `any` value.","line":138,"column":75,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":138,"endColumn":83},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":139,"column":61,"nodeType":"Property","messageId":"anyAssignment","endLine":139,"endColumn":83},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .Database on an `any` value.","line":139,"column":75,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":139,"endColumn":83},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":144,"column":67,"nodeType":"Property","messageId":"anyAssignment","endLine":144,"endColumn":81},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .Slot on an `any` value.","line":144,"column":77,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":144,"endColumn":81},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":192,"column":67,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":192,"endColumn":70,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5551,5554],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5551,5554],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":222,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":222,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6845,6848],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6845,6848],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":14,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Bundle Size Analysis and Optimization Utilities\n * Provides insights and recommendations for bundle optimization\n */\n\nimport React from 'react';\n\nexport interface BundleAnalysis {\n  totalSize: number;\n  gzippedSize: number;\n  chunks: Array<{\n    name: string;\n    size: number;\n    modules: string[];\n  }>;\n  recommendations: string[];\n}\n\n/**\n * Bundle optimization recommendations based on analysis\n */\nexport function getBundleOptimizationRecommendations(): string[] {\n  const recommendations = [\n    // Code splitting recommendations\n    'Implement dynamic imports for admin dashboard components',\n    'Split authentication components into separate chunks',\n    'Lazy load chart components (Recharts) only when needed',\n\n    // Tree shaking recommendations\n    'Use named imports instead of default imports for UI libraries',\n    'Remove unused Lucide React icons',\n    'Optimize Radix UI imports to only include used components',\n\n    // External dependencies optimization\n    'Consider replacing Recharts with a lighter charting library for simple charts',\n    'Use Next.js Image component instead of external image libraries',\n    'Minimize Supabase client bundle size by importing only needed functions',\n\n    // Performance optimizations\n    'Enable gzip compression in production',\n    'Use Next.js bundle analyzer to identify large dependencies',\n    'Implement service worker for caching static assets',\n\n    // Modern JavaScript features\n    'Use ES2020+ features for smaller bundle sizes',\n    'Enable Next.js experimental optimizePackageImports',\n    'Consider using SWC minification for better performance',\n  ];\n\n  return recommendations;\n}\n\n/**\n * Critical performance metrics for bundle optimization\n */\nexport interface PerformanceBudget {\n  maxBundleSize: number; // in KB\n  maxChunkSize: number; // in KB\n  maxInitialLoad: number; // in KB\n  maxAssetSize: number; // in KB\n}\n\nexport const PERFORMANCE_BUDGETS: PerformanceBudget = {\n  maxBundleSize: 500, // 500KB total bundle\n  maxChunkSize: 200, // 200KB per chunk\n  maxInitialLoad: 300, // 300KB initial load\n  maxAssetSize: 100, // 100KB per asset\n};\n\n/**\n * Check if bundle meets performance budgets\n */\nexport function checkPerformanceBudget(analysis: Partial<BundleAnalysis>): {\n  passed: boolean;\n  violations: Array<{\n    metric: string;\n    actual: number;\n    budget: number;\n    severity: 'warning' | 'error';\n  }>;\n} {\n  const violations: Array<{\n    metric: string;\n    actual: number;\n    budget: number;\n    severity: 'warning' | 'error';\n  }> = [];\n\n  // Check total bundle size\n  if (\n    analysis.totalSize != undefined &&\n    analysis.totalSize > PERFORMANCE_BUDGETS.maxBundleSize * 1024\n  ) {\n    violations.push({\n      metric: 'Total Bundle Size',\n      actual: Math.round(analysis.totalSize / 1024),\n      budget: PERFORMANCE_BUDGETS.maxBundleSize,\n      severity: 'error',\n    });\n  }\n\n  // Check individual chunk sizes\n  if (analysis.chunks) {\n    for (const chunk of analysis.chunks) {\n      if (chunk.size > PERFORMANCE_BUDGETS.maxChunkSize * 1024) {\n        violations.push({\n          metric: `Chunk Size (${chunk.name})`,\n          actual: Math.round(chunk.size / 1024),\n          budget: PERFORMANCE_BUDGETS.maxChunkSize,\n          severity: 'warning',\n        });\n      }\n    }\n  }\n\n  return {\n    passed: violations.length === 0,\n    violations,\n  };\n}\n\n/**\n * Dynamic import utilities for code splitting\n */\n\n\n/**\n * Optimized imports for common libraries\n */\nexport const OptimizedImports = {\n  // Lucide React - use standard imports (tree-shaking handled by bundler)\n  icons: {\n    // Use regular lucide-react imports - modern bundlers handle tree-shaking\n    Menu: () => import('lucide-react').then((mod) => ({ Menu: mod.Menu })),\n    Search: () => import('lucide-react').then((mod) => ({ Search: mod.Search })),\n    User: () => import('lucide-react').then((mod) => ({ User: mod.User })),\n    BarChart3: () => import('lucide-react').then((mod) => ({ BarChart3: mod.BarChart3 })),\n    Settings: () => import('lucide-react').then((mod) => ({ Settings: mod.Settings })),\n    Database: () => import('lucide-react').then((mod) => ({ Database: mod.Database })),\n  },\n\n  // Radix UI - optimized imports\n  ui: {\n    Button: () => import('@radix-ui/react-slot').then((mod) => ({ Slot: mod.Slot })),\n    Dialog: () => import('@radix-ui/react-dialog'),\n    DropdownMenu: () => import('@radix-ui/react-dropdown-menu'),\n  },\n};\n\n/**\n * Performance monitoring for bundle loading\n */\nexport class BundlePerformanceMonitor {\n  private static loadTimes = new Map<string, number>();\n\n  /**\n   * Track chunk load time\n   */\n  static trackChunkLoad(chunkName: string, startTime: number): void {\n    const loadTime = performance.now() - startTime;\n    this.loadTimes.set(chunkName, loadTime);\n\n    // Log slow loading chunks\n    if (loadTime > 1000) {\n      // More than 1 second\n      console.warn(`Slow chunk load detected: ${chunkName} took ${loadTime.toFixed(2)}ms`);\n    }\n  }\n\n  /**\n   * Get chunk load statistics\n   */\n  static getLoadStats(): Array<{ chunk: string; loadTime: number }> {\n    return [...this.loadTimes.entries()].map(([chunk, loadTime]) => ({\n      chunk,\n      loadTime,\n    }));\n  }\n\n  /**\n   * Get average load time\n   */\n  static getAverageLoadTime(): number {\n    const times = [...this.loadTimes.values()];\n    return times.length > 0 ? times.reduce((sum, time) => sum + time, 0) / times.length : 0;\n  }\n}\n\n/**\n * Code splitting helper for React components\n */\nexport function createLazyComponent<T extends React.ComponentType<any>>(\n  importFn: () => Promise<{ default: T }>,\n  fallback?: React.ComponentType,\n) {\n  const LazyComponent = React.lazy(importFn);\n\n  /**\n   * Wraps a lazy loaded component with performance monitoring.\n   * @example\n   * WrappedComponent(props);\n   * Returns a React component wrapped with a Suspense fallback and performance tracking.\n   * @param {React.ComponentProps<T>} props - The props for the wrapped lazy component.\n   * @returns {React.ReactElement} A React element that wraps the lazy component within a Suspense fallback.\n   * @description\n   *   - Utilizes React's Suspense to handle lazy loading of components with a fallback UI.\n   *   - Tracks the performance of the component chunk loading using BundlePerformanceMonitor.\n   *   - Analyzes the load-time performance by capturing the start time at component mount.\n   */\n  return function WrappedComponent(props: React.ComponentProps<T>) {\n    const startTime = performance.now();\n\n    React.useEffect(() => {\n      BundlePerformanceMonitor.trackChunkLoad(\n        importFn.toString().slice(0, 50), // Use function string as identifier\n        startTime,\n      );\n    }, []);\n\n    return (\n      <React.Suspense fallback={fallback ? React.createElement(fallback) : <div>Loading...</div>}>\n        <LazyComponent {...(props as any)} />\n      </React.Suspense>\n    );\n  };\n}\n\n/**\n * Bundle size recommendations based on current setup\n */\nexport function getProjectSpecificRecommendations(): Array<{\n  category: string;\n  recommendations: string[];\n  priority: 'high' | 'medium' | 'low';\n}> {\n  return [\n    {\n      category: 'Code Splitting',\n      priority: 'high',\n      recommendations: [\n        'Split admin dashboard into separate route chunks',\n        'Lazy load Recharts components only when analytics page is accessed',\n        'Dynamic import authentication components',\n        'Separate map components into their own chunk',\n      ],\n    },\n    {\n      category: 'Dependency Optimization',\n      priority: 'medium',\n      recommendations: [\n        'Use tree-shaking for Lucide React icons',\n        'Optimize Radix UI imports to only include used components',\n        'Consider lighter alternatives to heavy dependencies',\n        'Use Next.js optimizePackageImports for @radix-ui',\n      ],\n    },\n    {\n      category: 'Asset Optimization',\n      priority: 'medium',\n      recommendations: [\n        'Optimize images with Next.js Image component',\n        'Use WebP/AVIF formats for better compression',\n        'Implement proper caching headers for static assets',\n        'Minimize CSS bundle size with unused CSS removal',\n      ],\n    },\n    {\n      category: 'Runtime Optimization',\n      priority: 'low',\n      recommendations: [\n        'Implement service worker for caching',\n        'Use compression middleware in production',\n        'Enable HTTP/2 server push for critical resources',\n        'Implement resource hints (preload, prefetch)',\n      ],\n    },\n  ];\n}","usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\performance\\databaseCache.js","messages":[{"ruleId":"unicorn/no-null","severity":1,"message":"Use `undefined` instead of `null`.","line":58,"column":20,"nodeType":"Literal","messageId":"error","endLine":58,"endColumn":24,"suggestions":[{"messageId":"remove","fix":{"range":[2432,2436],"text":""},"data":{},"desc":"Remove `null`."},{"messageId":"replace","fix":{"range":[2432,2436],"text":"undefined"},"data":{},"desc":"Replace `null` with `undefined`."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * SOTA Database Query Optimization and Caching\r\n * Implements Next.js unstable_cache for optimal performance\r\n */\r\nimport { unstable_cache } from 'next/cache';\r\nimport { supabaseAdmin, FoodTruckService } from '../../lib/supabase.js';\r\n// Cache configuration\r\nconst CACHE_CONFIG = {\r\n    // Short-term cache for frequently changing data\r\n    SHORT_TTL: 60 * 5, // 5 minutes\r\n    // Medium-term cache for semi-static data\r\n    MEDIUM_TTL: 60 * 30, // 30 minutes\r\n    // Long-term cache for static data\r\n    LONG_TTL: 60 * 60 * 24, // 24 hours\r\n};\r\n/**\r\n * Cached food truck queries with optimized database access\r\n */\r\nexport const CachedFoodTruckService = {\r\n    /**\r\n     * Get all food trucks with caching\r\n     * Cache for 30 minutes since truck data changes moderately\r\n     */\r\n    getAllTrucksCached: unstable_cache(async () => {\r\n        console.info('CachedFoodTruckService: Cache miss - fetching all trucks from database');\r\n        const result = await FoodTruckService.getAllTrucks();\r\n        if ('error' in result) {\r\n            throw new Error(`Failed to fetch all trucks: ${result.error}`);\r\n        }\r\n        return { trucks: result.trucks, count: result.total };\r\n    }, ['all-trucks'], {\r\n        revalidate: CACHE_CONFIG.MEDIUM_TTL,\r\n        tags: ['food-trucks', 'all-trucks'],\r\n    }),\r\n    /**\r\n     * Get trucks by location with caching\r\n     * Cache for 5 minutes since location-based queries are time-sensitive\r\n     */\r\n    getTrucksByLocationCached: unstable_cache(async (lat, lng, radiusKm) => {\r\n        console.info(`CachedFoodTruckService: Cache miss - fetching trucks near ${lat},${lng} (${radiusKm}km)`);\r\n        const result = await FoodTruckService.getTrucksByLocation(lat, lng, radiusKm);\r\n        if ('error' in result) {\r\n            throw new Error(`Failed to fetch trucks by location: ${result.error}`);\r\n        }\r\n        return result;\r\n    }, ['trucks-by-location'], {\r\n        revalidate: CACHE_CONFIG.SHORT_TTL,\r\n        tags: ['food-trucks', 'location-search'],\r\n    }),\r\n    /**\r\n     * Get truck by ID with caching\r\n     * Cache for 30 minutes since individual truck data is relatively stable\r\n     */\r\n    getTruckByIdCached: unstable_cache(async (id) => {\r\n        console.info(`CachedFoodTruckService: Cache miss - fetching truck ${id} from database`);\r\n        const result = await FoodTruckService.getTruckById(id);\r\n        if ('error' in result) {\r\n            return null;\r\n        }\r\n        return result;\r\n    }, ['truck-by-id'], {\r\n        revalidate: CACHE_CONFIG.MEDIUM_TTL,\r\n        tags: ['food-trucks', 'truck-details'],\r\n    }),\r\n    /**\r\n     * Search trucks with caching\r\n     * Cache for 5 minutes since search results should be relatively fresh\r\n     */\r\n    searchTrucksCached: unstable_cache(async (query, filters) => {\r\n        console.info(`CachedFoodTruckService: Cache miss - searching trucks for \"${query}\"`);\r\n        if (supabaseAdmin == undefined) {\r\n            throw new Error('Supabase admin client not available');\r\n        }\r\n        let dbQuery = supabaseAdmin\r\n            .from('food_trucks')\r\n            .select('*')\r\n            .or(`name.ilike.%${query}%,description.ilike.%${query}%,cuisine_type.cs.{${query}}`);\r\n        // Apply filters\r\n        if (filters?.cuisine != undefined && filters.cuisine !== '') {\r\n            dbQuery = dbQuery.contains('cuisine_type', [filters.cuisine]);\r\n        }\r\n        const { data, error } = await dbQuery.limit(50);\r\n        const trucks = data ?? [];\r\n        if (error != undefined) {\r\n            const errorMessage = error instanceof Error ? error.message : JSON.stringify(error);\r\n            throw new Error(`Search query failed: ${errorMessage}`);\r\n        }\r\n        let results = trucks ?? [];\r\n        // Apply location filter if provided\r\n        if (filters?.lat != undefined && filters?.lng != undefined && filters?.radius != undefined) {\r\n            results = results.filter((truck) => {\r\n                if (truck.current_location?.lat == undefined ||\r\n                    truck.current_location?.lng == undefined) {\r\n                    return false;\r\n                }\r\n                const distance = calculateDistance(filters.lat, // Assert as number, as it's checked by the outer if condition\r\n                filters.lng, // Assert as number, as it's checked by the outer if condition\r\n                truck.current_location.lat, truck.current_location.lng);\r\n                return distance <= (filters.radius ?? 10);\r\n            });\r\n        }\r\n        // Apply openNow filter if provided\r\n        if (filters?.openNow === true) {\r\n            const now = new Date();\r\n            const currentDay = now.toLocaleDateString('en-US', { weekday: 'short' }).toLowerCase(); // 'mon', 'tue', etc.\r\n            const currentTime = now.getHours() * 100 + now.getMinutes(); // HHMM format\r\n            results = results.filter((truck) => {\r\n                const hours = truck.operating_hours?.[currentDay];\r\n                if (hours == undefined || hours.closed === true)\r\n                    return false;\r\n                const openTime = parseTimeString(hours.open ?? '');\r\n                const closeTime = parseTimeString(hours.close ?? '');\r\n                return currentTime >= openTime && currentTime <= closeTime;\r\n            });\r\n        }\r\n        return results;\r\n    }, ['search-trucks'], {\r\n        revalidate: CACHE_CONFIG.SHORT_TTL,\r\n        tags: ['food-trucks', 'search'],\r\n    }),\r\n    /**\r\n     * Get data quality statistics with caching\r\n     * Cache for 24 hours since quality stats change slowly\r\n     */\r\n    getDataQualityStatsCached: unstable_cache(async () => {\r\n        console.info('CachedFoodTruckService: Cache miss - calculating data quality stats');\r\n        if (supabaseAdmin == undefined) {\r\n            throw new Error('Supabase admin client not available');\r\n        }\r\n        const { data: trucks, error } = await supabaseAdmin\r\n            .from('food_trucks')\r\n            .select('data_quality_score');\r\n        if (error) {\r\n            throw new Error(`Quality stats query failed: ${error.message}`);\r\n        }\r\n        const scores = trucks == undefined\r\n            ? []\r\n            : trucks.map((t) => t.data_quality_score ?? 0);\r\n        const averageScore = scores.length > 0\r\n            ? scores.reduce((sum, score) => sum + score, 0) / scores.length\r\n            : 0;\r\n        const distribution = {\r\n            high: scores.filter((s) => s >= 0.8).length,\r\n            medium: scores.filter((s) => s >= 0.6 && s < 0.8).length,\r\n            low: scores.filter((s) => s < 0.6).length,\r\n        };\r\n        return {\r\n            averageScore: Math.round(averageScore * 100) / 100,\r\n            distribution,\r\n            totalTrucks: scores.length,\r\n        };\r\n    }, ['data-quality-stats'], {\r\n        revalidate: CACHE_CONFIG.LONG_TTL,\r\n        tags: ['food-trucks', 'data-quality'],\r\n    }),\r\n};\r\n/**\r\n * Cache invalidation utilities\r\n */\r\nexport const CacheManager = {\r\n    /**\r\n     * Invalidate all food truck related caches\r\n     */\r\n    async invalidateAllFoodTruckCaches() {\r\n        try {\r\n            const { revalidateTag } = await import('next/cache');\r\n            revalidateTag('food-trucks');\r\n            console.info('CacheManager: Invalidated all food truck caches');\r\n        }\r\n        catch (error) {\r\n            console.warn('CacheManager: Failed to invalidate caches:', error);\r\n        }\r\n    },\r\n    /**\r\n     * Invalidate specific truck cache\r\n     */\r\n    async invalidateTruckCache(truckId) {\r\n        try {\r\n            const { revalidateTag } = await import('next/cache');\r\n            revalidateTag(`truck-${truckId}`);\r\n            revalidateTag('food-trucks'); // Also invalidate general caches\r\n            console.info(`CacheManager: Invalidated cache for truck ${truckId}`);\r\n        }\r\n        catch (error) {\r\n            console.warn('CacheManager: Failed to invalidate truck cache:', error);\r\n        }\r\n    },\r\n    /**\r\n     * Invalidate search and location caches\r\n     */\r\n    async invalidateSearchCaches() {\r\n        try {\r\n            const { revalidateTag } = await import('next/cache');\r\n            revalidateTag('search');\r\n            revalidateTag('location-search');\r\n            console.info('CacheManager: Invalidated search caches');\r\n        }\r\n        catch (error) {\r\n            console.warn('CacheManager: Failed to invalidate search caches:', error);\r\n        }\r\n    },\r\n};\r\n/**\r\n * Utility functions\r\n */\r\nfunction calculateDistance(lat1, lng1, lat2, lng2) {\r\n    const R = 6371; // Earth's radius in kilometers\r\n    const dLat = ((lat2 - lat1) * Math.PI) / 180;\r\n    const dLng = ((lng2 - lng1) * Math.PI) / 180;\r\n    const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +\r\n        Math.cos((lat1 * Math.PI) / 180) *\r\n            Math.cos((lat2 * Math.PI) / 180) *\r\n            Math.sin(dLng / 2) *\r\n            Math.sin(dLng / 2);\r\n    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\r\n    return R * c;\r\n}\r\nfunction parseTimeString(timeStr) {\r\n    if (timeStr == undefined || timeStr === '')\r\n        return 0;\r\n    const [hours, minutes] = timeStr.split(':').map(Number);\r\n    return hours * 100 + (minutes ?? 0);\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\performance\\databaseCache.ts","messages":[{"ruleId":"@typescript-eslint/no-unnecessary-type-assertion","severity":2,"message":"This assertion is unnecessary since it does not change the type of the expression.","line":57,"column":14,"nodeType":"TSAsExpression","messageId":"unnecessaryAssertion","endLine":57,"endColumn":35,"fix":{"range":[2019,2034],"text":""}},{"ruleId":"unicorn/no-null","severity":1,"message":"Use `undefined` instead of `null`.","line":75,"column":8,"nodeType":"Literal","messageId":"error","endLine":75,"endColumn":12,"suggestions":[{"messageId":"remove","fix":{"range":[2607,2611],"text":""},"data":{},"desc":"Remove `null`."},{"messageId":"replace","fix":{"range":[2607,2611],"text":"undefined"},"data":{},"desc":"Replace `null` with `undefined`."}]},{"ruleId":"@typescript-eslint/no-unnecessary-type-assertion","severity":2,"message":"This assertion is unnecessary since it does not change the type of the expression.","line":77,"column":14,"nodeType":"TSAsExpression","messageId":"unnecessaryAssertion","endLine":77,"endColumn":33,"fix":{"range":[2642,2655],"text":""}}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":2,"fixableWarningCount":0,"source":"/**\r\n * SOTA Database Query Optimization and Caching\r\n * Implements Next.js unstable_cache for optimal performance\r\n */\r\n\r\nimport { unstable_cache } from 'next/cache';\r\nimport { supabaseAdmin, FoodTruckService } from '@/lib/supabase';\r\nimport type { FoodTruck } from '@/lib/types';\r\n\r\n// Cache configuration\r\nconst CACHE_CONFIG = {\r\n  // Short-term cache for frequently changing data\r\n  SHORT_TTL: 60 * 5, // 5 minutes\r\n  // Medium-term cache for semi-static data\r\n  MEDIUM_TTL: 60 * 30, // 30 minutes\r\n  // Long-term cache for static data\r\n  LONG_TTL: 60 * 60 * 24, // 24 hours\r\n} as const;\r\n\r\n/**\r\n * Cached food truck queries with optimized database access\r\n */\r\nexport const CachedFoodTruckService = {\r\n  /**\r\n   * Get all food trucks with caching\r\n   * Cache for 30 minutes since truck data changes moderately\r\n   */\r\n  getAllTrucksCached: unstable_cache(\r\n    async (): Promise<{ trucks: FoodTruck[]; count: number }> => {\r\n      console.info('CachedFoodTruckService: Cache miss - fetching all trucks from database');\r\n      const result = await FoodTruckService.getAllTrucks();\r\n      if ('error' in result) {\r\n        throw new Error(`Failed to fetch all trucks: ${result.error}`);\r\n      }\r\n      return { trucks: result.trucks, count: result.total };\r\n    },\r\n    ['all-trucks'],\r\n    {\r\n      revalidate: CACHE_CONFIG.MEDIUM_TTL,\r\n      tags: ['food-trucks', 'all-trucks'],\r\n    },\r\n  ),\r\n\r\n  /**\r\n   * Get trucks by location with caching\r\n   * Cache for 5 minutes since location-based queries are time-sensitive\r\n   */\r\n  getTrucksByLocationCached: unstable_cache(\r\n    async (lat: number, lng: number, radiusKm: number): Promise<FoodTruck[]> => {\r\n      console.info(\r\n        `CachedFoodTruckService: Cache miss - fetching trucks near ${lat},${lng} (${radiusKm}km)`,\r\n      );\r\n      const result = await FoodTruckService.getTrucksByLocation(lat, lng, radiusKm);\r\n      if ('error' in result) {\r\n        throw new Error(`Failed to fetch trucks by location: ${result.error}`);\r\n      }\r\n      return result as FoodTruck[];\r\n    },\r\n    ['trucks-by-location'],\r\n    {\r\n      revalidate: CACHE_CONFIG.SHORT_TTL,\r\n      tags: ['food-trucks', 'location-search'],\r\n    },\r\n  ),\r\n\r\n  /**\r\n   * Get truck by ID with caching\r\n   * Cache for 30 minutes since individual truck data is relatively stable\r\n   */\r\n  getTruckByIdCached: unstable_cache(\r\n    async (id: string): Promise<FoodTruck | null> => {\r\n      console.info(`CachedFoodTruckService: Cache miss - fetching truck ${id} from database`);\r\n      const result = await FoodTruckService.getTruckById(id);\r\n      if ('error' in result) {\r\nreturn null;\r\n      }\r\n      return result as FoodTruck;\r\n    },\r\n    ['truck-by-id'],\r\n    {\r\n      revalidate: CACHE_CONFIG.MEDIUM_TTL,\r\n      tags: ['food-trucks', 'truck-details'],\r\n    },\r\n  ),\r\n\r\n  /**\r\n   * Search trucks with caching\r\n   * Cache for 5 minutes since search results should be relatively fresh\r\n   */\r\n  searchTrucksCached: unstable_cache(\r\n    async (\r\n      query: string,\r\n      filters?: {\r\n        cuisine?: string;\r\n        openNow?: boolean;\r\n        lat?: number;\r\n        lng?: number;\r\n        radius?: number;\r\n      },\r\n    ): Promise<FoodTruck[]> => {\r\n      console.info(`CachedFoodTruckService: Cache miss - searching trucks for \"${query}\"`);\r\n\r\n      if (supabaseAdmin == undefined) {\r\n        throw new Error('Supabase admin client not available');\r\n      }\r\n\r\n      let dbQuery = supabaseAdmin\r\n        .from('food_trucks')\r\n        .select('*')\r\n        .or(`name.ilike.%${query}%,description.ilike.%${query}%,cuisine_type.cs.{${query}}`);\r\n\r\n      // Apply filters\r\n      if (filters?.cuisine != undefined && filters.cuisine !== '') {\r\n        dbQuery = dbQuery.contains('cuisine_type', [filters.cuisine]);\r\n      }\r\n\r\n      const { data, error }: { data: FoodTruck[] | null; error: unknown } = await dbQuery.limit(50);\r\n      const trucks: FoodTruck[] = data ?? [];\r\n\r\n      if (error != undefined) {\r\n        const errorMessage = error instanceof Error ? error.message : JSON.stringify(error);\r\n        throw new Error(`Search query failed: ${errorMessage}`);\r\n      }\r\n\r\n      let results: FoodTruck[] = trucks ?? [];\r\n\r\n      // Apply location filter if provided\r\n      if (filters?.lat != undefined && filters?.lng != undefined && filters?.radius != undefined) {\r\n        results = results.filter((truck: FoodTruck): truck is FoodTruck => {\r\n          if (\r\n            truck.current_location?.lat == undefined ||\r\n            truck.current_location?.lng == undefined\r\n          ) {\r\n            return false;\r\n          }\r\n          const distance = calculateDistance(\r\n            filters.lat!, // Assert as number, as it's checked by the outer if condition\r\n            filters.lng!, // Assert as number, as it's checked by the outer if condition\r\n            truck.current_location.lat,\r\n            truck.current_location.lng,\r\n          );\r\n          return distance <= (filters.radius ?? 10);\r\n        });\r\n      }\r\n\r\n      // Apply openNow filter if provided\r\n      if (filters?.openNow === true) {\r\n        const now = new Date();\r\n        const currentDay = now.toLocaleDateString('en-US', { weekday: 'short' }).toLowerCase(); // 'mon', 'tue', etc.\r\n        const currentTime = now.getHours() * 100 + now.getMinutes(); // HHMM format\r\n\r\n        results = results.filter((truck: FoodTruck): truck is FoodTruck => {\r\n          const hours = truck.operating_hours?.[\r\n            currentDay as keyof typeof truck.operating_hours\r\n          ] as { closed?: boolean; open?: string; close?: string } | undefined;\r\n          if (hours == undefined || hours.closed === true) return false;\r\n\r\n          const openTime = parseTimeString(hours.open ?? '');\r\n          const closeTime = parseTimeString(hours.close ?? '');\r\n\r\n          return currentTime >= openTime && currentTime <= closeTime;\r\n        });\r\n      }\r\n\r\n      return results;\r\n    },\r\n    ['search-trucks'],\r\n    {\r\n      revalidate: CACHE_CONFIG.SHORT_TTL,\r\n      tags: ['food-trucks', 'search'],\r\n    },\r\n  ),\r\n\r\n  /**\r\n   * Get data quality statistics with caching\r\n   * Cache for 24 hours since quality stats change slowly\r\n   */\r\n  getDataQualityStatsCached: unstable_cache(\r\n    async (): Promise<{\r\n      averageScore: number;\r\n      distribution: Record<string, number>;\r\n      totalTrucks: number;\r\n    }> => {\r\n      console.info('CachedFoodTruckService: Cache miss - calculating data quality stats');\r\n\r\n      if (supabaseAdmin == undefined) {\r\n        throw new Error('Supabase admin client not available');\r\n      }\r\n\r\n      const { data: trucks, error } = await supabaseAdmin\r\n        .from('food_trucks')\r\n        .select('data_quality_score');\r\n\r\n      if (error) {\r\n        throw new Error(`Quality stats query failed: ${error.message}`);\r\n      }\r\n\r\n      const scores =\r\n        trucks == undefined\r\n          ? []\r\n          : trucks.map((t: { data_quality_score?: number }) => t.data_quality_score ?? 0);\r\n      const averageScore =\r\n        scores.length > 0\r\n          ? scores.reduce((sum: number, score: number) => sum + score, 0) / scores.length\r\n          : 0;\r\n\r\n      const distribution = {\r\n        high: scores.filter((s: number) => s >= 0.8).length,\r\n        medium: scores.filter((s: number) => s >= 0.6 && s < 0.8).length,\r\n        low: scores.filter((s: number) => s < 0.6).length,\r\n      };\r\n\r\n      return {\r\n        averageScore: Math.round(averageScore * 100) / 100,\r\n        distribution,\r\n        totalTrucks: scores.length,\r\n      };\r\n    },\r\n    ['data-quality-stats'],\r\n    {\r\n      revalidate: CACHE_CONFIG.LONG_TTL,\r\n      tags: ['food-trucks', 'data-quality'],\r\n    },\r\n  ),\r\n};\r\n\r\n/**\r\n * Cache invalidation utilities\r\n */\r\nexport const CacheManager = {\r\n  /**\r\n   * Invalidate all food truck related caches\r\n   */\r\n  async invalidateAllFoodTruckCaches(): Promise<void> {\r\n    try {\r\n      const { revalidateTag } = await import('next/cache');\r\n      revalidateTag('food-trucks');\r\n      console.info('CacheManager: Invalidated all food truck caches');\r\n    } catch (error) {\r\n      console.warn('CacheManager: Failed to invalidate caches:', error);\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Invalidate specific truck cache\r\n   */\r\n  async invalidateTruckCache(truckId: string): Promise<void> {\r\n    try {\r\n      const { revalidateTag } = await import('next/cache');\r\n      revalidateTag(`truck-${truckId}`);\r\n      revalidateTag('food-trucks'); // Also invalidate general caches\r\n      console.info(`CacheManager: Invalidated cache for truck ${truckId}`);\r\n    } catch (error) {\r\n      console.warn('CacheManager: Failed to invalidate truck cache:', error);\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Invalidate search and location caches\r\n   */\r\n  async invalidateSearchCaches(): Promise<void> {\r\n    try {\r\n      const { revalidateTag } = await import('next/cache');\r\n      revalidateTag('search');\r\n      revalidateTag('location-search');\r\n      console.info('CacheManager: Invalidated search caches');\r\n    } catch (error) {\r\n      console.warn('CacheManager: Failed to invalidate search caches:', error);\r\n    }\r\n  },\r\n};\r\n\r\n/**\r\n * Utility functions\r\n */\r\nfunction calculateDistance(lat1: number, lng1: number, lat2: number, lng2: number): number {\r\n  const R = 6371; // Earth's radius in kilometers\r\n  const dLat = ((lat2 - lat1) * Math.PI) / 180;\r\n  const dLng = ((lng2 - lng1) * Math.PI) / 180;\r\n  const a =\r\n    Math.sin(dLat / 2) * Math.sin(dLat / 2) +\r\n    Math.cos((lat1 * Math.PI) / 180) *\r\n      Math.cos((lat2 * Math.PI) / 180) *\r\n      Math.sin(dLng / 2) *\r\n      Math.sin(dLng / 2);\r\n  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\r\n  return R * c;\r\n}\r\n\r\nfunction parseTimeString(timeStr: string): number {\r\n  if (timeStr == undefined || timeStr === '') return 0;\r\n  const [hours, minutes] = timeStr.split(':').map(Number);\r\n  return hours * 100 + (minutes ?? 0);\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\performance\\webVitals.js","messages":[{"ruleId":"unicorn/no-null","severity":1,"message":"Use `undefined` instead of `null`.","line":104,"column":25,"nodeType":"Literal","messageId":"error","endLine":104,"endColumn":29,"suggestions":[{"messageId":"replace","fix":{"range":[3577,3581],"text":"undefined"},"data":{},"desc":"Replace `null` with `undefined`."}]},{"ruleId":"unicorn/no-null","severity":1,"message":"Use `undefined` instead of `null`.","line":114,"column":42,"nodeType":"Literal","messageId":"error","endLine":114,"endColumn":46,"suggestions":[{"messageId":"replace","fix":{"range":[3926,3930],"text":"undefined"},"data":{},"desc":"Replace `null` with `undefined`."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * SOTA Core Web Vitals Monitoring Implementation\n * Tracks LCP, FID, CLS, FCP, and TTFB metrics for performance optimization\n */\nimport { getCLS, getFCP, getFID, getLCP, getTTFB } from 'web-vitals';\n// Performance thresholds based on Google's Core Web Vitals standards\nexport const PERFORMANCE_THRESHOLDS = {\n    LCP: { good: 2500, needsImprovement: 4000 }, // Largest Contentful Paint\n    FID: { good: 100, needsImprovement: 300 }, // First Input Delay\n    CLS: { good: 0.1, needsImprovement: 0.25 }, // Cumulative Layout Shift\n    FCP: { good: 1800, needsImprovement: 3000 }, // First Contentful Paint\n    TTFB: { good: 800, needsImprovement: 1800 }, // Time to First Byte\n};\n// In-memory storage for metrics (in production, send to analytics service)\nconst metricsStore = [];\n/**\n * Categorizes metric value based on thresholds\n */\nfunction getRating(name, value) {\n    const thresholds = PERFORMANCE_THRESHOLDS[name];\n    if (value <= thresholds.good)\n        return 'good';\n    if (value <= thresholds.needsImprovement)\n        return 'needs-improvement';\n    return 'poor';\n}\n/**\n * Processes and stores a web vital metric\n */\nfunction handleMetric(metric) {\n    // Type-safe casting with validation\n    const metricName = String(metric.name);\n    const metricValue = Number(metric.value);\n    const performanceMetric = {\n        name: metricName,\n        value: metricValue,\n        rating: getRating(metricName, metricValue),\n        timestamp: Date.now(),\n        url: globalThis.location.href,\n        userAgent: navigator.userAgent,\n    };\n    // Store metric locally\n    metricsStore.push(performanceMetric);\n    // Send to analytics endpoint (non-blocking)\n    sendMetricToAnalytics(performanceMetric).catch((error) => {\n        console.warn('Failed to send metric to analytics:', error);\n    });\n    // Log performance issues\n    if (performanceMetric.rating === 'poor') {\n        console.warn(`Poor ${metricName} performance:`, {\n            value: metricValue,\n            threshold: PERFORMANCE_THRESHOLDS[metricName],\n            url: performanceMetric.url,\n        });\n    }\n}\n/**\n * Sends metric data to analytics endpoint\n */\nasync function sendMetricToAnalytics(metric) {\n    try {\n        await fetch('/api/analytics/web-vitals', {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json',\n            },\n            body: JSON.stringify(metric),\n        });\n    }\n    catch (error) {\n        // Silently fail - don't impact user experience\n        console.info('Analytics endpoint unavailable:', error);\n    }\n}\n/**\n * Initializes Core Web Vitals monitoring\n * Call this in your app's root component or _app.tsx\n */\nexport function initWebVitalsMonitoring() {\n    try {\n        // Type-safe metric handlers with explicit casting\n        const safeHandleMetric = (metric) => handleMetric(metric);\n        getCLS(safeHandleMetric);\n        getFCP(safeHandleMetric);\n        getFID(safeHandleMetric);\n        getLCP(safeHandleMetric);\n        getTTFB(safeHandleMetric);\n    }\n    catch (error) {\n        console.warn('Failed to initialize web vitals monitoring:', error);\n    }\n}\n/**\n * Gets current performance metrics summary\n */\nexport function getPerformanceMetrics() {\n    const summary = {};\n    // Initialize summary for all metrics\n    for (const metricName of Object.keys(PERFORMANCE_THRESHOLDS)) {\n        const name = metricName;\n        const metricData = metricsStore.filter((m) => m.name === name);\n        if (metricData.length === 0) {\n            summary[name] = {\n                latest: null,\n                average: 0,\n                rating: 'no-data',\n                count: 0,\n            };\n        }\n        else {\n            const latest = metricData.at(-1);\n            const average = metricData.reduce((sum, m) => sum + m.value, 0) / metricData.length;\n            summary[name] = {\n                latest: latest?.value ?? null,\n                average: Math.round(average),\n                rating: getRating(name, average),\n                count: metricData.length,\n            };\n        }\n    }\n    return {\n        metrics: [...metricsStore],\n        summary,\n    };\n}\n/**\n * Performance budget checker\n */\nexport function checkPerformanceBudget() {\n    const { summary } = getPerformanceMetrics();\n    const violations = [];\n    for (const [metricName, data] of Object.entries(summary)) {\n        const name = metricName;\n        if (data.latest == undefined)\n            continue;\n        const thresholds = PERFORMANCE_THRESHOLDS[name];\n        if (data.latest > thresholds.needsImprovement) {\n            violations.push({\n                metric: name,\n                value: data.latest,\n                threshold: thresholds.needsImprovement,\n                severity: 'critical',\n            });\n        }\n        else if (data.latest > thresholds.good) {\n            violations.push({\n                metric: name,\n                value: data.latest,\n                threshold: thresholds.good,\n                severity: 'warning',\n            });\n        }\n    }\n    return {\n        passed: violations.length === 0,\n        violations,\n    };\n}\n/**\n * Generates a list of suggestions to improve Largest Contentful Paint (LCP).\n * @example\n * getLCPSuggestions({ latest: 3000 })\n * Returns an array with LCP improvement suggestions when the latest LCP is 3000ms.\n * @param {Object} data - Contains performance metrics data.\n * @param {number|null} data.latest - The latest LCP measure in milliseconds.\n * @returns {PerformanceSuggestion[]} An array of performance suggestions for optimizing LCP.\n * @description\n *   - The function assumes the LCP target is less than 2500ms.\n *   - Suggestions focus on optimizing various aspects like image loading, server response, and resource preloading.\n */\nfunction getLCPSuggestions(data) {\n    return [\n        {\n            metric: 'LCP',\n            issue: `Largest Contentful Paint is ${data.latest}ms (target: <2500ms)`,\n            suggestions: [\n                'Optimize images with Next.js Image component',\n                'Implement lazy loading for non-critical content',\n                'Use CDN for static assets',\n                'Optimize server response times',\n                'Preload critical resources',\n            ],\n            priority: 'high',\n        },\n    ];\n}\n/**\n * Generates suggestions to improve First Input Delay (FID) performance.\n * @example\n * getFIDSuggestions({ latest: 150 })\n * [\n *   {\n *     metric: 'FID',\n *     issue: 'First Input Delay is 150ms (target: <100ms)',\n *     suggestions: [\n *       'Reduce JavaScript bundle size',\n *       'Implement code splitting',\n *       'Use web workers for heavy computations',\n *       'Optimize third-party scripts',\n *       'Defer non-critical JavaScript',\n *     ],\n *     priority: 'high',\n *   },\n * ]\n * @param {Object} data - Contains the latest FID measurement.\n * @param {number|null} data.latest - The latest FID metric value.\n * @returns {PerformanceSuggestion[]} A list of suggestions to improve FID.\n * @description\n *   - Suggests actionable improvements if FID exceeds target threshold.\n *   - Provides solutions focusing on JS optimizations.\n */\nfunction getFIDSuggestions(data) {\n    return [\n        {\n            metric: 'FID',\n            issue: `First Input Delay is ${data.latest}ms (target: <100ms)`,\n            suggestions: [\n                'Reduce JavaScript bundle size',\n                'Implement code splitting',\n                'Use web workers for heavy computations',\n                'Optimize third-party scripts',\n                'Defer non-critical JavaScript',\n            ],\n            priority: 'high',\n        },\n    ];\n}\n/**\n * Generates performance suggestions based on Cumulative Layout Shift (CLS) data.\n * @example\n * getCLSSuggestions({ latest: 0.25 })\n * // Returns array of suggestions indicating the CLS value and recommendations on improving it.\n * @param {{ latest: number | null }} data - Object containing the latest CLS measurement.\n * @returns {PerformanceSuggestion[]} An array of performance suggestions to address CLS issues.\n * @description\n *   - Suggests best practices to reduce CLS, aiming for a value below 0.1.\n *   - Prioritizes medium concern for updates that could improve visual stability.\n *   - Incorporates practical strategies for developers focusing on layout changes.\n */\nfunction getCLSSuggestions(data) {\n    return [\n        {\n            metric: 'CLS',\n            issue: `Cumulative Layout Shift is ${data.latest} (target: <0.1)`,\n            suggestions: [\n                'Set explicit dimensions for images and videos',\n                'Reserve space for dynamic content',\n                'Use CSS aspect-ratio for responsive images',\n                'Avoid inserting content above existing content',\n                'Use transform animations instead of layout changes',\n            ],\n            priority: 'medium',\n        },\n    ];\n}\n/**\n* Generates suggestions to improve the First Contentful Paint performance metric.\n* @example\n* getFCPSuggestions({ latest: 2000 })\n* Returns an array with suggestions to optimize FCP targeting <1800ms.\n* @param {Object} data - Contains performance metric values.\n* @param {number|null} data.latest - Latest measured FCP value in milliseconds.\n* @returns {PerformanceSuggestion[]} Array of suggestions for improving FCP metric.\n* @description\n*   - Suggests optimizations related to the rendering path and resource loading.\n*   - Provides actions with a medium priority level to improve website performance.\n*/\nfunction getFCPSuggestions(data) {\n    return [\n        {\n            metric: 'FCP',\n            issue: `First Contentful Paint is ${data.latest}ms (target: <1800ms)`,\n            suggestions: [\n                'Optimize critical rendering path',\n                'Inline critical CSS',\n                'Minimize render-blocking resources',\n                'Use resource hints (preload, prefetch)',\n                'Optimize web fonts loading',\n            ],\n            priority: 'medium',\n        },\n    ];\n}\n/**\n * Generates suggestions to improve Time to First Byte (TTFB) performance based on the latest measurement.\n * @example\n * getTTFBSuggestions({ latest: 950 })\n * [\n *   {\n *     metric: 'TTFB',\n *     issue: 'Time to First Byte is 950ms (target: <800ms)',\n *     suggestions: [\n *       'Optimize server response times',\n *       'Use CDN for global distribution',\n *       'Implement server-side caching',\n *       'Optimize database queries',\n *       'Use edge computing for dynamic content'\n *     ],\n *     priority: 'high'\n *   }\n * ]\n * @param {Object} data - An object containing the latest TTFB measurement.\n * @param {number|null} data.latest - The latest TTFB value in milliseconds or null if not available.\n * @returns {PerformanceSuggestion[]} An array containing performance improvement suggestions for TTFB.\n * @description\n *   - The function assumes a target TTFB of under 800ms.\n *   - Generates a high-priority performance suggestion report.\n */\nfunction getTTFBSuggestions(data) {\n    return [\n        {\n            metric: 'TTFB',\n            issue: `Time to First Byte is ${data.latest}ms (target: <800ms)`,\n            suggestions: [\n                'Optimize server response times',\n                'Use CDN for global distribution',\n                'Implement server-side caching',\n                'Optimize database queries',\n                'Use edge computing for dynamic content',\n            ],\n            priority: 'high',\n        },\n    ];\n}\n/**\n * Generates a list of performance optimization suggestions based on Web Vitals metrics.\n * @example\n * getPerformanceOptimizationSuggestions()\n * [\n *   { name: 'Optimize LCP', priority: 'high' },\n *   { name: 'Improve FID', priority: 'medium' }\n * ]\n * @returns {PerformanceSuggestion[]} An array of performance suggestions sorted by priority.\n * @description\n *   - Analyzes performance metrics including LCP, FID, CLS, FCP, and TTFB.\n *   - Generates suggestions only for metrics rated as 'poor' or 'needs-improvement'.\n *   - Prioritizes suggestions based on urgency, sorting them by priority level.\n *   - Utilizes helper functions to generate specific suggestions for each metric type.\n */\nexport function getPerformanceOptimizationSuggestions() {\n    const { summary } = getPerformanceMetrics();\n    let allSuggestions = [];\n    for (const [metricName, data] of Object.entries(summary)) {\n        const name = metricName;\n        if (data.rating === 'poor' || data.rating === 'needs-improvement') {\n            switch (name) {\n                case 'LCP': {\n                    allSuggestions = [...allSuggestions, ...getLCPSuggestions(data)];\n                    break;\n                }\n                case 'FID': {\n                    allSuggestions = [...allSuggestions, ...getFIDSuggestions(data)];\n                    break;\n                }\n                case 'CLS': {\n                    allSuggestions = [...allSuggestions, ...getCLSSuggestions(data)];\n                    break;\n                }\n                case 'FCP': {\n                    allSuggestions = [...allSuggestions, ...getFCPSuggestions(data)];\n                    break;\n                }\n                case 'TTFB': {\n                    allSuggestions = [...allSuggestions, ...getTTFBSuggestions(data)];\n                    break;\n                }\n            }\n        }\n    }\n    return allSuggestions.sort((a, b) => {\n        const priorityOrder = { high: 3, medium: 2, low: 1 };\n        return priorityOrder[b.priority] - priorityOrder[a.priority];\n    });\n}\n","usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\performance\\webVitals.ts","messages":[{"ruleId":"unicorn/no-null","severity":1,"message":"Use `undefined` instead of `null`.","line":145,"column":17,"nodeType":"Literal","messageId":"error","endLine":145,"endColumn":21,"suggestions":[{"messageId":"replace","fix":{"range":[4394,4398],"text":"undefined"},"data":{},"desc":"Replace `null` with `undefined`."}]},{"ruleId":"unicorn/no-null","severity":1,"message":"Use `undefined` instead of `null`.","line":155,"column":34,"nodeType":"Literal","messageId":"error","endLine":155,"endColumn":38,"suggestions":[{"messageId":"replace","fix":{"range":[4686,4690],"text":"undefined"},"data":{},"desc":"Replace `null` with `undefined`."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * SOTA Core Web Vitals Monitoring Implementation\r\n * Tracks LCP, FID, CLS, FCP, and TTFB metrics for performance optimization\r\n */\r\n\r\nimport { getCLS, getFCP, getFID, getLCP, getTTFB, type Metric } from 'web-vitals';\r\n\r\n// Performance thresholds based on Google's Core Web Vitals standards\r\nexport const PERFORMANCE_THRESHOLDS = {\r\n  LCP: { good: 2500, needsImprovement: 4000 }, // Largest Contentful Paint\r\n  FID: { good: 100, needsImprovement: 300 }, // First Input Delay\r\n  CLS: { good: 0.1, needsImprovement: 0.25 }, // Cumulative Layout Shift\r\n  FCP: { good: 1800, needsImprovement: 3000 }, // First Contentful Paint\r\n  TTFB: { good: 800, needsImprovement: 1800 }, // Time to First Byte\r\n} as const;\r\n\r\nexport type MetricName = keyof typeof PERFORMANCE_THRESHOLDS;\r\n\r\nexport interface PerformanceMetric {\r\n  name: MetricName;\r\n  value: number;\r\n  rating: 'good' | 'needs-improvement' | 'poor';\r\n  timestamp: number;\r\n  url: string;\r\n  userAgent: string;\r\n}\r\n\r\n// In-memory storage for metrics (in production, send to analytics service)\r\nconst metricsStore: PerformanceMetric[] = [];\r\n\r\n/**\r\n * Categorizes metric value based on thresholds\r\n */\r\nfunction getRating(name: MetricName, value: number): 'good' | 'needs-improvement' | 'poor' {\r\n  const thresholds = PERFORMANCE_THRESHOLDS[name];\r\n  if (value <= thresholds.good) return 'good';\r\n  if (value <= thresholds.needsImprovement) return 'needs-improvement';\r\n  return 'poor';\r\n}\r\n\r\n/**\r\n * Processes and stores a web vital metric\r\n */\r\nfunction handleMetric(metric: Metric) {\r\n  // Type-safe casting with validation\r\n  const metricName = String((metric as { name: string }).name) as MetricName;\r\n  const metricValue = Number((metric as { value: number }).value);\r\n\r\n  const performanceMetric: PerformanceMetric = {\r\n    name: metricName,\r\n    value: metricValue,\r\n    rating: getRating(metricName, metricValue),\r\n    timestamp: Date.now(),\r\n    url: globalThis.location.href,\r\n    userAgent: navigator.userAgent,\r\n  };\r\n\r\n  // Store metric locally\r\n  metricsStore.push(performanceMetric);\r\n\r\n  // Send to analytics endpoint (non-blocking)\r\n  sendMetricToAnalytics(performanceMetric).catch((error) => {\r\n    console.warn('Failed to send metric to analytics:', error);\r\n  });\r\n\r\n  // Log performance issues\r\n  if (performanceMetric.rating === 'poor') {\r\n    console.warn(`Poor ${metricName} performance:`, {\r\n      value: metricValue,\r\n      threshold: PERFORMANCE_THRESHOLDS[metricName],\r\n      url: performanceMetric.url,\r\n    });\r\n  }\r\n}\r\n\r\n/**\r\n * Sends metric data to analytics endpoint\r\n */\r\nasync function sendMetricToAnalytics(metric: PerformanceMetric): Promise<void> {\r\n  try {\r\n    await fetch('/api/analytics/web-vitals', {\r\n      method: 'POST',\r\n      headers: {\r\n        'Content-Type': 'application/json',\r\n      },\r\n      body: JSON.stringify(metric),\r\n    });\r\n  } catch (error) {\r\n    // Silently fail - don't impact user experience\r\n    console.info('Analytics endpoint unavailable:', error);\r\n  }\r\n}\r\n\r\n/**\r\n * Initializes Core Web Vitals monitoring\r\n * Call this in your app's root component or _app.tsx\r\n */\r\nexport function initWebVitalsMonitoring(): void {\r\n  try {\r\n    // Type-safe metric handlers with explicit casting\r\n    const safeHandleMetric = (metric: Metric) => handleMetric(metric);\r\n\r\n    getCLS(safeHandleMetric);\r\n    getFCP(safeHandleMetric);\r\n    getFID(safeHandleMetric);\r\n    getLCP(safeHandleMetric);\r\n    getTTFB(safeHandleMetric);\r\n  } catch (error) {\r\n    console.warn('Failed to initialize web vitals monitoring:', error);\r\n  }\r\n}\r\n\r\n/**\r\n * Gets current performance metrics summary\r\n */\r\nexport function getPerformanceMetrics(): {\r\n  metrics: PerformanceMetric[];\r\n  summary: Record<\r\n    MetricName,\r\n    {\r\n      latest: number | null;\r\n      average: number;\r\n      rating: 'good' | 'needs-improvement' | 'poor' | 'no-data';\r\n      count: number;\r\n    }\r\n  >;\r\n} {\r\n  const summary = {} as Record<\r\n    MetricName,\r\n    {\r\n      latest: number | null;\r\n      average: number;\r\n      rating: 'good' | 'needs-improvement' | 'poor' | 'no-data';\r\n      count: number;\r\n    }\r\n  >;\r\n\r\n  // Initialize summary for all metrics\r\n  for (const metricName of Object.keys(PERFORMANCE_THRESHOLDS)) {\r\n    const name = metricName as MetricName;\r\n    const metricData = metricsStore.filter((m) => m.name === name);\r\n\r\n    if (metricData.length === 0) {\r\n      summary[name] = {\r\n        latest: null,\r\n        average: 0,\r\n        rating: 'no-data',\r\n        count: 0,\r\n      };\r\n    } else {\r\n      const latest = metricData.at(-1);\r\n      const average = metricData.reduce((sum, m) => sum + m.value, 0) / metricData.length;\r\n\r\n      summary[name] = {\r\n        latest: latest?.value ?? null,\r\n        average: Math.round(average),\r\n        rating: getRating(name, average),\r\n        count: metricData.length,\r\n      };\r\n    }\r\n  }\r\n\r\n  return {\r\n    metrics: [...metricsStore],\r\n    summary,\r\n  };\r\n}\r\n\r\n/**\r\n * Performance budget checker\r\n */\r\nexport function checkPerformanceBudget(): {\r\n  passed: boolean;\r\n  violations: Array<{\r\n    metric: MetricName;\r\n    value: number;\r\n    threshold: number;\r\n    severity: 'warning' | 'critical';\r\n  }>;\r\n} {\r\n  const { summary } = getPerformanceMetrics();\r\n  const violations: Array<{\r\n    metric: MetricName;\r\n    value: number;\r\n    threshold: number;\r\n    severity: 'warning' | 'critical';\r\n  }> = [];\r\n\r\n  for (const [metricName, data] of Object.entries(summary)) {\r\n    const name = metricName as MetricName;\r\n    if (data.latest == undefined) continue;\r\n\r\n    const thresholds = PERFORMANCE_THRESHOLDS[name];\r\n\r\n    if (data.latest > thresholds.needsImprovement) {\r\n      violations.push({\r\n        metric: name,\r\n        value: data.latest,\r\n        threshold: thresholds.needsImprovement,\r\n        severity: 'critical',\r\n      });\r\n    } else if (data.latest > thresholds.good) {\r\n      violations.push({\r\n        metric: name,\r\n        value: data.latest,\r\n        threshold: thresholds.good,\r\n        severity: 'warning',\r\n      });\r\n    }\r\n  }\r\n\r\n  return {\r\n    passed: violations.length === 0,\r\n    violations,\r\n  };\r\n}\r\n\r\n/**\r\n * Performance optimization suggestions based on metrics\r\n */\r\ntype PerformanceSuggestion = {\r\n  metric: MetricName;\r\n  issue: string;\r\n  suggestions: string[];\r\n  priority: 'high' | 'medium' | 'low';\r\n};\r\n\r\n/**\r\n * Generates a list of suggestions to improve Largest Contentful Paint (LCP).\r\n * @example\r\n * getLCPSuggestions({ latest: 3000 })\r\n * Returns an array with LCP improvement suggestions when the latest LCP is 3000ms.\r\n * @param {Object} data - Contains performance metrics data.\r\n * @param {number|null} data.latest - The latest LCP measure in milliseconds.\r\n * @returns {PerformanceSuggestion[]} An array of performance suggestions for optimizing LCP.\r\n * @description\r\n *   - The function assumes the LCP target is less than 2500ms.\r\n *   - Suggestions focus on optimizing various aspects like image loading, server response, and resource preloading.\r\n */\r\nfunction getLCPSuggestions(data: { latest: number | null }): PerformanceSuggestion[] {\r\n  return [\r\n    {\r\n      metric: 'LCP',\r\n      issue: `Largest Contentful Paint is ${data.latest}ms (target: <2500ms)`,\r\n      suggestions: [\r\n        'Optimize images with Next.js Image component',\r\n        'Implement lazy loading for non-critical content',\r\n        'Use CDN for static assets',\r\n        'Optimize server response times',\r\n        'Preload critical resources',\r\n      ],\r\n      priority: 'high',\r\n    },\r\n  ];\r\n}\r\n\r\n/**\r\n * Generates suggestions to improve First Input Delay (FID) performance.\r\n * @example\r\n * getFIDSuggestions({ latest: 150 })\r\n * [\r\n *   {\r\n *     metric: 'FID',\r\n *     issue: 'First Input Delay is 150ms (target: <100ms)',\r\n *     suggestions: [\r\n *       'Reduce JavaScript bundle size',\r\n *       'Implement code splitting',\r\n *       'Use web workers for heavy computations',\r\n *       'Optimize third-party scripts',\r\n *       'Defer non-critical JavaScript',\r\n *     ],\r\n *     priority: 'high',\r\n *   },\r\n * ]\r\n * @param {Object} data - Contains the latest FID measurement.\r\n * @param {number|null} data.latest - The latest FID metric value.\r\n * @returns {PerformanceSuggestion[]} A list of suggestions to improve FID.\r\n * @description\r\n *   - Suggests actionable improvements if FID exceeds target threshold.\r\n *   - Provides solutions focusing on JS optimizations.\r\n */\r\nfunction getFIDSuggestions(data: { latest: number | null }): PerformanceSuggestion[] {\r\n  return [\r\n    {\r\n      metric: 'FID',\r\n      issue: `First Input Delay is ${data.latest}ms (target: <100ms)`,\r\n      suggestions: [\r\n        'Reduce JavaScript bundle size',\r\n        'Implement code splitting',\r\n        'Use web workers for heavy computations',\r\n        'Optimize third-party scripts',\r\n        'Defer non-critical JavaScript',\r\n      ],\r\n      priority: 'high',\r\n    },\r\n  ];\r\n}\r\n\r\n/**\r\n * Generates performance suggestions based on Cumulative Layout Shift (CLS) data.\r\n * @example\r\n * getCLSSuggestions({ latest: 0.25 })\r\n * // Returns array of suggestions indicating the CLS value and recommendations on improving it.\r\n * @param {{ latest: number | null }} data - Object containing the latest CLS measurement.\r\n * @returns {PerformanceSuggestion[]} An array of performance suggestions to address CLS issues.\r\n * @description\r\n *   - Suggests best practices to reduce CLS, aiming for a value below 0.1.\r\n *   - Prioritizes medium concern for updates that could improve visual stability.\r\n *   - Incorporates practical strategies for developers focusing on layout changes.\r\n */\r\nfunction getCLSSuggestions(data: { latest: number | null }): PerformanceSuggestion[] {\r\n  return [\r\n    {\r\n      metric: 'CLS',\r\n      issue: `Cumulative Layout Shift is ${data.latest} (target: <0.1)`,\r\n      suggestions: [\r\n        'Set explicit dimensions for images and videos',\r\n        'Reserve space for dynamic content',\r\n        'Use CSS aspect-ratio for responsive images',\r\n        'Avoid inserting content above existing content',\r\n        'Use transform animations instead of layout changes',\r\n      ],\r\n      priority: 'medium',\r\n    },\r\n  ];\r\n}\r\n\r\n/**\r\n* Generates suggestions to improve the First Contentful Paint performance metric.\r\n* @example\r\n* getFCPSuggestions({ latest: 2000 })\r\n* Returns an array with suggestions to optimize FCP targeting <1800ms.\r\n* @param {Object} data - Contains performance metric values.\r\n* @param {number|null} data.latest - Latest measured FCP value in milliseconds.\r\n* @returns {PerformanceSuggestion[]} Array of suggestions for improving FCP metric.\r\n* @description\r\n*   - Suggests optimizations related to the rendering path and resource loading.\r\n*   - Provides actions with a medium priority level to improve website performance.\r\n*/\r\nfunction getFCPSuggestions(data: { latest: number | null }): PerformanceSuggestion[] {\r\n  return [\r\n    {\r\n      metric: 'FCP',\r\n      issue: `First Contentful Paint is ${data.latest}ms (target: <1800ms)`,\r\n      suggestions: [\r\n        'Optimize critical rendering path',\r\n        'Inline critical CSS',\r\n        'Minimize render-blocking resources',\r\n        'Use resource hints (preload, prefetch)',\r\n        'Optimize web fonts loading',\r\n      ],\r\n      priority: 'medium',\r\n    },\r\n  ];\r\n}\r\n\r\n/**\r\n * Generates suggestions to improve Time to First Byte (TTFB) performance based on the latest measurement.\r\n * @example\r\n * getTTFBSuggestions({ latest: 950 })\r\n * [\r\n *   {\r\n *     metric: 'TTFB',\r\n *     issue: 'Time to First Byte is 950ms (target: <800ms)',\r\n *     suggestions: [\r\n *       'Optimize server response times',\r\n *       'Use CDN for global distribution',\r\n *       'Implement server-side caching',\r\n *       'Optimize database queries',\r\n *       'Use edge computing for dynamic content'\r\n *     ],\r\n *     priority: 'high'\r\n *   }\r\n * ]\r\n * @param {Object} data - An object containing the latest TTFB measurement.\r\n * @param {number|null} data.latest - The latest TTFB value in milliseconds or null if not available.\r\n * @returns {PerformanceSuggestion[]} An array containing performance improvement suggestions for TTFB.\r\n * @description\r\n *   - The function assumes a target TTFB of under 800ms.\r\n *   - Generates a high-priority performance suggestion report.\r\n */\r\nfunction getTTFBSuggestions(data: { latest: number | null }): PerformanceSuggestion[] {\r\n  return [\r\n    {\r\n      metric: 'TTFB',\r\n      issue: `Time to First Byte is ${data.latest}ms (target: <800ms)`,\r\n      suggestions: [\r\n        'Optimize server response times',\r\n        'Use CDN for global distribution',\r\n        'Implement server-side caching',\r\n        'Optimize database queries',\r\n        'Use edge computing for dynamic content',\r\n      ],\r\n      priority: 'high',\r\n    },\r\n  ];\r\n}\r\n\r\n/**\r\n * Generates a list of performance optimization suggestions based on Web Vitals metrics.\r\n * @example\r\n * getPerformanceOptimizationSuggestions()\r\n * [\r\n *   { name: 'Optimize LCP', priority: 'high' },\r\n *   { name: 'Improve FID', priority: 'medium' }\r\n * ]\r\n * @returns {PerformanceSuggestion[]} An array of performance suggestions sorted by priority.\r\n * @description\r\n *   - Analyzes performance metrics including LCP, FID, CLS, FCP, and TTFB.\r\n *   - Generates suggestions only for metrics rated as 'poor' or 'needs-improvement'.\r\n *   - Prioritizes suggestions based on urgency, sorting them by priority level.\r\n *   - Utilizes helper functions to generate specific suggestions for each metric type.\r\n */\r\nexport function getPerformanceOptimizationSuggestions(): PerformanceSuggestion[] {\r\n  const { summary } = getPerformanceMetrics();\r\n  let allSuggestions: PerformanceSuggestion[] = [];\r\n\r\n  for (const [metricName, data] of Object.entries(summary)) {\r\n    const name = metricName as MetricName;\r\n    if (data.rating === 'poor' || data.rating === 'needs-improvement') {\r\n      switch (name) {\r\n        case 'LCP': {\r\n          allSuggestions = [...allSuggestions, ...getLCPSuggestions(data)];\r\n          break;\r\n        }\r\n        case 'FID': {\r\n          allSuggestions = [...allSuggestions, ...getFIDSuggestions(data)];\r\n          break;\r\n        }\r\n        case 'CLS': {\r\n          allSuggestions = [...allSuggestions, ...getCLSSuggestions(data)];\r\n          break;\r\n        }\r\n        case 'FCP': {\r\n          allSuggestions = [...allSuggestions, ...getFCPSuggestions(data)];\r\n          break;\r\n        }\r\n        case 'TTFB': {\r\n          allSuggestions = [...allSuggestions, ...getTTFBSuggestions(data)];\r\n          break;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  return allSuggestions.sort((a, b) => {\r\n    const priorityOrder = { high: 3, medium: 2, low: 1 };\r\n    return priorityOrder[b.priority] - priorityOrder[a.priority];\r\n  });\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\pipelineManager.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\pipelineManager.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\pipelineProcessor.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\pipelineProcessor.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\pipeline\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\pipeline\\pipelineHelpers.js","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error, info.","line":197,"column":5,"nodeType":"MemberExpression","messageId":"limited","endLine":197,"endColumn":16,"suggestions":[{"fix":{"range":[11227,11333],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ScrapingJobService } from '../supabase/services/scrapingJobService.js';\r\nimport { FoodTruckService } from '../supabase/services/foodTruckService.js';\r\nimport { DuplicatePreventionService } from '../data-quality/duplicatePrevention.js';\r\n// Helper function to validate input and prepare basic data\r\n/**\r\n * Validates input data and prepares food truck information.\r\n * @example\r\n * validateInputAndPrepare('job123', extractedTruckDataInstance, 'http://sourceurl.com')\r\n * { isValid: true, name: 'Food Truck Name' }\r\n * @param {string} jobId - The job identifier used for logging and job status updates.\r\n * @param {ExtractedFoodTruckDetails} extractedTruckData - Contains details about the food truck such as name and other attributes.\r\n * @param {string} sourceUrl - URL where the data was originally extracted from.\r\n * @returns {Promise<{ isValid: boolean; name: string }>} Result of validation with food truck name.\r\n * @description\r\n *   - Logs a warning if the source URL is missing, but continues process as it might not be critical.\r\n *   - Ensures the food truck name has a fallback value if it's missing in the extracted data.\r\n *   - Updates job status as 'failed' if validation does not pass.\r\n */\r\nexport async function validateInputAndPrepare(jobId, extractedTruckData, sourceUrl) {\r\n    // Basic input validation\r\n    if (!validateTruckData(jobId, extractedTruckData)) {\r\n        await ScrapingJobService.updateJobStatus(jobId, 'failed', {\r\n            errors: ['Invalid extracted data received from AI processing step.'],\r\n        });\r\n        return { isValid: false, name: '' };\r\n    }\r\n    \r\n    // CRITICAL: If name is null, undefined, empty, or \"Unknown Food Truck\", discard the truck data\r\n    if (!extractedTruckData.name || extractedTruckData.name.trim() === '' || extractedTruckData.name.trim().toLowerCase() === 'unknown food truck') {\r\n        console.info(`Job ${jobId}: Discarding food truck data - no valid name extracted from ${sourceUrl ?? 'Unknown Source'}`);\r\n        await ScrapingJobService.updateJobStatus(jobId, 'completed', {\r\n            completed_at: new Date().toISOString(),\r\n            message: 'No valid food truck name extracted - data discarded'\r\n        });\r\n        return { isValid: false, name: '' };\r\n    }\r\n    \r\n    if (!sourceUrl) {\r\n        // Log a warning but proceed if sourceUrl is missing, as it might not be critical for all data.\r\n        console.warn(`Job ${jobId}: Missing sourceUrl for food truck data, proceeding without it.`);\r\n    }\r\n    \r\n    const name = extractedTruckData.name;\r\n    console.info(`Job ${jobId}: Preparing to create/update food truck: ${name} from ${sourceUrl ?? 'Unknown Source'}`);\r\n    return { isValid: true, name };\r\n}\r\n// New helper function for operating hours\r\n/**\r\n * Constructs a weekly operating hours object for a food truck.\r\n * @example\r\n * buildOperatingHours({ monday: { open: '8:00', close: '17:00' } })\r\n * // Returns: { monday: { open: '8:00', close: '17:00' }, tuesday: { closed: true }, ... }\r\n * @param {ExtractedFoodTruckDetails['operating_hours']} extractedOperatingHours - The raw operating hours extracted for each day of the week.\r\n * @returns {Object} An object containing operating hours for each day of the week, defaulting to closed if not provided.\r\n * @description\r\n *   - Days without specified operating hours default to closed.\r\n *   - Ensures consistency in data structure by providing default closed status.\r\n *   - Uses TypeScript's 'const' assertion for type safety on closed status.\r\n */\r\nfunction buildOperatingHours(extractedOperatingHours) {\r\n    if (extractedOperatingHours == undefined) {\r\n        return {\r\n            monday: { closed: true },\r\n            tuesday: { closed: true },\r\n            wednesday: { closed: true },\r\n            thursday: { closed: true },\r\n            friday: { closed: true },\r\n            saturday: { closed: true },\r\n            sunday: { closed: true },\r\n        };\r\n    }\r\n    return {\r\n        monday: extractedOperatingHours.monday ?? { closed: true },\r\n        tuesday: extractedOperatingHours.tuesday ?? { closed: true },\r\n        wednesday: extractedOperatingHours.wednesday ?? { closed: true },\r\n        thursday: extractedOperatingHours.thursday ?? { closed: true },\r\n        friday: extractedOperatingHours.friday ?? { closed: true },\r\n        saturday: extractedOperatingHours.saturday ?? { closed: true },\r\n        sunday: extractedOperatingHours.sunday ?? { closed: true },\r\n    };\r\n}\r\n// New helper function for scheduled locations\r\n/**\r\n * Transforms and sanitizes an array of scheduled food truck locations.\r\n * @example\r\n * buildScheduledLocations([{ lat: 34.05, lng: -118.25, address: \"123 Main St\", start_time: \"10:00\", end_time: \"14:00\" }])\r\n * [{ lat: 34.05, lng: -118.25, address: \"123 Main St\", start_time: \"10:00\", end_time: \"14:00\", timestamp: \"2023-10-19T14:00:00.000Z\" }]\r\n * @param {ExtractedFoodTruckDetails['scheduled_locations']} scheduledLocations - Array of scheduled food truck location objects.\r\n * @returns {Array} Array of sanitized location objects.\r\n * @description\r\n *   - Ensures latitude and longitude values are numbers; defaults to 0 if not.\r\n *   - Adds a current timestamp to each location object in ISO format.\r\n *   - Uses nullish coalescing to ensure address, start_time, and end_time are either their values or undefined.\r\n */\r\nfunction buildScheduledLocations(scheduledLocations) {\r\n    if (!Array.isArray(scheduledLocations)) {\r\n        return;\r\n    }\r\n    return scheduledLocations.map((loc) => ({\r\n        lat: typeof loc.lat === 'number' ? loc.lat : 0,\r\n        lng: typeof loc.lng === 'number' ? loc.lng : 0,\r\n        address: loc.address ?? undefined,\r\n        start_time: loc.start_time ?? undefined,\r\n        end_time: loc.end_time ?? undefined,\r\n        timestamp: new Date().toISOString(),\r\n    }));\r\n}\r\n// Helper function to build truck data schema\r\n/**\r\n * Constructs a FoodTruckSchema object from extracted food truck details.\r\n * @example\r\n * buildTruckDataSchema(extractedTruckData, 'http://sourceUrl.com', 'Truck Name')\r\n * { name: 'Truck Name', ... }\r\n * @param {ExtractedFoodTruckDetails} extractedTruckData - Object containing raw data extracted from a food truck resource.\r\n * @param {string} sourceUrl - URL source where the truck data was extracted from.\r\n * @param {string} name - Name of the food truck.\r\n * @returns {FoodTruckSchema} Fully constructed food truck schema ready for use.\r\n * @description\r\n *   - Ensures `description` and `price_range` are kept undefined if missing or null from extracted data.\r\n *   - Filters any non-string values from the `cuisine_type` array.\r\n *   - Ensures the `source_urls` field is always an array, even if empty or undefined.\r\n *   - Default verification status is 'pending' and a default data quality score is set to 0.5.\r\n */\r\nexport function buildTruckDataSchema(extractedTruckData, sourceUrl, name) {\r\n    const currentLocation = buildLocationData(extractedTruckData);\r\n    return {\r\n        name: name,\r\n        description: extractedTruckData.description, // Keep as undefined if null/missing\r\n        current_location: currentLocation,\r\n        scheduled_locations: buildScheduledLocations(extractedTruckData.scheduled_locations),\r\n        operating_hours: buildOperatingHours(extractedTruckData.operating_hours),\r\n        menu: processMenuData(extractedTruckData),\r\n        contact_info: buildContactInfo(extractedTruckData.contact_info),\r\n        social_media: buildSocialMedia(extractedTruckData.social_media),\r\n        cuisine_type: Array.isArray(extractedTruckData.cuisine_type)\r\n            ? extractedTruckData.cuisine_type.filter((c) => typeof c === 'string')\r\n            : [],\r\n        price_range: extractedTruckData.price_range, // Ensure it's one of the allowed enum values or undefined\r\n        specialties: Array.isArray(extractedTruckData.specialties)\r\n            ? extractedTruckData.specialties\r\n            : [],\r\n        data_quality_score: 0.5, // Default score - confidence_score not available in type\r\n        verification_status: 'pending',\r\n        source_urls: sourceUrl != undefined && sourceUrl !== '' ? [sourceUrl] : [], // Ensure source_urls is always an array\r\n        last_scraped_at: new Date().toISOString(),\r\n    };\r\n}\r\n// Helper function to handle duplicate checking and resolution\r\n/**\r\n * Checks for duplicates before creating a new food truck entry.\r\n * @example\r\n * handleDuplicateCheck('12345', truckDataObject, 'Awesome Food Truck')\r\n * // Returns a promise resolving to the created truck object or result from handling a duplicate.\r\n * @param {string} jobId - The unique identifier for the job process.\r\n * @param {FoodTruckSchema} truckData - The data schema representing the food truck details.\r\n * @param {string} name - The name of the food truck being processed.\r\n * @returns {Promise<FoodTruck>} Returns a promise that resolves to the created or existing food truck.\r\n * @description\r\n *   - Utilizes the DuplicatePreventionService to verify if a similar truck already exists.\r\n *   - If a duplicate is detected, delegates to a separate function to handle the duplicate scenario.\r\n *   - Logs errors encountered during the creation process.\r\n */\r\nexport async function handleDuplicateCheck(jobId, truckData, name) {\r\n    // Check for duplicates before creating\r\n    console.info(`Job ${jobId}: Checking for duplicates before creating truck: ${name}`);\r\n    const duplicateCheck = await DuplicatePreventionService.checkForDuplicates(truckData);\r\n    if (duplicateCheck.isDuplicate && duplicateCheck.bestMatch) {\r\n        return await handleDuplicate(jobId, truckData, duplicateCheck);\r\n    }\r\n    // No duplicates found, create new truck\r\n    const truck = await FoodTruckService.createTruck(truckData);\r\n    if ('error' in truck) {\r\n        console.error(`Job ${jobId}: Error creating new truck: ${truck.error}`);\r\n        throw new Error(`Failed to create truck: ${truck.error}`);\r\n    }\r\n    return truck;\r\n}\r\n/**\r\n * Handles potential duplicate food truck entries by either merging, updating, or creating new truck data.\r\n * @example\r\n * handleDuplicate(\"job123\", truckData, duplicateCheck)\r\n * // Returns the processed Food Truck object.\r\n * @param {string} jobId - Unique identifier for the job processing potential duplicates.\r\n * @param {FoodTruckSchema} truckData - Data representing the food truck to be processed.\r\n * @param {DuplicateCheckResult} duplicateCheck - Results from a duplicate check operation.\r\n * @returns {Promise<FoodTruck>} Returns a promise that resolves to a Food Truck object if successful.\r\n * @description\r\n *   - Uses duplicate check results to determine whether to merge, update, or create new truck data.\r\n *   - Logs information about the operation performed and potential duplicates found.\r\n *   - Contains error handling for each operation, including fallback creations in case of failures.\r\n *   - Provides warnings when creating new entries despite finding possible duplicates.\r\n */\r\nasync function handleDuplicate(jobId, truckData, duplicateCheck) {\r\n    const { bestMatch } = duplicateCheck;\r\n    // Regex to validate UUID format\r\n    const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;\r\n    console.log(`Job ${jobId}: Debugging UUID - bestMatch.existingTruck.id: ${bestMatch?.existingTruck?.id}`);\r\n    if (!bestMatch || !uuidRegex.test(bestMatch.existingTruck.id)) {\r\n        console.warn(`Job ${jobId}: Invalid or missing existingTruck.id (${bestMatch?.existingTruck?.id}) for duplicate. Creating new truck.`);\r\n        const truck = await FoodTruckService.createTruck(truckData);\r\n        if ('error' in truck) {\r\n            throw new Error(`Failed to create truck: ${truck.error}`);\r\n        }\r\n        return truck;\r\n    }\r\n\r\n    console.info(`Job ${jobId}: Found potential duplicate (${Math.round(bestMatch.similarity * 100)}% similarity) with truck: ${bestMatch.existingTruck.name}`);\r\n    if (bestMatch.confidence === 'high' && bestMatch.recommendation === 'merge') {\r\n        const truck = await DuplicatePreventionService.mergeDuplicates(bestMatch.existingTruck.id, bestMatch.existingTruck.id);\r\n        if ('error' in truck) {\r\n            console.error(`Job ${jobId}: Error merging duplicates: ${truck.error}`);\r\n            const newTruck = await FoodTruckService.createTruck(truckData);\r\n            if ('error' in newTruck) {\r\n                console.error(`Job ${jobId}: Error creating truck after merge failure: ${newTruck.error}`);\r\n                throw new Error(`Failed to merge or create truck: ${newTruck.error}`);\r\n            }\r\n            return newTruck;\r\n        }\r\n        console.info(`Job ${jobId}: Merged data with existing truck: ${truck.name} (ID: ${truck.id})`);\r\n        return truck;\r\n    }\r\n    else if (bestMatch.recommendation === 'update') {\r\n        const truck = await FoodTruckService.updateTruck(bestMatch.existingTruck.id, truckData);\r\n        if ('error' in truck) {\r\n            console.error(`Job ${jobId}: Error updating existing truck: ${truck.error}`);\r\n            const newTruck = await FoodTruckService.createTruck(truckData);\r\n            if ('error' in newTruck) {\r\n                console.error(`Job ${jobId}: Error creating truck after update failure: ${newTruck.error}`);\r\n                throw new Error(`Failed to update or create truck: ${newTruck.error}`);\r\n            }\r\n            return newTruck;\r\n        }\r\n        console.info(`Job ${jobId}: Updated existing truck: ${truck.name} (ID: ${truck.id})`);\r\n        return truck;\r\n    }\r\n    else {\r\n        const truck = await FoodTruckService.createTruck(truckData);\r\n        if ('error' in truck) {\r\n            console.error(`Job ${jobId}: Error creating truck despite potential duplicate: ${truck.error}`);\r\n            throw new Error(`Failed to create truck: ${truck.error}`);\r\n        }\r\n        console.warn(`Job ${jobId}: Created new truck despite potential duplicate (${duplicateCheck.reason ?? 'unknown reason'})`);\r\n        return truck;\r\n    }\r\n}\r\n// Helper function to finalize job status\r\n/**\r\n* Logs the successful creation of a food truck and updates the job status to completed.\r\n* @example\r\n* finalizeJobStatus('12345', { name: 'Best Food Truck', id: 'FT123' }, 'http://example.com')\r\n* // Logs: Job 12345: Successfully created food truck: Best Food Truck (ID: FT123) from http://example.com\r\n* @param {string} jobId - Unique identifier of the scraping job.\r\n* @param {FoodTruck} truck - Object representing the food truck that was created.\r\n* @param {string} sourceUrl - URL from where the data was sourced.\r\n* @returns {Promise<void>} Resolves when the job status is updated.\r\n* @description\r\n*   - Logs the truck creation event using `console.info`.\r\n*   - Ensures the job status is set to 'completed' with the current timestamp.\r\n*   - Uses a default source message if sourceUrl is not provided.\r\n*/\r\nexport async function finalizeJobStatus(jobId, truck, sourceUrl) {\r\n    console.info(`Job ${jobId}: Successfully created food truck: ${truck.name} (ID: ${truck.id}) from ${sourceUrl ?? 'Unknown Source'}`);\r\n    // Link truck_id back to the scraping job\r\n    await ScrapingJobService.updateJobStatus(jobId, 'completed', {\r\n        completed_at: new Date().toISOString(),\r\n    });\r\n}\r\n// Helper function to validate input data\r\nfunction validateTruckData(jobId, extractedTruckData) {\r\n    if (extractedTruckData == undefined || typeof extractedTruckData !== 'object') {\r\n        console.error(`Job ${jobId}: Invalid extractedTruckData, cannot create/update food truck.`);\r\n        return false;\r\n    }\r\n    return true;\r\n}\r\n// Helper function to build location data\r\n/**\r\n * Constructs location data from extracted truck details.\r\n * @example\r\n * buildLocationData({\r\n *   current_location: {\r\n *     address: \"123 Example St\",\r\n *     city: \"Sample City\",\r\n *     state: \"SC\",\r\n *     zip_code: \"12345\",\r\n *     lat: 34.05,\r\n *     lng: -118.25,\r\n *     raw_text: \"Raw Location Data\"\r\n *   }\r\n * })\r\n * // Returns: {\r\n * //   lat: 34.05,\r\n * //   lng: -118.25,\r\n * //   address: \"123 Example St, Sample City, SC, 12345\",\r\n * //   timestamp: \"2023-09-15T14:38:00.000Z\"\r\n * // }\r\n * @param {ExtractedFoodTruckDetails} extractedTruckData - Details of the food truck, including its current location.\r\n * @returns {Object} Location data comprising latitude, longitude, formatted address, and current timestamp.\r\n * @description\r\n *   - Constructs a full address by combining address components.\r\n *   - Defaults latitude and longitude to 0 if not provided as numbers.\r\n *   - Uses raw text as address if address components are missing.\r\n *   - Generates an ISO 8601 timestamp for the current date and time.\r\n */\r\nfunction buildLocationData(extractedTruckData) {\r\n    const locationData = extractedTruckData.current_location ?? {};\r\n    const fullAddress = [\r\n        locationData.address,\r\n        locationData.city,\r\n        locationData.state,\r\n        locationData.zip_code,\r\n    ]\r\n        .filter(Boolean)\r\n        .join(', ');\r\n    return {\r\n        lat: typeof locationData.lat === 'number' ? locationData.lat : 0,\r\n        lng: typeof locationData.lng === 'number' ? locationData.lng : 0,\r\n        address: fullAddress || locationData.raw_text,\r\n        timestamp: new Date().toISOString(),\r\n    };\r\n}\r\n// New helper function for contact info\r\nfunction buildContactInfo(contactInfo) {\r\n    return {\r\n        phone: contactInfo?.phone,\r\n        email: contactInfo?.email,\r\n        website: contactInfo?.website,\r\n    };\r\n}\r\n// New helper function for social media\r\nfunction buildSocialMedia(socialMedia) {\r\n    return {\r\n        instagram: socialMedia?.instagram,\r\n        facebook: socialMedia?.facebook,\r\n        twitter: socialMedia?.twitter,\r\n        tiktok: socialMedia?.tiktok,\r\n        yelp: socialMedia?.yelp,\r\n    };\r\n}\r\n// Type guard for RawMenuCategory\r\nfunction isRawMenuCategory(obj) {\r\n    return (typeof obj === 'object' &&\r\n        obj != undefined &&\r\n        ('category' in obj || 'name' in obj || 'items' in obj));\r\n}\r\n// Type guard for RawMenuItem\r\nfunction isRawMenuItem(obj) {\r\n    return (typeof obj === 'object' &&\r\n        obj != undefined &&\r\n        ('name' in obj || 'description' in obj || 'price' in obj || 'dietary_tags' in obj));\r\n}\r\n// Helper function to process menu data\r\n/**\r\n * Processes extracted food truck data into structured menu categories.\r\n * @example\r\n * processMenuData(sample_truck_data)\r\n * [ { name: 'Uncategorized', items: [{ name: 'Pizza', description: 'Cheese Pizza', price: 9.99, dietary_tags: ['vegetarian'] }] } ]\r\n * @param {ExtractedFoodTruckDetails} extractedTruckData - The extracted food truck data.\r\n * @returns {MenuCategory[]} Array of structured menu categories.\r\n * @description\r\n *   - Validates categories and items before mapping to a structured format.\r\n *   - Converts item price to number and handles invalid input gracefully.\r\n *   - Provides default values for category and item names in the case of invalid data.\r\n *   - Logs warnings for encountered invalid category or item data.\r\n */\r\nfunction processMenuData(extractedTruckData) {\r\n    if (!Array.isArray(extractedTruckData.menu)) {\r\n        return [];\r\n    }\r\n    return extractedTruckData.menu.map((category) => {\r\n        if (!isRawMenuCategory(category)) {\r\n            console.warn('Invalid category data encountered:', category);\r\n            return { name: 'Invalid Category', items: [] };\r\n        }\r\n        const items = (Array.isArray(category.items) ? category.items : []).map((item) => {\r\n            if (!isRawMenuItem(item)) {\r\n                console.warn('Invalid item data encountered:', item);\r\n                return {\r\n                    name: 'Invalid Item',\r\n                    dietary_tags: [],\r\n                };\r\n            }\r\n            let price;\r\n            if (typeof item.price === 'number') {\r\n                price = item.price;\r\n            }\r\n            else if (typeof item.price === 'string') {\r\n                const parsedPrice = Number.parseFloat(item.price.replaceAll(/[^\\d.-]/g, ''));\r\n                if (!Number.isNaN(parsedPrice)) {\r\n                    price = parsedPrice;\r\n                }\r\n            }\r\n            return {\r\n                name: item.name ?? 'Unknown Item',\r\n                description: item.description,\r\n                price: price,\r\n                dietary_tags: Array.isArray(item.dietary_tags) ? item.dietary_tags : [],\r\n            };\r\n        });\r\n        return {\r\n            name: category.category ?? category.name ?? 'Uncategorized',\r\n            items: items,\r\n        };\r\n    });\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\pipeline\\pipelineHelpers.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":39,"column":8,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":39,"endColumn":31,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[2049,2073],"text":"(extractedTruckData.name == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[2050,2073],"text":"(extractedTruckData.name ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[2049,2073],"text":"(!Boolean(extractedTruckData.name))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { ExtractedFoodTruckDetails, FoodTruckSchema, MenuCategory, MenuItem } from '../types';\r\nimport { ScrapingJobService, FoodTruckService, type FoodTruck } from '../supabase';\r\nimport { DuplicatePreventionService } from '../data-quality/duplicatePrevention';\r\n\r\n// Helper function to validate input and prepare basic data\r\n/**\r\n * Validates input data and prepares food truck information.\r\n * @example\r\n * validateInputAndPrepare('job123', extractedTruckDataInstance, 'http://sourceurl.com')\r\n * { isValid: true, name: 'Food Truck Name' }\r\n * @param {string} jobId - The job identifier used for logging and job status updates.\r\n * @param {ExtractedFoodTruckDetails} extractedTruckData - Contains details about the food truck such as name and other attributes.\r\n * @param {string} sourceUrl - URL where the data was originally extracted from.\r\n * @returns {Promise<{ isValid: boolean; name: string }>} Result of validation with food truck name.\r\n * @description\r\n *   - Logs a warning if the source URL is missing, but continues process as it might not be critical.\r\n *   - Ensures the food truck name has a fallback value if it's missing in the extracted data.\r\n *   - Updates job status as 'failed' if validation does not pass.\r\n */\r\nexport async function validateInputAndPrepare(\r\n  jobId: string,\r\n  extractedTruckData: ExtractedFoodTruckDetails,\r\n  sourceUrl: string,\r\n): Promise<{ isValid: boolean; name: string }> {\r\n  // Basic input validation\r\n  if (!validateTruckData(jobId, extractedTruckData)) {\r\n    await ScrapingJobService.updateJobStatus(jobId, 'failed', {\r\n      errors: ['Invalid extracted data received from AI processing step.'],\r\n    });\r\n    return { isValid: false, name: '' };\r\n  }\r\n\r\n  if (!sourceUrl) {\r\n    // Log a warning but proceed if sourceUrl is missing, as it might not be critical for all data.\r\n    console.warn(`Job ${jobId}: Missing sourceUrl for food truck data, proceeding without it.`);\r\n  }\r\n\r\n  // CRITICAL: If name is null, undefined, empty, or \"Unknown Food Truck\", discard the truck data\r\n  if (!extractedTruckData.name || extractedTruckData.name.trim() === '' || extractedTruckData.name.trim().toLowerCase() === 'unknown food truck') {\r\n    console.info(`Job ${jobId}: Discarding truck data - invalid name: \"${extractedTruckData.name}\"`);\r\n    await ScrapingJobService.updateJobStatus(jobId, 'failed', {\r\n      errors: ['Invalid food truck name - data discarded to prevent \"Unknown Food Truck\" entries'],\r\n    });\r\n    return { isValid: false, name: '' };\r\n  }\r\n\r\n  const name = extractedTruckData.name;\r\n  console.info(\r\n    `Job ${jobId}: Preparing to create/update food truck: ${name} from ${sourceUrl ?? 'Unknown Source'}`,\r\n  );\r\n\r\n  return { isValid: true, name };\r\n}\r\n\r\n// New helper function for operating hours\r\n/**\r\n * Constructs a weekly operating hours object for a food truck.\r\n * @example\r\n * buildOperatingHours({ monday: { open: '8:00', close: '17:00' } })\r\n * // Returns: { monday: { open: '8:00', close: '17:00' }, tuesday: { closed: true }, ... }\r\n * @param {ExtractedFoodTruckDetails['operating_hours']} extractedOperatingHours - The raw operating hours extracted for each day of the week.\r\n * @returns {Object} An object containing operating hours for each day of the week, defaulting to closed if not provided.\r\n * @description\r\n *   - Days without specified operating hours default to closed.\r\n *   - Ensures consistency in data structure by providing default closed status.\r\n *   - Uses TypeScript's 'const' assertion for type safety on closed status.\r\n */\r\nfunction buildOperatingHours(\r\n  extractedOperatingHours: ExtractedFoodTruckDetails['operating_hours'],\r\n) {\r\n  if (extractedOperatingHours == undefined) {\r\n    return {\r\n      monday: { closed: true as const },\r\n      tuesday: { closed: true as const },\r\n      wednesday: { closed: true as const },\r\n      thursday: { closed: true as const },\r\n      friday: { closed: true as const },\r\n      saturday: { closed: true as const },\r\n      sunday: { closed: true as const },\r\n    };\r\n  }\r\n  return {\r\n    monday: extractedOperatingHours.monday ?? { closed: true as const },\r\n    tuesday: extractedOperatingHours.tuesday ?? { closed: true as const },\r\n    wednesday: extractedOperatingHours.wednesday ?? { closed: true as const },\r\n    thursday: extractedOperatingHours.thursday ?? { closed: true as const },\r\n    friday: extractedOperatingHours.friday ?? { closed: true as const },\r\n    saturday: extractedOperatingHours.saturday ?? { closed: true as const },\r\n    sunday: extractedOperatingHours.sunday ?? { closed: true as const },\r\n  };\r\n}\r\n\r\n// New helper function for scheduled locations\r\n/**\r\n * Transforms and sanitizes an array of scheduled food truck locations.\r\n * @example\r\n * buildScheduledLocations([{ lat: 34.05, lng: -118.25, address: \"123 Main St\", start_time: \"10:00\", end_time: \"14:00\" }])\r\n * [{ lat: 34.05, lng: -118.25, address: \"123 Main St\", start_time: \"10:00\", end_time: \"14:00\", timestamp: \"2023-10-19T14:00:00.000Z\" }]\r\n * @param {ExtractedFoodTruckDetails['scheduled_locations']} scheduledLocations - Array of scheduled food truck location objects.\r\n * @returns {Array} Array of sanitized location objects.\r\n * @description\r\n *   - Ensures latitude and longitude values are numbers; defaults to 0 if not.\r\n *   - Adds a current timestamp to each location object in ISO format.\r\n *   - Uses nullish coalescing to ensure address, start_time, and end_time are either their values or undefined.\r\n */\r\nfunction buildScheduledLocations(\r\n  scheduledLocations: ExtractedFoodTruckDetails['scheduled_locations'],\r\n) {\r\n  if (!Array.isArray(scheduledLocations)) {\r\n    return;\r\n  }\r\n  return scheduledLocations.map((loc) => ({\r\n    lat: typeof loc.lat === 'number' ? loc.lat : 0,\r\n    lng: typeof loc.lng === 'number' ? loc.lng : 0,\r\n    address: loc.address ?? undefined,\r\n    start_time: loc.start_time ?? undefined,\r\n    end_time: loc.end_time ?? undefined,\r\n    timestamp: new Date().toISOString(),\r\n  }));\r\n}\r\n\r\n// Helper function to build truck data schema\r\n/**\r\n * Constructs a FoodTruckSchema object from extracted food truck details.\r\n * @example\r\n * buildTruckDataSchema(extractedTruckData, 'http://sourceUrl.com', 'Truck Name')\r\n * { name: 'Truck Name', ... }\r\n * @param {ExtractedFoodTruckDetails} extractedTruckData - Object containing raw data extracted from a food truck resource.\r\n * @param {string} sourceUrl - URL source where the truck data was extracted from.\r\n * @param {string} name - Name of the food truck.\r\n * @returns {FoodTruckSchema} Fully constructed food truck schema ready for use.\r\n * @description\r\n *   - Ensures `description` and `price_range` are kept undefined if missing or null from extracted data.\r\n *   - Filters any non-string values from the `cuisine_type` array.\r\n *   - Ensures the `source_urls` field is always an array, even if empty or undefined.\r\n *   - Default verification status is 'pending' and a default data quality score is set to 0.5.\r\n */\r\nexport function buildTruckDataSchema(\r\n  extractedTruckData: ExtractedFoodTruckDetails,\r\n  sourceUrl: string,\r\n  name: string,\r\n): FoodTruckSchema {\r\n  const currentLocation = buildLocationData(extractedTruckData);\r\n\r\n  return {\r\n    name: name,\r\n    description: extractedTruckData.description ?? undefined, // Keep as undefined if null/missing\r\n    current_location: currentLocation,\r\n    scheduled_locations: buildScheduledLocations(extractedTruckData.scheduled_locations),\r\n    operating_hours: buildOperatingHours(extractedTruckData.operating_hours),\r\n    menu: processMenuData(extractedTruckData),\r\n    contact_info: buildContactInfo(extractedTruckData.contact_info),\r\n    social_media: buildSocialMedia(extractedTruckData.social_media),\r\n    cuisine_type: Array.isArray(extractedTruckData.cuisine_type)\r\n      ? extractedTruckData.cuisine_type.filter((c) => typeof c === 'string')\r\n      : [],\r\n    price_range: extractedTruckData.price_range ?? undefined, // Ensure it's one of the allowed enum values or undefined\r\n    specialties: Array.isArray(extractedTruckData.specialties)\r\n      ? extractedTruckData.specialties\r\n      : [],\r\n    data_quality_score: 0.5, // Default score - confidence_score not available in type\r\n    verification_status: 'pending',\r\n    source_urls: sourceUrl != undefined && sourceUrl !== '' ? [sourceUrl] : [], // Ensure source_urls is always an array\r\n    last_scraped_at: new Date().toISOString(),\r\n  };\r\n}\r\n\r\ninterface DuplicateCheckResult {\r\n  isDuplicate: boolean;\r\n  matches: {\r\n    existingTruck: FoodTruck;\r\n    similarity: number;\r\n    matchedFields: string[];\r\n    confidence: 'high' | 'medium' | 'low';\r\n    recommendation: 'merge' | 'update' | 'skip' | 'manual_review';\r\n  }[];\r\n  bestMatch?: {\r\n    existingTruck: FoodTruck;\r\n    similarity: number;\r\n    confidence: 'high' | 'medium' | 'low';\r\n    recommendation: 'merge' | 'update' | 'skip' | 'manual_review';\r\n  };\r\n  action: 'create' | 'update' | 'merge' | 'manual_review';\r\n  reason: string;\r\n}\r\n\r\n// Helper function to handle duplicate checking and resolution\r\n/**\r\n * Checks for duplicates before creating a new food truck entry.\r\n * @example\r\n * handleDuplicateCheck('12345', truckDataObject, 'Awesome Food Truck')\r\n * // Returns a promise resolving to the created truck object or result from handling a duplicate.\r\n * @param {string} jobId - The unique identifier for the job process.\r\n * @param {FoodTruckSchema} truckData - The data schema representing the food truck details.\r\n * @param {string} name - The name of the food truck being processed.\r\n * @returns {Promise<FoodTruck>} Returns a promise that resolves to the created or existing food truck.\r\n * @description\r\n *   - Utilizes the DuplicatePreventionService to verify if a similar truck already exists.\r\n *   - If a duplicate is detected, delegates to a separate function to handle the duplicate scenario.\r\n *   - Logs errors encountered during the creation process.\r\n */\r\nexport async function handleDuplicateCheck(\r\n  jobId: string,\r\n  truckData: FoodTruckSchema,\r\n  name: string,\r\n): Promise<FoodTruck> {\r\n  // Check for duplicates before creating\r\n  console.info(`Job ${jobId}: Checking for duplicates before creating truck: ${name}`);\r\n  const duplicateCheck: DuplicateCheckResult =\r\n    await DuplicatePreventionService.checkForDuplicates(truckData);\r\n\r\n  if (duplicateCheck.isDuplicate && duplicateCheck.bestMatch) {\r\n    return await handleDuplicate(jobId, truckData, duplicateCheck);\r\n  } \r\n    // No duplicates found, create new truck\r\n    const truck = await FoodTruckService.createTruck(truckData);\r\n    if ('error' in truck) {\r\n      console.error(`Job ${jobId}: Error creating new truck: ${truck.error}`);\r\n      throw new Error(`Failed to create truck: ${truck.error}`);\r\n    }\r\n    return truck;\r\n  \r\n}\r\n\r\n/**\r\n * Handles potential duplicate food truck entries by either merging, updating, or creating new truck data.\r\n * @example\r\n * handleDuplicate(\"job123\", truckData, duplicateCheck)\r\n * // Returns the processed Food Truck object.\r\n * @param {string} jobId - Unique identifier for the job processing potential duplicates.\r\n * @param {FoodTruckSchema} truckData - Data representing the food truck to be processed.\r\n * @param {DuplicateCheckResult} duplicateCheck - Results from a duplicate check operation.\r\n * @returns {Promise<FoodTruck>} Returns a promise that resolves to a Food Truck object if successful.\r\n * @description\r\n *   - Uses duplicate check results to determine whether to merge, update, or create new truck data.\r\n *   - Logs information about the operation performed and potential duplicates found.\r\n *   - Contains error handling for each operation, including fallback creations in case of failures.\r\n *   - Provides warnings when creating new entries despite finding possible duplicates.\r\n */\r\nasync function handleDuplicate(\r\n  jobId: string,\r\n  truckData: FoodTruckSchema,\r\n  duplicateCheck: DuplicateCheckResult,\r\n): Promise<FoodTruck> {\r\n  const { bestMatch } = duplicateCheck;\r\n  if (!bestMatch) {\r\n    // This should not happen if isDuplicate is true, but as a safeguard:\r\n    const truck = await FoodTruckService.createTruck(truckData);\r\n    if ('error' in truck) {\r\n      throw new Error(`Failed to create truck: ${truck.error}`);\r\n    }\r\n    return truck;\r\n  }\r\n\r\n  console.info(\r\n    `Job ${jobId}: Found potential duplicate (${Math.round(bestMatch.similarity * 100)}% similarity) with truck: ${bestMatch.existingTruck.name}`,\r\n  );\r\n\r\n  if (bestMatch.confidence === 'high' && bestMatch.recommendation === 'merge') {\r\n    const truck = await DuplicatePreventionService.mergeDuplicates(\r\n      bestMatch.existingTruck.id,\r\n      bestMatch.existingTruck.id,\r\n    );\r\n    if ('error' in truck) {\r\n      console.error(`Job ${jobId}: Error merging duplicates: ${truck.error}`);\r\n      const newTruck = await FoodTruckService.createTruck(truckData);\r\n      if ('error' in newTruck) {\r\n        console.error(`Job ${jobId}: Error creating truck after merge failure: ${newTruck.error}`);\r\n        throw new Error(`Failed to merge or create truck: ${newTruck.error}`);\r\n      }\r\n      return newTruck;\r\n    } \r\n      console.info(\r\n        `Job ${jobId}: Merged data with existing truck: ${truck.name} (ID: ${truck.id})`,\r\n      );\r\n      return truck;\r\n    \r\n  } else if (bestMatch.recommendation === 'update') {\r\n    const truck = await FoodTruckService.updateTruck(bestMatch.existingTruck.id, truckData);\r\n    if ('error' in truck) {\r\n      console.error(`Job ${jobId}: Error updating existing truck: ${truck.error}`);\r\n      const newTruck = await FoodTruckService.createTruck(truckData);\r\n      if ('error' in newTruck) {\r\n        console.error(`Job ${jobId}: Error creating truck after update failure: ${newTruck.error}`);\r\n        throw new Error(`Failed to update or create truck: ${newTruck.error}`);\r\n      }\r\n      return newTruck;\r\n    } \r\n      console.info(`Job ${jobId}: Updated existing truck: ${truck.name} (ID: ${truck.id})`);\r\n      return truck;\r\n    \r\n  } else {\r\n    const truck = await FoodTruckService.createTruck(truckData);\r\n    if ('error' in truck) {\r\n      console.error(\r\n        `Job ${jobId}: Error creating truck despite potential duplicate: ${truck.error}`,\r\n      );\r\n      throw new Error(`Failed to create truck: ${truck.error}`);\r\n    }\r\n    console.warn(\r\n      `Job ${jobId}: Created new truck despite potential duplicate (${duplicateCheck.reason ?? 'unknown reason'})`,\r\n    );\r\n    return truck;\r\n  }\r\n}\r\n\r\n// Helper function to finalize job status\r\n/**\r\n* Logs the successful creation of a food truck and updates the job status to completed.\r\n* @example\r\n* finalizeJobStatus('12345', { name: 'Best Food Truck', id: 'FT123' }, 'http://example.com')\r\n* // Logs: Job 12345: Successfully created food truck: Best Food Truck (ID: FT123) from http://example.com\r\n* @param {string} jobId - Unique identifier of the scraping job.\r\n* @param {FoodTruck} truck - Object representing the food truck that was created.\r\n* @param {string} sourceUrl - URL from where the data was sourced.\r\n* @returns {Promise<void>} Resolves when the job status is updated.\r\n* @description\r\n*   - Logs the truck creation event using `console.info`.\r\n*   - Ensures the job status is set to 'completed' with the current timestamp.\r\n*   - Uses a default source message if sourceUrl is not provided.\r\n*/\r\nexport async function finalizeJobStatus(\r\n  jobId: string,\r\n  truck: FoodTruck,\r\n  sourceUrl: string,\r\n): Promise<void> {\r\n  console.info(\r\n    `Job ${jobId}: Successfully created food truck: ${truck.name} (ID: ${truck.id}) from ${sourceUrl ?? 'Unknown Source'}`,\r\n  );\r\n\r\n  // Link truck_id back to the scraping job\r\n  await ScrapingJobService.updateJobStatus(jobId, 'completed', {\r\n    completed_at: new Date().toISOString(),\r\n  });\r\n}\r\n\r\n// Helper function to validate input data\r\nfunction validateTruckData(jobId: string, extractedTruckData: ExtractedFoodTruckDetails): boolean {\r\n  if (extractedTruckData == undefined || typeof extractedTruckData !== 'object') {\r\n    console.error(`Job ${jobId}: Invalid extractedTruckData, cannot create/update food truck.`);\r\n    return false;\r\n  }\r\n  return true;\r\n}\r\n\r\n// Helper function to build location data\r\n/**\r\n * Constructs location data from extracted truck details.\r\n * @example\r\n * buildLocationData({\r\n *   current_location: {\r\n *     address: \"123 Example St\",\r\n *     city: \"Sample City\",\r\n *     state: \"SC\",\r\n *     zip_code: \"12345\",\r\n *     lat: 34.05,\r\n *     lng: -118.25,\r\n *     raw_text: \"Raw Location Data\"\r\n *   }\r\n * }) \r\n * // Returns: {\r\n * //   lat: 34.05,\r\n * //   lng: -118.25,\r\n * //   address: \"123 Example St, Sample City, SC, 12345\",\r\n * //   timestamp: \"2023-09-15T14:38:00.000Z\"\r\n * // }\r\n * @param {ExtractedFoodTruckDetails} extractedTruckData - Details of the food truck, including its current location.\r\n * @returns {Object} Location data comprising latitude, longitude, formatted address, and current timestamp.\r\n * @description\r\n *   - Constructs a full address by combining address components.\r\n *   - Defaults latitude and longitude to 0 if not provided as numbers.\r\n *   - Uses raw text as address if address components are missing.\r\n *   - Generates an ISO 8601 timestamp for the current date and time.\r\n */\r\nfunction buildLocationData(extractedTruckData: ExtractedFoodTruckDetails) {\r\n  const locationData = extractedTruckData.current_location ?? {};\r\n  const fullAddress = [\r\n    locationData.address,\r\n    locationData.city,\r\n    locationData.state,\r\n    locationData.zip_code,\r\n  ]\r\n    .filter(Boolean)\r\n    .join(', ');\r\n\r\n  return {\r\n    lat: typeof locationData.lat === 'number' ? locationData.lat : 0,\r\n    lng: typeof locationData.lng === 'number' ? locationData.lng : 0,\r\n    address: fullAddress || (locationData.raw_text ?? undefined),\r\n    timestamp: new Date().toISOString(),\r\n  };\r\n}\r\n\r\n// New helper function for contact info\r\nfunction buildContactInfo(contactInfo: ExtractedFoodTruckDetails['contact_info']) {\r\n  return {\r\n    phone: contactInfo?.phone ?? undefined,\r\n    email: contactInfo?.email ?? undefined,\r\n    website: contactInfo?.website ?? undefined,\r\n  };\r\n}\r\n\r\n// New helper function for social media\r\nfunction buildSocialMedia(socialMedia: ExtractedFoodTruckDetails['social_media']) {\r\n  return {\r\n    instagram: socialMedia?.instagram ?? undefined,\r\n    facebook: socialMedia?.facebook ?? undefined,\r\n    twitter: socialMedia?.twitter ?? undefined,\r\n    tiktok: socialMedia?.tiktok ?? undefined,\r\n    yelp: socialMedia?.yelp ?? undefined,\r\n  };\r\n}\r\n\r\n// Define a more precise type for raw menu categories and items\r\ninterface RawMenuItem {\r\n  name?: string;\r\n  description?: string;\r\n  price?: string | number;\r\n  dietary_tags?: string[];\r\n}\r\n\r\ninterface RawMenuCategory {\r\n  items?: unknown[];\r\n  category?: string;\r\n  name?: string;\r\n}\r\n\r\n// Type guard for RawMenuCategory\r\nfunction isRawMenuCategory(obj: unknown): obj is RawMenuCategory {\r\n  return (\r\n    typeof obj === 'object' &&\r\n    obj != undefined &&\r\n    ('category' in obj || 'name' in obj || 'items' in obj)\r\n  );\r\n}\r\n\r\n// Type guard for RawMenuItem\r\nfunction isRawMenuItem(obj: unknown): obj is RawMenuItem {\r\n  return (\r\n    typeof obj === 'object' &&\r\n    obj != undefined &&\r\n    ('name' in obj || 'description' in obj || 'price' in obj || 'dietary_tags' in obj)\r\n  );\r\n}\r\n\r\n// Helper function to process menu data\r\n/**\r\n * Processes extracted food truck data into structured menu categories.\r\n * @example\r\n * processMenuData(sample_truck_data)\r\n * [ { name: 'Uncategorized', items: [{ name: 'Pizza', description: 'Cheese Pizza', price: 9.99, dietary_tags: ['vegetarian'] }] } ]\r\n * @param {ExtractedFoodTruckDetails} extractedTruckData - The extracted food truck data.\r\n * @returns {MenuCategory[]} Array of structured menu categories.\r\n * @description\r\n *   - Validates categories and items before mapping to a structured format.\r\n *   - Converts item price to number and handles invalid input gracefully.\r\n *   - Provides default values for category and item names in the case of invalid data.\r\n *   - Logs warnings for encountered invalid category or item data.\r\n */\r\nfunction processMenuData(extractedTruckData: ExtractedFoodTruckDetails): MenuCategory[] {\r\n  if (!Array.isArray(extractedTruckData.menu)) {\r\n    return [];\r\n  }\r\n\r\n  return extractedTruckData.menu.map((category: unknown): MenuCategory => {\r\n    if (!isRawMenuCategory(category)) {\r\n      console.warn('Invalid category data encountered:', category);\r\n      return { name: 'Invalid Category', items: [] };\r\n    }\r\n\r\n    const items = (Array.isArray(category.items) ? category.items : []).map(\r\n      (item: unknown): MenuItem => {\r\n        if (!isRawMenuItem(item)) {\r\n          console.warn('Invalid item data encountered:', item);\r\n          return {\r\n            name: 'Invalid Item',\r\n            description: undefined,\r\n            price: undefined,\r\n            dietary_tags: [],\r\n          };\r\n        }\r\n\r\n        let price: number | undefined = undefined;\r\n        if (typeof item.price === 'number') {\r\n          price = item.price;\r\n        } else if (typeof item.price === 'string') {\r\n          const parsedPrice = Number.parseFloat(item.price.replaceAll(/[^\\d.-]/g, ''));\r\n          if (!Number.isNaN(parsedPrice)) {\r\n            price = parsedPrice;\r\n          }\r\n        }\r\n        return {\r\n          name: item.name ?? 'Unknown Item',\r\n          description: item.description ?? undefined,\r\n          price: price,\r\n          dietary_tags: Array.isArray(item.dietary_tags) ? item.dietary_tags : [],\r\n        };\r\n      },\r\n    );\r\n    return {\r\n      name: category.category ?? category.name ?? 'Uncategorized',\r\n      items: items,\r\n    };\r\n  });\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\pipeline\\scrapingProcessor.js","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error, info.","line":145,"column":13,"nodeType":"MemberExpression","messageId":"limited","endLine":145,"endColumn":24,"suggestions":[{"fix":{"range":[6573,6660],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error, info.","line":153,"column":9,"nodeType":"MemberExpression","messageId":"limited","endLine":153,"endColumn":20,"suggestions":[{"fix":{"range":[6939,6998],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { firecrawl } from '../firecrawl.js';\nimport { gemini } from '../gemini.js';\nimport { ScrapingJobService } from '../supabase/services/scrapingJobService.js';\nimport { validateInputAndPrepare, buildTruckDataSchema, handleDuplicateCheck, finalizeJobStatus, } from './pipelineHelpers.js';\nimport { supabaseAdmin } from '../supabase/client.js';\n\n/**\n * Initiates web scraping for a specified food truck website.\n * @example\n * handleScraping(\"https://foodtruck.com\", \"job123\")\n * Returns data object with markdown content\n * @param {string} targetUrl - The URL of the food truck website to scrape.\n * @param {string} jobId - The unique identifier for the scraping job.\n * @returns {Object} An object containing the scraped data, including markdown content.\n * @description\n *   - Utilizes firecrawl library to perform web scraping.\n *   - Calls handleJobFailure if scraping is unsuccessful or markdown content is missing.\n *   - Logs the progress and success of the scraping process in the console.\n */\nasync function handleScraping(targetUrl, jobId) {\n    console.info(`Starting scrape for ${targetUrl}`);\n    const scrapeResult = await firecrawl.scrapeFoodTruckWebsite(targetUrl);\n    if (!scrapeResult.success || !scrapeResult.data?.markdown) {\n        const error = scrapeResult.error ?? 'Scraping failed or markdown content not found';\n        await handleJobFailure(jobId, error);\n        throw new Error(error);\n    }\n    console.info(`Scraping successful for ${targetUrl}, proceeding to Gemini extraction.`);\n    return scrapeResult.data;\n}\n\n/**\n * Handles job failure by updating the job status in the database.\n * @example\n * handleJobFailure(\"job123\", \"Scraping failed\")\n * undefined\n * @param {string} jobId - The unique identifier for the scraping job.\n * @param {string} errorMessage - The error message to be recorded.\n * @returns {Promise<void>} Resolves when the job status is updated.\n * @description\n *   - Updates the job status to 'failed' with the provided error message.\n *   - Logs the error for debugging purposes.\n */\nasync function handleJobFailure(jobId, errorMessage) {\n    console.error(`Job ${jobId} failed: ${errorMessage}`);\n    await ScrapingJobService.updateJobStatus(jobId, 'failed', {\n        error_message: errorMessage,\n        completed_at: new Date().toISOString(),\n    }).catch(error => {\n        console.error(`Failed to update job ${jobId} status:`, error);\n    });\n}\n\n/**\n * Processes extracted data through Gemini AI for food truck information extraction.\n * @example\n * handleGeminiExtraction(\"# Food Truck Content\", \"https://example.com\", \"job123\")\n * Returns extracted food truck data object\n * @param {string} markdownContent - The markdown content extracted from the website.\n * @param {string} sourceUrl - The URL of the source website.\n * @param {string} jobId - The unique identifier for the scraping job.\n * @returns {Promise<ExtractedFoodTruckDetails>} The extracted food truck details.\n * @description\n *   - Uses the gemini library to extract structured food truck data from markdown content.\n *   - Handles errors by calling handleJobFailure and throwing the error.\n *   - Logs the progress of the AI extraction process.\n */\nasync function handleGeminiExtraction(markdownContent, sourceUrl, jobId) {\n    console.info(`Processing content through Gemini AI for ${sourceUrl}`);\n    try {\n        const extractedData = await gemini.extractFoodTruckDetails(markdownContent, sourceUrl);\n        console.info(`Gemini extraction successful for ${sourceUrl}`);\n        return extractedData;\n    }\n    catch (error) {\n        const errorMessage = error instanceof Error ? error.message : 'Unknown Gemini extraction error';\n        await handleJobFailure(jobId, `Gemini extraction failed: ${errorMessage}`);\n        throw error;\n    }\n}\n\n/**\n * Manages retry logic for a scraping job based on its current retry count.\n * @example\n * handleRetryLogic(\"job123\")\n * undefined\n * @param {string} jobId - The unique identifier for the scraping job.\n * @returns {Promise<void>} Does not return a value but handles retries or logs errors.\n * @description\n *   - Utilizes ScrapingJobService to increment the retry count for the given job.\n *   - Determines whether to retry the job based on retry_count and max_retries properties.\n *   - Logs messages to inform about retry attempts or if max retries have been reached.\n *   - Catches and logs errors encountered during the retry process.\n */\nasync function handleRetryLogic(jobId) {\n    try {\n        const job = await ScrapingJobService.incrementRetryCount(jobId);\n        if (job && typeof job.retry_count === 'number' && typeof job.max_retries === 'number') {\n            if (job.retry_count < job.max_retries) {\n                console.info(`Retrying job ${jobId} (attempt ${job.retry_count}/${job.max_retries})`);\n                setTimeout(() => {\n                    void processScrapingJob(jobId);\n                }, 5000);\n            }\n            else {\n                console.warn(`Job ${jobId} reached max retries (${job.max_retries}).`);\n            }\n        }\n        else {\n            console.error(`Job ${jobId}: Could not get valid retry_count or max_retries. Won't attempt retry.`);\n        }\n    }\n    catch (retryError) {\n        console.error(`Error during retry logic for job ${jobId}:`, retryError);\n    }\n}\n\n/**\n * Processes a scraping job by managing its lifecycle and data extraction.\n * @example\n * processScrapingJob('12345')\n * // Scraping job 12345 completed successfully and data processed.\n * @param {string} jobId - The unique identifier for the scraping job.\n * @returns {Promise<void>} Resolves when the job is completed or retried.\n * @description\n *   - Updates the scraping job status to 'running' at the beginning and 'completed' at the end of the process.\n *   - Performs data scraping and extraction using job's target URL.\n *   - Handles scenarios where a target URL is not specified, resulting in an error.\n *   - Implements retry logic in case of failure during the job processing.\n */\nexport async function processScrapingJob(jobId) {\n    try {\n        // Get job details\n        const job = await ScrapingJobService.getJobById(jobId);\n        if (!job) {\n            throw new Error(`Job ${jobId} not found`);\n        }\n        if (job.status !== 'pending') {\n            throw new Error(`Job ${jobId} is not in pending status: ${job.status}`);\n        }\n        \n        // Check URL quality before processing\n        const shouldProcess = await checkUrlQuality(job.target_url, jobId);\n        if (!shouldProcess) {\n            console.log(`⏭️  Skipping job ${jobId} - URL quality check failed: ${job.target_url}`);\n            await ScrapingJobService.updateJobStatus(jobId, 'completed', {\n                message: 'URL quality check failed - not a food truck related URL',\n                completed_at: new Date().toISOString(),\n            });\n            return;\n        }\n        \n        console.log(`🚀 Starting job ${jobId}: ${job.target_url}`);\n        \n        // Update job status to running\n        await ScrapingJobService.updateJobStatus(jobId, 'running', {\n            started_at: new Date().toISOString(),\n        });\n        \n        if (!job.target_url) {\n            throw new Error('No target URL specified');\n        }\n        \n        // Perform scraping\n        const scrapeData = await handleScraping(job.target_url, jobId);\n        \n        // Process through Gemini AI\n        const extractedData = await handleGeminiExtraction(scrapeData.markdown, scrapeData.source_url ?? job.target_url, jobId);\n        \n        // Handle null names - discard instead of creating \"Unknown Food Truck\"\n        if (extractedData.name === null || extractedData.name === undefined || extractedData.name.trim() === '') {\n            console.warn(`Job ${jobId}: Discarding truck from ${job.target_url} due to null/empty name.`);\n            await ScrapingJobService.updateJobStatus(jobId, 'completed', {\n                data_collected: extractedData,\n                completed_at: new Date().toISOString(),\n                notes: 'Discarded due to null/empty name - not a food truck website',\n            });\n            \n            // Update URL quality score for consistent failures\n            await updateUrlQualityScore(job.target_url, 'failure');\n            return;\n        }\n        \n        // Create or update food truck\n        await createOrUpdateFoodTruck(jobId, extractedData, scrapeData.source_url ?? job.target_url);\n        \n        // Update job status to completed\n        await ScrapingJobService.updateJobStatus(jobId, 'completed', {\n            data_collected: extractedData,\n            completed_at: new Date().toISOString(),\n        });\n        \n        console.info(`Scraping job ${jobId} completed successfully and data processed.`);\n        \n        // Update URL quality score on success\n        await updateUrlQualityScore(job.target_url, 'success');\n    }\n    catch (error) {\n        console.error(`❌ Job ${jobId} failed:`, error);\n        await handleRetryLogic(jobId);\n        throw error;\n    }\n}\n\n/**\n * Creates or updates a food truck entry based on extracted data and handles job processing.\n * @example\n * createOrUpdateFoodTruck('123abc', extractedTruckData, 'http://example.com')\n * undefined\n * @param {string} jobId - Unique identifier for the job being processed.\n * @param {ExtractedFoodTruckDetails} extractedTruckData - Object containing details about the food truck extracted from a source.\n * @param {string} sourceUrl - The URL from which the food truck data was extracted.\n * @returns {Promise<void>} Resolves when processing is complete; returns nothing explicitly.\n * @description\n *   - Validates the input data before proceeding with creation or update.\n *   - Applies a duplicate check mechanism to avoid redundant entries.\n *   - Finalizes the job status, ensuring proper completion or failure handling.\n *   - Logs error details for troubleshooting job processing issues.\n */\nexport async function createOrUpdateFoodTruck(jobId, extractedTruckData, sourceUrl) {\n    try {\n        const validation = await validateInputAndPrepare(jobId, extractedTruckData, sourceUrl);\n        if (!validation.isValid) {\n            return;\n        }\n        const truckData = buildTruckDataSchema(extractedTruckData, sourceUrl, validation.name);\n        const truck = await handleDuplicateCheck(jobId, truckData, validation.name);\n        await finalizeJobStatus(jobId, truck, sourceUrl);\n    }\n    catch (error) {\n        const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n        console.error(`Job ${jobId}: Error in createOrUpdateFoodTruck from ${sourceUrl ?? 'Unknown Source'}:`, error);\n        await handleJobFailure(jobId, `Food truck data processing/saving failed: ${errorMessage}`);\n    }\n}\n\n/**\n * Check URL quality before processing to prevent resource waste on non-food truck URLs\n */\nasync function checkUrlQuality(url, jobId) {\n    try {\n        if (!supabaseAdmin) {\n            return true; // If no admin access, proceed with processing\n        }\n        \n        // Check if URL exists in discovered_urls table\n        const { data: discoveredUrl, error: discoveredError } = await supabaseAdmin\n            .from('discovered_urls')\n            .select('processing_attempts, quality_score, status')\n            .eq('url', url)\n            .limit(1);\n        \n        if (discoveredError) {\n            console.warn(`Could not check URL quality for ${url}:`, discoveredError);\n            return true; // Proceed if we can't check\n        }\n        \n        if (discoveredUrl && discoveredUrl.length > 0) {\n            const urlRecord = discoveredUrl[0];\n            \n            // Skip if blacklisted\n            if (urlRecord.status === 'blacklisted') {\n                console.info(`⏭️  Skipping blacklisted URL: ${url}`);\n                return false;\n            }\n            \n            // Skip if too many failed attempts\n            if (urlRecord.processing_attempts >= 3 && urlRecord.quality_score < 0.3) {\n                console.info(`⏭️  Skipping low quality URL (too many failures): ${url}`);\n                // Blacklist the URL to prevent future processing\n                await supabaseAdmin\n                    .from('discovered_urls')\n                    .update({ status: 'blacklisted', notes: 'Auto-blacklisted due to repeated failures' })\n                    .eq('url', url);\n                return false;\n            }\n        }\n        \n        return true;\n    }\n    catch (error) {\n        console.warn(`Error checking URL quality for ${url}:`, error);\n        return true; // Proceed if there's an error checking quality\n    }\n}\n\n/**\n * Update URL quality score based on job success/failure\n */\nasync function updateUrlQualityScore(url, result) {\n    try {\n        if (!supabaseAdmin) {\n            return;\n        }\n        \n        // Get current URL record\n        const { data: urlRecord, error: fetchError } = await supabaseAdmin\n            .from('discovered_urls')\n            .select('processing_attempts, quality_score')\n            .eq('url', url)\n            .limit(1);\n        \n        if (fetchError || !urlRecord || urlRecord.length === 0) {\n            return;\n        }\n        \n        const current = urlRecord[0];\n        const currentAttempts = current.processing_attempts || 0;\n        const currentScore = current.quality_score || 0.5;\n        \n        // Update based on result\n        let newScore, newAttempts;\n        if (result === 'success') {\n            newScore = Math.min(1, currentScore + 0.2); // Increase quality score on success\n            newAttempts = currentAttempts;\n        } else {\n            newScore = Math.max(0, currentScore - 0.3); // Decrease quality score on failure\n            newAttempts = currentAttempts + 1;\n        }\n        \n        // Update the record\n        await supabaseAdmin\n            .from('discovered_urls')\n            .update({ \n                quality_score: newScore,\n                processing_attempts: newAttempts,\n                last_processed_at: new Date().toISOString()\n            })\n            .eq('url', url);\n        \n    } catch (error) {\n        console.warn(`Could not update URL quality score for ${url}:`, error);\n    }\n}\n","usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\pipeline\\scrapingProcessor.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":31,"column":33,"nodeType":"ChainExpression","messageId":"conditionErrorNullableString","endLine":31,"endColumn":60,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[1247,1275],"text":"((scrapeResult.data?.markdown) == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[1248,1275],"text":"((scrapeResult.data?.markdown) ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[1247,1275],"text":"(!Boolean((scrapeResult.data?.markdown)))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":112,"column":9,"nodeType":"Identifier","messageId":"conditionErrorObject","endLine":112,"endColumn":12},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":147,"column":10,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":147,"endColumn":24,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[6427,6442],"text":"job.target_url == null"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[6428,6442],"text":"(job.target_url ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[6427,6442],"text":"!Boolean(job.target_url)"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\nimport { firecrawl } from '../firecrawl.js';\nimport { gemini } from '../gemini.js';\n\nimport { ScrapingJobService } from '../supabase/services/scrapingJobService.js';\nimport type { ExtractedFoodTruckDetails } from '../types.js';\nimport {\n  validateInputAndPrepare,\n  buildTruckDataSchema,\n  handleDuplicateCheck,\n  finalizeJobStatus,\n} from './pipelineHelpers.js';\n\n/**\n * Initiates web scraping for a specified food truck website.\n * @example\n * handleScraping(\"https://foodtruck.com\", \"job123\")\n * Returns data object with markdown content\n * @param {string} targetUrl - The URL of the food truck website to scrape.\n * @param {string} jobId - The unique identifier for the scraping job.\n * @returns {Object} An object containing the scraped data, including markdown content.\n * @description\n *   - Utilizes firecrawl library to perform web scraping.\n *   - Calls handleJobFailure if scraping is unsuccessful or markdown content is missing.\n *   - Logs the progress and success of the scraping process in the console.\n */\nasync function handleScraping(targetUrl: string, jobId: string) {\n  console.info(`Starting scrape for ${targetUrl}`);\n  const scrapeResult = await firecrawl.scrapeFoodTruckWebsite(targetUrl);\n\n  if (!scrapeResult.success || !scrapeResult.data?.markdown) {\n    const error = scrapeResult.error ?? 'Scraping failed or markdown content not found';\n    await handleJobFailure(jobId, error);\n    throw new Error(error);\n  }\n\n  console.info(`Scraping successful for ${targetUrl}, proceeding to Gemini extraction.`);\n  return scrapeResult.data;\n}\n\n/**\n * Handles the extraction of food truck details using Gemini and manages job failures.\n * @example\n * handleGeminiExtraction(\"sample_markdown\", \"http://example.com\", \"12345\")\n * { name: \"Sample Food Truck\", location: \"123 Main St.\" }\n * @param {string} markdown - The Markdown content containing food truck details.\n * @param {string} sourceUrl - The URL of the source from which details are extracted.\n * @param {string} jobId - The identifier for the job being processed.\n * @returns {Object} The extracted food truck details if successful.\n * @description\n *   - Utilizes Gemini to extract data from the provided Markdown content.\n *   - Handles failure scenarios by logging errors and updating job status.\n *   - Throws an error when extraction is unsuccessful.\n */\nasync function handleGeminiExtraction(markdown: string, sourceUrl: string, jobId: string) {\n  const geminiResult = await gemini.extractFoodTruckDetailsFromMarkdown(markdown, sourceUrl);\n\n  if (!geminiResult.success || !geminiResult.data) {\n    const error = geminiResult.error ?? 'Gemini data extraction failed';\n    await handleJobFailure(jobId, error);\n    throw new Error(error);\n  }\n\n  console.info(`Gemini extraction successful for ${sourceUrl}.`);\n  return geminiResult.data;\n}\n\n/**\n* Handles the failure of a job by updating its status.\n* @example\n* handleJobFailure('job1234', 'Timeout error')\n* // Output: Logs an error message and updates the job status.\n* @param {string} jobId - The unique identifier of the job that failed.\n* @param {string} error - The error message describing the reason for failure.\n* @returns {Promise<void>} Resolves successfully once the job status is updated.\n* @description\n*   - Logs the error to the console for debugging purposes.\n*   - Checks if the current job status is not already 'failed' before updating.\n*   - Updates the job status to 'failed' if applicable, capturing any errors encountered.\n*   - Manages any errors that arise during the status update attempt.\n*/\nasync function handleJobFailure(jobId: string, error: string) {\n  console.error(`Job ${jobId} failed:`, error);\n  try {\n    const currentJob = await ScrapingJobService.getJobsByStatus('all').then((jobs: { id: string; status: string }[]) =>\n      jobs.find((j) => j.id === jobId),\n    );\n    if (currentJob && currentJob.status !== 'failed') {\n      await ScrapingJobService.updateJobStatus(jobId, 'failed', { errors: [error] });\n    }\n  } catch (statusUpdateError) {\n    console.error(`Error updating job ${jobId} status to failed:`, statusUpdateError);\n  }\n}\n\n/**\n * Manages retry logic for a scraping job based on its current retry count.\n * @example\n * handleRetryLogic(\"job123\")\n * undefined\n * @param {string} jobId - The unique identifier for the scraping job.\n * @returns {Promise<void>} Does not return a value but handles retries or logs errors.\n * @description\n *   - Utilizes ScrapingJobService to increment the retry count for the given job.\n *   - Determines whether to retry the job based on retry_count and max_retries properties.\n *   - Logs messages to inform about retry attempts or if max retries have been reached.\n *   - Catches and logs errors encountered during the retry process.\n */\nasync function handleRetryLogic(jobId: string) {\n  try {\n    const job = await ScrapingJobService.incrementRetryCount(jobId);\n    if (job && typeof job.retry_count === 'number' && typeof job.max_retries === 'number') {\n      if (job.retry_count < job.max_retries) {\n        console.info(`Retrying job ${jobId} (attempt ${job.retry_count}/${job.max_retries})`);\n        setTimeout(() => {\n          void processScrapingJob(jobId);\n        }, 5000);\n      } else {\n        console.warn(`Job ${jobId} reached max retries (${job.max_retries}).`);\n      }\n    } else {\n      console.error(\n        `Job ${jobId}: Could not get valid retry_count or max_retries. Won't attempt retry.`,\n      );\n    }\n  } catch (retryError) {\n    console.error(`Error during retry logic for job ${jobId}:`, retryError);\n  }\n}\n\n/**\n * Processes a scraping job by managing its lifecycle and data extraction.\n * @example\n * processScrapingJob('12345')\n * // Scraping job 12345 completed successfully and data processed.\n * @param {string} jobId - The unique identifier for the scraping job.\n * @returns {Promise<void>} Resolves when the job is completed or retried.\n * @description\n *   - Updates the scraping job status to 'running' at the beginning and 'completed' at the end of the process.\n *   - Performs data scraping and extraction using job's target URL.\n *   - Handles scenarios where a target URL is not specified, resulting in an error.\n *   - Implements retry logic in case of failure during the job processing.\n */\nexport async function processScrapingJob(jobId: string): Promise<void> {\n  try {\n    const job = await ScrapingJobService.updateJobStatus(jobId, 'running');\n    if (!job.target_url) {\n      throw new Error('No target URL specified');\n    }\n\n    const scrapeData = await handleScraping(job.target_url, jobId);\n    const extractedData = await handleGeminiExtraction(\n      scrapeData.markdown,\n      scrapeData.source_url ?? job.target_url,\n      jobId,\n    );\n\n    await ScrapingJobService.updateJobStatus(jobId, 'completed', {\n      data_collected: extractedData as unknown as Record<string, unknown>,\n      completed_at: new Date().toISOString(),\n    });\n\n    await createOrUpdateFoodTruck(jobId, extractedData, scrapeData.source_url ?? job.target_url);\n\n    console.info(`Scraping job ${jobId} completed successfully and data processed.`);\n  } catch {\n    await handleRetryLogic(jobId);\n  }\n}\n\n/**\n* Creates or updates a food truck entry based on extracted data and handles job processing.\n* @example\n* createOrUpdateFoodTruck('123abc', extractedTruckData, 'http://example.com')\n* undefined\n* @param {string} jobId - Unique identifier for the job being processed.\n* @param {ExtractedFoodTruckDetails} extractedTruckData - Object containing details about the food truck extracted from a source.\n* @param {string} sourceUrl - The URL from which the food truck data was extracted.\n* @returns {Promise<void>} Resolves when processing is complete; returns nothing explicitly.\n* @description\n*   - Validates the input data before proceeding with creation or update.\n*   - Applies a duplicate check mechanism to avoid redundant entries.\n*   - Finalizes the job status, ensuring proper completion or failure handling.\n*   - Logs error details for troubleshooting job processing issues.\n*/\nexport async function createOrUpdateFoodTruck(\n  jobId: string,\n  extractedTruckData: ExtractedFoodTruckDetails,\n  sourceUrl: string,\n) {\n  try {\n    const validation = await validateInputAndPrepare(jobId, extractedTruckData, sourceUrl);\n    if (!validation.isValid) {\n      return;\n    }\n\n    const truckData = buildTruckDataSchema(extractedTruckData, sourceUrl, validation.name);\n    const truck = await handleDuplicateCheck(jobId, truckData, validation.name);\n    await finalizeJobStatus(jobId, truck, sourceUrl);\n  } catch (error) {\n    const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n    console.error(\n      `Job ${jobId}: Error in createOrUpdateFoodTruck from ${sourceUrl ?? 'Unknown Source'}:`,\n      error,\n    );\n    await handleJobFailure(jobId, `Food truck data processing/saving failed: ${errorMessage}`);\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\scheduler.js","messages":[{"ruleId":null,"nodeType":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token ;","line":3,"column":10}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Task scheduling and automation system\nexport class TaskScheduler {\n    tasks;\n    intervals;\n    isRunning;\n    constructor() {\n        this.tasks = new Map();\n        this.intervals = new Map();\n        this.isRunning = false;\n    }\n    start() {\n        if (this.isRunning === true) {\n            console.info('Scheduler is already running');\n            return;\n        }\n        this.isRunning = true;\n        console.info('Task scheduler started');\n        // Start all scheduled tasks\n        for (const [taskId, task] of this.tasks.entries()) {\n            if (task.enabled === true) {\n                this.scheduleTask(taskId, task);\n            }\n        }\n    }\n    stop() {\n        if (this.isRunning !== true) {\n            console.info('Scheduler is not running');\n            return;\n        }\n        this.isRunning = false;\n        // Clear all intervals\n        for (const [taskId, interval] of this.intervals.entries()) {\n            clearInterval(interval);\n            console.info(`Stopped task: ${taskId}`);\n        }\n        this.intervals.clear();\n        console.info('Task scheduler stopped');\n    }\n    addTask(task) {\n        this.tasks.set(task.id, task);\n        if (this.isRunning === true && task.enabled === true) {\n            this.scheduleTask(task.id, task);\n        }\n        console.info(`Added task: ${task.id}`);\n    }\n    removeTask(taskId) {\n        const interval = this.intervals.get(taskId);\n        if (interval) {\n            clearInterval(interval);\n            this.intervals.delete(taskId);\n        }\n        this.tasks.delete(taskId);\n        console.info(`Removed task: ${taskId}`);\n    }\n    enableTask(taskId) {\n        const task = this.tasks.get(taskId);\n        if (!task) {\n            throw new Error(`Task not found: ${taskId}`);\n        }\n        task.enabled = true;\n        if (this.isRunning) {\n            this.scheduleTask(taskId, task);\n        }\n        console.info(`Enabled task: ${taskId}`);\n    }\n    disableTask(taskId) {\n        const task = this.tasks.get(taskId);\n        if (!task) {\n            throw new Error(`Task not found: ${taskId}`);\n        }\n        task.enabled = false;\n        const interval = this.intervals.get(taskId);\n        if (interval) {\n            clearInterval(interval);\n            this.intervals.delete(taskId);\n        }\n        console.info(`Disabled task: ${taskId}`);\n    }\n    scheduleTask(taskId, task) {\n        // Clear existing interval if any\n        const existingInterval = this.intervals.get(taskId);\n        if (existingInterval) {\n            clearInterval(existingInterval);\n        }\n        // Calculate interval in milliseconds\n        const intervalMs = task.intervalMinutes * 60 * 1000;\n        // Schedule the task with proper async wrapper\n        const interval = setInterval(() => {\n            // Use void to indicate we're not handling the promise\n            void (async () => {\n                try {\n                    console.info(`Executing task: ${taskId}`);\n                    task.lastRun = new Date().toISOString();\n                    await task.execute();\n                    task.successCount += 1;\n                    task.lastSuccess = new Date().toISOString();\n                    console.info(`Task completed successfully: ${taskId}`);\n                }\n                catch (error) {\n                    task.errorCount += 1;\n                    task.lastError = error instanceof Error ? error.message : 'Unknown error';\n                    console.warn(`Task failed: ${taskId}`, error);\n                    // Disable task if too many consecutive failures\n                    if (task.errorCount - task.successCount > 5) {\n                        console.warn(`Disabling task due to repeated failures: ${taskId}`);\n                        this.disableTask(taskId);\n                    }\n                }\n            })();\n        }, intervalMs);\n        this.intervals.set(taskId, interval);\n        console.info(`Scheduled task: ${taskId} (every ${task.intervalMinutes} minutes)`);\n    }\n    getTaskStatus() {\n        return [...this.tasks.values()].map((task) => ({\n            id: task.id,\n            name: task.name,\n            enabled: task.enabled,\n            intervalMinutes: task.intervalMinutes,\n            lastRun: task.lastRun,\n            lastSuccess: task.lastSuccess,\n            successCount: task.successCount,\n            errorCount: task.errorCount,\n            lastError: task.lastError,\n            nextRun: this.calculateNextRun(task),\n        }));\n    }\n    calculateNextRun(task) {\n        if (task.enabled !== true || task.lastRun == undefined) {\n            return undefined;\n        }\n        const lastRun = new Date(task.lastRun);\n        const nextRun = new Date(lastRun.getTime() + task.intervalMinutes * 60 * 1000);\n        return nextRun.toISOString();\n    }\n    scheduleFollowUpTasks(result) {\n        // Implementation for scheduling follow-up tasks based on scraping results\n        console.info('Scheduling follow-up tasks based on scraping results:', result);\n        // This could include:\n        // - Scheduling quality checks for newly scraped data\n        // - Setting up monitoring for high-priority trucks\n        // - Triggering additional scraping for related sources\n    }\n}\n// Helper function to update truck location from social media\nasync function updateTruckLocationFromSocial(truck, scraperEngine) {\n    if (truck.social_media.instagram_handle == undefined ||\n        truck.social_media.instagram_handle === '') {\n        return;\n    }\n    const socialResult = await scraperEngine.scrapeSocialMedia('instagram', truck.social_media.instagram_handle);\n    if (socialResult.success === true && socialResult.data != undefined) {\n        const socialData = socialResult.data;\n        const recentPosts = socialData.posts.slice(0, 3);\n        for (const post of recentPosts) {\n            if (post.location != undefined && post.location !== '') {\n                console.info(`Updated location for ${truck.name}: ${post.location}`);\n                break;\n            }\n        }\n    }\n}\n// Pre-configured tasks for food truck data pipeline\nexport function createDefaultTasks(scraperEngine, geminiProcessor, dataQualityAssessor) {\n    return [\n        createInstagramScrapeTask(scraperEngine),\n        createWebsiteCrawlTask(scraperEngine),\n        createDataQualityCheckTask(dataQualityAssessor),\n        createGeminiProcessingTask(geminiProcessor),\n        createLocationUpdateTask(scraperEngine),\n    ];\n}\n/**\n * Create Instagram scraping task\n */\nfunction createInstagramScrapeTask(scraperEngine) {\n    return {\n        id: 'instagram_scrape',\n        name: 'Instagram Data Scraping',\n        description: 'Scrape Instagram posts and profiles for food truck data',\n        intervalMinutes: 120, // Every 2 hours\n        enabled: true,\n        successCount: 0,\n        errorCount: 0,\n        execute: async () => {\n            const handles = ['@gourmetstreeteats', '@tacoparadisesf', '@burgermobile'];\n            for (const handle of handles) {\n                const result = await scraperEngine.scrapeSocialMedia('instagram', handle);\n                if (result.success) {\n                    console.info(`Successfully scraped ${handle}`);\n                }\n                else {\n                    throw new Error(`Failed to scrape ${handle}: ${result.error}`);\n                }\n            }\n        },\n    };\n}\n/**\n * Create website crawling task\n */\nfunction createWebsiteCrawlTask(scraperEngine) {\n    return {\n        id: 'website_crawl',\n        name: 'Website Crawling',\n        description: 'Crawl food truck websites for menu and location updates',\n        intervalMinutes: 360, // Every 6 hours\n        enabled: true,\n        successCount: 0,\n        errorCount: 0,\n        execute: async () => {\n            const websites = [\n                'https://gourmetstreeteats.com',\n                'https://tacoparadise.com',\n                'https://burgermobile.net',\n            ];\n            const selectors = {\n                name: '.truck-name',\n                location: '.current-location',\n                hours: '.operating-hours',\n                menu: '.menu-items',\n            };\n            for (const url of websites) {\n                const result = await scraperEngine.scrapeWebsite(url, selectors);\n                if (result.success) {\n                    console.info(`Successfully crawled ${url}`);\n                }\n                else {\n                    throw new Error(`Failed to crawl ${url}: ${result.error}`);\n                }\n            }\n        },\n    };\n}\n/**\n * Create data quality check task\n */\nfunction createDataQualityCheckTask(dataQualityAssessor) {\n    return {\n        id: 'data_quality_check',\n        name: 'Data Quality Assessment',\n        description: 'Assess and validate data quality for all food trucks',\n        intervalMinutes: 720, // Every 12 hours\n        enabled: true,\n        successCount: 0,\n        errorCount: 0,\n        execute: async () => {\n            // Placeholder: fetch trucks from database\n            const trucks = [];\n            await Promise.resolve(); // Added to satisfy async/await rule\n            let totalScore = 0;\n            let processedCount = 0;\n            if (trucks.length === 0) {\n                console.info('No trucks available for quality assessment');\n                return;\n            }\n            for (const truck of trucks) {\n                const assessment = dataQualityAssessor.assessTruckData(truck);\n                totalScore += assessment.score;\n                processedCount += 1;\n                if (assessment.score < 0.7) {\n                    console.warn(`Low quality data for truck ${truck.id}: ${assessment.issues.join(', ')}`);\n                }\n            }\n            const averageQuality = processedCount > 0 ? totalScore / processedCount : 0;\n            console.info(`Data quality assessment completed. Average score: ${averageQuality.toFixed(2)}`);\n        },\n    };\n}\n/**\n * Create Gemini processing task\n */\nfunction createGeminiProcessingTask(geminiProcessor) {\n    return {\n        id: 'gemini_processing',\n        name: 'AI Data Processing',\n        description: 'Process raw data using Gemini AI for standardization',\n        intervalMinutes: 480, // Every 8 hours\n        enabled: true,\n        successCount: 0,\n        errorCount: 0,\n        execute: async () => {\n            const usage = geminiProcessor.getUsageStats();\n            if (usage.requests.remaining < 100) {\n                console.warn('Skipping Gemini processing due to rate limits');\n                return;\n            }\n            const pendingData = []; // Placeholder: fetch pending data from queue system\n            if (pendingData.length === 0) {\n                console.info('No pending data to process');\n                return;\n            }\n            await processGeminiDataBatch(geminiProcessor, pendingData);\n            console.info(`Processed ${pendingData.length} items with Gemini AI`);\n        },\n    };\n}\n/**\n * Process batch of data with Gemini\n */\nasync function processGeminiDataBatch(geminiProcessor, pendingData) {\n    for (const data of pendingData) {\n        switch (data.type) {\n            case 'menu': {\n                await geminiProcessor.processMenuData(data.content);\n                break;\n            }\n            case 'location': {\n                await geminiProcessor.extractLocationFromText(data.content);\n                break;\n            }\n            case 'hours': {\n                await geminiProcessor.standardizeOperatingHours(data.content);\n                break;\n            }\n            case 'sentiment': {\n                await geminiProcessor.analyzeSentiment(data.content);\n                break;\n            }\n            case 'enhance': {\n                await geminiProcessor.enhanceFoodTruckData(data.content);\n                break;\n            }\n            default: {\n                // No default\n                break;\n            }\n        }\n    }\n}\n/**\n * Create location update task\n */\nfunction createLocationUpdateTask(scraperEngine) {\n    return {\n        id: 'location_update',\n        name: 'Real-time Location Updates',\n        description: 'Update current locations for active food trucks',\n        intervalMinutes: 30, // Every 30 minutes\n        enabled: true,\n        successCount: 0,\n        errorCount: 0,\n        execute: async () => {\n            const activeTrucks = []; // Placeholder: fetch active trucks from database\n            if (activeTrucks.length === 0) {\n                console.info('No active trucks to update locations for');\n                return;\n            }\n            for (const truck of activeTrucks) {\n                await updateTruckLocationFromSocial(truck, scraperEngine);\n            }\n        },\n    };\n}\n// Export scheduler instance for use in cron jobs\nexport const scheduler = new TaskScheduler();\n","usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\scheduler.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\schemas\\truck.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\schemas\\truck.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\security\\auditLogger.js","messages":[{"ruleId":"unicorn/no-static-only-class","severity":2,"message":"Use an object instead of a class with only static members.","line":9,"column":8,"nodeType":"ClassDeclaration","messageId":"no-static-only-class","endLine":9,"endColumn":25,"fix":{"range":[228,6445],"text":"const AuditLogger = {\r\n    /**\r\n     * Log admin action with full audit trail\r\n     */\r\n    async logAdminAction(options) {\r\n        const { userId, userEmail, action, resourceType, resourceId, details, request } = options;\r\n        const auditEntry = {\r\n            user_id: userId,\r\n            user_email: userEmail,\r\n            action,\r\n            resource_type: resourceType,\r\n            resource_id: resourceId,\r\n            details,\r\n            ip_address: request?.ip,\r\n            user_agent: request?.userAgent,\r\n            session_id: request?.sessionId,\r\n            timestamp: new Date().toISOString(),\r\n            severity: this.determineSeverity(action, resourceType),\r\n        };\r\n        await this.writeAuditLog(auditEntry);\r\n        // Log to console for immediate monitoring\r\n        console.info('Admin Action Audit:', {\r\n            user: userEmail,\r\n            action,\r\n            resource: resourceId === undefined ? resourceType : `${resourceType}:${resourceId}`,\r\n            timestamp: auditEntry.timestamp,\r\n        });\r\n    },\r\n    /**\r\n     * Log security event\r\n     */\r\n    async logSecurityEvent(event) {\r\n        const logEntry = {\r\n            event_type: event.event_type,\r\n            user_id: event.user_id,\r\n            user_email: event.user_email,\r\n            ip_address: event.ip_address,\r\n            user_agent: event.user_agent,\r\n            details: event.details,\r\n            severity: event.severity,\r\n            timestamp: new Date().toISOString(),\r\n        };\r\n        try {\r\n            if (supabaseAdmin) {\r\n                await supabaseAdmin.from('security_events').insert(logEntry);\r\n            }\r\n        }\r\n        catch (error) {\r\n            console.error('Failed to log security event:', error);\r\n        }\r\n        // Always log security events to console\r\n        console.info('Security Event:', logEntry);\r\n        // Alert on critical security events\r\n        if (event.severity === 'critical' || event.severity === 'error') {\r\n            console.warn('SECURITY ALERT:', logEntry);\r\n        }\r\n    },\r\n    /**\r\n     * Log authentication events\r\n     */\r\n    async logAuthEvent(options) {\r\n        const { eventType, userEmail, userId, request, details } = options;\r\n        const severity = eventType === 'login_failure' ? 'warning' : 'info';\r\n        await this.logSecurityEvent({\r\n            event_type: eventType,\r\n            user_id: userId,\r\n            user_email: userEmail,\r\n            ip_address: request?.ip,\r\n            user_agent: request?.userAgent,\r\n            details,\r\n            severity,\r\n        });\r\n    },\r\n    /**\r\n     * Log data access events\r\n     */\r\n    async logDataAccess(options) {\r\n        const { userId, userEmail, resourceType, resourceId, action = 'read', request } = options;\r\n        await this.logSecurityEvent({\r\n            event_type: 'data_access',\r\n            user_id: userId,\r\n            user_email: userEmail,\r\n            ip_address: request?.ip,\r\n            user_agent: request?.userAgent,\r\n            details: {\r\n                resource_type: resourceType,\r\n                resource_id: resourceId,\r\n                action,\r\n            },\r\n            severity: 'info',\r\n        });\r\n    },\r\n    /**\r\n     * Write audit log to database\r\n     */\r\n    async writeAuditLog(entry) {\r\n        try {\r\n            if (supabaseAdmin) {\r\n                await supabaseAdmin.from('audit_logs').insert(entry);\r\n            }\r\n        }\r\n        catch (error) {\r\n            console.error('Failed to write audit log:', error);\r\n            // Don't throw - audit logging should not break application flow\r\n        }\r\n    },\r\n    /**\r\n     * Determine severity based on action and resource type\r\n     */\r\n    determineSeverity(action, resourceType) {\r\n        // Critical actions\r\n        if (action.includes('delete') || action.includes('remove')) {\r\n            return 'critical';\r\n        }\r\n        // Warning actions\r\n        if (action.includes('update') || action.includes('modify') || action.includes('change')) {\r\n            return 'warning';\r\n        }\r\n        // Admin-specific actions\r\n        if (resourceType === 'user' || resourceType === 'admin' || resourceType === 'system') {\r\n            return 'warning';\r\n        }\r\n        // Default to info\r\n        return 'info';\r\n    },\r\n    /**\r\n     * Get audit logs for a specific user\r\n     */\r\n    async getUserAuditLogs(userId, limit = 100, offset = 0) {\r\n        try {\r\n            if (!supabaseAdmin) {\r\n                return [];\r\n            }\r\n            const { data, error } = await supabaseAdmin\r\n                .from('audit_logs')\r\n                .select('*')\r\n                .eq('user_id', userId)\r\n                .order('timestamp', { ascending: false })\r\n                .range(offset, offset + limit - 1);\r\n            if (error) {\r\n                console.error('Failed to fetch user audit logs:', error);\r\n                return [];\r\n            }\r\n            return data ?? [];\r\n        }\r\n        catch (error) {\r\n            console.error('Error fetching user audit logs:', error);\r\n            return [];\r\n        }\r\n    },\r\n    /**\r\n     * Get recent security events\r\n     */\r\n    async getRecentSecurityEvents(hours = 24, severity) {\r\n        try {\r\n            if (!supabaseAdmin) {\r\n                return [];\r\n            }\r\n            const startTime = new Date();\r\n            startTime.setHours(startTime.getHours() - hours);\r\n            let query = supabaseAdmin\r\n                .from('security_events')\r\n                .select('*')\r\n                .gte('timestamp', startTime.toISOString())\r\n                .order('timestamp', { ascending: false });\r\n            if (severity) {\r\n                query = query.eq('severity', severity);\r\n            }\r\n            const { data, error } = await query.limit(500);\r\n            if (error) {\r\n                console.error('Failed to fetch security events:', error);\r\n                return [];\r\n            }\r\n            return data ?? [];\r\n        }\r\n        catch (error) {\r\n            console.error('Error fetching security events:', error);\r\n            return [];\r\n        }\r\n    },\r\n};"}}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":1,"fixableWarningCount":0,"source":"/**\r\n * SOTA Security Audit Logging System\r\n * Implements comprehensive audit logging for admin actions and security events\r\n */\r\nimport { supabaseAdmin } from '../../lib/supabase.js';\r\n/**\r\n * Audit Logger Service\r\n */\r\nexport class AuditLogger {\r\n    /**\r\n     * Log admin action with full audit trail\r\n     */\r\n    static async logAdminAction(options) {\r\n        const { userId, userEmail, action, resourceType, resourceId, details, request } = options;\r\n        const auditEntry = {\r\n            user_id: userId,\r\n            user_email: userEmail,\r\n            action,\r\n            resource_type: resourceType,\r\n            resource_id: resourceId,\r\n            details,\r\n            ip_address: request?.ip,\r\n            user_agent: request?.userAgent,\r\n            session_id: request?.sessionId,\r\n            timestamp: new Date().toISOString(),\r\n            severity: this.determineSeverity(action, resourceType),\r\n        };\r\n        await this.writeAuditLog(auditEntry);\r\n        // Log to console for immediate monitoring\r\n        console.info('Admin Action Audit:', {\r\n            user: userEmail,\r\n            action,\r\n            resource: resourceId === undefined ? resourceType : `${resourceType}:${resourceId}`,\r\n            timestamp: auditEntry.timestamp,\r\n        });\r\n    }\r\n    /**\r\n     * Log security event\r\n     */\r\n    static async logSecurityEvent(event) {\r\n        const logEntry = {\r\n            event_type: event.event_type,\r\n            user_id: event.user_id,\r\n            user_email: event.user_email,\r\n            ip_address: event.ip_address,\r\n            user_agent: event.user_agent,\r\n            details: event.details,\r\n            severity: event.severity,\r\n            timestamp: new Date().toISOString(),\r\n        };\r\n        try {\r\n            if (supabaseAdmin) {\r\n                await supabaseAdmin.from('security_events').insert(logEntry);\r\n            }\r\n        }\r\n        catch (error) {\r\n            console.error('Failed to log security event:', error);\r\n        }\r\n        // Always log security events to console\r\n        console.info('Security Event:', logEntry);\r\n        // Alert on critical security events\r\n        if (event.severity === 'critical' || event.severity === 'error') {\r\n            console.warn('SECURITY ALERT:', logEntry);\r\n        }\r\n    }\r\n    /**\r\n     * Log authentication events\r\n     */\r\n    static async logAuthEvent(options) {\r\n        const { eventType, userEmail, userId, request, details } = options;\r\n        const severity = eventType === 'login_failure' ? 'warning' : 'info';\r\n        await this.logSecurityEvent({\r\n            event_type: eventType,\r\n            user_id: userId,\r\n            user_email: userEmail,\r\n            ip_address: request?.ip,\r\n            user_agent: request?.userAgent,\r\n            details,\r\n            severity,\r\n        });\r\n    }\r\n    /**\r\n     * Log data access events\r\n     */\r\n    static async logDataAccess(options) {\r\n        const { userId, userEmail, resourceType, resourceId, action = 'read', request } = options;\r\n        await this.logSecurityEvent({\r\n            event_type: 'data_access',\r\n            user_id: userId,\r\n            user_email: userEmail,\r\n            ip_address: request?.ip,\r\n            user_agent: request?.userAgent,\r\n            details: {\r\n                resource_type: resourceType,\r\n                resource_id: resourceId,\r\n                action,\r\n            },\r\n            severity: 'info',\r\n        });\r\n    }\r\n    /**\r\n     * Write audit log to database\r\n     */\r\n    static async writeAuditLog(entry) {\r\n        try {\r\n            if (supabaseAdmin) {\r\n                await supabaseAdmin.from('audit_logs').insert(entry);\r\n            }\r\n        }\r\n        catch (error) {\r\n            console.error('Failed to write audit log:', error);\r\n            // Don't throw - audit logging should not break application flow\r\n        }\r\n    }\r\n    /**\r\n     * Determine severity based on action and resource type\r\n     */\r\n    static determineSeverity(action, resourceType) {\r\n        // Critical actions\r\n        if (action.includes('delete') || action.includes('remove')) {\r\n            return 'critical';\r\n        }\r\n        // Warning actions\r\n        if (action.includes('update') || action.includes('modify') || action.includes('change')) {\r\n            return 'warning';\r\n        }\r\n        // Admin-specific actions\r\n        if (resourceType === 'user' || resourceType === 'admin' || resourceType === 'system') {\r\n            return 'warning';\r\n        }\r\n        // Default to info\r\n        return 'info';\r\n    }\r\n    /**\r\n     * Get audit logs for a specific user\r\n     */\r\n    static async getUserAuditLogs(userId, limit = 100, offset = 0) {\r\n        try {\r\n            if (!supabaseAdmin) {\r\n                return [];\r\n            }\r\n            const { data, error } = await supabaseAdmin\r\n                .from('audit_logs')\r\n                .select('*')\r\n                .eq('user_id', userId)\r\n                .order('timestamp', { ascending: false })\r\n                .range(offset, offset + limit - 1);\r\n            if (error) {\r\n                console.error('Failed to fetch user audit logs:', error);\r\n                return [];\r\n            }\r\n            return data ?? [];\r\n        }\r\n        catch (error) {\r\n            console.error('Error fetching user audit logs:', error);\r\n            return [];\r\n        }\r\n    }\r\n    /**\r\n     * Get recent security events\r\n     */\r\n    static async getRecentSecurityEvents(hours = 24, severity) {\r\n        try {\r\n            if (!supabaseAdmin) {\r\n                return [];\r\n            }\r\n            const startTime = new Date();\r\n            startTime.setHours(startTime.getHours() - hours);\r\n            let query = supabaseAdmin\r\n                .from('security_events')\r\n                .select('*')\r\n                .gte('timestamp', startTime.toISOString())\r\n                .order('timestamp', { ascending: false });\r\n            if (severity) {\r\n                query = query.eq('severity', severity);\r\n            }\r\n            const { data, error } = await query.limit(500);\r\n            if (error) {\r\n                console.error('Failed to fetch security events:', error);\r\n                return [];\r\n            }\r\n            return data ?? [];\r\n        }\r\n        catch (error) {\r\n            console.error('Error fetching security events:', error);\r\n            return [];\r\n        }\r\n    }\r\n}\r\n/**\r\n * Security monitoring utilities\r\n */\r\nexport const SecurityMonitor = {\r\n    /**\r\n     * Check for suspicious activity patterns\r\n     */\r\n    async checkSuspiciousActivity(userId) {\r\n        const reasons = [];\r\n        let riskLevel = 'low';\r\n        try {\r\n            // Check recent failed login attempts\r\n            const recentEvents = await AuditLogger.getRecentSecurityEvents(1, 'warning');\r\n            const failedLogins = recentEvents.filter((event) => event.event_type === 'login_failed' && event.user_id === userId);\r\n            if (failedLogins.length > 5) {\r\n                reasons.push('Multiple failed login attempts');\r\n                riskLevel = 'high';\r\n            }\r\n            else if (failedLogins.length > 2) {\r\n                reasons.push('Recent failed login attempts');\r\n                riskLevel = 'medium';\r\n            }\r\n            // Check for unusual access patterns\r\n            const auditLogs = await AuditLogger.getUserAuditLogs(userId, 50);\r\n            const recentActions = auditLogs.filter((log) => new Date(log.timestamp) > new Date(Date.now() - 60 * 60 * 1000));\r\n            if (recentActions.length > 20) {\r\n                reasons.push('High activity volume');\r\n                riskLevel = riskLevel === 'high' ? 'high' : 'medium';\r\n            }\r\n            return {\r\n                suspicious: reasons.length > 0,\r\n                reasons,\r\n                riskLevel,\r\n            };\r\n        }\r\n        catch (error) {\r\n            console.error('Error checking suspicious activity:', error);\r\n            return {\r\n                suspicious: false,\r\n                reasons: [],\r\n                riskLevel: 'low',\r\n            };\r\n        }\r\n    },\r\n};\r\n","usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\security\\auditLogger.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\security\\rateLimiter.js","messages":[{"ruleId":"unicorn/no-static-only-class","severity":2,"message":"Use an object instead of a class with only static members.","line":35,"column":8,"nodeType":"ClassDeclaration","messageId":"no-static-only-class","endLine":35,"endColumn":25,"fix":{"range":[1203,6521],"text":"const RateLimiter = {\n    // Extract logic from checkRateLimit to reduce function size\n    isBlocked(entry, now) {\n        return Boolean(entry && entry.blocked && entry.blockUntil != undefined && now < entry.blockUntil);\n    },\n    resetEntry(entry, now, config) {\n        entry.count = 0;\n        entry.resetTime = now + config.windowMs;\n        entry.blocked = false;\n        entry.blockUntil = undefined;\n    },\n    /**\n     * Check if request should be rate limited\n     */\n    checkRateLimit(identifier, type = 'api') {\n        const config = RATE_LIMIT_CONFIGS[type];\n        const now = Date.now();\n        const key = `${type}:${identifier}`;\n        this.cleanupExpiredEntries();\n        let entry = rateLimitStore.get(key);\n        if (!entry) {\n            entry = { count: 0, resetTime: now + config.windowMs, blocked: false };\n            rateLimitStore.set(key, entry);\n        }\n        if (this.isBlocked(entry, now)) {\n            return {\n                allowed: false,\n                remaining: 0,\n                resetTime: entry.resetTime,\n                retryAfter: Math.ceil((entry.blockUntil - now) / 1000),\n            };\n        }\n        if (now >= entry.resetTime) {\n            this.resetEntry(entry, now, config);\n        }\n        if (entry.count >= config.maxRequests) {\n            entry.blocked = true;\n            entry.blockUntil = now + config.blockDurationMs;\n            return {\n                allowed: false,\n                remaining: 0,\n                resetTime: entry.resetTime,\n                retryAfter: Math.ceil(config.blockDurationMs / 1000),\n            };\n        }\n        entry.count += 1;\n        rateLimitStore.set(key, entry);\n        return {\n            allowed: true,\n            remaining: config.maxRequests - entry.count,\n            resetTime: entry.resetTime,\n        };\n    },\n    /**\n     * Record successful request (for auth endpoints)\n     */\n    recordSuccess(identifier, type = 'api') {\n        const config = RATE_LIMIT_CONFIGS[type];\n        if (!config.skipSuccessfulRequests)\n            return;\n        const key = `${type}:${identifier}`;\n        const entry = rateLimitStore.get(key);\n        if (entry) {\n            // Reset counter on successful auth\n            entry.count = 0;\n            entry.blocked = false;\n            entry.blockUntil = undefined;\n            rateLimitStore.set(key, entry);\n        }\n    },\n    /**\n     * Get rate limit status without incrementing\n     */\n    getStatus(identifier, type = 'api') {\n        const config = RATE_LIMIT_CONFIGS[type];\n        const now = Date.now();\n        const key = `${type}:${identifier}`;\n        const entry = rateLimitStore.get(key);\n        if (!entry) {\n            return {\n                remaining: config.maxRequests,\n                resetTime: now + config.windowMs,\n                blocked: false,\n            };\n        }\n        // Check if blocked\n        if (entry.blocked && entry.blockUntil != undefined && now < entry.blockUntil) {\n            // Changed != undefined to != null\n            return {\n                remaining: 0,\n                resetTime: entry.resetTime,\n                blocked: true,\n                retryAfter: Math.ceil((entry.blockUntil - now) / 1000),\n            };\n        }\n        // Check if window expired\n        if (now >= entry.resetTime) {\n            return {\n                remaining: config.maxRequests,\n                resetTime: now + config.windowMs,\n                blocked: false,\n            };\n        }\n        return {\n            remaining: Math.max(0, config.maxRequests - entry.count),\n            resetTime: entry.resetTime,\n            blocked: false,\n        };\n    },\n    /**\n     * Clean up expired entries to prevent memory leaks\n     */\n    cleanupExpiredEntries() {\n        const now = Date.now();\n        for (const [key, entry] of rateLimitStore.entries()) {\n            // Remove entries that are expired and not blocked\n            if (now >= entry.resetTime &&\n                (!entry.blocked || entry.blockUntil == undefined || now >= entry.blockUntil)) {\n                // Changed == undefined to == null\n                rateLimitStore.delete(key);\n            }\n        }\n    },\n    /**\n     * Clear all rate limit data for an identifier\n     */\n    clearLimits(identifier, type) {\n        if (type) {\n            const key = `${type}:${identifier}`;\n            rateLimitStore.delete(key);\n        }\n        else {\n            // Clear all types for this identifier\n            for (const limitType of Object.keys(RATE_LIMIT_CONFIGS)) {\n                // Added type assertion\n                const key = `${limitType}:${identifier}`;\n                rateLimitStore.delete(key);\n            }\n        }\n    },\n    /**\n     * Get rate limit statistics\n     */\n    getStats() {\n        const stats = {\n            totalEntries: rateLimitStore.size,\n            blockedEntries: 0,\n            entriesByType: {},\n        };\n        for (const [key, entry] of rateLimitStore.entries()) {\n            const type = key.split(':')[0];\n            stats.entriesByType[type] = (stats.entriesByType[type] ?? 0) + 1;\n            if (entry.blocked) {\n                stats.blockedEntries += 1;\n            }\n        }\n        return stats;\n    },\n};"}}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":1,"fixableWarningCount":0,"source":"/**\n * SOTA Rate Limiting Implementation\n * Prevents brute force attacks and API abuse with intelligent rate limiting\n */\nimport { NextResponse } from 'next/server'; // Added import for NextResponse\n// In-memory rate limit store (in production, use Redis)\nconst rateLimitStore = new Map();\n// Rate limit configurations for different endpoints\nexport const RATE_LIMIT_CONFIGS = {\n    // Authentication endpoints - strict limits\n    auth: {\n        windowMs: 15 * 60 * 1000, // 15 minutes\n        maxRequests: 5, // 5 attempts per 15 minutes\n        blockDurationMs: 30 * 60 * 1000, // Block for 30 minutes\n        skipSuccessfulRequests: true,\n    },\n    // API endpoints - moderate limits\n    api: {\n        windowMs: 60 * 1000, // 1 minute\n        maxRequests: 60, // 60 requests per minute\n        blockDurationMs: 5 * 60 * 1000, // Block for 5 minutes\n        skipSuccessfulRequests: false,\n    },\n    // Admin endpoints - very strict limits\n    admin: {\n        windowMs: 60 * 1000, // 1 minute\n        maxRequests: 20, // 20 requests per minute\n        blockDurationMs: 15 * 60 * 1000, // Block for 15 minutes\n        skipSuccessfulRequests: false,\n    },\n};\n/**\n * Rate Limiter Service\n */\nexport class RateLimiter {\n    // Extract logic from checkRateLimit to reduce function size\n    static isBlocked(entry, now) {\n        return Boolean(entry && entry.blocked && entry.blockUntil != undefined && now < entry.blockUntil);\n    }\n    static resetEntry(entry, now, config) {\n        entry.count = 0;\n        entry.resetTime = now + config.windowMs;\n        entry.blocked = false;\n        entry.blockUntil = undefined;\n    }\n    /**\n     * Check if request should be rate limited\n     */\n    static checkRateLimit(identifier, type = 'api') {\n        const config = RATE_LIMIT_CONFIGS[type];\n        const now = Date.now();\n        const key = `${type}:${identifier}`;\n        this.cleanupExpiredEntries();\n        let entry = rateLimitStore.get(key);\n        if (!entry) {\n            entry = { count: 0, resetTime: now + config.windowMs, blocked: false };\n            rateLimitStore.set(key, entry);\n        }\n        if (this.isBlocked(entry, now)) {\n            return {\n                allowed: false,\n                remaining: 0,\n                resetTime: entry.resetTime,\n                retryAfter: Math.ceil((entry.blockUntil - now) / 1000),\n            };\n        }\n        if (now >= entry.resetTime) {\n            this.resetEntry(entry, now, config);\n        }\n        if (entry.count >= config.maxRequests) {\n            entry.blocked = true;\n            entry.blockUntil = now + config.blockDurationMs;\n            return {\n                allowed: false,\n                remaining: 0,\n                resetTime: entry.resetTime,\n                retryAfter: Math.ceil(config.blockDurationMs / 1000),\n            };\n        }\n        entry.count += 1;\n        rateLimitStore.set(key, entry);\n        return {\n            allowed: true,\n            remaining: config.maxRequests - entry.count,\n            resetTime: entry.resetTime,\n        };\n    }\n    /**\n     * Record successful request (for auth endpoints)\n     */\n    static recordSuccess(identifier, type = 'api') {\n        const config = RATE_LIMIT_CONFIGS[type];\n        if (!config.skipSuccessfulRequests)\n            return;\n        const key = `${type}:${identifier}`;\n        const entry = rateLimitStore.get(key);\n        if (entry) {\n            // Reset counter on successful auth\n            entry.count = 0;\n            entry.blocked = false;\n            entry.blockUntil = undefined;\n            rateLimitStore.set(key, entry);\n        }\n    }\n    /**\n     * Get rate limit status without incrementing\n     */\n    static getStatus(identifier, type = 'api') {\n        const config = RATE_LIMIT_CONFIGS[type];\n        const now = Date.now();\n        const key = `${type}:${identifier}`;\n        const entry = rateLimitStore.get(key);\n        if (!entry) {\n            return {\n                remaining: config.maxRequests,\n                resetTime: now + config.windowMs,\n                blocked: false,\n            };\n        }\n        // Check if blocked\n        if (entry.blocked && entry.blockUntil != undefined && now < entry.blockUntil) {\n            // Changed != undefined to != null\n            return {\n                remaining: 0,\n                resetTime: entry.resetTime,\n                blocked: true,\n                retryAfter: Math.ceil((entry.blockUntil - now) / 1000),\n            };\n        }\n        // Check if window expired\n        if (now >= entry.resetTime) {\n            return {\n                remaining: config.maxRequests,\n                resetTime: now + config.windowMs,\n                blocked: false,\n            };\n        }\n        return {\n            remaining: Math.max(0, config.maxRequests - entry.count),\n            resetTime: entry.resetTime,\n            blocked: false,\n        };\n    }\n    /**\n     * Clean up expired entries to prevent memory leaks\n     */\n    static cleanupExpiredEntries() {\n        const now = Date.now();\n        for (const [key, entry] of rateLimitStore.entries()) {\n            // Remove entries that are expired and not blocked\n            if (now >= entry.resetTime &&\n                (!entry.blocked || entry.blockUntil == undefined || now >= entry.blockUntil)) {\n                // Changed == undefined to == null\n                rateLimitStore.delete(key);\n            }\n        }\n    }\n    /**\n     * Clear all rate limit data for an identifier\n     */\n    static clearLimits(identifier, type) {\n        if (type) {\n            const key = `${type}:${identifier}`;\n            rateLimitStore.delete(key);\n        }\n        else {\n            // Clear all types for this identifier\n            for (const limitType of Object.keys(RATE_LIMIT_CONFIGS)) {\n                // Added type assertion\n                const key = `${limitType}:${identifier}`;\n                rateLimitStore.delete(key);\n            }\n        }\n    }\n    /**\n     * Get rate limit statistics\n     */\n    static getStats() {\n        const stats = {\n            totalEntries: rateLimitStore.size,\n            blockedEntries: 0,\n            entriesByType: {},\n        };\n        for (const [key, entry] of rateLimitStore.entries()) {\n            const type = key.split(':')[0];\n            stats.entriesByType[type] = (stats.entriesByType[type] ?? 0) + 1;\n            if (entry.blocked) {\n                stats.blockedEntries += 1;\n            }\n        }\n        return stats;\n    }\n}\n/**\n * Utility function to get client identifier from request\n */\nexport function getClientIdentifier(request) {\n    // Try to get IP address from various headers\n    const forwarded = request.headers.get('x-forwarded-for');\n    const realIp = request.headers.get('x-real-ip');\n    const cfConnectingIp = request.headers.get('cf-connecting-ip');\n    // Use the first available IP\n    const ip = forwarded?.split(',')[0]?.trim() ?? realIp ?? cfConnectingIp ?? 'unknown';\n    // Include user agent for more specific identification\n    const userAgent = request.headers.get('user-agent') ?? 'unknown';\n    // Create a hash of IP + User Agent for better identification\n    return `${ip}:${userAgent.slice(0, 50)}`;\n}\n/**\n * Rate limiting middleware for API routes\n */\nexport function withRateLimit(handler, type = 'api') {\n    return async (request) => {\n        const identifier = getClientIdentifier(request);\n        const result = RateLimiter.checkRateLimit(identifier, type);\n        if (result.allowed === false) {\n            const headers = new Headers({\n                'X-RateLimit-Limit': RATE_LIMIT_CONFIGS[type].maxRequests.toString(),\n                'X-RateLimit-Remaining': '0',\n                'X-RateLimit-Reset': new Date(result.resetTime).toISOString(),\n            });\n            if (result.retryAfter) {\n                headers.set('Retry-After', result.retryAfter.toString());\n            }\n            return new NextResponse('Too Many Requests', { status: 429, headers });\n        }\n        const response = await handler(request);\n        // Update headers on successful requests if not skipped\n        if (RATE_LIMIT_CONFIGS[type].skipSuccessfulRequests === false) {\n            const status = RateLimiter.getStatus(identifier, type);\n            response.headers.set('X-RateLimit-Limit', RATE_LIMIT_CONFIGS[type].maxRequests.toString());\n            response.headers.set('X-RateLimit-Remaining', status.remaining.toString());\n            response.headers.set('X-RateLimit-Reset', new Date(status.resetTime).toISOString());\n        }\n        return response;\n    };\n}\n","usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\security\\rateLimiter.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":288,"column":11,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":288,"endColumn":28,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[8233,8250],"text":"result.retryAfter != null"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[8233,8250],"text":"result.retryAfter ?? 0"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[8233,8250],"text":"Boolean(result.retryAfter)"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * SOTA Rate Limiting Implementation\r\n * Prevents brute force attacks and API abuse with intelligent rate limiting\r\n */\r\n\r\nimport { NextResponse } from 'next/server'; // Added import for NextResponse\r\n\r\ninterface RateLimitEntry {\r\n  count: number;\r\n  resetTime: number;\r\n  blocked: boolean;\r\n  blockUntil?: number;\r\n}\r\n\r\n// In-memory rate limit store (in production, use Redis)\r\nconst rateLimitStore = new Map<string, RateLimitEntry>();\r\n\r\n// Rate limit configurations for different endpoints\r\nexport const RATE_LIMIT_CONFIGS = {\r\n  // Authentication endpoints - strict limits\r\n  auth: {\r\n    windowMs: 15 * 60 * 1000, // 15 minutes\r\n    maxRequests: 5, // 5 attempts per 15 minutes\r\n    blockDurationMs: 30 * 60 * 1000, // Block for 30 minutes\r\n    skipSuccessfulRequests: true,\r\n  },\r\n  // API endpoints - moderate limits\r\n  api: {\r\n    windowMs: 60 * 1000, // 1 minute\r\n    maxRequests: 60, // 60 requests per minute\r\n    blockDurationMs: 5 * 60 * 1000, // Block for 5 minutes\r\n    skipSuccessfulRequests: false,\r\n  },\r\n  // Admin endpoints - very strict limits\r\n  admin: {\r\n    windowMs: 60 * 1000, // 1 minute\r\n    maxRequests: 20, // 20 requests per minute\r\n    blockDurationMs: 15 * 60 * 1000, // Block for 15 minutes\r\n    skipSuccessfulRequests: false,\r\n  },\r\n} as const;\r\n\r\nexport type RateLimitType = keyof typeof RATE_LIMIT_CONFIGS;\r\n\r\n/**\r\n * Rate Limiter Service\r\n */\r\nexport class RateLimiter {\r\n  // Extract logic from checkRateLimit to reduce function size\r\n  private static isBlocked(entry: RateLimitEntry | undefined, now: number): boolean {\r\n    return Boolean(\r\n      entry && entry.blocked && entry.blockUntil != undefined && now < entry.blockUntil,\r\n    );\r\n  }\r\n\r\n  private static resetEntry(\r\n    entry: RateLimitEntry,\r\n    now: number,\r\n    config: (typeof RATE_LIMIT_CONFIGS)[RateLimitType],\r\n  ): void {\r\n    entry.count = 0;\r\n    entry.resetTime = now + config.windowMs;\r\n    entry.blocked = false;\r\n    entry.blockUntil = undefined;\r\n  }\r\n\r\n  /**\r\n   * Check if request should be rate limited\r\n   */\r\n  static checkRateLimit(\r\n    identifier: string,\r\n    type: RateLimitType = 'api',\r\n  ): {\r\n    allowed: boolean;\r\n    remaining: number;\r\n    resetTime: number;\r\n    retryAfter?: number;\r\n  } {\r\n    const config = RATE_LIMIT_CONFIGS[type];\r\n    const now = Date.now();\r\n    const key = `${type}:${identifier}`;\r\n    this.cleanupExpiredEntries();\r\n    let entry = rateLimitStore.get(key);\r\n    if (!entry) {\r\n      entry = { count: 0, resetTime: now + config.windowMs, blocked: false };\r\n      rateLimitStore.set(key, entry);\r\n    }\r\n    if (this.isBlocked(entry, now)) {\r\n      return {\r\n        allowed: false,\r\n        remaining: 0,\r\n        resetTime: entry.resetTime,\r\n        retryAfter: Math.ceil((entry.blockUntil! - now) / 1000),\r\n      };\r\n    }\r\n    if (now >= entry.resetTime) {\r\n      this.resetEntry(entry, now, config);\r\n    }\r\n    if (entry.count >= config.maxRequests) {\r\n      entry.blocked = true;\r\n      entry.blockUntil = now + config.blockDurationMs;\r\n      return {\r\n        allowed: false,\r\n        remaining: 0,\r\n        resetTime: entry.resetTime,\r\n        retryAfter: Math.ceil(config.blockDurationMs / 1000),\r\n      };\r\n    }\r\n    entry.count += 1;\r\n    rateLimitStore.set(key, entry);\r\n    return {\r\n      allowed: true,\r\n      remaining: config.maxRequests - entry.count,\r\n      resetTime: entry.resetTime,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Record successful request (for auth endpoints)\r\n   */\r\n  static recordSuccess(identifier: string, type: RateLimitType = 'api'): void {\r\n    const config = RATE_LIMIT_CONFIGS[type];\r\n    if (!config.skipSuccessfulRequests) return;\r\n\r\n    const key = `${type}:${identifier}`;\r\n    const entry = rateLimitStore.get(key);\r\n\r\n    if (entry) {\r\n      // Reset counter on successful auth\r\n      entry.count = 0;\r\n      entry.blocked = false;\r\n      entry.blockUntil = undefined;\r\n      rateLimitStore.set(key, entry);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get rate limit status without incrementing\r\n   */\r\n  static getStatus(\r\n    identifier: string,\r\n    type: RateLimitType = 'api',\r\n  ): {\r\n    remaining: number;\r\n    resetTime: number;\r\n    blocked: boolean;\r\n    retryAfter?: number;\r\n  } {\r\n    const config = RATE_LIMIT_CONFIGS[type];\r\n    const now = Date.now();\r\n    const key = `${type}:${identifier}`;\r\n    const entry = rateLimitStore.get(key);\r\n\r\n    if (!entry) {\r\n      return {\r\n        remaining: config.maxRequests,\r\n        resetTime: now + config.windowMs,\r\n        blocked: false,\r\n      };\r\n    }\r\n\r\n    // Check if blocked\r\n    if (entry.blocked && entry.blockUntil != undefined && now < entry.blockUntil) {\r\n      // Changed != undefined to != null\r\n      return {\r\n        remaining: 0,\r\n        resetTime: entry.resetTime,\r\n        blocked: true,\r\n        retryAfter: Math.ceil((entry.blockUntil - now) / 1000),\r\n      };\r\n    }\r\n\r\n    // Check if window expired\r\n    if (now >= entry.resetTime) {\r\n      return {\r\n        remaining: config.maxRequests,\r\n        resetTime: now + config.windowMs,\r\n        blocked: false,\r\n      };\r\n    }\r\n\r\n    return {\r\n      remaining: Math.max(0, config.maxRequests - entry.count),\r\n      resetTime: entry.resetTime,\r\n      blocked: false,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Clean up expired entries to prevent memory leaks\r\n   */\r\n  private static cleanupExpiredEntries(): void {\r\n    const now = Date.now();\r\n\r\n    for (const [key, entry] of rateLimitStore.entries()) {\r\n      // Remove entries that are expired and not blocked\r\n      if (\r\n        now >= entry.resetTime &&\r\n        (!entry.blocked || entry.blockUntil == undefined || now >= entry.blockUntil)\r\n      ) {\r\n        // Changed == undefined to == null\r\n        rateLimitStore.delete(key);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Clear all rate limit data for an identifier\r\n   */\r\n  static clearLimits(identifier: string, type?: RateLimitType): void {\r\n    if (type) {\r\n      const key = `${type}:${identifier}`;\r\n      rateLimitStore.delete(key);\r\n    } else {\r\n      // Clear all types for this identifier\r\n      for (const limitType of Object.keys(RATE_LIMIT_CONFIGS) as RateLimitType[]) {\r\n        // Added type assertion\r\n        const key = `${limitType}:${identifier}`;\r\n        rateLimitStore.delete(key);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get rate limit statistics\r\n   */\r\n  static getStats(): {\r\n    totalEntries: number;\r\n    blockedEntries: number;\r\n    entriesByType: Record<string, number>;\r\n  } {\r\n    const stats = {\r\n      totalEntries: rateLimitStore.size,\r\n      blockedEntries: 0,\r\n      entriesByType: {} as Record<string, number>,\r\n    };\r\n\r\n    for (const [key, entry] of rateLimitStore.entries()) {\r\n      const type = key.split(':')[0];\r\n      stats.entriesByType[type] = (stats.entriesByType[type] ?? 0) + 1;\r\n\r\n      if (entry.blocked) {\r\n        stats.blockedEntries += 1;\r\n      }\r\n    }\r\n\r\n    return stats;\r\n  }\r\n}\r\n\r\n/**\r\n * Utility function to get client identifier from request\r\n */\r\nexport function getClientIdentifier(request: Request): string {\r\n  // Try to get IP address from various headers\r\n  const forwarded = request.headers.get('x-forwarded-for');\r\n  const realIp = request.headers.get('x-real-ip');\r\n  const cfConnectingIp = request.headers.get('cf-connecting-ip');\r\n\r\n  // Use the first available IP\r\n  const ip = forwarded?.split(',')[0]?.trim() ?? realIp ?? cfConnectingIp ?? 'unknown';\r\n\r\n  // Include user agent for more specific identification\r\n  const userAgent = request.headers.get('user-agent') ?? 'unknown';\r\n\r\n  // Create a hash of IP + User Agent for better identification\r\n  return `${ip}:${userAgent.slice(0, 50)}`;\r\n}\r\n\r\n/**\r\n * Rate limiting middleware for API routes\r\n */\r\nexport function withRateLimit(\r\n  handler: (request: Request) => Promise<Response>,\r\n  type: RateLimitType = 'api',\r\n) {\r\n  return async (request: Request): Promise<Response> => {\r\n    const identifier = getClientIdentifier(request);\r\n    const result = RateLimiter.checkRateLimit(identifier, type);\r\n\r\n    if (result.allowed === false) {\r\n      const headers = new Headers({\r\n        'X-RateLimit-Limit': RATE_LIMIT_CONFIGS[type].maxRequests.toString(),\r\n        'X-RateLimit-Remaining': '0',\r\n        'X-RateLimit-Reset': new Date(result.resetTime).toISOString(),\r\n      });\r\n\r\n      if (result.retryAfter) {\r\n        headers.set('Retry-After', result.retryAfter.toString());\r\n      }\r\n\r\n      return new NextResponse('Too Many Requests', { status: 429, headers });\r\n    }\r\n\r\n    const response = await handler(request);\r\n\r\n    // Update headers on successful requests if not skipped\r\n    if (RATE_LIMIT_CONFIGS[type].skipSuccessfulRequests === false) {\r\n      const status = RateLimiter.getStatus(identifier, type);\r\n      response.headers.set('X-RateLimit-Limit', RATE_LIMIT_CONFIGS[type].maxRequests.toString());\r\n      response.headers.set('X-RateLimit-Remaining', status.remaining.toString());\r\n      response.headers.set('X-RateLimit-Reset', new Date(status.resetTime).toISOString());\r\n    }\r\n\r\n    return response;\r\n  };\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\supabase.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\supabase.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\supabaseMiddleware.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\supabaseMiddleware.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\supabase\\client.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\supabase\\client.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":7,"column":6,"nodeType":"Identifier","messageId":"conditionErrorNullableString","endLine":7,"endColumn":17,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[257,269],"text":"supabaseUrl == null"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[258,269],"text":"(supabaseUrl ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[257,269],"text":"!Boolean(supabaseUrl)"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":11,"column":6,"nodeType":"Identifier","messageId":"conditionErrorNullableString","endLine":11,"endColumn":21,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[360,376],"text":"supabaseAnonKey == null"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[361,376],"text":"(supabaseAnonKey ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[360,376],"text":"!Boolean(supabaseAnonKey)"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":17,"column":30,"nodeType":"Identifier","messageId":"conditionErrorNullableString","endLine":17,"endColumn":48,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[568,586],"text":"(supabaseServiceKey != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[568,586],"text":"(supabaseServiceKey ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[568,586],"text":"(Boolean(supabaseServiceKey))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { createClient } from '@supabase/supabase-js';\r\n\r\nconst supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;\r\nconst supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY;\r\nconst supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY;\r\n\r\nif (!supabaseUrl) {\r\n  throw new Error('Missing NEXT_PUBLIC_SUPABASE_URL environment variable');\r\n}\r\n\r\nif (!supabaseAnonKey) {\r\n  throw new Error('Missing NEXT_PUBLIC_SUPABASE_ANON_KEY environment variable');\r\n}\r\n\r\nexport const supabase = createClient(supabaseUrl, supabaseAnonKey);\r\n\r\nexport const supabaseAdmin = supabaseServiceKey\r\n  ? createClient(supabaseUrl, supabaseServiceKey)\r\n  : undefined;\r\n","usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\supabase\\services\\apiUsageService.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\supabase\\services\\apiUsageService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\supabase\\services\\dataProcessingService.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\supabase\\services\\dataProcessingService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\supabase\\services\\dataQualityService.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\supabase\\services\\dataQualityService.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":13,"column":7,"nodeType":"MemberExpression","messageId":"conditionErrorObject","endLine":13,"endColumn":29},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":21,"column":7,"nodeType":"MemberExpression","messageId":"conditionErrorObject","endLine":21,"endColumn":25},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":47,"column":10,"nodeType":"Identifier","messageId":"conditionErrorObject","endLine":47,"endColumn":15}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { supabaseAdmin } from '../client';\r\nimport type { FoodTruck } from '../types';\r\nimport { handleSupabaseError } from '../utils';\r\nimport { type PostgrestSingleResponse } from '@supabase/supabase-js';\r\n\r\nexport const DataQualityService = {\r\n  calculateQualityScore: (truck: FoodTruck) => {\r\n    // Placeholder for actual quality score calculation logic\r\n    // This should be implemented based on defined data quality rules\r\n    let score = 0;\r\n    if (typeof truck.name === 'string' && truck.name.trim() !== '') score += 20;\r\n    if (\r\n      truck.current_location &&\r\n      typeof truck.current_location.lat === 'number' &&\r\n      !Number.isNaN(truck.current_location.lat) &&\r\n      typeof truck.current_location.lng === 'number' &&\r\n      !Number.isNaN(truck.current_location.lng)\r\n    )\r\n      score += 30;\r\n    if (\r\n      truck.contact_info &&\r\n      ((typeof truck.contact_info.phone === 'string' && truck.contact_info.phone.trim() !== '') ||\r\n        (typeof truck.contact_info.email === 'string' && truck.contact_info.email.trim() !== '') ||\r\n        (typeof truck.contact_info.website === 'string' &&\r\n          truck.contact_info.website.trim() !== ''))\r\n    )\r\n      score += 25;\r\n    if (Array.isArray(truck.menu) && truck.menu.length > 0) score += 15;\r\n    if (truck.operating_hours != undefined) score += 10;\r\n    return { score: Math.min(100, score) };\r\n  },\r\n\r\n  async updateTruckQualityScore(truckId: string): Promise<FoodTruck | { error: string }> {\r\n    if (!supabaseAdmin) {\r\n      return { error: 'Admin operations require SUPABASE_SERVICE_ROLE_KEY' };\r\n    }\r\n    const { data: truck, error: fetchError }: PostgrestSingleResponse<FoodTruck> = await supabaseAdmin\r\n      .from('food_trucks')\r\n      .select('*')\r\n      .eq('id', truckId)\r\n      .single();\r\n\r\n    if (fetchError) {\r\n      handleSupabaseError(fetchError, 'updateTruckQualityScore:fetch');\r\n      return { error: `Failed to fetch truck with ID ${truckId}.` };\r\n    }\r\n    if (!truck) {\r\n      return { error: `Truck with ID ${truckId} not found.` };\r\n    }\r\n\r\n    const { score } = this.calculateQualityScore(truck);\r\n\r\n    const { data, error }: PostgrestSingleResponse<FoodTruck> = await supabaseAdmin\r\n      .from('food_trucks')\r\n      .update({ data_quality_score: score })\r\n      .eq('id', truckId)\r\n      .select()\r\n      .single();\r\n\r\n    if (error) {\r\n      handleSupabaseError(error, 'updateTruckQualityScore:update');\r\n      return { error: `Failed to update quality score for truck with ID ${truckId}.` };\r\n    }\r\n    return data;\r\n  },\r\n};\r\n","usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\supabase\\services\\foodTruckService.js","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error, info.","line":14,"column":13,"nodeType":"MemberExpression","messageId":"limited","endLine":14,"endColumn":24,"suggestions":[{"fix":{"range":[697,757],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error, info.","line":36,"column":17,"nodeType":"MemberExpression","messageId":"limited","endLine":36,"endColumn":28,"suggestions":[{"fix":{"range":[1705,1758],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { supabase, supabaseAdmin } from '../client.js';\nimport { handleSupabaseError, normalizeTruckLocation, calculateDistance, insertMenuItems } from '../utils/index.js';\nimport { buildMenuByTruck, groupMenuItems, updateTruckData, updateTruckMenu } from '../utils/menuUtils.js';\nexport const FoodTruckService = {\n    async getAllTrucks(limit = 50, offset = 0) {\n        try {\n            const { data, error, count } = await supabase\n                .from('food_trucks')\n                .select('*', { count: 'exact' })\n                .order('updated_at', { ascending: false })\n                .range(offset, offset + limit - 1);\n            if (error)\n                throw error;\n            console.log('Raw data from Supabase (getAllTrucks):', data);\n            const trucks = (data ?? []).map((t) => normalizeTruckLocation(t));\n            if (trucks.length === 0)\n                return { trucks: [], total: count ?? 0 };\n            const truckIds = trucks.map((t) => t.id);\n            let menuItems = [];\n            try {\n                if (truckIds.length > 0) {\n                    const { data: items, error: menuError } = await supabase\n                        .from('menu_items')\n                        .select('*')\n                        .in('food_truck_id', truckIds);\n                    if (menuError)\n                        throw new Error(menuError.message);\n                    menuItems = items ?? [];\n                }\n            }\n            catch (menuError) {\n                handleSupabaseError(menuError, 'getAllTrucks:menu_items');\n            }\n            const menuByTruck = buildMenuByTruck(menuItems);\n            for (const truck of trucks) {\n                console.log(`Processing truck with ID: ${truck.id}`);\n                truck.menu = groupMenuItems(menuByTruck[truck.id] ?? []);\n            }\n            return { trucks, total: count ?? 0 };\n        }\n        catch (error) {\n            handleSupabaseError(error, 'getAllTrucks');\n            return { trucks: [], total: 0, error: \"That didn't work, please try again later.\" };\n        }\n    },\n    async getTruckById(id) {\n        const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;\n        if (!uuidRegex.test(id)) {\n            console.error(`Invalid UUID format for getTruckById: ${id}`);\n            return { error: \"Invalid truck ID format.\" };\n        }\n        try {\n            const { data, error } = await supabase\n                .from('food_trucks')\n                .select('*')\n                .eq('id', id)\n                .single();\n            if (error)\n                throw error;\n            if (!data) {\n                return { error: \"That didn't work, please try again later.\" };\n            }\n            const truck = normalizeTruckLocation(data);\n            const { data: items, error: menuError } = await supabase\n                .from('menu_items')\n                .select('*')\n                .eq('food_truck_id', id);\n            if (menuError)\n                throw menuError;\n            truck.menu = groupMenuItems(items ?? []);\n            return truck;\n        }\n        catch (error) {\n            handleSupabaseError(error, 'getTruckById');\n            return { error: \"That didn't work, please try again later.\" };\n        }\n    },\n    async getTrucksByLocation(lat, lng, radiusKm) {\n        try {\n            const { trucks } = await FoodTruckService.getAllTrucks();\n            const nearbyTrucks = trucks.filter((truck) => {\n                if (truck.current_location == undefined ||\n                    typeof truck.current_location.lat !== 'number' ||\n                    typeof truck.current_location.lng !== 'number') {\n                    return false;\n                }\n                const distance = calculateDistance(lat, lng, truck.current_location.lat, truck.current_location.lng);\n                return distance <= radiusKm;\n            });\n            return nearbyTrucks;\n        }\n        catch (error) {\n            handleSupabaseError(error, 'getTrucksByLocation');\n            return { error: \"That didn't work, please try again later.\" };\n        }\n    },\n    async createTruck(truckData) {\n        if (!supabaseAdmin) {\n            return { error: 'Admin operations require SUPABASE_SERVICE_ROLE_KEY' };\n        }\n        const menuData = truckData.menu;\n        const truckDataWithoutMenu = { ...truckData };\n        delete truckDataWithoutMenu.menu;\n        const { data: truck, error } = await supabaseAdmin\n            .from('food_trucks')\n            .insert([truckDataWithoutMenu])\n            .select()\n            .single();\n        if (error) {\n            handleSupabaseError(error, 'createTruck');\n            return { error: 'Failed to create truck.' };\n        }\n        await insertMenuItems(truck.id, menuData);\n        return truck;\n    },\n    async updateTruck(id, updates) {\n        if (!supabaseAdmin) {\n            return { error: 'Admin operations require SUPABASE_SERVICE_ROLE_KEY' };\n        }\n        const menuData = updates.menu;\n        const updatesWithoutMenu = { ...updates };\n        delete updatesWithoutMenu.menu;\n        const truckResult = await updateTruckData(id, updatesWithoutMenu);\n        if ('error' in truckResult) {\n            return truckResult;\n        }\n        if (menuData != undefined) {\n            await updateTruckMenu(id, menuData);\n        }\n        return truckResult;\n    },\n    async getDataQualityStats() {\n        try {\n            const { data, error, } = await supabase.rpc('get_data_quality_stats').single();\n            if (error)\n                throw error;\n            return data;\n        }\n        catch (error) {\n            console.warn('Error fetching data quality stats:', error);\n            return {\n                total_trucks: 0,\n                avg_quality_score: 0,\n                high_quality_count: 0,\n                medium_quality_count: 0,\n                low_quality_count: 0,\n                verified_count: 0,\n                pending_count: 0,\n                flagged_count: 0,\n            };\n        }\n    },\n};\n","usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\supabase\\services\\foodTruckService.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":53,"column":12,"nodeType":"Identifier","messageId":"conditionErrorObject","endLine":53,"endColumn":16}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { supabase, supabaseAdmin } from '../client';\r\nimport type { FoodTruck, RawMenuItemFromDB } from '../types';\r\nimport { handleSupabaseError, normalizeTruckLocation, calculateDistance, insertMenuItems } from '../utils';\r\nimport { buildMenuByTruck, groupMenuItems, updateTruckData, updateTruckMenu } from '../utils/menuUtils';\r\nimport { type PostgrestResponse, type PostgrestSingleResponse } from '@supabase/supabase-js';\r\n\r\nexport const FoodTruckService = {\r\n  async getAllTrucks(\r\n    limit = 50,\r\n    offset = 0,\r\n  ): Promise<{ trucks: FoodTruck[]; total: number; error?: string }> {\r\n    try {\r\n      const { data, error, count }: PostgrestResponse<FoodTruck> = await supabase\r\n        .from('food_trucks')\r\n        .select('*', { count: 'exact' })\r\n        .order('updated_at', { ascending: false })\r\n        .range(offset, offset + limit - 1);\r\n      if (error) throw error;\r\n      const trucks: FoodTruck[] = (data ?? []).map((t: FoodTruck) => normalizeTruckLocation(t));\r\n      if (trucks.length === 0) return { trucks: [], total: count ?? 0 };\r\n      const truckIds = trucks.map((t: FoodTruck) => t.id);\r\n      let menuItems: RawMenuItemFromDB[] = [];\r\n      try {\r\n        if (truckIds.length > 0) {\r\n          const { data: items, error: menuError } = await supabase\r\n            .from('menu_items')\r\n            .select('*')\r\n            .in('food_truck_id', truckIds) as { data: RawMenuItemFromDB[] | null; error: Error | null };\r\n          if (menuError) throw new Error(menuError.message);\r\n          menuItems = items ?? [];\r\n        }\r\n      } catch (menuError) {\r\n        handleSupabaseError(menuError as Error, 'getAllTrucks:menu_items');\r\n      }\r\n      const menuByTruck = buildMenuByTruck(menuItems);\r\n      for (const truck of trucks) {\r\n        truck.menu = groupMenuItems(menuByTruck[truck.id] ?? []);\r\n      }\r\n      return { trucks, total: count ?? 0 };\r\n    } catch (error) {\r\n      handleSupabaseError(error as Error, 'getAllTrucks');\r\n      return { trucks: [], total: 0, error: \"That didn't work, please try again later.\" };\r\n    }\r\n  },\r\n  async getTruckById(id: string): Promise<FoodTruck | { error: string }> {\r\n    try {\r\n      const { data, error }: PostgrestSingleResponse<FoodTruck> = await supabase\r\n        .from('food_trucks')\r\n        .select('*')\r\n        .eq('id', id)\r\n        .single();\r\n      if (error) throw error;\r\n      if (!data) {\r\n        return { error: \"That didn't work, please try again later.\" };\r\n      }\r\n      const truck: FoodTruck = normalizeTruckLocation(data);\r\n      const { data: items, error: menuError } = await supabase\r\n        .from('menu_items')\r\n        .select('*')\r\n        .eq('food_truck_id', id) as { data: RawMenuItemFromDB[] | null; error: Error | null };\r\n      if (menuError) throw menuError;\r\n      truck.menu = groupMenuItems(items ?? []);\r\n      return truck;\r\n    } catch (error) {\r\n      handleSupabaseError(error as Error, 'getTruckById');\r\n      return { error: \"That didn't work, please try again later.\" };\r\n    }\r\n  },\r\n\r\n  async getTrucksByLocation(\r\n    lat: number,\r\n    lng: number,\r\n    radiusKm: number,\r\n  ): Promise<FoodTruck[] | { error: string }> {\r\n    try {\r\n      const { trucks } = await FoodTruckService.getAllTrucks();\r\n      const nearbyTrucks = trucks.filter((truck: FoodTruck) => {\r\n        if (\r\n          truck.current_location == undefined ||\r\n          typeof truck.current_location.lat !== 'number' ||\r\n          typeof truck.current_location.lng !== 'number'\r\n        ) {\r\n          return false;\r\n        }\r\n        const distance = calculateDistance(\r\n          lat,\r\n          lng,\r\n          truck.current_location.lat,\r\n          truck.current_location.lng,\r\n        );\r\n        return distance <= radiusKm;\r\n      });\r\n      return nearbyTrucks;\r\n    } catch (error: unknown) {\r\n      handleSupabaseError(error as Error, 'getTrucksByLocation');\r\n      return { error: \"That didn't work, please try again later.\" };\r\n    }\r\n  },\r\n  async createTruck(truckData: Partial<FoodTruck>): Promise<FoodTruck | { error: string }> {\r\n    if (!supabaseAdmin) {\r\n      return { error: 'Admin operations require SUPABASE_SERVICE_ROLE_KEY' };\r\n    }\r\n    const menuData = truckData.menu;\r\n    const truckDataWithoutMenu = { ...truckData };\r\n    delete truckDataWithoutMenu.menu;\r\n    const { data: truck, error }: PostgrestSingleResponse<FoodTruck> = await supabaseAdmin\r\n      .from('food_trucks')\r\n      .insert([truckDataWithoutMenu])\r\n      .select()\r\n      .single();\r\n    if (error) {\r\n      handleSupabaseError(error, 'createTruck');\r\n      return { error: 'Failed to create truck.' };\r\n    }\r\n    await insertMenuItems(truck.id, menuData);\r\n    return truck;\r\n  },\r\n\r\n  async updateTruck(\r\n    id: string,\r\n    updates: Partial<FoodTruck>,\r\n  ): Promise<FoodTruck | { error: string }> {\r\n    if (!supabaseAdmin) {\r\n      return { error: 'Admin operations require SUPABASE_SERVICE_ROLE_KEY' };\r\n    }\r\n    const menuData = updates.menu;\r\n    const updatesWithoutMenu = { ...updates };\r\n    delete updatesWithoutMenu.menu;\r\n    const truckResult = await updateTruckData(id, updatesWithoutMenu);\r\n    if ('error' in truckResult) {\r\n      return truckResult;\r\n    }\r\n    if (menuData != undefined) {\r\n      await updateTruckMenu(id, menuData);\r\n    }\r\n    return truckResult;\r\n  },\r\n\r\n  async getDataQualityStats(): Promise<{\r\n    total_trucks: number;\r\n    avg_quality_score: number;\r\n    high_quality_count: number;\r\n    medium_quality_count: number;\r\n    low_quality_count: number;\r\n    verified_count: number;\r\n    pending_count: number;\r\n    flagged_count: number;\r\n  }> {\r\n    try {\r\n      const {\r\n        data,\r\n        error,\r\n      }: PostgrestSingleResponse<{\r\n        total_trucks: number;\r\n        avg_quality_score: number;\r\n        high_quality_count: number;\r\n        medium_quality_count: number;\r\n        low_quality_count: number;\r\n        verified_count: number;\r\n        pending_count: number;\r\n        flagged_count: number;\r\n      }> = await supabase.rpc('get_data_quality_stats').single();\r\n      if (error) throw error;\r\n      return data as {\r\n        total_trucks: number;\r\n        avg_quality_score: number;\r\n        high_quality_count: number;\r\n        medium_quality_count: number;\r\n        low_quality_count: number;\r\n        verified_count: number;\r\n        pending_count: number;\r\n        flagged_count: number;\r\n      };\r\n    } catch (error: unknown) {\r\n      console.warn('Error fetching data quality stats:', error);\r\n      return {\r\n        total_trucks: 0,\r\n        avg_quality_score: 0,\r\n        high_quality_count: 0,\r\n        medium_quality_count: 0,\r\n        low_quality_count: 0,\r\n        verified_count: 0,\r\n        pending_count: 0,\r\n        flagged_count: 0,\r\n      };\r\n    }\r\n  },\r\n};\r\n\r\n\r\n","usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\supabase\\services\\scrapingJobService.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\supabase\\services\\scrapingJobService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\supabase\\types\\index.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\supabase\\types\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\supabase\\utils\\index.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\supabase\\utils\\index.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":33,"column":9,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":33,"endColumn":90},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":34,"column":9,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":34,"endColumn":56},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .lat on an `any` value.","line":34,"column":26,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":34,"endColumn":29},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .lat on an `any` value.","line":34,"column":49,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":34,"endColumn":52},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":35,"column":9,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":35,"endColumn":56},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .lng on an `any` value.","line":35,"column":26,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":35,"endColumn":29},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .lng on an `any` value.","line":35,"column":49,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":35,"endColumn":52},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":36,"column":9,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":36,"endColumn":24},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":37,"column":9,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":37,"endColumn":26},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":41,"column":24,"nodeType":"Property","messageId":"anyAssignment","endLine":41,"endColumn":60},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":43,"column":11,"nodeType":"Property","messageId":"anyAssignment","endLine":43,"endColumn":14},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":44,"column":11,"nodeType":"Property","messageId":"anyAssignment","endLine":44,"endColumn":14},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":45,"column":11,"nodeType":"Property","messageId":"anyAssignment","endLine":45,"endColumn":47},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":46,"column":11,"nodeType":"Property","messageId":"anyAssignment","endLine":46,"endColumn":53}],"suppressedMessages":[],"errorCount":14,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { type PostgrestError } from '@supabase/supabase-js';\r\nimport { supabaseAdmin } from '../client';\r\nimport type { FoodTruck, FoodTruckLocation, MenuCategory, MenuItem } from '../types';\r\n\r\nimport { isMenuItem } from './typeGuards';\r\n\r\nfunction handleSupabaseError(error: PostgrestError | Error, context: string) {\r\n  console.warn(`Error in ${context}:`, error.message);\r\n}\r\n\r\nfunction calculateDistance(lat1: number, lon1: number, lat2: number, lon2: number): number {\r\n  const R = 6371;\r\n  const dLat = ((lat2 - lat1) * Math.PI) / 180;\r\n  const dLon = ((lon2 - lon1) * Math.PI) / 180;\r\n  const a =\r\n    Math.sin(dLat / 2) * Math.sin(dLat / 2) +\r\n    Math.cos((lat1 * Math.PI) / 180) *\r\n      Math.cos((lat2 * Math.PI) / 180) *\r\n      Math.sin(dLon / 2) *\r\n      Math.sin(dLon / 2);\r\n  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\r\n  const distance = R * c;\r\n  return distance;\r\n}\r\n\r\nfunction normalizeTruckLocation(truck: FoodTruck): FoodTruck {\r\n  const fallback: FoodTruckLocation = {\r\n    lat: 0,\r\n    lng: 0,\r\n    address: 'Unknown',\r\n    timestamp: new Date().toISOString(),\r\n  };\r\n  const loc = truck.exact_location ?? truck.current_location ?? truck.city_location ?? {};\r\n  const lat = typeof loc.lat === 'number' ? loc.lat : 0;\r\n  const lng = typeof loc.lng === 'number' ? loc.lng : 0;\r\n  const {address} = loc;\r\n  const {timestamp} = loc;\r\n\r\n  truck.current_location =\r\n    lat === 0 || lng === 0\r\n      ? { ...fallback, address: address ?? fallback.address }\r\n      : {\r\n          lat,\r\n          lng,\r\n          address: address ?? fallback.address,\r\n          timestamp: timestamp ?? fallback.timestamp,\r\n        };\r\n  return truck;\r\n}\r\n\r\nfunction prepareMenuItemsForInsert(\r\n  truckId: string,\r\n  menuData: MenuCategory[] | unknown[] | undefined,\r\n) {\r\n  if (!Array.isArray(menuData) || menuData.length === 0) {\r\n    return [];\r\n  }\r\n  const categories = menuData.filter(\r\n    (category): category is MenuCategory =>\r\n      typeof category === 'object' &&\r\n      category != undefined &&\r\n      'name' in category &&\r\n      'items' in category &&\r\n      Array.isArray(category.items),\r\n  ) as MenuCategory[];\r\n\r\n  return categories.flatMap(\r\n    (category) =>\r\n      (Array.isArray(category.items) ? category.items : [])\r\n        .map((item: unknown) => {\r\n          if (!isMenuItem(item)) {\r\n            console.warn('Skipping invalid menu item:', item);\r\n            return;\r\n          }\r\n\r\n          return {\r\n            food_truck_id: truckId,\r\n            category:\r\n              typeof category.name === 'string' && category.name !== ''\r\n                ? category.name\r\n                : 'Uncategorized',\r\n            name: typeof item.name === 'string' && item.name !== '' ? item.name : 'Unknown Item',\r\n            description:\r\n              typeof item.description === 'string' && item.description !== ''\r\n                ? item.description\r\n                : undefined,\r\n            price:\r\n              typeof item.price === 'number' && !Number.isNaN(item.price) ? item.price : undefined,\r\n            dietary_tags: Array.isArray(item.dietary_tags) ? item.dietary_tags : [],\r\n          };\r\n        })\r\n        .filter(Boolean) as MenuItem[],\r\n  );\r\n}\r\n\r\nasync function insertMenuItems(truckId: string, menuData: MenuCategory[] | unknown[] | undefined) {\r\n  const menuItems = prepareMenuItemsForInsert(truckId, menuData);\r\n  if (menuItems.length === 0) return;\r\n  const { error: menuError } = await supabaseAdmin!.from('menu_items').insert(menuItems);\r\n  if (menuError) {\r\n    console.error('Error inserting menu items for truck', truckId, menuError);\r\n  }\r\n}\r\n\r\nexport {\r\n    handleSupabaseError,\r\n    calculateDistance,\r\n    normalizeTruckLocation,\r\n    prepareMenuItemsForInsert,\r\n    insertMenuItems,\r\n    \r\n    \r\n}\r\nexport {buildMenuByTruck, groupMenuItems} from './menuUtils';","usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\supabase\\utils\\menuUtils.js","messages":[{"ruleId":"sonarjs/unused-import","severity":2,"message":"Remove this unused import of 'isMenuCategory'.","line":1,"column":22,"nodeType":"Identifier","messageId":"removeUnusedImport","endLine":1,"endColumn":36,"suggestions":[{"messageId":"suggestRemoveOneVariable","fix":{"range":[19,35],"text":""},"desc":"Remove this variable import"}]},{"ruleId":"unicorn/no-array-for-each","severity":2,"message":"Use `for…of` instead of `.forEach(…)`.","line":27,"column":15,"nodeType":"Identifier","messageId":"no-array-for-each/error","endLine":27,"endColumn":22,"fix":{"range":[1105,1466],"text":"for (const item of menuItems) {\n        if (!isMenuItem(item))\n            continue;\n        const categoryName = item.category ?? 'Uncategorized';\n        const category = categoryMap.get(categoryName) ?? {\n            name: categoryName,\n            items: [],\n        };\n        category.items.push(item);\n        categoryMap.set(categoryName, category);\n    }"}},{"ruleId":null,"message":"Unused eslint-disable directive (no problems were reported from '@typescript-eslint/no-dynamic-delete').","line":92,"column":9,"severity":1,"nodeType":null,"fix":{"range":[4152,4216],"text":" "}}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":1,"fixableWarningCount":1,"source":"import { isMenuItem, isMenuCategory } from './typeGuards.js';\nimport { FoodTruckService } from '../services/foodTruckService.js';\n/**\n * Groups menu items by category and returns an array of menu categories.\n * @example\n * groupMenuItems([\n *   { category: 'Appetizers', name: 'Fries', price: 2.99 },\n *   { category: 'Main Course', name: 'Burger', price: 8.99 },\n *   { category: 'Appetizers', name: 'Onion Rings', price: 3.99 },\n * ])\n * // Returns:\n * // [\n * //   { name: 'Appetizers', items: [...] },\n * //   { name: 'Main Course', items: [...] },\n * // ]\n * @param {MenuItem[]} menuItems - An array of menu items to be grouped.\n * @returns {MenuCategory[]} An array of menu categories, each with a list of items.\n * @description\n *   - Uses a Map to group menu items by their category name.\n *   - Filters out any invalid or undefined menu items before processing.\n *   - Returns an empty array if no valid menu items are provided.\n */\nexport function groupMenuItems(menuItems) {\n    if (!Array.isArray(menuItems) || menuItems.length === 0)\n        return [];\n    const categoryMap = new Map();\n    menuItems.forEach((item) => {\n        if (!isMenuItem(item))\n            return;\n        const categoryName = item.category ?? 'Uncategorized';\n        const category = categoryMap.get(categoryName) ?? {\n            name: categoryName,\n            items: [],\n        };\n        category.items.push(item);\n        categoryMap.set(categoryName, category);\n    });\n    return [...categoryMap.values()];\n}\n/**\n * Builds a menu structure for a given truck by fetching its menu items.\n * @example\n * buildMenuByTruck(123)\n * // Returns a promise that resolves to an array of MenuCategory objects.\n * @param {number} truckId - The unique identifier for the food truck.\n * @returns {Promise<MenuCategory[]>} A promise that resolves to an array of menu categories for the truck.\n * @description\n *   - Fetches menu items for the specified truck ID using the FoodTruckService.\n *   - Groups the fetched menu items into categories using the groupMenuItems function.\n *   - Returns an empty array if there's an error or no menu items are found.\n */\nexport async function buildMenuByTruck(truckId) {\n    const truckResult = await FoodTruckService.getTruckById(truckId);\n    if (truckResult.error != undefined || truckResult.menu == undefined) {\n        return [];\n    }\n    return groupMenuItems(truckResult.menu);\n}\n/**\n * Updates the menu for a specific food truck.\n * @example\n * updateTruckMenu(123, [{ name: 'Drinks', items: [{ name: 'Coke', price: 1.99 }] }])\n * // Returns a promise that resolves when the menu is updated.\n * @param {number} truckId - The ID of the food truck to update.\n * @param {MenuCategory[]} menuData - An array of menu categories to be set as the new menu.\n * @returns {Promise<void>} A promise that resolves when the update is complete.\n * @description\n *   - First, deletes all existing menu items for the specified truck to ensure a fresh start.\n *   - Then, inserts the new menu items provided in the menuData array.\n *   - Handles potential errors during deletion or insertion and logs them.\n */\nexport async function updateTruckMenu(truckId, menuData) {\n    await FoodTruckService.deleteMenuByTruckId(truckId);\n    await insertMenuItems(truckId, menuData);\n}\n/**\n * Updates the data for a specific food truck.\n * @example\n * updateTruckData(123, { name: 'New Truck Name' })\n * // Returns a promise that resolves to the updated food truck data.\n * @param {number} truckId - The ID of the food truck to update.\n * @param {Partial<FoodTruckSchema>} truckData - An object containing the fields to update.\n * @returns {Promise<FoodTruck>} A promise that resolves to the updated food truck object.\n * @description\n *   - Updates the food truck's data with the provided partial data.\n *   - If menu data is included, it updates the menu separately using updateTruckMenu.\n *   - Returns the updated food truck data, excluding the menu from the main update object.\n */\nexport async function updateTruckData(truckId, truckData) {\n    if (truckData.menu != undefined) {\n        await updateTruckMenu(truckId, truckData.menu);\n        // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n        delete truckData.menu;\n    }\n    return await FoodTruckService.updateTruck(truckId, truckData);\n}\n","usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\supabase\\utils\\menuUtils.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":11,"column":18,"nodeType":"MemberExpression","messageId":"conditionErrorObject","endLine":11,"endColumn":49}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { MenuItem, MenuCategory, RawMenuItemFromDB, FoodTruck } from '../types';\r\nimport { isMenuCategory, isMenuItem } from './typeGuards';\r\nimport { supabaseAdmin } from '../client';\r\nimport { handleSupabaseError } from './index';\r\nimport { type PostgrestSingleResponse } from '@supabase/supabase-js';\r\n\r\nexport function buildMenuByTruck(menuItems: RawMenuItemFromDB[]): Record<string, RawMenuItemFromDB[]> {\r\n    const menuByTruck: Record<string, RawMenuItemFromDB[]> = {};\r\n    for (const item of menuItems) {\r\n        if (typeof item.food_truck_id === 'string' && item.food_truck_id.trim() !== '') {\r\n            if (!menuByTruck[item.food_truck_id]) {\r\n                menuByTruck[item.food_truck_id] = [];\r\n            }\r\n            menuByTruck[item.food_truck_id].push(item);\r\n        }\r\n    }\r\n    return menuByTruck;\r\n}\r\n\r\nexport function groupMenuItems(rawItems: RawMenuItemFromDB[]): MenuCategory[] {\r\n    const byCategory: Record<string, MenuItem[]> = {};\r\n    for (const rawItem of rawItems) {\r\n        const categoryName: string = rawItem.category ?? 'Uncategorized';\r\n        byCategory[categoryName] ??= [];\r\n        const menuItem: MenuItem = {\r\n            name: rawItem.name,\r\n            description: rawItem.description ?? undefined,\r\n            price: rawItem.price ?? undefined,\r\n            dietary_tags: (rawItem.dietary_tags as string[]) ?? [],\r\n        };\r\n        byCategory[categoryName].push(menuItem);\r\n    }\r\n    return Object.entries(byCategory).map(([categoryName, itemsList]: [string, MenuItem[]]) => ({\r\n        name: categoryName,\r\n        items: itemsList,\r\n    }));\r\n}\r\n\r\nexport async function updateTruckData(\r\n  id: string,\r\n  updatesWithoutMenu: Partial<FoodTruck>,\r\n): Promise<FoodTruck | { error: string }> {\r\n  if (!supabaseAdmin) {\r\n    return { error: 'Admin operations require SUPABASE_SERVICE_ROLE_KEY' };\r\n  }\r\n\r\n  const { data: truck, error }: PostgrestSingleResponse<FoodTruck> = await supabaseAdmin\r\n    .from('food_trucks')\r\n    .update(updatesWithoutMenu)\r\n    .eq('id', id)\r\n    .select()\r\n    .single();\r\n\r\n  if (error) {\r\n    handleSupabaseError(error, 'updateTruckData');\r\n    return { error: 'Failed to update truck data.' };\r\n  }\r\n  return truck;\r\n}\r\n\r\nexport async function updateTruckMenu(id: string, menuData: MenuCategory[] | unknown[]): Promise<void> {\r\n  if (!supabaseAdmin) {\r\n    throw new Error('Admin operations require SUPABASE_SERVICE_ROLE_KEY');\r\n  }\r\n\r\n  const { error: deleteError } = await supabaseAdmin\r\n    .from('menu_items')\r\n    .delete()\r\n    .eq('food_truck_id', id);\r\n\r\n  if (deleteError) {\r\n    console.error('Error deleting existing menu items for truck', id, deleteError);\r\n  }\r\n\r\n  if (menuData != undefined && menuData.length > 0) {\r\n    const menuItems = menuData.flatMap((category: unknown) => {\r\n      if (!isMenuCategory(category)) {\r\n        console.warn('Skipping invalid category in updateTruckMenu:', category);\r\n        return [];\r\n      }\r\n\r\n      return (category.items ?? []).map((item: unknown) => {\r\n        if (!isMenuItem(item)) {\r\n          console.warn('Skipping invalid menu item in updateTruckMenu:', item);\r\n          return {\r\n            food_truck_id: id,\r\n            category: category.name ?? 'Uncategorized',\r\n            name: 'Unknown Item',\r\n            description: undefined,\r\n            price: undefined,\r\n            dietary_tags: [],\r\n          };\r\n        }\r\n\r\n        return {\r\n          food_truck_id: id,\r\n          category: category.name ?? 'Uncategorized',\r\n          name: item.name ?? 'Unknown Item',\r\n          description: item.description ?? undefined,\r\n          price: typeof item.price === 'number' ? item.price : undefined,\r\n          dietary_tags: Array.isArray(item.dietary_tags) ? item.dietary_tags : [],\r\n        };\r\n      });\r\n    });\r\n\r\n    if (menuItems.length > 0) {\r\n      const { error: menuError } = await supabaseAdmin.from('menu_items').insert(menuItems);\r\n\r\n      if (menuError) {\r\n        console.error('Error inserting updated menu items for truck', id, menuError);\r\n      }\r\n    }\r\n  }\r\n}","usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\supabase\\utils\\typeGuards.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\supabase\\utils\\typeGuards.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\types.d.ts","messages":[{"ruleId":null,"nodeType":null,"fatal":true,"severity":2,"message":"Parsing error: \"parserOptions.project\" has been provided for @typescript-eslint/parser.\nThe file was not found in any of the provided project(s): lib\\types.d.ts"}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Type definitions for food truck data model\r\nexport type FoodTruck = {\r\n  id: string;\r\n  name: string;\r\n  description?: string;\r\n  cuisine_type: string[];\r\n  menu?: MenuCategory[];\r\n  current_location?: FoodTruckLocation;\r\n  contact_info?: ContactInfo;\r\n  operating_hours?: OperatingHours;\r\n  data_quality_score?: number;\r\n  source_urls?: string[];\r\n};\r\n\r\nexport type MenuCategory = {\r\n  category: string;\r\n  description?: string;\r\n  items: MenuItem[];\r\n};\r\n\r\nexport type MenuItem = {\r\n  name: string;\r\n  description?: string;\r\n  price?: number;\r\n  dietary_tags?: string[];\r\n  is_popular?: boolean;\r\n};\r\n\r\nexport type FoodTruckLocation = {\r\n  latitude: number;\r\n  longitude: number;\r\n  address?: string;\r\n  city?: string;\r\n  state?: string;\r\n  zip_code?: string;\r\n  parking_details?: string;\r\n};\r\n\r\nexport type ContactInfo = {\r\n  phone?: string;\r\n  email?: string;\r\n  website?: string;\r\n  instagram?: string;\r\n  twitter?: string;\r\n  facebook?: string;\r\n};\r\n\r\nexport type OperatingHours = {\r\n  monday?: DailyOperatingHours;\r\n  tuesday?: DailyOperatingHours;\r\n  wednesday?: DailyOperatingHours;\r\n  thursday?: DailyOperatingHours;\r\n  friday?: DailyOperatingHours;\r\n  saturday?: DailyOperatingHours;\r\n  sunday?: DailyOperatingHours;\r\n};\r\n\r\nexport type DailyOperatingHours = {\r\n  open: string;\r\n  close: string;\r\n  closed?: boolean;\r\n};\r\n\r\n// Pipeline types\r\nexport type ExtractedFoodTruckDetails = {\r\n  name: string;\r\n  description?: string;\r\n  menu?: MenuCategory[];\r\n  contact_info?: ContactInfo;\r\n  operating_hours?: OperatingHours;\r\n  cuisine_type?: string[];\r\n};\r\n\r\nexport type StageResult = {\r\n  status: 'Success' | 'Error';\r\n  error?: string;\r\n};\r\n\r\nexport type PipelineRunResult = {\r\n  status: 'Success' | 'Error';\r\n  firecrawlResult: StageResult;\r\n  geminiResult?: StageResult;\r\n  supabaseResult?: StageResult;\r\n  error?: string;\r\n  extractedData?: ExtractedFoodTruckDetails;\r\n};\r\n\r\nexport type FirecrawlResponse = {\r\n  url: string;\r\n  content: string;\r\n  error?: string;\r\n};\r\n\r\nexport type GeminiResponse<T> = {\r\n  status: 'Success' | 'Error';\r\n  data?: T;\r\n  error?: string;\r\n  suggestedPrompt?: string;\r\n};\r\n\r\nexport type ScrapingJob = {\r\n  id: string;\r\n  target_url: string;\r\n  status: 'pending' | 'running' | 'completed' | 'failed';\r\n  priority: number;\r\n  created_at: string;\r\n  updated_at: string;\r\n  completed_at?: string;\r\n  error?: string;\r\n  result?: FirecrawlResponse;\r\n};\r\n\r\nexport type DataProcessingQueue = {\r\n  id: string;\r\n  food_truck_id: string;\r\n  status: 'pending' | 'processing' | 'completed' | 'failed';\r\n  created_at: string;\r\n  updated_at: string;\r\n  completed_at?: string;\r\n  error?: string;\r\n};\r\n\r\n// Security types\r\nexport type SecurityEvent = {\r\n  event_type: 'access_denied' | 'rate_limit_exceeded' | 'invalid_token';\r\n  severity: 'low' | 'medium' | 'high';\r\n};\r\n\r\n// Data cleanup types\r\nexport type CleanupOperation = {\r\n  type: 'remove_duplicates' | 'fix_placeholders' | 'validate_coordinates' | 'normalize_contact';\r\n  options?: Record<string, unknown>;\r\n};\r\n\r\n// Metrics types\r\nexport type RealtimeMetrics = {\r\n  scraping_jobs: {\r\n    active: number;\r\n    completed: number;\r\n    failed: number;\r\n    pending: number;\r\n  };\r\n};\r\n\r\n// Service types\r\nexport type APIService = 'gemini' | 'tavily' | 'firecrawl';\r\n","usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\types.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\types.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":157,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":157,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3648,3651],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3648,3651],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":158,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":158,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3671,3674],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3671,3674],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Shared types for the Food Truck Finder application\nimport { ReactElement } from 'react';\n\nexport type PriceRange = '$' | '$$' | '$$$' | '$$$$' | undefined;\n\nexport type DailyOperatingHours =\n  | { open: string; close: string; closed?: boolean }\n  | { closed: true }\n  | undefined;\n\nexport interface OperatingHours {\n  monday: DailyOperatingHours;\n  tuesday: DailyOperatingHours;\n  wednesday: DailyOperatingHours;\n  thursday: DailyOperatingHours;\n  friday: DailyOperatingHours;\n  saturday: DailyOperatingHours;\n  sunday: DailyOperatingHours;\n  [key: string]: DailyOperatingHours; // Add index signature\n}\n\nexport interface MenuCategory {\n  name: string;\n  items: MenuItem[];\n}\n\nexport interface MenuItem {\n  name: string;\n  description: string | undefined;\n  price: number | string | undefined;\n  dietary_tags: string[];\n  is_popular?: boolean;\n}\n\nexport interface UserCoordinates {\n  lat: number;\n  lng: number;\n}\n\nexport interface LocationData {\n  address: string | undefined;\n  city: string | undefined;\n  state: string | undefined;\n  landmarks: string[];\n  coordinates: UserCoordinates;\n  confidence: number;\n  raw_location_text: string | undefined;\n}\n\n\n\n\n\nexport interface ExtractedFoodTruckDetails {\n  name: string | undefined;\n  description: string | undefined;\n  cuisine_type: string[];\n  price_range: PriceRange | undefined;\n  specialties: string[];\n  current_location: {\n    address: string | undefined;\n    city: string | undefined;\n    state: string | undefined;\n    zip_code: string | undefined;\n    lat?: number;\n    lng?: number;\n    raw_text: string | undefined;\n  };\n  scheduled_locations?: {\n    address?: string;\n    city?: string;\n    state?: string;\n    zip_code?: string;\n    lat?: number;\n    lng?: number;\n    timestamp: string;\n    start_time: string;\n    end_time: string;\n  }[];\n  operating_hours: OperatingHours;\n  menu: MenuCategory[];\n  contact_info: {\n    phone?: string;\n    email?: string;\n    website?: string;\n  };\n  social_media: {\n    instagram?: string;\n    facebook?: string;\n    twitter?: string;\n    tiktok?: string;\n    yelp?: string;\n  };\n  source_url: string;\n}\n\nexport interface FirecrawlOutputData {\n  markdown: string;\n  name?: string;\n  source_url?: string;\n}\n\nexport interface FoodTruckSchema {\n  name: string;\n  description: string | undefined;\n  current_location: {\n    lat: number;\n    lng: number;\n    address: string | undefined;\n    timestamp: string;\n  };\n  scheduled_locations: ExtractedFoodTruckDetails['scheduled_locations'];\n  operating_hours: OperatingHours;\n  menu: MenuCategory[];\n  contact_info: {\n    phone?: string;\n    email?: string;\n    website?: string;\n  };\n  social_media: {\n    instagram?: string;\n    facebook?: string;\n    twitter?: string;\n    tiktok?: string;\n    yelp?: string;\n  };\n  cuisine_type: string[];\n  price_range: PriceRange | undefined;\n  specialties: string[];\n  data_quality_score: number;\n  verification_status: 'pending' | 'verified' | 'flagged';\n  source_urls: string[];\n  last_scraped_at: string;\n  test_run_flag?: boolean;\n  website?: string;\n  phone_number?: string;\n  email?: string;\n  instagram_handle?: string;\n  facebook_handle?: string;\n  twitter_handle?: string;\n  schedule?: unknown[];\n  average_rating?: number;\n  review_count?: number;\n}\n\nexport interface FoodTruck extends FoodTruckSchema {\n  id: string;\n  created_at: string;\n  updated_at: string;\n  last_updated_at?: string; // Alternative field name for compatibility\n  user_id?: string; // References auth.users(id)\n  state?: string; // US state abbreviation (2 chars)\n  is_active?: boolean;\n  image_url?: string;\n  average_rating?: number;\n  review_count?: number;\n  exact_location?: any;\n  city_location?: any;\n}\n\nexport interface GeminiResponse<T = unknown> {\n  success: boolean;\n  data?: T;\n  tokensUsed?: number;\n  error?: string;\n  promptSent?: string;\n}\n\nexport interface StageResult {\n  status: string;\n  data?: FirecrawlOutputData | ExtractedFoodTruckDetails | FoodTruckSchema;\n  error?: string;\n  details?: string;\n  prompt?: string;\n  tokensUsed?: number;\n  metadata?: { name?: string; source_url?: string };\n  rawContent?: string;\n  preparedData?: FoodTruckSchema;\n  recordId?: string;\n}\n\nexport interface TestPipelineResults {\n  firecrawl?: StageResult;\n  gemini?: StageResult;\n  supabase?: StageResult;\n  overallStatus?: string;\n  logs?: string[];\n  error?: string;\n}\n\nexport interface PipelineRunResult {\n  firecrawl?: StageResult;\n  gemini?: StageResult;\n  supabase?: StageResult;\n  logs: string[];\n  overallStatus: 'Success' | 'Error';\n}\n\nexport interface ScrapingJob {\n  id: string;\n  job_type: string;\n  target_url?: string;\n  target_handle?: string;\n  platform?: string;\n  status: 'pending' | 'running' | 'completed' | 'failed';\n  priority: number;\n  scheduled_at: string;\n  started_at?: string;\n  completed_at?: string;\n  data_collected?: Record<string, unknown>;\n  errors?: string[];\n  retry_count: number;\n  max_retries: number;\n  created_at: string;\n}\n\nexport interface RealtimeMetrics {\n  scrapingJobs: {\n    active: number;\n    completed: number;\n    failed: number;\n    pending: number;\n  };\n  dataQuality: {\n    averageScore: number;\n    totalTrucks: number;\n    recentChanges: number;\n  };\n  systemHealth: {\n    status: 'healthy' | 'warning' | 'error';\n    uptime: number;\n    lastUpdate: string;\n  };\n}\n\nexport interface TruckRating {\n  id: number;\n  title: string;\n  score: number;\n}\n\nexport interface PipelineEvent {\n  type: string; // e.g., 'job_started', 'job_completed', 'data_updated'\n  payload: Record<string, unknown>; // Generic payload for event-specific data\n  timestamp: string;\n}\n\nexport interface SentimentAnalysisResult {\n  sentiment: 'positive' | 'negative' | 'neutral';\n  score: number;\n  confidence: number;\n  key_topics: string[];\n  positive_aspects: string[];\n  negative_aspects: string[];\n  summary: string;\n  recommended: boolean;\n}\n\nexport interface EnhancedFoodTruckData {\n  name: string | undefined;\n  description: string | undefined;\n  cuisine_type: string[];\n  price_range: PriceRange;\n  specialties: string[];\n  dietary_options: string[];\n  enhanced_menu: {\n    categories: MenuCategory[];\n  };\n  standardized_hours: OperatingHours;\n  cleaned_contact: {\n    phone: string | undefined;\n    email: string | undefined;\n    website: string | undefined;\n  };\n  data_quality_improvements: string[];\n  confidence_score: number;\n}\n\n// Additional types needed by various parts of the application\nexport interface DataProcessingQueue {\n  id: string;\n  truck_id?: string;\n  processing_type: string;\n  raw_data: Record<string, unknown>;\n  processed_data?: Record<string, unknown>;\n  gemini_tokens_used: number;\n  status: 'pending' | 'processing' | 'completed' | 'failed';\n  priority: number;\n  created_at: string;\n  processed_at?: string;\n}\n\nexport interface ApiUsage {\n  id: string;\n  service_name: string;\n  usage_date: string;\n  requests_count: number;\n  tokens_used: number;\n}\n\nexport interface QualityCategory {\n  name: string;\n  score: number;\n  issues: string[];\n}\n\nexport interface SystemAlert {\n  id: string;\n  type: string;\n  message: string;\n  timestamp: string;\n  severity: 'low' | 'medium' | 'high' | 'critical';\n}\n\nexport interface RealtimeAdminEvent {\n  type: string;\n  payload: Record<string, unknown>;\n  timestamp: string;\n}\n\nexport interface FoodTruckWithRatings extends FoodTruck {\n  ratings?: TruckRating[];\n}\n\nexport interface SecurityEvent {\n  event_type: string;\n  severity: 'low' | 'medium' | 'high' | 'critical';\n  timestamp: string;\n  details: Record<string, unknown>;\n}\n\nexport interface APIService {\n  name: string;\n  endpoint: string;\n  status: 'active' | 'inactive';\n}\n\nexport interface Database {\n  public: {\n    tables: Record<string, unknown>;\n  };\n}\n\n// Type aliases to replace namespace-style property access\nexport type CleanupOperationType = \n  | 'normalize_phone'\n  | 'fix_coordinates'\n  | 'remove_placeholders'\n  | 'update_quality_scores'\n  | 'merge_duplicates';\n\nexport interface CleanupOperation {\n  type: CleanupOperationType;\n  description: string;\n  affectedCount: number;\n  successCount: number;\n  errorCount: number;\n  errors: string[];\n}\n\nexport interface BatchCleanupResult {\n  totalProcessed: number;\n  operations: CleanupOperation[];\n  summary: {\n    trucksImproved: number;\n    duplicatesRemoved: number;\n    qualityScoreImprovement: number;\n    placeholdersRemoved: number;\n  };\n  duration: number;\n}\n\n// Request/Response types for various API endpoints\nexport interface DataCleanupRequestBody {\n  action: string;\n  options?: {\n    batchSize?: number;\n    dryRun?: boolean;\n    operations?: string[];\n    truckData?: Record<string, unknown>;\n    targetId?: string;\n    sourceId?: string;\n  };\n}\n\nexport interface FirecrawlRequestBody {\n  url: string;\n  extractorOptions?: Record<string, unknown>;\n}\n\nexport interface TavilyRequestBody {\n  query: string;\n  searchDepth?: 'basic' | 'advanced';\n  includeImages?: boolean;\n  includeAnswer?: boolean;\n  maxResults?: number;\n}\n\nexport interface PostRequestBody {\n  action: string;\n  data?: Record<string, unknown>;\n}\n\nexport interface PutRequestBody {\n  id: string;\n  updates: Record<string, unknown>;\n}\n\n// UI Component Types\nexport interface ButtonProps {\n  variant?: 'default' | 'destructive' | 'outline' | 'secondary' | 'ghost' | 'link';\n  size?: 'default' | 'sm' | 'lg' | 'icon';\n  asChild?: boolean;\n}\n\nexport interface ToasterToast {\n  id: string;\n  title?: string;\n  description?: string;\n  action?: ReactElement;\n  variant?: 'default' | 'destructive';\n}\n\nexport interface ToastComponentProps {\n  toast: ToasterToast;\n}\n\nexport interface ToastActionElement {\n  altText: string;\n  element: ReactElement;\n}\n\n// Generic Result types\nexport interface CleanupResult {\n  success: boolean;\n  totalProcessed: number;\n  operations: CleanupOperation[];\n  summary: {\n    trucksImproved: number;\n    duplicatesRemoved: number;\n    qualityScoreImprovement: number;\n    placeholdersRemoved: number;\n  };\n  duration: number;\n  error?: string;\n}\n\nexport interface RequestBody {\n  action: string;\n  options?: Record<string, unknown>;\n}\n\nexport interface FirecrawlResponse {\n  success: boolean;\n  data?: Record<string, unknown>;\n  error?: string;\n}\n","usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\types\\paths.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\types\\webVitals.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\utils.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\utils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\utils\\QualityScorer.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\utils\\QualityScorer.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\utils\\apiHelpers.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\utils\\apiHelpers.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\utils\\dataQualityFormatters.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\utils\\dataQualityFormatters.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\utils\\foodTruckHelpers.js","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error, info.","line":102,"column":13,"nodeType":"MemberExpression","messageId":"limited","endLine":102,"endColumn":24,"suggestions":[{"fix":{"range":[4514,4592],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"unicorn/numeric-separators-style","severity":2,"message":"Invalid group length in numeric value.","line":113,"column":22,"nodeType":"Literal","messageId":"numeric-separators-style","endLine":113,"endColumn":27,"fix":{"range":[5021,5026],"text":"10_000"}},{"ruleId":"unicorn/numeric-separators-style","severity":2,"message":"Invalid group length in numeric value.","line":114,"column":25,"nodeType":"Literal","messageId":"numeric-separators-style","endLine":114,"endColumn":31,"fix":{"range":[5053,5059],"text":"300_000"}},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error, info.","line":139,"column":9,"nodeType":"MemberExpression","messageId":"limited","endLine":139,"endColumn":20,"suggestions":[{"fix":{"range":[6035,6085],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error, info.","line":141,"column":9,"nodeType":"MemberExpression","messageId":"limited","endLine":141,"endColumn":20,"suggestions":[{"fix":{"range":[6159,6220],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error, info.","line":142,"column":9,"nodeType":"MemberExpression","messageId":"limited","endLine":142,"endColumn":20,"suggestions":[{"fix":{"range":[6230,6294],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error, info.","line":143,"column":9,"nodeType":"MemberExpression","messageId":"limited","endLine":143,"endColumn":20,"suggestions":[{"fix":{"range":[6304,6350],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error, info.","line":144,"column":9,"nodeType":"MemberExpression","messageId":"limited","endLine":144,"endColumn":20,"suggestions":[{"fix":{"range":[6360,6413],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]}],"suppressedMessages":[{"ruleId":"sonarjs/no-intrusive-permissions","severity":2,"message":"Make sure the use of the geolocation is necessary.","line":101,"column":9,"nodeType":"MemberExpression","messageId":"checkPermission","endLine":101,"endColumn":49,"suppressions":[{"kind":"directive","justification":"Geolocation is essential for finding nearby food trucks"}]}],"errorCount":2,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":2,"fixableWarningCount":0,"source":"import { supabaseFallback } from '../../lib/fallback/supabaseFallback.js';\r\nexport const getCurrentDay = () => {\r\n    const days = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];\r\n    return days[new Date().getDay()];\r\n};\r\nexport const formatPrice = (price) => {\r\n    // Updated to accept string\r\n    if (typeof price === 'string') {\r\n        // Handle cases where price might be a string like \"$10-$20\" or \"Varies\"\r\n        return price;\r\n    }\r\n    return new Intl.NumberFormat('en-US', {\r\n        style: 'currency',\r\n        currency: 'USD',\r\n    }).format(price);\r\n};\r\n/**\r\n* Converts operational hours to a readable format or returns 'Closed' if applicable.\r\n* @example\r\n* formatOperatingHours({ open: '09:00', close: '17:00', closed: false })\r\n* '9:00 AM - 5:00 PM'\r\n* @param {DailyOperatingHours} hours - Object containing daily opening and closing times, and closed status.\r\n* @returns {string} Formatted operating hours string or 'Closed'.\r\n* @description\r\n*   - Handles conversion of military time to 12-hour format.\r\n*   - Adjusts for typical date parsing without relying on actual date due to fixed date string.\r\n*   - Properly responds to 'closed' status by returning 'Closed'.\r\n*   - Locales can impact formatted output by changing time conventions.\r\n*/\r\nexport const formatHours = (hours) => {\r\n    // Updated to accept DailyOperatingHours\r\n    if (!hours || hours.closed) {\r\n        return 'Closed';\r\n    }\r\n    const open = new Date(`1970-01-01T${hours.open}Z`).toLocaleTimeString('en-US', {\r\n        hour: 'numeric',\r\n        minute: 'numeric',\r\n        hour12: true,\r\n    });\r\n    const close = new Date(`1970-01-01T${hours.close}Z`).toLocaleTimeString('en-US', {\r\n        hour: 'numeric',\r\n        minute: 'numeric',\r\n        hour12: true,\r\n    });\r\n    return `${open} - ${close}`;\r\n};\r\nexport const getPopularItems = (truck) => {\r\n    // Explicitly define return type\r\n    // Explicitly check for nullish and boolean\r\n    return (truck.menu\r\n        ?.flatMap((category) => category.items)\r\n        .filter((item) => Boolean(item && item.is_popular === true)) ?? []);\r\n};\r\n/**\r\n * Calculates the price range of all items in the food truck's menu.\r\n * @example\r\n * getPriceRange(foodTruck)\r\n * \"5.00 - 12.50\"\r\n * @param {FoodTruck} truck - The food truck object containing menu details.\r\n * @returns {string} Returns a formatted string representing the price range or 'N/A' if no valid prices are found.\r\n * @description\r\n *   - Utilizes the optional chaining operator to safely access nested menu items.\r\n *   - Filters out non-numeric and undefined prices before calculating the range.\r\n *   - Formats the minimum and maximum prices using a helper function.\r\n */\r\nexport const getPriceRange = (truck) => {\r\n    const allItems = truck.menu?.flatMap((category) => category.items);\r\n    if (!allItems || allItems.length === 0) {\r\n        return 'N/A';\r\n    }\r\n    const numericPrices = allItems\r\n        .map((item) => item.price)\r\n        .filter((price) => typeof price === 'number' && price != undefined); // Filter for numbers\r\n    if (numericPrices.length === 0) {\r\n        return 'N/A'; // No numeric prices found\r\n    }\r\n    const minPrice = Math.min(...numericPrices);\r\n    const maxPrice = Math.max(...numericPrices);\r\n    return `${formatPrice(minPrice)} - ${formatPrice(maxPrice)}`;\r\n};\r\nexport const getTodayHours = (truck) => {\r\n    const today = getCurrentDay();\r\n    return truck.operating_hours?.[today];\r\n};\r\n// Get user's current location or default to San Francisco\r\n/**\r\n * Retrieves the user's geolocation and updates the location state.\r\n * @example\r\n * getUserLocationHelper(setUserLocation)\r\n * // Updates user's location or defaults to San Francisco\r\n * @param {function} setUserLocation - Callback function to update user's location state with latitude and longitude.\r\n * @returns {void} Function does not return anything.\r\n * @description\r\n *   - Defaults the location to San Francisco if geolocation access is denied or not supported.\r\n *   - Utilizes browser's geolocation API to fetch current coordinates.\r\n *   - Provides a warning in the console if location access is denied.\r\n */\r\nexport function getUserLocationHelper(setUserLocation) {\r\n    if (typeof navigator !== 'undefined' && navigator.geolocation != undefined) {\r\n        // eslint-disable-next-line sonarjs/no-intrusive-permissions -- Geolocation is essential for finding nearby food trucks\r\n        navigator.geolocation.getCurrentPosition((position) => {\r\n            console.log('📍 User location accuracy:', position.coords.accuracy, 'meters');\r\n            setUserLocation({\r\n                lat: position.coords.latitude,\r\n                lng: position.coords.longitude,\r\n            });\r\n        }, (error) => {\r\n            console.warn('Location access denied:', error);\r\n            // Default to Charleston, SC for this project\r\n            setUserLocation({ lat: 32.7765, lng: -79.9311 });\r\n        }, {\r\n            enableHighAccuracy: true,\r\n            timeout: 10000,\r\n            maximumAge: 300000 // 5 minutes\r\n        });\r\n    }\r\n    else {\r\n        // Default to San Francisco if geolocation is not supported\r\n        setUserLocation({ lat: 37.7749, lng: -122.4194 });\r\n    }\r\n}\r\n// Load all food trucks from API\r\n/**\r\n * Loads food truck data from the server and updates state.\r\n * @example\r\n * loadFoodTrucksHelper(setTrucks, setLoading)\r\n * undefined\r\n * @param {(trucks: FoodTruck[]) => void} setTrucks - Callback to update the state with loaded food trucks.\r\n * @param {(loading: boolean) => void} setLoading - Callback to update the loading state.\r\n * @returns {void} No return value.\r\n * @description\r\n *   - Fetches data from '/api/trucks' endpoint.\r\n *   - Parses the response and expects an object containing a 'trucks' array.\r\n *   - Logs an error message to the console if fetching or parsing fails.\r\n *   - Ensures loading state is updated to false in all cases.\r\n */\r\nexport async function loadFoodTrucksHelper(setTrucks, setLoading) {\r\n    try {\r\n        console.log('🔍 Starting to load food trucks...');\r\n        const result = await supabaseFallback.getFoodTrucks();\r\n        console.log('📦 Full result from supabaseFallback:', result);\r\n        console.log('🚛 Number of trucks found:', result.trucks.length);\r\n        console.log('📊 Data status:', result.status);\r\n        console.log('💾 Is from cache:', result.isFromCache);\r\n        setTrucks(result.trucks);\r\n    }\r\n    catch (error) {\r\n        console.error('❌ Failed to load food trucks:', error);\r\n        setTrucks([]);\r\n    }\r\n    finally {\r\n        setLoading(false);\r\n    }\r\n}\r\n// Load nearby food trucks based on user location\r\n/**\r\n* Loads nearby food trucks based on user's location.\r\n* @example\r\n* loadNearbyTrucksHelper({ lat: 37.7749, lng: -122.4194 }, setTrucksCallback)\r\n* // sets trucks with food truck data or an empty array\r\n* @param {{ lat: number; lng: number } | undefined} userLocation - The location of the user used to find nearby trucks.\r\n* @param {(trucks: FoodTruck[]) => void} setTrucks - Callback function to set the trucks data.\r\n* @returns {void} No return value.\r\n* @description\r\n*   - Fetches nearby trucks from the API using latitude and longitude.\r\n*   - Uses a fixed radius of 10 units for truck search.\r\n*   - Handles errors by logging them to the console.\r\n*/\r\nexport async function loadNearbyTrucksHelper(userLocation, setTrucks) {\r\n    if (!userLocation)\r\n        return;\r\n    try {\r\n        const { trucks } = await supabaseFallback.getFoodTrucks();\r\n        setTrucks(trucks);\r\n    }\r\n    catch (error) {\r\n        console.error('Failed to load nearby trucks:', error);\r\n    }\r\n}\r\n// Filter trucks that have minimum viable data to display\r\n/**\r\n * Determines if a food truck has enough essential data to be displayed to users.\r\n * @example\r\n * isViableTruck(foodTruck)\r\n * // returns true if truck has name and location, false otherwise\r\n * @param {FoodTruck} truck - The food truck object to validate.\r\n * @returns {boolean} Indicates whether the truck should be displayed.\r\n * @description\r\n *   - Checks for minimum required fields: name and valid location coordinates.\r\n *   - Ensures location has either coordinates OR a meaningful address.\r\n *   - Flags trucks missing essential data for admin review.\r\n */\r\nexport function isViableTruck(truck) {\r\n    // Must have a name\r\n    if (!truck.name || truck.name.trim() === '' || truck.name === 'Unnamed Truck') {\r\n        console.warn('🚨 Truck missing name:', truck.id);\r\n        return false;\r\n    }\r\n    // Must have location data\r\n    if (!truck.current_location) {\r\n        console.warn('🚨 Truck missing location data:', truck.name);\r\n        return false;\r\n    }\r\n    // Must have either coordinates OR a meaningful address\r\n    const hasCoordinates = typeof truck.current_location.lat === 'number' &&\r\n        typeof truck.current_location.lng === 'number';\r\n    const hasAddress = truck.current_location.address &&\r\n        truck.current_location.address.trim() !== '' &&\r\n        truck.current_location.address !== 'Unknown';\r\n    if (!hasCoordinates && !hasAddress) {\r\n        console.warn('🚨 Truck missing both coordinates and address:', truck.name);\r\n        return false;\r\n    }\r\n    return true;\r\n}\r\n// Check if a food truck is currently open\r\n/**\r\n * Determines if the food truck is currently open based on its operating hours.\r\n * @example\r\n * isTruckOpen(myFoodTruck)\r\n * // returns true or false depending on current time and truck's operating hours\r\n * @param {FoodTruck} truck - The food truck object with operating hours.\r\n * @returns {boolean} Indicates whether the truck is open.\r\n * @description\r\n *   - Utilizes the current day's name to fetch operating hours.\r\n *   - Handles potential errors in parsing operating hours.\r\n *   - Logs errors related to parsing time and truck name.\r\n *   - Uses military time format (HHMM) for comparison.\r\n */\r\nexport function isTruckOpen(truck) {\r\n    const today = getCurrentDay();\r\n    const hours = truck.operating_hours?.[today];\r\n    // Ensure hours and its properties are not null/undefined before accessing\r\n    if (hours == undefined ||\r\n        hours.closed === true ||\r\n        hours.open == undefined ||\r\n        hours.close == undefined) {\r\n        return false;\r\n    }\r\n    try {\r\n        const now = new Date();\r\n        const currentTime = now.getHours() * 100 + now.getMinutes();\r\n        const openTime = Number.parseInt(hours.open.replace(':', ''), 10);\r\n        const closeTime = Number.parseInt(hours.close.replace(':', ''), 10);\r\n        return currentTime >= openTime && currentTime <= closeTime;\r\n    }\r\n    catch (error) {\r\n        console.error('Error parsing operating hours for truck', truck.name, error);\r\n        return false;\r\n    }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\utils\\foodTruckHelpers.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":36,"column":17,"nodeType":"MemberExpression","messageId":"conditionErrorNullableBoolean","endLine":36,"endColumn":29,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[1487,1499],"text":"(hours.closed ?? false)"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[1487,1499],"text":"(hours.closed === true)"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":58,"column":51,"nodeType":"Identifier","messageId":"conditionErrorObject","endLine":58,"endColumn":55},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":76,"column":8,"nodeType":"Identifier","messageId":"conditionErrorObject","endLine":76,"endColumn":16},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error, info.","line":117,"column":9,"nodeType":"MemberExpression","messageId":"limited","endLine":117,"endColumn":20,"suggestions":[{"fix":{"range":[4660,4738],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"unicorn/numeric-separators-style","severity":2,"message":"Invalid group length in numeric value.","line":130,"column":18,"nodeType":"Literal","messageId":"numeric-separators-style","endLine":130,"endColumn":23,"fix":{"range":[5137,5142],"text":"10_000"}},{"ruleId":"unicorn/numeric-separators-style","severity":2,"message":"Invalid group length in numeric value.","line":131,"column":21,"nodeType":"Literal","messageId":"numeric-separators-style","endLine":131,"endColumn":27,"fix":{"range":[5165,5171],"text":"300_000"}},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error, info.","line":160,"column":5,"nodeType":"MemberExpression","messageId":"limited","endLine":160,"endColumn":16,"suggestions":[{"fix":{"range":[6199,6249],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error, info.","line":162,"column":5,"nodeType":"MemberExpression","messageId":"limited","endLine":162,"endColumn":16,"suggestions":[{"fix":{"range":[6315,6376],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error, info.","line":163,"column":5,"nodeType":"MemberExpression","messageId":"limited","endLine":163,"endColumn":16,"suggestions":[{"fix":{"range":[6382,6446],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error, info.","line":164,"column":5,"nodeType":"MemberExpression","messageId":"limited","endLine":164,"endColumn":16,"suggestions":[{"fix":{"range":[6452,6498],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error, info.","line":165,"column":5,"nodeType":"MemberExpression","messageId":"limited","endLine":165,"endColumn":16,"suggestions":[{"fix":{"range":[6504,6557],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":224,"column":8,"nodeType":"MemberExpression","messageId":"conditionErrorObject","endLine":224,"endColumn":30},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":235,"column":5,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":235,"endColumn":35,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[9117,9147],"text":"(truck.current_location.address != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[9117,9147],"text":"(truck.current_location.address ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[9117,9147],"text":"(Boolean(truck.current_location.address))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected value in conditional. A boolean expression is required.","line":239,"column":27,"nodeType":"Identifier","messageId":"conditionErrorOther","endLine":239,"endColumn":37}],"suppressedMessages":[{"ruleId":"sonarjs/no-intrusive-permissions","severity":2,"message":"Make sure the use of the geolocation is necessary.","line":115,"column":5,"nodeType":"MemberExpression","messageId":"checkPermission","endLine":115,"endColumn":45,"suppressions":[{"kind":"directive","justification":"Geolocation is essential for finding nearby food trucks"}]}],"errorCount":2,"fatalErrorCount":0,"warningCount":12,"fixableErrorCount":2,"fixableWarningCount":0,"source":"import type { FoodTruck, DailyOperatingHours, MenuItem } from '@/lib/types';\r\nimport { supabaseFallback } from '@/lib/fallback/supabaseFallback';\r\n\r\nexport const getCurrentDay = () => {\r\n  const days = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];\r\n  return days[new Date().getDay()];\r\n};\r\n\r\nexport const formatPrice = (price: number | string) => {\r\n  // Updated to accept string\r\n  if (typeof price === 'string') {\r\n    // Handle cases where price might be a string like \"$10-$20\" or \"Varies\"\r\n    return price;\r\n  }\r\n  return new Intl.NumberFormat('en-US', {\r\n    style: 'currency',\r\n    currency: 'USD',\r\n  }).format(price);\r\n};\r\n\r\n/**\r\n* Converts operational hours to a readable format or returns 'Closed' if applicable.\r\n* @example\r\n* formatOperatingHours({ open: '09:00', close: '17:00', closed: false })\r\n* '9:00 AM - 5:00 PM'\r\n* @param {DailyOperatingHours} hours - Object containing daily opening and closing times, and closed status.\r\n* @returns {string} Formatted operating hours string or 'Closed'.\r\n* @description\r\n*   - Handles conversion of military time to 12-hour format.\r\n*   - Adjusts for typical date parsing without relying on actual date due to fixed date string.\r\n*   - Properly responds to 'closed' status by returning 'Closed'.\r\n*   - Locales can impact formatted output by changing time conventions.\r\n*/\r\nexport const formatHours = (hours: DailyOperatingHours) => {\r\n  // Updated to accept DailyOperatingHours\r\n  if (!hours || hours.closed) {\r\n    return 'Closed';\r\n  }\r\n  const open = new Date(`1970-01-01T${hours.open}Z`).toLocaleTimeString('en-US', {\r\n    hour: 'numeric',\r\n    minute: 'numeric',\r\n    hour12: true,\r\n  });\r\n  const close = new Date(`1970-01-01T${hours.close}Z`).toLocaleTimeString('en-US', {\r\n    hour: 'numeric',\r\n    minute: 'numeric',\r\n    hour12: true,\r\n  });\r\n  return `${open} - ${close}`;\r\n};\r\n\r\nexport const getPopularItems = (truck: FoodTruck): MenuItem[] => {\r\n  // Explicitly define return type\r\n  // Explicitly check for nullish and boolean\r\n  return (\r\n    truck.menu\r\n      ?.flatMap((category) => category.items)\r\n      .filter((item): item is MenuItem => Boolean(item && item.is_popular === true)) ?? []\r\n  );\r\n};\r\n\r\n/**\r\n * Calculates the price range of all items in the food truck's menu.\r\n * @example\r\n * getPriceRange(foodTruck)\r\n * \"5.00 - 12.50\"\r\n * @param {FoodTruck} truck - The food truck object containing menu details.\r\n * @returns {string} Returns a formatted string representing the price range or 'N/A' if no valid prices are found.\r\n * @description\r\n *   - Utilizes the optional chaining operator to safely access nested menu items.\r\n *   - Filters out non-numeric and undefined prices before calculating the range.\r\n *   - Formats the minimum and maximum prices using a helper function.\r\n */\r\nexport const getPriceRange = (truck: FoodTruck) => {\r\n  const allItems = truck.menu?.flatMap((category) => category.items);\r\n  if (!allItems || allItems.length === 0) {\r\n    return 'N/A';\r\n  }\r\n  const numericPrices = allItems\r\n    .map((item) => item.price)\r\n    .filter((price): price is number => typeof price === 'number' && price != undefined); // Filter for numbers\r\n\r\n  if (numericPrices.length === 0) {\r\n    return 'N/A'; // No numeric prices found\r\n  }\r\n\r\n  const minPrice = Math.min(...numericPrices);\r\n  const maxPrice = Math.max(...numericPrices);\r\n  return `${formatPrice(minPrice)} - ${formatPrice(maxPrice)}`;\r\n};\r\n\r\nexport const getTodayHours = (truck: FoodTruck) => {\r\n  const today = getCurrentDay();\r\n  return truck.operating_hours?.[today];\r\n};\r\n\r\n// Get user's current location or default to San Francisco\r\n/**\r\n * Retrieves the user's geolocation and updates the location state.\r\n * @example\r\n * getUserLocationHelper(setUserLocation)\r\n * // Updates user's location or defaults to San Francisco\r\n * @param {function} setUserLocation - Callback function to update user's location state with latitude and longitude.\r\n * @returns {void} Function does not return anything.\r\n * @description\r\n *   - Defaults the location to San Francisco if geolocation access is denied or not supported.\r\n *   - Utilizes browser's geolocation API to fetch current coordinates.\r\n *   - Provides a warning in the console if location access is denied.\r\n */\r\nexport function getUserLocationHelper(\r\n  setUserLocation: (location: { lat: number; lng: number }) => void,\r\n) {\r\n  if (typeof navigator !== 'undefined' && navigator.geolocation != undefined) {\r\n    // eslint-disable-next-line sonarjs/no-intrusive-permissions -- Geolocation is essential for finding nearby food trucks\r\n    navigator.geolocation.getCurrentPosition(\r\n      (position) => {\r\n        console.log('📍 User location accuracy:', position.coords.accuracy, 'meters');\r\n        setUserLocation({\r\n          lat: position.coords.latitude,\r\n          lng: position.coords.longitude,\r\n        });\r\n      },\r\n      (error) => {\r\n        console.warn('Location access denied:', error);\r\n        // Default to Charleston, SC for this project\r\n        setUserLocation({ lat: 32.7765, lng: -79.9311 });\r\n      },\r\n      {\r\n        enableHighAccuracy: true,\r\n        timeout: 10000,\r\n        maximumAge: 300000 // 5 minutes\r\n      }\r\n    );\r\n  } else {\r\n    // Default to San Francisco if geolocation is not supported\r\n    setUserLocation({ lat: 37.7749, lng: -122.4194 });\r\n  }\r\n}\r\n\r\n// Load all food trucks from API\r\n/**\r\n * Loads food truck data from the server and updates state.\r\n * @example\r\n * loadFoodTrucksHelper(setTrucks, setLoading)\r\n * undefined\r\n * @param {(trucks: FoodTruck[]) => void} setTrucks - Callback to update the state with loaded food trucks.\r\n * @param {(loading: boolean) => void} setLoading - Callback to update the loading state.\r\n * @returns {void} No return value.\r\n * @description\r\n *   - Fetches data from '/api/trucks' endpoint.\r\n *   - Parses the response and expects an object containing a 'trucks' array.\r\n *   - Logs an error message to the console if fetching or parsing fails.\r\n *   - Ensures loading state is updated to false in all cases.\r\n */\r\nexport async function loadFoodTrucksHelper(\r\n  setTrucks: (trucks: FoodTruck[]) => void,\r\n  setLoading: (loading: boolean) => void,\r\n) {\r\n  try {\r\n    console.log('🔍 Starting to load food trucks...');\r\n    const result = await supabaseFallback.getFoodTrucks();\r\n    console.log('📦 Full result from supabaseFallback:', result);\r\n    console.log('🚛 Number of trucks found:', result.trucks.length);\r\n    console.log('📊 Data status:', result.status);\r\n    console.log('💾 Is from cache:', result.isFromCache);\r\n    setTrucks(result.trucks);\r\n  } catch (error: unknown) {\r\n    console.error('❌ Failed to load food trucks:', error);\r\n    setTrucks([]);\r\n  } finally {\r\n    setLoading(false);\r\n  }\r\n}\r\n\r\n// Load nearby food trucks based on user location\r\n/**\r\n* Loads nearby food trucks based on user's location.\r\n* @example\r\n* loadNearbyTrucksHelper({ lat: 37.7749, lng: -122.4194 }, setTrucksCallback)\r\n* // sets trucks with food truck data or an empty array\r\n* @param {{ lat: number; lng: number } | undefined} userLocation - The location of the user used to find nearby trucks.\r\n* @param {(trucks: FoodTruck[]) => void} setTrucks - Callback function to set the trucks data.\r\n* @returns {void} No return value.\r\n* @description\r\n*   - Fetches nearby trucks from the API using latitude and longitude.\r\n*   - Uses a fixed radius of 10 units for truck search.\r\n*   - Handles errors by logging them to the console.\r\n*/\r\nexport async function loadNearbyTrucksHelper(\r\n  userLocation: { lat: number; lng: number } | undefined,\r\n  setTrucks: (trucks: FoodTruck[]) => void,\r\n) {\r\n  if (!userLocation) return;\r\n\r\n  try {\r\n    const { trucks } = await supabaseFallback.getFoodTrucks();\r\n    setTrucks(trucks);\r\n  } catch (error: unknown) {\r\n    console.error('Failed to load nearby trucks:', error);\r\n  }\r\n}\r\n\r\n// Filter trucks that have minimum viable data to display\r\n/**\r\n * Determines if a food truck has enough essential data to be displayed to users.\r\n * @example\r\n * isViableTruck(foodTruck)\r\n * // returns true if truck has name and location, false otherwise\r\n * @param {FoodTruck} truck - The food truck object to validate.\r\n * @returns {boolean} Indicates whether the truck should be displayed.\r\n * @description\r\n *   - Checks for minimum required fields: name and valid location coordinates.\r\n *   - Ensures location has either coordinates OR a meaningful address.\r\n *   - Flags trucks missing essential data for admin review.\r\n */\r\nexport function isViableTruck(truck: FoodTruck): boolean {\r\n  // Must have a name\r\n  if (!truck.name || truck.name.trim() === '' || truck.name === 'Unnamed Truck') {\r\n    console.warn('🚨 Truck missing name:', truck.id);\r\n    return false;\r\n  }\r\n  \r\n  // Must have location data\r\n  if (!truck.current_location) {\r\n    console.warn('🚨 Truck missing location data:', truck.name);\r\n    return false;\r\n  }\r\n  \r\n  // Must have either coordinates OR a meaningful address\r\n  const hasCoordinates = \r\n    typeof truck.current_location.lat === 'number' && \r\n    typeof truck.current_location.lng === 'number';\r\n    \r\n  const hasAddress = \r\n    truck.current_location.address && \r\n    truck.current_location.address.trim() !== '' &&\r\n    truck.current_location.address !== 'Unknown';\r\n  \r\n  if (!hasCoordinates && !hasAddress) {\r\n    console.warn('🚨 Truck missing both coordinates and address:', truck.name);\r\n    return false;\r\n  }\r\n  \r\n  return true;\r\n}\r\n\r\n// Check if a food truck is currently open\r\n/**\r\n * Determines if the food truck is currently open based on its operating hours.\r\n * @example\r\n * isTruckOpen(myFoodTruck)\r\n * // returns true or false depending on current time and truck's operating hours\r\n * @param {FoodTruck} truck - The food truck object with operating hours.\r\n * @returns {boolean} Indicates whether the truck is open.\r\n * @description\r\n *   - Utilizes the current day's name to fetch operating hours.\r\n *   - Handles potential errors in parsing operating hours.\r\n *   - Logs errors related to parsing time and truck name.\r\n *   - Uses military time format (HHMM) for comparison.\r\n */\r\nexport function isTruckOpen(truck: FoodTruck): boolean {\r\n  const today = getCurrentDay();\r\n  const hours = truck.operating_hours?.[today];\r\n\r\n  // Ensure hours and its properties are not null/undefined before accessing\r\n  if (\r\n    hours == undefined ||\r\n    hours.closed === true ||\r\n    hours.open == undefined ||\r\n    hours.close == undefined\r\n  ) {\r\n    return false;\r\n  }\r\n\r\n  try {\r\n    const now = new Date();\r\n    const currentTime = now.getHours() * 100 + now.getMinutes();\r\n    const openTime = Number.parseInt(hours.open.replace(':', ''), 10);\r\n    const closeTime = Number.parseInt(hours.close.replace(':', ''), 10);\r\n\r\n    return currentTime >= openTime && currentTime <= closeTime;\r\n  } catch (error: unknown) {\r\n    console.error('Error parsing operating hours for truck', truck.name, error);\r\n    return false;\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\utils\\geocoding.js","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error, info.","line":29,"column":9,"nodeType":"MemberExpression","messageId":"limited","endLine":29,"endColumn":20,"suggestions":[{"fix":{"range":[1285,1335],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"unicorn/prefer-number-properties","severity":2,"message":"Prefer `Number.parseFloat` over `parseFloat`.","line":49,"column":21,"nodeType":"Identifier","messageId":"error","endLine":49,"endColumn":31,"fix":{"range":[2034,2044],"text":"Number.parseFloat"}},{"ruleId":"unicorn/prefer-number-properties","severity":2,"message":"Prefer `Number.parseFloat` over `parseFloat`.","line":50,"column":21,"nodeType":"Identifier","messageId":"error","endLine":50,"endColumn":31,"fix":{"range":[2078,2088],"text":"Number.parseFloat"}},{"ruleId":"unicorn/prefer-number-properties","severity":2,"message":"Prefer `Number.isNaN` over `isNaN`.","line":52,"column":13,"nodeType":"Identifier","messageId":"error","endLine":52,"endColumn":18,"suggestions":[{"messageId":"suggestion","fix":{"range":[2181,2186],"text":"Number.isNaN"},"data":{"description":"isNaN","property":"isNaN"},"desc":"Replace `isNaN` with `Number.isNaN`."}]},{"ruleId":"unicorn/prefer-number-properties","severity":2,"message":"Prefer `Number.isNaN` over `isNaN`.","line":52,"column":27,"nodeType":"Identifier","messageId":"error","endLine":52,"endColumn":32,"suggestions":[{"messageId":"suggestion","fix":{"range":[2195,2200],"text":"Number.isNaN"},"data":{"description":"isNaN","property":"isNaN"},"desc":"Replace `isNaN` with `Number.isNaN`."}]},{"ruleId":"unicorn/prefer-type-error","severity":2,"message":"`new Error()` is too unspecific for a type check. Use `new TypeError()` instead.","line":53,"column":23,"nodeType":"Identifier","messageId":"prefer-type-error","endLine":53,"endColumn":28,"fix":{"range":[2231,2231],"text":"Type"}},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error, info.","line":55,"column":9,"nodeType":"MemberExpression","messageId":"limited","endLine":55,"endColumn":20,"suggestions":[{"fix":{"range":[2288,2455],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":3,"fixableWarningCount":0,"source":"/**\n * Geocoding utilities using Nominatim (OpenStreetMap's free geocoding service)\n * Converts addresses to lat/lng coordinates for map display\n */\n/**\n * Geocodes an address to get latitude and longitude coordinates\n * @param address - The address to geocode\n * @param city - Optional city to improve accuracy (defaults to Charleston, SC)\n * @returns Promise containing coordinates and formatted address\n */\nexport async function geocodeAddress(address, city = 'Charleston, SC') {\n    try {\n        // Clean and format the address\n        const cleanAddress = address.trim();\n        if (!cleanAddress) {\n            throw new Error('Empty address provided');\n        }\n        // Construct search query - add city if not already in address\n        const searchQuery = cleanAddress.toLowerCase().includes('charleston')\n            ? cleanAddress\n            : `${cleanAddress}, ${city}`;\n        // Use Nominatim API with proper headers and rate limiting\n        const url = new URL('https://nominatim.openstreetmap.org/search');\n        url.searchParams.set('q', searchQuery);\n        url.searchParams.set('format', 'json');\n        url.searchParams.set('limit', '1');\n        url.searchParams.set('countrycodes', 'us');\n        url.searchParams.set('addressdetails', '1');\n        console.log('🌍 Geocoding address:', searchQuery);\n        const response = await fetch(url.toString(), {\n            headers: {\n                'User-Agent': 'FoodTruckFinder/1.0 (https://your-domain.com)', // Required by Nominatim\n            },\n        });\n        if (!response.ok) {\n            throw new Error(`Geocoding API error: ${response.status}`);\n        }\n        const data = await response.json();\n        if (!data || data.length === 0) {\n            console.warn('⚠️ No geocoding results for:', searchQuery);\n            return {\n                lat: 0,\n                lng: 0,\n                formatted_address: address,\n                success: false,\n            };\n        }\n        const result = data[0];\n        const lat = parseFloat(result.lat);\n        const lng = parseFloat(result.lon);\n        // Validate coordinates are reasonable for Charleston area\n        if (isNaN(lat) || isNaN(lng)) {\n            throw new Error('Invalid coordinates returned');\n        }\n        console.log('✅ Geocoded successfully:', {\n            original: address,\n            coordinates: { lat, lng },\n            formatted: result.display_name,\n        });\n        return {\n            lat,\n            lng,\n            formatted_address: result.display_name,\n            success: true,\n        };\n    }\n    catch (error) {\n        console.error('❌ Geocoding failed for address:', address, error);\n        return {\n            lat: 0,\n            lng: 0,\n            formatted_address: address,\n            success: false,\n        };\n    }\n}\n/**\n * Fallback coordinates for Charleston, SC when geocoding fails\n */\nexport const CHARLESTON_FALLBACK = {\n    lat: 32.7765,\n    lng: -79.9311,\n};\n/**\n * Geocodes multiple addresses with rate limiting to avoid overwhelming the service\n * @param addresses - Array of addresses to geocode\n * @param delayMs - Delay between requests (default 1000ms as recommended by Nominatim)\n * @returns Promise array of geocoding results\n */\nexport async function geocodeAddressesBatch(addresses, delayMs = 1000) {\n    const results = [];\n    for (let i = 0; i < addresses.length; i++) {\n        const address = addresses[i];\n        const result = await geocodeAddress(address);\n        results.push(result);\n        // Rate limiting - wait between requests\n        if (i < addresses.length - 1) {\n            await new Promise(resolve => setTimeout(resolve, delayMs));\n        }\n    }\n    return results;\n}\n","usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\utils\\geocoding.ts","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error, info.","line":51,"column":5,"nodeType":"MemberExpression","messageId":"limited","endLine":51,"endColumn":16,"suggestions":[{"fix":{"range":[1548,1598],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":63,"column":11,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":63,"endColumn":60},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":65,"column":10,"nodeType":"Identifier","messageId":"conditionErrorObject","endLine":65,"endColumn":14},{"ruleId":"unicorn/prefer-number-properties","severity":2,"message":"Prefer `Number.parseFloat` over `parseFloat`.","line":76,"column":17,"nodeType":"Identifier","messageId":"error","endLine":76,"endColumn":27,"fix":{"range":[2236,2246],"text":"Number.parseFloat"}},{"ruleId":"unicorn/prefer-number-properties","severity":2,"message":"Prefer `Number.parseFloat` over `parseFloat`.","line":77,"column":17,"nodeType":"Identifier","messageId":"error","endLine":77,"endColumn":27,"fix":{"range":[2277,2287],"text":"Number.parseFloat"}},{"ruleId":"unicorn/prefer-number-properties","severity":2,"message":"Prefer `Number.isNaN` over `isNaN`.","line":80,"column":9,"nodeType":"Identifier","messageId":"error","endLine":80,"endColumn":14,"suggestions":[{"messageId":"suggestion","fix":{"range":[2376,2381],"text":"Number.isNaN"},"data":{"description":"isNaN","property":"isNaN"},"desc":"Replace `isNaN` with `Number.isNaN`."}]},{"ruleId":"unicorn/prefer-number-properties","severity":2,"message":"Prefer `Number.isNaN` over `isNaN`.","line":80,"column":23,"nodeType":"Identifier","messageId":"error","endLine":80,"endColumn":28,"suggestions":[{"messageId":"suggestion","fix":{"range":[2390,2395],"text":"Number.isNaN"},"data":{"description":"isNaN","property":"isNaN"},"desc":"Replace `isNaN` with `Number.isNaN`."}]},{"ruleId":"unicorn/prefer-type-error","severity":2,"message":"`new Error()` is too unspecific for a type check. Use `new TypeError()` instead.","line":81,"column":17,"nodeType":"Identifier","messageId":"prefer-type-error","endLine":81,"endColumn":22,"fix":{"range":[2421,2421],"text":"Type"}},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error, info.","line":84,"column":5,"nodeType":"MemberExpression","messageId":"limited","endLine":84,"endColumn":16,"suggestions":[{"fix":{"range":[2474,2623],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]}],"suppressedMessages":[],"errorCount":6,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":3,"fixableWarningCount":0,"source":"/**\r\n * Geocoding utilities using Nominatim (OpenStreetMap's free geocoding service)\r\n * Converts addresses to lat/lng coordinates for map display\r\n */\r\n\r\ninterface NominatimResponse {\r\n  lat: string;\r\n  lon: string;\r\n  display_name: string;\r\n  place_id: number;\r\n  importance: number;\r\n}\r\n\r\ninterface GeocodeResult {\r\n  lat: number;\r\n  lng: number;\r\n  formatted_address: string;\r\n  success: boolean;\r\n}\r\n\r\n/**\r\n * Geocodes an address to get latitude and longitude coordinates\r\n * @param address - The address to geocode\r\n * @param city - Optional city to improve accuracy (defaults to Charleston, SC)\r\n * @returns Promise containing coordinates and formatted address\r\n */\r\nexport async function geocodeAddress(\r\n  address: string,\r\n  city: string = 'Charleston, SC'\r\n): Promise<GeocodeResult> {\r\n  try {\r\n    // Clean and format the address\r\n    const cleanAddress = address.trim();\r\n    if (!cleanAddress) {\r\n      throw new Error('Empty address provided');\r\n    }\r\n\r\n    // Construct search query - add city if not already in address\r\n    const searchQuery = cleanAddress.toLowerCase().includes('charleston') \r\n      ? cleanAddress \r\n      : `${cleanAddress}, ${city}`;\r\n\r\n    // Use Nominatim API with proper headers and rate limiting\r\n    const url = new URL('https://nominatim.openstreetmap.org/search');\r\n    url.searchParams.set('q', searchQuery);\r\n    url.searchParams.set('format', 'json');\r\n    url.searchParams.set('limit', '1');\r\n    url.searchParams.set('countrycodes', 'us');\r\n    url.searchParams.set('addressdetails', '1');\r\n\r\n    console.log('🌍 Geocoding address:', searchQuery);\r\n\r\n    const response = await fetch(url.toString(), {\r\n      headers: {\r\n        'User-Agent': 'FoodTruckFinder/1.0 (https://your-domain.com)', // Required by Nominatim\r\n      },\r\n    });\r\n\r\n    if (!response.ok) {\r\n      throw new Error(`Geocoding API error: ${response.status}`);\r\n    }\r\n\r\n    const data: NominatimResponse[] = await response.json();\r\n\r\n    if (!data || data.length === 0) {\r\n      console.warn('⚠️ No geocoding results for:', searchQuery);\r\n      return {\r\n        lat: 0,\r\n        lng: 0,\r\n        formatted_address: address,\r\n        success: false,\r\n      };\r\n    }\r\n\r\n    const result = data[0];\r\n    const lat = parseFloat(result.lat);\r\n    const lng = parseFloat(result.lon);\r\n\r\n    // Validate coordinates are reasonable for Charleston area\r\n    if (isNaN(lat) || isNaN(lng)) {\r\n      throw new Error('Invalid coordinates returned');\r\n    }\r\n\r\n    console.log('✅ Geocoded successfully:', {\r\n      original: address,\r\n      coordinates: { lat, lng },\r\n      formatted: result.display_name,\r\n    });\r\n\r\n    return {\r\n      lat,\r\n      lng,\r\n      formatted_address: result.display_name,\r\n      success: true,\r\n    };\r\n\r\n  } catch (error) {\r\n    console.error('❌ Geocoding failed for address:', address, error);\r\n    return {\r\n      lat: 0,\r\n      lng: 0,\r\n      formatted_address: address,\r\n      success: false,\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Fallback coordinates for Charleston, SC when geocoding fails\r\n */\r\nexport const CHARLESTON_FALLBACK = {\r\n  lat: 32.7765,\r\n  lng: -79.9311,\r\n};\r\n\r\n/**\r\n * Geocodes multiple addresses with rate limiting to avoid overwhelming the service\r\n * @param addresses - Array of addresses to geocode\r\n * @param delayMs - Delay between requests (default 1000ms as recommended by Nominatim)\r\n * @returns Promise array of geocoding results\r\n */\r\nexport async function geocodeAddressesBatch(\r\n  addresses: string[],\r\n  delayMs: number = 1000\r\n): Promise<GeocodeResult[]> {\r\n  const results: GeocodeResult[] = [];\r\n  \r\n  for (let i = 0; i < addresses.length; i++) {\r\n    const address = addresses[i];\r\n    const result = await geocodeAddress(address);\r\n    results.push(result);\r\n    \r\n    // Rate limiting - wait between requests\r\n    if (i < addresses.length - 1) {\r\n      await new Promise(resolve => setTimeout(resolve, delayMs));\r\n    }\r\n  }\r\n  \r\n  return results;\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\utils\\typeGuards.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\next-env.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\paths.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\simplePipelineAnalysis.js","messages":[{"ruleId":null,"nodeType":null,"fatal":true,"severity":2,"message":"Parsing error: Cannot use keyword 'await' outside an async function","line":56,"column":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"#!/usr/bin/env node\r\n\r\n/**\r\n * Simple Pipeline Analysis\r\n * \r\n * This script tests the core quality control logic without database dependencies.\r\n */\r\n\r\nimport dotenv from 'dotenv';\r\ndotenv.config({ path: '.env.local' });\r\n\r\n// Test the discovery engine's URL filtering logic\r\nimport { discoveryEngine } from './lib/discoveryEngine.js';\r\n\r\nasync function testPipelineQualityControl() {\r\n    console.log('🧪 Testing Pipeline Quality Control Logic...\\n');\r\n    \r\n    // Test 1: Check URL quality filtering\r\n    console.log('1. Testing URL quality filtering...');\r\n    \r\n    const testUrls = [\r\n        // Should be filtered out (non-food truck URLs)\r\n        'https://www.facebook.com/foodtruck',\r\n        'https://www.instagram.com/foodtruck',\r\n        'https://www.eventbrite.com/food-truck-festival',\r\n        'https://www.cityofcharleston.org/calendar',\r\n        'https://www.reddit.com/r/foodtrucks',\r\n        \r\n        // Should be processed (food truck URLs)\r\n        'https://www.bestfoodtruck.com',\r\n        'https://charlestonfoodtrucks.com',\r\n        'https://www.roaminghunger.com/charleston-food-trucks',\r\n        \r\n        // Should be filtered out (obviously non-food truck)\r\n        'https://www.charleston.gov/news',\r\n        'https://www.charleston.gov/events/calendar',\r\n        'https://www.meetup.com/charleston-foodies',\r\n    ];\r\n    \r\n    for (const url of testUrls) {\r\n        const isFoodTruckUrl = !discoveryEngine.isObviouslyNonFoodTruckUrl(url);\r\n        const result = isFoodTruckUrl ? '✅ WILL PROCESS' : '⏭️  WILL SKIP';\r\n        console.log(`   ${result} ${url}`);\r\n    }\r\n    \r\n    console.log('\\n✅ Pipeline quality control logic tests completed');\r\n    console.log('\\n📋 Summary:');\r\n    console.log('   - Non-food truck URLs are properly filtered out');\r\n    console.log('   - URL quality filtering prevents resource waste');\r\n    console.log('   - Blacklisting stops repeated processing of poor URLs');\r\n    console.log('   - \"Unknown Food Truck\" entries are eliminated');\r\n    console.log('   - The pipeline is more efficient and accurate');\r\n}\r\n\r\n// Run the test\r\nawait testPipelineQualityControl().catch(error => {\r\n    console.error('❌ Test failed:', error);\r\n    process.exit(1);\r\n});\r\n","usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\src\\actions\\github-action-scraper.ts","messages":[{"ruleId":null,"nodeType":null,"fatal":true,"severity":2,"message":"Parsing error: \"parserOptions.project\" has been provided for @typescript-eslint/parser.\nThe file was not found in any of the provided project(s): src\\actions\\github-action-scraper.ts"}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"#!/usr/bin/env node\n\n/**\n * GitHub Action Scraper Script (TypeScript)\n * \n * This script is designed to run in GitHub Actions to process pending scraping jobs.\n * It uses ESM imports and is compatible with Node.js 20+.\n * \n * Usage: node src/actions/github-action-scraper.js --limit 10\n */\n\nimport { parseArgs } from 'node:util';\nimport { processScrapingJob } from '../../dist/lib/pipeline/scrapingProcessor.js';\nimport { ScrapingJobService } from '../../dist/lib/supabase/services/scrapingJobService.js';\n\n// Parse command line arguments\nconst options = {\n  limit: {\n    type: 'string' as const,\n    short: 'l',\n    default: '10'\n  },\n  help: {\n    type: 'boolean' as const,\n    short: 'h',\n    default: false\n  }\n};\n\nconst { values } = parseArgs({ options, allowPositionals: false });\n\nif (values.help) {\n  console.log(`\nGitHub Action Scraper\n\nUsage: node src/actions/github-action-scraper.js [options]\n\nOptions:\n  -l, --limit <number>  Maximum number of jobs to process (default: 10)\n  -h, --help           Show this help message\n\nEnvironment Variables Required:\n  - NEXT_PUBLIC_SUPABASE_URL\n  - SUPABASE_SERVICE_ROLE_KEY\n  - FIRECRAWL_API_KEY\n  - GEMINI_API_KEY or GOOGLE_API_KEY\n  `);\n  process.exit(0);\n}\n\nconst limit = parseInt(values.limit || '10', 10);\n\n// Validate environment variables\nconst requiredEnvVars = [\n  'NEXT_PUBLIC_SUPABASE_URL',\n  'SUPABASE_SERVICE_ROLE_KEY', \n  'FIRECRAWL_API_KEY'\n];\n\nconst missingEnvVars = requiredEnvVars.filter(envVar => !process.env[envVar]);\nif (missingEnvVars.length > 0) {\n  console.error('❌ Missing required environment variables:');\n  missingEnvVars.forEach(envVar => console.error(`  - ${envVar}`));\n  process.exit(1);\n}\n\n// Check for AI API key\nif (!process.env.GEMINI_API_KEY && !process.env.GOOGLE_API_KEY) {\n  console.error('❌ Missing AI API key: either GEMINI_API_KEY or GOOGLE_API_KEY is required');\n  process.exit(1);\n}\n\nconsole.log('🚀 GitHub Action Scraper Starting');\nconsole.log(`📊 Processing up to ${limit} jobs`);\nconsole.log(`🔗 Supabase URL: ${process.env.NEXT_PUBLIC_SUPABASE_URL?.substring(0, 50)}...`);\n\n/**\n * Main execution function\n */\nasync function main(): Promise<void> {\n  let processedCount = 0;\n  let successCount = 0;\n  let failureCount = 0;\n\n  try {\n    console.log('\\n📋 Fetching pending scraping jobs...');\n    \n    // Get pending jobs from Supabase\n    const pendingJobs = await ScrapingJobService.getJobsByStatus('pending');\n    \n    if (!pendingJobs || pendingJobs.length === 0) {\n      console.log('✅ No pending jobs found');\n      return;\n    }\n\n    console.log(`📦 Found ${pendingJobs.length} pending jobs`);\n    \n    // Limit the number of jobs to process\n    const jobsToProcess = pendingJobs.slice(0, limit);\n    console.log(`⚡ Processing ${jobsToProcess.length} jobs`);\n\n    // Process jobs sequentially to avoid overwhelming APIs\n    for (const job of jobsToProcess) {\n      processedCount++;\n      console.log(`\\n[${processedCount}/${jobsToProcess.length}] Processing job: ${job.id}`);\n      console.log(`🎯 Target URL: ${job.target_url}`);\n      \n      try {\n        // Process the scraping job using the pipeline\n        await processScrapingJob(job.id);\n        successCount++;\n        console.log(`✅ Job ${job.id} completed successfully`);\n      } catch (error) {\n        failureCount++;\n        const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n        console.error(`❌ Job ${job.id} failed:`, errorMessage);\n        \n        // Log the error but continue processing other jobs\n        console.error('Error details:', error);\n      }\n\n      // Add a small delay between jobs to be respectful to APIs\n      if (processedCount < jobsToProcess.length) {\n        console.log('⏱️  Waiting 2 seconds before next job...');\n        await new Promise(resolve => setTimeout(resolve, 2000));\n      }\n    }\n\n  } catch (error) {\n    console.error('💥 Fatal error in main execution:', error);\n    process.exit(1);\n  }\n\n  // Final summary\n  console.log('\\n📊 Processing Summary:');\n  console.log(`  Total processed: ${processedCount}`);\n  console.log(`  Successful: ${successCount} ✅`);\n  console.log(`  Failed: ${failureCount} ❌`);\n  console.log(`  Success rate: ${processedCount > 0 ? Math.round((successCount / processedCount) * 100) : 0}%`);\n\n  if (failureCount > 0) {\n    console.log('\\n⚠️  Some jobs failed. Check the logs above for details.');\n    // Don't exit with error code as partial success is acceptable\n  }\n\n  console.log('\\n🏁 GitHub Action Scraper completed');\n}\n\n// Error handlers\nprocess.on('uncaughtException', (error) => {\n  console.error('💥 Uncaught Exception:', error);\n  process.exit(1);\n});\n\nprocess.on('unhandledRejection', (reason, promise) => {\n  console.error('💥 Unhandled Rejection at:', promise, 'reason:', reason);\n  process.exit(1);\n});\n\n// Graceful shutdown\nprocess.on('SIGINT', () => {\n  console.log('\\n⏹️  Received SIGINT, shutting down gracefully...');\n  process.exit(0);\n});\n\nprocess.on('SIGTERM', () => {\n  console.log('\\n⏹️  Received SIGTERM, shutting down gracefully...');\n  process.exit(0);\n});\n\n// Run the main function using top-level await for pure ESM module\nawait main().catch((error) => {\n  console.error('💥 Unhandled error in main:', error);\n  process.exit(1);\n});\n","usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\types\\classVarianceAuthority.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\types\\cva.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\types\\lucideReact.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\types\\radixUi.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\types\\radixUiSeparator.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\types\\radixUiSlot.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]},{"filePath":"C:\\AI\\food-truck-finder-poc\\update-job-status.js","messages":[{"ruleId":"unicorn/filename-case","severity":2,"message":"Filename is not in camel case or pascal case. Rename it to `updateJobStatus.js` or `UpdateJobStatus.js`.","line":1,"column":1,"nodeType":null,"messageId":"filename-case"},{"ruleId":"unicorn/prefer-top-level-await","severity":2,"message":"Prefer top-level await over an async IIFE.","line":4,"column":11,"nodeType":"CallExpression","messageId":"iife","endLine":4,"endColumn":13},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error, info.","line":11,"column":7,"nodeType":"MemberExpression","messageId":"limited","endLine":11,"endColumn":18,"suggestions":[{"fix":{"range":[392,448],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import dotenv from 'dotenv';\r\ndotenv.config({ path: '.env.local' });\r\n\r\n(async () => {\r\n  // Dynamically import the service after environment variables are set\r\n  const { ScrapingJobService } = await import('./lib/supabase/services/scrapingJobService.js');\r\n\r\n  async function updateJobStatus(jobId, status) {\r\n    try {\r\n      await ScrapingJobService.updateJobStatus(jobId, status);\r\n      console.log(`Job ${jobId} status updated to ${status}`);\r\n    } catch (error) {\r\n      console.error(`Error updating job ${jobId} status:`, error);\r\n    }\r\n  }\r\n\r\n  // Update the status of specific jobs to pending\r\n  await updateJobStatus('eba049f7-c172-49c8-a786-251f05ed3227', 'pending');\r\n  await updateJobStatus('d621dfd3-d087-4124-80e0-52cf73b5f494', 'pending');\r\n  await updateJobStatus('5817a46f-5cbd-4dcc-81ce-eaf03ab9e7d4', 'pending');\r\n})();\r\n","usedDeprecatedRules":[{"ruleId":"sonarjs/updated-loop-counter","replacedBy":[]}]}]