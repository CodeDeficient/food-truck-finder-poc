[{"filePath":"C:\\AI\\food-truck-finder-poc\\app\\access-denied\\page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\app\\admin\\analytics\\page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\app\\admin\\auto-scraping\\page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\app\\admin\\data-cleanup\\page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\app\\admin\\data-quality\\page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\app\\admin\\events\\page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\app\\admin\\food-trucks\\[id]\\page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\app\\admin\\food-trucks\\page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\app\\admin\\layout.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\app\\admin\\monitoring\\page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\app\\admin\\page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\app\\admin\\pipeline\\page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\app\\admin\\test-pipeline\\page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\app\\admin\\users\\page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\app\\api\\admin\\automated-cleanup\\route.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected any value in conditional. An explicit comparison or type conversion is required.","line":27,"column":10,"nodeType":"Identifier","messageId":"conditionErrorAny","endLine":27,"endColumn":19,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[928,937],"text":"(Boolean(hasAccess))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected any value in conditional. An explicit comparison or type conversion is required.","line":68,"column":10,"nodeType":"Identifier","messageId":"conditionErrorAny","endLine":68,"endColumn":19,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[2109,2118],"text":"(Boolean(hasAccess))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]}],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an error typed value.","line":26,"column":11,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":26,"endColumn":55,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a(n) `error` type typed value.","line":26,"column":29,"nodeType":"Identifier","messageId":"unsafeCall","endLine":26,"endColumn":46,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an error typed value.","line":67,"column":11,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":67,"endColumn":55,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a(n) `error` type typed value.","line":67,"column":29,"nodeType":"Identifier","messageId":"unsafeCall","endLine":67,"endColumn":46,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { NextRequest, NextResponse } from 'next/server';\nimport {\n  handlePostRequest,\n  handleGetStatus,\n  handleGetSchedules,\n  handleGetHistory,\n  handleGetPreview,\n  handleGetDefault,\n} from '@/lib/api/admin/automated-cleanup/handlers';\nimport { verifyAdminAccess } from '@/lib/auth/authHelpers';\nimport { RequestBody } from '@/lib/api/admin/automated-cleanup/types';\n\n/**\n * SOTA Automated Data Cleanup API\n *\n * Provides scheduled and on-demand data cleanup operations\n * with comprehensive monitoring and reporting capabilities\n *\n * GET /api/admin/automated-cleanup - Get cleanup status and schedule\n * POST /api/admin/automated-cleanup - Run cleanup operations\n */\n\nexport async function GET(request: NextRequest): Promise<NextResponse> {\n  try {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-call\n    const hasAccess = await verifyAdminAccess(request);\n    if (!hasAccess) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });\n    }\n\n    const { searchParams } = new URL(request.url);\n    const action = searchParams.get('action');\n\n    switch (action) {\n      case 'status': {\n        return await handleGetStatus();\n      }\n      case 'schedules': {\n        return await handleGetSchedules();\n      }\n      case 'history': {\n        return await handleGetHistory(searchParams);\n      }\n      case 'preview': {\n        return await handleGetPreview(searchParams);\n      }\n      default: {\n        return await handleGetDefault();\n      }\n    }\n  } catch (error: unknown) {\n    console.error('Automated cleanup GET error:', error);\n    return NextResponse.json(\n      {\n        success: false,\n        error: 'Failed to process cleanup request',\n        details: error instanceof Error ? error.message : String(error),\n      },\n      { status: 500 },\n    );\n  }\n}\n\nexport async function POST(request: NextRequest): Promise<NextResponse> {\n  try {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-call\n    const hasAccess = await verifyAdminAccess(request);\n    if (!hasAccess) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });\n    }\n\n    const rawBody: unknown = await request.json();\n\n    // Type guard for RequestBody\n    function isRequestBody(obj: unknown): obj is RequestBody {\n      return (\n        typeof obj === 'object' &&\n        obj !== null &&\n        'action' in obj &&\n        typeof (obj as RequestBody).action === 'string'\n      );\n    }\n\n    // Validate rawBody against RequestBody type\n    if (!isRequestBody(rawBody)) {\n      return NextResponse.json(\n        { success: false, error: 'Invalid request body: does not conform to RequestBody type' },\n        { status: 400 },\n      );\n    }\n\n    const body: RequestBody = rawBody;\n\n    return await handlePostRequest(body);\n  } catch (error: unknown) {\n    console.error('Automated cleanup POST error:', error);\n    return NextResponse.json(\n      {\n        success: false,\n        error: 'Failed to process cleanup request',\n        details: error instanceof Error ? error.message : String(error),\n      },\n      { status: 500 },\n    );\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\app\\api\\admin\\cron-status\\route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\app\\api\\admin\\data-cleanup\\route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\app\\api\\admin\\data-quality\\route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\app\\api\\admin\\oauth-status\\route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\app\\api\\admin\\realtime-events\\route.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected any value in conditional. An explicit comparison or type conversion is required.","line":11,"column":8,"nodeType":"Identifier","messageId":"conditionErrorAny","endLine":11,"endColumn":17,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[440,449],"text":"(Boolean(hasAccess))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected any value in conditional. An explicit comparison or type conversion is required.","line":36,"column":8,"nodeType":"Identifier","messageId":"conditionErrorAny","endLine":36,"endColumn":17,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[1189,1198],"text":"(Boolean(hasAccess))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]}],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an error typed value.","line":10,"column":9,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":10,"endColumn":53,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a(n) `error` type typed value.","line":10,"column":27,"nodeType":"Identifier","messageId":"unsafeCall","endLine":10,"endColumn":44,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an error typed value.","line":35,"column":9,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":35,"endColumn":53,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a(n) `error` type typed value.","line":35,"column":27,"nodeType":"Identifier","messageId":"unsafeCall","endLine":35,"endColumn":44,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { NextRequest } from 'next/server';\nimport {\n  handleGetRequest,\n  handlePostRequest,\n} from '@/lib/api/admin/realtime-events/handlers';\nimport { verifyAdminAccess } from '@/lib/auth/authHelpers';\n\nexport async function GET(request: NextRequest): Promise<Response> {\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-call\n  const hasAccess = await verifyAdminAccess(request);\n  if (!hasAccess) {\n    return new Response('Unauthorized', { status: 401 });\n  }\n\n  try {\n    return handleGetRequest(request);\n  } catch (error: unknown) {\n    console.error('Realtime events GET error:', error);\n    return new Response(\n      JSON.stringify({\n        success: false,\n        error: 'Internal server error',\n        details: error instanceof Error ? error.message : 'Unknown error',\n      }),\n      {\n        status: 500,\n        headers: { 'Content-Type': 'application/json' },\n      },\n    );\n  }\n}\n\nexport async function POST(request: NextRequest): Promise<Response> {\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-call\n  const hasAccess = await verifyAdminAccess(request);\n  if (!hasAccess) {\n    return new Response('Unauthorized', { status: 401 });\n  }\n\n  try {\n    return await handlePostRequest(request);\n  } catch (error: unknown) {\n    console.error('Realtime events POST error:', error);\n    return new Response(\n      JSON.stringify({\n        success: false,\n        error: 'Internal server error',\n        details: error instanceof Error ? error.message : 'Unknown error',\n      }),\n      {\n        status: 500,\n        headers: { 'Content-Type': 'application/json' },\n      },\n    );\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\app\\api\\admin\\scraping-metrics\\route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\app\\api\\analytics\\web-vitals\\route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\app\\api\\auto-scrape-initiate\\route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\app\\api\\autonomous-discovery\\route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\app\\api\\cron\\auto-scrape\\route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\app\\api\\cron\\quality-check\\route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\app\\api\\dashboard\\route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\app\\api\\enhanced-pipeline\\route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\app\\api\\firecrawl\\route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\app\\api\\gemini\\route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\app\\api\\monitoring\\api-usage\\route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\app\\api\\pipeline\\route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\app\\api\\scheduler\\route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\app\\api\\scrape\\route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\app\\api\\search\\route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\app\\api\\tavily\\route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\app\\api\\test-integration\\route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\app\\api\\test-pipeline-run\\route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\app\\api\\trucks\\[id]\\route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\app\\api\\trucks\\route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\app\\auth\\AuthProvider.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\app\\auth\\callback\\route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\app\\layout.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\app\\loading.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\app\\login\\page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\app\\middleware.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\app\\page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\app\\trucks\\[id]\\page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\FoodTruckInfoCard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\ModeToggle.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\SearchFilters.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\ThemeProvider.tsx","messages":[],"suppressedMessages":[{"ruleId":"sonarjs/different-types-comparison","severity":2,"message":"Remove this \"===\" check; it will always be false. Did you mean to use \"==\"?","line":42,"column":15,"nodeType":null,"endLine":42,"endColumn":18,"suggestions":[{"desc":"Replace \"===\" with \"==\"","fix":{"range":[1583,1586],"text":"=="}}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\TruckCard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\WebVitalsReporter.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\admin\\AdminNavLinks.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\admin\\DataCleanupDashboard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\admin\\RealtimeStatusIndicator.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\admin\\UserMenu.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\admin\\cleanup\\CleanupGuide.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\admin\\cleanup\\CleanupHeader.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\admin\\cleanup\\CleanupOperationDetails.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\admin\\cleanup\\CleanupPreview.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\admin\\cleanup\\CleanupResults.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\admin\\cleanup\\CleanupSummaryCards.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\admin\\cleanup\\OperationSelector.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\admin\\dashboard\\DataQualityScoreCard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\admin\\dashboard\\PipelineStatusCard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\admin\\dashboard\\QualityDistributionCard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\admin\\dashboard\\RecentErrorsCard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\admin\\dashboard\\TotalFoodTrucksCard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\admin\\dashboard\\TrucksPage.tsx","messages":[{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an error typed value.","line":31,"column":45,"nodeType":"MemberExpression","messageId":"anyAssignment","endLine":31,"endColumn":53},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .id on an `error` typed value.","line":31,"column":51,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":31,"endColumn":53},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an error typed value.","line":31,"column":62,"nodeType":"Identifier","messageId":"anyAssignment","endLine":31,"endColumn":67}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useEffect, useState } from 'react';\nimport { Truck } from '@/lib/types'; // Import from actual types file\nimport TruckCard from '@/components/ui/TruckCard';\n\n/**\n* Loads and displays a list of trucks on the dashboard.\n* @example\n* TrucksPage()\n* Returns a container with truck cards or a loading message.\n* @returns {JSX.Element} A container with truck cards or a loading message.\n* @description\n*   - Uses temporary truck data, which should be replaced with real truck loading logic.\n*   - Employs useState to manage the array of trucks.\n*   - Displays 'Loading trucks...' message when truck data is unavailable.\n*/\nconst TrucksPage = () => {\n  const [trucks, setTrucks] = useState<Truck[]>([]);\n\n  useEffect(() => {\n    // Placeholder: Integrate actual truck loading logic here\n    setTrucks([\n      // Temporary data - replace with real query\n      { id: \"1\", name: \"Temp Truck 1\", cuisine_type: [\"American\"], price_range: \"$\", data_quality_score: 0, verification_status: \"pending\", source_urls: [], last_scraped_at: \"\", current_location: { lat: 0, lng: 0, address: \"\", timestamp: \"\" }, operating_hours: { monday: { closed: true }, tuesday: { closed: true }, wednesday: { closed: true }, thursday: { closed: true }, friday: { closed: true }, saturday: { closed: true }, sunday: { closed: true } }, menu: [], contact_info: {}, social_media: {}, created_at: \"\", updated_at: \"\" } as Truck,\n      { id: \"2\", name: \"Temp Truck 2\", cuisine_type: [\"Mexican\"], price_range: \"$\", data_quality_score: 0, verification_status: \"pending\", source_urls: [], last_scraped_at: \"\", current_location: { lat: 0, lng: 0, address: \"\", timestamp: \"\" }, operating_hours: { monday: { closed: true }, tuesday: { closed: true }, wednesday: { closed: true }, thursday: { closed: true }, friday: { closed: true }, saturday: { closed: true }, sunday: { closed: true } }, menu: [], contact_info: {}, social_media: {}, created_at: \"\", updated_at: \"\" } as Truck\n    ]);\n  }, []);\n\n  return (\n    <div className=\"trucks-container\">\n      {trucks.length > 0 ? (\n        trucks.map(truck => <TruckCard key={truck.id} truck={truck} />)\n      ) : (\n        <p>Loading trucks...</p>\n      )}\n    </div>\n  );\n}\n\nexport default TrucksPage;\n","usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\admin\\food-trucks\\detail\\BasicInfoCard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\admin\\food-trucks\\detail\\DataQualityCard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\admin\\food-trucks\\detail\\LocationInfoCard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\admin\\food-trucks\\detail\\OperatingHoursCard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\admin\\food-trucks\\detail\\QualityMetricsGrid.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\admin\\food-trucks\\detail\\QualityScoreMetric.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\admin\\food-trucks\\detail\\RatingsReviewsCard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\admin\\food-trucks\\detail\\TruckDetailHeader.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\admin\\food-trucks\\detail\\TruckNotFound.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\admin\\pipeline\\FailedProcessingQueueTable.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\admin\\pipeline\\PipelineStatisticsCards.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\admin\\pipeline\\RecentScrapingJobsTable.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\admin\\pipeline\\ScrapingJobRow.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\admin\\pipeline\\ScrapingJobsTableContent.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\admin\\realtime\\AlertListDisplay.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\admin\\realtime\\AlertToggleButton.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\admin\\realtime\\ConnectionStatusHeader.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\admin\\realtime\\EventControls.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\admin\\realtime\\EventSubscriptionManager.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'React' is defined but never used.","line":1,"column":8,"nodeType":null,"messageId":"unusedVar","endLine":1,"endColumn":13},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an error typed value.","line":18,"column":11,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":25,"endColumn":7},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a(n) `error` type typed value.","line":18,"column":26,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":18,"endColumn":58},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .subscribe on an `error` typed value.","line":18,"column":49,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":18,"endColumn":58},{"ruleId":"unicorn/no-null","severity":1,"message":"Use `undefined` instead of `null`.","line":24,"column":62,"nodeType":"Literal","messageId":"error","endLine":24,"endColumn":66,"suggestions":[{"messageId":"replace","fix":{"range":[1046,1050],"text":"undefined"},"data":{},"desc":"Replace `null` with `undefined`."}]},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a(n) `error` type typed value.","line":27,"column":18,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":27,"endColumn":42},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .unsubscribe on an `error` typed value.","line":27,"column":31,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":27,"endColumn":42}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useEffect } from 'react';\nimport { SupabaseRealtimeClient } from '@/lib/supabase'; \nimport { PipelineEvent } from '@/lib/types';\n\n/**\n * Manages event subscriptions for pipeline events using Supabase.\n * @example\n * EventSubscriptionManager()\n * null\n * @returns {null} Returns null as it serves purely for side-effects of subscription management.\n * @description\n *   - Utilizes the Supabase Realtime Client to subscribe and process \"pipeline-events\".\n *   - Includes an effect cleanup to unsubscribe from events when the component unmounts.\n *   - Current implementation logs events to the console as placeholders.\n */\nfunction EventSubscriptionManager() {\n  useEffect(() => {\n    const subscription = SupabaseRealtimeClient.subscribe('pipeline-events', (_event: PipelineEvent) => {\n      /**\n       * This is a placeholder for the complete event handling logic\n       * Remove the following console.log statements and add proper event processing\n       **/ \n       \n      console.info(`Received event: ${JSON.stringify(_event, null, 2)}`);\n    });\n\n    return () => subscription.unsubscribe() as void;\n  }, []);\n}\n\nexport default EventSubscriptionManager;\n","usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\admin\\realtime\\RealtimeStatusDisplay.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\admin\\realtime\\ScrapingJobsStatus.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\admin\\realtime\\StatusHelpers.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\admin\\realtime\\SystemAlertItem.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\admin\\realtime\\SystemAlerts.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\admin\\realtime\\SystemMetricsGrid.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\admin\\realtime\\SystemStatusIndicators.tsx","messages":[{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an error typed value.","line":26,"column":11,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":43,"endColumn":7},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a(n) `error` type typed value.","line":26,"column":26,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":26,"endColumn":58},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .subscribe on an `error` typed value.","line":26,"column":49,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":26,"endColumn":58},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a(n) `error` type typed value.","line":45,"column":18,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":45,"endColumn":42},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .unsubscribe on an `error` typed value.","line":45,"column":31,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":45,"endColumn":42}],"suppressedMessages":[{"ruleId":"sonarjs/different-types-comparison","severity":2,"message":"Remove this \"!==\" check; it will always be true. Did you mean to use \"!=\"?","line":32,"column":76,"nodeType":null,"endLine":32,"endColumn":79,"suggestions":[{"desc":"Replace \"!==\" with \"!=\"","fix":{"range":[1383,1386],"text":"!="}}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":5,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useEffect, useState } from 'react';\nimport { SupabaseRealtimeClient } from '@/lib/supabase'; \n\ninterface SystemStatusResponse {\n  status: string;\n  data: {\n    status: string;\n  };\n}\n\n/**\n* Represents system status indicators in real-time\n* @example\n* SystemStatusIndicators()\n* <div><h3>Current System Status:</h3><span>ONLINE</span></div>\n* @returns {JSX.Element} A JSX element displaying the current system status.\n* @description\n*   - Utilizes Supabase Realtime Client for subscribing to system status updates.\n*   - Updates the display with the latest system status retrieved from a realtime database.\n*   - Handles subscription clean-up on component unmount to avoid memory leaks.\n*/\nfunction SystemStatusIndicators() {\n  const [systemStatus, setSystemStatus] = useState('UNKNOWN');\n\n  useEffect(() => {\n    const subscription = SupabaseRealtimeClient.subscribe('system-status', (response: unknown) => {\n      if (typeof response === 'object' && response !== null && 'status' in response) {\n        const typedResponse = response as SystemStatusResponse;\n        const responseStatus = typedResponse.status; // Extract status to a variable\n\n        if (typeof responseStatus === 'string' && responseStatus === \"success\") { // eslint-disable-next-line sonarjs/different-types-comparison\n          if (typeof typedResponse.data === 'object' && typedResponse.data !== null && 'status' in typedResponse.data) {\n            setSystemStatus(typedResponse.data.status);\n          } else {\n            console.error(\"Invalid data structure in system status response\");\n          }\n        } else {\n          console.error(\"Failed to retrieve system status or invalid response format\");\n        }\n      } else {\n        console.error(\"Failed to retrieve system status or invalid response format\");\n      }\n    });\n\n    return () => subscription.unsubscribe() as void;\n  }, []);\n\n  return (\n    <div>\n      <h3>Current System Status:</h3>\n      <span>{systemStatus}</span>\n    </div>\n  );\n}\n\nexport default SystemStatusIndicators;\n","usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\admin\\realtime\\useSystemAlertsLogic.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\admin\\realtime\\useSystemMetrics.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\admin\\users\\UserTable.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\home\\AppHeader.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\home\\LoadingScreen.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\home\\MainContent.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\home\\MapSection.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\home\\TruckListHeader.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\home\\TruckListSection.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\login\\EmailFormFields.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\map\\DynamicMap.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\map\\MapContent.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\map\\MapLoadingFallback.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\map\\MapViewUpdater.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\map\\TruckMarkers.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\map\\UserLocationMarker.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\map\\mapHelpers.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\monitoring\\ApiMonitoringDashboard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\monitoring\\FeatureCard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\monitoring\\FeatureList.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\monitoring\\FeatureOverviewCards.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\monitoring\\FeatureOverviewContent.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\monitoring\\MonitoringFeaturesCard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\monitoring\\MonitoringFeaturesContent.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\monitoring\\MonitoringPageHeader.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\monitoring\\TechnicalDetailsCard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\search\\AdvancedFilters.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\search\\CuisineTypesSection.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\search\\DistanceSliderSection.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\search\\FilterToggleButton.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\search\\MainSearchSection.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\search\\QuickFiltersSection.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\search\\SearchFilterContent.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\search\\SearchInputWithIcon.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\test-pipeline\\ErrorDisplay.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\test-pipeline\\StageResultCard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\test-pipeline\\StageResultDetails.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\test-pipeline\\TestPipelineForm.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\test-pipeline\\TestPipelineSubmitHandler.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\test-pipeline\\TestResultsDisplay.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\trucks\\MenuSection.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\trucks\\OperatingHoursSection.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\trucks\\RatingSection.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\trucks\\TruckAccordionItem.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\trucks\\TruckBasicInfo.tsx","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":43,"column":10,"nodeType":"MemberExpression","messageId":"conditionErrorObject","endLine":43,"endColumn":28}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from 'react';\r\nimport { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';\r\nimport { Badge } from '@/components/ui/badge';\r\nimport type { FoodTruck } from '@/lib/supabase';\r\n\r\ninterface TruckBasicInfoProps {\r\n  readonly truck: FoodTruck;\r\n}\r\n\r\n/**\r\n* Renders basic information about a food truck within a styled card component.\r\n* @example\r\n* TruckBasicInfo({ truck: { name: \"Tasty Truck\", description: \"Best burgers in town\", cuisine_type: \"American\", price_range: \"$$$\" } })\r\n* // Will return a React component displaying the food truck's name, description, cuisine type, and price range in a formatted card layout.\r\n* @param {object} truck - An object containing food truck information, including name, description, cuisine type, and price range.\r\n* @returns {JSX.Element} A styled React component displaying the provided food truck information.\r\n* @description\r\n*   - Applies styling for both light and dark mode themes.\r\n*   - Only displays fields if corresponding values are provided within the truck object.\r\n*/\r\nexport function TruckBasicInfo({ truck }: Readonly<TruckBasicInfoProps>) {\r\n  return (\r\n    <Card className=\"dark:bg-slate-800 dark:border-slate-700\">\r\n      <CardHeader>\r\n        <CardTitle className=\"dark:text-gray-100\">About</CardTitle>\r\n        <CardDescription className=\"dark:text-gray-400\">Food truck information</CardDescription>\r\n      </CardHeader>\r\n      <CardContent className=\"space-y-4\">\r\n        <div>\r\n          <label className=\"text-sm font-medium text-gray-500 dark:text-gray-400\">Name</label>\r\n          <p className=\"text-lg font-semibold dark:text-gray-100\">{truck.name}</p>\r\n        </div>\r\n\r\n        {truck.description != undefined && (\r\n          <div>\r\n            <label className=\"text-sm font-medium text-gray-500 dark:text-gray-400\">\r\n              Description\r\n            </label>\r\n            <p className=\"text-gray-900 dark:text-gray-200\">{truck.description}</p>\r\n          </div>\r\n        )}\r\n\r\n        {truck.cuisine_type && (\r\n          <div>\r\n            <label className=\"text-sm font-medium text-gray-500 dark:text-gray-400\">\r\n              Cuisine Type\r\n            </label>\r\n            <p className=\"text-gray-900 dark:text-gray-200\">{truck.cuisine_type}</p>\r\n          </div>\r\n        )}\r\n\r\n        {truck.price_range && (\r\n          <div>\r\n            <label className=\"text-sm font-medium text-gray-500 dark:text-gray-400\">\r\n              Price Range\r\n            </label>\r\n            <Badge variant=\"outline\" className=\"ml-2\">\r\n              {truck.price_range}\r\n            </Badge>\r\n          </div>\r\n        )}\r\n      </CardContent>\r\n    </Card>\r\n  );\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\trucks\\TruckCardFooter.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\trucks\\TruckCardHeader.tsx","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected value in conditional. A boolean expression is required.","line":50,"column":42,"nodeType":"MemberExpression","messageId":"conditionErrorOther","endLine":50,"endColumn":52},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":50,"column":57,"nodeType":"Identifier","messageId":"conditionErrorNullableString","endLine":50,"endColumn":67,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[2542,2552],"text":"(priceRange != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[2542,2552],"text":"(priceRange ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[2542,2552],"text":"(Boolean(priceRange))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from 'react';\r\nimport { CardHeader, CardTitle, CardDescription } from '@/components/ui/card';\r\nimport { Badge } from '@/components/ui/badge';\r\nimport { MapPin } from 'lucide-react';\r\nimport { FoodTruck } from '@/lib/types';\r\n\r\ninterface TruckCardHeaderProps {\r\n  readonly truck: FoodTruck;\r\n  readonly isOpen: boolean;\r\n  readonly popularItems: Array<{ name: string; price: number | string | undefined }>;\r\n  readonly priceRange: string | undefined;\r\n}\r\n\r\n/**\r\n * Renders a header component for a truck card, displaying truck details and status.\r\n * @example\r\n * TruckCardHeader({\r\n *   truck: { name: 'Food Truck', current_location: { address: '123 Street' } },\r\n *   isOpen: true,\r\n *   popularItems: [{ name: 'Burger', price: undefined }],\r\n *   priceRange: '$$'\r\n * })\r\n * <CardHeader>...</CardHeader>\r\n * @param {Object} truck - Object containing information about the truck, including name and current location.\r\n * @param {boolean} isOpen - Indicates whether the truck is currently open or closed.\r\n * @param {Array} popularItems - Array containing popular items offered by the truck, typically objects with a name and optional price.\r\n * @param {string} priceRange - String indicating the general price range of items if explicit prices are unavailable.\r\n * @returns {JSX.Element} JSX representation of the card header for a truck.\r\n * @description\r\n *   - Displays the truck's name and current address if available.\r\n *   - Shows the open/closed status with a badge, changing appearance according to the status.\r\n *   - Fallback badge displaying price range shows only if no prices are available for popular items.\r\n */\r\nexport function TruckCardHeader({ truck, isOpen, popularItems, priceRange }: TruckCardHeaderProps) {\r\n  return (\r\n    <CardHeader>\r\n      <div className=\"flex justify-between items-start\">\r\n        <div className=\"flex-1\">\r\n          <CardTitle className=\"text-lg dark:text-gray-100\">{truck.name}</CardTitle>\r\n          {truck.current_location?.address != undefined && (\r\n            <CardDescription className=\"flex items-center mt-1 dark:text-gray-400\">\r\n              <MapPin className=\"size-4 mr-1\" />\r\n              {truck.current_location.address}\r\n            </CardDescription>\r\n          )}\r\n        </div>\r\n        <div className=\"flex flex-col items-end space-y-1\">\r\n          <Badge variant={isOpen ? 'default' : 'secondary'}>{isOpen ? 'Open' : 'Closed'}</Badge>\r\n          {/* Show price range fallback if no explicit prices */}\r\n          {popularItems.every((item) => !item.price) && priceRange && (\r\n            <Badge variant=\"outline\" className=\"mt-1\">\r\n              {priceRange}\r\n            </Badge>\r\n          )}\r\n        </div>\r\n      </div>\r\n    </CardHeader>\r\n  );\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\trucks\\TruckContactInfo.tsx","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":62,"column":10,"nodeType":"Identifier","messageId":"conditionErrorNullableString","endLine":62,"endColumn":14,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[2346,2350],"text":"(href != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[2346,2350],"text":"(href ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[2346,2350],"text":"(Boolean(href))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":159,"column":17,"nodeType":"ChainExpression","messageId":"conditionErrorNullableString","endLine":159,"endColumn":42,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[6470,6495],"text":"((truck.contact_info?.phone) != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[6470,6495],"text":"((truck.contact_info?.phone) ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[6470,6495],"text":"(Boolean((truck.contact_info?.phone)))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":167,"column":17,"nodeType":"ChainExpression","messageId":"conditionErrorNullableString","endLine":167,"endColumn":42,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[6747,6772],"text":"((truck.contact_info?.email) != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[6747,6772],"text":"((truck.contact_info?.email) ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[6747,6772],"text":"(Boolean((truck.contact_info?.email)))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from 'react';\r\nimport { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';\r\nimport { Phone, Mail, Globe } from 'lucide-react';\r\nimport type { FoodTruck } from '@/lib/supabase';\r\n\r\ninterface TruckContactInfoProps {\r\n  readonly truck: FoodTruck;\r\n}\r\n\r\ninterface ContactFieldProps {\r\n  readonly icon: React.ComponentType<{ className?: string }>;\r\n  readonly label: string;\r\n  readonly value?: string | null;\r\n  readonly href?: string;\r\n  readonly unavailableText: string;\r\n}\r\n\r\n/**\r\n * Renders a contact field with icon, label, and value, handling both available and unavailable states.\r\n * @example\r\n * ContactField({\r\n *   icon: EmailIcon,\r\n *   label: 'Email',\r\n *   value: 'example@example.com',\r\n *   href: 'mailto:example@example.com',\r\n *   unavailableText: 'Not Available'\r\n * })\r\n * <div>...</div>\r\n * @param {React.ComponentType} icon - The icon component to display in the contact field.\r\n * @param {string} label - The label to display above the contact value.\r\n * @param {string} value - The contact value to display; if undefined or empty, displays unavailableText instead.\r\n * @param {string} [href] - The link associated with the contact value for redirection. Determines link behavior based on URL format.\r\n * @param {string} unavailableText - Text displayed when value is unavailable or empty.\r\n * @returns {JSX.Element} JSX structure for the contact field.\r\n * @description\r\n *   - Opens external links in a new tab with 'noopener noreferrer' for security.\r\n *   - Conditionally renders either a hyperlink or plain text based on value and href.\r\n *   - Applies specific styling based on the availability of the value.\r\n */\r\nfunction ContactField({\r\n  icon: Icon,\r\n  label,\r\n  value,\r\n  href,\r\n  unavailableText,\r\n}: Readonly<ContactFieldProps>) {\r\n  if (value == undefined || value.length === 0) {\r\n    // Handles null, undefined, and empty string\r\n    return (\r\n      <div className=\"flex items-center gap-3 text-gray-400\">\r\n        <Icon className=\"size-4\" />\r\n        <span className=\"text-sm\">{unavailableText}</span>\r\n      </div>\r\n    );\r\n  }\r\n\r\n  return (\r\n    <div className=\"flex items-center gap-3\">\r\n      <Icon className=\"size-4 text-gray-500\" />\r\n      <div>\r\n        <label className=\"text-sm font-medium text-gray-500 dark:text-gray-400\">{label}</label>\r\n        {href ? (\r\n          <a\r\n            href={href}\r\n            target={href.startsWith('http') ? '_blank' : undefined}\r\n            rel={href.startsWith('http') ? 'noopener noreferrer' : undefined}\r\n            className=\"block text-blue-600 hover:text-blue-800 dark:text-blue-400 dark:hover:text-blue-300 underline\"\r\n          >\r\n            {href.startsWith('http') ? 'Visit Website' : value}\r\n          </a>\r\n        ) : (\r\n          <p className=\"text-gray-900 dark:text-gray-200\">{value}</p>\r\n        )}\r\n      </div>\r\n    </div>\r\n  );\r\n}\r\n\r\n/**\r\n * Renders social media links based on provided handles.\r\n * @example\r\n * SocialMediaLinks({ socialMedia: { instagram: 'insta_user', twitter: 'twit_user' } })\r\n * Renders and displays links for Instagram and Twitter.\r\n * @param {Object} {socialMedia} - Contains platform keys mapped to user handles.\r\n * @returns {JSX.Element|undefined} A JSX element displaying social media links or undefined if no valid links exist.\r\n * @description\r\n *   - Checks for undefined or empty socialMedia input to prevent unnecessary rendering.\r\n *   - Supports Instagram, Facebook, and Twitter platforms with specific styles.\r\n *   - Handles links are generated dynamically based on platform keys and user handles.\r\n *   - Applies consistent styling for light and dark themes using color properties.\r\n */\r\nfunction SocialMediaLinks({\r\n  socialMedia,\r\n}: Readonly<{ readonly socialMedia?: Record<string, string> }>) {\r\n  if (socialMedia == undefined || Object.keys(socialMedia).length === 0) {\r\n    return;\r\n  }\r\n\r\n  const socialPlatforms = [\r\n    { key: 'instagram', name: 'Instagram', baseUrl: 'https://instagram.com/', color: 'pink' },\r\n    { key: 'facebook', name: 'Facebook', baseUrl: 'https://facebook.com/', color: 'blue' },\r\n    { key: 'twitter', name: 'Twitter', baseUrl: 'https://twitter.com/', color: 'sky' },\r\n  ];\r\n\r\n  return (\r\n    <div>\r\n      <label className=\"text-sm font-medium text-gray-500 dark:text-gray-400\">Social Media</label>\r\n      <div className=\"flex flex-wrap gap-2 mt-2\">\r\n        {socialPlatforms.map(({ key, name, baseUrl, color }) => {\r\n          const handle = socialMedia[key];\r\n          if (handle == undefined || handle.length === 0) return; // Handles null, undefined, and empty string\r\n\r\n          return (\r\n            <a\r\n              key={key}\r\n              href={`${baseUrl}${handle}`}\r\n              target=\"_blank\"\r\n              rel=\"noopener noreferrer\"\r\n              className={`flex items-center gap-1 px-2 py-1 bg-${color}-100 text-${color}-800 rounded-md text-sm hover:bg-${color}-200 dark:bg-${color}-900 dark:text-${color}-200`}\r\n            >\r\n              <Globe className=\"size-3\" />\r\n              {name}\r\n            </a>\r\n          );\r\n        })}\r\n      </div>\r\n    </div>\r\n  );\r\n}\r\n\r\n/**\r\n * Renders a truck's contact information within a styled card component.\r\n * @example\r\n * TruckContactInfo({ truck: sampleTruckObject })\r\n * <Card>...</Card>\r\n * @param {Readonly<TruckContactInfoProps>} {truck} - Object containing truck's contact information and social media links.\r\n * @returns {JSX.Element} A card component displaying various contact fields and social media links.\r\n * @description\r\n *   - Utilizes conditional rendering to display availability of contact information.\r\n *   - Applies Tailwind CSS classes for dark mode styling.\r\n *   - Integrates icons alongside contact labels for visual aid.\r\n *   - SocialMediaLinks component is used to list the truck's social media presence.\r\n */\r\nexport function TruckContactInfo({ truck }: Readonly<TruckContactInfoProps>) {\r\n  return (\r\n    <Card className=\"dark:bg-slate-800 dark:border-slate-700\">\r\n      <CardHeader>\r\n        <CardTitle className=\"flex items-center gap-2 dark:text-gray-100\">\r\n          <Phone className=\"size-5\" />\r\n          Contact Information\r\n        </CardTitle>\r\n        <CardDescription className=\"dark:text-gray-400\">Get in touch</CardDescription>\r\n      </CardHeader>\r\n      <CardContent className=\"space-y-4\">\r\n        <ContactField\r\n          icon={Phone}\r\n          label=\"Phone\"\r\n          value={truck.contact_info?.phone}\r\n          href={truck.contact_info?.phone ? `tel:${truck.contact_info.phone}` : undefined}\r\n          unavailableText=\"No phone number available\"\r\n        />\r\n\r\n        <ContactField\r\n          icon={Mail}\r\n          label=\"Email\"\r\n          value={truck.contact_info?.email}\r\n          href={truck.contact_info?.email ? `mailto:${truck.contact_info.email}` : undefined}\r\n          unavailableText=\"No email available\"\r\n        />\r\n\r\n        <ContactField\r\n          icon={Globe}\r\n          label=\"Website\"\r\n          value={truck.contact_info?.website}\r\n          href={truck.contact_info?.website}\r\n          unavailableText=\"No website available\"\r\n        />\r\n\r\n        <SocialMediaLinks socialMedia={truck.social_media} />\r\n      </CardContent>\r\n    </Card>\r\n  );\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\trucks\\TruckDetailHeader.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\trucks\\TruckLocationInfo.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\trucks\\TruckNotFound.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\trucks\\TruckOperatingHours.tsx","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":59,"column":29,"nodeType":"MemberExpression","messageId":"conditionErrorObject","endLine":59,"endColumn":50}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from 'react';\r\nimport { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';\r\nimport { Clock } from 'lucide-react';\r\nimport type { FoodTruck } from '@/lib/supabase';\r\n\r\ninterface TruckOperatingHoursProps {\r\n  readonly truck: FoodTruck;\r\n}\r\n\r\ninterface DayData {\r\n  closed?: boolean;\r\n  open?: string;\r\n  close?: string;\r\n}\r\n\r\n/**\r\n * Displays the schedule for a specific day.\r\n * @example\r\n * DaySchedule({ day: 'monday', dayData: { open: '8:00 AM', close: '5:00 PM', closed: false } })\r\n * <div>...</div>\r\n * @param {Object} props - The properties for the schedule component.\r\n * @param {string} props.day - The name of the day (e.g., 'monday').\r\n * @param {DayData} [props.dayData] - Optional data object containing the opening and closing hours and a closed status.\r\n * @returns {JSX.Element} A React component representing the schedule for the given day.\r\n * @description\r\n *   - Capitalizes the first letter of the provided day's name.\r\n *   - Displays 'Closed' if dayData.closed is true, otherwise displays opening and closing times.\r\n *   - 'N/A' is shown if opening or closing time is not defined.\r\n */\r\nfunction DaySchedule({ day, dayData }: Readonly<{ day: string; dayData?: DayData }>) {\r\n  const dayName = day.charAt(0).toUpperCase() + day.slice(1);\r\n\r\n  return (\r\n    <div className=\"flex justify-between items-center\">\r\n      <span className=\"text-sm font-medium dark:text-gray-200\">{dayName}</span>\r\n      <span className=\"text-sm text-gray-600 dark:text-gray-400\">\r\n        {dayData?.closed === true\r\n          ? 'Closed'\r\n          : `${dayData?.open ?? 'N/A'} - ${dayData?.close ?? 'N/A'}`}\r\n      </span>\r\n    </div>\r\n  );\r\n}\r\n\r\n/**\r\n * Renders a truck's operating hours in a card format.\r\n * @example\r\n * TruckOperatingHours({ truck: { operating_hours: { monday: { open: \"9:00 AM\", close: \"5:00 PM\" } } } })\r\n * <Card>...</Card>\r\n * @param {TruckOperatingHoursProps} {truck} - Object containing truck details including operating hours.\r\n * @returns {JSX.Element} A JSX element representing truck operating hours card.\r\n * @description\r\n *   - Utilizes a Card component for displaying the information visually.\r\n *   - Iterates through the days of the week to display operating hours for each day.\r\n *   - Displays a message when operating hours are not available.\r\n */\r\nexport function TruckOperatingHours({ truck }: TruckOperatingHoursProps) {\r\n  const daysOfWeek = ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday'];\r\n  const hasOperatingHours = truck.operating_hours && Object.keys(truck.operating_hours).length > 0;\r\n\r\n  return (\r\n    <Card className=\"dark:bg-slate-800 dark:border-slate-700\">\r\n      <CardHeader>\r\n        <CardTitle className=\"flex items-center gap-2 dark:text-gray-100\">\r\n          <Clock className=\"size-5\" />\r\n          Operating Hours\r\n        </CardTitle>\r\n        <CardDescription className=\"dark:text-gray-400\">Daily schedule</CardDescription>\r\n      </CardHeader>\r\n      <CardContent>\r\n        {hasOperatingHours ? (\r\n          <div className=\"space-y-2\">\r\n            {daysOfWeek.map((day) => {\r\n              const dayData = truck.operating_hours?.[day as keyof typeof truck.operating_hours] as\r\n                | DayData\r\n                | undefined;\r\n              return <DaySchedule key={day} day={day} dayData={dayData} />;\r\n            })}\r\n          </div>\r\n        ) : (\r\n          <p className=\"text-gray-400 text-sm\">Operating hours not available</p>\r\n        )}\r\n      </CardContent>\r\n    </Card>\r\n  );\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\trucks\\TruckRatingsReviews.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\ui\\AlertDialog.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\ui\\AspectRatio.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\ui\\ContactSection.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\ui\\ContextMenu.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\ui\\DropdownMenu.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\ui\\HoverCard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\ui\\InputOtp.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\ui\\MenuSection.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\ui\\NavigationMenu.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\ui\\RadioGroup.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\ui\\RatingSection.tsx","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":17,"column":8,"nodeType":"Identifier","messageId":"conditionErrorObject","endLine":17,"endColumn":15}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from 'react';\r\nimport { TruckRating } from '@/lib/types';\r\n\r\n/**\r\n * Displays truck ratings and calculates average score.\r\n * @example\r\n * renderRatings({ ratings: [{ id: 1, title: 'Service', score: 4.5 }, { id: 2, title: 'Quality', score: 4.0 }] })\r\n * <div>A rendered ratings breakdown</div>\r\n * @param {{ ratings: Array<{ id: number, title: string, score: number }> }} ratings - An array of truck ratings, each containing an id, a title, and a score.\r\n * @returns {JSX.Element} A JSX element displaying the list of ratings with an average score.\r\n * @description\r\n *   - Returns a message that no ratings are available if the input array is empty or undefined.\r\n *   - Calculates the average rating score using all ratings in the array.\r\n *   - Renders individual ratings dynamically within the returned JSX.\r\n */\r\nconst RatingSection = ({ ratings }: { ratings: TruckRating[] }) => {\r\n  if (!ratings || ratings.length === 0) return <p>No ratings yet</p>;\r\n\r\n  const avgScore = ratings.reduce((total, rating) => total + rating.score, 0) / ratings.length;\r\n\r\n  return (\r\n    <div className=\"rating-container\">\r\n      <h3>Ratings Breakdown</h3>\r\n      <div className=\"average-rating\">Average: {avgScore.toFixed(1)}</div>\r\n      {ratings.map(rating => (\r\n        <div key={rating.id} className=\"individual-rating\">\r\n          <p>{rating.title}: {rating.score}</p>\r\n        </div>\r\n      ))}\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default RatingSection;\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\ui\\ScrollArea.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\ui\\SimpleQualityPanel.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\ui\\SocialMediaSection.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\ui\\ToggleGroup.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\ui\\TruckCard.tsx","messages":[{"ruleId":"@next/next/no-img-element","severity":1,"message":"Using `<img>` could result in slower LCP and higher bandwidth. Consider using `<Image />` from `next/image` or a custom image loader to automatically optimize images. This may incur additional usage or cost from your provider. See: https://nextjs.org/docs/messages/no-img-element","line":14,"column":7,"nodeType":"JSXOpeningElement","endLine":14,"endColumn":58}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from 'react';\r\n\r\nexport interface TruckCardProps {\r\n  title: string;\r\n  price: string;\r\n  reviews: number;\r\n  image_url: string;\r\n  rating: number;\r\n}\r\n\r\nexport default function TruckCard({ title, price, reviews, image_url, rating }: Readonly<TruckCardProps>) {\r\n  return (\r\n    <div className=\"bg-white p-4 rounded-md\">\r\n      <img src={image_url} alt={title} className=\"mb-3\"/>\r\n      <h3>{title}</h3>\r\n      <p className=\"text-gray-800\">${price}</p>\r\n      <p>Rating: {rating} based on {reviews} reviews</p>\r\n    </div>\r\n  );\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\ui\\TruckCardContent.tsx","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":55,"column":27,"nodeType":"MemberExpression","messageId":"conditionErrorNullableBoolean","endLine":55,"endColumn":44,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[2150,2167],"text":"(todayHours.closed ?? false)"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareFalse","fix":{"range":[2149,2167],"text":"(todayHours.closed === false)"},"desc":"Change condition to check if false (`value === false`)"}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from 'react';\nimport TruckCard from './TruckCard';\nimport { formatPrice } from '@/lib/utils/foodTruckHelpers';\nimport { MenuSection, SocialMediaSection, ContactSection } from '.';\n\ninterface MenuItem {\n  name: string;\n  price_cents?: number; // Make price_cents optional\n}\n\n/**\n* Renders the card content for a food truck including its name, operating hours, popular menu items, and contact details.\n* @example\n* TruckCardContent({\n*   truck: { name: 'Tasty Truck', address: '123 Street', phone_number: '123-456-7890' },\n*   todayHours: { open: '8:00 AM', close: '5:00 PM', closed: false },\n*   popularItems: [{ name: 'Burger', price_cents: 500 }],\n* })\n* // returns JSX containing truck's card\n* @param {object} truck - The truck object containing name, address, and phone number.\n* @param {object} todayHours - An optional object specifying today's opening and closing times and whether it is closed.\n* @param {MenuItem[]} popularItems - List of popular menu items to display.\n* @returns {JSX.Element} The JSX content for rendering the truck's card.\n* @description\n*   - Uses default values for missing truck properties to ensure components render safely.\n*   - Calculates the average price of popular items and formats it to two decimal places.\n*   - Validates the existence of social media and contact information before rendering related sections.\n*/\nexport function TruckCardContent({\n  truck,\n  todayHours,\n  popularItems = [],\n}: {\n  readonly truck: { name: string; address?: string; phone_number?: string; social_media?: Record<string, string> };\n  readonly todayHours?: { open?: string; close?: string; closed?: boolean };\n  readonly popularItems: MenuItem[];\n}) {\n  const {\n    name = 'Unnamed Truck',\n    social_media = {},\n    address = '', // Provide safe defaults\n    phone_number = '',\n  } = truck;\n\n  const avgDailyPrice = (\n    popularItems.reduce((acc, item) => acc + (item.price_cents ?? 0), 0) /\n    popularItems.length ?? 0\n  ).toFixed(2);\n\n  return (\n    <main className=\"ui-truck-container\">\n      {name && (\n        <>\n          <TruckCard title={name} avgCost={`$${avgDailyPrice}`} />\n          {todayHours && !todayHours.closed && (\n            <div className=\"hours-display\">\n              <strong>Today:</strong> {todayHours.open} - {todayHours.close}\n            </div>\n          )}\n        </>\n      )}\n\n      {popularItems.length > 0 && (\n        <MenuSection\n          items={popularItems.map(item => ({\n            name: item.name,\n            price: formatPrice(item.price_cents),\n          }))}\n        />\n      )}\n\n      {/* SocialMediaSection and ContactSection require validation */}\n      {Object.keys(social_media).length > 0 && (typeof social_media === 'object')&& (\n        <SocialMediaSection social_media={social_media} />\n      )}\n\n      {/* Refactored ContactSection - handle undefined values explicitly*/}\n      {(address || phone_number) && (\n        <ContactSection address={address} phone_number={phone_number} />\n      )}\n    </main>\n  );\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\ui\\accordion.tsx","messages":[],"suppressedMessages":[{"ruleId":"sonarjs/deprecation","severity":2,"message":"'ElementRef' is deprecated.","line":13,"column":9,"nodeType":null,"messageId":"deprecation","endLine":13,"endColumn":19,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\ui\\alert.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\ui\\avatar.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\ui\\badge.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\ui\\breadcrumb.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\ui\\button.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\ui\\calendar.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\ui\\card.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\ui\\carousel.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\ui\\chart.tsx","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected any value in conditional. An explicit comparison or type conversion is required.","line":233,"column":43,"nodeType":"MemberExpression","messageId":"conditionErrorAny","endLine":233,"endColumn":55,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[8384,8396],"text":"(Boolean(item.payload))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]}],"suppressedMessages":[{"ruleId":"max-params","severity":2,"message":"Function has too many parameters (5). Maximum allowed is 4.","line":120,"column":25,"nodeType":"TSFunctionType","messageId":"exceed","endLine":120,"endColumn":25,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/* eslint-disable max-params */\n'use client';\n\nimport * as React from 'react';\nimport * as RechartsPrimitive from 'recharts';\nimport { NameType, Payload, ValueType } from 'recharts/types/component/DefaultTooltipContent';\n\nimport { cn } from '@/lib/utils';\nimport { useTooltipLabel } from './chart/useTooltipLabel';\nimport { TooltipIndicator } from './chart/TooltipIndicator';\nimport { TooltipItemContent } from './chart/TooltipItemContent';\nimport { getPayloadConfigFromPayload } from './chart/getPayloadConfigFromPayload';\n\n// Format: { THEME_NAME: CSS_SELECTOR }\nconst THEMES = { light: '', dark: '.dark' } as const;\n\nexport type ChartConfig = {\n  [k in string]: {\n    label?: React.ReactNode;\n    icon?: React.ComponentType;\n  } & (\n    | { color?: string; theme?: never }\n    | { color?: never; theme: Record<keyof typeof THEMES, string> }\n  );\n};\n\ntype ChartContextProps = {\n  config: ChartConfig;\n};\n\nconst ChartContext = React.createContext<ChartContextProps | undefined>(undefined);\n\nfunction useChart() {\n  const context = React.useContext(ChartContext);\n  if (context === undefined) {\n    throw new Error('useChart must be used within a <ChartContainer />');\n  }\n  return context;\n}\n\nconst ChartContainer = React.forwardRef<\n  HTMLDivElement,\n  React.ComponentProps<'div'> & {\n    readonly config: ChartConfig;\n    readonly children: React.ComponentProps<\n      typeof RechartsPrimitive.ResponsiveContainer\n    >['children'];\n  }\n>(({ id, className, children, config, ...props }, ref) => {\n  const uniqueId = React.useId();\n  const chartId = `chart-${id ?? uniqueId.replaceAll(':', '')}`;\n\n  return (\n    <ChartContext.Provider value={{ config }}>\n      <div\n        data-chart={chartId}\n        ref={ref}\n        className={cn(\n          \"flex aspect-video justify-center text-xs [&_.recharts-cartesian-axis-tick_text]:fill-muted-foreground [&_.recharts-cartesian-grid_line[stroke='#ccc']]:stroke-border/50 [&_.recharts-curve.recharts-tooltip-cursor]:stroke-border [&_.recharts-dot[stroke='#fff']]:stroke-transparent [&_.recharts-layer]:outline-none [&_.recharts-polar-grid_[stroke='#ccc']]:stroke-border [&_.recharts-radial-bar-background-sector]:fill-muted [&_.recharts-rectangle.recharts-tooltip-cursor]:fill-muted [&_.recharts-reference-line_[stroke='#ccc']]:stroke-border [&_.recharts-sector[stroke='#fff']]:stroke-transparent [&_.recharts-sector]:outline-none [&_.recharts-surface]:outline-none\",\n          className,\n        )}\n        {...props}\n      >\n        <ChartStyle id={chartId} config={config} />\n        <RechartsPrimitive.ResponsiveContainer>{children}</RechartsPrimitive.ResponsiveContainer>\n      </div>\n    </ChartContext.Provider>\n  );\n});\nChartContainer.displayName = 'Chart';\n\n/**\n * Generates and returns a style JSX element with theme-based color configurations for charts.\n * @example\n * const jsxStyleElement = generateStyleElement({ id: 'myChart', config: myChartConfig });\n * @param {Object} context - An object containing the chart's identifier and configuration.\n * @param {string} context.id - The unique identifier for the chart.\n * @param {ChartConfig} context.config - The configuration object for the chart.\n * @returns {JSX.Element|undefined} A JSX style element setting CSS variables for chart colors, or undefined if no color configuration is provided.\n * @description\n *   - Only charts with theme or color properties in their configuration will generate color styles.\n *   - Utilizes `dangerouslySetInnerHTML` to inject computed styles into JSX.\n */\nconst ChartStyle = ({ id, config }: { readonly id: string; readonly config: ChartConfig }) => {\n  const colorConfig = Object.entries(config).filter(\n    ([_, itemConfig]) => (itemConfig.theme ?? itemConfig.color) !== undefined,\n  );\n  if (colorConfig.length === 0) {\n    return;\n  }\n\n  return (\n    <style\n      dangerouslySetInnerHTML={{\n        __html: Object.entries(THEMES)\n          .map(\n            ([theme, prefix]) => `\n${prefix} [data-chart=${id}] {\n${colorConfig\n  .map(([key, itemConfig]) => {\n    const color = itemConfig.theme?.[theme as keyof typeof itemConfig.theme] ?? itemConfig.color;\n    return color !== undefined && color !== '' ? `  --color-${key}: ${color};` : undefined;\n  })\n  .join('\\n')}\n}\n`,\n          )\n          .join('\\n'),\n      }}\n    />\n  );\n};\n\nconst ChartTooltip = RechartsPrimitive.Tooltip;\n\nfunction isNonEmptyArray<T>(arr: T[] | undefined): arr is T[] {\n  return Array.isArray(arr) && arr.length > 0;\n}\n\ntype TooltipFormatter = (\n  value: number,\n  name: string,\n  item: unknown,\n  index: number,\n  payload: Record<string, unknown>[],\n) => React.ReactNode;\ntype TooltipItemData = {\n  name?: string;\n  dataKey?: string;\n  payload?: Record<string, unknown>;\n  color?: string;\n  value?: number;\n};\n\ntype ChartTooltipIndicatorAndContentProps = {\n  indicator: 'line' | 'dot' | 'dashed';\n  hideIndicator: boolean;\n  indicatorColor?: string;\n  nestLabel: boolean;\n  itemConfig: Record<string, unknown>;\n  formatter: TooltipFormatter | undefined;\n  itemData: TooltipItemData;\n  item: Payload<ValueType, NameType>;\n  index: number;\n  tooltipLabel: React.ReactNode;\n};\n\n/**\n* Renders a tooltip indicator and content for a chart\n* @example\n* ChartTooltipIndicatorAndContent({ indicator: 'sample', hideIndicator: false })\n* Returns a JSX fragment containing TooltipIndicator and TooltipItemContent components\n* @param {ChartTooltipIndicatorAndContentProps} props - Configuration object for rendering the tooltip components.\n* @returns {JSX.Element} A fragment that contains tooltip indicator and item content components.\n* @description\n*   - Combines TooltipIndicator and TooltipItemContent using provided configuration.\n*   - Uses the `formatter` function to format the item data in the tooltip content.\n*   - Passes the `itemConfig` and `nestLabel` to both child components for consistent rendering.\n*/\nfunction ChartTooltipIndicatorAndContent(props: Readonly<ChartTooltipIndicatorAndContentProps>) {\n  const {\n    indicator,\n    hideIndicator,\n    indicatorColor,\n    nestLabel,\n    itemConfig,\n    formatter,\n    itemData,\n    item,\n    index,\n    tooltipLabel,\n  } = props;\n  return (\n    <>\n      <TooltipIndicator\n        indicator={indicator}\n        hideIndicator={hideIndicator}\n        indicatorColor={indicatorColor}\n        nestLabel={nestLabel}\n        itemConfig={itemConfig}\n      />\n      <TooltipItemContent\n        formatter={formatter}\n        itemData={itemData}\n        item={item}\n        index={index}\n        itemConfig={itemConfig}\n        nestLabel={nestLabel}\n        tooltipLabel={tooltipLabel}\n      />\n    </>\n  );\n}\n\ntype ChartTooltipItemProps = {\n  item: Payload<ValueType, NameType>;\n  index: number;\n  indicatorProps: {\n    indicator: 'line' | 'dot' | 'dashed';\n    hideIndicator: boolean;\n    color?: string;\n    nestLabel: boolean;\n    config: ChartConfig;\n    nameKey?: string;\n    tooltipLabel: React.ReactNode;\n    formatter: TooltipFormatter | undefined;\n  };\n};\n\n/**\n * Renders a chart tooltip item with a configurable indicator.\n * @example\n * ChartTooltipItem({ item: { name: \"Sample\", dataKey: \"key\" }, index: 0, indicatorProps: { indicator: \"dot\", hideIndicator: false, color: \"blue\" } })\n * // Returns JSX element for tooltip with indicator\n * @param {Object} item - The chart item containing dataKey, name, payload, color, and value attributes.\n * @param {number} index - The index position of the chart item.\n * @param {Object} indicatorProps - Properties for configuring the indicator like type, visibility, color, etc.\n * @returns {JSX.Element} A JSX element rendering the chart tooltip item with an optional indicator.\n * @description\n *   - The tooltip item will display customizable content based on provided item configuration.\n *   - Tooltip indicator can be hidden or shown based on `hideIndicator` property.\n *   - Determines the color of the indicator, initially defaulting to item-specific color or payload-specific fill.\n */\nfunction ChartTooltipItem({ item, index, indicatorProps }: Readonly<ChartTooltipItemProps>) {\n  const { indicator, hideIndicator, color, nestLabel, config, nameKey, tooltipLabel, formatter } =\n    indicatorProps;\n  const dataKey = typeof item.dataKey === 'string' ? item.dataKey : undefined;\n\n  const itemData: TooltipItemData = {\n    name: item.name === undefined ? undefined : String(item.name),\n    dataKey,\n    payload:\n      typeof item.payload === 'object' && item.payload\n        ? (item.payload as Record<string, unknown>)\n        : undefined,\n    color: typeof item.color === 'string' ? item.color : undefined,\n    value: typeof item.value === 'number' ? item.value : undefined,\n  };\n  const key = nameKey ?? itemData.name ?? itemData.dataKey ?? 'value';\n  const itemConfig = getPayloadConfigFromPayload(config, item, key) as Record<string, unknown>;\n  const indicatorColor =\n    color ??\n    (itemData.payload !== undefined &&\n    typeof itemData.payload === 'object' &&\n    'fill' in itemData.payload\n      ? String(itemData.payload.fill)\n      : undefined) ??\n    itemData.color;\n  return (\n    <div\n      key={itemData.dataKey ?? index}\n      className={cn(\n        'flex w-full flex-wrap items-stretch gap-2 [&>svg]:h-2.5 [&>svg]:w-2.5 [&>svg]:text-muted-foreground',\n        indicator === 'dot' && 'items-center',\n      )}\n    >\n      <ChartTooltipIndicatorAndContent\n        indicator={indicator}\n        hideIndicator={hideIndicator}\n        indicatorColor={indicatorColor}\n        nestLabel={nestLabel}\n        itemConfig={itemConfig}\n        formatter={formatter}\n        itemData={itemData}\n        item={item}\n        index={index}\n        tooltipLabel={tooltipLabel}\n      />\n    </div>\n  );\n}\n\ntype ChartTooltipItemsProps = {\n  safePayload: Payload<ValueType, NameType>[];\n  indicatorProps: {\n    indicator: 'line' | 'dot' | 'dashed';\n    hideIndicator: boolean;\n    formatter: TooltipFormatter | undefined;\n    nameKey?: string;\n    color?: string;\n    tooltipLabel: React.ReactNode;\n    config: ChartConfig;\n    nestLabel: boolean;\n  };\n};\n\n/**\n * Represents a grid layout of tooltip items for a chart.\n * @example\n * ChartTooltipItems({ safePayload: payloadData, indicatorProps: chartIndicatorSettings })\n * <div className=\"grid gap-1.5\">...</div>\n * @param {Readonly<ChartTooltipItemsProps>} props - Contains the payload and indicator properties required for rendering tooltip items.\n * @returns {JSX.Element} A div containing tooltip items in a grid layout.\n * @description\n *   - Utilizes the `ChartTooltipItem` component to render individual tooltip items.\n *   - Applies a CSS class for a grid layout with spacing between items.\n *   - Ensures safe access to each item's key using `item.dataKey ?? index`.\n */\nfunction ChartTooltipItems(props: Readonly<ChartTooltipItemsProps>) {\n  const { safePayload, indicatorProps } = props;\n  return (\n    <div className=\"grid gap-1.5\">\n      {safePayload.map((item, index) => (\n        <ChartTooltipItem\n          key={item.dataKey ?? index}\n          item={item}\n          index={index}\n          indicatorProps={indicatorProps}\n        />\n      ))}\n    </div>\n  );\n}\n\nconst ChartTooltipContent = React.forwardRef<\n  HTMLDivElement,\n  React.ComponentProps<typeof RechartsPrimitive.Tooltip> &\n    React.ComponentProps<'div'> & {\n      readonly hideLabel?: boolean;\n      readonly hideIndicator?: boolean;\n      readonly indicator?: 'line' | 'dot' | 'dashed';\n      readonly nameKey?: string;\n      readonly labelKey?: string;\n    }\n>(\n  (\n    {\n      active,\n      payload,\n      className,\n      indicator = 'dot',\n      hideLabel = false,\n      hideIndicator = false,\n      label,\n      labelFormatter,\n      labelClassName,\n      formatter,\n      color,\n      nameKey,\n      labelKey,\n    },\n    ref,\n  ) => {\n    const { config } = useChart();\n    const safePayload: Payload<ValueType, NameType>[] = isNonEmptyArray(payload) ? payload : [];\n    const tooltipLabel = useTooltipLabel({\n      hideLabel,\n      payload: safePayload,\n      label,\n      labelFormatter,\n      labelClassName,\n      config,\n      labelKey,\n    });\n\n    if (active === false || !isNonEmptyArray(safePayload)) {\n      return;\n    }\n\n    const nestLabel = safePayload.length === 1 && indicator !== 'dot';\n\n    return (\n      <div\n        ref={ref}\n        className={cn(\n          'grid min-w-[8rem] items-start gap-1.5 rounded-lg border border-border/50 bg-background px-2.5 py-1.5 text-xs shadow-xl',\n          className,\n        )}\n      >\n        {!nestLabel && tooltipLabel}\n        <ChartTooltipItems\n          safePayload={safePayload}\n          indicatorProps={{\n            indicator,\n            hideIndicator,\n            formatter: formatter,\n            nameKey,\n            color,\n            tooltipLabel,\n            config,\n            nestLabel,\n          }}\n        />\n      </div>\n    );\n  },\n);\nChartTooltipContent.displayName = 'ChartTooltip';\n\nconst ChartLegend = RechartsPrimitive.Legend;\n\ninterface ChartLegendItemProps {\n  item: Payload<ValueType, NameType>;\n  idx: number;\n  hideIcon: boolean;\n  nameKey?: string;\n  config: ChartConfig;\n}\n\n/**\n * Renders a chart legend item with customizable appearance.\n * @example\n * ChartLegendItem({ item: sampleItem, idx: 0, hideIcon: false, nameKey: 'legendItem', config: sampleConfig })\n * Returns a JSX element representing the chart legend item with an icon, label, or color box.\n * @param {Object} item - The legend item data including `dataKey`, `value`, and `color`.\n * @param {number} idx - The index of the item in the legend list to be used as a fallback key.\n * @param {boolean} hideIcon - A flag to determine whether to hide the item icon.\n * @param {string} [nameKey] - Optional key to identify the legend item, falling back to `dataKey` or 'value'.\n * @param {Object} config - Configuration object to customize the legend item appearance and behavior.\n * @returns {JSX.Element} A JSX element representing the chart legend item with optional icon, label, or color box.\n * @description\n *   - Uses the item's `dataKey` as a unique identifier when `nameKey` is not provided.\n *   - Applies default styling to SVG icons within the legend item using Tailwind CSS classes.\n *   - Dynamically renders either an icon or a styled color box based on the `hideIcon` flag and `itemConfig`.\n *   - Retrieves configuration using `getPayloadConfigFromPayload` for interactive legend item customization.\n */\nfunction ChartLegendItem({ item, idx, hideIcon, nameKey, config }: Readonly<ChartLegendItemProps>) {\n  const dataKey = item.dataKey?.toString();\n  const itemData = {\n    dataKey,\n    value: item.value?.toString(),\n    color: item.color?.toString(),\n  };\n  const key = nameKey ?? dataKey ?? 'value';\n  const itemConfig = getPayloadConfigFromPayload(config, item, key);\n\n  return (\n    <div\n      key={itemData.value ?? idx}\n      className={cn(\n        'flex items-center gap-1.5 [&>svg]:h-3 [&>svg]:w-3 [&>svg]:text-muted-foreground',\n      )}\n    >\n      {itemConfig?.icon && !hideIcon ? (\n        <itemConfig.icon />\n      ) : (\n        <div\n          className=\"size-2 shrink-0 rounded-[2px]\"\n          style={{\n            backgroundColor: itemData.color,\n          }}\n        />\n      )}\n      {itemConfig?.label}\n    </div>\n  );\n}\n\nconst ChartLegendContent = React.forwardRef<\n  HTMLDivElement,\n  React.ComponentProps<typeof RechartsPrimitive.Legend> &\n    Pick<RechartsPrimitive.LegendProps, 'payload' | 'verticalAlign'> & {\n      hideIcon?: boolean;\n      nameKey?: string;\n    }\n>(({ className, hideIcon = false, payload, verticalAlign = 'bottom', nameKey }, ref) => {\n  const { config } = useChart();\n  const safePayload: Payload<ValueType, NameType>[] = isNonEmptyArray(payload)\n    ? (payload as Payload<ValueType, NameType>[])\n    : [];\n  if (!isNonEmptyArray(safePayload)) {\n    return;\n  }\n\n  return (\n    <div\n      ref={ref}\n      className={cn(\n        'flex items-center justify-center gap-4',\n        verticalAlign === 'top' ? 'pb-3' : 'pt-3',\n        className,\n      )}\n    >\n      {safePayload.map((item, idx) => (\n        <ChartLegendItem\n          key={item.dataKey ?? idx}\n          item={item}\n          idx={idx}\n          hideIcon={hideIcon}\n          nameKey={nameKey}\n          config={config}\n        />\n      ))}\n    </div>\n  );\n});\nChartLegendContent.displayName = 'ChartLegend';\n\nexport {\n  ChartContainer,\n  ChartTooltip,\n  ChartTooltipContent,\n  ChartLegend,\n  ChartLegendContent,\n  ChartStyle,\n};\n","usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\ui\\chart\\QualityPieChart.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\ui\\chart\\TooltipIndicator.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\ui\\chart\\TooltipItemContent.tsx","messages":[],"suppressedMessages":[{"ruleId":"max-params","severity":2,"message":"Function has too many parameters (5). Maximum allowed is 4.","line":6,"column":24,"nodeType":"TSFunctionType","messageId":"exceed","endLine":6,"endColumn":24,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\ui\\chart\\getPayloadConfigFromPayload.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\ui\\chart\\useTooltipLabel.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\ui\\checkbox.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\ui\\collapsible.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\ui\\command.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\ui\\dataQualityCharts.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\ui\\dialog.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\ui\\drawer.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\ui\\form.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\ui\\input.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\ui\\label.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\ui\\pagination.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\ui\\popover.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\ui\\progress.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\ui\\resizable.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\ui\\select.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\ui\\separator.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\ui\\sheet.tsx","messages":[],"suppressedMessages":[{"ruleId":"sonarjs/deprecation","severity":2,"message":"'ElementRef' is deprecated.","line":20,"column":9,"nodeType":null,"messageId":"deprecation","endLine":20,"endColumn":19,"suppressions":[{"kind":"directive","justification":"False positive, ElementRef is not deprecated."}]},{"ruleId":"sonarjs/deprecation","severity":2,"message":"'ElementRef' is deprecated.","line":59,"column":9,"nodeType":null,"messageId":"deprecation","endLine":59,"endColumn":19,"suppressions":[{"kind":"directive","justification":"False positive, ElementRef is not deprecated."}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\ui\\sidebar.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\ui\\skeleton.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\ui\\slider.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\ui\\sonner.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\ui\\switch.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\ui\\table.tsx","messages":[],"suppressedMessages":[{"ruleId":"sonarjs/table-header","severity":2,"message":"Add a valid header row or column to this \"<table>\".","line":9,"column":7,"nodeType":"JSXElement","endLine":9,"endColumn":96,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\ui\\tabs.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\ui\\textarea.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\ui\\toast.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\ui\\toaster.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\ui\\toggle.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\ui\\tooltip.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\hooks\\UseMobile.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\hooks\\UseToast.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\hooks\\realtime\\connectionManagementHelpers.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\hooks\\realtime\\createEventSourceConnection.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\hooks\\realtime\\setupEventSourceListeners.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\hooks\\realtime\\useAutoConnect.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\hooks\\realtime\\useConnectionManagement.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\hooks\\realtime\\useConnectionState.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\hooks\\realtime\\useEventHandlers.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\hooks\\useAdminAuth.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\hooks\\useAuthHandlers.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\hooks\\useDataCleanup.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\hooks\\useFoodTruckDetails.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\hooks\\useFoodTruckFinder.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\hooks\\useRealtimeAdminEvents.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a(n) `error` type typed value.","line":71,"column":3,"nodeType":"Identifier","messageId":"unsafeCall","endLine":71,"endColumn":12}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useRef } from 'react';\nimport { RealtimeEvent, RealtimeMetrics } from './useRealtimeAdminEvents.types';\nimport { useConnectionState } from './realtime/useConnectionState';\nimport { useConnectionManagement } from './realtime/useConnectionManagement';\nimport { useEventHandlers } from './realtime/useEventHandlers';\n\n/**\n * SOTA Real-time Admin Dashboard Hook\n *\n * Provides real-time updates for admin dashboard using Server-Sent Events (SSE)\n * Implements automatic reconnection, error handling, and event filtering\n */\n\ninterface UseRealtimeAdminEventsOptions {\n  autoConnect?: boolean;\n  reconnectInterval?: number;\n  maxReconnectAttempts?: number;\n  eventFilter?: (event: RealtimeEvent) => boolean;\n}\n\ninterface UseRealtimeAdminEventsReturn {\n  // Connection state\n  isConnected: boolean;\n  isConnecting: boolean;\n  connectionError: string | undefined;\n\n  // Data\n  latestMetrics: RealtimeMetrics | undefined;\n  recentEvents: RealtimeEvent[];\n\n  // Controls\n  connect: () => void;\n  disconnect: () => void;\n  clearEvents: () => void;\n\n  // Statistics\n  connectionAttempts: number;\n  lastEventTime: Date | undefined;\n}\n\nexport function useRealtimeAdminEvents(\n  options: UseRealtimeAdminEventsOptions = {},\n): UseRealtimeAdminEventsReturn {\n  const { autoConnect = true, reconnectInterval = 5000, maxReconnectAttempts = 10, eventFilter } = options;\n\n  const eventSourceRef = useRef<EventSource>();\n  const reconnectTimeoutRef = useRef<NodeJS.Timeout>();\n  const isManuallyDisconnectedRef = useRef(false);\n\n  const connectionState = useConnectionState();\n  const { isConnected, isConnecting, connectionError, latestMetrics, recentEvents, connectionAttempts, lastEventTime } = connectionState;\n\n  const handleEvent = useEventHandlers(\n    eventFilter as ((event: RealtimeEvent) => boolean) | undefined,\n    setLastEventTime as React.Dispatch<React.SetStateAction<Date | undefined>>,\n    setLatestMetrics as React.Dispatch<React.SetStateAction<RealtimeMetrics | undefined>>,\n    setRecentEvents as React.Dispatch<React.SetStateAction<RealtimeEvent[]>>,\n  );\n\n  const { connect, disconnect, clearEvents } = useConnectionManagement({\n    eventSourceRef,\n    reconnectTimeoutRef,\n    isManuallyDisconnectedRef,\n    connectionState,\n    handleEvent,\n    maxReconnectAttempts,\n    reconnectInterval,\n  });\n\n  // Auto-connect effect\n  useEffect(() => {\n    if (autoConnect) {\n      connect();\n    }\n    return () => {\n      disconnect();\n    };\n  }, [autoConnect, connect, disconnect]);\n\n  return {\n    isConnected,\n    isConnecting,\n    connectionError,\n    latestMetrics,\n    recentEvents,\n    connect,\n    disconnect,\n    clearEvents,\n    connectionAttempts,\n    lastEventTime,\n  };\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\hooks\\useRealtimeAdminEvents.types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\hooks\\useRealtimeAdminEventsHelpers.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\hooks\\useSearchFiltersLogic.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\hooks\\useSidebarKeyboardShortcut.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\hooks\\useSystemAlerts.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\hooks\\useTruckCard.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\ScraperEngine.ts","messages":[],"suppressedMessages":[{"ruleId":"sonarjs/pseudo-random","severity":2,"message":"Make sure that using this pseudorandom number generator is safe here.","line":325,"column":24,"nodeType":"CallExpression","messageId":"safeGenerator","endLine":325,"endColumn":37,"suppressions":[{"kind":"directive","justification":"Math.random is acceptable for non-security-critical user agent selection."}]},{"ruleId":"sonarjs/pseudo-random","severity":2,"message":"Make sure that using this pseudorandom number generator is safe here.","line":341,"column":29,"nodeType":"CallExpression","messageId":"safeGenerator","endLine":341,"endColumn":42,"suppressions":[{"kind":"directive","justification":"Math.random is acceptable for non-security-critical random delays."}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\activityLogger.ts","messages":[],"suppressedMessages":[{"ruleId":"sonarjs/pseudo-random","severity":2,"message":"Make sure that using this pseudorandom number generator is safe here.","line":58,"column":10,"nodeType":"CallExpression","messageId":"safeGenerator","endLine":58,"endColumn":23,"suppressions":[{"kind":"directive","justification":"Math.random is acceptable for non-security-critical logging IDs."}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\api\\admin\\automated-cleanup\\handlers.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":100,"column":23,"nodeType":"ChainExpression","messageId":"conditionErrorObject","endLine":100,"endColumn":33}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { NextRequest, NextResponse } from 'next/server';\nimport { BatchCleanupService } from '@/lib/data-quality/batchCleanup';\nimport { supabase, supabaseAdmin } from '@/lib/supabase';\n\ninterface CleanupSchedule {\n  id: string;\n  name: string;\n  operations: string[];\n  schedule: string; // cron expression\n  enabled: boolean;\n  lastRun?: string;\n  nextRun?: string;\n  successCount: number;\n  errorCount: number;\n}\n\ninterface CleanupResult {\n  id: string;\n  timestamp: string;\n  operation: string;\n  success: boolean;\n  details: Record<string, unknown>;\n}\n\ninterface RunScheduledOptions {\n  scheduleId: string;\n}\n\ninterface RunImmediateOptions {\n  operations?: string[];\n  batchSize?: number;\n  dryRun?: boolean;\n}\n\ninterface ScheduleCleanupOptions {\n  name: string;\n  operations: string[];\n  schedule: string;\n  enabled?: boolean;\n}\n\ninterface UpdateScheduleOptions {\n  scheduleId: string;\n  updates: Record<string, unknown>;\n}\n\ninterface DeleteScheduleOptions {\n  scheduleId: string;\n}\n\ninterface AnalyzeDuplicatesOptions {\n  threshold?: number;\n}\n\ninterface AutomatedCleanupStatus {\n  isRunning: boolean;\n  lastRun: string | null;\n  nextScheduledRun: string | null;\n  schedules: CleanupSchedule[];\n  recentResults: CleanupResult[];\n  statistics: {\n    totalRuns: number;\n    successfulRuns: number;\n    failedRuns: number;\n    trucksImproved: number;\n    duplicatesRemoved: number;\n  };\n}\n\ntype CleanupOperationType =\n  | 'normalize_phone'\n  | 'fix_coordinates'\n  | 'remove_placeholders'\n  | 'update_quality_scores'\n  | 'merge_duplicates';\n\n/**\n * Verifies if the requester has admin access based on the authorization header.\n * @example\n * verifyAdminAccess(request)\n * Returns true if user is an admin, otherwise false.\n * @param {NextRequest} request - The request object containing headers for authorization.\n * @returns {Promise<boolean>} Returns a promise resolving to true if the user has admin access, false otherwise.\n * @description\n *   - Uses Supabase for validating and retrieving user information from a token.\n *   - Assumes a 'Bearer' token structure for the authorization header.\n *   - Checks for existence of a Supabase admin client before querying for user roles.\n *   - Handles any errors silently by returning false.\n */\nexport async function verifyAdminAccess(request: NextRequest): Promise<boolean> {\n  try {\n    const authHeader = request.headers.get('authorization');\n    if (authHeader?.startsWith('Bearer ') !== true) {\n      return false;\n    }\n\n    const token = authHeader.slice(7);\n    const { data, error: authError } = await supabase.auth.getUser(token);\n\n    if (authError || !data?.user) {\n      return false;\n    }\n\n    const user = data.user;\n\n    if (!supabaseAdmin) {\n      return false;\n    }\n\n    const { data: profile } = await supabaseAdmin\n      .from('profiles')\n      .select('role')\n      .eq('id', user.id)\n      .single();\n\n    return profile?.role === 'admin';\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Handles post requests by executing specific actions based on the provided body.\n * @example\n * handlePostRequest({ action: 'run_scheduled', options: { key: 'value' } })\n * Returns the result of executing handleRunScheduled with the provided options.\n * @param {Object} body - The body of the request containing action type and optional parameters.\n * @param {string} body.action - The action to perform such as 'run_scheduled', 'update_schedule', etc.\n * @param {Object} [body.options] - Optional parameters for the specified action, default is an empty object.\n * @returns {Promise<Object>} Resolves with the result of the corresponding action handler or an error object for unknown actions.\n * @description\n *   - Supports multiple predefined actions like scheduling, running, and cleanup operations.\n *   - Provides feedback on available actions when an unknown action is specified.\n *   - Uses async functions to perform operations, ensuring asynchronous behavior.\n *   - Returns JSON responses compliant with NextResponse standards.\n */\nexport async function handlePostRequest(body: {\n  action: string;\n  options?: Record<string, unknown>;\n}) {\n  const { action, options = {} } = body;\n\n  switch (action) {\n    case 'run_scheduled': {\n      return await handleRunScheduled(options);\n    }\n    case 'run_immediate': {\n      return await handleRunImmediate(options);\n    }\n    case 'schedule_cleanup': {\n      return await handleScheduleCleanup(options);\n    }\n    case 'update_schedule': {\n      return await handleUpdateSchedule(options);\n    }\n    case 'delete_schedule': {\n      return await handleDeleteSchedule(options);\n    }\n    case 'analyze_duplicates': {\n      return await handleAnalyzeDuplicates(options);\n    }\n    default: {\n      return NextResponse.json(\n        {\n          success: false,\n          error: 'Unknown action',\n          available_actions: [\n            'run_scheduled',\n            'run_immediate',\n            'schedule_cleanup',\n            'update_schedule',\n            'delete_schedule',\n            'analyze_duplicates',\n          ],\n        },\n        { status: 400 },\n      );\n    }\n  }\n}\n\nexport async function handleGetStatus(): Promise<NextResponse> {\n  const status = await getCleanupStatus();\n  return NextResponse.json({\n    success: true,\n    status,\n  });\n}\n\nexport async function handleGetSchedules(): Promise<NextResponse> {\n  const schedules = await getCleanupSchedules();\n  return NextResponse.json({\n    success: true,\n    schedules,\n  });\n}\n\nexport async function handleGetHistory(searchParams: URLSearchParams): Promise<NextResponse> {\n  const limit = Number.parseInt(searchParams.get('limit') ?? '10', 10);\n  const history = await getCleanupHistory(limit);\n  return NextResponse.json({\n    success: true,\n    history,\n  });\n}\n\nexport async function handleGetPreview(searchParams: URLSearchParams): Promise<NextResponse> {\n  const operations = searchParams.get('operations')?.split(',') ?? [];\n  const preview = await previewCleanupOperations(operations);\n  return NextResponse.json({\n    success: true,\n    preview,\n  });\n}\n\n/**\n * Handles the retrieval of default cleanup status and returns a JSON response.\n * @example\n * handleGetDefault().then(response => console.log(response));\n * // { success: true, status: ..., endpoints: [...] }\n * @param {none} {none} - No arguments are required for this function.\n * @returns {Promise<NextResponse>} A promise that resolves to a NextResponse JSON object containing cleanup status and endpoints.\n * @description\n *   - Utilizes the getCleanupStatus function to fetch the current cleanup status.\n *   - Constructs a response object detailing available cleanup-related endpoints.\n *   - Follow API endpoint descriptions to properly utilize cleanup functionalities.\n */\nexport async function handleGetDefault(): Promise<NextResponse> {\n  const status = await getCleanupStatus();\n  return NextResponse.json({\n    success: true,\n    status,\n    endpoints: [\n      'GET ?action=status - Get overall cleanup status',\n      'GET ?action=schedules - Get cleanup schedules',\n      'GET ?action=history&limit=N - Get cleanup history',\n      'GET ?action=preview&operations=op1,op2 - Preview cleanup operations',\n      'POST - Run cleanup operations',\n    ],\n  });\n}\n\nexport async function handleRunScheduled(options: Record<string, unknown>): Promise<NextResponse> {\n  const { scheduleId } = options as RunScheduledOptions;\n  const result = await runScheduledCleanup(scheduleId);\n  return NextResponse.json({\n    success: true,\n    action: 'run_scheduled',\n    result,\n  });\n}\n\n/**\n* Executes a batch cleanup operation immediately based on provided options.\n* @example\n* handleRunImmediate({ dryRun: true, batchSize: 100 })\n* Returns: { success: true, action: 'run_immediate', result: {...}, message: 'Dry run completed successfully' }\n* @param {Object} options - Configuration options for the cleanup operation.\n* @returns {Promise<NextResponse>} A promise that resolves to the NextResponse object containing the cleanup result.\n* @description\n*   - The `operations` parameter defaults to a set of predefined cleanup tasks if not specified.\n*   - If `dryRun` is true, the function simulates the cleanup without making any modifications.\n*   - Utilizes `BatchCleanupService` for executing the cleanup logic.\n*   - Operation results are logged with `logCleanupOperation` for tracking purposes.\n*/\nexport async function handleRunImmediate(options: Record<string, unknown>): Promise<NextResponse> {\n  const {\n    operations = [\n      'remove_placeholders',\n      'normalize_phone',\n      'fix_coordinates',\n      'update_quality_scores',\n    ],\n    batchSize = 50,\n    dryRun = false,\n  } = options as RunImmediateOptions;\n\n  const result = await BatchCleanupService.runFullCleanup({\n    operations: operations as CleanupOperationType[],\n    batchSize,\n    dryRun,\n  });\n\n  await logCleanupOperation('immediate', result, options);\n\n  return NextResponse.json({\n    success: true,\n    action: 'run_immediate',\n    result,\n    message: dryRun ? 'Dry run completed successfully' : 'Cleanup completed successfully',\n  });\n}\n\nexport async function handleScheduleCleanup(\n  options: Record<string, unknown>,\n): Promise<NextResponse> {\n  const { name, operations, schedule, enabled = true } = options as ScheduleCleanupOptions;\n  const scheduleResult = await createCleanupSchedule(name, operations, schedule, enabled);\n  return NextResponse.json({\n    success: true,\n    action: 'schedule_cleanup',\n    result: scheduleResult,\n  });\n}\n\nexport async function handleUpdateSchedule(\n  options: Record<string, unknown>,\n): Promise<NextResponse> {\n  const { scheduleId, updates } = options as UpdateScheduleOptions;\n  const updateResult = await updateCleanupSchedule(scheduleId, updates);\n  return NextResponse.json({\n    success: true,\n    action: 'update_schedule',\n    result: updateResult,\n  });\n}\n\nexport async function handleDeleteSchedule(\n  options: Record<string, unknown>,\n): Promise<NextResponse> {\n  const { scheduleId } = options as DeleteScheduleOptions;\n  const deleteResult = await deleteCleanupSchedule(scheduleId);\n  return NextResponse.json({\n    success: true,\n    action: 'delete_schedule',\n    result: deleteResult,\n  });\n}\n\nexport async function handleAnalyzeDuplicates(\n  options: Record<string, unknown>,\n): Promise<NextResponse> {\n  const { threshold = 0.8 } = options as AnalyzeDuplicatesOptions;\n  const analysis = await analyzeDuplicates(threshold);\n  return NextResponse.json({\n    success: true,\n    action: 'analyze_duplicates',\n    result: analysis,\n  });\n}\n\n/**\n * Retrieves the status of automated cleanup operations.\n * @example\n * getCleanupStatus()\n * // returns: Promise<AutomatedCleanupStatus>\n * @returns {Promise<AutomatedCleanupStatus>} An object representing the status of cleanup operations.\n * @description\n *   - The status includes statistics on cleanup runs such as total number of runs, successful runs, and failed runs.\n *   - Provides information on whether a cleanup operation is currently running and when it last ran.\n *   - Fetches schedules asynchronously using the getCleanupSchedules() function.\n *   - Includes data on recent cleanup results and operations performed, such as the number of trucks improved and duplicates removed.\n */\nasync function getCleanupStatus(): Promise<AutomatedCleanupStatus> {\n  return {\n    isRunning: false,\n    lastRun: new Date(Date.now() - 3_600_000).toISOString(),\n    nextScheduledRun: new Date(Date.now() + 3_600_000).toISOString(),\n    schedules: await getCleanupSchedules(),\n    recentResults: [],\n    statistics: {\n      totalRuns: 42,\n      successfulRuns: 40,\n      failedRuns: 2,\n      trucksImproved: 156,\n      duplicatesRemoved: 23,\n    },\n  };\n}\n\n/**\n * Retrieves the scheduled cleanup operations including their details.\n * @example\n * getCleanupSchedules()\n * Promise resolves to an array of cleanup schedule objects.\n * @returns {Promise<CleanupSchedule[]>} Promise resolving to an array of cleanup schedule objects.\n * @description\n *   - Schedules are defined using cron-like syntax for timing.\n *   - Both daily and weekly cleanup operations are included.\n *   - Each schedule has a record of success and error counts from the last execution.\n *   - Enabled status indicates if the schedule is currently active.\n */\nfunction getCleanupSchedules(): Promise<CleanupSchedule[]> {\n  return Promise.resolve([\n    {\n      id: 'daily-maintenance',\n      name: 'Daily Maintenance Cleanup',\n      operations: ['remove_placeholders', 'normalize_phone', 'update_quality_scores'],\n      schedule: '0 2 * * *',\n      enabled: true,\n      lastRun: new Date(Date.now() - 86_400_000).toISOString(),\n      nextRun: new Date(Date.now() + 3_600_000).toISOString(),\n      successCount: 30,\n      errorCount: 1,\n    },\n    {\n      id: 'weekly-deep-clean',\n      name: 'Weekly Deep Cleanup',\n      operations: [\n        'remove_placeholders',\n        'normalize_phone',\n        'fix_coordinates',\n        'update_quality_scores',\n        'merge_duplicates',\n      ],\n      schedule: '0 3 * * 0',\n      enabled: true,\n      lastRun: new Date(Date.now() - 604_800_000).toISOString(),\n      nextRun: new Date(Date.now() + 259_200_000).toISOString(),\n      successCount: 4,\n      errorCount: 0,\n    },\n  ]);\n}\n\nfunction getCleanupHistory(_limit: number): Promise<CleanupResult[]> {\n  return Promise.resolve([]);\n}\n\ninterface PreviewResult {\n  estimatedChanges: Record<string, unknown>;\n  operationDetails: Record<string, unknown>;\n  estimatedDuration: number;\n  affectedTrucks: number;\n}\n\n/**\n * Generates a preview of cleanup operations and their estimated impact.\n * @example\n * previewCleanupOperations(['delete_logs', 'archive_data'])\n * // Returns a Promise resolving to an object with estimated changes and operation details\n * @param {string[]} operations - An array of cleanup operation names to preview.\n * @returns {Promise<PreviewResult>} A promise that resolves to a preview result containing estimated changes and details.\n * @description\n *   - The function uses BatchCleanupService to simulate cleanup operations in a dry-run mode.\n *   - Each operation's details include types, descriptions, and counts of affected, successful, and erroneous items.\n *   - Returns comprehensive information including estimated changes, durations, and affected entities.\n */\nasync function previewCleanupOperations(operations: string[]): Promise<PreviewResult> {\n  try {\n    const result = await BatchCleanupService.runFullCleanup({\n      operations: operations as CleanupOperationType[],\n      batchSize: 10,\n      dryRun: true,\n    });\n\n    return {\n      estimatedChanges: result.summary as Record<string, unknown>,\n      operationDetails: (() => {\n        const details: Record<string, unknown> = {};\n        for (const [index, op] of result.operations.entries()) {\n          details[`operation_${index}`] = {\n            type: op.type,\n            description: op.description,\n            affectedCount: op.affectedCount,\n            successCount: op.successCount,\n            errorCount: op.errorCount,\n          };\n        }\n        return details;\n      })(),\n      estimatedDuration: result.duration,\n      affectedTrucks: result.totalProcessed,\n    };\n  } catch (error) {\n    throw new Error(`Preview failed: ${error instanceof Error ? error.message : 'Unknown error'}`);\n  }\n}\n\n/**\n * Executes a cleanup based on a given schedule ID.\n * @example\n * runScheduledCleanup('schedule123')\n * { success: true, cleanedRecords: 150 }\n * @param {string} scheduleId - The ID of the cleanup schedule to run.\n * @returns {Promise<Record<string, unknown>>} Result of the cleanup operation.\n * @description\n *   - Throws an error if the schedule is not found or is disabled.\n *   - Utilizes BatchCleanupService for performing the cleanup operation.\n *   - Logs the result of the cleanup operation with a 'scheduled' context.\n */\nasync function runScheduledCleanup(scheduleId: string): Promise<Record<string, unknown>> {\n  const schedules = await getCleanupSchedules();\n  const schedule = schedules.find((s) => s.id === scheduleId);\n\n  if (!schedule) {\n    throw new Error(`Schedule ${scheduleId} not found`);\n  }\n\n  if (!schedule.enabled) {\n    throw new Error(`Schedule ${scheduleId} is disabled`);\n  }\n\n  const result = await BatchCleanupService.runFullCleanup({\n    operations: schedule.operations as CleanupOperationType[],\n    batchSize: 50,\n    dryRun: false,\n  });\n\n  await logCleanupOperation('scheduled', result, { scheduleId });\n\n  return result as Record<string, unknown>;\n}\n\ninterface ScheduleCreateResult {\n  id: string;\n  name: string;\n  operations: string[];\n  schedule: string;\n  enabled: boolean;\n  created: string;\n}\n\ninterface ScheduleUpdateResult {\n  scheduleId: string;\n  updates: Record<string, unknown>;\n  updated: string;\n}\n\ninterface ScheduleDeleteResult {\n  scheduleId: string;\n  deleted: string;\n}\n\ninterface DuplicateAnalysisResult {\n  threshold: number;\n  potentialDuplicates: number;\n  highConfidenceMatches: number;\n  mediumConfidenceMatches: number;\n  lowConfidenceMatches: number;\n  analysisTime: string;\n}\n\n/**\n* Creates a cleanup schedule with the specified parameters\n* @example\n* createCleanupSchedule('Daily Cleanup', ['delete', 'archive'], '0 0 * * *', true)\n* Promise<ScheduleCreateResult> { id: 'schedule-1609459200000', name: 'Daily Cleanup', operations: ['delete', 'archive'], schedule: '0 0 * * *', enabled: true, created: '2021-01-01T00:00:00.000Z' }\n* @param {string} name - The name of the cleanup schedule.\n* @param {Array<string>} operations - List of operations to be included in the cleanup.\n* @param {string} schedule - Cron-style string for schedule timings.\n* @param {boolean} enabled - Status of whether the schedule is active.\n* @returns {Promise<ScheduleCreateResult>} Promise resolving to the details of the created schedule.\n* @description \n*   - Returns a Promise that resolves to a ScheduleCreateResult object.\n*   - Automatically generates a unique ID based on the current timestamp.\n*   - Includes a creation timestamp in ISO format.\n*/\nfunction createCleanupSchedule(\n  name: string,\n  operations: string[],\n  schedule: string,\n  enabled: boolean,\n): Promise<ScheduleCreateResult> {\n  return Promise.resolve({\n    id: `schedule-${Date.now()}`,\n    name,\n    operations,\n    schedule,\n    enabled,\n    created: new Date().toISOString(),\n  });\n}\n\nfunction updateCleanupSchedule(\n  scheduleId: string,\n  updates: Record<string, unknown>,\n): Promise<ScheduleUpdateResult> {\n  return Promise.resolve({\n    scheduleId,\n    updates,\n    updated: new Date().toISOString(),\n  });\n}\n\nfunction deleteCleanupSchedule(scheduleId: string): Promise<ScheduleDeleteResult> {\n  return Promise.resolve({\n    scheduleId,\n    deleted: new Date().toISOString(),\n  });\n}\n\n/**\n* Analyzes duplicates based on a given threshold and returns a summary of the analysis.\n* @example\n* analyzeDuplicates(0.8)\n* // Returns: { threshold: 0.8, potentialDuplicates: 0, highConfidenceMatches: 0, mediumConfidenceMatches: 0, lowConfidenceMatches: 0, analysisTime: \"2023-10-01T12:34:56.789Z\" }\n* @param {number} threshold - The threshold value used to determine duplicate matching confidence.\n* @returns {Promise<DuplicateAnalysisResult>} An object representing the duplicate analysis results including counts of potential matches and confidence levels.\n* @description\n*   - Executes the analysis asynchronously, returning a promise that resolves with the analysis results.\n*   - Initializes match counts to zero as defaults.\n*   - Includes the analysis time formatted as an ISO string.\n*/\nfunction analyzeDuplicates(threshold: number): Promise<DuplicateAnalysisResult> {\n  try {\n    return Promise.resolve({\n      threshold,\n      potentialDuplicates: 0,\n      highConfidenceMatches: 0,\n      mediumConfidenceMatches: 0,\n      lowConfidenceMatches: 0,\n      analysisTime: new Date().toISOString(),\n    });\n  } catch (error) {\n    throw new Error(\n      `Duplicate analysis failed: ${error instanceof Error ? error.message : 'Unknown error'}`,\n    );\n  }\n}\n\n/**\n * Logs the completion details of a cleanup operation.\n * @example\n * logCleanupOperation('database', {summary: {success: true}}, {verbose: true})\n * // No return value\n * @param {string} type - The type of cleanup operation performed (e.g., 'database').\n * @param {Record<string, unknown>} result - An object containing the results of the cleanup operation.\n * @param {Record<string, unknown>} options - Additional options related to the logging of the cleanup.\n * @returns {Promise<void>} A Promise that resolves when the logging is complete.\n * @description\n *   - Utilizes `console.info` for successful logging and `console.warn` for handling errors during logging.\n *   - Ensures the operation's details include the type, result summary, options, and a timestamp.\n */\nfunction logCleanupOperation(\n  type: string,\n  result: Record<string, unknown>,\n  options: Record<string, unknown>,\n): Promise<void> {\n  try {\n    console.info(`Cleanup operation completed:`, {\n      type,\n      result: result.summary as Record<string, unknown>,\n      options,\n      timestamp: new Date().toISOString(),\n    });\n    return Promise.resolve();\n  } catch (error) {\n    console.warn('Failed to log cleanup operation:', error);\n    return Promise.resolve();\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\api\\admin\\automated-cleanup\\types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\api\\admin\\data-cleanup\\handlers.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\api\\admin\\data-quality\\handlers.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":26,"column":12,"nodeType":"Identifier","messageId":"conditionErrorNullableString","endLine":26,"endColumn":19,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[1169,1177],"text":"truckId == null"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[1170,1177],"text":"(truckId ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[1169,1177],"text":"!Boolean(truckId)"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":261,"column":10,"nodeType":"Identifier","messageId":"conditionErrorNullableString","endLine":261,"endColumn":20,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[9582,9593],"text":"authHeader == null"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[9583,9593],"text":"(authHeader ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[9582,9593],"text":"!Boolean(authHeader)"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { NextRequest, NextResponse } from 'next/server';\r\nimport { FoodTruckService, supabase, FoodTruck } from '@/lib/supabase';\r\n\r\n/**\r\n * Handles GET requests by executing different actions based on query parameters.\r\n * @example\r\n * handleGetRequest(request)\r\n * Returns a response based on the action specified in the query parameters.\r\n * @param {NextRequest} request - The incoming request object containing URL and query parameters.\r\n * @returns {Promise<NextResponse>} A Promise resolving to a NextResponse object with the result of the action.\r\n * @description\r\n *   - Processes 'stats', 'assess', and defaults actions based on the 'action' query parameter.\r\n *   - Requires 'truckId' for the 'assess' action; otherwise, returns a 400 error.\r\n *   - Utilizes async handling for processing actions.\r\n */\r\nexport async function handleGetRequest(request: NextRequest): Promise<NextResponse> {\r\n  const { searchParams } = new URL(request.url);\r\n  const action = searchParams.get('action');\r\n  const truckId = searchParams.get('truckId');\r\n\r\n  switch (action) {\r\n    case 'stats': {\r\n      return await handleStatsAction();\r\n    }\r\n    case 'assess': {\r\n      if (!truckId) {\r\n        return NextResponse.json(\r\n          { success: false, error: 'Missing truckId for assess action' },\r\n          { status: 400 },\r\n        );\r\n      }\r\n      return await handleAssessAction(truckId);\r\n    }\r\n    default: {\r\n      return await handleDefaultGetAction();\r\n    }\r\n  }\r\n}\r\n\r\ninterface PostRequestBody {\r\n  action: string;\r\n  truckId?: string;\r\n}\r\n\r\n/**\r\n* Handles different types of POST requests by determining the action and executing appropriate functions.\r\n* @example\r\n* handlePostRequest(request)\r\n* NextResponse containing success status and result or error message\r\n* @param {NextRequest} request - Incoming request object containing body data as JSON.\r\n* @returns {Promise<NextResponse>} Response indicating success or failure and any relevant data or error messages.\r\n* @description\r\n*   - Validates request body to ensure it's a non-null object.\r\n*   - Extracts action and truckId from request body to decide on processing steps.\r\n*   - Handles actions like \"update-single\", \"batch-update\", and \"recalculate-all\", returning an appropriate NextResponse.\r\n*   - Responds with an error JSON if the action is unknown or if required fields are missing.\r\n*/\r\nexport async function handlePostRequest(request: NextRequest): Promise<NextResponse> {\r\n  const body: unknown = await request.json();\r\n\r\n  if (typeof body !== 'object' || body === null) {\r\n    return NextResponse.json({ success: false, error: 'Invalid request body' }, { status: 400 });\r\n  }\r\n\r\n  const { action, truckId } = body as PostRequestBody;\r\n\r\n  switch (action) {\r\n    case 'update-single': {\r\n      if (truckId === undefined || truckId === '') {\r\n        return NextResponse.json(\r\n          { success: false, error: 'Missing truckId for update-single action' },\r\n          { status: 400 },\r\n        );\r\n      }\r\n      return await handleUpdateSingle(truckId);\r\n    }\r\n    case 'batch-update': {\r\n      return handleBatchUpdate();\r\n    }\r\n    case 'recalculate-all': {\r\n      return await handleRecalculateAll();\r\n    }\r\n    default: {\r\n      return NextResponse.json(\r\n        { success: false, error: `Unknown action: ${action}` },\r\n        { status: 400 },\r\n      );\r\n    }\r\n  }\r\n}\r\n\r\nasync function handleStatsAction() {\r\n  const qualityStats = await FoodTruckService.getDataQualityStats();\r\n\r\n  return NextResponse.json({\r\n    success: true,\r\n    data: {\r\n      ...qualityStats,\r\n      timestamp: new Date().toISOString(),\r\n    },\r\n  });\r\n}\r\n\r\n/**\r\n * Processes and returns the assessment result of a food truck action by its ID.\r\n * @example\r\n * handleAssessAction(\"12345\")\r\n * { success: true, data: { truckId: \"12345\", truckName: \"Best Food Truck\", currentScore: 95, timestamp: \"2023-10-05T14:48:00.000Z\" } }\r\n * @param {string} truckId - The identifier of the food truck to be assessed.\r\n * @returns {object} Returns a JSON response containing either the assessment data or an error.\r\n * @description\r\n *   - Retrieves data of the specified food truck using FoodTruckService.\r\n *   - Casts the retrieved data explicitly to a FoodTruck object type to ensure type safety.\r\n *   - Responds with a 404 status and the error description if the truck is not found.\r\n */\r\nasync function handleAssessAction(truckId: string) {\r\n  const truckResult = await FoodTruckService.getTruckById(truckId);\r\n\r\n  if ('error' in truckResult) {\r\n    return NextResponse.json({ success: false, error: truckResult.error }, { status: 404 });\r\n  }\r\n\r\n  const truck: FoodTruck = truckResult; // Explicitly cast to FoodTruck\r\n\r\n  return NextResponse.json({\r\n    success: true,\r\n    data: {\r\n      truckId,\r\n      truckName: truck.name,\r\n      currentScore: truck.data_quality_score,\r\n      timestamp: new Date().toISOString(),\r\n    },\r\n  });\r\n}\r\n\r\nasync function handleDefaultGetAction() {\r\n  const qualityStats = await FoodTruckService.getDataQualityStats();\r\n  return NextResponse.json({\r\n    success: true,\r\n    data: qualityStats,\r\n  });\r\n}\r\n\r\n/**\r\n * Handles updating a single food truck's quality score and returns the result.\r\n * @example\r\n * handleUpdateSingle(\"1234\")\r\n * { success: true, message: 'Quality score updated successfully', data: { truckId: '1234', truckName: 'Food Truck A', newScore: 95, verificationStatus: 'verified', timestamp: '2023-10-30T14:48:00.000Z' } }\r\n * @param {string} truckId - The unique identifier of the food truck to update.\r\n * @returns {Object} An object containing the success status, message, and either updated truck data or error information.\r\n * @description\r\n *   - Utilizes `FoodTruckService.getTruckById` to fetch truck details.\r\n *   - Responds differently based on whether an error is encountered or not.\r\n *   - Formats the response appropriately for successful updates.\r\n *   - Includes a timestamp in the response when successful.\r\n */\r\nasync function handleUpdateSingle(truckId: string) {\r\n  const updatedTruckResult = await FoodTruckService.getTruckById(truckId);\r\n\r\n  if ('error' in updatedTruckResult) {\r\n    return NextResponse.json({ success: false, error: updatedTruckResult.error }, { status: 404 });\r\n  }\r\n\r\n  const updatedTruck = updatedTruckResult;\r\n\r\n  return NextResponse.json({\r\n    success: true,\r\n    message: 'Quality score updated successfully',\r\n    data: {\r\n      truckId: updatedTruck.id,\r\n      truckName: updatedTruck.name,\r\n      newScore: updatedTruck.data_quality_score,\r\n      verificationStatus: updatedTruck.verification_status,\r\n      timestamp: new Date().toISOString(),\r\n    },\r\n  });\r\n}\r\n\r\nfunction handleBatchUpdate() {\r\n  return NextResponse.json({\r\n    success: true,\r\n    message: 'Batch quality score update completed',\r\n    data: {\r\n      timestamp: new Date().toISOString(),\r\n    },\r\n  });\r\n}\r\n\r\nfunction updateSingleTruckQualityScore(truck: { id: string }): boolean {\r\n  try {\r\n    // Placeholder for actual update logic if needed\r\n    // DataQualityService.updateTruckQualityScore(truck.id);\r\n    return true;\r\n  } catch (error: unknown) {\r\n    console.error(`Failed to update truck ${truck.id}:`, error);\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * Recalculates the quality score for all food trucks.\r\n * @example\r\n * handleRecalculateAll()\r\n * { success: true, message: 'Quality score recalculation completed', data: { totalTrucks: 100, updated: 95, errors: 5, timestamp: '2023-10-07T10:30:00.000Z' } }\r\n * @param {undefined} undefined - No arguments are needed.\r\n * @returns {Object} JSON response with success status, message, and data containing recalculation statistics.\r\n * @description\r\n *   - Fetches all food trucks in batches for recalculation using the FoodTruckService.\r\n *   - Logs an error message if the API call to fetch all trucks fails.\r\n *   - Updates the `qualityScore` for each truck and maintains a count of successful and unsuccessful updates.\r\n */\r\nasync function handleRecalculateAll() {\r\n  const allTrucksResult = await FoodTruckService.getAllTrucks(1000, 0);\r\n  if (allTrucksResult.error !== undefined) {\r\n    console.error('Error fetching all trucks for recalculation:', allTrucksResult.error);\r\n    return NextResponse.json(\r\n      { success: false, error: 'Failed to fetch trucks for recalculation' },\r\n      { status: 500 },\r\n    );\r\n  }\r\n  const { trucks } = allTrucksResult;\r\n  let updated = 0;\r\n  let errors = 0;\r\n\r\n  for (const truck of trucks) {\r\n    const success = updateSingleTruckQualityScore(truck);\r\n    if (success) {\r\n      updated+=1;\r\n    } else {\r\n      errors+=1;\r\n    }\r\n  }\r\n\r\n  return NextResponse.json({\r\n    success: true,\r\n    message: 'Quality score recalculation completed',\r\n    data: {\r\n      totalTrucks: trucks.length,\r\n      updated,\r\n      errors,\r\n      timestamp: new Date().toISOString(),\r\n    },\r\n  });\r\n}\r\n\r\n/**\r\n * Checks if the request has valid admin access.\r\n * @example\r\n * verifyAdminAccess(request)\r\n * true\r\n * @param {Request} request - The incoming request object containing headers with authorization token.\r\n * @returns {Promise<boolean>} Returns true if the user has admin role, otherwise false.\r\n * @description\r\n *   - Retrieves the authorization token from request headers and validates the user through Supabase.\r\n *   - Checks the user's role from the 'profiles' table to determine admin access.\r\n *   - Returns false if the authorization header is missing or the user validation fails.\r\n */\r\nexport async function verifyAdminAccess(request: Request): Promise<boolean> {\r\n  try {\r\n    const authHeader = request.headers.get('authorization');\r\n    if (!authHeader) return false;\r\n\r\n    const token = authHeader.replace('Bearer ', '');\r\n    const { data, error } = await supabase.auth.getUser(token);\r\n    const user = data?.user;\r\n\r\n    if (error || !user) return false;\r\n\r\n    const { data: profile } = await supabase\r\n      .from('profiles')\r\n      .select('role')\r\n      .eq('id', user.id)\r\n      .single();\r\n\r\n    return profile?.role === 'admin';\r\n  } catch {\r\n    return false;\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\api\\admin\\oauth-status\\helpers.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":334,"column":7,"nodeType":"ChainExpression","messageId":"conditionErrorNullableBoolean","endLine":334,"endColumn":50,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[13701,13744],"text":"((status.supabase.authSettings?.googleEnabled) ?? false)"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[13701,13744],"text":"((status.supabase.authSettings?.googleEnabled) === true)"},"desc":"Change condition to check if true (`value === true`)"}]}],"suppressedMessages":[{"ruleId":"sonarjs/different-types-comparison","severity":2,"message":"Remove this \"!==\" check; it will always be true. Did you mean to use \"!=\"?","line":325,"column":59,"nodeType":null,"endLine":325,"endColumn":62,"suggestions":[{"desc":"Replace \"!==\" with \"!=\"","fix":{"range":[13503,13506],"text":"!="}}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { NextRequest, NextResponse } from 'next/server';\r\nimport { supabase } from '@/lib/supabase';\r\nimport { OAuthStatus } from './types';\r\nimport type { SupabaseClient } from '@supabase/supabase-js';\r\n\r\n/**\r\n * Handles a GET request to retrieve OAuth configuration status.\r\n * @example\r\n * handleGetRequest(request)\r\n * Returns a JSON response with OAuth status details and legacy format.\r\n * @param {NextRequest} _request - The incoming request object.\r\n * @returns {NextResponse} JSON response indicating the current OAuth status.\r\n * @description\r\n *   - Retrieves the current OAuth configuration status from the server.\r\n *   - Adapts the response to include both modern and legacy format details.\r\n *   - Provides a step-by-step legacy configuration guide if OAuth is not ready.\r\n */\r\nexport async function handleGetRequest(_request: NextRequest) {\r\n  const status = await getOAuthStatus();\r\n\r\n  return NextResponse.json({\r\n    success: true,\r\n    ...status,\r\n    legacy_format: {\r\n      oauth_status: status.overall_status,\r\n      message: getStatusMessage(status.overall_status),\r\n      configuration_steps:\r\n        status.overall_status === 'ready'\r\n          ? undefined\r\n          : [\r\n              '1. Go to Supabase Dashboard > Authentication > Providers',\r\n              '2. Enable Google provider',\r\n              '3. Add Google OAuth Client ID and Secret',\r\n              '4. Configure redirect URLs',\r\n              '5. Test OAuth flow',\r\n            ],\r\n    },\r\n  });\r\n}\r\n\r\n// 1. Refactor nested template literals in generateOAuthTestUrl\r\nfunction generateOAuthTestUrl(baseUrl: string): string {\r\n  const redirectPath = `${baseUrl}/auth/callback`;\r\n  const encodedRedirect = encodeURIComponent(redirectPath);\r\n  return (\r\n    process.env.NEXT_PUBLIC_SUPABASE_URL +\r\n    '/auth/v1/authorize?provider=google&redirect_to=' +\r\n    encodedRedirect\r\n  );\r\n}\r\n\r\n/**\r\n * Handles a post request to generate an OAuth test URL based on the environment.\r\n * @example\r\n * handlePostRequest()\r\n * {\r\n *   success: true,\r\n *   message: 'OAuth test URL generated',\r\n *   test_url: 'http://localhost:3000/...',\r\n *   environment: 'development',\r\n *   instructions: [ ... ],\r\n *   manual_test_steps: [ ... ],\r\n *   automation_commands: [ ... ]\r\n * }\r\n * @returns {object} An object containing success status, message, the test URL, the environment, instructions, manual test steps, and automation commands.\r\n * @description\r\n *   - Determines the base URL depending on whether the environment is production or development.\r\n *   - Utilizes `generateOAuthTestUrl` to construct the OAuth test URL.\r\n *   - Responds with JSON containing test instructions and automation commands for verifying OAuth functionality.\r\n */\r\nexport function handlePostRequest() {\r\n  // Removed _request parameter\r\n  const baseUrl =\r\n    process.env.NODE_ENV === 'production'\r\n      ? 'https://food-truck-finder-poc-git-feat-s-20ec1c-codedeficients-projects.vercel.app'\r\n      : 'http://localhost:3000';\r\n\r\n  const testUrl = generateOAuthTestUrl(baseUrl);\r\n\r\n  return NextResponse.json({\r\n    success: true,\r\n    message: 'OAuth test URL generated',\r\n    test_url: testUrl,\r\n    environment: process.env.NODE_ENV ?? 'development',\r\n    instructions: [\r\n      '1. Open the test_url in a new browser tab',\r\n      '2. Complete Google OAuth flow',\r\n      '3. Verify redirect to admin dashboard',\r\n      '4. Check for proper role assignment',\r\n    ],\r\n    manual_test_steps: [\r\n      'Navigate to /login page',\r\n      'Click Google login button',\r\n      'Complete OAuth flow',\r\n      'Verify admin access',\r\n    ],\r\n    automation_commands: [\r\n      'npm run oauth:verify - Check configuration',\r\n      'npm run oauth:test:dev - Test development flow',\r\n      'npm run oauth:test:prod - Test production flow',\r\n    ],\r\n  });\r\n}\r\n\r\n/**\r\n * Retrieves the current OAuth status including configuration and connectivity information.\r\n * @example\r\n * getOAuthStatus().then(status => {\r\n *   console.log(status);\r\n * });\r\n * // Output: OAuthStatus object with current configuration and connection status details\r\n * @returns {Promise<OAuthStatus>} An object representing the current status of OAuth configuration and connectivity.\r\n * @description\r\n *   - The function assesses the connectivity and configuration of Supabase and its authentication settings.\r\n *   - It checks if the necessary environment variables are set.\r\n *   - Executes a series of asynchronous checks to determine if the OAuth provider is properly configured.\r\n *   - Recommendations for improving the OAuth setup are generated based on the current status.\r\n */\r\nasync function getOAuthStatus(): Promise<OAuthStatus> {\r\n  const status: OAuthStatus = {\r\n    timestamp: new Date().toISOString(),\r\n    environment: process.env.NODE_ENV === 'production' ? 'production' : 'development',\r\n    supabase: {\r\n      connected: false,\r\n      projectId: 'zkwliyjjkdnigizidlln' as string,\r\n    },\r\n    environment_variables: {\r\n      supabaseUrl: process.env.NEXT_PUBLIC_SUPABASE_URL !== undefined,\r\n      supabaseAnonKey: process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY !== undefined,\r\n      supabaseServiceKey: process.env.SUPABASE_SERVICE_ROLE_KEY !== undefined,\r\n    },\r\n    oauth_flow: {\r\n      loginPageExists: true,\r\n      callbackRouteExists: true,\r\n      authProviderConfigured: false,\r\n    },\r\n    recommendations: [],\r\n    overall_status: 'not_configured',\r\n  };\r\n\r\n  await checkSupabaseConnection(status, supabase);\r\n  await checkSupabaseAuthSettings(status);\r\n  await testOAuthProvider(status, supabase);\r\n\r\n  status.recommendations = generateRecommendations(status);\r\n  status.overall_status = determineOverallStatus(status);\r\n\r\n  return status;\r\n}\r\n\r\n/**\r\n * Checks the connection status with Supabase and updates the `OAuthStatus`.\r\n * @example\r\n * checkSupabaseConnection(status, supabase)\r\n * // Updates the `status.supabase.connected` property based on connection success\r\n * @param {OAuthStatus} status - The current OAuthStatus object that tracks connection state and errors.\r\n * @param {SupabaseClient} supabase - The Supabase client instance used to interact with the database.\r\n * @returns {void} No explicit return value, operates directly on the `status` object.\r\n * @description\r\n *   - Attempts a query to the 'profiles' table to ensure Supabase connection.\r\n *   - Updates `status.supabase.connected` based on query success.\r\n *   - Captures and records detailed error messages in case of connection failure.\r\n */\r\nasync function checkSupabaseConnection(status: OAuthStatus, supabase: SupabaseClient) {\r\n  try {\r\n    const { error } = await supabase.from('profiles').select('count').limit(1);\r\n    if (error === null) {\r\n      status.supabase.connected = true;\r\n    } else {\r\n      status.supabase.error = error.message;\r\n    }\r\n  } catch (error: unknown) {\r\n    status.supabase.error = error instanceof Error ? error.message : 'Unknown connection error';\r\n  }\r\n}\r\n\r\n/**\r\n * Checks and processes Supabase authentication settings.\r\n * @example\r\n * checkSupabaseAuthSettings(oAuthStatusInstance)\r\n * { supabase: { authSettings: { googleEnabled: true, signupEnabled: false, autoconfirm: true } } }\r\n * @param {OAuthStatus} status - An object that holds OAuth configuration status.\r\n * @returns {void} Modifies the passed status object with fetched authentication settings.\r\n * @description\r\n *   - The function fetches authentication settings from the Supabase URL defined in environment variables.\r\n *   - If Supabase settings are fetched successfully, it updates the OAuth status with authentication settings like Google integration, signup availability, and autoconfirm feature.\r\n *   - Provides a fallback log for cases where fetching settings require authentication.\r\n */\r\nasync function checkSupabaseAuthSettings(status: OAuthStatus) {\r\n  try {\r\n    const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;\r\n    if (typeof supabaseUrl === 'string' && supabaseUrl.length > 0) {\r\n      // Explicit check for undefined and empty string\r\n      const settingsResponse = await fetch(`${supabaseUrl}/auth/v1/settings`);\r\n      if (settingsResponse.ok === true) {\r\n        const settings: {\r\n          external?: { google?: boolean };\r\n          disable_signup?: boolean;\r\n          autoconfirm?: boolean;\r\n        } = (await settingsResponse.json()) as {\r\n          external?: { google?: boolean };\r\n          disable_signup?: boolean;\r\n          autoconfirm?: boolean;\r\n        };\r\n        status.supabase.authSettings = {\r\n          googleEnabled: settings.external?.google ?? false,\r\n          signupEnabled: settings.disable_signup === false,\r\n          autoconfirm: settings.autoconfirm ?? false,\r\n        };\r\n        if (settings.external?.google !== undefined) {\r\n          // Explicit check for undefined\r\n          status.oauth_flow.authProviderConfigured = true;\r\n        }\r\n      }\r\n    }\r\n  } catch {\r\n    console.info('Auth settings endpoint requires authentication (normal)');\r\n  }\r\n}\r\n\r\n/**\r\n * Tests the configuration of an OAuth provider and updates the status based on the result.\r\n * @example\r\n * testOAuthProvider(status, supabase)\r\n * undefined\r\n * @param {OAuthStatus} status - An object representing the current OAuth status and configuration.\r\n * @param {SupabaseClient} supabase - The Supabase client instance used to interact with the authentication system.\r\n * @returns {void} Does not return any value.\r\n * @description\r\n *   - Utilizes Google as the OAuth provider for the sign-in attempt.\r\n *   - Redirects to a localhost callback URL to simulate the OAuth process.\r\n *   - Direct usage of the Supabase auth method to initiate OAuth process.\r\n *   - Handles exceptions without altering the control flow and logs them for informational purposes.\r\n */\r\nasync function testOAuthProvider(status: OAuthStatus, supabase: SupabaseClient) {\r\n  try {\r\n    const { error: oauthError } = await supabase.auth.signInWithOAuth({\r\n      provider: 'google',\r\n      options: {\r\n        redirectTo: 'http://localhost:3000/auth/callback',\r\n        skipBrowserRedirect: true,\r\n      },\r\n    });\r\n    if (oauthError !== null && oauthError.message !== 'Provider not found') {\r\n      // Explicitly check for oauthError existence\r\n      status.oauth_flow.authProviderConfigured = true;\r\n    }\r\n  } catch (error: unknown) {\r\n    console.info('OAuth provider test failed (may be normal):', error);\r\n  }\r\n}\r\n\r\n/**\r\n * Generates a list of recommendations for OAuth configuration based on the current status.\r\n * @example\r\n * generateRecommendations(status)\r\n * ['❌ Configure NEXT_PUBLIC_SUPABASE_URL environment variable', ...]\r\n * @param {OAuthStatus} status - The current status of OAuth configuration and environment variables.\r\n * @returns {string[]} Array of recommendation messages to guide configuration setup.\r\n * @description\r\n *   - Checks for necessary environment variables and Supabase connectivity.\r\n *   - Provides guidance on enabling Google OAuth.\r\n *   - Suggests consulting documentation for further setup instructions.\r\n */\r\nfunction generateRecommendations(status: OAuthStatus): string[] {\r\n  const recommendations: string[] = [];\r\n\r\n  if (!status.environment_variables.supabaseUrl) {\r\n    recommendations.push('❌ Configure NEXT_PUBLIC_SUPABASE_URL environment variable');\r\n  }\r\n  if (!status.environment_variables.supabaseAnonKey) {\r\n    recommendations.push('❌ Configure NEXT_PUBLIC_SUPABASE_ANON_KEY environment variable');\r\n  }\r\n  if (!status.environment_variables.supabaseServiceKey) {\r\n    recommendations.push('❌ Configure SUPABASE_SERVICE_ROLE_KEY environment variable');\r\n  }\r\n\r\n  if (!status.supabase.connected) {\r\n    recommendations.push('❌ Fix Supabase connection issue');\r\n    if (typeof status.supabase.error === 'string' && status.supabase.error.length > 0) {\r\n      recommendations.push(`   Error: ${status.supabase.error}`);\r\n    }\r\n  }\r\n\r\n  if (status.supabase.authSettings?.googleEnabled === true) {\r\n    recommendations.push('✅ Google OAuth provider is enabled');\r\n  } else {\r\n    recommendations.push(\r\n      '🔧 Enable Google OAuth provider in Supabase Dashboard',\r\n      '   Go to: Authentication > Providers > Google',\r\n    );\r\n  }\r\n\r\n  if (status.overall_status === 'ready') {\r\n    recommendations.push('🎉 OAuth configuration is complete!', '✅ Test the login flow at /login');\r\n  }\r\n\r\n  if (recommendations.length > 1) {\r\n    recommendations.push(\r\n      '📖 See docs/GOOGLE_OAUTH_SETUP_GUIDE.md for detailed instructions',\r\n      '🔧 Run: npm run oauth:verify for automated checks',\r\n    );\r\n  }\r\n\r\n  return recommendations;\r\n}\r\n\r\n/**\r\n * Determines the overall OAuth status based on provided conditions.\r\n * @example\r\n * determineOverallStatus(status)\r\n * 'ready'\r\n * @param {OAuthStatus} status - The status object containing configuration details.\r\n * @returns {'ready' | 'partial' | 'not_configured' | 'error'} Overall status derived from the evaluations.\r\n * @description\r\n *   - Evaluates connectivity and configuration status from various parameters within the status object.\r\n *   - Prioritizes returning 'error' if Supabase connection fails or if an error is detected.\r\n *   - Checks completeness of environment variables before proceeding to other status evaluations.\r\n *   - Distinguishes between 'ready' and 'partial' based on specific OAuth settings.\r\n */\r\nfunction determineOverallStatus(\r\n  status: OAuthStatus,\r\n): 'ready' | 'partial' | 'not_configured' | 'error' {\r\n  // eslint-disable-next-line sonarjs/different-types-comparison\r\n  if (!status.supabase.connected || status.supabase.error !== null) {\r\n    return 'error';\r\n  }\r\n\r\n  const envVarsComplete = Object.values(status.environment_variables).every(Boolean);\r\n  if (!envVarsComplete) {\r\n    return 'not_configured';\r\n  }\r\n\r\n  if (status.supabase.authSettings?.googleEnabled && status.oauth_flow.authProviderConfigured) {\r\n    return 'ready';\r\n  }\r\n\r\n  if (status.supabase.connected && envVarsComplete) {\r\n    return 'partial';\r\n  }\r\n\r\n  return 'not_configured';\r\n}\r\n\r\n/**\r\n * Retrieves a human-readable message based on the OAuth configuration status.\r\n * @example\r\n * getStatusMessage('ready')\r\n * 'Google OAuth is fully configured and ready to use'\r\n * @param {string} status - The current status of the OAuth configuration.\r\n * @returns {string} A message explaining the OAuth configuration status.\r\n * @description\r\n *   - Handles several predefined status cases.\r\n *   - Provides feedback for both success and error states.\r\n *   - Returns a default message for unrecognized statuses.\r\n */\r\nfunction getStatusMessage(status: string): string {\r\n  switch (status) {\r\n    case 'ready': {\r\n      return 'Google OAuth is fully configured and ready to use';\r\n    }\r\n    case 'partial': {\r\n      return 'Basic configuration complete, OAuth provider needs setup';\r\n    }\r\n    case 'not_configured': {\r\n      return 'Google OAuth is not configured';\r\n    }\r\n    case 'error': {\r\n      return 'Configuration error detected';\r\n    }\r\n    default: {\r\n      return 'Unknown configuration status';\r\n    }\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\api\\admin\\oauth-status\\types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\api\\admin\\realtime-events\\handlers.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":48,"column":10,"nodeType":"ChainExpression","messageId":"conditionErrorNullableBoolean","endLine":48,"endColumn":43,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[1399,1432],"text":"((authHeader?.startsWith('Bearer ')) ?? false)"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareFalse","fix":{"range":[1398,1432],"text":"(authHeader?.startsWith('Bearer ')) === false"},"desc":"Change condition to check if false (`value === false`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":55,"column":23,"nodeType":"ChainExpression","messageId":"conditionErrorObject","endLine":55,"endColumn":33}],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-misused-promises","severity":2,"message":"Promise returned in function argument where a void return was expected.","line":106,"column":38,"nodeType":"ArrowFunctionExpression","messageId":"voidReturnArgument","endLine":108,"endColumn":8,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-misused-promises","severity":2,"message":"Promise returned in function argument where a void return was expected.","line":193,"column":22,"nodeType":"ArrowFunctionExpression","messageId":"voidReturnArgument","endLine":199,"endColumn":4,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"sonarjs/pseudo-random","severity":2,"message":"Make sure that using this pseudorandom number generator is safe here.","line":459,"column":27,"nodeType":"CallExpression","messageId":"safeGenerator","endLine":459,"endColumn":40,"suppressions":[{"kind":"directive","justification":"Math.random is acceptable for generating non-security-sensitive event IDs."}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/* eslint-disable @typescript-eslint/no-misused-promises */\nimport { NextRequest } from 'next/server';\nimport {\n  supabase,\n  supabaseAdmin,\n  ScrapingJobService,\n  FoodTruckService,\n  type ScrapingJob,\n  type FoodTruck,\n} from '@/lib/supabase';\nimport { AdminEvent } from './types';\n\ninterface RealtimeMetrics {\n  scrapingJobs: {\n    active: number;\n    completed: number;\n    failed: number;\n    pending: number;\n  };\n  dataQuality: {\n    averageScore: number;\n    totalTrucks: number;\n    recentChanges: number;\n  };\n  systemHealth: {\n    status: 'healthy' | 'warning' | 'error';\n    uptime: number;\n    lastUpdate: string;\n  };\n}\n\n/**\n * Verifies if the request is made by an admin user.\n * @example\n * verifyAdminAccess(request)\n * false\n * @param {NextRequest} request - The incoming request containing authorization headers.\n * @returns {Promise<boolean>} Returns true if the user is an admin, otherwise false.\n * @description\n *   - Checks authorization header for a Bearer token.\n *   - Uses Supabase client to verify the user associated with the token.\n *   - Validates the user's role from the 'profiles' table in the Supabase database.\n *   - Handles exceptions gracefully, returning false if any step encounters an error.\n */\nexport async function verifyAdminAccess(request: NextRequest): Promise<boolean> {\n  try {\n    const authHeader = request.headers.get('authorization');\n    if (!authHeader?.startsWith('Bearer ')) {\n      return false;\n    }\n\n    const token = authHeader.slice(7);\n    const { data, error: authError } = await supabase.auth.getUser(token);\n\n    if (authError || !data?.user) {\n      return false;\n    }\n    const user = data.user;\n\n    if (!supabaseAdmin) {\n      return false;\n    }\n\n    const { data: profile } = await supabaseAdmin\n      .from('profiles')\n      .select('role')\n      .eq('id', user.id)\n      .single();\n\n    return profile?.role === 'admin';\n  } catch {\n    return false;\n  }\n}\n\n/**\n* Handles incoming GET requests by streaming real-time admin events through Server-Sent Events.\n* @example\n* handleGetRequest(request)\n* Response object with event stream data\n* @param {NextRequest} request - Incoming request to handle and process.\n* @returns {Response} Returns a streaming Response object containing the SSE data.\n* @description\n*   - Initializes a readable stream for emitting real-time events as SSE.\n*   - Enqueues a connection event upon a new client connection.\n*   - Sets up periodic heartbeat events every 5 seconds.\n*   - Registers an abort event listener to gracefully close streams and clear intervals.\n*/\nexport function handleGetRequest(request: NextRequest): Response {\n  const stream = new ReadableStream({\n    start(controller: ReadableStreamDefaultController<Uint8Array>) {\n      const encoder = new TextEncoder();\n\n      const connectionEvent: AdminEvent = {\n        id: generateEventId(),\n        type: 'heartbeat',\n        timestamp: new Date().toISOString(),\n        data: {\n          message: 'Real-time admin dashboard connected',\n          connectionId: generateEventId(),\n        },\n      };\n\n      controller.enqueue(encoder.encode(formatSSEMessage(connectionEvent)));\n\n      const intervalId = setInterval(async () => {\n        await sendHeartbeatEvent(controller, encoder);\n      }, 5000);\n\n      const changeMonitorId = setupDataChangeMonitor(controller, encoder);\n\n      request.signal.addEventListener('abort', () => {\n        clearInterval(intervalId);\n        clearInterval(changeMonitorId);\n        controller.close();\n      });\n    },\n  });\n\n  return new Response(stream, {\n    headers: {\n      'Content-Type': 'text/event-stream',\n      'Cache-Control': 'no-cache',\n      Connection: 'keep-alive',\n      'Access-Control-Allow-Origin': '*',\n      'Access-Control-Allow-Headers': 'Cache-Control',\n    },\n  });\n}\n\n/**\n* Sends a heartbeat event by fetching realtime metrics or logs an error alert when unsuccessful\n* @example\n* sendHeartbeatEvent(controller, encoder)\n* // No return value\n* @param {ReadableStreamDefaultController<Uint8Array>} controller - The controller used for enqueueing the event data.\n* @param {TextEncoder} encoder - The encoder used to convert the event data to a Uint8Array.\n* @returns {Promise<void>} Promise that resolves when event has been sent or error has been handled.\n* @description\n*   - Utilizes `fetchRealtimeMetrics()` to gather current system metrics.\n*   - Generates a unique event id via `generateEventId()`.\n*   - Formats the event data using `formatSSEMessage()` before enqueueing.\n*   - Handles errors by creating a system alert event if metrics fetching fails.\n*/\nasync function sendHeartbeatEvent(\n  controller: ReadableStreamDefaultController<Uint8Array>,\n  encoder: TextEncoder,\n): Promise<void> {\n  try {\n    const metrics = await fetchRealtimeMetrics();\n    const event: AdminEvent = {\n      id: generateEventId(),\n      type: 'heartbeat',\n      timestamp: new Date().toISOString(),\n      data: { ...metrics },\n    };\n\n    controller.enqueue(encoder.encode(formatSSEMessage(event)));\n  } catch (error) {\n    console.error('Error fetching realtime metrics:', error);\n\n    const errorEvent: AdminEvent = {\n      id: generateEventId(),\n      type: 'system_alert',\n      timestamp: new Date().toISOString(),\n      data: {\n        error: 'Failed to fetch metrics',\n        details: error instanceof Error ? error.message : 'Unknown error',\n      },\n      severity: 'error',\n    };\n\n    controller.enqueue(encoder.encode(formatSSEMessage(errorEvent)));\n  }\n}\n\n/**\n* Sets up a periodic monitor for data changes using provided controller and encoder.\n* @example\n* setupDataChangeMonitor(controller, encoder)\n* // returns a NodeJS.Timeout object that repeatedly monitors data changes every 10 seconds\n* @param {ReadableStreamDefaultController<Uint8Array>} controller - Controller to handle readable stream of Uint8Array.\n* @param {TextEncoder} encoder - Encoder to encode texts for processing the monitor.\n* @returns {NodeJS.Timeout} Returns a timeout object responsible for invoking data change monitoring at set intervals.\n* @description\n*   - Utilizes async operation to monitor data changes ensuring non-blocking execution.\n*   - Handles errors by logging them to the console, useful for debugging.\n*/\nfunction setupDataChangeMonitor(\n  controller: ReadableStreamDefaultController<Uint8Array>,\n  encoder: TextEncoder,\n): NodeJS.Timeout {\n  return setInterval(async () => {\n    try {\n      await monitorDataChanges(controller, encoder);\n    } catch (error) {\n      console.error('Error monitoring data changes:', error);\n    }\n  }, 10_000);\n}\n\n/**\n * Handles a POST request and performs an action based on the 'action' property in the request body.\n * @example\n * handlePostRequest(request)\n * Promise<Response>\n * @param {NextRequest} request - The incoming request object containing the POST data.\n * @returns {Promise<Response>} A response object indicating the result of the action.\n * @description\n *   - Utilizes type guarding to validate the presence of the 'action' property in the request body.\n *   - Executes different actions like 'health_check' or 'trigger_test_event' based on the 'action' value.\n *   - Provides error handling to return appropriate response codes and error messages.\n */\nexport async function handlePostRequest(request: NextRequest): Promise<Response> {\n  try {\n    const rawBody: unknown = await request.json();\n\n    interface PostRequestBody {\n      action: 'health_check' | 'trigger_test_event';\n    }\n\n    function isPostRequestBody(obj: unknown): obj is PostRequestBody {\n      return (\n        typeof obj === 'object' &&\n        obj !== null &&\n        'action' in obj &&\n        typeof (obj as PostRequestBody).action === 'string' &&\n        ((obj as PostRequestBody).action === 'health_check' ||\n          (obj as PostRequestBody).action === 'trigger_test_event')\n      );\n    }\n\n    if (!isPostRequestBody(rawBody)) {\n      return new Response(\n        JSON.stringify({\n          success: false,\n          error: \"Invalid request body: 'action' property is missing or not a valid action.\",\n        }),\n        {\n          status: 400,\n          headers: { 'Content-Type': 'application/json' },\n        },\n      );\n    }\n\n    const body: PostRequestBody = rawBody;\n\n    switch (body.action) {\n      case 'health_check': {\n        return await handleHealthCheck();\n      }\n\n      case 'trigger_test_event': {\n        return handleTriggerTestEvent();\n      }\n\n      default: {\n        return new Response(\n          JSON.stringify({\n            success: false,\n            error: \"That didn't work, please try again later.\",\n          }),\n          {\n            status: 400,\n            headers: { 'Content-Type': 'application/json' },\n          },\n        );\n      }\n    }\n  } catch (error) {\n    console.error('Realtime events POST error:', error);\n    return new Response(\n      JSON.stringify({\n        success: false,\n        error: \"That didn't work, please try again later.\",\n      }),\n      {\n        status: 500,\n        headers: { 'Content-Type': 'application/json' },\n      },\n    );\n  }\n}\n\n/**\n * Fetches current scraping job metrics, data quality statistics, and system health status.\n * @example\n * fetchRealtimeMetrics()\n * {\n *   scrapingJobs: { active: 4, completed: 5, failed: 1, pending: 2 },\n *   dataQuality: { averageScore: 85, totalTrucks: 50, recentChanges: 0 },\n *   systemHealth: { status: 'healthy', uptime: 3600, lastUpdate: '2023-10-01T12:00:00Z' }\n * }\n * @returns {Promise<RealtimeMetrics>} An object containing metrics about scraping jobs, data quality, and system health.\n * @description\n *   - Utilizes external services ScrapingJobService and FoodTruckService to gather data.\n *   - Provides comprehensive metrics for monitoring system health and data processing status.\n *   - Catches errors to ensure consistent return structure even upon failure.\n */\nasync function fetchRealtimeMetrics(): Promise<RealtimeMetrics> {\n  try {\n    const recentJobs = await ScrapingJobService.getJobsByStatus('all');\n    const scrapingMetrics = {\n      active: recentJobs.filter((job: ScrapingJob) => job.status === 'running').length,\n      completed: recentJobs.filter((job: ScrapingJob) => job.status === 'completed').length,\n      failed: recentJobs.filter((job: ScrapingJob) => job.status === 'failed').length,\n      pending: recentJobs.filter((job: ScrapingJob) => job.status === 'pending').length,\n    };\n\n    const qualityStats = await FoodTruckService.getDataQualityStats();\n    const dataQualityMetrics = {\n      averageScore: qualityStats.avg_quality_score ?? 0,\n      totalTrucks: qualityStats.total_trucks ?? 0,\n      recentChanges: 0,\n    };\n\n    const systemHealth = {\n      status: 'healthy' as const,\n      uptime: process.uptime(),\n      lastUpdate: new Date().toISOString(),\n    };\n\n    return {\n      scrapingJobs: scrapingMetrics,\n      dataQuality: dataQualityMetrics,\n      systemHealth,\n    };\n  } catch (error) {\n    console.error('Error fetching realtime metrics:', error);\n    return {\n      scrapingJobs: { active: 0, completed: 0, failed: 0, pending: 0 },\n      dataQuality: { averageScore: 0, totalTrucks: 0, recentChanges: 0 },\n      systemHealth: {\n        status: 'error',\n        uptime: 0,\n        lastUpdate: new Date().toISOString(),\n      },\n    };\n  }\n}\n\nfunction isScrapingJob(obj: unknown): obj is ScrapingJob {\n  return typeof obj === 'object' && obj !== null && 'id' in obj && 'status' in obj;\n}\n\n// Removed isFoodTruck function as it is unused.\n// function isFoodTruck(obj: unknown): obj is FoodTruck {\n//   return typeof obj === 'object' && obj !== null && 'id' in obj && 'name' in obj;\n// }\n\n/**\n * Sends an update event about recent scraping jobs to a stream.\n * @example\n * sendScrapingUpdateEvent(controller, encoder)\n * @param {ReadableStreamDefaultController<Uint8Array>} controller - The stream controller to enqueue the event data.\n * @param {TextEncoder} encoder - The TextEncoder used to encode the event message.\n * @returns {Promise<void>} Resolves when the event has been enqueued.\n * @description\n *   - The function retrieves all recent scraping jobs with their status.\n *   - Filters the jobs to include only valid scraping jobs.\n *   - Constructs an event object adhering to the expected format.\n *   - Uses the controller to stream the encoded event to the client.\n */\nasync function sendScrapingUpdateEvent(\n  controller: ReadableStreamDefaultController<Uint8Array>,\n  encoder: TextEncoder,\n): Promise<void> {\n  const recentJobs = await ScrapingJobService.getJobsByStatus('all');\n\n  if (Array.isArray(recentJobs) && recentJobs.length > 0) {\n    const event: AdminEvent = {\n      id: generateEventId(),\n      type: 'scraping_update',\n      timestamp: new Date().toISOString(),\n      data: {\n        recentJobs: recentJobs\n          .filter((job) => isScrapingJob(job))\n          .map((job) => ({\n            // Fixed unicorn/no-array-callback-reference\n            id: job.id,\n            status: job.status,\n            started_at: job.started_at,\n            completed_at: job.completed_at,\n          })),\n        count: recentJobs.length,\n      },\n      severity: 'info',\n    };\n\n    controller.enqueue(encoder.encode(formatSSEMessage(event)));\n  }\n}\n\n/**\n * Sends a data quality change event if recent updates are detected.\n * @example\n * sendDataQualityChangeEvent(controller, encoder)\n * // Enqueues an event to the provided controller.\n * @param {ReadableStreamDefaultController<Uint8Array>} controller - The controller that enqueues the encoded event data.\n * @param {TextEncoder} encoder - The encoder used to transform event data into Uint8Array format.\n * @returns {Promise<void>} Resolves when the event is successfully handled and enqueued.\n * @description\n *   - Retrieves recent food truck updates from the FoodTruckService.\n *   - Filters food trucks updated within the last minute.\n *   - Formats a server-sent event message with the updates.\n *   - Only enqueues the event if there are updates detected.\n */\nasync function sendDataQualityChangeEvent(\n  controller: ReadableStreamDefaultController<Uint8Array>,\n  encoder: TextEncoder,\n): Promise<void> {\n  const recentTrucksResult = await FoodTruckService.getAllTrucks(10, 0);\n  const recentlyUpdated = recentTrucksResult.trucks.filter((truck: FoodTruck) => {\n    if (!truck.updated_at) return false;\n    const updatedAt = new Date(truck.updated_at);\n    const oneMinuteAgo = new Date(Date.now() - 60_000);\n    return updatedAt > oneMinuteAgo;\n  });\n\n  if (recentlyUpdated.length > 0) {\n    const event: AdminEvent = {\n      id: generateEventId(),\n      type: 'data_quality_change',\n      timestamp: new Date().toISOString(),\n      data: {\n        updatedTrucks: recentlyUpdated.map((truck) => ({\n          id: truck.id,\n          name: truck.name,\n          data_quality_score: truck.data_quality_score,\n          updated_at: truck.updated_at,\n        })),\n        count: recentlyUpdated.length,\n      },\n      severity: 'info',\n    };\n\n    controller.enqueue(encoder.encode(formatSSEMessage(event)));\n  }\n}\n\nasync function monitorDataChanges(\n  controller: ReadableStreamDefaultController<Uint8Array>,\n  encoder: TextEncoder,\n): Promise<void> {\n  try {\n    await sendScrapingUpdateEvent(controller, encoder);\n    await sendDataQualityChangeEvent(controller, encoder);\n  } catch (error) {\n    console.error('Error monitoring data changes:', error);\n  }\n}\n\nfunction formatSSEMessage(event: AdminEvent): string {\n  return `id: ${event.id}\\nevent: ${event.type}\\ndata: ${JSON.stringify(event)}\\n\\n`;\n}\n\nfunction generateEventId(): string {\n  // eslint-disable-next-line sonarjs/pseudo-random -- Math.random is acceptable for generating non-security-sensitive event IDs.\n  return `${Date.now()}-${Math.random().toString(36).slice(2, 11)}`;\n}\n\n/**\n * Performs a health check and returns the system status along with real-time metrics.\n * @example\n * handleHealthCheck().then(response => console.log(response));\n * Response { \"success\": true, \"status\": \"healthy\", \"metrics\": {...}, \"timestamp\": \"2023-03-17T12:34:56.789Z\" }\n * @returns {Promise<Response>} A Promise that resolves to a Response object containing JSON data.\n * @description\n *   - Utilizes real-time metrics to provide current system health information.\n *   - Returns a JSON response formatted with specific headers and structure.\n */\nasync function handleHealthCheck(): Promise<Response> {\n  const metrics = await fetchRealtimeMetrics();\n  return new Response(\n    JSON.stringify({\n      success: true,\n      status: 'healthy',\n      metrics,\n      timestamp: new Date().toISOString(),\n    }),\n    {\n      headers: { 'Content-Type': 'application/json' },\n    },\n  );\n}\n\n/**\n * Returns a JSON response indicating a test event has been triggered.\n * @example\n * handleTriggerTestEvent()\n * Response object with a success message.\n * @returns {Response} JSON response containing success status, message, and timestamp.\n * @description\n *   - The response content type is set to 'application/json'.\n *   - The timestamp is generated using the current date and time.\n *   - Ensures consistent response formatting for realtime event triggers.\n */\nfunction handleTriggerTestEvent(): Response {\n  return new Response(\n    JSON.stringify({\n      success: true,\n      message: 'Test event triggered',\n      timestamp: new Date().toISOString(),\n    }),\n    {\n      headers: { 'Content-Type': 'application/json' },\n    },\n  );\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\api\\admin\\realtime-events\\types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\api\\admin\\scraping-metrics\\handlers.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":20,"column":10,"nodeType":"Identifier","messageId":"conditionErrorNullableString","endLine":20,"endColumn":20,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[878,889],"text":"authHeader == null"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[879,889],"text":"(authHeader ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[878,889],"text":"!Boolean(authHeader)"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":25,"column":23,"nodeType":"ChainExpression","messageId":"conditionErrorObject","endLine":25,"endColumn":33},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an error typed value.","line":42,"column":9,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":42,"endColumn":45},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an error typed value.","line":45,"column":5,"nodeType":"Property","messageId":"anyAssignment","endLine":45,"endColumn":18}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { NextResponse } from 'next/server';\nimport { ScrapingJobService, FoodTruckService, supabase } from '@/lib/supabase';\nimport { RealtimeMetrics } from './types';\n\n/**\n * Verifies if the requesting user has admin access.\n * @example\n * verifyAdminAccess(request)\n * true\n * @param {Request} request - The HTTP request object containing headers for authorization.\n * @returns {Promise<boolean>} Returns a promise resolving to true if the user has admin access, otherwise false.\n * @description\n *   - Extracts the authorization token from the request headers.\n *   - Checks if the user associated with the token exists and retrieves their role.\n *   - Ensures the retrieved role is 'admin' for access confirmation.\n */\nexport async function verifyAdminAccess(request: Request): Promise<boolean> {\n  try {\n    const authHeader = request.headers.get('authorization');\n    if (!authHeader) return false;\n\n    const token = authHeader.replace('Bearer ', '');\n    const { data, error: authError } = await supabase.auth.getUser(token);\n\n    if (authError || !data?.user) return false;\n\n    const user = data.user;\n\n    const { data: profile } = await supabase\n      .from('profiles')\n      .select('role')\n      .eq('id', user.id)\n      .single();\n\n    return profile?.role === 'admin';\n  } catch {\n    return false;\n  }\n}\n\nexport async function handleGetRequest(): Promise<NextResponse> {\n  const metrics = await getScrapingMetrics();\n  return NextResponse.json({\n    success: true,\n    data: metrics,\n    timestamp: new Date().toISOString(),\n  });\n}\n\n/**\n * Retrieves real-time scraping metrics from the database.\n * @example\n * getScrapingMetrics().then(metrics => console.log(metrics))\n * // { scrapingJobs: {...}, dataQuality: {...}, systemHealth: {...} }\n * @returns {Promise<RealtimeMetrics>} A promise that resolves to an object containing scraping job metrics, data quality information, and system health stats.\n * @description\n *   - Fetches data from ScrapingJobService and FoodTruckService to compute metrics.\n *   - Placeholder values are used for averageScore and recentChanges in dataQuality.\n *   - Computes the number of jobs by their status: running, completed, failed, and pending.\n */\nasync function getScrapingMetrics(): Promise<RealtimeMetrics> {\n  // Fetch real scraping metrics from database\n  const [allJobsResult, recentTrucksResult] = await Promise.all([\n    ScrapingJobService.getAllJobs(100, 0), // Get last 100 jobs for metrics\n    FoodTruckService.getAllTrucks(1000, 0), // Get trucks for processing count\n  ]);\n\n  // Type guard for allJobsResult\n  const allJobs: ScrapingJob[] = Array.isArray(allJobsResult) ? allJobsResult : [];\n\n  // Type guard for recentTrucksResult\n  const recentTrucks: { trucks: FoodTruck[]; total: number; error?: string } = (\n    typeof recentTrucksResult === 'object' &&\n    'trucks' in recentTrucksResult &&\n    Array.isArray(recentTrucksResult.trucks)\n  )\n    ? (recentTrucksResult as { trucks: FoodTruck[]; total: number; error?: string })\n    : { trucks: [], total: 0 };\n\n  const typedJobs = allJobs as Array<{\n    status?: string;\n    started_at?: string;\n    completed_at?: string;\n  }>;\n  const successfulRuns = typedJobs.filter((job) => job.status === 'completed').length;\n  const failedRuns = typedJobs.filter((job) => job.status === 'failed').length;\n\n  return {\n    scrapingJobs: {\n      active: typedJobs.filter((job) => job.status === 'running').length,\n      completed: successfulRuns,\n      failed: failedRuns,\n      pending: typedJobs.filter((job) => job.status === 'pending').length,\n    },\n    dataQuality: {\n      averageScore: 0, // Placeholder, actual calculation might be complex\n      totalTrucks: recentTrucks.total,\n      recentChanges: 0, // Placeholder\n    },\n    systemHealth: {\n      status: 'healthy',\n      uptime: process.uptime(),\n      lastUpdate: new Date().toISOString(),\n    },\n  };\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\api\\analytics\\web-vitals\\handlers.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\api\\analytics\\web-vitals\\types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\api\\cron\\auto-scrape\\handlers.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":110,"column":53,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":110,"endColumn":62,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[4529,4538],"text":"(e.details != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[4529,4538],"text":"(e.details ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[4529,4538],"text":"(Boolean(e.details))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { NextRequest, NextResponse } from 'next/server';\r\nimport { autoScraper } from '@/lib/autoScraper';\r\nimport { scheduler } from '@/lib/scheduler';\r\nimport { logActivity } from '@/lib/activityLogger';\r\nimport { AutoScrapeResult } from './types';\r\n\r\n/**\r\n* Verifies the cron secret authorization header against a stored environment variable.\r\n* @example\r\n* verifyCronSecret(request)\r\n* NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\r\n* @param {NextRequest} request - The incoming request object containing headers.\r\n* @returns {NextResponse | null} Returns an error response if authorization fails or if the secret is not set.\r\n* @description\r\n*   - Logs an error message if the CRON_SECRET environment variable is not configured or is empty.\r\n*   - Logs unauthorized attempts, including the provided authorization header value.\r\n*   - Relies on the Bearer token scheme for authorization.\r\n*/\r\nfunction verifyCronSecret(request: NextRequest): NextResponse | null {\r\n  const authHeader = request.headers.get('authorization');\r\n  const cronSecret = process.env.CRON_SECRET;\r\n\r\n  if (cronSecret === undefined || cronSecret === '') {\r\n    console.error('CRON_SECRET not configured');\r\n    return NextResponse.json({ error: 'Server configuration error' }, { status: 500 });\r\n  }\r\n\r\n  if (authHeader !== `Bearer ${cronSecret}`) {\r\n    console.error('Unauthorized cron attempt:', authHeader);\r\n    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });\r\n  }\r\n  return undefined;\r\n}\r\n\r\nfunction logAutoScrapeStart() {\r\n  console.info('Starting automated scraping job...');\r\n  logActivity({\r\n    type: 'cron_job',\r\n    action: 'auto_scrape_started',\r\n    details: { timestamp: new Date().toISOString() },\r\n  });\r\n}\r\n\r\n/**\r\n * Logs the completion of an automated scraping job with pertinent details.\r\n * @example\r\n * logAutoScrapeCompletion(autoScrapeResult)\r\n * Automated scraping job completed successfully\r\n * @param {AutoScrapeResult} result - The result object containing details of the scraping job.\r\n * @returns {void} Does not return a value.\r\n * @description\r\n *   - Logs activity including the number of trucks processed and found, as well as any errors encountered.\r\n *   - Utilizes a standardized logActivity function to record job completion.\r\n *   - Converts the current timestamp to an ISO string format.\r\n *   - Provides a console message indicating successful job completion.\r\n */\r\nfunction logAutoScrapeCompletion(result: AutoScrapeResult) {\r\n  logActivity({\r\n    type: 'cron_job',\r\n    action: 'auto_scrape_completed',\r\n    details: {\r\n      timestamp: new Date().toISOString(),\r\n      trucksProcessed: result.trucksProcessed,\r\n      newTrucksFound: result.newTrucksFound,\r\n      errorsCount: result.errors?.length ?? 0,\r\n    },\r\n  });\r\n  console.info('Automated scraping job completed successfully');\r\n}\r\n\r\nfunction logAutoScrapeFailure(error: unknown) {\r\n  console.error('Auto-scraping cron job failed:', error);\r\n  logActivity({\r\n    type: 'cron_job',\r\n    action: 'auto_scrape_failed',\r\n    details: {\r\n      timestamp: new Date().toISOString(),\r\n      error: error instanceof Error ? error.message : 'Unknown error',\r\n    },\r\n  });\r\n}\r\n\r\n/**\r\n * Handles a POST request to initiate an auto-scraping process and returns the result.\r\n * @example\r\n * handlePostRequest(request)\r\n * { success: true, message: 'Auto-scraping completed successfully', data: { trucksProcessed: 10, newTrucksFound: 2, timestamp: '2023-08-23T18:25:43.511Z' } }\r\n * @param {NextRequest} request - The request object containing necessary parameters and headers for processing.\r\n * @returns {NextResponse} JSON response with either the success data or an error message.\r\n * @description\r\n *   - Validates request with a secret key before processing.\r\n *   - Logs scraping start and completion along with processed results.\r\n *   - Schedules follow-up tasks after successful scraping.\r\n *   - Catches and logs errors with a failure response in case of any exceptions during the process.\r\n */\r\nexport async function handlePostRequest(request: NextRequest) {\r\n  try {\r\n    const authResponse = verifyCronSecret(request);\r\n    if (authResponse) {\r\n      return authResponse;\r\n    }\r\n\r\n    logAutoScrapeStart();\r\n\r\n    const rawResult = await autoScraper.runAutoScraping();\r\n    // Map errors to string[] for compatibility\r\n    const result: AutoScrapeResult = {\r\n      trucksProcessed: rawResult.trucksProcessed,\r\n      newTrucksFound: rawResult.newTrucksFound,\r\n      errors: rawResult.errors?.map((e) => e.url + (e.details ? `: ${e.details}` : '')),\r\n    };\r\n    scheduler.scheduleFollowUpTasks(result);\r\n    logAutoScrapeCompletion(result);\r\n\r\n    return NextResponse.json({\r\n      success: true,\r\n      message: 'Auto-scraping completed successfully',\r\n      data: {\r\n        trucksProcessed: result.trucksProcessed,\r\n        newTrucksFound: result.newTrucksFound,\r\n        timestamp: new Date().toISOString(),\r\n      },\r\n    });\r\n  } catch (error) {\r\n    logAutoScrapeFailure(error);\r\n    return NextResponse.json(\r\n      {\r\n        success: false,\r\n        error: 'Auto-scraping failed',\r\n        message: error instanceof Error ? error.message : 'Unknown error',\r\n      },\r\n      { status: 500 },\r\n    );\r\n  }\r\n}\r\n\r\nexport function handleGetRequest() {\r\n  return NextResponse.json(\r\n    { error: 'Method not allowed. Use POST for cron jobs.' },\r\n    { status: 405 },\r\n  );\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\api\\cron\\auto-scrape\\types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\api\\firecrawl\\handlers.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\api\\firecrawl\\types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\api\\monitoring\\api-usage\\handlers.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\api\\pipeline\\handlers.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\api\\pipeline\\types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\api\\scheduler\\data.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\api\\scheduler\\handlers.ts","messages":[],"suppressedMessages":[{"ruleId":"sonarjs/pseudo-random","severity":2,"message":"Make sure that using this pseudorandom number generator is safe here.","line":172,"column":7,"nodeType":"CallExpression","messageId":"safeGenerator","endLine":172,"endColumn":20,"suppressions":[{"kind":"directive","justification":"Math.random is acceptable for simulating task execution."}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\api\\scheduler\\types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\api\\search\\data.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\api\\search\\filters.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\api\\search\\helpers.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\api\\tavily\\handlers.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\api\\tavily\\types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\api\\test-integration\\helpers.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\api\\test-integration\\pipelineRunner.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\api\\test-integration\\pipelineRunnerHelpers.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\api\\test-integration\\schemaMapper.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":8,"column":8,"nodeType":"Identifier","messageId":"conditionErrorObject","endLine":8,"endColumn":21}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ExtractedFoodTruckDetails, FoodTruckSchema, MenuCategory, MenuItem } from '@/lib/types';\n\nexport function mapExtractedDataToTruckSchema(\n  extractedData: ExtractedFoodTruckDetails,\n  sourceUrl: string,\n  isDryRun: boolean,\n): FoodTruckSchema {\n  if (!extractedData || typeof extractedData !== 'object') {\n    throw new Error('Invalid extractedData for mapping.');\n  }\n\n  const name = extractedData.name ?? 'Unknown Test Truck';\n  const locationData = extractedData.current_location ?? {};\n  const fullAddress = [\n    locationData.address,\n    locationData.city,\n    locationData.state,\n    locationData.zip_code,\n  ]\n    .filter(Boolean)\n    .join(', ');\n\n  return {\n    name: name,\n    description: extractedData.description ?? undefined,\n    current_location: {\n      lat: locationData.lat ?? 0,\n      lng: locationData.lng ?? 0,\n      address: fullAddress ?? locationData.raw_text ?? undefined,\n      timestamp: new Date().toISOString(),\n    },\n    scheduled_locations: extractedData.scheduled_locations ?? undefined,\n    operating_hours: extractedData.operating_hours ?? undefined,\n    menu: (extractedData.menu ?? []).map((category: MenuCategory) => ({\n      name: category.name ?? 'Uncategorized',\n      items: (category.items ?? []).map((item: MenuItem) => ({\n        name: item.name ?? 'Unknown Item',\n        description: item.description ?? undefined,\n        price:\n          typeof item.price === 'number' || typeof item.price === 'string' ? item.price : undefined,\n        dietary_tags: item.dietary_tags ?? [],\n      })),\n    })),\n    contact_info: extractedData.contact_info ?? undefined,\n    social_media: extractedData.social_media ?? undefined,\n    cuisine_type: extractedData.cuisine_type ?? [],\n    price_range: extractedData.price_range ?? undefined,\n    specialties: extractedData.specialties ?? [],\n    data_quality_score: isDryRun ? 0.5 : 0.6, // Differentiate test/dry run\n    verification_status: 'pending',\n    source_urls: [sourceUrl].filter(Boolean),\n    last_scraped_at: new Date().toISOString(),\n    ...(isDryRun && { test_run_flag: true }), // Add a flag for actual test saves if needed\n  };\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\api\\test-integration\\stageHandlers.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\api\\trucks\\handlers.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\auth\\authHelpers.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\autoScraper.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\data-quality\\batchCleanup.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":192,"column":11,"nodeType":"Identifier","messageId":"conditionErrorObject","endLine":192,"endColumn":17},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":269,"column":9,"nodeType":"Identifier","messageId":"conditionErrorObject","endLine":269,"endColumn":16},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":433,"column":10,"nodeType":"MemberExpression","messageId":"conditionErrorObject","endLine":433,"endColumn":32},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":519,"column":9,"nodeType":"Identifier","messageId":"conditionErrorObject","endLine":519,"endColumn":26}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * SOTA Batch Data Cleanup System\n * Implements automated data quality improvements and cleanup operations\n */\n\nimport { FoodTruckService, type FoodTruck, DataQualityService } from '@/lib/supabase';\nimport { DuplicatePreventionService } from './duplicatePrevention';\nimport { getPlaceholderPatterns, processTruckForPlaceholders } from './placeholderUtils';\n\nexport interface CleanupOperation {\n  type:\n    | 'normalize_phone'\n    | 'fix_coordinates'\n    | 'remove_placeholders'\n    | 'update_quality_scores'\n    | 'merge_duplicates';\n  description: string;\n  affectedCount: number;\n  successCount: number;\n  errorCount: number;\n  errors: string[];\n}\n\nexport interface BatchCleanupResult {\n  totalProcessed: number;\n  operations: CleanupOperation[];\n  summary: {\n    trucksImproved: number;\n    duplicatesRemoved: number;\n    qualityScoreImprovement: number;\n    placeholdersRemoved: number;\n  };\n  duration: number;\n}\n\ninterface MergeOperationContext {\n  operation: CleanupOperation;\n  processedIds: Set<string>;\n}\n\ninterface CoordinateProcessContext {\n  defaultLat: number;\n  defaultLng: number;\n  dryRun: boolean;\n  operation: CleanupOperation;\n}\n\n/**\n * Automated Data Quality Cleanup Service\n */\nexport class BatchCleanupService {\n  /**\n   * Run comprehensive data cleanup operations\n   */\n  static async runFullCleanup(\n    options: {\n      batchSize?: number;\n      dryRun?: boolean;\n      operations?: CleanupOperation['type'][];\n    } = {},\n  ): Promise<BatchCleanupResult> {\n    const startTime = Date.now();\n    const {\n      batchSize = 50,\n      dryRun = false,\n      operations = [\n        'remove_placeholders',\n        'normalize_phone',\n        'fix_coordinates',\n        'update_quality_scores',\n        'merge_duplicates',\n      ],\n    } = options;\n\n    console.info(`Starting batch cleanup (${dryRun ? 'DRY RUN' : 'LIVE'})...`);\n    const result = this.initializeCleanupResult();\n    try {\n      const allTrucks = await FoodTruckService.getAllTrucks();\n      result.totalProcessed = allTrucks.total;\n      await this.processTrucksInBatches(allTrucks.trucks, {\n        batchSize,\n        operations,\n        dryRun,\n        result,\n      });\n      return this.finalizeCleanupResult(result, startTime);\n    } catch (error) {\n      console.error('Batch cleanup failed:', error);\n      throw error;\n    }\n  }\n\n  /**\n  * Initializes and returns a new BatchCleanupResult object with default values.\n  * @example\n  * initializeCleanupResult()\n  * { totalProcessed: 0, operations: [], summary: { trucksImproved: 0, duplicatesRemoved: 0, qualityScoreImprovement: 0, placeholdersRemoved: 0 }, duration: 0 }\n  * @returns {BatchCleanupResult} A new BatchCleanupResult object with all properties set to initial default values.\n  */\n  private static initializeCleanupResult(): BatchCleanupResult {\n    return {\n      totalProcessed: 0,\n      operations: [],\n      summary: {\n        trucksImproved: 0,\n        duplicatesRemoved: 0,\n        qualityScoreImprovement: 0,\n        placeholdersRemoved: 0,\n      },\n      duration: 0,\n    };\n  }\n\n  private static finalizeCleanupResult(\n    result: BatchCleanupResult,\n    startTime: number,\n  ): BatchCleanupResult {\n    result.summary = this.calculateSummary(result.operations);\n    result.duration = Date.now() - startTime;\n\n    console.info(`Batch cleanup completed in ${result.duration}ms`);\n    return result;\n  }\n\n  /**\n   * Processes food trucks in batches, executing specified operations on each batch.\n   * @example\n   * processTrucksInBatches(truckList, { batchSize: 10, operations: ['clean'], dryRun: true, result: batchResult })\n   * // It executes 'clean' operation on batches of 10 trucks without making permanent changes.\n   * @param {FoodTruck[]} trucks - Array of food trucks to be processed in batches.\n   * @param {object} options - Options object containing batchSize, operations, dryRun, and result.\n   * @param {number} options.batchSize - Number of trucks in each batch.\n   * @param {CleanupOperation['type'][]} options.operations - Array of operation types to be executed on each batch.\n   * @param {boolean} options.dryRun - If true, operations are executed in simulation mode without permanent changes.\n   * @param {BatchCleanupResult} options.result - Stores the results of operations performed on batches.\n   * @returns {Promise<void>} Completes processing batches without a return value.\n   * @description\n   *   - Uses async function to allow non-blocking execution of operations.\n   *   - Collects and stores results of batch operations separately, keeping track of each operation's outcome.\n   *   - Iterates over arrays using slicing to dynamically create batches for processing.\n   */\n  private static async processTrucksInBatches(\n    trucks: FoodTruck[],\n    {\n      batchSize,\n      operations,\n      dryRun,\n      result,\n    }: {\n      batchSize: number;\n      operations: CleanupOperation['type'][];\n      dryRun: boolean;\n      result: BatchCleanupResult;\n    },\n  ): Promise<void> {\n    for (let i = 0; i < trucks.length; i += batchSize) {\n      const batch = trucks.slice(i, i + batchSize);\n      for (const op of operations) {\n        const opResult = await this.runOperation(op, batch, dryRun);\n        result.operations.push(opResult);\n      }\n    }\n  }\n\n  /**\n   * Run a specific cleanup operation\n   */\n  private static async runOperation(\n    type: CleanupOperation['type'],\n    trucks: FoodTruck[],\n    dryRun: boolean,\n  ): Promise<CleanupOperation> {\n    const operation: CleanupOperation = {\n      type,\n      description: this.getOperationDescription(type),\n      affectedCount: 0,\n      successCount: 0,\n      errorCount: 0,\n      errors: [],\n    };\n\n    const operationRunners = {\n      remove_placeholders: this.runRemovePlaceholders,\n      normalize_phone: this.runNormalizePhoneNumbers,\n      fix_coordinates: this.runFixCoordinates,\n      update_quality_scores: this.runUpdateQualityScores,\n      merge_duplicates: this.runMergeDuplicates,\n    };\n\n    try {\n      const runner = operationRunners[type];\n      if (runner) {\n        return await runner.call(this, trucks, dryRun, operation);\n      } \n        operation.errors.push(`Unknown operation type: ${String(type)}`);\n        return operation;\n      \n    } catch (error) {\n      operation.errors.push(\n        `Operation failed: ${error instanceof Error ? error.message : String(error)}`,\n      );\n      return operation;\n    }\n  }\n\n  private static runRemovePlaceholders = async (\n    trucks: FoodTruck[],\n    dryRun: boolean,\n    operation: CleanupOperation,\n  ): Promise<CleanupOperation> => {\n    return await this.removePlaceholders(trucks, dryRun, operation);\n  };\n\n  private static runNormalizePhoneNumbers = async (\n    trucks: FoodTruck[],\n    dryRun: boolean,\n    operation: CleanupOperation,\n  ): Promise<CleanupOperation> => {\n    return await this.normalizePhoneNumbers(trucks, dryRun, operation);\n  };\n\n  private static runFixCoordinates = async (\n    trucks: FoodTruck[],\n    dryRun: boolean,\n    operation: CleanupOperation,\n  ): Promise<CleanupOperation> => {\n    return await this.fixCoordinates(trucks, dryRun, operation);\n  };\n\n  private static runUpdateQualityScores = async (\n    trucks: FoodTruck[],\n    dryRun: boolean,\n    operation: CleanupOperation,\n  ): Promise<CleanupOperation> => {\n    return await this.updateQualityScores(trucks, dryRun, operation);\n  };\n\n  private static runMergeDuplicates = async (\n    trucks: FoodTruck[],\n    dryRun: boolean,\n    operation: CleanupOperation,\n  ): Promise<CleanupOperation> => {\n    return await this.mergeDuplicates(trucks, dryRun, operation);\n  };\n\n  /**\n   * Remove placeholder and mock data\n   */\n  private static async removePlaceholders(\n    trucks: FoodTruck[],\n    dryRun: boolean,\n    operation: CleanupOperation,\n  ): Promise<CleanupOperation> {\n    const placeholderPatterns = getPlaceholderPatterns();\n    const promises = trucks.map((truck) =>\n      this.processSingleTruckForPlaceholders(truck, placeholderPatterns, dryRun, operation),\n    );\n    await Promise.all(promises);\n    return operation;\n  }\n\n  private static async processSingleTruckForPlaceholders(\n    truck: FoodTruck,\n    patterns: RegExp[],\n    dryRun: boolean,\n    operation: CleanupOperation,\n  ): Promise<void> {\n    const updates = processTruckForPlaceholders(truck, patterns);\n    if (updates && Object.keys(updates).length > 0) {\n      await this.performUpdateOperation(truck.id, updates, dryRun, operation);\n    }\n  }\n\n  /**\n   * Perform an update operation on a specified food truck.\n   * @example\n   * performUpdateOperation('truck123', { name: 'New Name' }, true, cleanupOperation)\n   * // No direct return value; operation may log errors.\n   * @param {string} truckId - The unique identifier of the food truck to be updated.\n   * @param {Partial<FoodTruck>} updates - An object containing the fields to be updated.\n   * @param {boolean} dryRun - Flag indicating whether the operation should be a simulation without actual changes.\n   * @param {CleanupOperation} operation - An operation object that logs errors encountered during update.\n   * @returns {Promise<void>} A promise that resolves when the update operation is complete.\n   * @description\n   *   - If 'dryRun' is true, no updates are applied but actions are logged.\n   *   - Errors during update are caught and logged in the 'operation.errors' array.\n   */\n  private static async performUpdateOperation(\n    truckId: string,\n    updates: Partial<FoodTruck>,\n    dryRun: boolean,\n    operation: CleanupOperation,\n  ): Promise<void> {\n    operation.affectedCount += 1;\n    if (dryRun) {\n      operation.successCount += 1;\n    } else {\n      try {\n        await FoodTruckService.updateTruck(truckId, updates);\n        operation.successCount += 1;\n      } catch (error) {\n        operation.errorCount += 1;\n        operation.errors.push(\n          `Failed to update truck ${truckId}: ${error instanceof Error ? error.message : String(error)}`,\n        );\n      }\n    }\n  }\n\n  /**\n   * Normalize phone numbers to consistent format\n   */\n  private static async normalizePhoneNumbers(\n    trucks: FoodTruck[],\n    dryRun: boolean,\n    operation: CleanupOperation,\n  ): Promise<CleanupOperation> {\n    const promises = trucks.map((truck) => {\n      if (truck.contact_info?.phone !== undefined) {\n        const originalPhone = truck.contact_info.phone;\n        const normalizedPhone = this.normalizePhone(originalPhone);\n\n        if (normalizedPhone !== undefined && normalizedPhone !== originalPhone) {\n          return this.applyPhoneNormalizationUpdate(truck, normalizedPhone, dryRun, operation);\n        }\n      }\n      return Promise.resolve();\n    });\n    await Promise.all(promises);\n    return operation;\n  }\n\n  /**\n   * Apply phone normalization update to a food truck's contact information.\n   * @example\n   * applyPhoneNormalizationUpdate(truckInstance, '+1234567890', false, operationInstance)\n   * // Normalizes and updates phone number of given truckInstance.\n   * @param {FoodTruck} truck - The food truck object whose phone number needs normalization.\n   * @param {string} normalizedPhone - The normalized phone number to update to the food truck's contact information.\n   * @param {boolean} dryRun - Flag indicating whether the operation is a dry run; updates are skipped if true.\n   * @param {CleanupOperation} operation - Object containing cleanup operation context including a record of errors.\n   * @returns {Promise<void>} Does not return a value, but potentially modifies the truck and operation objects.\n   * @description\n   *   - Executes the update operation only if `dryRun` is false.\n   *   - Pushes error messages to `operation.errors` on failure during the update process.\n   *   - Uses `FoodTruckService.updateTruck` for updating the contact information.\n   */\n  private static async applyPhoneNormalizationUpdate(\n    truck: FoodTruck,\n    normalizedPhone: string,\n    dryRun: boolean,\n    operation: CleanupOperation,\n  ): Promise<void> {\n    operation.affectedCount += 1;\n    if (dryRun) {\n      operation.successCount += 1;\n    } else {\n      try {\n        await FoodTruckService.updateTruck(truck.id, {\n          contact_info: {\n            ...truck.contact_info,\n            phone: normalizedPhone,\n          },\n        });\n        operation.successCount += 1;\n      } catch (error) {\n        operation.errorCount += 1;\n        operation.errors.push(\n          `Failed to normalize phone for truck ${truck.id}: ${error instanceof Error ? error.message : String(error)}`,\n        );\n      }\n    }\n  }\n\n  /**\n   * Helper to determine if coordinates need fixing and provide updates\n   */\n  private static getFixedCoordinates(\n    lat: number | undefined,\n    lng: number | undefined,\n    defaultLat: number,\n    defaultLng: number,\n  ): Partial<FoodTruck['current_location']> | undefined {\n    // Fix invalid coordinates (0,0 or undefined)\n    if (lat === undefined || lng === undefined || lat === 0 || lng === 0) {\n      return { lat: defaultLat, lng: defaultLng };\n    }\n    // Fix coordinates outside reasonable bounds for Charleston area\n    if (lat < 32 || lat > 34 || lng > -79 || lng < -81) {\n      return { lat: defaultLat, lng: defaultLng };\n    }\n    return undefined;\n  }\n\n  /**\n   * Fix invalid GPS coordinates\n   */\n  private static async fixCoordinates(\n    trucks: FoodTruck[],\n    dryRun: boolean,\n    operation: CleanupOperation,\n  ): Promise<CleanupOperation> {\n    const context: Omit<CoordinateProcessContext, 'operation'> = {\n      defaultLat: 32.7767,\n      defaultLng: -79.9311,\n      dryRun,\n    };\n\n    const promises = trucks.map((truck) =>\n      this.processSingleTruckCoordinates(truck, { ...context, operation }),\n    );\n    await Promise.all(promises);\n    return operation;\n  }\n\n  /**\n   * Processes coordinates for a single food truck, applying any necessary fixes.\n   * @example\n   * processSingleTruckCoordinates(truck, context)\n   * // No return value, function completes silently\n   * @param {FoodTruck} truck - The food truck whose coordinates are to be processed.\n   * @param {CoordinateProcessContext} context - Contains configuration and operation context for processing coordinates.\n   * @returns {Promise<void>} Returns a promise that resolves when the processing and possible updates are complete.\n   * @description\n   *   - Skips processing if the truck's current location is not available.\n   *   - Retrieves updates for fixed coordinates based on truck's current and default locations.\n   *   - Applies updates conditionally based on context settings such as `dryRun` and `operation`.\n   */\n  private static async processSingleTruckCoordinates(\n    truck: FoodTruck,\n    context: CoordinateProcessContext,\n  ): Promise<void> {\n    if (!truck.current_location) return;\n    const { defaultLat, defaultLng, dryRun, operation } = context;\n    const { lat, lng } = truck.current_location;\n    const updates = this.getFixedCoordinates(lat, lng, defaultLat, defaultLng);\n    if (updates) {\n      await this.applyCoordinateFixUpdate(truck, updates, dryRun, operation);\n    }\n  }\n\n  /**\n   * Applies coordinate updates for a food truck's current location.\n   * @example\n   * applyCoordinateFixUpdate(truck, { lat: 34.05, lng: -118.25 }, false, operation)\n   * // Updates the coordinates of the truck's location asynchronously.\n   * @param {FoodTruck} truck - The food truck object whose coordinates need correction.\n   * @param {Partial<FoodTruck['current_location']>} updates - The latitude and longitude updates to be applied.\n   * @param {boolean} dryRun - Flag to simulate the update without altering data.\n   * @param {CleanupOperation} operation - The cleanup operation instance used for error tracking.\n   * @returns {Promise<void>} Resolves when the coordinate update process is complete.\n   * @description\n   *   - Executes the update operation only if the dryRun flag is false.\n   *   - If the update fails, logs the error details into the operation's error array.\n   */\n  private static async applyCoordinateFixUpdate(\n    truck: FoodTruck,\n    updates: Partial<FoodTruck['current_location']>,\n    dryRun: boolean,\n    operation: CleanupOperation,\n  ): Promise<void> {\n    operation.affectedCount += 1;\n    if (dryRun) {\n      operation.successCount += 1;\n    } else {\n      try {\n        await FoodTruckService.updateTruck(truck.id, {\n          current_location: {\n            ...truck.current_location,\n            ...updates,\n          },\n        });\n        operation.successCount += 1;\n      } catch (error) {\n        operation.errorCount += 1;\n        operation.errors.push(\n          `Failed to fix coordinates for truck ${truck.id}: ${error instanceof Error ? error.message : String(error)}`,\n        );\n      }\n    }\n  }\n\n  /**\n   * Update quality scores for all trucks\n   */\n  private static async updateQualityScores(\n    trucks: FoodTruck[],\n    dryRun: boolean,\n    operation: CleanupOperation,\n  ): Promise<CleanupOperation> {\n    const promises = trucks.map((truck) =>\n      this.processSingleTruckForQualityScore(truck, dryRun, operation),\n    );\n    await Promise.all(promises);\n    return operation;\n  }\n\n  /**\n  * Processes a single food truck for an updated quality score assessment.\n  * @example\n  * processSingleTruckForQualityScore(truckInstance, false, cleanupOperationInstance)\n  * // No return value\n  * @param {FoodTruck} truck - The food truck instance to assess and potentially update.\n  * @param {boolean} dryRun - Specifies whether this is a dry run (no actual data updates).\n  * @param {CleanupOperation} operation - The cleanup operation context for processing.\n  * @returns {Promise<void>} No return value; operation is performed asynchronously.\n  * @description\n  *   - Computes the quality score using data from DataQualityService.\n  *   - Updates the quality score only if the score changes significantly (>5% difference).\n  *   - Assumes `truck.data_quality_score` might be undefined, defaulting to 0.\n  *   - Handles asynchronous processing of the update application if conditions are met.\n  */\n  private static async processSingleTruckForQualityScore(\n    truck: FoodTruck,\n    dryRun: boolean,\n    operation: CleanupOperation,\n  ): Promise<void> {\n    const qualityAssessment = DataQualityService.calculateQualityScore(truck);\n    if (qualityAssessment) {\n      const newScore = qualityAssessment.score;\n      const currentScore = truck.data_quality_score ?? 0;\n      // Only update if score changed significantly (>5% difference)\n      if (typeof newScore === 'number' && Math.abs(newScore - currentScore) > 0.05) {\n        await this.applyQualityScoreUpdate(truck, dryRun, operation);\n      }\n    }\n  }\n\n  /**\n   * Updates the quality score of a specified food truck and handles errors during the update process.\n   * @example\n   * applyQualityScoreUpdate(foodTruckInstance, false, cleanupOperationInstance)\n   * void\n   * @param {FoodTruck} truck - The food truck for which the quality score will be updated.\n   * @param {boolean} dryRun - Flag indicating whether the function should perform the update or just simulate it.\n   * @param {CleanupOperation} operation - The cleanup operation containing possible error records.\n   * @returns {Promise<void>} Resolves with no value when the update completes. Errors are recorded in the `operation` if thrown.\n   * @description\n   *   - Throws an error if the quality score update fails.\n   *   - If `dryRun` is true, the function simulates the update without changing any data.\n   *   - Errors occurring during the update are appended to the `operation.errors` array.\n   */\n  private static async applyQualityScoreUpdate(\n    truck: FoodTruck,\n    dryRun: boolean,\n    operation: CleanupOperation,\n  ): Promise<void> {\n    operation.affectedCount += 1;\n    if (dryRun) {\n      operation.successCount += 1;\n    } else {\n      try {\n        const updateResult = await DataQualityService.updateTruckQualityScore(truck.id);\n        if ('error' in updateResult) {\n          throw new Error(updateResult.error);\n        }\n        operation.successCount += 1;\n      } catch (error) {\n        operation.errorCount += 1;\n        operation.errors.push(\n          `Failed to update quality score for truck ${truck.id}: ${error instanceof Error ? error.message : String(error)}`,\n        );\n      }\n    }\n  }\n\n  /**\n   * Identify and merge duplicate trucks\n   */\n  private static async mergeDuplicates(\n    trucks: FoodTruck[],\n    dryRun: boolean,\n    operation: CleanupOperation,\n  ): Promise<CleanupOperation> {\n    const processedIds = new Set<string>();\n    for (const truck of trucks) {\n      await this.processSingleTruckForDuplicates(truck, dryRun, { operation, processedIds });\n    }\n    return operation;\n  }\n\n  /**\n   * Processes a single food truck to detect and handle duplicates in the dataset.\n   * @example\n   * processSingleTruckForDuplicates(foodTruck, true, mergeContext)\n   * // No return value. Performs operations as a side effect.\n   * @param {FoodTruck} truck - An instance of FoodTruck to process for duplicates.\n   * @param {boolean} dryRun - Flag indicating if the operation should be executed in dry run mode.\n   * @param {MergeOperationContext} context - Operational context that carries state and configurations for the merge operation.\n   * @returns {Promise<void>} Executes a set of operations for handling duplicate records, does not return any value.\n   * @description\n   *   - Ensures a food truck is only processed once by maintaining a set of processed IDs.\n   *   - Uses DuplicatePreventionService to assess whether the given truck is a duplicate.\n   *   - Applies a merge operation if a duplicate truck is confidently identified.\n   */\n  private static async processSingleTruckForDuplicates(\n    truck: FoodTruck,\n    dryRun: boolean,\n    context: MergeOperationContext,\n  ): Promise<void> {\n    const { processedIds } = context;\n    if (processedIds.has(truck.id)) return;\n\n    const duplicateCheck = await DuplicatePreventionService.checkForDuplicates(truck);\n    if (\n      duplicateCheck.isDuplicate &&\n      duplicateCheck.bestMatch?.confidence === 'high' &&\n      duplicateCheck.bestMatch.recommendation === 'merge'\n    ) {\n      await this.applyMergeOperation(\n        truck,\n        duplicateCheck.bestMatch.existingTruck,\n        dryRun,\n        context,\n      );\n    }\n    processedIds.add(truck.id);\n  }\n\n  /**\n   * Applies a merge operation between two food trucks and updates the context.\n   * @example\n   * applyMergeOperation(truck, existingTruck, true, context)\n   * // Executes a dry run of the merge operation without affecting data\n   * @param {FoodTruck} truck - The food truck that is being merged.\n   * @param {FoodTruck} existingTruck - The existing food truck to merge with.\n   * @param {boolean} dryRun - Indicates if the merge operation should be simulated.\n   * @param {MergeOperationContext} context - Context containing details and state of the merge operation.\n   * @returns {Promise<void>} Promise representing the completion of the merge operation.\n   * @description\n   *   - Updates the list of processed IDs in the context upon successful merge.\n   *   - Throws and records an error if the merge operation fails.\n   *   - Utilizes the DuplicatePreventionService for performing the merge.\n   */\n  private static async applyMergeOperation(\n    truck: FoodTruck,\n    existingTruck: FoodTruck,\n    dryRun: boolean,\n    context: MergeOperationContext,\n  ): Promise<void> {\n    const { operation, processedIds } = context;\n    operation.affectedCount += 1;\n    if (dryRun) {\n      operation.successCount += 1;\n    } else {\n      try {\n        const mergeResult = await DuplicatePreventionService.mergeDuplicates(\n          truck.id,\n          existingTruck.id,\n        );\n        if ('error' in mergeResult) {\n          throw new Error(mergeResult.error);\n        }\n        processedIds.add(existingTruck.id);\n        operation.successCount += 1;\n      } catch (error) {\n        operation.errorCount += 1;\n        operation.errors.push(\n          `Failed to merge duplicates ${truck.id} and ${existingTruck.id}: ${error instanceof Error ? error.message : String(error)}`,\n        );\n      }\n    }\n  }\n\n  /**\n   * Normalize phone number format\n   */\n  private static normalizePhone(phone: string): string | undefined {\n    if (!phone) return undefined;\n\n    // Remove all non-digit characters\n    const digits = phone.replaceAll(/\\D/g, '');\n\n    // Handle US phone numbers\n    if (digits.length === 10) {\n      return `(${digits.slice(0, 3)}) ${digits.slice(3, 6)}-${digits.slice(6)}`;\n    }\n    if (digits.length === 11 && digits.startsWith('1')) {\n      return `+1 (${digits.slice(1, 4)}) ${digits.slice(4, 7)}-${digits.slice(7)}`;\n    }\n\n    // Return original if can't normalize\n    return phone;\n  }\n\n  /**\n   * Get operation description\n   */\n  private static getOperationDescription(type: CleanupOperation['type']): string {\n    const descriptions = {\n      remove_placeholders: 'Remove placeholder and mock data values',\n      normalize_phone: 'Normalize phone numbers to consistent format',\n      fix_coordinates: 'Fix invalid GPS coordinates',\n      update_quality_scores: 'Recalculate data quality scores',\n      merge_duplicates: 'Identify and merge duplicate truck entries',\n    };\n\n    return descriptions[type] ?? 'Unknown operation';\n  }\n\n  /**\n   * Calculate cleanup summary\n   */\n  private static calculateSummary(operations: CleanupOperation[]): BatchCleanupResult['summary'] {\n    return {\n      trucksImproved: operations.reduce((sum, op) => sum + op.successCount, 0),\n      duplicatesRemoved: operations.find((op) => op.type === 'merge_duplicates')?.successCount ?? 0,\n      qualityScoreImprovement:\n        operations.find((op) => op.type === 'update_quality_scores')?.successCount ?? 0,\n      placeholdersRemoved:\n        operations.find((op) => op.type === 'remove_placeholders')?.successCount ?? 0,\n    };\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\data-quality\\duplicatePrevention.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":233,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":233,"endColumn":21,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[7148,7160],"text":"(loc1.address != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[7148,7160],"text":"(loc1.address ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[7148,7160],"text":"(Boolean(loc1.address))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":233,"column":25,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":233,"endColumn":37,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[7164,7176],"text":"(loc2.address != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[7164,7176],"text":"(loc2.address ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[7164,7176],"text":"(Boolean(loc2.address))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]}],"suppressedMessages":[{"ruleId":"sonarjs/no-redundant-assignments","severity":2,"message":"Review this redundant assignment: \"j\" already holds the assigned value along all execution paths.","line":204,"column":20,"nodeType":"Literal","messageId":"reviewAssignment","endLine":204,"endColumn":21,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * SOTA Duplicate Prevention System\n * Implements intelligent duplicate detection and prevention for food truck data\n */\n\nimport { FoodTruckService, type FoodTruck } from '@/lib/supabase';\n\n// Duplicate detection configuration\nexport const DUPLICATE_DETECTION_CONFIG = {\n  // Similarity thresholds (0.0 = no match, 1.0 = exact match)\n  thresholds: {\n    name: 0.85, // High threshold for name matching\n    location: 0.9, // Very high threshold for location matching\n    phone: 1, // Exact match for phone numbers\n    website: 1, // Exact match for websites\n    overall: 0.8, // Overall similarity threshold\n  },\n\n  // Weight factors for different fields\n  weights: {\n    name: 0.4, // 40% weight for name similarity\n    location: 0.3, // 30% weight for location similarity\n    contact: 0.2, // 20% weight for contact info similarity\n    menu: 0.1, // 10% weight for menu similarity\n  },\n} as const;\n\nexport interface DuplicateMatch {\n  existingTruck: FoodTruck;\n  similarity: number;\n  matchedFields: string[];\n  confidence: 'high' | 'medium' | 'low';\n  recommendation: 'merge' | 'update' | 'skip' | 'manual_review';\n}\n\nexport interface DuplicateDetectionResult {\n  isDuplicate: boolean;\n  matches: DuplicateMatch[];\n  bestMatch?: DuplicateMatch;\n  action: 'create' | 'update' | 'merge' | 'manual_review';\n  reason: string;\n}\n\n/**\n * Advanced Duplicate Prevention Service\n */\nexport class DuplicatePreventionService {\n  /**\n   * Check if a food truck is a duplicate of existing trucks\n   */\n  static async checkForDuplicates(\n    candidateTruck: Partial<FoodTruck>,\n  ): Promise<DuplicateDetectionResult> {\n    try {\n      // Get all existing trucks for comparison\n      const existingTrucksResult = await FoodTruckService.getAllTrucks();\n\n      if ('error' in existingTrucksResult) {\n        console.error('Error fetching existing trucks:', existingTrucksResult.error);\n        return {\n          isDuplicate: false,\n          matches: [],\n          action: 'create',\n          reason: `Error fetching existing trucks: ${existingTrucksResult.error}`,\n        };\n      }\n\n      const existingTrucks = existingTrucksResult.trucks;\n      const matches: DuplicateMatch[] = [];\n\n      for (const existingTruck of existingTrucks) {\n        const similarity = this.calculateSimilarity(candidateTruck, existingTruck);\n\n        if (similarity.overall >= DUPLICATE_DETECTION_CONFIG.thresholds.overall) {\n          matches.push({\n            existingTruck,\n            similarity: similarity.overall,\n            matchedFields: similarity.matchedFields,\n            confidence: this.getConfidenceLevel(similarity.overall),\n            recommendation: this.getRecommendation(similarity),\n          });\n        }\n      }\n\n      return this.processDuplicateMatches(matches, candidateTruck);\n    } catch (error) {\n      console.error('Error checking for duplicates:', error);\n      return {\n        isDuplicate: false,\n        matches: [],\n        action: 'create',\n        reason:\n          'An unexpected error occurred during duplicate detection - proceeding with creation',\n      };\n    }\n  }\n\n  /**\n   * Processes the matches found during duplicate detection and returns the result.\n   */\n  private static processDuplicateMatches(\n    matches: DuplicateMatch[],\n    candidateTruck: Partial<FoodTruck>,\n  ): DuplicateDetectionResult {\n    // Sort matches by similarity (highest first)\n    matches.sort((a, b) => b.similarity - a.similarity);\n\n    const bestMatch = matches.length > 0 ? matches[0] : undefined;\n    const isDuplicate = matches.length > 0;\n\n    return {\n      isDuplicate,\n      matches,\n      bestMatch,\n      action: this.determineAction(matches, candidateTruck),\n      reason: this.generateReason(matches, candidateTruck),\n    };\n  }\n\n  /**\n   * Calculate similarity between two food trucks\n   */\n  private static calculateSimilarity(\n    candidate: Partial<FoodTruck>,\n    existing: FoodTruck,\n  ): { overall: number; matchedFields: string[]; breakdown: Record<string, number> } {\n    const breakdown: Record<string, number> = {};\n    const matchedFields: string[] = [];\n\n    // Name similarity\n    const nameSimilarity = this.calculateStringSimilarity(\n      candidate.name ?? '',\n      existing.name ?? '',\n    );\n    breakdown.name = nameSimilarity;\n    if (nameSimilarity >= DUPLICATE_DETECTION_CONFIG.thresholds.name) {\n      matchedFields.push('name');\n    }\n\n    // Location similarity\n    const locationSimilarity = this.calculateLocationSimilarity(\n      candidate.current_location,\n      existing.current_location,\n    );\n    breakdown.location = locationSimilarity;\n    if (locationSimilarity >= DUPLICATE_DETECTION_CONFIG.thresholds.location) {\n      matchedFields.push('location');\n    }\n\n    // Contact similarity\n    const contactSimilarity = this.calculateContactSimilarity(\n      candidate.contact_info,\n      existing.contact_info,\n    );\n    breakdown.contact = contactSimilarity;\n    if (contactSimilarity >= DUPLICATE_DETECTION_CONFIG.thresholds.phone) {\n      matchedFields.push('contact');\n    }\n\n    // Menu similarity (basic)\n    const menuSimilarity = this.calculateMenuSimilarity(candidate.menu, existing.menu);\n    breakdown.menu = menuSimilarity;\n    if (menuSimilarity > 0.7) {\n      matchedFields.push('menu');\n    }\n\n    // Calculate weighted overall similarity\n    const overall =\n      nameSimilarity * DUPLICATE_DETECTION_CONFIG.weights.name +\n      locationSimilarity * DUPLICATE_DETECTION_CONFIG.weights.location +\n      contactSimilarity * DUPLICATE_DETECTION_CONFIG.weights.contact +\n      menuSimilarity * DUPLICATE_DETECTION_CONFIG.weights.menu;\n\n    return { overall, matchedFields, breakdown };\n  }\n\n  /**\n   * Calculate string similarity using Levenshtein distance\n   */\n  private static calculateStringSimilarity(str1: string, str2: string): number {\n    if (!str1 || !str2) return 0;\n\n    // Normalize strings\n    const s1 = str1.toLowerCase().trim();\n    const s2 = str2.toLowerCase().trim();\n\n    if (s1 === s2) return 1;\n\n    // Calculate Levenshtein distance\n    const matrix: number[][] = [];\n    const len1 = s1.length;\n    const len2 = s2.length;\n\n    for (let i = 0; i <= len1; i+=1) {\n      matrix[i] = [i];\n    }\n\n    for (let j = 0; j <= len2; j+=1) {\n      matrix[0][j] = j;\n    }\n\n    for (let i = 1; i <= len1; i+=1) {\n      // eslint-disable-next-line sonarjs/no-redundant-assignments\n      for (let j = 1; j <= len2; j+=1) {\n        const cost = s1[i - 1] === s2[j - 1] ? 0 : 1;\n        matrix[i][j] = Math.min(\n          matrix[i - 1][j] + 1, // deletion\n          matrix[i][j - 1] + 1, // insertion\n          matrix[i - 1][j - 1] + cost, // substitution\n        );\n      }\n    }\n\n    const distance = matrix[len1][len2];\n    const maxLength = Math.max(len1, len2);\n\n    return maxLength === 0 ? 1 : 1 - distance / maxLength;\n  }\n\n  /**\n   * Calculate location similarity\n   */\n  private static calculateLocationSimilarity(\n    loc1: FoodTruck['current_location'] | undefined | null,\n    loc2: FoodTruck['current_location'] | undefined | null,\n  ): number {\n    if (!loc1 || !loc2) return 0;\n\n    let similarity = 0;\n    let factors = 0;\n\n    // Address similarity\n    if (loc1.address && loc2.address) {\n      similarity += this.calculateStringSimilarity(loc1.address, loc2.address);\n      factors+=1;\n    }\n\n    // GPS coordinate similarity (within 100 meters = high similarity)\n    if (loc1.lat && loc1.lng && loc2.lat && loc2.lng) {\n      const distance = this.calculateGPSDistance(loc1.lat, loc1.lng, loc2.lat, loc2.lng);\n\n      // Distance similarity (closer = higher similarity)\n      const distanceSimilarity = distance <= 0.1 ? 1 : Math.max(0, 1 - distance / 1); // 1km max\n      similarity += distanceSimilarity;\n      factors+=1;\n    }\n\n    return factors > 0 ? similarity / factors : 0;\n  }\n\n  /**\n   * Calculate GPS distance in kilometers\n   */\n  private static calculateGPSDistance(\n    lat1: number,\n    lng1: number,\n    lat2: number,\n    lng2: number,\n  ): number {\n    const R = 6371; // Earth's radius in kilometers\n    const dLat = ((lat2 - lat1) * Math.PI) / 180;\n    const dLng = ((lng2 - lng1) * Math.PI) / 180;\n    const a =\n      Math.sin(dLat / 2) * Math.sin(dLat / 2) +\n      Math.cos((lat1 * Math.PI) / 180) *\n        Math.cos((lat2 * Math.PI) / 180) *\n        Math.sin(dLng / 2) *\n        Math.sin(dLng / 2);\n    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n    return R * c;\n  }\n\n  /**\n   * Calculate contact similarity\n   */\n  private static calculateContactSimilarity(\n    contact1: FoodTruck['contact_info'] | undefined | null,\n    contact2: FoodTruck['contact_info'] | undefined | null,\n  ): number {\n    if (!contact1 || !contact2) return 0;\n\n    let matches = 0;\n    let total = 0;\n\n    // Phone number exact match\n    if (contact1.phone != undefined && contact2.phone != undefined) {\n      const phone1 = contact1.phone.replaceAll(/\\D/g, ''); // Remove non-digits\n      const phone2 = contact2.phone.replaceAll(/\\D/g, '');\n      if (phone1 === phone2) matches+=1;\n      total+=1;\n    }\n\n    // Website exact match\n    if (contact1.website != undefined && contact2.website != undefined) {\n      const url1 = contact1.website\n        .toLowerCase()\n        .replace(/^https?:\\/\\//, '')\n        .replace(/\\/$/, '');\n      const url2 = contact2.website\n        .toLowerCase()\n        .replace(/^https?:\\/\\//, '')\n        .replace(/\\/$/, '');\n      if (url1 === url2) matches+=1;\n      total+=1;\n    }\n\n    // Email similarity\n    if (contact1.email != undefined && contact2.email != undefined) {\n      if (contact1.email.toLowerCase() === contact2.email.toLowerCase()) matches+=1;\n      total+=1;\n    }\n\n    return total > 0 ? matches / total : 0;\n  }\n\n  /**\n   * Calculate menu similarity (basic implementation)\n   */\n  private static calculateMenuSimilarity(\n    menu1: FoodTruck['menu'] | undefined | null,\n    menu2: FoodTruck['menu'] | undefined | null,\n  ): number {\n    if (!menu1 || !menu2 || menu1.length === 0 || menu2.length === 0) return 0;\n\n    // Simple category name matching\n    const categories1 = menu1\n      .map((cat) => (cat as { category?: string }).category?.toLowerCase() ?? '')\n      .filter(Boolean);\n    const categories2 = menu2\n      .map((cat) => (cat as { category?: string }).category?.toLowerCase() ?? '')\n      .filter(Boolean);\n\n    const commonCategories = categories1.filter((cat) => categories2.includes(cat));\n    const totalCategories = new Set([...categories1, ...categories2]).size;\n\n    return totalCategories > 0 ? commonCategories.length / totalCategories : 0;\n  }\n\n  /**\n   * Get confidence level based on similarity score\n   */\n  private static getConfidenceLevel(similarity: number): 'high' | 'medium' | 'low' {\n    if (similarity >= 0.95) return 'high';\n    if (similarity >= 0.85) return 'medium';\n    return 'low';\n  }\n\n  /**\n   * Get recommendation based on similarity analysis\n   */\n  private static getRecommendation(similarity: {\n    overall: number;\n    matchedFields: string[];\n  }): 'merge' | 'update' | 'skip' | 'manual_review' {\n    if (similarity.overall >= 0.95) return 'merge';\n    if (similarity.overall >= 0.9) return 'update';\n    if (similarity.overall >= 0.8) return 'manual_review';\n    return 'skip';\n  }\n\n  /**\n   * Determine action based on matches\n   */\n  private static determineAction(\n    matches: DuplicateMatch[],\n    _candidate: Partial<FoodTruck>,\n  ): 'create' | 'update' | 'merge' | 'manual_review' {\n    if (matches.length === 0) return 'create';\n\n    const bestMatch = matches[0];\n\n    if (bestMatch.confidence === 'high') {\n      const {recommendation} = bestMatch;\n      if (recommendation === 'merge' || recommendation === 'update') {\n        return recommendation;\n      }\n      return 'manual_review';\n    }\n\n    return 'manual_review';\n  }\n\n  /**\n   * Generate human-readable reason\n   */\n  private static generateReason(matches: DuplicateMatch[], _candidate: Partial<FoodTruck>): string {\n    if (matches.length === 0) {\n      return 'No duplicates found - safe to create new truck entry';\n    }\n\n    const bestMatch = matches[0];\n    const similarity = Math.round(bestMatch.similarity * 100);\n\n    return `Found ${matches.length} potential duplicate(s). Best match: ${similarity}% similarity with \"${bestMatch.existingTruck.name}\" (matched: ${bestMatch.matchedFields.join(', ')})`;\n  }\n\n  /**\n   * Merge duplicate truck data intelligently\n   */\n  static async mergeDuplicates(\n    targetId: string,\n    sourceId: string,\n  ): Promise<FoodTruck | { error: string }> {\n    const targetResult = await FoodTruckService.getTruckById(targetId);\n    const sourceResult = await FoodTruckService.getTruckById(sourceId);\n\n    if ('error' in targetResult) {\n      return {\n        error: `Failed to retrieve target truck with ID ${targetId}: ${targetResult.error}`,\n      };\n    }\n    if ('error' in sourceResult) {\n      return {\n        error: `Failed to retrieve source truck with ID ${sourceId}: ${sourceResult.error}`,\n      };\n    }\n\n    const target = targetResult;\n    const source = sourceResult;\n\n    // Merge logic: prefer non-null, more complete data\n    const mergedData: Partial<FoodTruck> = {\n      name: target.name ?? source.name,\n      description: target.description ?? source.description,\n      cuisine_type:\n        (target.cuisine_type?.length ?? 0) > 0 ? target.cuisine_type : source.cuisine_type,\n      price_range: target.price_range ?? source.price_range,\n      current_location: target.current_location ?? source.current_location,\n      contact_info: {\n        ...source.contact_info,\n        ...target.contact_info, // Target takes precedence\n      },\n      operating_hours: target.operating_hours ?? source.operating_hours,\n      menu: (target.menu?.length ?? 0) > 0 ? target.menu : source.menu,\n      social_media: {\n        ...source.social_media,\n        ...target.social_media,\n      },\n      source_urls: [...new Set([...(target.source_urls ?? []), ...(source.source_urls ?? [])])],\n      last_scraped_at: new Date().toISOString(),\n    };\n\n    // Update target with merged data\n    const updatedTruckResult = await FoodTruckService.updateTruck(targetId, mergedData);\n\n    if ('error' in updatedTruckResult) {\n      return {\n        error: `Failed to update target truck with merged data: ${updatedTruckResult.error}`,\n      };\n    }\n\n    console.info(`Merged truck ${sourceId} into ${targetId}`);\n\n    return updatedTruckResult;\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\data-quality\\placeholderUtils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\discoveryEngine.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\firecrawl.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\gemini.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\gemini\\geminiApiClient.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\gemini\\promptTemplates.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":223,"column":3,"nodeType":"Identifier","messageId":"conditionErrorNullableString","endLine":223,"endColumn":12,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[7097,7106],"text":"(sourceUrl != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[7097,7106],"text":"(sourceUrl ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[7097,7106],"text":"(Boolean(sourceUrl))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"export const PromptTemplates = {\n  menuProcessing: (rawMenuText: string) => `\nParse the following food truck menu text and return a structured JSON format.\nExtract menu items with categories, names, descriptions, prices, and dietary tags.\n\nMenu text:\n${rawMenuText}\n\nExpected JSON format:\n[\n  {\n    \"category\": \"string\",\n    \"items\": [\n      {\n        \"name\": \"string\",\n        \"description\": \"string\",\n        \"price\": number,\n        \"dietary_tags\": [\"string\"]\n      }\n    ]\n  }\n]\n\nRules:\n- Extract actual prices as numbers (e.g., 12.99, not \"$12.99\")\n- Include dietary restrictions and special tags\n- Group items into logical categories\n- If no clear categories, use \"Main Items\"\n- Return only the json, no additional text\n  `,\n\n  locationExtraction: (textInput: string) => `\nExtract location information from the following text and return structured data.\nLook for addresses, cross streets, landmarks, or location descriptions.\n\nText:\n${textInput}\n\nExpected JSON format:\n{\n  \"address\": \"string or undefined\",\n  \"city\": \"string or undefined\", \n  \"state\": \"string or undefined\",\n  \"zipCode\": \"string or undefined\",\n  \"coordinates\": {\"lat\": number, \"lng\": number} or undefined,\n  \"confidence\": number,\n  \"landmarks\": [\"string\"]\n}\n\nRules:\n- Set coordinates to undefined if not explicitly provided\n- Confidence should be 0.0 to 1.0 based on clarity\n- Include any mentioned landmarks or cross streets\n- Return only the json, no additional text\n  `,\n\n  operatingHours: (hoursText: string) => `\nParse the following operating hours text and return standardized format.\nConvert all times to 24-hour format and handle various input formats.\n\nHours text:\n${hoursText}\n\nExpected JSON format:\n{\n  \"monday\": {\"open\": \"HH:MM\", \"close\": \"HH:MM\", \"closed\": false},\n  \"tuesday\": {\"open\": \"HH:MM\", \"close\": \"HH:MM\", \"closed\": false},\n  \"wednesday\": {\"open\": \"HH:MM\", \"close\": \"HH:MM\", \"closed\": false},\n  \"thursday\": {\"open\": \"HH:MM\", \"close\": \"HH:MM\", \"closed\": false},\n  \"friday\": {\"open\": \"HH:MM\", \"close\": \"HH:MM\", \"closed\": false},\n  \"saturday\": {\"open\": \"HH:MM\", \"close\": \"HH:MM\", \"closed\": false},\n  \"sunday\": {\"open\": \"HH:MM\", \"close\": \"HH:MM\", \"closed\": false}\n}\n\nRules:\n- Use 24-hour format (e.g., \"14:30\" for 2:30 pm)\n- If closed on a day, set \"closed\": true and omit open/close times\n- Handle ranges like \"Mon-Fri\" by applying to all days in range\n- Default to reasonable hours if ambiguous\n- Return only the json, no additional text\n  `,\n\n  sentimentAnalysis: (reviewText: string) => `\nAnalyze the sentiment of this food truck review and extract key insights.\nFocus on food quality, service, value, and overall experience.\n\nReview text:\n${reviewText}\n\nExpected JSON format:\n{\n  \"score\": number,\n  \"confidence\": number,\n  \"aspects\": {\n    \"food_quality\": number,\n    \"service\": number,\n    \"value\": number,\n    \"overall\": number\n  },\n  \"summary\": \"string\",\n  \"keywords\": [\"string\"]\n}\n\nRules:\n- Score should be 0.0 (very negative) to 1.0 (very positive)\n- Confidence should be 0.0 to 1.0 based on clarity of sentiment\n- Include specific aspects mentioned in the review\n- Summary should be 1-2 sentences max\n- Return only the json, no additional text\n  `,\n\n  dataEnhancement: (rawData: unknown) => `\nEnhance and standardize the following food truck data.\nFill in missing information where possible and improve data quality.\n\nRaw data:\n${JSON.stringify(rawData, undefined, 2)}\n\nExpected JSON format:\n{\n  \"name\": \"string\",\n  \"description\": \"string\",\n  \"cuisine_type\": \"string\",\n  \"price_range\": \"$ | $$ | $$$ | $$$$\",\n  \"contact\": {\n    \"phone\": \"string\",\n    \"email\": \"string\",\n    \"website\": \"string\",\n    \"social_media\": {}\n  },\n  \"location\": {\n    \"address\": \"string\",\n    \"city\": \"string\",\n    \"state\": \"string\",\n    \"coordinates\": {\"lat\": number, \"lng\": number}\n  },\n  \"operating_hours\": {},\n  \"menu_categories\": [\"string\"],\n  \"specialties\": [\"string\"],\n  \"dietary_options\": [\"string\"]\n}\n\nRules:\n- Preserve all original data while enhancing it\n- Standardize naming conventions\n- Infer cuisine type from menu items\n- Estimate price range from menu prices\n- Return only the json, no additional text\n  `,\n\n  foodTruckExtraction: (markdownContent: string, sourceUrl?: string) => {\n    const schema = `\nExpected JSON schema:\n{\n  \"name\": \"string (food truck name)\",\n  \"description\": \"string (brief description of the food truck)\",\n  \"cuisine_type\": \"string (type of cuisine served)\",\n  \"contact\": {\n    \"phone\": \"string (phone number if found)\",\n    \"email\": \"string (email if found)\", \n    \"website\": \"string (website URL if found)\",\n    \"social_media\": {\n      \"facebook\": \"string (Facebook URL if found)\",\n      \"instagram\": \"string (Instagram URL if found)\",\n      \"twitter\": \"string (Twitter URL if found)\"\n    }\n  },\n  \"location\": {\n    \"address\": \"string (physical address if found)\",\n    \"city\": \"string (city name)\",\n    \"state\": \"string (state abbreviation)\",\n    \"coordinates\": {\n      \"lat\": \"number (latitude if found)\",\n      \"lng\": \"number (longitude if found)\"\n    }\n  },\n  \"operating_hours\": {\n    \"monday\": {\"open\": \"string (HH:MM)\", \"close\": \"string (HH:MM)\", \"closed\": \"boolean\"},\n    \"tuesday\": {\"open\": \"string (HH:MM)\", \"close\": \"string (HH:MM)\", \"closed\": \"boolean\"},\n    \"wednesday\": {\"open\": \"string (HH:MM)\", \"close\": \"string (HH:MM)\", \"closed\": \"boolean\"},\n    \"thursday\": {\"open\": \"string (HH:MM)\", \"close\": \"string (HH:MM)\", \"closed\": \"boolean\"},\n    \"friday\": {\"open\": \"string (HH:MM)\", \"close\": \"string (HH:MM)\", \"closed\": \"boolean\"},\n    \"saturday\": {\"open\": \"string (HH:MM)\", \"close\": \"string (HH:MM)\", \"closed\": \"boolean\"},\n    \"sunday\": {\"open\": \"string (HH:MM)\", \"close\": \"string (HH:MM)\", \"closed\": \"boolean\"}\n  },\n  \"menu\": [\n    {\n      \"category\": \"string (menu category)\",\n      \"items\": [\n        {\n          \"name\": \"string (item name)\",\n          \"description\": \"string (item description)\",\n          \"price\": \"number (price as number, not string)\",\n          \"dietary_tags\": [\"string (dietary restrictions/tags)\"]\n        }\n      ]\n    }\n  ],\n  \"specialties\": [\"string (signature dishes or specialties)\"],\n  \"dietary_options\": [\"string (dietary accommodations like vegan, gluten-free)\"],\n  \"price_range\": \"string ($ for under $10, $$ for $10-20, $$$ for $20-30, $$$$ for over $30)\"\n}\n`;\n\n    const instructions = `\nInstructions:\n- Extract as much information as possible from the provided content\n- If information is not available, use null for the field\n- For operating hours, use 24-hour format (e.g., \"14:30\" for 2:30 PM)\n- If a day is closed, set \"closed\": true and omit open/close times\n- For prices, extract numeric values only (e.g., 12.99, not \"$12.99\")\n- Be thorough in extracting menu items and their details\n- Look for social media links and contact information carefully\n- Return only the JSON object, no additional text or formatting\n`;\n\n    return `\nYou are an ai assistant tasked with extracting structured information about food trucks from their website content (provided in Markdown format). Your goal is to populate a json object with the following schema. Only return the json object, nothing else.\n\nWebsite content:\n${markdownContent}\n\n${sourceUrl ? `Source URL: ${sourceUrl}` : ''}\n\n${schema}\n\n${instructions}\n`;\n  },\n};\n","usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\gemini\\responseParser.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\gemini\\usageLimits.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\middleware\\middlewareHelpers.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":33,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":33,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[760,763],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[760,763],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":74,"column":7,"nodeType":"Identifier","messageId":"conditionErrorNullableString","endLine":74,"endColumn":23,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[2564,2580],"text":"redirectFromPath != null"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[2564,2580],"text":"redirectFromPath ?? \"\""},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[2564,2580],"text":"Boolean(redirectFromPath)"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { NextRequest, NextResponse } from 'next/server';\r\nimport { AuditLogger, SecurityEvent } from '@/lib/security/auditLogger';\r\nimport { createSupabaseMiddlewareClient } from '@/lib/supabaseMiddleware';\r\n\r\ninterface RequestMetadata {\r\n  ip: string;\r\n  userAgent: string;\r\n  url: string;\r\n  method: string;\r\n}\r\n\r\ninterface SupabaseUser {\r\n  id: string;\r\n  email?: string;\r\n}\r\n\r\ninterface SupabaseProfile {\r\n  role?: string;\r\n}\r\n\r\ninterface LogAndRedirectParams {\r\n  req: NextRequest;\r\n  res: NextResponse;\r\n  requestMetadata: RequestMetadata;\r\n  reason: string;\r\n  userError?: { message?: string };\r\n}\r\n\r\ninterface LogSecurityEventParams {\r\n  event_type: SecurityEvent['event_type'];\r\n  ip_address: string;\r\n  user_agent: string;\r\n  details: Record<string, any>;\r\n  severity: SecurityEvent['severity'];\r\n  user_id?: string;\r\n  user_email?: string;\r\n}\r\n\r\ninterface LogSecurityEventAndRedirectParams {\r\n  req: NextRequest;\r\n  res: NextResponse;\r\n  logParams: LogSecurityEventParams;\r\n  redirectPath: string;\r\n  redirectFromPath?: string;\r\n}\r\n\r\n/**\r\n * Logs a security event and redirects the request to a specified path.\r\n * @example\r\n * logSecurityEventAndRedirect({ req, res, logParams, redirectPath, redirectFromPath })\r\n * NextResponse with redirect to the target path\r\n * @param {Object} params - The parameters for the function.\r\n * @param {Request} params.req - The original request object containing the URL to clone for redirection.\r\n * @param {Response} params._res - The original response object (unused in function, but part of expected parameters).\r\n * @param {Object} params.logParams - Parameters required by the AuditLogger to log the security event.\r\n * @param {string} params.redirectPath - The pathname where the request should be redirected.\r\n * @param {string} [params.redirectFromPath] - Optional pathname indicating where the redirect originated from.\r\n * @returns {NextResponse} A response that performs a redirect to the specified path.\r\n * @description\r\n *   - The function uses AuditLogger to record the security event.\r\n *   - It clones the current URL from the request to ensure original query parameters are preserved.\r\n *   - Redirect path can optionally include info on where the redirect originated via a search parameter.\r\n */\r\nasync function logSecurityEventAndRedirect({\r\n  req,\r\n  res: _res,\r\n  logParams,\r\n  redirectPath,\r\n  redirectFromPath,\r\n}: LogSecurityEventAndRedirectParams) {\r\n  await AuditLogger.logSecurityEvent(logParams);\r\n  const redirectUrl = req.nextUrl.clone();\r\n  redirectUrl.pathname = redirectPath;\r\n  if (redirectFromPath) {\r\n    redirectUrl.searchParams.set(`redirectedFrom`, redirectFromPath);\r\n  }\r\n  return NextResponse.redirect(redirectUrl);\r\n}\r\n\r\n/**\r\n * Logs a security event and redirects the user to the login page.\r\n * @example\r\n * logAndRedirect({\r\n *   req: requestObject, \r\n *   res: responseObject, \r\n *   requestMetadata: { ip: '192.168.1.1', userAgent: 'Mozilla/5.0', url: '/dashboard' }, \r\n *   reason: 'Session Expired', \r\n *   userError: new Error('User authentication failed')\r\n * })\r\n * // Redirects user to login page and logs the event\r\n * @param {Object} req - Express request object containing details of the incoming request.\r\n * @param {Object} res - Express response object used to send a response to the client.\r\n * @param {Object} requestMetadata - Metadata associated with the request, including IP and user agent.\r\n * @param {string} reason - The reason for redirect, generally describing why access was denied.\r\n * @param {Error} userError - Optional error object that provides additional context about the user error.\r\n * @returns {Promise<void>} Returns a promise that resolves once the security event is logged and redirect is completed.\r\n * @description\r\n *   - Utilizes a severity of 'warning' when logging security events.\r\n *   - Redirects users from the attempted URL to the login page.\r\n *   - Captures detailed information about the request including attempted URL and user agent.\r\n */\r\nasync function logAndRedirect({\r\n  req,\r\n  res,\r\n  requestMetadata,\r\n  reason,\r\n  userError,\r\n}: LogAndRedirectParams) {\r\n  return logSecurityEventAndRedirect({\r\n    req,\r\n    res,\r\n    logParams: {\r\n      event_type: 'permission_denied',\r\n      ip_address: requestMetadata.ip,\r\n      user_agent: requestMetadata.userAgent,\r\n      details: {\r\n        attempted_url: requestMetadata.url,\r\n        reason,\r\n        error: userError?.message,\r\n      },\r\n      severity: 'warning',\r\n    },\r\n    redirectPath: '/login',\r\n    redirectFromPath: req.nextUrl.pathname,\r\n  });\r\n}\r\n\r\ninterface LogAndRedirectDeniedParams {\r\n  req: NextRequest;\r\n  res: NextResponse;\r\n  requestMetadata: RequestMetadata;\r\n  user: SupabaseUser;\r\n  profile: SupabaseProfile | null;\r\n  profileQueryError?: { message?: string } | null; // Changed to allow null\r\n}\r\n\r\n/**\r\n * Logs a security event and redirects to an access-denied page.\r\n * @example\r\n * logAndRedirectDenied({\r\n *   req: requestObject,\r\n *   res: responseObject,\r\n *   requestMetadata: metadataObject,\r\n *   user: userObject,\r\n *   profile: profileObject,\r\n *   profileQueryError: errorObject\r\n * })\r\n * // Redirects user and logs the event with relevant details\r\n * @param {Object} params - Contains necessary parameters for the function.\r\n * @param {Object} params.req - The HTTP request object.\r\n * @param {Object} params.res - The HTTP response object.\r\n * @param {Object} params.requestMetadata - Metadata related to the request.\r\n * @param {Object} params.user - User information object.\r\n * @param {Object} params.profile - Profile object related to the user.\r\n * @param {Object} params.profileQueryError - Error object if querying profile fails.\r\n * @returns {Promise<void>} Returns a promise that resolves after logging and redirecting.\r\n * @description\r\n *   - Utilizes `logSecurityEventAndRedirect` to perform logging and redirect operations.\r\n *   - The function assumes a structure for the user object, expecting 'id' and 'email' properties.\r\n *   - Redirects to '/access-denied' path by default.\r\n *   - Sets event severity as 'error' when logging the security event.\r\n */\r\nasync function logAndRedirectDenied({\r\n  req,\r\n  res,\r\n  requestMetadata,\r\n  user,\r\n  profile,\r\n  profileQueryError,\r\n}: LogAndRedirectDeniedParams) {\r\n  return logSecurityEventAndRedirect({\r\n    req,\r\n    res,\r\n    logParams: {\r\n      event_type: 'permission_denied',\r\n      user_id: user.id,\r\n      user_email: user.email ?? undefined,\r\n      ip_address: requestMetadata.ip,\r\n      user_agent: requestMetadata.userAgent,\r\n      details: {\r\n        attempted_url: requestMetadata.url,\r\n        user_role: profile?.role ?? 'none',\r\n        reason: 'insufficient_privileges',\r\n        error: profileQueryError?.message,\r\n      },\r\n      severity: 'error',\r\n    },\r\n    redirectPath: '/access-denied',\r\n  });\r\n}\r\n\r\n/**\r\n * Protects admin routes by verifying user authentication and authorization.\r\n * @example\r\n * protectAdminRoutes(req, res, requestMetadata)\r\n * returns NextResponse or redirects depending on user authentication status.\r\n * @param {NextRequest} req - The incoming request object.\r\n * @param {NextResponse} res - The response object to send back to the client.\r\n * @param {RequestMetadata} requestMetadata - Metadata about the request for logging purposes.\r\n * @returns {NextResponse} Returns the response object or redirects to an error page.\r\n * @description\r\n *   - Fetches and verifies the user's session from Supabase.\r\n *   - Checks if the user is an admin based on the profile 'role' from the database.\r\n *   - Logs access attempts to the admin panel for auditing purposes.\r\n *   - Redirects to an appropriate error handler if the user isn't authenticated or authorized.\r\n */\r\nexport async function protectAdminRoutes(\r\n  req: NextRequest,\r\n  res: NextResponse,\r\n  requestMetadata: RequestMetadata,\r\n) {\r\n  const supabase = createSupabaseMiddlewareClient(req, res);\r\n  const { data, error: userError } = await supabase.auth.getUser();\r\n  const user = data?.user;\r\n\r\n  if (userError || !user) {\r\n    return logAndRedirect({\r\n      req,\r\n      res,\r\n      requestMetadata,\r\n      reason: 'no_session',\r\n      userError: userError ?? undefined,\r\n    });\r\n  }\r\n  // Explicitly type the result of the Supabase query\r\n  const { data: profile, error: profileQueryError } = (await supabase\r\n    .from('profiles')\r\n    .select('role')\r\n    .eq('id', user.id)\r\n    .single()) as { data: SupabaseProfile | null; error: { message?: string } | null };\r\n  if (profileQueryError || (profile && profile.role !== 'admin')) {\r\n    return logAndRedirectDenied({\r\n      req,\r\n      res,\r\n      requestMetadata,\r\n      user,\r\n      profile: profile ?? undefined,\r\n      profileQueryError: profileQueryError ?? undefined,\r\n    });\r\n  }\r\n  if (req.method !== 'GET' || req.nextUrl.pathname.includes('/api/')) {\r\n    await AuditLogger.logDataAccess({\r\n      userId: user.id,\r\n      userEmail: user.email ?? 'unknown',\r\n      resourceType: 'admin_panel',\r\n      resourceId: req.nextUrl.pathname,\r\n      action: req.method === 'GET' ? 'read' : 'admin_access',\r\n      request: {\r\n        ip: requestMetadata.ip,\r\n        userAgent: requestMetadata.userAgent,\r\n      },\r\n    });\r\n  }\r\n  return res;\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\monitoring\\apiMonitor.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\performance\\bundleAnalyzer.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\performance\\databaseCache.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\performance\\webVitals.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\pipelineManager.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\pipelineProcessor.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\pipeline\\pipelineHelpers.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\pipeline\\scrapingProcessor.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":29,"column":33,"nodeType":"ChainExpression","messageId":"conditionErrorNullableString","endLine":29,"endColumn":60,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[1234,1262],"text":"((scrapeResult.data?.markdown) == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[1235,1262],"text":"((scrapeResult.data?.markdown) ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[1234,1262],"text":"(!Boolean((scrapeResult.data?.markdown)))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":110,"column":9,"nodeType":"Identifier","messageId":"conditionErrorObject","endLine":110,"endColumn":12},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":145,"column":10,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":145,"endColumn":24,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[6496,6511],"text":"job.target_url == null"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[6497,6511],"text":"(job.target_url ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[6496,6511],"text":"!Boolean(job.target_url)"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { firecrawl } from '@/lib/firecrawl';\r\nimport { gemini } from '@/lib/gemini';\r\nimport { ScrapingJobService } from '@/lib/supabase';\r\nimport { ExtractedFoodTruckDetails } from '../types';\r\nimport {\r\n  validateInputAndPrepare,\r\n  buildTruckDataSchema,\r\n  handleDuplicateCheck,\r\n  finalizeJobStatus,\r\n} from './pipelineHelpers';\r\n\r\n/**\r\n * Initiates web scraping for a specified food truck website.\r\n * @example\r\n * handleScraping(\"https://foodtruck.com\", \"job123\")\r\n * Returns data object with markdown content\r\n * @param {string} targetUrl - The URL of the food truck website to scrape.\r\n * @param {string} jobId - The unique identifier for the scraping job.\r\n * @returns {Object} An object containing the scraped data, including markdown content.\r\n * @description\r\n *   - Utilizes firecrawl library to perform web scraping.\r\n *   - Calls handleJobFailure if scraping is unsuccessful or markdown content is missing.\r\n *   - Logs the progress and success of the scraping process in the console.\r\n */\r\nasync function handleScraping(targetUrl: string, jobId: string) {\r\n  console.info(`Starting scrape for ${targetUrl}`);\r\n  const scrapeResult = await firecrawl.scrapeFoodTruckWebsite(targetUrl);\r\n\r\n  if (!scrapeResult.success || !scrapeResult.data?.markdown) {\r\n    const error = scrapeResult.error ?? 'Scraping failed or markdown content not found';\r\n    await handleJobFailure(jobId, error);\r\n    throw new Error(error);\r\n  }\r\n\r\n  console.info(`Scraping successful for ${targetUrl}, proceeding to Gemini extraction.`);\r\n  return scrapeResult.data;\r\n}\r\n\r\n/**\r\n * Handles the extraction of food truck details using Gemini and manages job failures.\r\n * @example\r\n * handleGeminiExtraction(\"sample_markdown\", \"http://example.com\", \"12345\")\r\n * { name: \"Sample Food Truck\", location: \"123 Main St.\" }\r\n * @param {string} markdown - The Markdown content containing food truck details.\r\n * @param {string} sourceUrl - The URL of the source from which details are extracted.\r\n * @param {string} jobId - The identifier for the job being processed.\r\n * @returns {Object} The extracted food truck details if successful.\r\n * @description\r\n *   - Utilizes Gemini to extract data from the provided Markdown content.\r\n *   - Handles failure scenarios by logging errors and updating job status.\r\n *   - Throws an error when extraction is unsuccessful.\r\n */\r\nasync function handleGeminiExtraction(markdown: string, sourceUrl: string, jobId: string) {\r\n  const geminiResult = await gemini.extractFoodTruckDetailsFromMarkdown(markdown, sourceUrl);\r\n\r\n  if (!geminiResult.success || !geminiResult.data) {\r\n    const error = geminiResult.error ?? 'Gemini data extraction failed';\r\n    await handleJobFailure(jobId, error);\r\n    throw new Error(error);\r\n  }\r\n\r\n  console.info(`Gemini extraction successful for ${sourceUrl}.`);\r\n  return geminiResult.data;\r\n}\r\n\r\n/**\r\n* Handles the failure of a job by updating its status.\r\n* @example\r\n* handleJobFailure('job1234', 'Timeout error')\r\n* // Output: Logs an error message and updates the job status.\r\n* @param {string} jobId - The unique identifier of the job that failed.\r\n* @param {string} error - The error message describing the reason for failure.\r\n* @returns {Promise<void>} Resolves successfully once the job status is updated.\r\n* @description\r\n*   - Logs the error to the console for debugging purposes.\r\n*   - Checks if the current job status is not already 'failed' before updating.\r\n*   - Updates the job status to 'failed' if applicable, capturing any errors encountered.\r\n*   - Manages any errors that arise during the status update attempt.\r\n*/\r\nasync function handleJobFailure(jobId: string, error: string) {\r\n  console.error(`Job ${jobId} failed:`, error);\r\n  try {\r\n    const currentJob = await ScrapingJobService.getJobsByStatus('all').then((jobs) =>\r\n      jobs.find((j) => j.id === jobId),\r\n    );\r\n    if (currentJob && currentJob.status !== 'failed') {\r\n      await ScrapingJobService.updateJobStatus(jobId, 'failed', { errors: [error] });\r\n    }\r\n  } catch (statusUpdateError) {\r\n    console.error(`Error updating job ${jobId} status to failed:`, statusUpdateError);\r\n  }\r\n}\r\n\r\n/**\r\n * Manages retry logic for a scraping job based on its current retry count.\r\n * @example\r\n * handleRetryLogic(\"job123\")\r\n * undefined\r\n * @param {string} jobId - The unique identifier for the scraping job.\r\n * @returns {Promise<void>} Does not return a value but handles retries or logs errors.\r\n * @description\r\n *   - Utilizes ScrapingJobService to increment the retry count for the given job.\r\n *   - Determines whether to retry the job based on retry_count and max_retries properties.\r\n *   - Logs messages to inform about retry attempts or if max retries have been reached.\r\n *   - Catches and logs errors encountered during the retry process.\r\n */\r\nasync function handleRetryLogic(jobId: string) {\r\n  try {\r\n    const job = await ScrapingJobService.incrementRetryCount(jobId);\r\n    if (job && typeof job.retry_count === 'number' && typeof job.max_retries === 'number') {\r\n      if (job.retry_count < job.max_retries) {\r\n        console.info(`Retrying job ${jobId} (attempt ${job.retry_count}/${job.max_retries})`);\r\n        setTimeout(() => {\r\n          void processScrapingJob(jobId);\r\n        }, 5000);\r\n      } else {\r\n        console.warn(`Job ${jobId} reached max retries (${job.max_retries}).`);\r\n      }\r\n    } else {\r\n      console.error(\r\n        `Job ${jobId}: Could not get valid retry_count or max_retries. Won't attempt retry.`,\r\n      );\r\n    }\r\n  } catch (retryError) {\r\n    console.error(`Error during retry logic for job ${jobId}:`, retryError);\r\n  }\r\n}\r\n\r\n/**\r\n * Processes a scraping job by managing its lifecycle and data extraction.\r\n * @example\r\n * processScrapingJob('12345')\r\n * // Scraping job 12345 completed successfully and data processed.\r\n * @param {string} jobId - The unique identifier for the scraping job.\r\n * @returns {Promise<void>} Resolves when the job is completed or retried.\r\n * @description\r\n *   - Updates the scraping job status to 'running' at the beginning and 'completed' at the end of the process.\r\n *   - Performs data scraping and extraction using job's target URL.\r\n *   - Handles scenarios where a target URL is not specified, resulting in an error.\r\n *   - Implements retry logic in case of failure during the job processing.\r\n */\r\nexport async function processScrapingJob(jobId: string): Promise<void> {\r\n  try {\r\n    const job = await ScrapingJobService.updateJobStatus(jobId, 'running');\r\n    if (!job.target_url) {\r\n      throw new Error('No target URL specified');\r\n    }\r\n\r\n    const scrapeData = await handleScraping(job.target_url, jobId);\r\n    const extractedData = await handleGeminiExtraction(\r\n      scrapeData.markdown,\r\n      scrapeData.source_url ?? job.target_url,\r\n      jobId,\r\n    );\r\n\r\n    await ScrapingJobService.updateJobStatus(jobId, 'completed', {\r\n      data_collected: extractedData as unknown as Record<string, unknown>,\r\n      completed_at: new Date().toISOString(),\r\n    });\r\n\r\n    await createOrUpdateFoodTruck(jobId, extractedData, scrapeData.source_url ?? job.target_url);\r\n\r\n    console.info(`Scraping job ${jobId} completed successfully and data processed.`);\r\n  } catch {\r\n    await handleRetryLogic(jobId);\r\n  }\r\n}\r\n\r\n/**\r\n* Creates or updates a food truck entry based on extracted data and handles job processing.\r\n* @example\r\n* createOrUpdateFoodTruck('123abc', extractedTruckData, 'http://example.com')\r\n* undefined\r\n* @param {string} jobId - Unique identifier for the job being processed.\r\n* @param {ExtractedFoodTruckDetails} extractedTruckData - Object containing details about the food truck extracted from a source.\r\n* @param {string} sourceUrl - The URL from which the food truck data was extracted.\r\n* @returns {Promise<void>} Resolves when processing is complete; returns nothing explicitly.\r\n* @description\r\n*   - Validates the input data before proceeding with creation or update.\r\n*   - Applies a duplicate check mechanism to avoid redundant entries.\r\n*   - Finalizes the job status, ensuring proper completion or failure handling.\r\n*   - Logs error details for troubleshooting job processing issues.\r\n*/\r\nexport async function createOrUpdateFoodTruck(\r\n  jobId: string,\r\n  extractedTruckData: ExtractedFoodTruckDetails,\r\n  sourceUrl: string,\r\n) {\r\n  try {\r\n    const validation = await validateInputAndPrepare(jobId, extractedTruckData, sourceUrl);\r\n    if (!validation.isValid) {\r\n      return;\r\n    }\r\n\r\n    const truckData = buildTruckDataSchema(extractedTruckData, sourceUrl, validation.name);\r\n    const truck = await handleDuplicateCheck(jobId, truckData, validation.name);\r\n    await finalizeJobStatus(jobId, truck, sourceUrl);\r\n  } catch (error) {\r\n    const errorMessage = error instanceof Error ? error.message : 'Unknown error';\r\n    console.error(\r\n      `Job ${jobId}: Error in createOrUpdateFoodTruck from ${sourceUrl ?? 'Unknown Source'}:`,\r\n      error,\r\n    );\r\n    await handleJobFailure(jobId, `Food truck data processing/saving failed: ${errorMessage}`);\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\scheduler.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\security\\auditLogger.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\security\\rateLimiter.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":288,"column":11,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":288,"endColumn":28,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[7946,7963],"text":"result.retryAfter != null"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[7946,7963],"text":"result.retryAfter ?? 0"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[7946,7963],"text":"Boolean(result.retryAfter)"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * SOTA Rate Limiting Implementation\n * Prevents brute force attacks and API abuse with intelligent rate limiting\n */\n\nimport { NextResponse } from 'next/server'; // Added import for NextResponse\n\ninterface RateLimitEntry {\n  count: number;\n  resetTime: number;\n  blocked: boolean;\n  blockUntil?: number;\n}\n\n// In-memory rate limit store (in production, use Redis)\nconst rateLimitStore = new Map<string, RateLimitEntry>();\n\n// Rate limit configurations for different endpoints\nexport const RATE_LIMIT_CONFIGS = {\n  // Authentication endpoints - strict limits\n  auth: {\n    windowMs: 15 * 60 * 1000, // 15 minutes\n    maxRequests: 5, // 5 attempts per 15 minutes\n    blockDurationMs: 30 * 60 * 1000, // Block for 30 minutes\n    skipSuccessfulRequests: true,\n  },\n  // API endpoints - moderate limits\n  api: {\n    windowMs: 60 * 1000, // 1 minute\n    maxRequests: 60, // 60 requests per minute\n    blockDurationMs: 5 * 60 * 1000, // Block for 5 minutes\n    skipSuccessfulRequests: false,\n  },\n  // Admin endpoints - very strict limits\n  admin: {\n    windowMs: 60 * 1000, // 1 minute\n    maxRequests: 20, // 20 requests per minute\n    blockDurationMs: 15 * 60 * 1000, // Block for 15 minutes\n    skipSuccessfulRequests: false,\n  },\n} as const;\n\nexport type RateLimitType = keyof typeof RATE_LIMIT_CONFIGS;\n\n/**\n * Rate Limiter Service\n */\nexport class RateLimiter {\n  // Extract logic from checkRateLimit to reduce function size\n  private static isBlocked(entry: RateLimitEntry | undefined, now: number): boolean {\n    return Boolean(\n      entry && entry.blocked && entry.blockUntil != undefined && now < entry.blockUntil,\n    );\n  }\n\n  private static resetEntry(\n    entry: RateLimitEntry,\n    now: number,\n    config: (typeof RATE_LIMIT_CONFIGS)[RateLimitType],\n  ): void {\n    entry.count = 0;\n    entry.resetTime = now + config.windowMs;\n    entry.blocked = false;\n    entry.blockUntil = undefined;\n  }\n\n  /**\n   * Check if request should be rate limited\n   */\n  static checkRateLimit(\n    identifier: string,\n    type: RateLimitType = 'api',\n  ): {\n    allowed: boolean;\n    remaining: number;\n    resetTime: number;\n    retryAfter?: number;\n  } {\n    const config = RATE_LIMIT_CONFIGS[type];\n    const now = Date.now();\n    const key = `${type}:${identifier}`;\n    this.cleanupExpiredEntries();\n    let entry = rateLimitStore.get(key);\n    if (!entry) {\n      entry = { count: 0, resetTime: now + config.windowMs, blocked: false };\n      rateLimitStore.set(key, entry);\n    }\n    if (this.isBlocked(entry, now)) {\n      return {\n        allowed: false,\n        remaining: 0,\n        resetTime: entry.resetTime,\n        retryAfter: Math.ceil((entry.blockUntil! - now) / 1000),\n      };\n    }\n    if (now >= entry.resetTime) {\n      this.resetEntry(entry, now, config);\n    }\n    if (entry.count >= config.maxRequests) {\n      entry.blocked = true;\n      entry.blockUntil = now + config.blockDurationMs;\n      return {\n        allowed: false,\n        remaining: 0,\n        resetTime: entry.resetTime,\n        retryAfter: Math.ceil(config.blockDurationMs / 1000),\n      };\n    }\n    entry.count += 1;\n    rateLimitStore.set(key, entry);\n    return {\n      allowed: true,\n      remaining: config.maxRequests - entry.count,\n      resetTime: entry.resetTime,\n    };\n  }\n\n  /**\n   * Record successful request (for auth endpoints)\n   */\n  static recordSuccess(identifier: string, type: RateLimitType = 'api'): void {\n    const config = RATE_LIMIT_CONFIGS[type];\n    if (!config.skipSuccessfulRequests) return;\n\n    const key = `${type}:${identifier}`;\n    const entry = rateLimitStore.get(key);\n\n    if (entry) {\n      // Reset counter on successful auth\n      entry.count = 0;\n      entry.blocked = false;\n      entry.blockUntil = undefined;\n      rateLimitStore.set(key, entry);\n    }\n  }\n\n  /**\n   * Get rate limit status without incrementing\n   */\n  static getStatus(\n    identifier: string,\n    type: RateLimitType = 'api',\n  ): {\n    remaining: number;\n    resetTime: number;\n    blocked: boolean;\n    retryAfter?: number;\n  } {\n    const config = RATE_LIMIT_CONFIGS[type];\n    const now = Date.now();\n    const key = `${type}:${identifier}`;\n    const entry = rateLimitStore.get(key);\n\n    if (!entry) {\n      return {\n        remaining: config.maxRequests,\n        resetTime: now + config.windowMs,\n        blocked: false,\n      };\n    }\n\n    // Check if blocked\n    if (entry.blocked && entry.blockUntil != undefined && now < entry.blockUntil) {\n      // Changed != undefined to != null\n      return {\n        remaining: 0,\n        resetTime: entry.resetTime,\n        blocked: true,\n        retryAfter: Math.ceil((entry.blockUntil - now) / 1000),\n      };\n    }\n\n    // Check if window expired\n    if (now >= entry.resetTime) {\n      return {\n        remaining: config.maxRequests,\n        resetTime: now + config.windowMs,\n        blocked: false,\n      };\n    }\n\n    return {\n      remaining: Math.max(0, config.maxRequests - entry.count),\n      resetTime: entry.resetTime,\n      blocked: false,\n    };\n  }\n\n  /**\n   * Clean up expired entries to prevent memory leaks\n   */\n  private static cleanupExpiredEntries(): void {\n    const now = Date.now();\n\n    for (const [key, entry] of rateLimitStore.entries()) {\n      // Remove entries that are expired and not blocked\n      if (\n        now >= entry.resetTime &&\n        (!entry.blocked || entry.blockUntil == undefined || now >= entry.blockUntil)\n      ) {\n        // Changed == undefined to == null\n        rateLimitStore.delete(key);\n      }\n    }\n  }\n\n  /**\n   * Clear all rate limit data for an identifier\n   */\n  static clearLimits(identifier: string, type?: RateLimitType): void {\n    if (type) {\n      const key = `${type}:${identifier}`;\n      rateLimitStore.delete(key);\n    } else {\n      // Clear all types for this identifier\n      for (const limitType of Object.keys(RATE_LIMIT_CONFIGS) as RateLimitType[]) {\n        // Added type assertion\n        const key = `${limitType}:${identifier}`;\n        rateLimitStore.delete(key);\n      }\n    }\n  }\n\n  /**\n   * Get rate limit statistics\n   */\n  static getStats(): {\n    totalEntries: number;\n    blockedEntries: number;\n    entriesByType: Record<string, number>;\n  } {\n    const stats = {\n      totalEntries: rateLimitStore.size,\n      blockedEntries: 0,\n      entriesByType: {} as Record<string, number>,\n    };\n\n    for (const [key, entry] of rateLimitStore.entries()) {\n      const type = key.split(':')[0];\n      stats.entriesByType[type] = (stats.entriesByType[type] ?? 0) + 1;\n\n      if (entry.blocked) {\n        stats.blockedEntries += 1;\n      }\n    }\n\n    return stats;\n  }\n}\n\n/**\n * Utility function to get client identifier from request\n */\nexport function getClientIdentifier(request: Request): string {\n  // Try to get IP address from various headers\n  const forwarded = request.headers.get('x-forwarded-for');\n  const realIp = request.headers.get('x-real-ip');\n  const cfConnectingIp = request.headers.get('cf-connecting-ip');\n\n  // Use the first available IP\n  const ip = forwarded?.split(',')[0]?.trim() ?? realIp ?? cfConnectingIp ?? 'unknown';\n\n  // Include user agent for more specific identification\n  const userAgent = request.headers.get('user-agent') ?? 'unknown';\n\n  // Create a hash of IP + User Agent for better identification\n  return `${ip}:${userAgent.slice(0, 50)}`;\n}\n\n/**\n * Rate limiting middleware for API routes\n */\nexport function withRateLimit(\n  handler: (request: Request) => Promise<Response>,\n  type: RateLimitType = 'api',\n) {\n  return async (request: Request): Promise<Response> => {\n    const identifier = getClientIdentifier(request);\n    const result = RateLimiter.checkRateLimit(identifier, type);\n\n    if (result.allowed === false) {\n      const headers = new Headers({\n        'X-RateLimit-Limit': RATE_LIMIT_CONFIGS[type].maxRequests.toString(),\n        'X-RateLimit-Remaining': '0',\n        'X-RateLimit-Reset': new Date(result.resetTime).toISOString(),\n      });\n\n      if (result.retryAfter) {\n        headers.set('Retry-After', result.retryAfter.toString());\n      }\n\n      return new NextResponse('Too Many Requests', { status: 429, headers });\n    }\n\n    const response = await handler(request);\n\n    // Update headers on successful requests if not skipped\n    if (RATE_LIMIT_CONFIGS[type].skipSuccessfulRequests === false) {\n      const status = RateLimiter.getStatus(identifier, type);\n      response.headers.set('X-RateLimit-Limit', RATE_LIMIT_CONFIGS[type].maxRequests.toString());\n      response.headers.set('X-RateLimit-Remaining', status.remaining.toString());\n      response.headers.set('X-RateLimit-Reset', new Date(status.resetTime).toISOString());\n    }\n\n    return response;\n  };\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\supabase.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":12,"column":6,"nodeType":"Identifier","messageId":"conditionErrorNullableString","endLine":12,"endColumn":24,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[335,354],"text":"supabaseServiceKey == null"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[336,354],"text":"(supabaseServiceKey ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[335,354],"text":"!Boolean(supabaseServiceKey)"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":107,"column":12,"nodeType":"MemberExpression","messageId":"conditionErrorObject","endLine":107,"endColumn":43},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":165,"column":12,"nodeType":"Identifier","messageId":"conditionErrorObject","endLine":165,"endColumn":16},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":768,"column":7,"nodeType":"MemberExpression","messageId":"conditionErrorObject","endLine":768,"endColumn":29},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":776,"column":7,"nodeType":"MemberExpression","messageId":"conditionErrorObject","endLine":776,"endColumn":25}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {\n  createClient,\n  type PostgrestSingleResponse,\n  type PostgrestResponse,\n  type PostgrestError,\n} from '@supabase/supabase-js';\n\nconst supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;\nconst supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY;\nconst supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY;\n\nif (!supabaseServiceKey) {\n  throw new Error('Missing NEXT_PUBLIC_SUPABASE_URL environment variable');\n}\n\nif (supabaseAnonKey === undefined || supabaseAnonKey === '') {\n  throw new Error('Missing NEXT_PUBLIC_SUPABASE_ANON_KEY environment variable');\n}\n\nexport const supabase = createClient(supabaseUrl, supabaseAnonKey);\n\n// Only create admin client on server side where service key is available\nexport const supabaseAdmin = supabaseServiceKey\n  ? createClient(supabaseUrl, supabaseServiceKey)\n  : undefined;\n\n// Database types\nimport { MenuCategory, MenuItem } from './types';\n\nexport interface FoodTruckLocation {\n  lat: number;\n  lng: number;\n  address?: string;\n  timestamp: string;\n}\n\n// Re-exporting from types.ts to ensure consistency\n\nimport { FoodTruckSchema } from './types';\n\nexport interface FoodTruck extends FoodTruckSchema {\n  id: string;\n  created_at: string;\n  updated_at: string;\n  is_active?: boolean; // This property is in lib/types.ts but not in lib/supabase.ts\n  // Add any other properties that are in the database but not in FoodTruckSchema\n  // For example, if the database has 'exact_location' or 'city_location'\n  exact_location?: FoodTruckLocation;\n  city_location?: FoodTruckLocation;\n}\n\nexport interface ScrapingJob {\n  id: string;\n  job_type: string;\n  target_url?: string;\n  target_handle?: string;\n  platform?: string;\n  status: 'pending' | 'running' | 'completed' | 'failed';\n  priority: number;\n  scheduled_at: string;\n  started_at?: string;\n  completed_at?: string;\n  data_collected?: Record<string, unknown>;\n  errors?: string[];\n  retry_count: number;\n  max_retries: number;\n  created_at: string;\n}\n\nexport interface DataProcessingQueue {\n  id: string;\n  truck_id?: string;\n  processing_type: string;\n  raw_data: Record<string, unknown>;\n  processed_data?: Record<string, unknown>;\n  gemini_tokens_used: number;\n  status: 'pending' | 'processing' | 'completed' | 'failed';\n  priority: number;\n  created_at: string;\n  processed_at?: string;\n}\n\nexport interface ApiUsage {\n  id: string;\n  service_name: string;\n  usage_date: string;\n  requests_count: number;\n  tokens_used: number;\n}\n\n// Food truck operations\n/**\n* Groups menu items by their associated food truck ID.\n* @example\n* buildMenuByTruck([{ food_truck_id: '1', name: 'Burger' }, { food_truck_id: '2', name: 'Pizza' }])\n* { '1': [{ food_truck_id: '1', name: 'Burger' }], '2': [{ food_truck_id: '2', name: 'Pizza' }] }\n* @param {RawMenuItemFromDB[]} menuItems - Array of menu items where each item must have a food truck ID.\n* @returns {Record<string, RawMenuItemFromDB[]>} A record with keys of food truck IDs and values of arrays of menu items.\n* @description\n*   - Ensures only menu items with valid, non-empty food truck IDs are included.\n*   - Initializes an array for each unique food truck ID, grouping corresponding menu items.\n*/\nfunction buildMenuByTruck(menuItems: RawMenuItemFromDB[]): Record<string, RawMenuItemFromDB[]> {\n  const menuByTruck: Record<string, RawMenuItemFromDB[]> = {};\n  for (const item of menuItems) {\n    if (typeof item.food_truck_id === 'string' && item.food_truck_id.trim() !== '') {\n      if (!menuByTruck[item.food_truck_id]) {\n        menuByTruck[item.food_truck_id] = [];\n      }\n      menuByTruck[item.food_truck_id].push(item);\n    }\n  }\n  return menuByTruck;\n}\n\nfunction handleSupabaseError(error: unknown, context: string) {\n  // Log technical details for developers\n  console.warn(`Error in ${context}:`, error);\n}\n\nexport const FoodTruckService = {\n  async getAllTrucks(\n    limit = 50,\n    offset = 0,\n  ): Promise<{ trucks: FoodTruck[]; total: number; error?: string }> {\n    try {\n      const { data, error, count }: PostgrestResponse<FoodTruck> = await supabase\n        .from('food_trucks')\n        .select('*', { count: 'exact' })\n        .order('updated_at', { ascending: false })\n        .range(offset, offset + limit - 1);\n      if (error) throw error;\n      const trucks: FoodTruck[] = (data ?? []).map((t: FoodTruck) => normalizeTruckLocation(t));\n      if (trucks.length === 0) return { trucks: [], total: count ?? 0 };\n      const truckIds = trucks.map((t: FoodTruck) => t.id);\n      let menuItems: RawMenuItemFromDB[] = [];\n      try {\n        if (truckIds.length > 0) {\n          const { data: items, error: menuError }: PostgrestResponse<RawMenuItemFromDB> =\n            await supabase.from('menu_items').select('*').in('food_truck_id', truckIds);\n          if (menuError) throw new Error(menuError.message);\n          menuItems = Array.isArray(items) ? items : [];\n        }\n      } catch (menuError) {\n        handleSupabaseError(menuError, 'getAllTrucks:menu_items');\n      }\n      const menuByTruck = buildMenuByTruck(menuItems);\n      for (const truck of trucks) {\n        truck.menu = groupMenuItems(menuByTruck[truck.id] ?? []);\n      }\n      return { trucks, total: count ?? 0 };\n    } catch (error) {\n      handleSupabaseError(error, 'getAllTrucks');\n      return { trucks: [], total: 0, error: \"That didn't work, please try again later.\" };\n    }\n  },\n  async getTruckById(id: string): Promise<FoodTruck | { error: string }> {\n    try {\n      const { data, error }: PostgrestSingleResponse<FoodTruck> = await supabase\n        .from('food_trucks')\n        .select('*')\n        .eq('id', id)\n        .single();\n      if (error) throw error;\n      if (!data) {\n        return { error: \"That didn't work, please try again later.\" };\n      }\n      const truck: FoodTruck = normalizeTruckLocation(data);\n      const { data: items, error: menuError }: PostgrestResponse<RawMenuItemFromDB> = await supabase\n        .from('menu_items')\n        .select('*')\n        .eq('food_truck_id', id);\n      if (menuError) throw menuError;\n      truck.menu = groupMenuItems(Array.isArray(items) ? items : []);\n      return truck;\n    } catch (error) {\n      handleSupabaseError(error, 'getTruckById');\n      return { error: \"That didn't work, please try again later.\" };\n    }\n  },\n\n  async getTrucksByLocation(\n    lat: number,\n    lng: number,\n    radiusKm: number,\n  ): Promise<FoodTruck[] | { error: string }> {\n    try {\n      const { trucks } = await FoodTruckService.getAllTrucks();\n      const nearbyTrucks = trucks.filter((truck: FoodTruck) => {\n        if (\n          truck.current_location == undefined ||\n          typeof truck.current_location.lat !== 'number' ||\n          typeof truck.current_location.lng !== 'number'\n        ) {\n          return false;\n        }\n        const distance = calculateDistance(\n          lat,\n          lng,\n          truck.current_location.lat,\n          truck.current_location.lng,\n        );\n        return distance <= radiusKm;\n      });\n      return nearbyTrucks;\n    } catch (error: unknown) {\n      handleSupabaseError(error, 'getTrucksByLocation');\n      return { error: \"That didn't work, please try again later.\" };\n    }\n  },\n  async createTruck(truckData: Partial<FoodTruck>): Promise<FoodTruck | { error: string }> {\n    if (!supabaseAdmin) {\n      return { error: 'Admin operations require SUPABASE_SERVICE_ROLE_KEY' };\n    }\n    const menuData = truckData.menu;\n    const truckDataWithoutMenu = { ...truckData };\n    delete truckDataWithoutMenu.menu;\n    const { data: truck, error }: PostgrestSingleResponse<FoodTruck> = await supabaseAdmin\n      .from('food_trucks')\n      .insert([truckDataWithoutMenu])\n      .select()\n      .single();\n    if (error) {\n      handleSupabaseError(error, 'createTruck');\n      return { error: 'Failed to create truck.' };\n    }\n    await insertMenuItems(truck.id, menuData);\n    return truck;\n  },\n\n  async updateTruck(\n    id: string,\n    updates: Partial<FoodTruck>,\n  ): Promise<FoodTruck | { error: string }> {\n    if (!supabaseAdmin) {\n      return { error: 'Admin operations require SUPABASE_SERVICE_ROLE_KEY' };\n    }\n    const menuData = updates.menu;\n    const updatesWithoutMenu = { ...updates };\n    delete updatesWithoutMenu.menu;\n    const truckResult = await updateTruckData(id, updatesWithoutMenu);\n    if ('error' in truckResult) {\n      return truckResult;\n    }\n    if (menuData != undefined) {\n      await updateTruckMenu(id, menuData);\n    }\n    return truckResult;\n  },\n\n  async getDataQualityStats(): Promise<{\n    total_trucks: number;\n    avg_quality_score: number;\n    high_quality_count: number;\n    medium_quality_count: number;\n    low_quality_count: number;\n    verified_count: number;\n    pending_count: number;\n    flagged_count: number;\n  }> {\n    try {\n      const {\n        data,\n        error,\n      }: PostgrestSingleResponse<{\n        total_trucks: number;\n        avg_quality_score: number;\n        high_quality_count: number;\n        medium_quality_count: number;\n        low_quality_count: number;\n        verified_count: number;\n        pending_count: number;\n        flagged_count: number;\n      }> = await supabase.rpc('get_data_quality_stats').single();\n      if (error) throw error;\n      return data as {\n        total_trucks: number;\n        avg_quality_score: number;\n        high_quality_count: number;\n        medium_quality_count: number;\n        low_quality_count: number;\n        verified_count: number;\n        pending_count: number;\n        flagged_count: number;\n      };\n    } catch (error: unknown) {\n      console.warn('Error fetching data quality stats:', error);\n      return {\n        total_trucks: 0,\n        avg_quality_score: 0,\n        high_quality_count: 0,\n        medium_quality_count: 0,\n        low_quality_count: 0,\n        verified_count: 0,\n        pending_count: 0,\n        flagged_count: 0,\n      };\n    }\n  },\n};\n\n// Helper functions to reduce cognitive complexity\nconst isMenuCategory = (obj: unknown): obj is MenuCategory =>\n  typeof obj === 'object' &&\n  obj != undefined &&\n  'name' in obj &&\n  'items' in obj &&\n  Array.isArray(obj.items);\n\n/**\n * Determines whether the given object is a MenuItem.\n * @example\n * isMenuItem({ name: \"Pizza\", description: \"Delicious\", price: 9.99, dietary_tags: [\"Vegetarian\"] })\n * true\n * @param {unknown} obj - The object to be checked.\n * @returns {boolean} Returns true if the object has properties consistent with a MenuItem.\n * @description\n *   - Checks if 'name' is a string.\n *   - Checks if 'description' is either undefined or a string.\n *   - Checks if 'price' is either undefined or a number.\n *   - Ensures 'dietary_tags' is either undefined or an array of strings.\n */\nconst isMenuItem = (obj: unknown): obj is MenuItem => {\n  if (typeof obj !== 'object' || obj == undefined) return false;\n  const item = obj as Record<string, unknown>;\n  return (\n    typeof item.name === 'string' &&\n    (item.description === undefined || typeof item.description === 'string') &&\n    (item.price === undefined || typeof item.price === 'number') &&\n    (item.dietary_tags === undefined ||\n      (Array.isArray(item.dietary_tags) &&\n        item.dietary_tags.every((tag) => typeof tag === 'string')))\n  );\n};\n\n/**\n* Updates the food truck data for a given truck ID with provided updates.\n* @example\n* updateTruckData('truck123', { name: 'New Truck Name', location: 'Downtown' })\n* { id: 'truck123', name: 'New Truck Name', location: 'Downtown', ... }\n* @param {string} id - The ID of the food truck to be updated.\n* @param {Partial<FoodTruck>} updatesWithoutMenu - Partial object containing truck attributes to be updated, excluding menu items.\n* @returns {Promise<FoodTruck | { error: string }>} Returns the updated FoodTruck object or an error message upon failure.\n* @description\n*   - Requires SUPABASE_SERVICE_ROLE_KEY to perform operations.\n*   - Updates only non-menu details of the food truck.\n*   - Selects and returns the single updated record from the database.\n*   - Handles errors by invoking handleSupabaseError and returns an error message if any issues occur during update.\n*/\nasync function updateTruckData(\n  id: string,\n  updatesWithoutMenu: Partial<FoodTruck>,\n): Promise<FoodTruck | { error: string }> {\n  if (!supabaseAdmin) {\n    return { error: 'Admin operations require SUPABASE_SERVICE_ROLE_KEY' };\n  }\n\n  const { data: truck, error }: PostgrestSingleResponse<FoodTruck> = await supabaseAdmin\n    .from('food_trucks')\n    .update(updatesWithoutMenu)\n    .eq('id', id)\n    .select()\n    .single();\n\n  if (error) {\n    handleSupabaseError(error, 'updateTruckData');\n    return { error: 'Failed to update truck data.' };\n  }\n  return truck;\n}\n\n/**\n * Updates the menu items for a specific food truck in the Supabase database.\n * @example\n * updateTruckMenu('truck123', menuData)\n * Promise<void> // Updates the menu items and resolves a promise.\n * @param {string} id - Identifier for the food truck whose menu is being updated.\n * @param {MenuCategory[] | unknown[]} menuData - Array containing menu category objects or unknown objects.\n * @returns {Promise<void>} Resolves a promise when the operation is complete.\n * @description\n *   - Requires `SUPABASE_SERVICE_ROLE_KEY` to perform admin operations.\n *   - Deletes existing menu items before inserting updated ones.\n *   - Handles invalid categories or menu items by skipping them and logs warnings.\n */\nasync function updateTruckMenu(id: string, menuData: MenuCategory[] | unknown[]): Promise<void> {\n  if (!supabaseAdmin) {\n    throw new Error('Admin operations require SUPABASE_SERVICE_ROLE_KEY');\n  }\n\n  // Delete existing menu items\n  const { error: deleteError } = await supabaseAdmin\n    .from('menu_items')\n    .delete()\n    .eq('food_truck_id', id);\n\n  if (deleteError) {\n    console.error('Error deleting existing menu items for truck', id, deleteError);\n  }\n\n  // Insert new menu items if they exist\n  if (menuData != undefined && menuData.length > 0) {\n    const menuItems = menuData.flatMap((category: unknown) => {\n      if (!isMenuCategory(category)) {\n        console.warn('Skipping invalid category in updateTruckMenu:', category);\n        return [];\n      }\n\n      return (category.items ?? []).map((item: unknown) => {\n        if (!isMenuItem(item)) {\n          console.warn('Skipping invalid menu item in updateTruckMenu:', item);\n          // Return a default valid MenuItem or skip based on requirements\n          return {\n            food_truck_id: id,\n            category: category.name ?? 'Uncategorized',\n            name: 'Unknown Item',\n            description: undefined,\n            price: undefined,\n            dietary_tags: [],\n          };\n        }\n\n        return {\n          food_truck_id: id,\n          category: category.name ?? 'Uncategorized',\n          name: item.name ?? 'Unknown Item',\n          description: item.description ?? undefined,\n          price: typeof item.price === 'number' ? item.price : undefined,\n          dietary_tags: Array.isArray(item.dietary_tags) ? item.dietary_tags : [],\n        };\n      });\n    });\n\n    if (menuItems.length > 0) {\n      const { error: menuError } = await supabaseAdmin.from('menu_items').insert(menuItems);\n\n      if (menuError) {\n        console.error('Error inserting updated menu items for truck', id, menuError);\n      }\n    }\n  }\n}\n\n/**\n* Computes the distance between two geographical points using the Haversine formula.\n* @example\n* calculateDistance(51.5074, -0.1278, 40.7128, -74.0060)\n* 5585.107071089907\n* @param {number} lat1 - Latitude of the first point in decimal degrees.\n* @param {number} lon1 - Longitude of the first point in decimal degrees.\n* @param {number} lat2 - Latitude of the second point in decimal degrees.\n* @param {number} lon2 - Longitude of the second point in decimal degrees.\n* @returns {number} The distance between the two points in kilometers.\n* @description\n*   - Uses Haversine formula to account for Earth's curvature.\n*   - Assumes Earth’s radius is 6371 kilometers.\n*   - Angles should be provided in decimal degrees, not radians.\n*/\nfunction calculateDistance(lat1: number, lon1: number, lat2: number, lon2: number): number {\n  const R = 6371;\n  const dLat = ((lat2 - lat1) * Math.PI) / 180;\n  const dLon = ((lon2 - lon1) * Math.PI) / 180;\n  const a =\n    Math.sin(dLat / 2) * Math.sin(dLat / 2) +\n    Math.cos((lat1 * Math.PI) / 180) *\n      Math.cos((lat2 * Math.PI) / 180) *\n      Math.sin(dLon / 2) *\n      Math.sin(dLon / 2);\n  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n  const distance = R * c;\n  return distance;\n}\n\n// Define a helper type for items coming from the DB, which might include a category field\ninterface RawMenuItemFromDB {\n  name: string;\n  description?: string;\n  price?: number;\n  dietary_tags?: string[];\n  category?: string; // This field is expected from the DB query\n  // Potentially other fields like id, food_truck_id, etc.\n  [key: string]: unknown; // Allow other properties from DB select *\n}\n\n/**\n * Groups raw menu items into categories based on their category property.\n * @example\n * groupMenuItems([{name: 'Salad', category: 'Appetizers'}, {name: 'Burger'}])\n * // Returns: [{name: 'Appetizers', items: [{name: 'Salad', description: undefined, price: undefined, dietary_tags: []}]}, \n * //           {name: 'Uncategorized', items: [{name: 'Burger', description: undefined, price: undefined, dietary_tags: []}]}]\n * @param {RawMenuItemFromDB[]} rawItems - Array of raw menu items from the database.\n * @returns {MenuCategory[]} A list of menu categories with categorized menu items.\n * @description\n *   - Wraps raw menu items into a structured format separating them by categories.\n *   - Uses the nullish coalescing operator to handle null and undefined values from the database.\n *   - Explicitly casts dietary tags to an array of strings.\n */\nfunction groupMenuItems(rawItems: RawMenuItemFromDB[]): MenuCategory[] {\n  const byCategory: Record<string, MenuItem[]> = {}; // Stores processed MenuItems\n  for (const rawItem of rawItems) {\n    const categoryName: string = rawItem.category ?? 'Uncategorized';\n    byCategory[categoryName] ??= [];\n    // Construct a MenuItem conforming to the MenuItem interface (no 'category' property)\n    const menuItem: MenuItem = {\n      name: rawItem.name,\n      // Use nullish coalescing to convert null from DB to undefined for the MenuItem type\n      description: rawItem.description ?? undefined,\n      price: rawItem.price ?? undefined,\n      dietary_tags: (rawItem.dietary_tags as string[]) ?? [], // Explicitly cast to string[]\n    };\n    byCategory[categoryName].push(menuItem);\n  }\n  // Map to MenuCategory structure { name: string, items: MenuItem[] }\n  return Object.entries(byCategory).map(([categoryName, itemsList]: [string, MenuItem[]]) => ({\n    name: categoryName,\n    items: itemsList,\n  }));\n}\n\n// Remove redundant type constituent in normalizeTruckLocation\n/**\n * Normalizes the location of a food truck by selecting the most accurate available location data.\n * @example\n * normalizeTruckLocation(truckInstance)\n * returns truckInstance with updated current_location property\n * @param {FoodTruck} truck - A food truck object whose location needs normalization.\n * @returns {FoodTruck} A food truck object with a standardized current location.\n * @description\n *   - If no valid latitude or longitude is found, it defaults to the fallback location.\n *   - The function prioritizes exact_location over current_location and city_location.\n *   - Ensures that the address is populated even if only latitude and longitude are available.\n *   - Uses the current timestamp when none is provided in the location data.\n */\nfunction normalizeTruckLocation(truck: FoodTruck): FoodTruck {\n  const fallback: FoodTruckLocation = {\n    lat: 0,\n    lng: 0,\n    address: 'Unknown',\n    timestamp: new Date().toISOString(),\n  };\n  const loc = truck.exact_location ?? truck.current_location ?? truck.city_location ?? {};\n  const lat = typeof loc.lat === 'number' ? loc.lat : 0;\n  const lng = typeof loc.lng === 'number' ? loc.lng : 0;\n  const {address} = loc;\n  const {timestamp} = loc;\n\n  truck.current_location =\n    lat === 0 || lng === 0\n      ? { ...fallback, address: address ?? fallback.address }\n      : {\n          lat,\n          lng,\n          address: address ?? fallback.address,\n          timestamp: timestamp ?? fallback.timestamp,\n        };\n  return truck;\n}\n\nexport const ScrapingJobService = {\n  async createJob(jobData: Partial<ScrapingJob>): Promise<ScrapingJob> {\n    if (!supabaseAdmin) {\n      throw new Error('Admin operations require SUPABASE_SERVICE_ROLE_KEY');\n    }\n\n    const { data, error }: PostgrestSingleResponse<ScrapingJob> = await supabaseAdmin\n      .from('scraping_jobs')\n      .insert([\n        {\n          ...jobData,\n          status: 'pending',\n          retry_count: 0,\n          max_retries: 3,\n          created_at: new Date().toISOString(),\n        },\n      ])\n      .select()\n      .single();\n\n    if (error) throw error;\n    return data;\n  },\n\n  async getJobsByStatus(status: string): Promise<ScrapingJob[]> {\n    try {\n      const query = supabase.from('scraping_jobs').select('*');\n\n      const { data, error }: PostgrestResponse<ScrapingJob> = await (\n        status === 'all' ? query : query.eq('status', status)\n      )\n        .order('priority', { ascending: false })\n        .order('scheduled_at', { ascending: true });\n\n      if (error) throw error;\n      return data ?? [];\n    } catch (error: unknown) {\n      console.warn('Error fetching jobs:', error);\n      return [];\n    }\n  },\n  async updateJobStatus(\n    id: string,\n    status: string,\n    updates: Partial<ScrapingJob> = {},\n  ): Promise<ScrapingJob> {\n    if (!supabaseAdmin) {\n      throw new Error('Admin operations require SUPABASE_SERVICE_ROLE_KEY');\n    }\n\n    const { data, error }: PostgrestSingleResponse<ScrapingJob> = await supabaseAdmin\n      .from('scraping_jobs')\n      .update({\n        status,\n        ...updates,\n        ...(status === 'running' && { started_at: new Date().toISOString() }),\n        ...(status === 'completed' && { completed_at: new Date().toISOString() }),\n      })\n      .eq('id', id)\n      .select()\n      .single();\n    if (error) throw error;\n    return data;\n  },\n  async incrementRetryCount(id: string): Promise<ScrapingJob> {\n    if (!supabaseAdmin) {\n      throw new Error('Admin operations require SUPABASE_SERVICE_ROLE_KEY');\n    }\n\n    const {\n      data: current,\n      error: fetchError,\n    }: PostgrestSingleResponse<Pick<ScrapingJob, 'retry_count'>> = await supabaseAdmin\n      .from('scraping_jobs')\n      .select('retry_count')\n      .eq('id', id)\n      .single();\n\n    if (fetchError) throw fetchError;\n\n    const { data, error }: PostgrestSingleResponse<ScrapingJob> = await supabaseAdmin\n      .from('scraping_jobs')\n      .update({ retry_count: (current?.retry_count ?? 0) + 1 })\n      .eq('id', id)\n      .select()\n      .single();\n\n    if (error) throw error;\n    return data;\n  },\n  async getAllJobs(limit = 50, offset = 0): Promise<ScrapingJob[]> {\n    try {\n      const { data, error }: PostgrestResponse<ScrapingJob> = await supabase\n        .from('scraping_jobs')\n        .select('*')\n        .order('priority', { ascending: false })\n        .order('scheduled_at', { ascending: true })\n        .range(offset, offset + limit - 1);\n\n      if (error) throw error;\n      return data ?? [];\n    } catch (error: unknown) {\n      console.warn('Error fetching jobs:', error);\n      return [];\n    }\n  },\n\n  async getJobsFromDate(date: Date): Promise<ScrapingJob[]> {\n    try {\n      const { data, error }: PostgrestResponse<ScrapingJob> = await supabase\n        .from('scraping_jobs')\n        .select('*')\n        .gte('created_at', date.toISOString())\n        .order('created_at', { ascending: false });\n\n      if (error) throw error;\n      return data ?? [];\n    } catch (error: unknown) {\n      console.warn('Error fetching jobs from date:', error);\n      return [];\n    }\n  },\n};\n\nexport const DataProcessingService = {\n  async addToQueue(queueData: Partial<DataProcessingQueue>): Promise<DataProcessingQueue> {\n    if (!supabaseAdmin) {\n      throw new Error('Admin operations require SUPABASE_SERVICE_ROLE_KEY');\n    }\n\n    const { data, error }: PostgrestSingleResponse<DataProcessingQueue> = await supabaseAdmin\n      .from('data_processing_queue')\n      .insert([\n        {\n          ...queueData,\n          status: 'pending',\n          gemini_tokens_used: 0,\n          created_at: new Date().toISOString(),\n        },\n      ])\n      .select()\n      .single();\n\n    if (error) throw error;\n    return data;\n  },\n\n  async getNextQueueItem(): Promise<DataProcessingQueue | undefined> {\n    if (!supabaseAdmin) {\n      throw new Error('Admin operations require SUPABASE_SERVICE_ROLE_KEY');\n    }\n\n    const { data, error }: PostgrestSingleResponse<DataProcessingQueue> = await supabaseAdmin\n      .from('data_processing_queue')\n      .select('*')\n      .eq('status', 'pending')\n      .order('priority', { ascending: false })\n      .order('created_at', { ascending: true })\n      .limit(1)\n      .single();\n\n    if (error !== null && String(error.code) != 'PGRST116') throw error;\n    return data ?? undefined;\n  },\n\n  async getQueueByStatus(status: string): Promise<DataProcessingQueue[]> {\n    try {\n      const { data, error }: PostgrestResponse<DataProcessingQueue> = await supabase\n        .from('data_processing_queue')\n        .select('*')\n        .eq('status', status)\n        .order('created_at', { ascending: false });\n\n      if (error) throw error;\n      return data ?? [];\n    } catch (error: unknown) {\n      console.warn('Error fetching queue:', error);\n      return [];\n    }\n  },\n  async updateQueueItem(\n    id: string,\n    updates: Partial<DataProcessingQueue>,\n  ): Promise<DataProcessingQueue> {\n    if (!supabaseAdmin) {\n      throw new Error('Admin operations require SUPABASE_SERVICE_ROLE_KEY');\n    }\n\n    const { data, error }: PostgrestSingleResponse<DataProcessingQueue> = await supabaseAdmin\n      .from('data_processing_queue')\n      .update({\n        ...updates,\n        ...(updates.status === 'completed' && { processed_at: new Date().toISOString() }),\n      })\n      .eq('id', id)\n      .select()\n      .single();\n\n    if (error) throw error;\n    return data;\n  },\n};\n\nexport const DataQualityService = {\n  calculateQualityScore: (truck: FoodTruck) => {\n    // Placeholder for actual quality score calculation logic\n    // This should be implemented based on defined data quality rules\n    let score = 0;\n    if (typeof truck.name === 'string' && truck.name.trim() !== '') score += 20;\n    if (\n      truck.current_location &&\n      typeof truck.current_location.lat === 'number' &&\n      !Number.isNaN(truck.current_location.lat) &&\n      typeof truck.current_location.lng === 'number' &&\n      !Number.isNaN(truck.current_location.lng)\n    )\n      score += 30;\n    if (\n      truck.contact_info &&\n      ((typeof truck.contact_info.phone === 'string' && truck.contact_info.phone.trim() !== '') ||\n        (typeof truck.contact_info.email === 'string' && truck.contact_info.email.trim() !== '') ||\n        (typeof truck.contact_info.website === 'string' &&\n          truck.contact_info.website.trim() !== ''))\n    )\n      score += 25;\n    if (Array.isArray(truck.menu) && truck.menu.length > 0) score += 15;\n    if (truck.operating_hours != undefined) score += 10;\n    return { score: Math.min(100, score) };\n  },\n\n  async updateTruckQualityScore(truckId: string): Promise<FoodTruck | { error: string }> {\n    if (!supabaseAdmin) {\n      return { error: 'Admin operations require SUPABASE_SERVICE_ROLE_KEY' };\n    }\n    const { data: truck, error: fetchError } = (await supabaseAdmin\n      .from('food_trucks')\n      .select('*')\n      .eq('id', truckId)\n      .single()) as { data: FoodTruck | undefined; error: PostgrestError | undefined };\n\n    if (fetchError) {\n      handleSupabaseError(fetchError, 'updateTruckQualityScore:fetch');\n      return { error: `Failed to fetch truck with ID ${truckId}.` };\n    }\n    if (!truck) {\n      return { error: `Truck with ID ${truckId} not found.` };\n    }\n\n    const { score } = this.calculateQualityScore(truck);\n\n    const { data, error }: PostgrestSingleResponse<FoodTruck> = await supabaseAdmin\n      .from('food_trucks')\n      .update({ data_quality_score: score })\n      .eq('id', truckId)\n      .select()\n      .single();\n\n    if (error) {\n      handleSupabaseError(error, 'updateTruckQualityScore:update');\n      return { error: `Failed to update quality score for truck with ID ${truckId}.` };\n    }\n    return data;\n  },\n};\n\nexport const APIUsageService = {\n  async trackUsage(serviceName: string, requests: number, tokens: number): Promise<ApiUsage> {\n    if (!supabaseAdmin) {\n      throw new Error('Admin operations require SUPABASE_SERVICE_ROLE_KEY');\n    }\n\n    try {\n      const today = new Date().toISOString().split('T')[0];\n\n      const {\n        data: existing,\n        error: existingError,\n      }: { data: ApiUsage | undefined; error: PostgrestError | undefined } = await supabaseAdmin\n        .from('api_usage')\n        .select('*')\n        .eq('service_name', serviceName)\n        .eq('usage_date', today)\n        .single();\n\n      if (existingError && existingError.code !== 'PGRST116') throw existingError;\n\n      if (existing) {\n        const { data, error }: PostgrestSingleResponse<ApiUsage> = await supabaseAdmin\n          .from('api_usage')\n          .update({\n            requests_count: (existing.requests_count ?? 0) + requests,\n            tokens_used: (existing.tokens_used ?? 0) + tokens,\n          })\n          .eq('id', existing.id)\n          .select()\n          .single();\n\n        if (error) throw error;\n        return data;\n      } \n        const { data, error }: PostgrestSingleResponse<ApiUsage> = await supabaseAdmin\n          .from('api_usage')\n          .insert([\n            {\n              service_name: serviceName,\n              usage_date: today,\n              requests_count: requests,\n              tokens_used: tokens,\n            },\n          ])\n          .select()\n          .single();\n\n        if (error) throw error;\n        return data;\n      \n    } catch (error: unknown) {\n      console.warn('Error tracking usage:', error);\n      throw error;\n    }\n  },\n  async getTodayUsage(serviceName: string): Promise<ApiUsage | undefined> {\n    try {\n      const today = new Date().toISOString().split('T')[0];\n\n      const { data, error }: PostgrestSingleResponse<ApiUsage> = await supabase\n        .from('api_usage')\n        .select('*')\n        .eq('service_name', serviceName)\n        .eq('usage_date', today)\n        .single();\n\n      if (error !== null && String(error.code) != 'PGRST116') throw error;\n      return data ?? undefined;\n    } catch (error: unknown) {\n      console.warn('Error getting today usage:', error);\n      throw error;\n    }\n  },\n\n  async getAllUsageStats(): Promise<ApiUsage[]> {\n    try {\n      const { data, error }: PostgrestResponse<ApiUsage> = await supabase\n        .from('api_usage')\n        .select('*')\n        .order('usage_date', { ascending: false })\n        .limit(30);\n\n      if (error) throw error;\n      return data ?? [];\n    } catch (error: unknown) {\n      console.warn('Error getting usage stats:', error);\n      throw error;\n    }\n  },\n};\n\nexport { type MenuItem, type MenuCategory, type OperatingHours, type PriceRange } from './types';\n\n// Helper to prepare menu items for DB insertion\n/**\n * Prepares a list of menu items for insertion by filtering and transforming the input data.\n * @example\n * prepareMenuItemsForInsert(\"truck123\", [{ name: \"Beverages\", items: [{name: \"Tea\", price: 3.00}]}])\n * [\n *   {\n *     food_truck_id: \"truck123\",\n *     category: \"Beverages\",\n *     name: \"Tea\",\n *     description: undefined,\n *     price: 3.00,\n *     dietary_tags: []\n *   }\n * ]\n * @param {string} truckId - Unique identifier of the food truck.\n * @param {MenuCategory[] | unknown[] | undefined} menuData - Array of menu categories or unknown data, which may contain items to insert.\n * @returns {MenuItem[]} Returns an array of valid menu items formatted for database insertion, excluding invalid entries.\n * @description\n *   - Filters input data to ensure items are of MenuCategory type.\n *   - Logs warnings for invalid menu items and skips them.\n *   - Uses default values for missing item properties such as `category`, `name`, or `price`.\n */\nfunction prepareMenuItemsForInsert(\n  truckId: string,\n  menuData: MenuCategory[] | unknown[] | undefined,\n) {\n  if (!Array.isArray(menuData) || menuData.length === 0) return [];\n  // Explicitly filter for MenuCategory to ensure type safety\n  const categories = menuData.filter(\n    (category): category is MenuCategory =>\n      typeof category === 'object' &&\n      category != undefined &&\n      'name' in category &&\n      'items' in category &&\n      Array.isArray(category.items),\n  ) as MenuCategory[];\n\n  return categories.flatMap(\n    (category) =>\n      (Array.isArray(category.items) ? category.items : [])\n        .map((item: unknown) => {\n          if (!isMenuItem(item)) {\n            console.warn('Skipping invalid menu item:', item);\n            return; // Return undefined for invalid items to be filtered out later\n          }\n\n          return {\n            food_truck_id: truckId,\n            category:\n              typeof category.name === 'string' && category.name !== ''\n                ? category.name\n                : 'Uncategorized',\n            name: typeof item.name === 'string' && item.name !== '' ? item.name : 'Unknown Item',\n            description:\n              typeof item.description === 'string' && item.description !== ''\n                ? item.description\n                : undefined,\n            price:\n              typeof item.price === 'number' && !Number.isNaN(item.price) ? item.price : undefined,\n            dietary_tags: Array.isArray(item.dietary_tags) ? item.dietary_tags : [],\n          };\n        })\n        .filter(Boolean) as MenuItem[], // Filter out nulls and assert type\n  );\n}\n\nasync function insertMenuItems(truckId: string, menuData: MenuCategory[] | unknown[] | undefined) {\n  const menuItems = prepareMenuItemsForInsert(truckId, menuData);\n  if (menuItems.length === 0) return;\n  const { error: menuError } = await supabaseAdmin!.from('menu_items').insert(menuItems);\n  if (menuError) {\n    console.error('Error inserting menu items for truck', truckId, menuError);\n  }\n}\n\n// Fix all strict-boolean-expressions and always-true/false comparisons below\n// Example: if (someString) => if (typeof someString === 'string' && someString.trim() !== '')\n// Example: if (someNumber) => if (typeof someNumber === 'number' && !Number.isNaN(someNumber) && someNumber !== 0)\n// Example: if (someObject) => if (someObject != null && someObject != undefined)\n\n// For all other conditionals, ensure explicit nullish/empty/NaN checks as above\n\nexport { type PostgrestError, type PostgrestResponse } from '@supabase/supabase-js';\n","usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\supabaseMiddleware.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\types.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":14,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":14,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[298,301],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[298,301],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Shared types for the Food Truck Finder application\n\nexport type PriceRange = '$|$$,$$$';\n\nexport interface MenuCategory {\n  name: string;\n  items: MenuItem[];\n}\n\nexport interface MenuItem {\n  name: string;\n  description: string | undefined;\n  price: number | string | undefined;\n  dietary_tags: any[];\n  is_popular?: boolean;\n}\n\nexport interface LocationData {\n  address: string | undefined;\n  city: string | undefined;\n  state: string | undefined;\n  landmarks: string[];\n  coordinates: {\n    lat: number | undefined;\n    lng: number | undefined;\n  };\n  confidence: number;\n  raw_location_text: string | undefined;\n}\n\nexport type DailyOperatingHours =\n  | { open: string; close: string; closed: boolean }\n  | { closed: true }\n  | undefined;\n\nexport interface OperatingHours {\n  monday: DailyOperatingHours;\n  tuesday: DailyOperatingHours;\n  wednesday: DailyOperatingHours;\n  thursday: DailyOperatingHours;\n  friday: DailyOperatingHours;\n  saturday: DailyOperatingHours;\n  sunday: DailyOperatingHours;\n  [key: string]: DailyOperatingHours; // Add index signature\n}\n\nexport interface SentimentAnalysisResult {\n  sentiment: 'positive' | 'negative' | 'neutral';\n  score: number;\n  confidence: number;\n  key_topics: string[];\n  positive_aspects: string[];\n  negative_aspects: string[];\n  summary: string;\n  recommended: boolean;\n}\n\nexport interface EnhancedFoodTruckData {\n  name: string | undefined;\n  description: string | undefined;\n  cuisine_type: string[];\n  price_range: PriceRange;\n  specialties: string[];\n  dietary_options: string[];\n  enhanced_menu: {\n    categories: MenuCategory[];\n  };\n  standardized_hours: OperatingHours;\n  cleaned_contact: {\n    phone: string | undefined;\n    email: string | undefined;\n    website: string | undefined;\n  };\n  data_quality_improvements: string[];\n  confidence_score: number;\n}\n\nexport interface ExtractedFoodTruckDetails {\n  name: string | undefined;\n  description: string | undefined;\n  cuisine_type: string[];\n  price_range: PriceRange | undefined;\n  specialties: string[];\n  current_location: {\n    address: string | undefined;\n    city: string | undefined;\n    state: string | undefined;\n    zip_code: string | undefined;\n    lat?: number;\n    lng?: number;\n    raw_text: string | undefined;\n  };\n  scheduled_locations?: {\n    // Added scheduled_locations\n    address?: string;\n    city?: string;\n    state?: string;\n    zip_code?: string;\n    lat?: number;\n    lng?: number;\n    timestamp: string;\n    start_time: string; // Added start_time\n    end_time: string; // Added end_time\n  }[];\n  operating_hours: OperatingHours;\n  menu: MenuCategory[];\n  contact_info: {\n    phone?: string;\n    email?: string;\n    website?: string;\n  };\n  social_media: {\n    instagram?: string;\n    facebook?: string;\n    twitter?: string;\n    tiktok?: string;\n    yelp?: string;\n  };\n  source_url: string;\n}\n\nexport interface FirecrawlOutputData {\n  markdown: string;\n  name?: string;\n  source_url?: string;\n}\n\nexport interface FoodTruckSchema {\n  name: string;\n  description?: string;\n  current_location: {\n    lat: number;\n    lng: number;\n    address: string | undefined;\n    timestamp: string;\n  };\n  scheduled_locations: ExtractedFoodTruckDetails['scheduled_locations'];\n  operating_hours: OperatingHours;\n  menu: MenuCategory[];\n  contact_info: ExtractedFoodTruckDetails['contact_info'];\n  social_media: ExtractedFoodTruckDetails['social_media'];\n  cuisine_type: string[];\n  price_range: PriceRange | undefined;\n  specialties: string[];\n  data_quality_score: number;\n  verification_status: 'pending' | 'verified' | 'flagged';\n  source_urls: string[];\n  last_scraped_at: string;\n  test_run_flag?: boolean;\n  website?: string;\n  phone_number?: string;\n  email?: string;\n  instagram_handle?: string;\n  facebook_handle?: string;\n  twitter_handle?: string;\n  schedule?: unknown[]; // Assuming schedule is an array, adjust type if known\n  average_rating?: number;\n  review_count?: number;\n}\n\n// Database record type with additional fields\nexport interface FoodTruck extends FoodTruckSchema {\n  id: string;\n  created_at: string;\n  updated_at: string;\n  is_active?: boolean;\n}\n\nexport interface GeminiResponse<T = unknown> {\n  success: boolean;\n  data?: T;\n  tokensUsed?: number;\n  error?: string;\n  promptSent?: string;\n}\n\nexport interface StageResult {\n  status: string;\n  data?: FirecrawlOutputData | ExtractedFoodTruckDetails | FoodTruckSchema;\n  error?: string;\n  details?: string;\n  prompt?: string;\n  tokensUsed?: number;\n  metadata?: { name?: string; source_url?: string };\n  rawContent?: string;\n  preparedData?: FoodTruckSchema;\n  recordId?: string;\n}\n\nexport interface TestPipelineResults {\n  firecrawl?: StageResult;\n  gemini?: StageResult;\n  supabase?: StageResult;\n  overallStatus?: string;\n  logs?: string[];\n  error?: string;\n}\n\nexport interface PipelineRunResult {\n  firecrawl?: StageResult;\n  gemini?: StageResult;\n  supabase?: StageResult;\n  logs: string[];\n  overallStatus: 'Success' | 'Error';\n}\n\nexport interface RealtimeMetrics {\n  scrapingJobs: {\n    active: number;\n    completed: number;\n    failed: number;\n    pending: number;\n  };\n  dataQuality: {\n    averageScore: number;\n    totalTrucks: number;\n    recentChanges: number;\n  };\n  systemHealth: {\n    status: 'healthy' | 'warning' | 'error';\n    uptime: number;\n    lastUpdate: string;\n  };\n}\n\nexport interface TruckRating {\n  id: number;\n  title: string;\n  score: number;\n}\n\nexport interface PipelineEvent {\n  type: string; // e.g., 'job_started', 'job_completed', 'data_updated'\n  payload: Record<string, unknown>; // Generic payload for event-specific data\n  timestamp: string;\n}","usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\types\\foodTruck.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\types\\webVitals.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\utils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\utils\\QualityScorer.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\utils\\apiHelpers.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\utils\\dataQualityFormatters.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\utils\\foodTruckHelpers.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":57,"column":51,"nodeType":"Identifier","messageId":"conditionErrorObject","endLine":57,"endColumn":55},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":75,"column":8,"nodeType":"Identifier","messageId":"conditionErrorObject","endLine":75,"endColumn":16}],"suppressedMessages":[{"ruleId":"sonarjs/no-intrusive-permissions","severity":2,"message":"Make sure the use of the geolocation is necessary.","line":114,"column":5,"nodeType":"MemberExpression","messageId":"checkPermission","endLine":114,"endColumn":45,"suppressions":[{"kind":"directive","justification":"Geolocation is essential for finding nearby food trucks"}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { FoodTruck, DailyOperatingHours, MenuItem } from '@/lib/types'; // Added DailyOperatingHours, PriceRange, MenuItem\r\n\r\nexport const getCurrentDay = () => {\r\n  const days = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];\r\n  return days[new Date().getDay()];\r\n};\r\n\r\nexport const formatPrice = (price: number | string) => {\r\n  // Updated to accept string\r\n  if (typeof price === 'string') {\r\n    // Handle cases where price might be a string like \"$10-$20\" or \"Varies\"\r\n    return price;\r\n  }\r\n  return new Intl.NumberFormat('en-US', {\r\n    style: 'currency',\r\n    currency: 'USD',\r\n  }).format(price);\r\n};\r\n\r\n/**\r\n* Converts operational hours to a readable format or returns 'Closed' if applicable.\r\n* @example\r\n* formatOperatingHours({ open: '09:00', close: '17:00', closed: false })\r\n* '9:00 AM - 5:00 PM'\r\n* @param {DailyOperatingHours} hours - Object containing daily opening and closing times, and closed status.\r\n* @returns {string} Formatted operating hours string or 'Closed'.\r\n* @description\r\n*   - Handles conversion of military time to 12-hour format.\r\n*   - Adjusts for typical date parsing without relying on actual date due to fixed date string.\r\n*   - Properly responds to 'closed' status by returning 'Closed'.\r\n*   - Locales can impact formatted output by changing time conventions.\r\n*/\r\nexport const formatHours = (hours: DailyOperatingHours) => {\r\n  // Updated to accept DailyOperatingHours\r\n  if (!hours || hours.closed) {\r\n    return 'Closed';\r\n  }\r\n  const open = new Date(`1970-01-01T${hours.open}Z`).toLocaleTimeString('en-US', {\r\n    hour: 'numeric',\r\n    minute: 'numeric',\r\n    hour12: true,\r\n  });\r\n  const close = new Date(`1970-01-01T${hours.close}Z`).toLocaleTimeString('en-US', {\r\n    hour: 'numeric',\r\n    minute: 'numeric',\r\n    hour12: true,\r\n  });\r\n  return `${open} - ${close}`;\r\n};\r\n\r\nexport const getPopularItems = (truck: FoodTruck): MenuItem[] => {\r\n  // Explicitly define return type\r\n  // Explicitly check for nullish and boolean\r\n  return (\r\n    truck.menu\r\n      ?.flatMap((category) => category.items)\r\n      .filter((item): item is MenuItem => Boolean(item && item.is_popular === true)) ?? []\r\n  );\r\n};\r\n\r\n/**\r\n * Calculates the price range of all items in the food truck's menu.\r\n * @example\r\n * getPriceRange(foodTruck)\r\n * \"5.00 - 12.50\"\r\n * @param {FoodTruck} truck - The food truck object containing menu details.\r\n * @returns {string} Returns a formatted string representing the price range or 'N/A' if no valid prices are found.\r\n * @description\r\n *   - Utilizes the optional chaining operator to safely access nested menu items.\r\n *   - Filters out non-numeric and undefined prices before calculating the range.\r\n *   - Formats the minimum and maximum prices using a helper function.\r\n */\r\nexport const getPriceRange = (truck: FoodTruck) => {\r\n  const allItems = truck.menu?.flatMap((category) => category.items);\r\n  if (!allItems || allItems.length === 0) {\r\n    return 'N/A';\r\n  }\r\n  const numericPrices = allItems\r\n    .map((item) => item.price)\r\n    .filter((price): price is number => typeof price === 'number' && price != undefined); // Filter for numbers\r\n\r\n  if (numericPrices.length === 0) {\r\n    return 'N/A'; // No numeric prices found\r\n  }\r\n\r\n  const minPrice = Math.min(...numericPrices);\r\n  const maxPrice = Math.max(...numericPrices);\r\n  return `${formatPrice(minPrice)} - ${formatPrice(maxPrice)}`;\r\n};\r\n\r\nexport const getTodayHours = (truck: FoodTruck) => {\r\n  const today = getCurrentDay();\r\n  return truck.operating_hours?.[today];\r\n};\r\n\r\n// Get user's current location or default to San Francisco\r\n/**\r\n * Retrieves the user's geolocation and updates the location state.\r\n * @example\r\n * getUserLocationHelper(setUserLocation)\r\n * // Updates user's location or defaults to San Francisco\r\n * @param {function} setUserLocation - Callback function to update user's location state with latitude and longitude.\r\n * @returns {void} Function does not return anything.\r\n * @description\r\n *   - Defaults the location to San Francisco if geolocation access is denied or not supported.\r\n *   - Utilizes browser's geolocation API to fetch current coordinates.\r\n *   - Provides a warning in the console if location access is denied.\r\n */\r\nexport function getUserLocationHelper(\r\n  setUserLocation: (location: { lat: number; lng: number }) => void,\r\n) {\r\n  if (typeof navigator !== 'undefined' && navigator.geolocation != undefined) {\r\n    // eslint-disable-next-line sonarjs/no-intrusive-permissions -- Geolocation is essential for finding nearby food trucks\r\n    navigator.geolocation.getCurrentPosition(\r\n      (position) => {\r\n        setUserLocation({\r\n          lat: position.coords.latitude,\r\n          lng: position.coords.longitude,\r\n        });\r\n      },\r\n      (error) => {\r\n        console.warn('Location access denied:', error);\r\n        // Default to San Francisco\r\n        setUserLocation({ lat: 37.7749, lng: -122.4194 });\r\n      },\r\n    );\r\n  } else {\r\n    // Default to San Francisco if geolocation is not supported\r\n    setUserLocation({ lat: 37.7749, lng: -122.4194 });\r\n  }\r\n}\r\n\r\n// Load all food trucks from API\r\n/**\r\n * Loads food truck data from the server and updates state.\r\n * @example\r\n * loadFoodTrucksHelper(setTrucks, setLoading)\r\n * undefined\r\n * @param {(trucks: FoodTruck[]) => void} setTrucks - Callback to update the state with loaded food trucks.\r\n * @param {(loading: boolean) => void} setLoading - Callback to update the loading state.\r\n * @returns {void} No return value.\r\n * @description\r\n *   - Fetches data from '/api/trucks' endpoint.\r\n *   - Parses the response and expects an object containing a 'trucks' array.\r\n *   - Logs an error message to the console if fetching or parsing fails.\r\n *   - Ensures loading state is updated to false in all cases.\r\n */\r\nexport async function loadFoodTrucksHelper(\r\n  setTrucks: (trucks: FoodTruck[]) => void,\r\n  setLoading: (loading: boolean) => void,\r\n) {\r\n  try {\r\n    const response = await fetch('/api/trucks');\r\n    const data: unknown = await response.json();\r\n    if (\r\n      typeof data === 'object' &&\r\n      data != undefined &&\r\n      'trucks' in data &&\r\n      Array.isArray(data.trucks)\r\n    ) {\r\n      setTrucks(data.trucks as FoodTruck[]);\r\n    } else {\r\n      setTrucks([]);\r\n    }\r\n  } catch (error: unknown) {\r\n    console.error('Failed to load food trucks:', error);\r\n  } finally {\r\n    setLoading(false);\r\n  }\r\n}\r\n\r\n// Load nearby food trucks based on user location\r\n/**\r\n* Loads nearby food trucks based on user's location.\r\n* @example\r\n* loadNearbyTrucksHelper({ lat: 37.7749, lng: -122.4194 }, setTrucksCallback)\r\n* // sets trucks with food truck data or an empty array\r\n* @param {{ lat: number; lng: number } | undefined} userLocation - The location of the user used to find nearby trucks.\r\n* @param {(trucks: FoodTruck[]) => void} setTrucks - Callback function to set the trucks data.\r\n* @returns {void} No return value.\r\n* @description\r\n*   - Fetches nearby trucks from the API using latitude and longitude.\r\n*   - Uses a fixed radius of 10 units for truck search.\r\n*   - Handles errors by logging them to the console.\r\n*/\r\nexport async function loadNearbyTrucksHelper(\r\n  userLocation: { lat: number; lng: number } | undefined,\r\n  setTrucks: (trucks: FoodTruck[]) => void,\r\n) {\r\n  if (!userLocation) return;\r\n\r\n  try {\r\n    const response = await fetch(\r\n      `/api/trucks?lat=${userLocation.lat}&lng=${userLocation.lng}&radius=10`,\r\n    );\r\n    const data: unknown = await response.json();\r\n    if (\r\n      typeof data === 'object' &&\r\n      data != undefined &&\r\n      'trucks' in data &&\r\n      Array.isArray(data.trucks)\r\n    ) {\r\n      setTrucks(data.trucks as FoodTruck[]);\r\n    } else {\r\n      setTrucks([]);\r\n    }\r\n  } catch (error: unknown) {\r\n    console.error('Failed to load nearby trucks:', error);\r\n  }\r\n}\r\n\r\n// Check if a food truck is currently open\r\n/**\r\n * Determines if the food truck is currently open based on its operating hours.\r\n * @example\r\n * isTruckOpen(myFoodTruck)\r\n * // returns true or false depending on current time and truck's operating hours\r\n * @param {FoodTruck} truck - The food truck object with operating hours.\r\n * @returns {boolean} Indicates whether the food truck is open.\r\n * @description\r\n *   - Utilizes the current day's name to fetch operating hours.\r\n *   - Handles potential errors in parsing operating hours.\r\n *   - Logs errors related to parsing time and truck name.\r\n *   - Uses military time format (HHMM) for comparison.\r\n */\r\nexport function isTruckOpen(truck: FoodTruck): boolean {\r\n  const today = getCurrentDay();\r\n  const hours = truck.operating_hours?.[today];\r\n\r\n  // Ensure hours and its properties are not null/undefined before accessing\r\n  if (\r\n    hours == undefined ||\r\n    hours.closed === true ||\r\n    hours.open == undefined ||\r\n    hours.close == undefined\r\n  ) {\r\n    return false;\r\n  }\r\n\r\n  try {\r\n    const now = new Date();\r\n    const currentTime = now.getHours() * 100 + now.getMinutes();\r\n    const openTime = Number.parseInt(hours.open.replace(':', ''), 10);\r\n    const closeTime = Number.parseInt(hours.close.replace(':', ''), 10);\r\n\r\n    return currentTime >= openTime && currentTime <= closeTime;\r\n  } catch (error: unknown) {\r\n    console.error('Error parsing operating hours for truck', truck.name, error);\r\n    return false;\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\next-env.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]}]
