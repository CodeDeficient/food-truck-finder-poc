[{"filePath":"C:\\AI\\food-truck-finder-poc\\app\\api\\admin\\cron-status\\route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\app\\api\\admin\\scraping-metrics\\route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\components\\admin\\realtime\\useSystemAlertsLogic.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\hooks\\useRealtimeAdminEvents.types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\ScraperEngine.ts","messages":[],"suppressedMessages":[{"ruleId":"sonarjs/pseudo-random","severity":2,"message":"Make sure that using this pseudorandom number generator is safe here.","line":327,"column":24,"nodeType":"CallExpression","messageId":"safeGenerator","endLine":327,"endColumn":37,"suppressions":[{"kind":"directive","justification":"Math.random is acceptable for non-security-critical user agent selection."}]},{"ruleId":"sonarjs/pseudo-random","severity":2,"message":"Make sure that using this pseudorandom number generator is safe here.","line":343,"column":29,"nodeType":"CallExpression","messageId":"safeGenerator","endLine":343,"endColumn":42,"suppressions":[{"kind":"directive","justification":"Math.random is acceptable for non-security-critical random delays."}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\api\\admin\\automated-cleanup\\handlers.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\api\\admin\\data-quality\\handlers.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\api\\admin\\realtime-events\\handlers.ts","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-misused-promises","severity":2,"message":"Promise returned in function argument where a void return was expected.","line":61,"column":38,"nodeType":"ArrowFunctionExpression","messageId":"voidReturnArgument","endLine":63,"endColumn":8,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-misused-promises","severity":2,"message":"Promise returned in function argument where a void return was expected.","line":148,"column":22,"nodeType":"ArrowFunctionExpression","messageId":"voidReturnArgument","endLine":154,"endColumn":4,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"sonarjs/pseudo-random","severity":2,"message":"Make sure that using this pseudorandom number generator is safe here.","line":414,"column":27,"nodeType":"CallExpression","messageId":"safeGenerator","endLine":414,"endColumn":40,"suppressions":[{"kind":"directive","justification":"Math.random is acceptable for generating non-security-sensitive event IDs."}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\api\\admin\\scraping-metrics\\handlers.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'supabase' is defined but never used.","line":2,"column":48,"nodeType":null,"messageId":"unusedVar","endLine":2,"endColumn":56},{"ruleId":"sonarjs/unused-import","severity":2,"message":"Remove this unused import of 'supabase'.","line":2,"column":48,"nodeType":"Identifier","messageId":"removeUnusedImport","endLine":2,"endColumn":56,"suggestions":[{"messageId":"suggestRemoveOneVariable","fix":{"range":[90,100],"text":""},"desc":"Remove this variable import"}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'verifyAdminAccess' is defined but never used.","line":4,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":4,"endColumn":27},{"ruleId":"sonarjs/unused-import","severity":2,"message":"Remove this unused import of 'verifyAdminAccess'.","line":4,"column":10,"nodeType":"Identifier","messageId":"removeUnusedImport","endLine":4,"endColumn":27,"suggestions":[{"messageId":"suggestRemoveWholeStatement","fix":{"range":[169,230],"text":""},"desc":"Remove this import statement"}]},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an error typed value.","line":7,"column":9,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":7,"endColumn":45},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an error typed value.","line":10,"column":5,"nodeType":"Property","messageId":"anyAssignment","endLine":10,"endColumn":18}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { NextResponse } from 'next/server';\r\nimport { ScrapingJobService, FoodTruckService, supabase } from '@/lib/supabase';\r\nimport { RealtimeMetrics } from './types';\r\nimport { verifyAdminAccess } from '@/lib/auth/authHelpers';\r\n\r\nexport async function handleGetRequest(): Promise<NextResponse> {\r\n  const metrics = await getScrapingMetrics();\r\n  return NextResponse.json({\r\n    success: true,\r\n    data: metrics,\r\n    timestamp: new Date().toISOString(),\r\n  });\r\n}\r\n\r\n/**\r\n * Retrieves real-time scraping metrics from the database.\r\n * @example\r\n * getScrapingMetrics().then(metrics => console.log(metrics))\r\n * // { scrapingJobs: {...}, dataQuality: {...}, systemHealth: {...} }\r\n * @returns {Promise<RealtimeMetrics>} A promise that resolves to an object containing scraping job metrics, data quality information, and system health stats.\r\n * @description\r\n *   - Fetches data from ScrapingJobService and FoodTruckService to compute metrics.\r\n *   - Placeholder values are used for averageScore and recentChanges in dataQuality.\r\n *   - Computes the number of jobs by their status: running, completed, failed, and pending.\r\n */\r\nasync function getScrapingMetrics(): Promise<RealtimeMetrics> {\r\n  // Fetch real scraping metrics from database\r\n  const [allJobsResult, recentTrucksResult] = await Promise.all([\r\n    ScrapingJobService.getAllJobs(100, 0), // Get last 100 jobs for metrics\r\n    FoodTruckService.getAllTrucks(1000, 0), // Get trucks for processing count\r\n  ]);\r\n\r\n  // Type guard for allJobsResult\r\n  const allJobs: ScrapingJob[] = Array.isArray(allJobsResult) ? allJobsResult : [];\r\n\r\n  // Type guard for recentTrucksResult\r\n  const recentTrucks: { trucks: FoodTruck[]; total: number; error?: string } = (\r\n    typeof recentTrucksResult === 'object' &&\r\n    'trucks' in recentTrucksResult &&\r\n    Array.isArray(recentTrucksResult.trucks)\r\n  )\r\n    ? (recentTrucksResult as { trucks: FoodTruck[]; total: number; error?: string })\r\n    : { trucks: [], total: 0 };\r\n\r\n  const typedJobs = allJobs as Array<{\r\n    status?: string;\r\n    started_at?: string;\r\n    completed_at?: string;\r\n  }>;\r\n  const successfulRuns = typedJobs.filter((job) => job.status === 'completed').length;\r\n  const failedRuns = typedJobs.filter((job) => job.status === 'failed').length;\r\n\r\n  return {\r\n    scrapingJobs: {\r\n      active: typedJobs.filter((job) => job.status === 'running').length,\r\n      completed: successfulRuns,\r\n      failed: failedRuns,\r\n      pending: typedJobs.filter((job) => job.status === 'pending').length,\r\n    },\r\n    dataQuality: {\r\n      averageScore: 0, // Placeholder, actual calculation might be complex\r\n      totalTrucks: recentTrucks.total,\r\n      recentChanges: 0, // Placeholder\r\n    },\r\n    systemHealth: {\r\n      status: 'healthy',\r\n      uptime: process.uptime(),\r\n      lastUpdate: new Date().toISOString(),\r\n    },\r\n  };\r\n}","usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\auth\\authHelpers.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":6,"column":10,"nodeType":"Identifier","messageId":"conditionErrorNullableString","endLine":6,"endColumn":20,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[199,210],"text":"authHeader == null"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[200,210],"text":"(authHeader ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[199,210],"text":"!Boolean(authHeader)"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { supabase } from '@/lib/supabase';\n\nexport async function verifyAdminAccess(request: Request): Promise<boolean> {\n  try {\n    const authHeader = request.headers.get('authorization');\n    if (!authHeader) return false;\n\n    const token = authHeader.replace('Bearer ', '');\n    const { data, error } = await supabase.auth.getUser(token);\n    const user = data?.user;\n\n    if (error || !user) return false;\n\n    const { data: profile } = await supabase\n      .from('profiles')\n      .select('role')\n      .eq('id', user.id)\n      .single();\n\n    return profile?.role === 'admin';\n  } catch {\n    return false;\n  }\n}","usedDeprecatedRules":[]},{"filePath":"C:\\AI\\food-truck-finder-poc\\lib\\supabase.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":12,"column":6,"nodeType":"Identifier","messageId":"conditionErrorNullableString","endLine":12,"endColumn":24,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[346,365],"text":"supabaseServiceKey == null"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[347,365],"text":"(supabaseServiceKey ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[346,365],"text":"!Boolean(supabaseServiceKey)"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":107,"column":12,"nodeType":"MemberExpression","messageId":"conditionErrorObject","endLine":107,"endColumn":43},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":165,"column":12,"nodeType":"Identifier","messageId":"conditionErrorObject","endLine":165,"endColumn":16},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":769,"column":7,"nodeType":"MemberExpression","messageId":"conditionErrorObject","endLine":769,"endColumn":29},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":777,"column":7,"nodeType":"MemberExpression","messageId":"conditionErrorObject","endLine":777,"endColumn":25},{"ruleId":"sonarjs/no-unenclosed-multiline-block","severity":2,"message":"This statement will not be executed conditionally; only the first statement will be. The rest will execute unconditionally.","line":945,"column":68,"nodeType":"EmptyStatement","endLine":945,"endColumn":69}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {\r\n  createClient,\r\n  type PostgrestSingleResponse,\r\n  type PostgrestResponse,\r\n  type PostgrestError,\r\n} from '@supabase/supabase-js';\r\n\r\nconst supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;\r\nconst supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY;\r\nconst supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY;\r\n\r\nif (!supabaseServiceKey) {\r\n  throw new Error('Missing NEXT_PUBLIC_SUPABASE_URL environment variable');\r\n}\r\n\r\nif (supabaseAnonKey === undefined || supabaseAnonKey === '') {\r\n  throw new Error('Missing NEXT_PUBLIC_SUPABASE_ANON_KEY environment variable');\r\n}\r\n\r\nexport const supabase = createClient(supabaseUrl, supabaseAnonKey);\r\n\r\n// Only create admin client on server side where service key is available\r\nexport const supabaseAdmin = supabaseServiceKey\r\n  ? createClient(supabaseUrl, supabaseServiceKey)\r\n  : undefined;\r\n\r\n// Database types\r\nimport { MenuCategory, MenuItem } from './types';\r\n\r\nexport interface FoodTruckLocation {\r\n  lat: number;\r\n  lng: number;\r\n  address?: string;\r\n  timestamp: string;\r\n}\r\n\r\n// Re-exporting from types.ts to ensure consistency\r\n\r\nimport { FoodTruckSchema } from './types';\r\n\r\nexport interface FoodTruck extends FoodTruckSchema {\r\n  id: string;\r\n  created_at: string;\r\n  updated_at: string;\r\n  is_active?: boolean; // This property is in lib/types.ts but not in lib/supabase.ts\r\n  // Add any other properties that are in the database but not in FoodTruckSchema\r\n  // For example, if the database has 'exact_location' or 'city_location'\r\n  exact_location?: FoodTruckLocation;\r\n  city_location?: FoodTruckLocation;\r\n}\r\n\r\nexport interface ScrapingJob {\r\n  id: string;\r\n  job_type: string;\r\n  target_url?: string;\r\n  target_handle?: string;\r\n  platform?: string;\r\n  status: 'pending' | 'running' | 'completed' | 'failed';\r\n  priority: number;\r\n  scheduled_at: string;\r\n  started_at?: string;\r\n  completed_at?: string;\r\n  data_collected?: Record<string, unknown>;\r\n  errors?: string[];\r\n  retry_count: number;\r\n  max_retries: number;\r\n  created_at: string;\r\n}\r\n\r\nexport interface DataProcessingQueue {\r\n  id: string;\r\n  truck_id?: string;\r\n  processing_type: string;\r\n  raw_data: Record<string, unknown>;\r\n  processed_data?: Record<string, unknown>;\r\n  gemini_tokens_used: number;\r\n  status: 'pending' | 'processing' | 'completed' | 'failed';\r\n  priority: number;\r\n  created_at: string;\r\n  processed_at?: string;\r\n}\r\n\r\nexport interface ApiUsage {\r\n  id: string;\r\n  service_name: string;\r\n  usage_date: string;\r\n  requests_count: number;\r\n  tokens_used: number;\r\n}\r\n\r\n// Food truck operations\r\n/**\r\n* Groups menu items by their associated food truck ID.\r\n* @example\r\n* buildMenuByTruck([{ food_truck_id: '1', name: 'Burger' }, { food_truck_id: '2', name: 'Pizza' }])\r\n* { '1': [{ food_truck_id: '1', name: 'Burger' }], '2': [{ food_truck_id: '2', name: 'Pizza' }] }\r\n* @param {RawMenuItemFromDB[]} menuItems - Array of menu items where each item must have a food truck ID.\r\n* @returns {Record<string, RawMenuItemFromDB[]>} A record with keys of food truck IDs and values of arrays of menu items.\r\n* @description\r\n*   - Ensures only menu items with valid, non-empty food truck IDs are included.\r\n*   - Initializes an array for each unique food truck ID, grouping corresponding menu items.\r\n*/\r\nfunction buildMenuByTruck(menuItems: RawMenuItemFromDB[]): Record<string, RawMenuItemFromDB[]> {\r\n  const menuByTruck: Record<string, RawMenuItemFromDB[]> = {};\r\n  for (const item of menuItems) {\r\n    if (typeof item.food_truck_id === 'string' && item.food_truck_id.trim() !== '') {\r\n      if (!menuByTruck[item.food_truck_id]) {\r\n        menuByTruck[item.food_truck_id] = [];\r\n      }\r\n      menuByTruck[item.food_truck_id].push(item);\r\n    }\r\n  }\r\n  return menuByTruck;\r\n}\r\n\r\nfunction handleSupabaseError(error: unknown, context: string) {\r\n  // Log technical details for developers\r\n  console.warn(`Error in ${context}:`, error);\r\n}\r\n\r\nexport const FoodTruckService = {\r\n  async getAllTrucks(\r\n    limit = 50,\r\n    offset = 0,\r\n  ): Promise<{ trucks: FoodTruck[]; total: number; error?: string }> {\r\n    try {\r\n      const { data, error, count }: PostgrestResponse<FoodTruck> = await supabase\r\n        .from('food_trucks')\r\n        .select('*', { count: 'exact' })\r\n        .order('updated_at', { ascending: false })\r\n        .range(offset, offset + limit - 1);\r\n      if (error) throw error;\r\n      const trucks: FoodTruck[] = (data ?? []).map((t: FoodTruck) => normalizeTruckLocation(t));\r\n      if (trucks.length === 0) return { trucks: [], total: count ?? 0 };\r\n      const truckIds = trucks.map((t: FoodTruck) => t.id);\r\n      let menuItems: RawMenuItemFromDB[] = [];\r\n      try {\r\n        if (truckIds.length > 0) {\r\n          const { data: items, error: menuError }: PostgrestResponse<RawMenuItemFromDB> =\r\n            await supabase.from('menu_items').select('*').in('food_truck_id', truckIds);\r\n          if (menuError) throw new Error(menuError.message);\r\n          menuItems = Array.isArray(items) ? items : [];\r\n        }\r\n      } catch (menuError) {\r\n        handleSupabaseError(menuError, 'getAllTrucks:menu_items');\r\n      }\r\n      const menuByTruck = buildMenuByTruck(menuItems);\r\n      for (const truck of trucks) {\r\n        truck.menu = groupMenuItems(menuByTruck[truck.id] ?? []);\r\n      }\r\n      return { trucks, total: count ?? 0 };\r\n    } catch (error) {\r\n      handleSupabaseError(error, 'getAllTrucks');\r\n      return { trucks: [], total: 0, error: \"That didn't work, please try again later.\" };\r\n    }\r\n  },\r\n  async getTruckById(id: string): Promise<FoodTruck | { error: string }> {\r\n    try {\r\n      const { data, error }: PostgrestSingleResponse<FoodTruck> = await supabase\r\n        .from('food_trucks')\r\n        .select('*')\r\n        .eq('id', id)\r\n        .single();\r\n      if (error) throw error;\r\n      if (!data) {\r\n        return { error: \"That didn't work, please try again later.\" };\r\n      }\r\n      const truck: FoodTruck = normalizeTruckLocation(data);\r\n      const { data: items, error: menuError }: PostgrestResponse<RawMenuItemFromDB> = await supabase\r\n        .from('menu_items')\r\n        .select('*')\r\n        .eq('food_truck_id', id);\r\n      if (menuError) throw menuError;\r\n      truck.menu = groupMenuItems(Array.isArray(items) ? items : []);\r\n      return truck;\r\n    } catch (error) {\r\n      handleSupabaseError(error, 'getTruckById');\r\n      return { error: \"That didn't work, please try again later.\" };\r\n    }\r\n  },\r\n\r\n  async getTrucksByLocation(\r\n    lat: number,\r\n    lng: number,\r\n    radiusKm: number,\r\n  ): Promise<FoodTruck[] | { error: string }> {\r\n    try {\r\n      const { trucks } = await FoodTruckService.getAllTrucks();\r\n      const nearbyTrucks = trucks.filter((truck: FoodTruck) => {\r\n        if (\r\n          truck.current_location == undefined ||\r\n          typeof truck.current_location.lat !== 'number' ||\r\n          typeof truck.current_location.lng !== 'number'\r\n        ) {\r\n          return false;\r\n        }\r\n        const distance = calculateDistance(\r\n          lat,\r\n          lng,\r\n          truck.current_location.lat,\r\n          truck.current_location.lng,\r\n        );\r\n        return distance <= radiusKm;\r\n      });\r\n      return nearbyTrucks;\r\n    } catch (error: unknown) {\r\n      handleSupabaseError(error, 'getTrucksByLocation');\r\n      return { error: \"That didn't work, please try again later.\" };\r\n    }\r\n  },\r\n  async createTruck(truckData: Partial<FoodTruck>): Promise<FoodTruck | { error: string }> {\r\n    if (!supabaseAdmin) {\r\n      return { error: 'Admin operations require SUPABASE_SERVICE_ROLE_KEY' };\r\n    }\r\n    const menuData = truckData.menu;\r\n    const truckDataWithoutMenu = { ...truckData };\r\n    delete truckDataWithoutMenu.menu;\r\n    const { data: truck, error }: PostgrestSingleResponse<FoodTruck> = await supabaseAdmin\r\n      .from('food_trucks')\r\n      .insert([truckDataWithoutMenu])\r\n      .select()\r\n      .single();\r\n    if (error) {\r\n      handleSupabaseError(error, 'createTruck');\r\n      return { error: 'Failed to create truck.' };\r\n    }\r\n    await insertMenuItems(truck.id, menuData);\r\n    return truck;\r\n  },\r\n\r\n  async updateTruck(\r\n    id: string,\r\n    updates: Partial<FoodTruck>,\r\n  ): Promise<FoodTruck | { error: string }> {\r\n    if (!supabaseAdmin) {\r\n      return { error: 'Admin operations require SUPABASE_SERVICE_ROLE_KEY' };\r\n    }\r\n    const menuData = updates.menu;\r\n    const updatesWithoutMenu = { ...updates };\r\n    delete updatesWithoutMenu.menu;\r\n    const truckResult = await updateTruckData(id, updatesWithoutMenu);\r\n    if ('error' in truckResult) {\r\n      return truckResult;\r\n    }\r\n    if (menuData != undefined) {\r\n      await updateTruckMenu(id, menuData);\r\n    }\r\n    return truckResult;\r\n  },\r\n\r\n  async getDataQualityStats(): Promise<{\r\n    total_trucks: number;\r\n    avg_quality_score: number;\r\n    high_quality_count: number;\r\n    medium_quality_count: number;\r\n    low_quality_count: number;\r\n    verified_count: number;\r\n    pending_count: number;\r\n    flagged_count: number;\r\n  }> {\r\n    try {\r\n      const {\r\n        data,\r\n        error,\r\n      }: PostgrestSingleResponse<{\r\n        total_trucks: number;\r\n        avg_quality_score: number;\r\n        high_quality_count: number;\r\n        medium_quality_count: number;\r\n        low_quality_count: number;\r\n        verified_count: number;\r\n        pending_count: number;\r\n        flagged_count: number;\r\n      }> = await supabase.rpc('get_data_quality_stats').single();\r\n      if (error) throw error;\r\n      return data as {\r\n        total_trucks: number;\r\n        avg_quality_score: number;\r\n        high_quality_count: number;\r\n        medium_quality_count: number;\r\n        low_quality_count: number;\r\n        verified_count: number;\r\n        pending_count: number;\r\n        flagged_count: number;\r\n      };\r\n    } catch (error: unknown) {\r\n      console.warn('Error fetching data quality stats:', error);\r\n      return {\r\n        total_trucks: 0,\r\n        avg_quality_score: 0,\r\n        high_quality_count: 0,\r\n        medium_quality_count: 0,\r\n        low_quality_count: 0,\r\n        verified_count: 0,\r\n        pending_count: 0,\r\n        flagged_count: 0,\r\n      };\r\n    }\r\n  },\r\n};\r\n\r\n// Helper functions to reduce cognitive complexity\r\nconst isMenuCategory = (obj: unknown): obj is MenuCategory =>\r\n  typeof obj === 'object' &&\r\n  obj != undefined &&\r\n  'name' in obj &&\r\n  'items' in obj &&\r\n  Array.isArray(obj.items);\r\n\r\n/**\r\n * Determines whether the given object is a MenuItem.\r\n * @example\r\n * isMenuItem({ name: \"Pizza\", description: \"Delicious\", price: 9.99, dietary_tags: [\"Vegetarian\"] })\r\n * true\r\n * @param {unknown} obj - The object to be checked.\r\n * @returns {boolean} Returns true if the object has properties consistent with a MenuItem.\r\n * @description\r\n *   - Checks if 'name' is a string.\r\n *   - Checks if 'description' is either undefined or a string.\r\n *   - Checks if 'price' is either undefined or a number.\r\n *   - Ensures 'dietary_tags' is either undefined or an array of strings.\r\n */\r\nconst isMenuItem = (obj: unknown): obj is MenuItem => {\r\n  if (typeof obj !== 'object' || obj == undefined) return false;\r\n  const item = obj as Record<string, unknown>;\r\n  return (\r\n    typeof item.name === 'string' &&\r\n    (item.description === undefined || typeof item.description === 'string') &&\r\n    (item.price === undefined || typeof item.price === 'number') &&\r\n    (item.dietary_tags === undefined ||\r\n      (Array.isArray(item.dietary_tags) &&\r\n        item.dietary_tags.every((tag) => typeof tag === 'string')))\r\n  );\r\n};\r\n\r\n/**\r\n* Updates the food truck data for a given truck ID with provided updates.\r\n* @example\r\n* updateTruckData('truck123', { name: 'New Truck Name', location: 'Downtown' })\r\n* { id: 'truck123', name: 'New Truck Name', location: 'Downtown', ... }\r\n* @param {string} id - The ID of the food truck to be updated.\r\n* @param {Partial<FoodTruck>} updatesWithoutMenu - Partial object containing truck attributes to be updated, excluding menu items.\r\n* @returns {Promise<FoodTruck | { error: string }>} Returns the updated FoodTruck object or an error message upon failure.\r\n* @description\r\n*   - Requires SUPABASE_SERVICE_ROLE_KEY to perform operations.\r\n*   - Updates only non-menu details of the food truck.\r\n*   - Selects and returns the single updated record from the database.\r\n*   - Handles errors by invoking handleSupabaseError and returns an error message if any issues occur during update.\r\n*/\r\nasync function updateTruckData(\r\n  id: string,\r\n  updatesWithoutMenu: Partial<FoodTruck>,\r\n): Promise<FoodTruck | { error: string }> {\r\n  if (!supabaseAdmin) {\r\n    return { error: 'Admin operations require SUPABASE_SERVICE_ROLE_KEY' };\r\n  }\r\n\r\n  const { data: truck, error }: PostgrestSingleResponse<FoodTruck> = await supabaseAdmin\r\n    .from('food_trucks')\r\n    .update(updatesWithoutMenu)\r\n    .eq('id', id)\r\n    .select()\r\n    .single();\r\n\r\n  if (error) {\r\n    handleSupabaseError(error, 'updateTruckData');\r\n    return { error: 'Failed to update truck data.' };\r\n  }\r\n  return truck;\r\n}\r\n\r\n/**\r\n * Updates the menu items for a specific food truck in the Supabase database.\r\n * @example\r\n * updateTruckMenu('truck123', menuData)\r\n * Promise<void> // Updates the menu items and resolves a promise.\r\n * @param {string} id - Identifier for the food truck whose menu is being updated.\r\n * @param {MenuCategory[] | unknown[]} menuData - Array containing menu category objects or unknown objects.\r\n * @returns {Promise<void>} Resolves a promise when the operation is complete.\r\n * @description\r\n *   - Requires `SUPABASE_SERVICE_ROLE_KEY` to perform admin operations.\r\n *   - Deletes existing menu items before inserting updated ones.\r\n *   - Handles invalid categories or menu items by skipping them and logs warnings.\r\n */\r\nasync function updateTruckMenu(id: string, menuData: MenuCategory[] | unknown[]): Promise<void> {\r\n  if (!supabaseAdmin) {\r\n    throw new Error('Admin operations require SUPABASE_SERVICE_ROLE_KEY');\r\n  }\r\n\r\n  // Delete existing menu items\r\n  const { error: deleteError } = await supabaseAdmin\r\n    .from('menu_items')\r\n    .delete()\r\n    .eq('food_truck_id', id);\r\n\r\n  if (deleteError) {\r\n    console.error('Error deleting existing menu items for truck', id, deleteError);\r\n  }\r\n\r\n  // Insert new menu items if they exist\r\n  if (menuData != undefined && menuData.length > 0) {\r\n    const menuItems = menuData.flatMap((category: unknown) => {\r\n      if (!isMenuCategory(category)) {\r\n        console.warn('Skipping invalid category in updateTruckMenu:', category);\r\n        return [];\r\n      }\r\n\r\n      return (category.items ?? []).map((item: unknown) => {\r\n        if (!isMenuItem(item)) {\r\n          console.warn('Skipping invalid menu item in updateTruckMenu:', item);\r\n          // Return a default valid MenuItem or skip based on requirements\r\n          return {\r\n            food_truck_id: id,\r\n            category: category.name ?? 'Uncategorized',\r\n            name: 'Unknown Item',\r\n            description: undefined,\r\n            price: undefined,\r\n            dietary_tags: [],\r\n          };\r\n        }\r\n\r\n        return {\r\n          food_truck_id: id,\r\n          category: category.name ?? 'Uncategorized',\r\n          name: item.name ?? 'Unknown Item',\r\n          description: item.description ?? undefined,\r\n          price: typeof item.price === 'number' ? item.price : undefined,\r\n          dietary_tags: Array.isArray(item.dietary_tags) ? item.dietary_tags : [],\r\n        };\r\n      });\r\n    });\r\n\r\n    if (menuItems.length > 0) {\r\n      const { error: menuError } = await supabaseAdmin.from('menu_items').insert(menuItems);\r\n\r\n      if (menuError) {\r\n        console.error('Error inserting updated menu items for truck', id, menuError);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n* Computes the distance between two geographical points using the Haversine formula.\r\n* @example\r\n* calculateDistance(51.5074, -0.1278, 40.7128, -74.0060)\r\n* 5585.107071089907\r\n* @param {number} lat1 - Latitude of the first point in decimal degrees.\r\n* @param {number} lon1 - Longitude of the first point in decimal degrees.\r\n* @param {number} lat2 - Latitude of the second point in decimal degrees.\r\n* @param {number} lon2 - Longitude of the second point in decimal degrees.\r\n* @returns {number} The distance between the two points in kilometers.\r\n* @description\r\n*   - Uses Haversine formula to account for Earth's curvature.\r\n*   - Assumes Earth’s radius is 6371 kilometers.\r\n*   - Angles should be provided in decimal degrees, not radians.\r\n*/\r\nfunction calculateDistance(lat1: number, lon1: number, lat2: number, lon2: number): number {\r\n  const R = 6371;\r\n  const dLat = ((lat2 - lat1) * Math.PI) / 180;\r\n  const dLon = ((lon2 - lon1) * Math.PI) / 180;\r\n  const a =\r\n    Math.sin(dLat / 2) * Math.sin(dLat / 2) +\r\n    Math.cos((lat1 * Math.PI) / 180) *\r\n      Math.cos((lat2 * Math.PI) / 180) *\r\n      Math.sin(dLon / 2) *\r\n      Math.sin(dLon / 2);\r\n  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\r\n  const distance = R * c;\r\n  return distance;\r\n}\r\n\r\n// Define a helper type for items coming from the DB, which might include a category field\r\ninterface RawMenuItemFromDB {\r\n  name: string;\r\n  description?: string;\r\n  price?: number;\r\n  dietary_tags?: string[];\r\n  category?: string; // This field is expected from the DB query\r\n  // Potentially other fields like id, food_truck_id, etc.\r\n  [key: string]: unknown; // Allow other properties from DB select *\r\n}\r\n\r\n/**\r\n * Groups raw menu items into categories based on their category property.\r\n * @example\r\n * groupMenuItems([{name: 'Salad', category: 'Appetizers'}, {name: 'Burger'}])\r\n * // Returns: [{name: 'Appetizers', items: [{name: 'Salad', description: undefined, price: undefined, dietary_tags: []}]}, \r\n * //           {name: 'Uncategorized', items: [{name: 'Burger', description: undefined, price: undefined, dietary_tags: []}]}]\r\n * @param {RawMenuItemFromDB[]} rawItems - Array of raw menu items from the database.\r\n * @returns {MenuCategory[]} A list of menu categories with categorized menu items.\r\n * @description\r\n *   - Wraps raw menu items into a structured format separating them by categories.\r\n *   - Uses the nullish coalescing operator to handle null and undefined values from the database.\r\n *   - Explicitly casts dietary tags to an array of strings.\r\n */\r\nfunction groupMenuItems(rawItems: RawMenuItemFromDB[]): MenuCategory[] {\r\n  const byCategory: Record<string, MenuItem[]> = {}; // Stores processed MenuItems\r\n  for (const rawItem of rawItems) {\r\n    const categoryName: string = rawItem.category ?? 'Uncategorized';\r\n    byCategory[categoryName] ??= [];\r\n    // Construct a MenuItem conforming to the MenuItem interface (no 'category' property)\r\n    const menuItem: MenuItem = {\r\n      name: rawItem.name,\r\n      // Use nullish coalescing to convert null from DB to undefined for the MenuItem type\r\n      description: rawItem.description ?? undefined,\r\n      price: rawItem.price ?? undefined,\r\n      dietary_tags: (rawItem.dietary_tags as string[]) ?? [], // Explicitly cast to string[]\r\n    };\r\n    byCategory[categoryName].push(menuItem);\r\n  }\r\n  // Map to MenuCategory structure { name: string, items: MenuItem[] }\r\n  return Object.entries(byCategory).map(([categoryName, itemsList]: [string, MenuItem[]]) => ({\r\n    name: categoryName,\r\n    items: itemsList,\r\n  }));\r\n}\r\n\r\n// Remove redundant type constituent in normalizeTruckLocation\r\n/**\r\n * Normalizes the location of a food truck by selecting the most accurate available location data.\r\n * @example\r\n * normalizeTruckLocation(truckInstance)\r\n * returns truckInstance with updated current_location property\r\n * @param {FoodTruck} truck - A food truck object whose location needs normalization.\r\n * @returns {FoodTruck} A food truck object with a standardized current location.\r\n * @description\r\n *   - If no valid latitude or longitude is found, it defaults to the fallback location.\r\n *   - The function prioritizes exact_location over current_location and city_location.\r\n *   - Ensures that the address is populated even if only latitude and longitude are available.\r\n *   - Uses the current timestamp when none is provided in the location data.\r\n */\r\nfunction normalizeTruckLocation(truck: FoodTruck): FoodTruck {\r\n  const fallback: FoodTruckLocation = {\r\n    lat: 0,\r\n    lng: 0,\r\n    address: 'Unknown',\r\n    timestamp: new Date().toISOString(),\r\n  };\r\n  const loc = truck.exact_location ?? truck.current_location ?? truck.city_location ?? {};\r\n  const lat = typeof loc.lat === 'number' ? loc.lat : 0;\r\n  const lng = typeof loc.lng === 'number' ? loc.lng : 0;\r\n  const {address} = loc;\r\n  const {timestamp} = loc;\r\n\r\n  truck.current_location =\r\n    lat === 0 || lng === 0\r\n      ? { ...fallback, address: address ?? fallback.address }\r\n      : {\r\n          lat,\r\n          lng,\r\n          address: address ?? fallback.address,\r\n          timestamp: timestamp ?? fallback.timestamp,\r\n        };\r\n  return truck;\r\n}\r\n\r\nexport const ScrapingJobService = {\r\n  async createJob(jobData: Partial<ScrapingJob>): Promise<ScrapingJob> {\r\n    if (!supabaseAdmin) {\r\n      throw new Error('Admin operations require SUPABASE_SERVICE_ROLE_KEY');\r\n    }\r\n\r\n    const { data, error }: PostgrestSingleResponse<ScrapingJob> = await supabaseAdmin\r\n      .from('scraping_jobs')\r\n      .insert([\r\n        {\r\n          ...jobData,\r\n          status: 'pending',\r\n          retry_count: 0,\r\n          max_retries: 3,\r\n          created_at: new Date().toISOString(),\r\n        },\r\n      ])\r\n      .select()\r\n      .single();\r\n\r\n    if (error) throw error;\r\n    return data;\r\n  },\r\n\r\n  async getJobsByStatus(status: string): Promise<ScrapingJob[]> {\r\n    try {\r\n      const query = supabase.from('scraping_jobs').select('*');\r\n\r\n      const { data, error }: PostgrestResponse<ScrapingJob> = await (\r\n        status === 'all' ? query : query.eq('status', status)\r\n      )\r\n        .order('priority', { ascending: false })\r\n        .order('scheduled_at', { ascending: true });\r\n\r\n      if (error) throw error;\r\n      return data ?? [];\r\n    } catch (error: unknown) {\r\n      console.warn('Error fetching jobs:', error);\r\n      return [];\r\n    }\r\n  },\r\n  async updateJobStatus(\r\n    id: string,\r\n    status: string,\r\n    updates: Partial<ScrapingJob> = {},\r\n  ): Promise<ScrapingJob> {\r\n    if (!supabaseAdmin) {\r\n      throw new Error('Admin operations require SUPABASE_SERVICE_ROLE_KEY');\r\n    }\r\n\r\n    const { data, error }: PostgrestSingleResponse<ScrapingJob> = await supabaseAdmin\r\n      .from('scraping_jobs')\r\n      .update({\r\n        status,\r\n        ...updates,\r\n        ...(status === 'running' && { started_at: new Date().toISOString() }),\r\n        ...(status === 'completed' && { completed_at: new Date().toISOString() }),\r\n      })\r\n      .eq('id', id)\r\n      .select()\r\n      .single();\r\n\r\n    if (error) throw error;\r\n    return data;\r\n  },\r\n  async incrementRetryCount(id: string): Promise<ScrapingJob> {\r\n    if (!supabaseAdmin) {\r\n      throw new Error('Admin operations require SUPABASE_SERVICE_ROLE_KEY');\r\n    }\r\n\r\n    const {\r\n      data: current,\r\n      error: fetchError,\r\n    }: PostgrestSingleResponse<Pick<ScrapingJob, 'retry_count'>> = await supabaseAdmin\r\n      .from('scraping_jobs')\r\n      .select('retry_count')\r\n      .eq('id', id)\r\n      .single();\r\n\r\n    if (fetchError) throw fetchError;\r\n\r\n    const { data, error }: PostgrestSingleResponse<ScrapingJob> = await supabaseAdmin\r\n      .from('scraping_jobs')\r\n      .update({ retry_count: (current?.retry_count ?? 0) + 1 })\r\n      .eq('id', id)\r\n      .select()\r\n      .single();\r\n\r\n    if (error) throw error;\r\n    return data;\r\n  },\r\n  async getAllJobs(limit = 50, offset = 0): Promise<ScrapingJob[]> {\r\n    try {\r\n      const { data, error }: PostgrestResponse<ScrapingJob> = await supabase\r\n        .from('scraping_jobs')\r\n        .select('*')\r\n        .order('priority', { ascending: false })\r\n        .order('scheduled_at', { ascending: true })\r\n        .range(offset, offset + limit - 1);\r\n\r\n      if (error) throw error;\r\n      return data ?? [];\r\n    } catch (error: unknown) {\r\n      console.warn('Error fetching jobs:', error);\r\n      return [];\r\n    }\r\n  },\r\n\r\n  async getJobsFromDate(date: Date): Promise<ScrapingJob[]> {\r\n    try {\r\n      const { data, error }: PostgrestResponse<ScrapingJob> = await supabase\r\n        .from('scraping_jobs')\r\n        .select('*')\r\n        .gte('created_at', date.toISOString())\r\n        .order('created_at', { ascending: false });\r\n\r\n      if (error) throw error;\r\n      return data ?? [];\r\n    } catch (error: unknown) {\r\n      console.warn('Error fetching jobs from date:', error);\r\n      return [];\r\n    }\r\n  },\r\n};\r\n\r\nexport const DataProcessingService = {\r\n  async addToQueue(queueData: Partial<DataProcessingQueue>): Promise<DataProcessingQueue> {\r\n    if (!supabaseAdmin) {\r\n      throw new Error('Admin operations require SUPABASE_SERVICE_ROLE_KEY');\r\n    }\r\n\r\n    const { data, error }: PostgrestSingleResponse<DataProcessingQueue> = await supabaseAdmin\r\n      .from('data_processing_queue')\r\n      .insert([\r\n        {\r\n          ...queueData,\r\n          status: 'pending',\r\n          gemini_tokens_used: 0,\r\n          created_at: new Date().toISOString(),\r\n        },\r\n      ])\r\n      .select()\r\n      .single();\r\n\r\n    if (error) throw error;\r\n    return data;\r\n  },\r\n\r\n  async getNextQueueItem(): Promise<DataProcessingQueue | undefined> {\r\n    if (!supabaseAdmin) {\r\n      throw new Error('Admin operations require SUPABASE_SERVICE_ROLE_KEY');\r\n    }\r\n\r\n    const { data, error }: PostgrestSingleResponse<DataProcessingQueue> = await supabaseAdmin\r\n      .from('data_processing_queue')\r\n      .select('*')\r\n      .eq('status', 'pending')\r\n      .order('priority', { ascending: false })\r\n      .order('created_at', { ascending: true })\r\n      .limit(1)\r\n      .single();\r\n\r\n    if (error !== null && String(error.code) != 'PGRST116') throw error;\r\n    return data ?? undefined;\r\n  },\r\n\r\n  async getQueueByStatus(status: string): Promise<DataProcessingQueue[]> {\r\n    try {\r\n      const { data, error }: PostgrestResponse<DataProcessingQueue> = await supabase\r\n        .from('data_processing_queue')\r\n        .select('*')\r\n        .eq('status', status)\r\n        .order('created_at', { ascending: false });\r\n\r\n      if (error) throw error;\r\n      return data ?? [];\r\n    } catch (error: unknown) {\r\n      console.warn('Error fetching queue:', error);\r\n      return [];\r\n    }\r\n  },\r\n  async updateQueueItem(\r\n    id: string,\r\n    updates: Partial<DataProcessingQueue>,\r\n  ): Promise<DataProcessingQueue> {\r\n    if (!supabaseAdmin) {\r\n      throw new Error('Admin operations require SUPABASE_SERVICE_ROLE_KEY');\r\n    }\r\n\r\n    const { data, error }: PostgrestSingleResponse<DataProcessingQueue> = await supabaseAdmin\r\n      .from('data_processing_queue')\r\n      .update({\r\n        ...updates,\r\n        ...(updates.status === 'completed' && { processed_at: new Date().toISOString() }),\r\n      })\r\n      .eq('id', id)\r\n      .select()\r\n      .single();\r\n\r\n    if (error) throw error;\r\n    return data;\r\n  },\r\n};\r\n\r\nexport const DataQualityService = {\r\n  calculateQualityScore: (truck: FoodTruck) => {\r\n    // Placeholder for actual quality score calculation logic\r\n    // This should be implemented based on defined data quality rules\r\n    let score = 0;\r\n    if (typeof truck.name === 'string' && truck.name.trim() !== '') score += 20;\r\n    if (\r\n      truck.current_location &&\r\n      typeof truck.current_location.lat === 'number' &&\r\n      !Number.isNaN(truck.current_location.lat) &&\r\n      typeof truck.current_location.lng === 'number' &&\r\n      !Number.isNaN(truck.current_location.lng)\r\n    )\r\n      score += 30;\r\n    if (\r\n      truck.contact_info &&\r\n      ((typeof truck.contact_info.phone === 'string' && truck.contact_info.phone.trim() !== '') ||\r\n        (typeof truck.contact_info.email === 'string' && truck.contact_info.email.trim() !== '') ||\r\n        (typeof truck.contact_info.website === 'string' &&\r\n          truck.contact_info.website.trim() !== ''))\r\n    )\r\n      score += 25;\r\n    if (Array.isArray(truck.menu) && truck.menu.length > 0) score += 15;\r\n    if (truck.operating_hours != undefined) score += 10;\r\n    return { score: Math.min(100, score) };\r\n  },\r\n\r\n  async updateTruckQualityScore(truckId: string): Promise<FoodTruck | { error: string }> {\r\n    if (!supabaseAdmin) {\r\n      return { error: 'Admin operations require SUPABASE_SERVICE_ROLE_KEY' };\r\n    }\r\n    const { data: truck, error: fetchError } = (await supabaseAdmin\r\n      .from('food_trucks')\r\n      .select('*')\r\n      .eq('id', truckId)\r\n      .single()) as { data: FoodTruck | undefined; error: PostgrestError | undefined };\r\n\r\n    if (fetchError) {\r\n      handleSupabaseError(fetchError, 'updateTruckQualityScore:fetch');\r\n      return { error: `Failed to fetch truck with ID ${truckId}.` };\r\n    }\r\n    if (!truck) {\r\n      return { error: `Truck with ID ${truckId} not found.` };\r\n    }\r\n\r\n    const { score } = this.calculateQualityScore(truck);\r\n\r\n    const { data, error }: PostgrestSingleResponse<FoodTruck> = await supabaseAdmin\r\n      .from('food_trucks')\r\n      .update({ data_quality_score: score })\r\n      .eq('id', truckId)\r\n      .select()\r\n      .single();\r\n\r\n    if (error) {\r\n      handleSupabaseError(error, 'updateTruckQualityScore:update');\r\n      return { error: `Failed to update quality score for truck with ID ${truckId}.` };\r\n    }\r\n    return data;\r\n  },\r\n};\r\n\r\nexport const APIUsageService = {\r\n  async trackUsage(serviceName: string, requests: number, tokens: number): Promise<ApiUsage> {\r\n    if (!supabaseAdmin) {\r\n      throw new Error('Admin operations require SUPABASE_SERVICE_ROLE_KEY');\r\n    }\r\n\r\n    try {\r\n      const today = new Date().toISOString().split('T')[0];\r\n\r\n      const {\r\n        data: existing,\r\n        error: existingError,\r\n      }: { data: ApiUsage | undefined; error: PostgrestError | undefined } = await supabaseAdmin\r\n        .from('api_usage')\r\n        .select('*')\r\n        .eq('service_name', serviceName)\r\n        .eq('usage_date', today)\r\n        .single();\r\n\r\n      if (existingError && existingError.code !== 'PGRST116') throw existingError;\r\n\r\n      if (existing) {\r\n        const { data, error }: PostgrestSingleResponse<ApiUsage> = await supabaseAdmin\r\n          .from('api_usage')\r\n          .update({\r\n            requests_count: (existing.requests_count ?? 0) + requests,\r\n            tokens_used: (existing.tokens_used ?? 0) + tokens,\r\n          })\r\n          .eq('id', existing.id)\r\n          .select()\r\n          .single();\r\n\r\n        if (error) throw error;\r\n        return data;\r\n      } \r\n        const { data, error }: PostgrestSingleResponse<ApiUsage> = await supabaseAdmin\r\n          .from('api_usage')\r\n          .insert([\r\n            {\r\n              service_name: serviceName,\r\n              usage_date: today,\r\n              requests_count: requests,\r\n              tokens_used: tokens,\r\n            },\r\n          ])\r\n          .select()\r\n          .single();\r\n\r\n        if (error) throw error;\r\n        return data;\r\n      \r\n    } catch (error: unknown) {\r\n      console.warn('Error tracking usage:', error);\r\n      throw error;\r\n    }\r\n  },\r\n  async getTodayUsage(serviceName: string): Promise<ApiUsage | undefined> {\r\n    try {\r\n      const today = new Date().toISOString().split('T')[0];\r\n\r\n      const { data, error }: PostgrestSingleResponse<ApiUsage> = await supabase\r\n        .from('api_usage')\r\n        .select('*')\r\n        .eq('service_name', serviceName)\r\n        .eq('usage_date', today)\r\n        .single();\r\n\r\n      if (error !== null && String(error.code) != 'PGRST116') throw error;\r\n      return data ?? undefined;\r\n    } catch (error: unknown) {\r\n      console.warn('Error getting today usage:', error);\r\n      throw error;\r\n    }\r\n  },\r\n\r\n  async getAllUsageStats(): Promise<ApiUsage[]> {\r\n    try {\r\n      const { data, error }: PostgrestResponse<ApiUsage> = await supabase\r\n        .from('api_usage')\r\n        .select('*')\r\n        .order('usage_date', { ascending: false })\r\n        .limit(30);\r\n\r\n      if (error) throw error;\r\n      return data ?? [];\r\n    } catch (error: unknown) {\r\n      console.warn('Error getting usage stats:', error);\r\n      throw error;\r\n    }\r\n  },\r\n};\r\n\r\nexport { type MenuItem, type MenuCategory, type OperatingHours, type PriceRange } from './types';\r\n\r\n// Helper to prepare menu items for DB insertion\r\n/**\r\n * Prepares a list of menu items for insertion by filtering and transforming the input data.\r\n * @example\r\n * prepareMenuItemsForInsert(\"truck123\", [{ name: \"Beverages\", items: [{name: \"Tea\", price: 3.00}]}])\r\n * [\r\n *   {\r\n *     food_truck_id: \"truck123\",\r\n *     category: \"Beverages\",\r\n *     name: \"Tea\",\r\n *     description: undefined,\r\n *     price: 3.00,\r\n *     dietary_tags: []\r\n *   }\r\n * ]\r\n * @param {string} truckId - Unique identifier of the food truck.\r\n * @param {MenuCategory[] | unknown[] | undefined} menuData - Array of menu categories or unknown data, which may contain items to insert.\r\n * @returns {MenuItem[]} Returns an array of valid menu items formatted for database insertion, excluding invalid entries.\r\n * @description\r\n *   - Filters input data to ensure items are of MenuCategory type.\r\n *   - Logs warnings for invalid menu items and skips them.\r\n *   - Uses default values for missing item properties such as `category`, `name`, or `price`.\r\n */\r\nfunction prepareMenuItemsForInsert(\r\n  truckId: string,\r\n  menuData: MenuCategory[] | unknown[] | undefined,\r\n) {\r\n  if (!Array.isArray(menuData) || menuData.length === 0) return [];;\r\n  // Explicitly filter for MenuCategory to ensure type safety\r\n  const categories = menuData.filter(\r\n    (category): category is MenuCategory =>\r\n      typeof category === 'object' &&\r\n      category != undefined &&\r\n      'name' in category &&\r\n      'items' in category &&\r\n      Array.isArray(category.items),\r\n  ) as MenuCategory[];\r\n\r\n  return categories.flatMap(\r\n    (category) =>\r\n      (Array.isArray(category.items) ? category.items : [])\r\n        .map((item: unknown) => {\r\n          if (!isMenuItem(item)) {\r\n            console.warn('Skipping invalid menu item:', item);\r\n            return; // Return undefined for invalid items to be filtered out later\r\n          }\r\n\r\n          return {\r\n            food_truck_id: truckId,\r\n            category:\r\n              typeof category.name === 'string' && category.name !== ''\r\n                ? category.name\r\n                : 'Uncategorized',\r\n            name: typeof item.name === 'string' && item.name !== '' ? item.name : 'Unknown Item',\r\n            description:\r\n              typeof item.description === 'string' && item.description !== ''\r\n                ? item.description\r\n                : undefined,\r\n            price:\r\n              typeof item.price === 'number' && !Number.isNaN(item.price) ? item.price : undefined,\r\n            dietary_tags: Array.isArray(item.dietary_tags) ? item.dietary_tags : [],\r\n          };\r\n        })\r\n        .filter(Boolean) as MenuItem[], // Filter out nulls and assert type\r\n  );\r\n}\r\n\r\nasync function insertMenuItems(truckId: string, menuData: MenuCategory[] | unknown[] | undefined) {\r\n  const menuItems = prepareMenuItemsForInsert(truckId, menuData);\r\n  if (menuItems.length === 0) return;\r\n  const { error: menuError } = await supabaseAdmin!.from('menu_items').insert(menuItems);\r\n  if (menuError) {\r\n    console.error('Error inserting menu items for truck', truckId, menuError);\r\n  }\r\n}\r\n\r\n// Fix all strict-boolean-expressions and always-true/false comparisons below\r\n// Example: if (someString) => if (typeof someString === 'string' && someString.trim() !== '')\r\n// Example: if (someNumber) => if (typeof someNumber === 'number' && !Number.isNaN(someNumber) && someNumber !== 0)\r\n// Example: if (someObject) => if (someObject != null && someObject != undefined)\r\n\r\n// For all other conditionals, ensure explicit nullish/empty/NaN checks as above\r\n\r\nexport { type PostgrestError, type PostgrestResponse } from '@supabase/supabase-js';","usedDeprecatedRules":[]}]