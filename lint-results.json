[{"filePath":"/app/app/access-denied/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/app/admin/analytics/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/app/admin/auto-scraping/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/app/admin/data-cleanup/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/app/admin/data-quality/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/app/admin/events/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/app/admin/food-trucks/[id]/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/app/admin/food-trucks/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/app/admin/layout.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/app/admin/monitoring/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/app/admin/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/app/admin/pipeline/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/app/admin/test-pipeline/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/app/admin/users/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/app/api/admin/automated-cleanup/route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/app/api/admin/cron-status/route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/app/api/admin/data-cleanup/route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/app/api/admin/data-quality/route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/app/api/admin/oauth-status/route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/app/api/admin/realtime-events/route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/app/api/admin/scraping-metrics/route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/app/api/analytics/web-vitals/route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/app/api/auto-scrape-initiate/route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/app/api/autonomous-discovery/route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/app/api/cron/auto-scrape/route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/app/api/cron/quality-check/route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/app/api/dashboard/route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/app/api/enhanced-pipeline/route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/app/api/firecrawl/route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/app/api/gemini/route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/app/api/monitoring/api-usage/route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/app/api/pipeline/route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/app/api/scheduler/route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/app/api/scrape/route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/app/api/search/route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/app/api/tavily/route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/app/api/test-integration/route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/app/api/test-pipeline-run/route.ts","messages":[{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??=`) instead of an assignment expression, as it is simpler to read.","line":33,"column":5,"nodeType":"IfStatement","messageId":"preferNullishOverAssignment","endLine":35,"endColumn":6,"suggestions":[{"messageId":"suggestNullish","data":{"equals":"="},"fix":{"range":[1310,1380],"text":"body.isDryRun ??= true;"},"desc":"Fix to nullish coalescing operator (`??=`)."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { NextResponse, NextRequest } from 'next/server';\nimport { runTestPipeline } from '@/lib/api/test-integration/pipelineRunner';\n\nexport async function POST(request: NextRequest) {\n  const logs: string[] = [];\n  logs.push('Test pipeline run started.');\n\n  interface TestPipelineRequestBody {\n    url?: string;\n    rawText?: string;\n    isDryRun?: boolean;\n  }\n\n  try {\n    const rawBody: unknown = await request.json();\n\n    if (typeof rawBody !== 'object' || rawBody === null) {\n      logs.push('Invalid request body: expected an object.');\n      return NextResponse.json({ error: 'Invalid request body: expected an object.' }, { status: 400 });\n    }\n\n    const body: TestPipelineRequestBody = {};\n    if ('url' in rawBody && typeof (rawBody as { url?: unknown }).url === 'string') {\n      body.url = (rawBody as { url: string }).url;\n    }\n    if ('rawText' in rawBody && typeof (rawBody as { rawText?: unknown }).rawText === 'string') {\n      body.rawText = (rawBody as { rawText: string }).rawText;\n    }\n    if ('isDryRun' in rawBody && typeof (rawBody as { isDryRun?: unknown }).isDryRun === 'boolean') {\n      body.isDryRun = (rawBody as { isDryRun: boolean }).isDryRun;\n    }\n    // Default isDryRun if not provided, as per original logic where isDryRun = true was default in runTestPipeline\n    if (body.isDryRun === undefined) {\n        body.isDryRun = true;\n    }\n\n    const results = await runTestPipeline(body, logs);\n\n    // Explicitly cast to Record<string, unknown> for NextResponse.json\n    // to handle the complex/union types within PipelineRunResult's StageResult.data\n    return NextResponse.json({ results: results as Record<string, unknown> }, { status: 200 });\n  } catch (error: unknown) {\n    const errorMessage =\n      error instanceof Error\n        ? error.message\n        : 'An unknown error occurred during overall test pipeline run.';\n    logs.push(`Overall test pipeline error: ${errorMessage}`);\n    return NextResponse.json(\n      {\n        message: 'Test pipeline run failed.',\n        error: errorMessage,\n        results: {\n          logs,\n          overallStatus: 'Error',\n        },\n      },\n      { status: 200 },\n    );\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/app/app/api/trucks/[id]/route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/app/api/trucks/route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/app/auth/AuthProvider.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/app/auth/callback/route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/app/layout.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/app/loading.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/app/login/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/app/middleware.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/app/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/app/trucks/[id]/page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/FoodTruckInfoCard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/MapDisplay.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/ModeToggle.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/SearchFilters.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/ThemeProvider.tsx","messages":[],"suppressedMessages":[{"ruleId":"sonarjs/different-types-comparison","severity":2,"message":"Remove this \"===\" check; it will always be false. Did you mean to use \"==\"?","line":30,"column":15,"nodeType":null,"endLine":30,"endColumn":18,"suggestions":[{"desc":"Replace \"===\" with \"==\"","fix":{"range":[831,834],"text":"=="}}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/TruckCard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/WebVitalsReporter.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/admin/AdminNavLinks.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/admin/DataCleanupDashboard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/admin/RealtimeStatusIndicator.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/admin/UserMenu.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/admin/cleanup/CleanupGuide.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/admin/cleanup/CleanupHeader.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/admin/cleanup/CleanupOperationDetails.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/admin/cleanup/CleanupPreview.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/admin/cleanup/CleanupResults.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/admin/cleanup/CleanupSummaryCards.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/admin/cleanup/OperationSelector.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/admin/dashboard/DataQualityScoreCard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/admin/dashboard/PipelineStatusCard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/admin/dashboard/QualityDistributionCard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/admin/dashboard/RecentErrorsCard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/admin/dashboard/TotalFoodTrucksCard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/admin/food-trucks/detail/BasicInfoCard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/admin/food-trucks/detail/ContactField.tsx","messages":[{"ruleId":"unicorn/no-null","severity":1,"message":"Use `undefined` instead of `null`.","line":33,"column":19,"nodeType":"Literal","messageId":"error","endLine":33,"endColumn":23,"fix":{"range":[887,891],"text":"undefined"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import React from 'react';\n// Removed Mail, Phone, Globe imports as they are not directly used here\n\ninterface ContactFieldProps {\n  readonly icon: React.ComponentType<{ className?: string }>;\n  readonly label: string;\n  readonly value?: string;\n  readonly href?: string;\n  readonly unavailableText: string;\n}\n\nexport function ContactField({\n  icon: Icon,\n  label,\n  value,\n  href,\n  unavailableText\n}: Readonly<ContactFieldProps>) {\n  if (value == undefined || value === '') {\n    return (\n      <div className=\"flex items-center gap-3 text-gray-400\">\n        <Icon className=\"h-4 w-4\" />\n        <span className=\"text-sm\">{unavailableText}</span>\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"flex items-center gap-3\">\n      <Icon className=\"h-4 w-4 text-gray-500\" />\n      <div>\n        <label className=\"text-sm font-medium text-gray-500\">{label}</label>\n        {(href != null && href !== '') ? (\n          <a\n            href={href}\n            target=\"_blank\"\n            rel=\"noopener noreferrer\"\n            className=\"text-blue-600 hover:text-blue-800 underline\"\n          >\n            {value}\n          </a>\n        ) : (\n          <p className=\"text-gray-900\">{value}</p>\n        )}\n      </div>\n    </div>\n  );\n}\n","usedDeprecatedRules":[]},{"filePath":"/app/components/admin/food-trucks/detail/ContactInfoCard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/admin/food-trucks/detail/DataQualityCard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/admin/food-trucks/detail/LocationInfoCard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/admin/food-trucks/detail/OperatingHoursCard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/admin/food-trucks/detail/QualityMetricsGrid.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/admin/food-trucks/detail/QualityScoreMetric.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/admin/food-trucks/detail/RatingsReviewsCard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/admin/food-trucks/detail/SocialMediaLinks.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/admin/food-trucks/detail/TruckDetailHeader.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/admin/food-trucks/detail/TruckNotFound.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/admin/pipeline/FailedProcessingQueueTable.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/admin/pipeline/PipelineStatisticsCards.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/admin/pipeline/RecentScrapingJobsTable.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/admin/pipeline/ScrapingJobRow.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/admin/pipeline/ScrapingJobsTableContent.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/admin/realtime/AlertListDisplay.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/admin/realtime/AlertToggleButton.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/admin/realtime/ConnectionStatusHeader.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/admin/realtime/EventControls.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/admin/realtime/RealtimeStatusDisplay.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/admin/realtime/ScrapingJobsStatus.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/admin/realtime/StatusHelpers.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/admin/realtime/SystemAlertItem.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/admin/realtime/SystemAlerts.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/admin/realtime/SystemMetricsGrid.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/admin/realtime/useSystemAlertsLogic.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/admin/realtime/useSystemMetrics.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/admin/users/UserTable.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/home/AppHeader.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/home/LoadingScreen.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/home/MainContent.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/home/MapSection.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/home/TruckAccordionContent.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/home/TruckListHeader.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/home/TruckListSection.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/login/EmailFormFields.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/map/MapContent.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/map/MapLoadingFallback.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/map/MapViewUpdater.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/map/TruckMarkers.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/map/UserLocationMarker.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/map/mapHelpers.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/monitoring/ApiMonitoringDashboard.tsx","messages":[],"suppressedMessages":[{"ruleId":"unicorn/no-null","severity":1,"message":"Use `undefined` instead of `null`.","line":42,"column":37,"nodeType":"Literal","messageId":"error","endLine":42,"endColumn":41,"suggestions":[{"messageId":"replace","fix":{"range":[1557,1561],"text":"undefined"},"data":{},"desc":"Replace `null` with `undefined`."}],"suppressions":[{"kind":"directive","justification":"null is standard for JSON.stringify replacer"}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/monitoring/FeatureCard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/monitoring/FeatureList.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/monitoring/FeatureOverviewCards.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/monitoring/FeatureOverviewContent.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/monitoring/MonitoringFeaturesCard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/monitoring/MonitoringFeaturesContent.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/monitoring/MonitoringPageHeader.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/monitoring/TechnicalDetailsCard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/search/AdvancedFilters.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/search/CuisineTypesSection.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/search/DistanceSliderSection.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/search/FilterToggleButton.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/search/MainSearchSection.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/search/QuickFiltersSection.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/search/SearchFilterContent.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/search/SearchInputWithIcon.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/test-pipeline/ErrorDisplay.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/test-pipeline/StageResultCard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/test-pipeline/StageResultDetails.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/test-pipeline/TestPipelineForm.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/test-pipeline/TestPipelineSubmitHandler.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/test-pipeline/TestResultsDisplay.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/trucks/ContactSection.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/trucks/MenuSection.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/trucks/OperatingHoursSection.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/trucks/RatingSection.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/trucks/SocialMediaSection.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/trucks/TruckAccordionItem.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'selectedTruckId' is defined but never used. Allowed unused args must match /^_/u.","line":21,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":21,"endColumn":18}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from 'react';\nimport {\n  AccordionContent,\n  AccordionItem,\n  AccordionTrigger,\n} from '@/components/ui/accordion';\nimport { Badge } from '@/components/ui/badge';\nimport { TruckCard } from '@/components/TruckCard';\nimport { FoodTruck } from '@/lib/types/foodTruck';\n\ninterface TruckAccordionItemProps {\n  readonly truck: FoodTruck;\n  readonly selectedTruckId: string | undefined;\n  readonly setSelectedTruckId: (id: string | undefined) => void;\n  readonly isOpen: (truck: FoodTruck) => boolean;\n  readonly userLocation: { lat: number; lng: number } | undefined;\n}\n\nexport function TruckAccordionItem({\n  truck,\n  selectedTruckId,\n  setSelectedTruckId,\n  isOpen,\n  userLocation,\n}: TruckAccordionItemProps) {\n  return (\n    <AccordionItem value={truck.id} key={truck.id}>\n      <AccordionTrigger className=\"flex items-center justify-between p-4 hover:bg-gray-50 dark:hover:bg-slate-700 rounded-md\">\n        <div className=\"flex-1 text-left\">\n          <h4 className=\"font-medium dark:text-gray-100\">{truck.name}</h4>\n          {truck.current_location?.address && (\n            <p className=\"text-sm text-gray-600 dark:text-gray-400 line-clamp-1\">\n              {truck.current_location.address}\n            </p>\n          )}\n        </div>\n        <Badge variant={isOpen(truck) ? 'default' : 'secondary'}>\n          {isOpen(truck) ? 'Open' : 'Closed'}\n        </Badge>\n      </AccordionTrigger>\n      <AccordionContent>\n        <TruckCard\n          truck={truck}\n          isOpen={isOpen(truck)}\n          onSelectTruck={() => setSelectedTruckId(truck.id)}\n          userLocation={userLocation}\n          hideHeader={true}\n        />\n      </AccordionContent>\n    </AccordionItem>\n  );\n}\n","usedDeprecatedRules":[]},{"filePath":"/app/components/trucks/TruckBasicInfo.tsx","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":30,"column":10,"nodeType":"MemberExpression","messageId":"conditionErrorObject","endLine":30,"endColumn":28}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from 'react';\nimport { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';\nimport { Badge } from '@/components/ui/badge';\nimport type { FoodTruck } from '@/lib/supabase';\n\ninterface TruckBasicInfoProps {\n  readonly truck: FoodTruck;\n}\n\nexport function TruckBasicInfo({ truck }: Readonly<TruckBasicInfoProps>) {\n  return (\n    <Card className=\"dark:bg-slate-800 dark:border-slate-700\">\n      <CardHeader>\n        <CardTitle className=\"dark:text-gray-100\">About</CardTitle>\n        <CardDescription className=\"dark:text-gray-400\">Food truck information</CardDescription>\n      </CardHeader>\n      <CardContent className=\"space-y-4\">\n        <div>\n          <label className=\"text-sm font-medium text-gray-500 dark:text-gray-400\">Name</label>\n          <p className=\"text-lg font-semibold dark:text-gray-100\">{truck.name}</p>\n        </div>\n        \n        {truck.description != undefined && (\n          <div>\n            <label className=\"text-sm font-medium text-gray-500 dark:text-gray-400\">Description</label>\n            <p className=\"text-gray-900 dark:text-gray-200\">{truck.description}</p>\n          </div>\n        )}\n\n        {truck.cuisine_type && (\n          <div>\n            <label className=\"text-sm font-medium text-gray-500 dark:text-gray-400\">Cuisine Type</label>\n            <p className=\"text-gray-900 dark:text-gray-200\">{truck.cuisine_type}</p>\n          </div>\n        )}\n\n        {truck.price_range && (\n          <div>\n            <label className=\"text-sm font-medium text-gray-500 dark:text-gray-400\">Price Range</label>\n            <Badge variant=\"outline\" className=\"ml-2\">\n              {truck.price_range}\n            </Badge>\n          </div>\n        )}\n      </CardContent>\n    </Card>\n  );\n}\n","usedDeprecatedRules":[]},{"filePath":"/app/components/trucks/TruckCardContent.tsx","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":24,"column":8,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":24,"endColumn":25,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[781,798],"text":"(truck.description != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[781,798],"text":"(truck.description ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[781,798],"text":"(Boolean(truck.description))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from 'react';\nimport { Badge } from '@/components/ui/badge';\nimport { FoodTruck, DailyOperatingHours, MenuItem } from '@/lib/types';\nimport { RatingSection } from './RatingSection';\nimport { MenuSection } from './MenuSection';\nimport { ContactSection } from './ContactSection';\nimport { SocialMediaSection } from './SocialMediaSection';\nimport { OperatingHoursSection } from './OperatingHoursSection';\nimport { formatHours } from '@/lib/utils/foodTruckHelpers';\n\ninterface TruckCardContentProps {\n  readonly truck: FoodTruck;\n  readonly todayHours?: DailyOperatingHours;\n  readonly popularItems: MenuItem[]; // Use the full MenuItem type\n}\n\nexport function TruckCardContent({\n  truck,\n  todayHours,\n  popularItems,\n}: TruckCardContentProps) {\n  return (\n    <>\n      {truck.description && (\n        <p className=\"text-gray-600 dark:text-gray-400 mb-4 line-clamp-2\">{truck.description}</p>\n      )}\n      <div className=\"space-y-4\">\n        {/* Ratings & Hours Row */}\n        <div className=\"grid grid-cols-1 md:grid-cols-2 gap-4\">\n          <RatingSection averageRating={truck.average_rating} reviewCount={truck.review_count} />\n          <OperatingHoursSection todayHours={todayHours} formatHours={formatHours} />\n        </div>\n\n        {/* Menu & Contact Row */}\n        <div className=\"grid grid-cols-1 md:grid-cols-2 gap-4\">\n          <MenuSection popularItems={popularItems} />\n          <ContactSection contactInfo={truck.contact_info} verificationStatus={truck.verification_status} />\n        </div>\n\n        <SocialMediaSection socialMedia={truck.social_media} />\n      </div>\n      {truck.verification_status && (\n        <div className=\"mt-2\">\n          <Badge variant={truck.verification_status === 'verified' ? 'default' : 'secondary'}>\n            <span className=\"capitalize\">{truck.verification_status}</span>\n          </Badge>\n        </div>\n      )}\n    </>\n  );\n}\n","usedDeprecatedRules":[]},{"filePath":"/app/components/trucks/TruckCardFooter.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/trucks/TruckCardHeader.tsx","messages":[{"ruleId":"unicorn/no-null","severity":1,"message":"Use `undefined` instead of `null`.","line":35,"column":55,"nodeType":"Literal","messageId":"error","endLine":35,"endColumn":59,"fix":{"range":[1348,1352],"text":"undefined"}},{"ruleId":"unicorn/no-null","severity":1,"message":"Use `undefined` instead of `null`.","line":35,"column":163,"nodeType":"Literal","messageId":"error","endLine":35,"endColumn":167,"fix":{"range":[1456,1460],"text":"undefined"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":2,"source":"import React from 'react';\nimport { CardHeader, CardTitle, CardDescription } from '@/components/ui/card';\nimport { Badge } from '@/components/ui/badge';\nimport { MapPin } from 'lucide-react';\nimport { FoodTruck } from '@/lib/types';\n\ninterface TruckCardHeaderProps {\n  readonly truck: FoodTruck;\n  readonly isOpen: boolean;\n  readonly popularItems: Array<{ name: string; price: number | string | undefined }>;\n  readonly priceRange: string | undefined;\n}\n\nexport function TruckCardHeader({\n  truck,\n  isOpen,\n  popularItems,\n  priceRange\n}: TruckCardHeaderProps) {\n  return (\n    <CardHeader>\n      <div className=\"flex justify-between items-start\">\n        <div className=\"flex-1\">\n          <CardTitle className=\"text-lg dark:text-gray-100\">{truck.name}</CardTitle>\n          {(truck.current_location?.address != undefined) && (\n            <CardDescription className=\"flex items-center mt-1 dark:text-gray-400\">\n              <MapPin className=\"h-4 w-4 mr-1\" />\n              {truck.current_location.address}\n            </CardDescription>\n          )}\n        </div>\n        <div className=\"flex flex-col items-end space-y-1\">\n          <Badge variant={isOpen ? 'default' : 'secondary'}>{isOpen ? 'Open' : 'Closed'}</Badge>\n          {/* Show price range fallback if no explicit prices */}\n          {popularItems.every((item) => item.price == null || item.price === 0 || (typeof item.price === 'string' && item.price.trim() === '')) && (priceRange != null && priceRange !== '') && (\n            <Badge variant=\"outline\" className=\"mt-1\">\n              {priceRange}\n            </Badge>\n          )}\n        </div>\n      </div>\n    </CardHeader>\n  );\n}\n","usedDeprecatedRules":[]},{"filePath":"/app/components/trucks/TruckContactInfo.tsx","messages":[{"ruleId":"unicorn/no-null","severity":1,"message":"Use `undefined` instead of `null`.","line":39,"column":19,"nodeType":"Literal","messageId":"error","endLine":39,"endColumn":23,"fix":{"range":[1154,1158],"text":"undefined"}},{"ruleId":"unicorn/no-null","severity":1,"message":"Use `undefined` instead of `null`.","line":108,"column":47,"nodeType":"Literal","messageId":"error","endLine":108,"endColumn":51,"fix":{"range":[3748,3752],"text":"undefined"}},{"ruleId":"unicorn/no-null","severity":1,"message":"Use `undefined` instead of `null`.","line":116,"column":47,"nodeType":"Literal","messageId":"error","endLine":116,"endColumn":51,"fix":{"range":[4062,4066],"text":"undefined"}},{"ruleId":"unicorn/no-null","severity":1,"message":"Use `undefined` instead of `null`.","line":124,"column":49,"nodeType":"Literal","messageId":"error","endLine":124,"endColumn":53,"fix":{"range":[4379,4383],"text":"undefined"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":4,"source":"import React from 'react';\nimport { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';\nimport { Phone, Mail, Globe } from 'lucide-react';\nimport type { FoodTruck } from '@/lib/supabase';\n\ninterface TruckContactInfoProps {\n  readonly truck: FoodTruck;\n}\n\ninterface ContactFieldProps {\n  readonly icon: React.ComponentType<{ className?: string }>;\n  readonly label: string;\n  readonly value?: string | null;\n  readonly href?: string;\n  readonly unavailableText: string;\n}\n\nfunction ContactField({ \n  icon: Icon, \n  label, \n  value, \n  href, \n  unavailableText \n}: Readonly<ContactFieldProps>) {\n  if (value == undefined || value.length === 0) { // Handles null, undefined, and empty string\n    return (\n      <div className=\"flex items-center gap-3 text-gray-400\">\n        <Icon className=\"h-4 w-4\" />\n        <span className=\"text-sm\">{unavailableText}</span>\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"flex items-center gap-3\">\n      <Icon className=\"h-4 w-4 text-gray-500\" />\n      <div>\n        <label className=\"text-sm font-medium text-gray-500 dark:text-gray-400\">{label}</label>\n        {(href != null && href !== '') ? (\n          <a \n            href={href}\n            target={href.startsWith('http') ? '_blank' : undefined}\n            rel={href.startsWith('http') ? 'noopener noreferrer' : undefined}\n            className=\"block text-blue-600 hover:text-blue-800 dark:text-blue-400 dark:hover:text-blue-300 underline\"\n          >\n            {href.startsWith('http') ? 'Visit Website' : value}\n          </a>\n        ) : (\n          <p className=\"text-gray-900 dark:text-gray-200\">{value}</p>\n        )}\n      </div>\n    </div>\n  );\n}\n\nfunction SocialMediaLinks({ socialMedia }: Readonly<{ readonly socialMedia?: Record<string, string> }>) {\n  if (socialMedia == undefined || Object.keys(socialMedia).length === 0) {\n    return;\n  }\n\n  const socialPlatforms = [\n    { key: 'instagram', name: 'Instagram', baseUrl: 'https://instagram.com/', color: 'pink' },\n    { key: 'facebook', name: 'Facebook', baseUrl: 'https://facebook.com/', color: 'blue' },\n    { key: 'twitter', name: 'Twitter', baseUrl: 'https://twitter.com/', color: 'sky' },\n  ];\n\n  return (\n    <div>\n      <label className=\"text-sm font-medium text-gray-500 dark:text-gray-400\">Social Media</label>\n      <div className=\"flex flex-wrap gap-2 mt-2\">\n        {socialPlatforms.map(({ key, name, baseUrl, color }) => {\n          const handle = socialMedia[key];\n          if (handle == undefined || handle.length === 0) return; // Handles null, undefined, and empty string\n\n          return (\n            <a\n              key={key}\n              href={`${baseUrl}${handle}`}\n              target=\"_blank\"\n              rel=\"noopener noreferrer\"\n              className={`flex items-center gap-1 px-2 py-1 bg-${color}-100 text-${color}-800 rounded-md text-sm hover:bg-${color}-200 dark:bg-${color}-900 dark:text-${color}-200`}\n            >\n              <Globe className=\"h-3 w-3\" />\n              {name}\n            </a>\n          );\n        })}\n      </div>\n    </div>\n  );\n}\n\nexport function TruckContactInfo({ truck }: Readonly<TruckContactInfoProps>) {\n  return (\n    <Card className=\"dark:bg-slate-800 dark:border-slate-700\">\n      <CardHeader>\n        <CardTitle className=\"flex items-center gap-2 dark:text-gray-100\">\n          <Phone className=\"h-5 w-5\" />\n          Contact Information\n        </CardTitle>\n        <CardDescription className=\"dark:text-gray-400\">Get in touch</CardDescription>\n      </CardHeader>\n      <CardContent className=\"space-y-4\">\n        <ContactField\n          icon={Phone}\n          label=\"Phone\"\n          value={truck.contact_info?.phone}\n          href={(truck.contact_info?.phone != null && truck.contact_info.phone !== '') ? `tel:${truck.contact_info.phone}` : undefined}\n          unavailableText=\"No phone number available\"\n        />\n\n        <ContactField\n          icon={Mail}\n          label=\"Email\"\n          value={truck.contact_info?.email}\n          href={(truck.contact_info?.email != null && truck.contact_info.email !== '') ? `mailto:${truck.contact_info.email}` : undefined}\n          unavailableText=\"No email available\"\n        />\n\n        <ContactField\n          icon={Globe}\n          label=\"Website\"\n          value={truck.contact_info?.website}\n          href={(truck.contact_info?.website != null && truck.contact_info.website !== '') ? truck.contact_info.website : undefined}\n          unavailableText=\"No website available\"\n        />\n\n        <SocialMediaLinks socialMedia={truck.social_media} />\n      </CardContent>\n    </Card>\n  );\n}\n","usedDeprecatedRules":[]},{"filePath":"/app/components/trucks/TruckDetailHeader.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/trucks/TruckLocationInfo.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/trucks/TruckNotFound.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/trucks/TruckOperatingHours.tsx","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":31,"column":29,"nodeType":"MemberExpression","messageId":"conditionErrorObject","endLine":31,"endColumn":50}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from 'react';\nimport { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';\nimport { Clock } from 'lucide-react';\nimport type { FoodTruck } from '@/lib/supabase';\n\ninterface TruckOperatingHoursProps {\n  readonly truck: FoodTruck;\n}\n\ninterface DayData {\n  closed?: boolean;\n  open?: string;\n  close?: string;\n}\n\nfunction DaySchedule({ day, dayData }: Readonly<{ day: string; dayData?: DayData }>) {\n  const dayName = day.charAt(0).toUpperCase() + day.slice(1);\n  \n  return (\n    <div className=\"flex justify-between items-center\">\n      <span className=\"text-sm font-medium dark:text-gray-200\">{dayName}</span>\n      <span className=\"text-sm text-gray-600 dark:text-gray-400\">\n        {dayData?.closed === true ? 'Closed' : `${dayData?.open ?? 'N/A'} - ${dayData?.close ?? 'N/A'}`}\n      </span>\n    </div>\n  );\n}\n\nexport function TruckOperatingHours({ truck }: TruckOperatingHoursProps) {\n  const daysOfWeek = ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday'];\n  const hasOperatingHours = truck.operating_hours && Object.keys(truck.operating_hours).length > 0;\n\n  return (\n    <Card className=\"dark:bg-slate-800 dark:border-slate-700\">\n      <CardHeader>\n        <CardTitle className=\"flex items-center gap-2 dark:text-gray-100\">\n          <Clock className=\"h-5 w-5\" />\n          Operating Hours\n        </CardTitle>\n        <CardDescription className=\"dark:text-gray-400\">Daily schedule</CardDescription>\n      </CardHeader>\n      <CardContent>\n        {hasOperatingHours === true ? (\n          <div className=\"space-y-2\">\n            {daysOfWeek.map((day) => {\n              const dayData = truck.operating_hours?.[day as keyof typeof truck.operating_hours] as DayData | undefined;\n              return (\n                <DaySchedule key={day} day={day} dayData={dayData} />\n              );\n            })}\n          </div>\n        ) : (\n          <p className=\"text-gray-400 text-sm\">Operating hours not available</p>\n        )}\n      </CardContent>\n    </Card>\n  );\n}\n","usedDeprecatedRules":[]},{"filePath":"/app/components/trucks/TruckRatingsReviews.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/ui/AlertDialog.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/ui/AspectRatio.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/ui/ContextMenu.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/ui/DropdownMenu.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/ui/HoverCard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/ui/InputOtp.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/ui/NavigationMenu.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/ui/RadioGroup.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/ui/ScrollArea.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/ui/SimpleQualityPanel.tsx","messages":[{"ruleId":"@typescript-eslint/no-misused-promises","severity":2,"message":"Promise-returning function provided to attribute where a void return was expected.","line":106,"column":21,"nodeType":"JSXExpressionContainer","messageId":"voidReturnAttribute","endLine":106,"endColumn":43}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use client';\n\nimport React, { useState } from 'react';\nimport { Button } from '@/components/ui/button';\nimport { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';\nimport { Badge } from '@/components/ui/badge';\nimport { RefreshCw, Settings, Loader2 } from 'lucide-react';\n\ninterface SimpleQualityPanelProps {\n  readonly onRefresh?: () => void;\n}\n\ninterface RecalculateAllResult {\n  success: boolean;\n  data?: {\n    updated: number;\n    errors: number;\n  };\n  error?: string;\n}\n\nconst recalculateAllScores = async (): Promise<RecalculateAllResult> => {\n  const response = await fetch('/api/admin/data-quality', {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n    },\n    body: JSON.stringify({\n      action: 'recalculate_all',\n    }),\n  });\n\n  const result: unknown = await response.json();\n\n  if (typeof result === 'object' && result !== null && 'success' in result) {\n    return result.success === true ? {\n        success: true,\n        data: {\n          updated: (result as { data?: { updated?: number } }).data?.updated ?? 0,\n          errors: (result as { data?: { errors?: number } }).data?.errors ?? 0,\n        },\n      } : {\n        success: false,\n        error: (result as { error?: string }).error ?? 'Failed to recalculate quality scores',\n      };\n  }\n  return { success: false, error: 'Invalid response format' };\n};\n\nconst QualityScoreThresholds: React.FC = () => (\n  <div className=\"border rounded-lg p-4 bg-blue-50/50\">\n    <h4 className=\"font-medium mb-2 text-blue-900\">Quality Score Thresholds</h4>\n    <div className=\"space-y-1 text-sm text-blue-800\">\n      <div className=\"flex justify-between\">\n        <span>High Quality:</span>\n        <Badge className=\"bg-green-100 text-green-800\">≥ 80%</Badge>\n      </div>\n      <div className=\"flex justify-between\">\n        <span>Medium Quality:</span>\n        <Badge className=\"bg-yellow-100 text-yellow-800\">60% - 79%</Badge>\n      </div>\n      <div className=\"flex justify-between\">\n        <span>Low Quality:</span>\n        <Badge className=\"bg-red-100 text-red-800\">{`< 60%`}</Badge>\n      </div>\n    </div>\n  </div>\n);\n\nexport const SimpleQualityPanel: React.FC<SimpleQualityPanelProps> = ({ onRefresh }) => {\n  const [isRecalculating, setIsRecalculating] = useState(false);\n\n  const handleRecalculateAll = async () => {\n    setIsRecalculating(true);\n\n    try {\n      const result = await recalculateAllScores();\n      if (result.success) {\n        alert(`Quality scores updated successfully! ${result.data?.updated} trucks updated, ${result.data?.errors} errors.`);\n        onRefresh?.();\n      } else {\n        throw new Error(result.error);\n      }\n    } catch (error) {\n      console.error('Error recalculating quality scores:', error);\n      alert('Failed to recalculate quality scores. Please try again.');\n    } finally {\n      setIsRecalculating(false);\n    }\n  };\n\n  return (\n    <Card>\n      <CardHeader>\n        <CardTitle className=\"flex items-center gap-2\">\n          <Settings className=\"h-5 w-5\" />\n          Quality Management Operations\n        </CardTitle>\n        <CardDescription>\n          Bulk operations for managing data quality scores across all food trucks\n        </CardDescription>\n      </CardHeader>\n      <CardContent className=\"space-y-6\">\n        <div className=\"grid grid-cols-1 md:grid-cols-2 gap-4\">\n          <Button\n            onClick={handleRecalculateAll}\n            disabled={isRecalculating}\n            className=\"flex items-center gap-2\"\n            variant=\"default\"\n          >\n            {isRecalculating ? (\n              <Loader2 className=\"h-4 w-4 animate-spin\" />\n            ) : (\n              <RefreshCw className=\"h-4 w-4\" />\n            )}\n            Recalculate All Scores\n          </Button>\n        </div>\n\n        <QualityScoreThresholds />\n\n        <div className=\"text-xs text-muted-foreground\">\n          <p>\n            <strong>Recalculate All:</strong> Updates quality scores for all food trucks using the latest algorithm.\n          </p>\n        </div>\n      </CardContent>\n    </Card>\n  );\n};\n\nexport default SimpleQualityPanel;\n","usedDeprecatedRules":[]},{"filePath":"/app/components/ui/ToggleGroup.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/ui/UseMobile.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/ui/UseToast.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/ui/accordion.tsx","messages":[],"suppressedMessages":[{"ruleId":"sonarjs/deprecation","severity":2,"message":"'ElementRef' is deprecated.","line":13,"column":9,"nodeType":null,"messageId":"deprecation","endLine":13,"endColumn":19,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/ui/alert.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/ui/avatar.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/ui/badge.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/ui/breadcrumb.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/ui/button.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/ui/calendar.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/ui/card.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/ui/carousel.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/ui/chart.tsx","messages":[{"ruleId":"max-params","severity":2,"message":"Function has too many parameters (5). Maximum allowed is 4.","line":118,"column":25,"nodeType":"TSFunctionType","messageId":"exceed","endLine":118,"endColumn":25},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected any value in conditional. An explicit comparison or type conversion is required.","line":192,"column":50,"nodeType":"MemberExpression","messageId":"conditionErrorAny","endLine":192,"endColumn":62,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[6228,6240],"text":"(Boolean(item.payload))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'props' is defined but never used. Allowed unused args must match /^_/u.","line":277,"column":6,"nodeType":null,"messageId":"unusedVar","endLine":277,"endColumn":11},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":295,"column":10,"nodeType":"Identifier","messageId":"conditionErrorNullableBoolean","endLine":295,"endColumn":16,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[9225,9231],"text":"(active ?? false)"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareFalse","fix":{"range":[9224,9231],"text":"(active === false)"},"desc":"Change condition to check if false (`value === false`)"}]},{"ruleId":"unicorn/no-null","severity":1,"message":"Use `undefined` instead of `null`.","line":296,"column":14,"nodeType":"Literal","messageId":"error","endLine":296,"endColumn":18,"suggestions":[{"messageId":"remove","fix":{"range":[9281,9285],"text":""},"data":{},"desc":"Remove `null`."},{"messageId":"replace","fix":{"range":[9281,9285],"text":"undefined"},"data":{},"desc":"Replace `null` with `undefined`."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'props' is defined but never used. Allowed unused args must match /^_/u.","line":384,"column":82,"nodeType":null,"messageId":"unusedVar","endLine":384,"endColumn":87}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use client';\n\nimport * as React from 'react';\nimport * as RechartsPrimitive from 'recharts';\nimport {\n  NameType,\n  Payload,\n  ValueType,\n} from 'recharts/types/component/DefaultTooltipContent';\n\nimport { cn } from '@/lib/utils';\nimport { useTooltipLabel } from './chart/useTooltipLabel';\nimport { TooltipIndicator } from './chart/TooltipIndicator';\nimport { TooltipItemContent } from './chart/TooltipItemContent';\nimport { getPayloadConfigFromPayload } from './chart/getPayloadConfigFromPayload';\n\n// Format: { THEME_NAME: CSS_SELECTOR }\nconst THEMES = { light: '', dark: '.dark' } as const;\n\nexport type ChartConfig = {\n  [k in string]: {\n    label?: React.ReactNode;\n    icon?: React.ComponentType;\n  } & (\n    | { color?: string; theme?: never }\n    | { color?: never; theme: Record<keyof typeof THEMES, string> }\n  );\n};\n\ntype ChartContextProps = {\n  config: ChartConfig;\n};\n\nconst ChartContext = React.createContext<ChartContextProps | undefined>(undefined);\n\nfunction useChart() {\n  const context = React.useContext(ChartContext);\n  if (context === undefined) {\n    throw new Error('useChart must be used within a <ChartContainer />');\n  }\n  return context;\n}\n\nconst ChartContainer = React.forwardRef<\n  HTMLDivElement,\n  React.ComponentProps<'div'> & {\n    readonly config: ChartConfig;\n    readonly children: React.ComponentProps<typeof RechartsPrimitive.ResponsiveContainer>['children'];\n  }\n>(({ id, className, children, config, ...props }, ref) => {\n  const uniqueId = React.useId();\n  const chartId = `chart-${id ?? uniqueId.replaceAll(':', '')}`;\n\n  return (\n    <ChartContext.Provider value={{ config }}>\n      <div\n        data-chart={chartId}\n        ref={ref}\n        className={cn(\n          \"flex aspect-video justify-center text-xs [&_.recharts-cartesian-axis-tick_text]:fill-muted-foreground [&_.recharts-cartesian-grid_line[stroke='#ccc']]:stroke-border/50 [&_.recharts-curve.recharts-tooltip-cursor]:stroke-border [&_.recharts-dot[stroke='#fff']]:stroke-transparent [&_.recharts-layer]:outline-none [&_.recharts-polar-grid_[stroke='#ccc']]:stroke-border [&_.recharts-radial-bar-background-sector]:fill-muted [&_.recharts-rectangle.recharts-tooltip-cursor]:fill-muted [&_.recharts-reference-line_[stroke='#ccc']]:stroke-border [&_.recharts-sector[stroke='#fff']]:stroke-transparent [&_.recharts-sector]:outline-none [&_.recharts-surface]:outline-none\",\n          className,\n        )}\n        {...props}\n      >\n        <ChartStyle id={chartId} config={config} />\n        <RechartsPrimitive.ResponsiveContainer>{children}</RechartsPrimitive.ResponsiveContainer>\n      </div>\n    </ChartContext.Provider>\n  );\n});\nChartContainer.displayName = 'Chart';\n\nconst ChartStyle = ({ id, config }: { readonly id: string; readonly config: ChartConfig }) => {\n  const colorConfig = Object.entries(config).filter(([_, itemConfig]) => (itemConfig.theme ?? itemConfig.color) !== undefined);\n  if (colorConfig.length === 0) {\n    return;\n  }\n\n  return (\n    <style\n      dangerouslySetInnerHTML={{\n        __html: Object.entries(THEMES)\n          .map(\n            ([theme, prefix]) => `\n${prefix} [data-chart=${id}] {\n${colorConfig\n  .map(([key, itemConfig]) => {\n    const color = itemConfig.theme?.[theme as keyof typeof itemConfig.theme] ?? itemConfig.color;\n    return color !== undefined && color !== '' ? `  --color-${key}: ${color};` : undefined;\n  })\n  .join('\\n')}\n}\n`,\n          )\n          .join('\\n'),\n      }}\n    />\n  );\n};\n\nconst ChartTooltip = RechartsPrimitive.Tooltip;\n\ninterface ChartTooltipContentProps {\n  readonly hideLabel?: boolean;\n  readonly hideIndicator?: boolean;\n  readonly indicator?: 'line' | 'dot' | 'dashed';\n  readonly nameKey?: string;\n  readonly labelKey?: string;\n  // We can add any other specific props for ChartTooltipContent here\n  // and ensure they are distinct from RechartsPrimitive.Tooltip props\n  // and standard div props to avoid conflicts.\n}\n\nfunction isNonEmptyArray<T>(arr: T[] | undefined): arr is T[] {\n  return Array.isArray(arr) && arr.length > 0;\n}\n\ntype TooltipFormatter = (value: number, name: string, item: unknown, index: number, payload: Record<string, unknown>[]) => React.ReactNode;\ntype TooltipItemData = { name?: string; dataKey?: string; payload?: Record<string, unknown>; color?: string; value?: number };\n\n\ntype ChartTooltipIndicatorAndContentProps = {\n  indicator: 'line' | 'dot' | 'dashed';\n  hideIndicator: boolean;\n  indicatorColor?: string;\n  nestLabel: boolean;\n  itemConfig: Record<string, unknown>;\n  formatter: TooltipFormatter | undefined;\n  itemData: TooltipItemData;\n  item: Payload<ValueType, NameType>;\n  index: number;\n  tooltipLabel: React.ReactNode;\n};\n\nfunction ChartTooltipIndicatorAndContent(props: Readonly<ChartTooltipIndicatorAndContentProps>) {\n  const {\n    indicator,\n    hideIndicator,\n    indicatorColor,\n    nestLabel,\n    itemConfig,\n    formatter,\n    itemData,\n    item,\n    index,\n    tooltipLabel,\n  } = props;\n  return (\n    <>\n      <TooltipIndicator\n        indicator={indicator}\n        hideIndicator={hideIndicator}\n        indicatorColor={indicatorColor}\n        nestLabel={nestLabel}\n        itemConfig={itemConfig}\n      />\n      <TooltipItemContent\n        formatter={formatter}\n        itemData={itemData}\n        item={item}\n        index={index}\n        itemConfig={itemConfig}\n        nestLabel={nestLabel}\n        tooltipLabel={tooltipLabel}\n      />\n    </>\n  );\n}\n\ntype ChartTooltipItemProps = {\n  item: Payload<ValueType, NameType>;\n  index: number;\n  indicatorProps: {\n    indicator: 'line' | 'dot' | 'dashed';\n    hideIndicator: boolean;\n    color?: string;\n    nestLabel: boolean;\n    config: ChartConfig;\n    nameKey?: string;\n    tooltipLabel: React.ReactNode;\n    formatter: TooltipFormatter | undefined;\n  };\n};\n\nfunction ChartTooltipItem(props: Readonly<ChartTooltipItemProps>) {\n  const { item, index, indicatorProps } = props;\n  const { indicator, hideIndicator, color, nestLabel, config, nameKey, tooltipLabel, formatter } = indicatorProps;\n  const dataKey = typeof item.dataKey === 'string' ? item.dataKey : undefined;\n  const itemData: TooltipItemData = {\n    name: item.name === undefined ? undefined : String(item.name),\n    dataKey,\n    payload: typeof item.payload === 'object' && item.payload ? (item.payload as Record<string, unknown>) : undefined,\n    color: typeof item.color === 'string' ? item.color : undefined,\n    value: typeof item.value === 'number' ? item.value : undefined,\n  };\n  const key = nameKey ?? itemData.name ?? itemData.dataKey ?? 'value';\n  const itemConfig = getPayloadConfigFromPayload(config, item, key) as Record<string, unknown>;\n  const indicatorColor =\n    color ??\n    (itemData.payload && typeof itemData.payload === 'object' && 'fill' in itemData.payload\n      ? String(itemData.payload.fill)\n      : undefined) ??\n    itemData.color;\n  return (\n    <div\n      key={itemData.dataKey ?? index}\n      className={cn(\n        'flex w-full flex-wrap items-stretch gap-2 [&>svg]:h-2.5 [&>svg]:w-2.5 [&>svg]:text-muted-foreground',\n        indicator === 'dot' && 'items-center',\n      )}\n    >\n      <ChartTooltipIndicatorAndContent\n        indicator={indicator}\n        hideIndicator={hideIndicator}\n        indicatorColor={indicatorColor}\n        nestLabel={nestLabel}\n        itemConfig={itemConfig}\n        formatter={formatter}\n        itemData={itemData}\n        item={item}\n        index={index}\n        tooltipLabel={tooltipLabel}\n      />\n    </div>\n  );\n}\n\ntype ChartTooltipItemsProps = {\n  safePayload: Payload<ValueType, NameType>[];\n  indicatorProps: {\n    indicator: 'line' | 'dot' | 'dashed';\n    hideIndicator: boolean;\n    formatter: TooltipFormatter | undefined;\n    nameKey?: string;\n    color?: string;\n    tooltipLabel: React.ReactNode;\n    config: ChartConfig;\n    nestLabel: boolean;\n  };\n};\n\nfunction ChartTooltipItems(props: Readonly<ChartTooltipItemsProps>) {\n  const { safePayload, indicatorProps } = props;\n  return (\n    <div className=\"grid gap-1.5\">\n      {safePayload.map((item, index) => (\n        <ChartTooltipItem\n          key={item.dataKey ?? index}\n          item={item}\n          index={index}\n          indicatorProps={indicatorProps}\n        />\n      ))}\n    </div>\n  );\n}\n\nconst ChartTooltipContent = React.forwardRef<\n  HTMLDivElement,\n  React.ComponentProps<typeof RechartsPrimitive.Tooltip> &\n    React.ComponentProps<'div'> &\n    ChartTooltipContentProps\n>(({\n  active,\n  payload,\n  className,\n  indicator = 'dot',\n  hideLabel = false,\n  hideIndicator = false,\n  label,\n  labelFormatter,\n  labelClassName,\n  formatter,\n  color,\n  nameKey,\n  labelKey,\n  ...props // Capture any other div props\n}, ref) => {\n  // Destructure from props if necessary, or use directly if already destructured\n  // For example, if ChartTooltipContentProps was defined as:\n  // interface ChartTooltipContentProps { tooltipSpecificProp?: string; ... }\n  // Then you might access props.tooltipSpecificProp\n    const { config } = useChart();\n    const safePayload: Payload<ValueType, NameType>[] = isNonEmptyArray(payload) ? payload : [];\n    const tooltipLabel = useTooltipLabel({\n      hideLabel,\n      payload: safePayload,\n      label,\n      labelFormatter,\n      labelClassName,\n      config,\n      labelKey\n    });\n\n    if (!active || !isNonEmptyArray(safePayload)) {\n      return null;\n    }\n\n    const nestLabel = safePayload.length === 1 && indicator !== 'dot';\n\n    return (\n      <div\n        ref={ref}\n        className={cn(\n          'grid min-w-[8rem] items-start gap-1.5 rounded-lg border border-border/50 bg-background px-2.5 py-1.5 text-xs shadow-xl',\n          className,\n        )}\n      >\n        {!nestLabel && tooltipLabel}\n        <ChartTooltipItems\n          safePayload={safePayload}\n          indicatorProps={{\n            indicator,\n            hideIndicator,\n            formatter: formatter as TooltipFormatter | undefined,\n            nameKey,\n            color,\n            tooltipLabel,\n            config,\n            nestLabel,\n          }}\n        />\n      </div>\n    );\n  },\n);\nChartTooltipContent.displayName = 'ChartTooltip';\n\nconst ChartLegend = RechartsPrimitive.Legend;\n\ninterface ChartLegendContentProps {\n  hideIcon?: boolean;\n  nameKey?: string;\n  // Allow other RechartsPrimitive.LegendProps and div attributes\n  // by intersection or by explicitly including them if needed.\n  // For now, focusing on the direct props causing max-params.\n}\n\ninterface ChartLegendItemProps {\n  item: Payload<ValueType, NameType>;\n  idx: number;\n  hideIcon: boolean;\n  nameKey?: string;\n  config: ChartConfig;\n}\n\nfunction ChartLegendItem({ item, idx, hideIcon, nameKey, config }: Readonly<ChartLegendItemProps>) {\n  const dataKey = item.dataKey?.toString();\n  const itemData = {\n    dataKey,\n    value: item.value?.toString(),\n    color: item.color?.toString(),\n  };\n  const key = nameKey ?? dataKey ?? 'value';\n  const itemConfig = getPayloadConfigFromPayload(config, item, key);\n\n  return (\n    <div\n      key={itemData.value ?? idx}\n      className={cn(\n        'flex items-center gap-1.5 [&>svg]:h-3 [&>svg]:w-3 [&>svg]:text-muted-foreground',\n      )}\n    >\n      {itemConfig?.icon && !hideIcon ? (\n        <itemConfig.icon />\n      ) : (\n        <div\n          className=\"h-2 w-2 shrink-0 rounded-[2px]\"\n          style={{\n            backgroundColor: itemData.color,\n          }}\n        />\n      )}\n      {itemConfig?.label}\n    </div>\n  );\n}\n\nconst ChartLegendContent = React.forwardRef<\n  HTMLDivElement,\n  React.ComponentProps<typeof RechartsPrimitive.Legend> &\n    Pick<RechartsPrimitive.LegendProps, 'payload' | 'verticalAlign'> &\n    ChartLegendContentProps\n>(({ className, hideIcon = false, payload, verticalAlign = 'bottom', nameKey, ...props }, ref) => {\n  const { config } = useChart();\n  const safePayload: Payload<ValueType, NameType>[] = isNonEmptyArray(payload) ? payload as Payload<ValueType, NameType>[] : [];\n  if (!isNonEmptyArray(safePayload)) {\n    return;\n  }\n\n  return (\n    <div\n      ref={ref}\n      className={cn(\n        'flex items-center justify-center gap-4',\n        verticalAlign === 'top' ? 'pb-3' : 'pt-3',\n        className,\n      )}\n    >\n      {safePayload.map((item, idx) => (\n        <ChartLegendItem\n          key={item.dataKey ?? idx}\n          item={item}\n          idx={idx}\n          hideIcon={hideIcon}\n          nameKey={nameKey}\n          config={config}\n        />\n      ))}\n    </div>\n  );\n});\nChartLegendContent.displayName = 'ChartLegend';\n\nexport {\n  ChartContainer,\n  ChartTooltip,\n  ChartTooltipContent,\n  ChartLegend,\n  ChartLegendContent,\n  ChartStyle,\n};\n","usedDeprecatedRules":[]},{"filePath":"/app/components/ui/chart/QualityPieChart.tsx","messages":[{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type error typed assigned to a parameter of type `ArrayLike<unknown> | { [s: string]: unknown; }`.","line":35,"column":42,"nodeType":"Identifier","messageId":"unsafeArgument","endLine":35,"endColumn":56}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from 'react';\nimport { PieChart, Pie, Cell, Tooltip, ResponsiveContainer } from 'recharts';\nimport { QUALITY_COLORS } from '../dataQualityCharts';\nimport { CustomTooltip } from '../dataQualityCharts';\n\ninterface QualityPieChartProps {\n  readonly data: {\n    name: string;\n    value: number;\n    percentage: string;\n  }[];\n}\n\nexport function QualityPieChart({ data }: QualityPieChartProps) {\n  return (\n    <ResponsiveContainer width=\"100%\" height={300}>\n      <PieChart>\n        <Pie\n          data={data}\n          cx=\"50%\"\n          cy=\"50%\"\n          labelLine={false}\n          label={({\n            name,\n            percentage\n          }: {\n            name?: string;\n            percentage?: string;\n          }) => `${name ?? 'Unknown'}: ${percentage ?? '0'}%`}\n          outerRadius={80}\n          fill=\"#8884d8\"\n          dataKey=\"value\"\n        >\n          {data.map((entry, index) => {\n            const colors = Object.values(QUALITY_COLORS);\n            const fillColor = colors[index % colors.length];\n            return (\n              <Cell \n                key={`cell-${index}`} \n                fill={fillColor} \n              />\n            );\n          })}\n        </Pie>\n        <Tooltip content={<CustomTooltip />} />\n      </PieChart>\n    </ResponsiveContainer>\n  );\n}\n","usedDeprecatedRules":[]},{"filePath":"/app/components/ui/chart/TooltipIndicator.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/ui/chart/TooltipItemContent.tsx","messages":[{"ruleId":"max-params","severity":2,"message":"Function has too many parameters (5). Maximum allowed is 4.","line":5,"column":24,"nodeType":"TSFunctionType","messageId":"exceed","endLine":5,"endColumn":24}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from 'react';\nimport { cn } from '@/lib/utils';\n\ninterface TooltipItemContentProps {\n  readonly formatter?: (value: number, name: string, item: unknown, index: number, payload: Record<string, unknown>[]) => React.ReactNode;\n  readonly itemData: { name?: string; dataKey?: string; payload?: unknown; color?: string; value?: number };\n  readonly item: unknown;\n  readonly index: number;\n  readonly itemConfig?: { label?: React.ReactNode };\n  readonly nestLabel: boolean;\n  readonly tooltipLabel: React.ReactNode;\n}\n\nexport function TooltipItemContent({\n  formatter,\n  itemData,\n  item,\n  index,\n  itemConfig,\n  nestLabel,\n  tooltipLabel\n}: TooltipItemContentProps) {\n  if (formatter !== undefined && itemData?.value !== undefined && itemData.name !== undefined && itemData.name !== '') {\n    const payloadArray = Array.isArray(itemData.payload)\n      ? (itemData.payload as Record<string, unknown>[])\n      : [];\n    return <>{formatter(itemData.value, itemData.name, item, index, payloadArray)}</>;\n  }\n\n  return (\n    <div\n      className={cn(\n        'flex flex-1 justify-between leading-none',\n        nestLabel ? 'items-end' : 'items-center',\n      )}\n    >\n      <div className=\"grid gap-1.5\">\n        {nestLabel ? tooltipLabel : undefined}\n        <span className=\"text-muted-foreground\">\n          {itemConfig?.label ?? itemData.name}\n        </span>\n      </div>\n      {itemData.value !== undefined && itemData.value !== 0 && (\n        <span className=\"font-mono font-medium tabular-nums text-foreground\">\n          {itemData.value.toLocaleString()}\n        </span>\n      )}\n    </div>\n  );\n}\n","usedDeprecatedRules":[]},{"filePath":"/app/components/ui/chart/getPayloadConfigFromPayload.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/ui/chart/useTooltipLabel.tsx","messages":[{"ruleId":"unicorn/no-null","severity":1,"message":"Use `undefined` instead of `null`.","line":29,"column":14,"nodeType":"Literal","messageId":"error","endLine":29,"endColumn":18,"suggestions":[{"messageId":"remove","fix":{"range":[889,893],"text":""},"data":{},"desc":"Remove `null`."},{"messageId":"replace","fix":{"range":[889,893],"text":"undefined"},"data":{},"desc":"Replace `null` with `undefined`."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from 'react';\nimport { cn } from '@/lib/utils';\nimport { ChartConfig } from '../chart';\nimport { Payload, ValueType, NameType } from 'recharts/types/component/DefaultTooltipContent';\n\nimport { getPayloadConfigFromPayload } from './getPayloadConfigFromPayload';\n\ninterface UseTooltipLabelProps {\n  readonly hideLabel: boolean;\n  readonly payload: Payload<ValueType, NameType>[] | undefined;\n  readonly label: unknown;\n  readonly labelFormatter?: (value: unknown, payload: Payload<ValueType, NameType>[]) => React.ReactNode;\n  readonly labelClassName?: string;\n  readonly config: ChartConfig;\n  readonly labelKey?: string;\n}\n\nexport function useTooltipLabel({\n  hideLabel,\n  payload,\n  label,\n  labelFormatter,\n  labelClassName,\n  config,\n  labelKey\n}: UseTooltipLabelProps) {\n  return React.useMemo(() => {\n    if (hideLabel || !payload || payload.length === 0) {\n      return null; // Return null or an empty div if no label or payload\n    }\n\n    const [item] = payload;\n\n    const key = `${labelKey ?? (item as { dataKey?: string; name?: string }).dataKey ?? (item as { dataKey?: string; name?: string }).name ?? 'value'}`;\n    const itemConfig = getPayloadConfigFromPayload(config, item, key);\n    const value =\n      (labelKey === undefined && typeof label === 'string') ? config[label]?.label ?? label : itemConfig?.label;\n\n    if (labelFormatter) {\n      return (\n        <div className={cn('font-medium', labelClassName)}>{labelFormatter(value, payload)}</div>\n      );\n    }\n\n    if (value === undefined || value === null || value === '') {\n      \n    }\n\n    return <div className={cn('font-medium', labelClassName)}>{value}</div>;\n  }, [label, labelFormatter, payload, hideLabel, labelClassName, config, labelKey]);\n}\n","usedDeprecatedRules":[]},{"filePath":"/app/components/ui/checkbox.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/ui/collapsible.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/ui/command.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/ui/dataQualityCharts.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/ui/dialog.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/ui/drawer.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/ui/form.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/ui/input.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/ui/label.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/ui/menubar.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/ui/pagination.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/ui/popover.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/ui/progress.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/ui/resizable.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/ui/select.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/ui/separator.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/ui/sheet.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/ui/sidebar.tsx","messages":[{"ruleId":"@typescript-eslint/unbound-method","severity":2,"message":"Avoid referencing unbound methods which may cause unintentional scoping of `this`.\nIf your function does not access `this`, you can annotate it with `this: void`, or consider using an arrow function instead.","line":205,"column":12,"nodeType":"Identifier","messageId":"unboundWithoutThisAnnotation","endLine":205,"endColumn":24}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use client';\n\nimport * as React from 'react';\n// @ts-expect-error TS(2792): Cannot find module '@radix-ui/react-slot'. Did you... Remove this comment to see the full error message\nimport { Slot } from '@radix-ui/react-slot';\n// @ts-expect-error TS(2792): Cannot find module 'class-variance-authority'. Did... Remove this comment to see the full error message\nimport { VariantProps, cva } from 'class-variance-authority';\n// @ts-expect-error TS(2792): Cannot find module 'lucide-react'. Did you mean to... Remove this comment to see the full error message\nimport { PanelLeft } from 'lucide-react';\n\nimport { useIsMobile } from '@/hooks/UseMobile';\nimport { cn } from '@/lib/utils';\nimport { Button } from '@/components/ui/button';\nimport { Input } from '@/components/ui/input';\nimport { Separator } from '@/components/ui/separator';\nimport { Sheet, SheetContent } from '@/components/ui/sheet';\nimport { Skeleton } from '@/components/ui/skeleton';\nimport { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from '@/components/ui/tooltip';\nimport Cookies from 'js-cookie';\n\nconst SIDEBAR_COOKIE_NAME = 'sidebar:state';\nconst SIDEBAR_COOKIE_MAX_AGE = 60 * 60 * 24 * 7;\nconst SIDEBAR_WIDTH = '16rem';\nconst SIDEBAR_WIDTH_MOBILE = '18rem';\nconst SIDEBAR_WIDTH_ICON = '3rem';\nconst SIDEBAR_KEYBOARD_SHORTCUT = 'b';\n\ntype SidebarContext = {\n  state: 'expanded' | 'collapsed';\n  open: boolean;\n  setOpen: (open: boolean) => void;\n  openMobile: boolean;\n  setOpenMobile: (open: boolean) => void;\n  isMobile: boolean;\n  toggleSidebar: () => void;\n};\n\nconst SidebarContext = React.createContext<SidebarContext | undefined>(undefined);\n\nfunction useSidebar() {\n  const context = React.useContext(SidebarContext);\n  if (!context) {\n    throw new Error('useSidebar must be used within a SidebarProvider.');\n  }\n\n  return context;\n}\n\ninterface UseSidebarStateProps {\n  defaultOpen?: boolean;\n  open?: boolean;\n  onOpenChange?: (open: boolean) => void;\n}\n\nfunction useSidebarState({ defaultOpen = true, open: openProp, onOpenChange: setOpenProp }: UseSidebarStateProps) {\n  const isMobile = useIsMobile();\n  const [openMobile, setOpenMobile] = React.useState(false);\n  const [_open, _setOpen] = React.useState(defaultOpen);\n  const open = openProp ?? _open;\n\n  const setOpen = React.useCallback(\n    (value: boolean | ((currentOpen: boolean) => boolean)) => {\n      const openState = typeof value === 'function' ? value(open) : value;\n      if (setOpenProp) {\n        setOpenProp(openState);\n      } else {\n        _setOpen(openState);\n      }\n      Cookies.set(SIDEBAR_COOKIE_NAME, String(openState), {\n        path: '/',\n        expires: SIDEBAR_COOKIE_MAX_AGE / (60 * 60 * 24),\n      });\n    },\n    [setOpenProp, open, _setOpen],\n  );\n\n  const toggleSidebar = React.useCallback(() => {\n    if (isMobile) {\n      setOpenMobile((current) => !current);\n    } else {\n      setOpen((current) => !current);\n    }\n  }, [isMobile, setOpen, setOpenMobile]);\n\n  const state = open ? 'expanded' : 'collapsed';\n\n  return {\n    isMobile,\n    openMobile,\n    setOpenMobile,\n    open,\n    setOpen,\n    toggleSidebar,\n    state,\n  };\n}\n\nfunction useSidebarKeyboardShortcut(toggleSidebar: () => void) {\n  React.useEffect(() => {\n    const handleKeyDown = (event: KeyboardEvent) => {\n      if (event.key === SIDEBAR_KEYBOARD_SHORTCUT && (event.metaKey || event.ctrlKey)) {\n        event.preventDefault();\n        toggleSidebar();\n      }\n    };\n    globalThis.addEventListener('keydown', handleKeyDown);\n    return () => globalThis.removeEventListener('keydown', handleKeyDown);\n  }, [toggleSidebar]);\n}\n\nconst SidebarProvider = React.forwardRef<\n  HTMLDivElement,\n  React.ComponentProps<'div'> & UseSidebarStateProps\n>(\n  (\n    {\n      defaultOpen,\n      open: openProp,\n      onOpenChange: setOpenProp,\n      className,\n      style,\n      children,\n      ...props\n    },\n    ref,\n  ) => {\n    const {\n      isMobile,\n      openMobile,\n      setOpenMobile,\n      open,\n      setOpen,\n      toggleSidebar,\n      state,\n    } = useSidebarState({ defaultOpen, open: openProp, onOpenChange: setOpenProp });\n\n    useSidebarKeyboardShortcut(toggleSidebar);\n\n    const contextValue = React.useMemo<SidebarContext>(\n      () => ({\n        state,\n        open,\n        setOpen,\n        isMobile,\n        openMobile,\n        setOpenMobile,\n        toggleSidebar,\n      }),\n      [state, open, setOpen, isMobile, openMobile, setOpenMobile, toggleSidebar],\n    );\n\n    return (\n      <SidebarContext.Provider value={contextValue}>\n        <TooltipProvider delayDuration={0}>\n          <div\n            style={\n              {\n                '--sidebar-width': SIDEBAR_WIDTH,\n                '--sidebar-width-icon': SIDEBAR_WIDTH_ICON,\n                ...style,\n              } as React.CSSProperties\n            }\n            className={cn(\n              'group/sidebar-wrapper flex min-h-svh w-full has-[[data-variant=inset]]:bg-sidebar',\n              className,\n            )}\n            ref={ref}\n            {...props}\n          >\n            {children}\n          </div>\n        </TooltipProvider>\n      </SidebarContext.Provider>\n    );\n  },\n);\nSidebarProvider.displayName = 'SidebarProvider';\n\n// Extracted NonCollapsibleSidebar component\nconst NonCollapsibleSidebar = React.forwardRef<\n  HTMLDivElement,\n  React.ComponentProps<'div'>\n>(({ className, children, ...props }, ref) => (\n  <div\n    className={cn(\n      'flex h-full w-[--sidebar-width] flex-col bg-sidebar text-sidebar-foreground',\n      className,\n    )}\n    ref={ref}\n    {...props}\n  >\n    {children}\n  </div>\n));\nNonCollapsibleSidebar.displayName = 'NonCollapsibleSidebar';\n\n// Extracted MobileSidebarSheet component\ninterface MobileSidebarSheetProps extends React.ComponentProps<typeof Sheet> {\n  side?: 'left' | 'right';\n  children?: React.ReactNode;\n}\nconst MobileSidebarSheet = React.forwardRef<\n  HTMLDivElement, // Changed from React.ElementRef<typeof SheetContent>\n  MobileSidebarSheetProps\n>(({ open, onOpenChange, side, children, ...props }, ref) => ( // Added ref to SheetContent\n  <Sheet open={open} onOpenChange={onOpenChange} {...props}>\n    <SheetContent\n      ref={ref} // Apply ref here\n      data-sidebar=\"sidebar\"\n      data-mobile=\"true\"\n      className=\"w-[--sidebar-width] bg-sidebar p-0 text-sidebar-foreground [&>button]:hidden\"\n      style={\n        {\n          '--sidebar-width': SIDEBAR_WIDTH_MOBILE,\n        } as React.CSSProperties\n      }\n      side={side}\n    >\n      <div className=\"flex h-full w-full flex-col\">{children}</div>\n    </SheetContent>\n  </Sheet>\n));\nMobileSidebarSheet.displayName = 'MobileSidebarSheet';\n\n// Extracted DesktopCollapsibleSidebar component\ninterface DesktopCollapsibleSidebarProps extends React.ComponentProps<'div'> {\n  state: 'expanded' | 'collapsed';\n  collapsible: 'offcanvas' | 'icon';\n  variant: 'sidebar' | 'floating' | 'inset';\n  side: 'left' | 'right';\n  children?: React.ReactNode;\n}\nconst DesktopCollapsibleSidebar = React.forwardRef<\n  HTMLDivElement,\n  DesktopCollapsibleSidebarProps\n>(({ state, collapsible, variant, side, className, children, ...props }, ref) => (\n  <div\n    ref={ref}\n    className=\"group peer hidden md:block text-sidebar-foreground\"\n    data-state={state}\n    data-collapsible={state === 'collapsed' ? collapsible : ''}\n    data-variant={variant}\n    data-side={side}\n  >\n    <div\n      className={cn(\n        'duration-200 relative h-svh w-[--sidebar-width] bg-transparent transition-[width] ease-linear',\n        'group-data-[collapsible=offcanvas]:w-0',\n        'group-data-[side=right]:rotate-180',\n        variant === 'floating' || variant === 'inset'\n          ? 'group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)_+_theme(spacing.4))]'\n          : 'group-data-[collapsible=icon]:w-[--sidebar-width-icon]',\n      )}\n    />\n    <div\n      className={cn(\n        'duration-200 fixed inset-y-0 z-10 hidden h-svh w-[--sidebar-width] transition-[left,right,width] ease-linear md:flex',\n        side === 'left'\n          ? 'left-0 group-data-[collapsible=offcanvas]:left-[calc(var(--sidebar-width)*-1)]'\n          : 'right-0 group-data-[collapsible=offcanvas]:right-[calc(var(--sidebar-width)*-1)]',\n        variant === 'floating' || variant === 'inset'\n          ? 'p-2 group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)_+_theme(spacing.4)_+2px)]'\n          : 'group-data-[collapsible=icon]:w-[--sidebar-width-icon] group-data-[side=left]:border-r group-data-[side=right]:border-l',\n        className,\n      )}\n      {...props}\n    >\n      <div\n        data-sidebar=\"sidebar\"\n        className=\"flex h-full w-full flex-col bg-sidebar group-data-[variant=floating]:rounded-lg group-data-[variant=floating]:border group-data-[variant=floating]:border-sidebar-border group-data-[variant=floating]:shadow\"\n      >\n        {children}\n      </div>\n    </div>\n  </div>\n));\nDesktopCollapsibleSidebar.displayName = 'DesktopCollapsibleSidebar';\n\nconst Sidebar = React.forwardRef<\n  HTMLDivElement,\n  React.ComponentProps<'div'> & {\n    side?: 'left' | 'right';\n    variant?: 'sidebar' | 'floating' | 'inset';\n    collapsible?: 'offcanvas' | 'icon' | 'none';\n  }\n>(\n  (\n    {\n      side = 'left',\n      variant = 'sidebar',\n      collapsible = 'offcanvas',\n      className,\n      children,\n      ...props\n    },\n    ref,\n  ) => {\n    const { isMobile, state, openMobile, setOpenMobile } = useSidebar();\n\n    if (collapsible === 'none') {\n      return <NonCollapsibleSidebar ref={ref as React.Ref<HTMLDivElement>} className={className} {...props}>{children}</NonCollapsibleSidebar>;\n    }\n\n    if (isMobile) {\n      return <MobileSidebarSheet ref={ref as React.Ref<HTMLDivElement>} open={openMobile} onOpenChange={setOpenMobile} side={side} {...props}>{children}</MobileSidebarSheet>;\n    }\n\n    return <DesktopCollapsibleSidebar ref={ref} state={state} collapsible={collapsible} variant={variant} side={side} className={className} {...props}>{children}</DesktopCollapsibleSidebar>;\n  },\n);\nSidebar.displayName = 'Sidebar';\n\nconst SidebarTrigger = React.forwardRef<HTMLButtonElement, React.ComponentProps<typeof Button>>(\n  ({ className, onClick, ...props }, ref) => {\n    const { toggleSidebar } = useSidebar();\n\n    return (\n      <Button\n        ref={ref}\n        data-sidebar=\"trigger\"\n        // @ts-expect-error TS(2322): Type '{ children: Element[]; form?: string | undef... Remove this comment to see the full error message\n        variant=\"ghost\"\n        size=\"icon\"\n        className={cn('h-7 w-7', className)}\n        onClick={(event) => {\n          onClick?.(event);\n          toggleSidebar();\n        }}\n        {...props}\n      >\n        <PanelLeft />\n        <span className=\"sr-only\">Toggle Sidebar</span>\n      </Button>\n    );\n  },\n);\nSidebarTrigger.displayName = 'SidebarTrigger';\n\nconst SidebarRail = React.forwardRef<HTMLButtonElement, React.ComponentProps<'button'>>(\n  ({ className, ...props }, ref) => {\n    const { toggleSidebar } = useSidebar();\n\n    return (\n      <button\n        ref={ref}\n        data-sidebar=\"rail\"\n        aria-label=\"Toggle Sidebar\"\n        tabIndex={-1}\n        onClick={toggleSidebar}\n        title=\"Toggle Sidebar\"\n        className={cn(\n          'absolute inset-y-0 z-20 hidden w-4 -translate-x-1/2 transition-all ease-linear after:absolute after:inset-y-0 after:left-1/2 after:w-[2px] hover:after:bg-sidebar-border group-data-[side=left]:-right-4 group-data-[side=right]:left-0 sm:flex',\n          '[[data-side=left]_&]:cursor-w-resize [[data-side=right]_&]:cursor-e-resize',\n          '[[data-side=left][data-state=collapsed]_&]:cursor-e-resize [[data-side=right][data-state=collapsed]_&]:cursor-w-resize',\n          'group-data-[collapsible=offcanvas]:translate-x-0 group-data-[collapsible=offcanvas]:after:left-full group-data-[collapsible=offcanvas]:hover:bg-sidebar',\n          '[[data-side=left][data-collapsible=offcanvas]_&]:-right-2',\n          '[[data-side=right][data-collapsible=offcanvas]_&]:-left-2',\n          className,\n        )}\n        {...props}\n      />\n    );\n  },\n);\nSidebarRail.displayName = 'SidebarRail';\n\nconst SidebarInset = React.forwardRef<HTMLDivElement, React.ComponentProps<'main'>>(\n  ({ className, ...props }, ref) => {\n    return (\n      <main\n        ref={ref}\n        className={cn(\n          'relative flex min-h-svh flex-1 flex-col bg-background',\n          'peer-data-[variant=inset]:min-h-[calc(100svh-theme(spacing.4))] md:peer-data-[variant=inset]:m-2 md:peer-data-[state=collapsed]:peer-data-[variant=inset]:ml-2 md:peer-data-[variant=inset]:ml-0 md:peer-data-[variant=inset]:rounded-xl md:peer-data-[variant=inset]:shadow',\n          className,\n        )}\n        {...props}\n      />\n    );\n  },\n);\nSidebarInset.displayName = 'SidebarInset';\n\nconst SidebarInput = React.forwardRef<HTMLInputElement, React.ComponentProps<typeof Input>>(\n  ({ className, ...props }, ref) => {\n    return (\n      <Input\n        ref={ref}\n        data-sidebar=\"input\"\n        className={cn(\n          'h-8 w-full bg-background shadow-none focus-visible:ring-2 focus-visible:ring-sidebar-ring',\n          className,\n        )}\n        {...props}\n      />\n    );\n  },\n);\nSidebarInput.displayName = 'SidebarInput';\n\nconst SidebarHeader = React.forwardRef<HTMLDivElement, React.ComponentProps<'div'>>(\n  ({ className, ...props }, ref) => {\n    return (\n      <div\n        ref={ref}\n        data-sidebar=\"header\"\n        className={cn('flex flex-col gap-2 p-2', className)}\n        {...props}\n      />\n    );\n  },\n);\nSidebarHeader.displayName = 'SidebarHeader';\n\nconst SidebarFooter = React.forwardRef<HTMLDivElement, React.ComponentProps<'div'>>(\n  ({ className, ...props }, ref) => {\n    return (\n      <div\n        ref={ref}\n        data-sidebar=\"footer\"\n        className={cn('flex flex-col gap-2 p-2', className)}\n        {...props}\n      />\n    );\n  },\n);\nSidebarFooter.displayName = 'SidebarFooter';\n\nconst SidebarSeparator = React.forwardRef<HTMLDivElement, React.ComponentProps<typeof Separator>>(\n  ({ className, ...props }, ref) => (\n    <Separator\n      ref={ref}\n      data-sidebar=\"separator\"\n      className={cn('mx-2 w-auto bg-sidebar-border', className)}\n      {...props}\n    />\n  ),\n);\nSidebarSeparator.displayName = 'SidebarSeparator';\n\nconst SidebarContent = React.forwardRef<HTMLDivElement, React.ComponentProps<'div'>>(\n  ({ className, ...props }, ref) => {\n    return (\n      <div\n        ref={ref}\n        data-sidebar=\"content\"\n        className={cn(\n          'flex min-h-0 flex-1 flex-col gap-2 overflow-auto group-data-[collapsible=icon]:overflow-hidden',\n          className,\n        )}\n        {...props}\n      />\n    );\n  },\n);\nSidebarContent.displayName = 'SidebarContent';\n\nconst SidebarGroup = React.forwardRef<HTMLDivElement, React.ComponentProps<'div'>>(\n  ({ className, ...props }, ref) => {\n    return (\n      <div\n        ref={ref}\n        data-sidebar=\"group\"\n        className={cn('relative flex w-full min-w-0 flex-col p-2', className)}\n        {...props}\n      />\n    );\n  },\n);\nSidebarGroup.displayName = 'SidebarGroup';\n\nconst SidebarGroupLabel = React.forwardRef<\n  HTMLDivElement,\n  React.ComponentProps<'div'> & { asChild?: boolean }\n>(({ className, asChild = false, ...props }, ref) => {\n  const Comp = asChild ? Slot : 'div';\n\n  return (\n    <Comp\n      ref={ref}\n      data-sidebar=\"group-label\"\n      className={cn(\n        'duration-200 flex h-8 shrink-0 items-center rounded-md px-2 text-xs font-medium text-sidebar-foreground/70 outline-none ring-sidebar-ring transition-[margin,opa] ease-linear focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0',\n        'group-data-[collapsible=icon]:-mt-8 group-data-[collapsible=icon]:opacity-0',\n        className,\n      )}\n      {...props}\n    />\n  );\n});\nSidebarGroupLabel.displayName = 'SidebarGroupLabel';\n\nconst SidebarGroupAction = React.forwardRef<\n  HTMLButtonElement,\n  React.ComponentProps<'button'> & { asChild?: boolean }\n>(({ className, asChild = false, ...props }, ref) => {\n  const Comp = asChild ? Slot : 'button';\n\n  return (\n    <Comp\n      ref={ref}\n      data-sidebar=\"group-action\"\n      className={cn(\n        'absolute right-3 top-3.5 flex aspect-square w-5 items-center justify-center rounded-md p-0 text-sidebar-foreground outline-none ring-sidebar-ring transition-transform hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0',\n        // Increases the hit area of the button on mobile.\n        'after:absolute after:-inset-2 after:md:hidden',\n        'group-data-[collapsible=icon]:hidden',\n        className,\n      )}\n      {...props}\n    />\n  );\n});\nSidebarGroupAction.displayName = 'SidebarGroupAction';\n\nconst SidebarGroupContent = React.forwardRef<HTMLDivElement, React.ComponentProps<'div'>>(\n  ({ className, ...props }, ref) => (\n    <div\n      ref={ref}\n      data-sidebar=\"group-content\"\n      className={cn('w-full text-sm', className)}\n      {...props}\n    />\n  ),\n);\nSidebarGroupContent.displayName = 'SidebarGroupContent';\n\nconst SidebarMenu = React.forwardRef<HTMLUListElement, React.ComponentProps<'ul'>>(\n  ({ className, ...props }, ref) => (\n    <ul\n      ref={ref}\n      data-sidebar=\"menu\"\n      className={cn('flex w-full min-w-0 flex-col gap-1', className)}\n      {...props}\n    />\n  ),\n);\nSidebarMenu.displayName = 'SidebarMenu';\n\nconst SidebarMenuItem = React.forwardRef<HTMLLIElement, React.ComponentProps<'li'>>(\n  ({ className, ...props }, ref) => (\n    <li\n      ref={ref}\n      data-sidebar=\"menu-item\"\n      className={cn('group/menu-item relative', className)}\n      {...props}\n    />\n  ),\n);\nSidebarMenuItem.displayName = 'SidebarMenuItem';\n\nconst sidebarMenuButtonVariants = cva(\n  'peer/menu-button flex w-full items-center gap-2 overflow-hidden rounded-md p-2 text-left text-sm outline-none ring-sidebar-ring transition-[width,height,padding] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 group-has-[[data-sidebar=menu-action]]/menu-item:pr-8 aria-disabled:pointer-events-none aria-disabled:opacity-50 data-[active=true]:bg-sidebar-accent data-[active=true]:font-medium data-[active=true]:text-sidebar-accent-foreground data-[state=open]:hover:bg-sidebar-accent data-[state=open]:hover:text-sidebar-accent-foreground group-data-[collapsible=icon]:!size-8 group-data-[collapsible=icon]:!p-2 [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0',\n  {\n    variants: {\n      variant: {\n        default: 'hover:bg-sidebar-accent hover:text-sidebar-accent-foreground',\n        outline:\n          'bg-background shadow-[0_0_0_1px_hsl(var(--sidebar-border))] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground hover:shadow-[0_0_0_1px_hsl(var(--sidebar-accent))]',\n      },\n      size: {\n        default: 'h-8 text-sm',\n        sm: 'h-7 text-xs',\n        lg: 'h-12 text-sm group-data-[collapsible=icon]:!p-0',\n      },\n    },\n    defaultVariants: {\n      variant: 'default',\n      size: 'default',\n    },\n  },\n);\n\nconst SidebarMenuButton = React.forwardRef<\n  HTMLButtonElement,\n  React.ComponentProps<'button'> & {\n    asChild?: boolean;\n    isActive?: boolean;\n    tooltip?: string | React.ComponentProps<typeof TooltipContent>;\n  } & VariantProps<typeof sidebarMenuButtonVariants>\n>(\n  (\n    {\n      asChild = false,\n      isActive = false,\n      variant = 'default',\n      size = 'default',\n      tooltip,\n      className,\n      ...props\n    },\n    ref,\n  ) => {\n    const Comp = asChild ? Slot : 'button';\n    const { isMobile, state } = useSidebar();\n\n    const button = (\n      <Comp\n        ref={ref}\n        data-sidebar=\"menu-button\"\n        data-size={size}\n        data-active={isActive}\n        className={cn(sidebarMenuButtonVariants({ variant, size }), className)}\n        {...props}\n      />\n    );\n\n    if (tooltip == undefined) {\n      return button;\n    }\n\n    if (typeof tooltip === 'string') {\n      tooltip = {\n        children: tooltip,\n      };\n    }\n\n    return (\n      <Tooltip>\n        <TooltipTrigger asChild>{button}</TooltipTrigger>\n        <TooltipContent\n          side=\"right\"\n          align=\"center\"\n          hidden={state !== 'collapsed' || isMobile}\n          {...tooltip}\n        />\n      </Tooltip>\n    );\n  },\n);\nSidebarMenuButton.displayName = 'SidebarMenuButton';\n\nconst SidebarMenuAction = React.forwardRef<\n  HTMLButtonElement,\n  React.ComponentProps<'button'> & {\n    asChild?: boolean;\n    showOnHover?: boolean;\n  }\n>(({ className, asChild = false, showOnHover = false, ...props }, ref) => {\n  const Comp = asChild ? Slot : 'button';\n\n  return (\n    <Comp\n      ref={ref}\n      data-sidebar=\"menu-action\"\n      className={cn(\n        'absolute right-1 top-1.5 flex aspect-square w-5 items-center justify-center rounded-md p-0 text-sidebar-foreground outline-none ring-sidebar-ring transition-transform hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 peer-hover/menu-button:text-sidebar-accent-foreground [&>svg]:size-4 [&>svg]:shrink-0',\n        // Increases the hit area of the button on mobile.\n        'after:absolute after:-inset-2 after:md:hidden',\n        'peer-data-[size=sm]/menu-button:top-1',\n        'peer-data-[size=default]/menu-button:top-1.5',\n        'peer-data-[size=lg]/menu-button:top-2.5',\n        'group-data-[collapsible=icon]:hidden',\n        showOnHover &&\n          'group-focus-within/menu-item:opacity-100 group-hover/menu-item:opacity-100 data-[state=open]:opacity-100 peer-data-[active=true]/menu-button:text-sidebar-accent-foreground md:opacity-0',\n        className,\n      )}\n      {...props}\n    />\n  );\n});\nSidebarMenuAction.displayName = 'SidebarMenuAction';\n\nconst SidebarMenuBadge = React.forwardRef<HTMLDivElement, React.ComponentProps<'div'>>(\n  ({ className, ...props }, ref) => (\n    <div\n      ref={ref}\n      data-sidebar=\"menu-badge\"\n      className={cn(\n        'absolute right-1 flex h-5 min-w-5 items-center justify-center rounded-md px-1 text-xs font-medium tabular-nums text-sidebar-foreground select-none pointer-events-none',\n        'peer-hover/menu-button:text-sidebar-accent-foreground peer-data-[active=true]/menu-button:text-sidebar-accent-foreground',\n        'peer-data-[size=sm]/menu-button:top-1',\n        'peer-data-[size=default]/menu-button:top-1.5',\n        'peer-data-[size=lg]/menu-button:top-2.5',\n        'group-data-[collapsible=icon]:hidden',\n        className,\n      )}\n      {...props}\n    />\n  ),\n);\nSidebarMenuBadge.displayName = 'SidebarMenuBadge';\n\nconst SidebarMenuSkeleton = React.forwardRef<\n  HTMLDivElement,\n  React.ComponentProps<'div'> & {\n    showIcon?: boolean;\n  }\n>(({ className, showIcon = false, ...props }, ref) => {\n  // Predictable width between 50 to 90%.\n\n  const width = React.useMemo(() => {\n    // Use a more predictable approach for skeleton width to avoid pseudorandom warning\n    const widths = ['50%', '60%', '70%', '80%', '90%'];\n    const index = Math.floor(Date.now() / 1000) % widths.length;\n    return widths[index];\n  }, []);\n\n  return (\n    <div\n      ref={ref}\n      data-sidebar=\"menu-skeleton\"\n      className={cn('rounded-md h-8 flex gap-2 px-2 items-center', className)}\n      {...props}\n    >\n      {showIcon && <Skeleton className=\"size-4 rounded-md\" data-sidebar=\"menu-skeleton-icon\" />}\n      <Skeleton\n        className=\"h-4 flex-1 max-w-[--skeleton-width]\"\n        data-sidebar=\"menu-skeleton-text\"\n        style={\n          {\n            '--skeleton-width': width,\n          } as React.CSSProperties\n        }\n      />\n    </div>\n  );\n});\nSidebarMenuSkeleton.displayName = 'SidebarMenuSkeleton';\n\nconst SidebarMenuSub = React.forwardRef<HTMLUListElement, React.ComponentProps<'ul'>>(\n  ({ className, ...props }, ref) => (\n    <ul\n      ref={ref}\n      data-sidebar=\"menu-sub\"\n      className={cn(\n        'mx-3.5 flex min-w-0 translate-x-px flex-col gap-1 border-l border-sidebar-border px-2.5 py-0.5',\n        'group-data-[collapsible=icon]:hidden',\n        className,\n      )}\n      {...props}\n    />\n  ),\n);\nSidebarMenuSub.displayName = 'SidebarMenuSub';\n\nconst SidebarMenuSubItem = React.forwardRef<HTMLLIElement, React.ComponentProps<'li'>>(\n  ({ ...props }, ref) => <li ref={ref} {...props} />,\n);\nSidebarMenuSubItem.displayName = 'SidebarMenuSubItem';\n\nconst SidebarMenuSubButton = React.forwardRef<\n  HTMLAnchorElement,\n  React.ComponentProps<'a'> & {\n    asChild?: boolean;\n    size?: 'sm' | 'md';\n    isActive?: boolean;\n  }\n>(({ asChild = false, size = 'md', isActive, className, ...props }, ref) => {\n  const Comp = asChild ? Slot : 'a';\n\n  return (\n    <Comp\n      ref={ref}\n      data-sidebar=\"menu-sub-button\"\n      data-size={size}\n      data-active={isActive}\n      className={cn(\n        'flex h-7 min-w-0 -translate-x-px items-center gap-2 overflow-hidden rounded-md px-2 text-sidebar-foreground outline-none ring-sidebar-ring hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 aria-disabled:pointer-events-none aria-disabled:opacity-50 [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0 [&>svg]:text-sidebar-accent-foreground',\n        'data-[active=true]:bg-sidebar-accent data-[active=true]:text-sidebar-accent-foreground',\n        size === 'sm' && 'text-xs',\n        size === 'md' && 'text-sm',\n        'group-data-[collapsible=icon]:hidden',\n        className,\n      )}\n      {...props}\n    />\n  );\n});\nSidebarMenuSubButton.displayName = 'SidebarMenuSubButton';\n\nexport {\n  Sidebar,\n  SidebarContent,\n  SidebarFooter,\n  SidebarGroup,\n  SidebarGroupAction,\n  SidebarGroupContent,\n  SidebarGroupLabel,\n  SidebarHeader,\n  SidebarInput,\n  SidebarInset,\n  SidebarMenu,\n  SidebarMenuAction,\n  SidebarMenuBadge,\n  SidebarMenuButton,\n  SidebarMenuItem,\n  SidebarMenuSkeleton,\n  SidebarMenuSub,\n  SidebarMenuSubButton,\n  SidebarMenuSubItem,\n  SidebarProvider,\n  SidebarRail,\n  SidebarSeparator,\n  SidebarTrigger,\n  useSidebar,\n};\n","usedDeprecatedRules":[]},{"filePath":"/app/components/ui/skeleton.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/ui/slider.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/ui/sonner.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/ui/switch.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/ui/table.tsx","messages":[],"suppressedMessages":[{"ruleId":"sonarjs/table-header","severity":2,"message":"Add a valid header row or column to this \"<table>\".","line":9,"column":7,"nodeType":"JSXElement","endLine":9,"endColumn":96,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/ui/tabs.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/ui/textarea.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/ui/toast.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/ui/toaster.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/ui/toggle.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/components/ui/tooltip.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/hooks/UseMobile.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/hooks/UseToast.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/hooks/realtime/connectionManagementHelpers.ts","messages":[{"ruleId":"@typescript-eslint/no-unnecessary-type-assertion","severity":2,"message":"This assertion is unnecessary since it does not change the type of the expression.","line":23,"column":4,"nodeType":"TSAsExpression","messageId":"unnecessaryAssertion","endLine":23,"endColumn":48,"fix":{"range":[906,917],"text":""}}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":1,"fixableWarningCount":0,"source":"import { RealtimeEvent } from '../useRealtimeAdminEvents.types';\n\n// NOTE: React.MutableRefObject is flagged as deprecated by some linters, but is still the standard type for refs created by useRef in React 18+.\n// See: https://github.com/DefinitelyTyped/DefinitelyTyped/issues/66808\n\ninterface DisconnectEventSourceParams {\n  eventSourceRef: React.RefObject<EventSource | undefined>;\n  reconnectTimeoutRef: React.RefObject<NodeJS.Timeout | undefined>;\n  isManuallyDisconnectedRef: React.RefObject<boolean>;\n  setIsConnected: (connected: boolean) => void;\n  setIsConnecting: (connecting: boolean) => void;\n  setConnectionError: (error: string | undefined) => void;\n}\n\nexport function disconnectEventSource({\n  eventSourceRef,\n  reconnectTimeoutRef,\n  isManuallyDisconnectedRef,\n  setIsConnected,\n  setIsConnecting,\n  setConnectionError\n}: DisconnectEventSourceParams) {\n  (isManuallyDisconnectedRef.current as boolean) = true;\n\n  if (reconnectTimeoutRef.current) {\n    clearTimeout(reconnectTimeoutRef.current);\n    (reconnectTimeoutRef.current as NodeJS.Timeout | undefined) = undefined;\n  }\n\n  if (eventSourceRef.current) {\n    eventSourceRef.current.close();\n    (eventSourceRef.current as EventSource | undefined) = undefined;\n  }\n\n  setIsConnected(false);\n  setIsConnecting(false);\n  setConnectionError(undefined);\n}\n\nexport function clearRecentEvents(\n  setRecentEvents: (events: RealtimeEvent[]) => void\n) {\n  setRecentEvents([]);\n}\n","usedDeprecatedRules":[]},{"filePath":"/app/hooks/realtime/createEventSourceConnection.ts","messages":[],"suppressedMessages":[{"ruleId":"sonarjs/deprecation","severity":2,"message":"'MutableRefObject' is deprecated.","line":45,"column":36,"nodeType":null,"messageId":"deprecation","endLine":45,"endColumn":52,"suppressions":[{"kind":"directive","justification":"MutableRefObject is used intentionally here for mutable ref values."}]},{"ruleId":"sonarjs/deprecation","severity":2,"message":"'MutableRefObject' is deprecated.","line":68,"column":56,"nodeType":null,"messageId":"deprecation","endLine":68,"endColumn":72,"suppressions":[{"kind":"directive","justification":"MutableRefObject is used intentionally here for mutable ref values."}]},{"ruleId":"sonarjs/deprecation","severity":2,"message":"'MutableRefObject' is deprecated.","line":74,"column":25,"nodeType":null,"messageId":"deprecation","endLine":74,"endColumn":41,"suppressions":[{"kind":"directive","justification":"MutableRefObject is used intentionally here for mutable ref values."}]},{"ruleId":"sonarjs/deprecation","severity":2,"message":"'MutableRefObject' is deprecated.","line":77,"column":36,"nodeType":null,"messageId":"deprecation","endLine":77,"endColumn":52,"suppressions":[{"kind":"directive","justification":"MutableRefObject is used intentionally here for mutable ref values."}]},{"ruleId":"sonarjs/deprecation","severity":2,"message":"'MutableRefObject' is deprecated.","line":82,"column":30,"nodeType":null,"messageId":"deprecation","endLine":82,"endColumn":46,"suppressions":[{"kind":"directive","justification":"MutableRefObject is used intentionally here for mutable ref values."}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/hooks/realtime/setupEventSourceListeners.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":38,"column":11,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":38,"endColumn":56}],"suppressedMessages":[{"ruleId":"sonarjs/deprecation","severity":2,"message":"'MutableRefObject' is deprecated.","line":14,"column":36,"nodeType":null,"messageId":"deprecation","endLine":14,"endColumn":52,"suppressions":[{"kind":"directive","justification":"MutableRefObject is used intentionally here for mutable ref values."}]},{"ruleId":"sonarjs/deprecation","severity":2,"message":"'MutableRefObject' is deprecated.","line":16,"column":30,"nodeType":null,"messageId":"deprecation","endLine":16,"endColumn":46,"suppressions":[{"kind":"directive","justification":"MutableRefObject is used intentionally here for mutable ref values."}]},{"ruleId":"sonarjs/deprecation","severity":2,"message":"'MutableRefObject' is deprecated.","line":83,"column":36,"nodeType":null,"messageId":"deprecation","endLine":83,"endColumn":52,"suppressions":[{"kind":"directive","justification":"MutableRefObject is used intentionally here for mutable ref values."}]},{"ruleId":"sonarjs/deprecation","severity":2,"message":"'MutableRefObject' is deprecated.","line":88,"column":30,"nodeType":null,"messageId":"deprecation","endLine":88,"endColumn":46,"suppressions":[{"kind":"directive","justification":"MutableRefObject is used intentionally here for mutable ref values."}]}],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from 'react';\nimport { RealtimeEvent } from '../useRealtimeAdminEvents.types';\nimport { useConnectionState } from './useConnectionState';\n\ninterface ConnectionStateActions {\n  setIsConnected: (connected: boolean) => void;\n  setIsConnecting: (connecting: boolean) => void;\n  setConnectionError: (error: string | undefined) => void;\n  setConnectionAttempts: (attempts: number | ((prev: number) => number)) => void;\n}\n\ninterface EventSourceRefs {\n  // eslint-disable-next-line sonarjs/deprecation -- MutableRefObject is used intentionally here for mutable ref values.\n  isManuallyDisconnectedRef: React.MutableRefObject<boolean | null>;\n  // eslint-disable-next-line sonarjs/deprecation -- MutableRefObject is used intentionally here for mutable ref values.\n  reconnectTimeoutRef: React.MutableRefObject<NodeJS.Timeout | undefined | null>;\n}\n\ninterface ReconnectLogicParams extends EventSourceRefs {\n  connectionAttempts: number;\n  maxReconnectAttempts: number;\n  reconnectInterval: number;\n  connect: () => void;\n  setConnectionAttempts: (attempts: number | ((prev: number) => number)) => void;\n  setConnectionError: (error: string | undefined) => void;\n}\n\nconst handleOpen = (connectionState: ConnectionStateActions) => () => {\n  console.info('Real-time admin events connected');\n  connectionState.setIsConnected(true);\n  connectionState.setIsConnecting(false);\n  connectionState.setConnectionError(undefined);\n  connectionState.setConnectionAttempts(0);\n};\n\nconst handleMessage = (handleEvent: (event: RealtimeEvent) => void, setConnectionError: (error: string | undefined) => void) => (event: MessageEvent) => {\n  try {\n    const parsedData = JSON.parse(event.data as string);\n    // Add a basic check for type property, assuming it's a key indicator of RealtimeEvent\n    if (typeof parsedData === 'object' && parsedData !== null && 'type' in parsedData) {\n      const adminEvent: RealtimeEvent = parsedData as RealtimeEvent;\n      handleEvent(adminEvent);\n    } else {\n      console.error('Parsed event data does not match RealtimeEvent structure:', parsedData);\n      setConnectionError('Received malformed event data');\n    }\n  } catch (error) {\n    console.error('Error parsing event data:', error);\n    setConnectionError('Error parsing event data');\n  }\n};\n\nconst handleReconnectLogic = (refs: EventSourceRefs, reconnectParams: ReconnectLogicParams) => {\n  if (refs.isManuallyDisconnectedRef.current !== true && reconnectParams.connectionAttempts < reconnectParams.maxReconnectAttempts) {\n    reconnectParams.setConnectionAttempts((prev) => prev + 1);\n\n    if (refs.reconnectTimeoutRef.current !== undefined) { // Check if undefined before assigning\n      refs.reconnectTimeoutRef.current = setTimeout(() => {\n        if (refs.isManuallyDisconnectedRef.current !== true) {\n          reconnectParams.connect();\n        }\n      }, reconnectParams.reconnectInterval);\n    }\n  } else if (reconnectParams.connectionAttempts >= reconnectParams.maxReconnectAttempts) {\n    reconnectParams.setConnectionError('Max reconnection attempts reached');\n  }\n};\n\nconst handleError = (connectionState: ConnectionStateActions, refs: EventSourceRefs, reconnectParams: ReconnectLogicParams) => (error: Event) => {\n  console.error('Real-time admin events error:', error);\n  connectionState.setIsConnected(false);\n  connectionState.setIsConnecting(false);\n  connectionState.setConnectionError('Connection error occurred');\n\n  handleReconnectLogic(refs, reconnectParams);\n};\n\ninterface SetupEventSourceListenersParams {\n  eventSource: EventSource;\n  handleEvent: (event: RealtimeEvent) => void;\n  connectionState: ReturnType<typeof useConnectionState>;\n  // eslint-disable-next-line sonarjs/deprecation -- MutableRefObject is used intentionally here for mutable ref values.\n  isManuallyDisconnectedRef: React.MutableRefObject<boolean | null>;\n  connectionAttempts: number;\n  maxReconnectAttempts: number;\n  reconnectInterval: number;\n  // eslint-disable-next-line sonarjs/deprecation -- MutableRefObject is used intentionally here for mutable ref values.\n  reconnectTimeoutRef: React.MutableRefObject<NodeJS.Timeout | undefined | null>;\n  connect: () => void;\n}\n\nfunction createReconnectLogicParams(\n  params: Omit<SetupEventSourceListenersParams, 'eventSource' | 'handleEvent' | 'connectionState'>,\n  connectionState: ReturnType<typeof useConnectionState>\n): ReconnectLogicParams {\n  return {\n    ...params,\n    setConnectionAttempts: connectionState.setConnectionAttempts,\n    setConnectionError: connectionState.setConnectionError,\n  };\n}\n\nfunction addEventListeners(\n  eventSource: EventSource,\n  params: SetupEventSourceListenersParams,\n  connectionActions: ConnectionStateActions,\n  reconnectLogicParams: ReconnectLogicParams\n) {\n  const { handleEvent, isManuallyDisconnectedRef, reconnectTimeoutRef } = params;\n  const refs: EventSourceRefs = { isManuallyDisconnectedRef, reconnectTimeoutRef };\n\n  eventSource.addEventListener('open', handleOpen(connectionActions));\n  eventSource.addEventListener('message', handleMessage(handleEvent, connectionActions.setConnectionError));\n  eventSource.addEventListener('error', handleError(connectionActions, refs, reconnectLogicParams));\n}\n\nexport function setupEventSourceListeners(params: SetupEventSourceListenersParams) {\n  const { eventSource, connectionState } = params;\n  const { setIsConnected, setIsConnecting, setConnectionError, setConnectionAttempts } = connectionState;\n  const connectionActions: ConnectionStateActions = { setIsConnected, setIsConnecting, setConnectionError, setConnectionAttempts };\n  const reconnectLogicParams = createReconnectLogicParams(params, connectionState);\n\n  addEventListeners(eventSource, params, connectionActions, reconnectLogicParams);\n}\n","usedDeprecatedRules":[]},{"filePath":"/app/hooks/realtime/useAutoConnect.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/hooks/realtime/useConnectionManagement.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/hooks/realtime/useConnectionState.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/hooks/realtime/useEventHandlers.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/hooks/realtime/useRealtimeAdminEventsLogic.ts","messages":[{"ruleId":null,"message":"Unused eslint-disable directive (no problems were reported from 'max-lines-per-function').","line":35,"column":1,"severity":1,"nodeType":null,"fix":{"range":[967,1102],"text":" "}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import { useEffect, useRef } from 'react';\nimport { RealtimeEvent, RealtimeMetrics } from '../useRealtimeAdminEvents.types';\nimport { useConnectionState } from './useConnectionState';\nimport { useEventHandlers } from './useEventHandlers';\nimport { useConnectionManagement } from './useConnectionManagement';\nimport { useAutoConnect } from './useAutoConnect';\n\ninterface UseRealtimeAdminEventsOptions {\n  autoConnect?: boolean;\n  reconnectInterval?: number;\n  maxReconnectAttempts?: number;\n  eventFilter?: (event: RealtimeEvent) => boolean;\n}\n\ninterface UseRealtimeAdminEventsReturn {\n  // Connection state\n  isConnected: boolean;\n  isConnecting: boolean;\n  connectionError: string | undefined;\n  \n  // Data\n  latestMetrics: RealtimeMetrics | undefined;\n  recentEvents: RealtimeEvent[];\n  \n  // Controls\n  connect: () => void;\n  disconnect: () => void;\n  clearEvents: () => void;\n  \n  // Statistics\n  connectionAttempts: number;\n  lastEventTime: Date | undefined;\n}\n\n// eslint-disable-next-line max-lines-per-function -- This hook orchestrates multiple other hooks and manages their state/dependencies.\nexport function useRealtimeAdminEventsLogic(\n  options: UseRealtimeAdminEventsOptions = {}\n): UseRealtimeAdminEventsReturn {\n  const {\n    autoConnect = true,\n    reconnectInterval = 5000,\n    maxReconnectAttempts = 10,\n    eventFilter\n  } = options;\n\n  // State management\n  const connectionState = useConnectionState();\n  const {\n    isConnected,\n    isConnecting,\n    connectionError,\n    latestMetrics,\n    recentEvents,\n    connectionAttempts,\n    lastEventTime\n  } = connectionState;\n\n  // Refs\n  const eventSourceRef = useRef<EventSource | undefined>(undefined);\n  const reconnectTimeoutRef = useRef<NodeJS.Timeout | undefined>(undefined);\n  const isManuallyDisconnectedRef = useRef(false);\n\n  // Event handlers\n  const handleEvent = useEventHandlers(\n    eventFilter,\n    connectionState.setLastEventTime,\n    connectionState.setLatestMetrics,\n    connectionState.setRecentEvents\n  );\n\n  // Connection management\n  const { connect, disconnect, clearEvents } = useConnectionManagement(\n    eventSourceRef,\n    reconnectTimeoutRef,\n    isManuallyDisconnectedRef,\n    connectionState,\n    handleEvent,\n    connectionAttempts,\n    maxReconnectAttempts,\n    reconnectInterval,\n    isConnecting\n  );\n\n  // Auto-connect on mount\n  useAutoConnect(autoConnect, connect, disconnect);\n\n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      if (reconnectTimeoutRef.current) {\n        clearTimeout(reconnectTimeoutRef.current);\n      }\n      if (eventSourceRef.current) {\n        eventSourceRef.current.close();\n      }\n    };\n  }, []);\n\n  return {\n    // Connection state\n    isConnected,\n    isConnecting,\n    connectionError,\n    \n    // Data\n    latestMetrics,\n    recentEvents,\n    \n    // Controls\n    connect,\n    disconnect,\n    clearEvents,\n    \n    // Statistics\n    connectionAttempts,\n    lastEventTime\n  };\n}\n","usedDeprecatedRules":[]},{"filePath":"/app/hooks/useAdminAuth.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/hooks/useAuthHandlers.ts","messages":[{"ruleId":"react-hooks/exhaustive-deps","message":"Definition for rule 'react-hooks/exhaustive-deps' was not found.","line":61,"column":46,"endLine":61,"endColumn":97,"severity":2,"nodeType":null},{"ruleId":"react-hooks/exhaustive-deps","message":"Definition for rule 'react-hooks/exhaustive-deps' was not found.","line":85,"column":29,"endLine":85,"endColumn":79,"severity":2,"nodeType":null}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useState, useCallback } from 'react';\nimport { supabase } from '@/lib/supabase';\nimport { useRouter } from 'next/navigation';\n\ninterface UseAuthHandlersReturn {\n  handleEmailLogin: (e: React.FormEvent) => Promise<void>;\n  handleGoogleLogin: () => Promise<void>;\n  loading: boolean;\n  error: string | undefined;\n  email: string;\n  setEmail: (email: string) => void;\n  password: string;\n  setPassword: (password: string) => void;\n}\n\nexport function useAuthHandlers(redirectTo: string): UseAuthHandlersReturn {\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState<string | undefined>();\n  const [email, setEmail] = useState('');\n  const [password, setPassword] = useState('');\n  const router = useRouter();\n\n  const performEmailLogin = async (currentEmail: string, currentPassword: string) => {\n    const { error: signInError } = await supabase.auth.signInWithPassword({\n      email: currentEmail,\n      password: currentPassword,\n    });\n    if (signInError) throw signInError;\n\n    const { data: { user }, error: userError } = await supabase.auth.getUser();\n    if (userError) throw userError;\n\n    if (user) {\n      const { data: profile, error: profileError } = await supabase\n        .from('profiles')\n        .select('role')\n        .eq('id', user.id)\n        .single();\n      if (profileError) throw profileError;\n\n      if (profile?.role === 'admin') {\n        router.push(redirectTo);\n      } else {\n        router.push('/access-denied');\n      }\n    }\n  };\n\n  const handleEmailLogin = useCallback(async (e: React.FormEvent) => {\n    e.preventDefault();\n    setLoading(true);\n    setError(undefined);\n    try {\n      await performEmailLogin(email, password);\n    } catch (error_: unknown) {\n      console.error('Email login error:', error_);\n      setError(error_ instanceof Error ? error_.message : 'An error occurred during email login');\n    } finally {\n      setLoading(false);\n    }\n  }, [email, password, router, redirectTo]); // eslint-disable-line react-hooks/exhaustive-deps \n  // router, redirectTo are stable, email/password are dependencies for performEmailLogin call.\n\n  const performGoogleLogin = async () => {\n    const { error: signInError } = await supabase.auth.signInWithOAuth({\n      provider: 'google',\n      options: {\n        redirectTo: `${globalThis.location.origin}/auth/callback?redirectTo=${encodeURIComponent(redirectTo)}`,\n      },\n    });\n    if (signInError) throw signInError;\n  };\n\n  const handleGoogleLogin = useCallback(async () => {\n    setLoading(true);\n    setError(undefined);\n    try {\n      await performGoogleLogin();\n    } catch (error_: unknown) {\n      console.error('Google login error:', error_);\n      setError(error_ instanceof Error ? error_.message : 'An error occurred during Google login');\n    } finally {\n      setLoading(false);\n    }\n  }, [router, redirectTo]); // eslint-disable-line react-hooks/exhaustive-deps\n  // router, redirectTo are stable.\n\n  return {\n    handleEmailLogin,\n    handleGoogleLogin,\n    loading,\n    error,\n    email,\n    setEmail,\n    password,\n    setPassword,\n  };\n}\n","usedDeprecatedRules":[]},{"filePath":"/app/hooks/useDataCleanup.ts","messages":[{"ruleId":"unicorn/consistent-function-scoping","severity":2,"message":"Move async arrow function 'performLoadPreviewApiCall' to the outer scope.","line":69,"column":96,"nodeType":"ArrowFunctionExpression","messageId":"consistent-function-scoping","endLine":69,"endColumn":98}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use client';\n\nimport { useState } from 'react';\n\nexport interface CleanupOperation {\n  type: string;\n  description: string;\n  affectedCount: number;\n  successCount: number;\n  errorCount: number;\n  errors: string[];\n}\n\nexport interface CleanupResult {\n  totalProcessed: number;\n  operations: CleanupOperation[];\n  summary: {\n    trucksImproved: number;\n    duplicatesRemoved: number;\n    qualityScoreImprovement: number;\n    placeholdersRemoved: number;\n  };\n  duration: number;\n}\n\nexport function useDataCleanup() {\n  const [isRunning, setIsRunning] = useState(false);\n  const [lastResult, setLastResult] = useState<CleanupResult | undefined>();\n  const [previewData, setPreviewData] = useState<unknown>();\n  const [selectedOperations, setSelectedOperations] = useState<string[]>([\n    'remove_placeholders',\n    'normalize_phone',\n    'fix_coordinates',\n    'update_quality_scores'\n  ]);\n\n  const performCleanupApiCall = async (dryRun: boolean, operations: string[]): Promise<{ success: boolean; result?: CleanupResult; error?: string }> => {\n    const response = await fetch('/api/admin/data-cleanup', {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({\n        action: dryRun ? 'dry-run' : 'full-cleanup',\n        options: {\n          operations: operations,\n          batchSize: 50,\n          dryRun\n        }\n      })\n    });\n    return response.json() as Promise<{ success: boolean; result?: CleanupResult; error?: string }>;\n  };\n\n  const runCleanup = async (dryRun: boolean = false) => {\n    setIsRunning(true);\n    try {\n      const data = await performCleanupApiCall(dryRun, selectedOperations);\n      if (data.success === true) {\n        setLastResult(data.result);\n      } else {\n        console.error('Cleanup failed:', data.error);\n      }\n    } catch (error) {\n      console.error('Error running cleanup:', error);\n    } finally {\n      setIsRunning(false);\n    }\n  };\n\n  const performLoadPreviewApiCall = async (): Promise<{ success: boolean; preview?: unknown }> => {\n    const response = await fetch('/api/admin/data-cleanup?action=preview');\n    return response.json() as Promise<{ success: boolean; preview?: unknown }>;\n  };\n\n  const loadPreview = async () => {\n    try {\n      const data = await performLoadPreviewApiCall();\n      if (data.success === true) {\n        setPreviewData(data.preview);\n      } else {\n        // It's good practice to also handle the case where data.success is false from the API\n        console.error('Failed to load preview data:', (data as { error?: string }).error);\n      }\n    } catch (error) {\n      console.error('Error loading preview:', error);\n    }\n  };\n\n  const toggleOperation = (operation: string) => {\n    setSelectedOperations(prev => \n      prev.includes(operation)\n        ? prev.filter(op => op !== operation)\n        : [...prev, operation]\n    );\n  };\n\n  return {\n    isRunning,\n    lastResult,\n    previewData,\n    selectedOperations,\n    runCleanup,\n    loadPreview,\n    toggleOperation\n  };\n}\n","usedDeprecatedRules":[]},{"filePath":"/app/hooks/useFoodTruckDetails.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/hooks/useFoodTruckFinder.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/hooks/useRealtimeAdminEvents.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/hooks/useRealtimeAdminEvents.types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/hooks/useRealtimeAdminEventsHelpers.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/hooks/useSearchFiltersLogic.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/hooks/useSidebarKeyboardShortcut.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/hooks/useSystemAlerts.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/hooks/useSystemAlertsLogic.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/hooks/useTruckCard.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/lib/ScraperEngine.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":640,"column":13,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":640,"endColumn":74},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":678,"column":13,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":678,"endColumn":70},{"ruleId":"sonarjs/no-redundant-optional","severity":2,"message":"Consider removing 'undefined' type or '?' specifier, one of them is redundant.","line":699,"column":30,"nodeType":null,"endLine":699,"endColumn":31,"suggestions":[{"desc":"Remove \"?\" operator","fix":{"range":[22281,22282],"text":""}},{"desc":"Remove \"undefined\" type annotation","fix":{"range":[22284,22302],"text":"number"}}]},{"ruleId":"sonarjs/no-redundant-optional","severity":2,"message":"Consider removing 'undefined' type or '?' specifier, one of them is redundant.","line":702,"column":30,"nodeType":null,"endLine":702,"endColumn":31,"suggestions":[{"desc":"Remove \"?\" operator","fix":{"range":[22409,22410],"text":""}},{"desc":"Remove \"undefined\" type annotation","fix":{"range":[22412,22430],"text":"number"}}]},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":735,"column":13,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":735,"endColumn":42},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":770,"column":13,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":770,"endColumn":42}],"suppressedMessages":[{"ruleId":"sonarjs/pseudo-random","severity":2,"message":"Make sure that using this pseudorandom number generator is safe here.","line":319,"column":24,"nodeType":"CallExpression","messageId":"safeGenerator","endLine":319,"endColumn":37,"suppressions":[{"kind":"directive","justification":"Math.random is acceptable for non-security-critical user agent selection."}]},{"ruleId":"sonarjs/pseudo-random","severity":2,"message":"Make sure that using this pseudorandom number generator is safe here.","line":335,"column":29,"nodeType":"CallExpression","messageId":"safeGenerator","endLine":335,"endColumn":42,"suppressions":[{"kind":"directive","justification":"Math.random is acceptable for non-security-critical random delays."}]}],"errorCount":6,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { firecrawl } from './firecrawl'; // Import the firecrawl singleton\nimport * as crypto from 'node:crypto'; // Node.js crypto for secure randomness\n\ninterface InstagramPost {\n  id: string;\n  caption: string;\n  timestamp: string;\n  location: string;\n  hashtags: string[];\n  engagement: { likes: number; comments: number };\n}\n\ninterface InstagramProfile {\n  followers: number;\n  following: number;\n  posts_count: number;\n  bio: string;\n  contact_info: { email: string; phone: string };\n}\n\ninterface FacebookPost {\n  id: string;\n  content: string;\n  timestamp: string;\n  reactions: { likes: number; loves: number; shares: number };\n  comments: number;\n}\n\ninterface FacebookPageInfo {\n  likes: number;\n  followers: number;\n  check_ins: number;\n  about: string;\n  hours: Record<string, string>;\n}\n\ninterface TwitterTweet {\n  id: string;\n  text: string;\n  timestamp: string;\n  retweets: number;\n  likes: number;\n  replies: number;\n  location: string;\n}\n\ninterface TwitterProfile {\n  followers: number;\n  following: number;\n  tweets_count: number;\n  bio: string;\n  location: string;\n  website: string;\n}\n\ninterface InstagramData {\n  posts: InstagramPost[];\n  profile: InstagramProfile;\n}\n\ninterface FacebookData {\n  posts: FacebookPost[];\n  page_info: FacebookPageInfo;\n}\n\ninterface TwitterData {\n  tweets: TwitterTweet[];\n  profile: TwitterProfile;\n}\n\nexport interface WebsiteScrapeData {\n  markdown?: string;\n  html?: string;\n  metadata?: Record<string, unknown>;\n  is_fallback?: boolean;\n}\n\nexport interface ExtractedHTMLData {\n  name?: string;\n  location?: string;\n  phone?: string;\n  hours?: string;\n  menu?: { item: string; price: string }[];\n}\n\ninterface ScrapeResult {\n  success: boolean;\n  error?: string;\n  data?: InstagramData | FacebookData | TwitterData | WebsiteScrapeData | ExtractedHTMLData;\n  timestamp: string;\n  source: string;\n  note?: string;\n}\n\n// Core scraping engine with anti-detection measures\nexport class ScraperEngine {\n  private userAgents: string[];\n  private requestDelay: number;\n  private maxRetries: number;\n\n  constructor() {\n    this.userAgents = [\n      'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',\n      'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',\n      'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',\n    ];\n    this.requestDelay = 2000;\n    this.maxRetries = 3;\n  }\n\n  private async performFallbackScrape(url: string): Promise<ScrapeResult> {\n    try {\n      const response = await fetch(url, { headers: { 'User-Agent': this.getRandomUserAgent() } });\n      if (!response.ok) {\n        throw new Error(\n          `HTTP error ${response.status}: ${response.statusText} during fallback fetch.`,\n        );\n      }\n      const htmlContent = await response.text();\n      return {\n        success: true,\n        data: {\n          html: htmlContent,\n          is_fallback: true,\n        },\n        timestamp: new Date().toISOString(),\n        source: url,\n        note: 'Fetched using basic fetch as Firecrawl failed.',\n      };\n    } catch (fallbackError) {\n      const errMsg = fallbackError instanceof Error ? fallbackError.message : 'Unknown fallback fetch error';\n      console.warn(`Fallback fetch error for ${url}:`, errMsg);\n      return {\n        success: false,\n        error: \"That didn't work, please try again later.\",\n        timestamp: new Date().toISOString(),\n        source: url,\n      };\n    }\n  }\n\n  async scrapeWebsite(url: string, _selectors?: Record<string, string>): Promise<ScrapeResult> {\n    try {\n      const firecrawlResult = await firecrawl.scrapeUrl(url, {\n        formats: ['markdown', 'html'],\n        onlyMainContent: true,\n      });\n\n      if (firecrawlResult.success !== true || firecrawlResult.data == undefined) {\n        throw new Error(firecrawlResult.error ?? 'Firecrawl scraping failed to return data.');\n      }\n\n      const returnedData: WebsiteScrapeData = {};\n      if (typeof firecrawlResult.data.markdown === 'string' && firecrawlResult.data.markdown !== '') {\n        returnedData.markdown = firecrawlResult.data.markdown;\n      }\n      if (typeof firecrawlResult.data.html === 'string' && firecrawlResult.data.html !== '') {\n        returnedData.html = firecrawlResult.data.html;\n      }\n      if (firecrawlResult.data.metadata != undefined && typeof firecrawlResult.data.metadata === 'object') {\n        returnedData.metadata = firecrawlResult.data.metadata;\n      }\n\n      if (\n        (returnedData.markdown == undefined || returnedData.markdown === '') &&\n        (returnedData.html == undefined || returnedData.html === '')\n      ) {\n        throw new Error('Firecrawl returned no markdown or HTML content.');\n      }\n\n      return {\n        success: true,\n        data: returnedData,\n        timestamp: new Date().toISOString(),\n        source: url,\n      };\n    } catch (error: unknown) {\n      console.warn(`Scraping error for ${url} using Firecrawl:`, error);\n      console.info(`Falling back to basic fetch for ${url}`);\n      return await this.performFallbackScrape(url);\n    }\n  }\n\n  async scrapeSocialMedia(platform: string, handle: string): Promise<ScrapeResult> {\n    try {\n      await this.randomDelay();\n\n      switch (platform) {\n        case 'instagram': {\n          return await this.scrapeInstagram(handle);\n        }\n        case 'facebook': {\n          return await this.scrapeFacebook(handle);\n        }\n        case 'twitter': {\n          return await this.scrapeTwitter(handle);\n        }\n        default: {\n          throw new Error(`Unsupported platform: ${platform}`);\n        }\n      }\n    } catch (error) {\n      console.warn(`Social media scraping error for ${platform}/${handle}:`, error);\n      return {\n        success: false,\n        error: \"That didn't work, please try again later.\",\n        timestamp: new Date().toISOString(),\n        source: `social_media:${platform}:${handle}`,\n      };\n    }\n  }\n\n  private async scrapeInstagram(handle: string): Promise<ScrapeResult> {\n    await this.randomDelay();\n    const posts: InstagramPost[] = [\n      {\n        id: 'post_001',\n        caption: 'Fresh tacos available now at Mission St! 🌮 #foodtruck #tacos',\n        timestamp: new Date(Date.now() - 3_600_000).toISOString(),\n        location: 'Mission St, San Francisco',\n        hashtags: ['foodtruck', 'tacos', 'fresh'],\n        engagement: { likes: 45, comments: 8 },\n      },\n    ];\n    const profile: InstagramProfile = {\n      followers: 1250,\n      following: 340,\n      posts_count: 156,\n      bio: 'Best tacos in SF 🌮 Follow for daily locations!',\n      contact_info: {\n        email: 'contact@tacoparadise.com',\n        phone: '+1-555-0456',\n      },\n    };\n    return {\n      success: true,\n      data: { posts, profile },\n      timestamp: new Date().toISOString(),\n      source: `instagram:${handle}`,\n    };\n  }\n\n  private async scrapeFacebook(handle: string): Promise<ScrapeResult> {\n    await this.randomDelay();\n    const posts: FacebookPost[] = [\n      {\n        id: 'fb_post_001',\n        content:\n          \"Today we'll be at Union Square from 11 AM to 3 PM! Come try our new BBQ burger!\",\n        timestamp: new Date(Date.now() - 7_200_000).toISOString(),\n        reactions: { likes: 23, loves: 5, shares: 3 },\n        comments: 12,\n      },\n    ];\n    const page_info: FacebookPageInfo = {\n      likes: 890,\n      followers: 1100,\n      check_ins: 450,\n      about: 'Gourmet food truck serving the Bay Area',\n      hours: {\n        monday: '11:00-15:00',\n        tuesday: '11:00-15:00',\n        wednesday: '11:00-15:00',\n        thursday: '11:00-15:00',\n        friday: '11:00-20:00',\n        saturday: '12:00-20:00',\n        sunday: '12:00-16:00',\n      },\n    };\n    return {\n      success: true,\n      data: { posts, page_info },\n      timestamp: new Date().toISOString(),\n      source: `facebook:${handle}`,\n    };\n  }\n\n  private async scrapeTwitter(handle: string): Promise<ScrapeResult> {\n    await this.randomDelay();\n    const tweets: TwitterTweet[] = [\n      {\n        id: 'tweet_001',\n        text: 'LIVE at Dolores Park! Fresh burritos and quesadillas available now 🌯',\n        timestamp: new Date(Date.now() - 1_800_000).toISOString(),\n        retweets: 8,\n        likes: 34,\n        replies: 5,\n        location: 'Dolores Park, San Francisco',\n      },\n    ];\n    const profile: TwitterProfile = {\n      followers: 2340,\n      following: 567,\n      tweets_count: 1890,\n      bio: '🚚 SF Food Truck | Fresh Mexican Food | Follow for locations',\n      location: 'San Francisco, CA',\n      website: 'https://tacoparadise.com',\n    };\n    return {\n      success: true,\n      data: { tweets, profile },\n      timestamp: new Date().toISOString(),\n      source: `twitter:${handle}`,\n    };\n  }\n\n  private getRandomUserAgent(): string {\n    // Use Node.js crypto for stronger randomness if available, fallback to Math.random otherwise.\n    let idx: number;\n    if (globalThis.window?.crypto?.getRandomValues != undefined) {\n      const array = globalThis.window.crypto.getRandomValues(new Uint32Array(1));\n      idx = array[0] % this.userAgents.length;\n    } else if (typeof crypto.randomInt === 'function') {\n      idx = crypto.randomInt(0, this.userAgents.length);\n    } else {\n      // Fallback to Math.random for environments where crypto is not available.\n      // This is acceptable for non-security-critical random number generation like user agent selection.\n      // eslint-disable-next-line sonarjs/pseudo-random -- Math.random is acceptable for non-security-critical user agent selection.\n      idx = Math.floor(Math.random() * this.userAgents.length);\n    }\n    return this.userAgents[idx];\n  }\n\n  private randomDelay(): Promise<void> {\n    let randomMs: number;\n    if (globalThis.window?.crypto?.getRandomValues != undefined) {\n      const array = globalThis.window.crypto.getRandomValues(new Uint32Array(1));\n      randomMs = array[0] % 1000;\n    } else if (typeof crypto.randomInt === 'function') {\n      randomMs = crypto.randomInt(0, 1000);\n    } else {\n      // Fallback to Math.random for environments where crypto is not available.\n      // This is acceptable for non-security-critical random delays.\n      // eslint-disable-next-line sonarjs/pseudo-random -- Math.random is acceptable for non-security-critical random delays.\n      randomMs = Math.floor(Math.random() * 1000);\n    }\n    const delay = this.requestDelay + randomMs;\n    return new Promise((resolve) => setTimeout(resolve, delay));\n  }\n\n   handleRateLimit(retryAfter: number): Promise<void> {\n    console.info(`Rate limited. Waiting ${retryAfter} seconds before retry...`);\n    return new Promise((resolve) => setTimeout(resolve, retryAfter * 1000));\n  }\n\n  async retryWithBackoff<T>(\n    operation: () => Promise<T>,\n    maxRetries: number = this.maxRetries,\n  ): Promise<T> {\n    let lastError: unknown;\n\n    for (let attempt = 1; attempt <= maxRetries; attempt++) {\n      try {\n        return await operation();\n      } catch (error: unknown) {\n        lastError = error;\n        if (attempt === maxRetries) {\n          throw lastError instanceof Error ? lastError : new Error(String(lastError));\n        }\n\n        const backoffDelay = Math.pow(2, attempt) * 1000;\n        console.info(`Attempt ${attempt} failed. Retrying in ${backoffDelay}ms...`);\n        await new Promise((resolve) => setTimeout(resolve, backoffDelay));\n      }\n    }\n\n    throw lastError instanceof Error ? lastError : new Error('Request failed after all retries');\n  }\n}\n\ninterface LocationData {\n  current?: {\n    lat: number | undefined;\n    lng: number | undefined;\n    address?: string;\n  };\n}\n\ninterface ContactInfo {\n  phone?: string;\n  email?: string;\n}\n\ninterface OperatingHours {\n  [key: string]: {\n    open: string;\n    close: string;\n    closed: boolean;\n  };\n}\n\ninterface MenuItem {\n  name: string;\n  description?: string;\n  price: number;\n  dietary_tags?: string[];\n}\n\ninterface MenuCategory {\n  category: string;\n  items: MenuItem[];\n}\n\ninterface TruckData {\n  name: string;\n  location: LocationData;\n  contact?: ContactInfo;\n  operating_hours?: OperatingHours;\n  menu?: MenuCategory[];\n  last_updated?: string;\n}\n\nexport class DataQualityAssessor {\n  private assessBasicInfo(truckData: TruckData, issues: string[], score: number): number {\n    if (truckData.name == undefined || truckData.name.trim().length === 0) {\n      issues.push('Missing or empty truck name');\n      score -= 20;\n    }\n    return score;\n  }\n\n  private assessLocationInfo(truckData: TruckData, issues: string[], score: number): number {\n    if (truckData.location?.current == undefined) {\n      issues.push('Missing current location data');\n      score -= 25;\n    } else {\n      if (\n        truckData.location.current.lat == undefined || \n        truckData.location.current.lng == undefined\n      ) {\n        issues.push('Missing GPS coordinates');\n        score -= 15;\n      }\n      if (truckData.location.current.address == undefined || truckData.location.current.address === '') {\n        issues.push('Missing address information');\n        score -= 10;\n      }\n    }\n    return score;\n  }\n\n  private assessContactInfo(truckData: TruckData, issues: string[], score: number): number {\n    if (truckData.contact) {\n      const hasPhone = typeof truckData.contact.phone === 'string' && truckData.contact.phone.trim() !== '';\n      const hasEmail = typeof truckData.contact.email === 'string' && truckData.contact.email.trim() !== '';\n\n      if (!hasPhone && !hasEmail) {\n        issues.push('No phone or email contact available');\n        score -= 15;\n      }\n      if (hasPhone && !this.isValidPhone(truckData.contact.phone as string)) {\n        issues.push('Invalid phone number format');\n        score -= 5;\n      }\n      if (hasEmail && !this.isValidEmail(truckData.contact.email as string)) {\n        issues.push('Invalid email format');\n        score -= 5;\n      }\n    } else {\n      issues.push('Missing contact information');\n      score -= 20;\n    }\n    return score;\n  }\n\n  private assessOperatingHours(truckData: TruckData, issues: string[], score: number): number {\n    if (truckData.operating_hours == undefined || Object.keys(truckData.operating_hours).length === 0) {\n      issues.push('Missing operating hours');\n      score -= 15;\n    }\n    return score;\n  }\n\n  private assessMenuInfo(truckData: TruckData, issues: string[], score: number): number {\n    if (truckData.menu == undefined || truckData.menu.length === 0) {\n      issues.push('Missing menu information');\n      score -= 10;\n    } else {\n      const menuIssues = this.validateMenuData(truckData.menu);\n      issues.push(...menuIssues);\n      score -= menuIssues.length * 2;\n    }\n    return score;\n  }\n\n  private assessLastUpdated(truckData: TruckData, issues: string[], score: number): number {\n    if (truckData.last_updated != undefined && truckData.last_updated !== '') {\n      const lastUpdate = new Date(truckData.last_updated);\n      const daysSinceUpdate = (Date.now() - lastUpdate.getTime()) / (1000 * 60 * 60 * 24);\n\n      if (daysSinceUpdate > 7) {\n        issues.push('Data is more than 7 days old');\n        score -= 10;\n      } else if (daysSinceUpdate > 3) {\n        issues.push('Data is more than 3 days old');\n        score -= 5;\n      }\n    }\n    return score;\n  }\n\n  assessTruckData(truckData: TruckData): { score: number; issues: string[] } {\n    const issues: string[] = [];\n    let score = 100;\n\n    score = this.assessBasicInfo(truckData, issues, score);\n    score = this.assessLocationInfo(truckData, issues, score);\n    score = this.assessContactInfo(truckData, issues, score);\n    score = this.assessOperatingHours(truckData, issues, score);\n    score = this.assessMenuInfo(truckData, issues, score);\n    score = this.assessLastUpdated(truckData, issues, score);\n\n    return {\n      score: Math.max(0, score) / 100,\n      issues,\n    };\n  }\n\n  private validateMenuCategory(category: MenuCategory, categoryIndex: number, issues: string[]): void {\n    if (category.category == undefined || category.category.trim().length === 0) {\n      issues.push(`Menu category ${categoryIndex + 1} missing name`);\n    }\n  }\n\n  private validateMenuItems(category: MenuCategory, issues: string[]): void {\n    if (category.items == undefined || category.items.length === 0) {\n      issues.push(`Menu category \"${category.category ?? 'Unknown'}\" has no items`);\n    } else {\n      for (const [itemIndex, item] of category.items.entries()) {\n        if (item.name == undefined || item.name.trim().length === 0) {\n          issues.push(`Menu item ${itemIndex + 1} in \"${category.category ?? 'Unknown'}\" missing name`);\n        }\n        if (typeof item.price !== 'number' || item.price <= 0) {\n          issues.push(`Menu item \"${item.name ?? 'Unknown'}\" has invalid price`);\n        }\n      }\n    }\n  }\n\n  private validateMenuData(menu: MenuCategory[]): string[] {\n    const issues: string[] = [];\n\n    for (const [categoryIndex, category] of menu.entries()) {\n      this.validateMenuCategory(category, categoryIndex, issues);\n      this.validateMenuItems(category, issues);\n    }\n\n    return issues;\n  }\n  private isValidPhone(phone: string): boolean {\n    // Regex for phone number validation. Not vulnerable to super-linear runtime due to backtracking.\n    // Accepts +, digits, spaces, dashes, and parentheses. At least 10 digits.\n    const phoneRegex = /^\\+?[\\d\\s\\-()]{10,}$/;\n    return phoneRegex.test(phone);\n  }\n  private isValidEmail(email: string): boolean {\n    // Regex for email validation optimized to avoid backtracking\n    const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[a-zA-Z]{2,}$/;\n    return emailRegex.test(email);\n  }\n}\n\ninterface GeminiLocationData {\n  address: string;\n  city: string;\n  state: string;\n  coordinates: {\n    lat?: number;\n    lng?: number;\n  };\n  confidence: number;\n}\n\ninterface GeminiOperatingHours {\n  monday: { open: string; close: string; closed: boolean };\n  tuesday: { open: string; close: string; closed: boolean };\n  wednesday: { open: string; close: string; closed: boolean };\n  thursday: { open: string; close: string; closed: boolean };\n  friday: { open: string; close: string; closed: boolean };\n  saturday: { open: string; close: string; closed: boolean };\n  sunday: { open: string; close: string; closed: boolean };\n}\n\ninterface GeminiSentimentAnalysis {\n  sentiment: 'positive' | 'negative' | 'neutral';\n  score: number;\n  key_topics: string[];\n  summary: string;\n}\n\nexport class GeminiDataProcessor {\n  private _apiKey: string;\n  private _baseUrl: string;\n  private requestCount: number;\n  private tokenCount: number;\n  private dailyLimit: { requests: number; tokens: number };\n\n  constructor(apiKey: string) {\n    this._apiKey = apiKey;\n    this._baseUrl = 'https://generativelanguage.googleapis.com/v1beta';\n    this.requestCount = 0;\n    this.tokenCount = 0;\n    this.dailyLimit = { requests: 1500, tokens: 32_000 };\n  }\n  async processMenuData(rawMenuText: string): Promise<{ categories: MenuCategory[] }> {\n    if (!this.canMakeRequest()) {\n      throw new Error('Gemini API rate limit exceeded');\n    }\n\n    try {\n      const prompt = `\n        Parse the following food truck menu text and return a structured JSON format:\n        \n        ${rawMenuText}\n        \n        Return format:\n        {\n          \"categories\": [\n            {\n              \"name\": \"category_name\",\n              \"items\": [\n                {\n                  \"name\": \"item_name\",\n                  \"description\": \"item_description\",\n                  \"price\": 0.00,\n                  \"dietary_tags\": [\"vegetarian\", \"vegan\", \"gluten-free\", etc.]\n                }\n              ]\n            }\n          ]\n        }\n        \n        Only return valid JSON, no additional text.\n      `;\n\n      const response = await this.makeGeminiRequest(prompt);\n      this.updateUsageCounters(1, prompt.length + response.length);\n\n      // Ensure type safety for parsed response\n      const parsed: { categories: MenuCategory[] } = JSON.parse(response); // Explicitly type the parsed object\n      if (typeof parsed !== 'object' || parsed == undefined || !('categories' in parsed) || !Array.isArray(parsed.categories)) {\n        throw new Error('Invalid Gemini menu response: missing or malformed categories array');\n      }\n      return parsed;\n    } catch (error) {\n      console.error('Error processing menu data with Gemini:', error);\n      throw error;\n    }\n  }\n\n  async extractLocationFromText(text: string): Promise<GeminiLocationData> {\n    if (!this.canMakeRequest()) {\n      throw new Error('Gemini API rate limit exceeded');\n    }\n\n    try {\n      const prompt = `\n        Extract location information from the following text and return structured data:\n        \n        \"${text}\"\n        \n        Return format:\n        {\n          \"address\": \"full_address\",\n          \"city\": \"city_name\",\n          \"state\": \"state\",\n          \"coordinates\": {\n            \"lat\": 0.0,\n            \"lng\": 0.0\n          },\n          \"confidence\": 0.95\n        }\n        \n        If coordinates cannot be determined, set them to undefined. Only return valid JSON.\n      `;\n      const response = await this.makeGeminiRequest(prompt);\n      this.updateUsageCounters(1, prompt.length + response.length);\n      const parsedResponse: GeminiLocationData = JSON.parse(response); // Explicitly type the parsed object\n      const validatedResponse = this.validateGeminiLocationResponse(parsedResponse);\n      return validatedResponse;\n    } catch (error) {\n      console.error('Error extracting location with Gemini:', error);\n      throw error;\n    }\n  }\n\n  private validateGeminiLocationResponse(parsedResponse: unknown): GeminiLocationData {\n    if (\n      parsedResponse == undefined ||\n      typeof parsedResponse !== 'object' ||\n      !('coordinates' in parsedResponse) ||\n      typeof (parsedResponse as Record<string, unknown>).coordinates !== 'object'\n    ) {\n      throw new Error('Invalid Gemini location response');\n    }\n    const coordinates = (parsedResponse as { coordinates?: { lat?: unknown; lng?: unknown } }).coordinates;\n    if (coordinates && typeof coordinates === 'object') {\n      if (typeof coordinates.lat !== 'number') {\n        (coordinates as { lat?: number | undefined }).lat = undefined;\n      }\n      if (typeof coordinates.lng !== 'number') {\n        (coordinates as { lng?: number | undefined }).lng = undefined;\n      }\n    }\n    return parsedResponse as GeminiLocationData;\n  }\n\n  async standardizeOperatingHours(hoursText: string): Promise<GeminiOperatingHours> {\n    if (!this.canMakeRequest()) {\n      throw new Error('Gemini API rate limit exceeded');\n    }\n\n    try {\n      const prompt = `\n        Parse the following operating hours text and return standardized format:\n        \n        \"${hoursText}\"\n        \n        Return format:\n        {\n          \"monday\": {\"open\": \"HH:MM\", \"close\": \"HH:MM\", \"closed\": false},\n          \"tuesday\": {\"open\": \"HH:MM\", \"close\": \"HH:MM\", \"closed\": false},\n          \"wednesday\": {\"open\": \"HH:MM\", \"close\": \"HH:MM\", \"closed\": false},\n          \"thursday\": {\"open\": \"HH:MM\", \"close\": \"HH:MM\", \"closed\": false},\n          \"friday\": {\"open\": \"HH:MM\", \"close\": \"HH:MM\", \"closed\": false},\n          \"saturday\": {\"open\": \"HH:MM\", \"close\": \"HH:MM\", \"closed\": false},\n          \"sunday\": {\"open\": \"HH:MM\", \"close\": \"HH:MM\", \"closed\": false}\n        }\n          Use 24-hour format. If closed on a day, set \"closed\": true and omit open/close times.\n        Only return valid JSON.\n      `;\n\n      const response = await this.makeGeminiRequest(prompt);\n      this.updateUsageCounters(1, prompt.length + response.length);\n      const parsed = JSON.parse(response);\n      if (parsed == undefined || typeof parsed !== 'object') {\n        throw new Error('Invalid Gemini hours response');\n      }\n      return parsed as GeminiOperatingHours;\n    } catch (error) {\n      console.error('Error standardizing hours with Gemini:', error);\n      throw error;\n    }\n  }\n\n  async analyzeSentiment(reviewText: string): Promise<GeminiSentimentAnalysis> {\n    if (!this.canMakeRequest()) {\n      throw new Error('Gemini API rate limit exceeded');\n    }\n\n    try {\n      const prompt = `\n        Analyze the sentiment of this food truck review and extract key insights:\n        \n        \"${reviewText}\"\n        \n        Return format:\n        {\n          \"sentiment\": \"positive|negative|neutral\",\n          \"score\": 0.85,\n          \"key_topics\": [\"food_quality\", \"service\", \"price\", \"location\"],\n          \"summary\": \"brief_summary_of_review\"\n        }\n          Score should be between 0 (very negative) and 1 (very positive).\n        Only return valid JSON.\n      `;\n\n      const response = await this.makeGeminiRequest(prompt);\n      this.updateUsageCounters(1, prompt.length + response.length);\n      const parsed = JSON.parse(response);\n      if (parsed == undefined || typeof parsed !== 'object') {\n        throw new Error('Invalid Gemini sentiment response');\n      }\n      return parsed as GeminiSentimentAnalysis;\n    } catch (error) {\n      console.error('Error analyzing sentiment with Gemini:', error);\n      throw error;\n    }\n  }\n\n  private async makeGeminiRequest(prompt: string): Promise<string> {\n    await new Promise((resolve) => setTimeout(resolve, 1000)); // Simulate API delay\n    return this.getMockGeminiResponse(prompt);\n  }\n\n  private getMockGeminiResponse(prompt: string): string {\n    if (prompt.includes('menu text')) {\n      return JSON.stringify({\n        categories: [\n          {\n            name: 'Burgers',\n            items: [\n              {\n                name: 'Classic Cheeseburger',\n                description: 'Beef patty with cheese, lettuce, tomato',\n                price: 12.99,\n                dietary_tags: [],\n              },\n            ],\n          },\n        ],\n      });\n    } else if (prompt.includes('location information')) {\n      return JSON.stringify({\n        address: '123 Market St, San Francisco, CA 94105',\n        city: 'San Francisco',\n        state: 'CA',\n        coordinates: {\n          lat: 37.7749,\n          lng: -122.4194,\n        },\n        confidence: 0.95,\n      });\n    } else if (prompt.includes('operating hours')) {\n      return JSON.stringify({\n        monday: { open: '11:00', close: '15:00', closed: false },\n        tuesday: { open: '11:00', close: '15:00', closed: false },\n        wednesday: { open: '11:00', close: '15:00', closed: false },\n        thursday: { open: '11:00', close: '15:00', closed: false },\n        friday: { open: '11:00', close: '20:00', closed: false },\n        saturday: { open: '12:00', close: '20:00', closed: false },\n        sunday: { open: '12:00', close: '16:00', closed: false },\n      });\n    } else if (prompt.includes('sentiment')) {\n      return JSON.stringify({\n        sentiment: 'positive',\n        score: 0.85,\n        key_topics: ['food_quality', 'service'],\n        summary: 'Customer enjoyed the food and service',\n      });\n    }\n    return '{\"processed\": true}';\n  }\n\n  private canMakeRequest(): boolean {\n    return this.requestCount < this.dailyLimit.requests && this.tokenCount < this.dailyLimit.tokens;\n  }\n\n  private updateUsageCounters(requests: number, tokens: number): void {\n    this.requestCount += requests;\n    this.tokenCount += tokens;\n  }\n\n  getUsageStats(): {\n    requests: { used: number; limit: number; remaining: number };\n    tokens: { used: number; limit: number; remaining: number };\n  } {\n    return {\n      requests: {\n        used: this.requestCount,\n        limit: this.dailyLimit.requests,\n        remaining: this.dailyLimit.requests - this.requestCount,\n      },\n      tokens: {\n        used: this.tokenCount,\n        limit: this.dailyLimit.tokens,\n        remaining: this.dailyLimit.tokens - this.tokenCount,\n      },\n    };\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/app/lib/activityLogger.ts","messages":[],"suppressedMessages":[{"ruleId":"sonarjs/pseudo-random","severity":2,"message":"Make sure that using this pseudorandom number generator is safe here.","line":45,"column":10,"nodeType":"CallExpression","messageId":"safeGenerator","endLine":45,"endColumn":23,"suppressions":[{"kind":"directive","justification":"Math.random is acceptable for non-security-critical logging IDs."}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/lib/api/admin/automated-cleanup/handlers.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/lib/api/admin/automated-cleanup/types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/lib/api/admin/data-cleanup/handlers.ts","messages":[{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async function 'handleGetStatus' has no 'await' expression.","line":126,"column":8,"nodeType":"FunctionDeclaration","messageId":"missingAwait","endLine":126,"endColumn":38,"suggestions":[{"messageId":"removeAsync","fix":{"range":[3673,3728],"text":"function handleGetStatus(): NextResponse"},"desc":"Remove 'async'."}]},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async function 'handleGetDefault' has no 'await' expression.","line":163,"column":8,"nodeType":"FunctionDeclaration","messageId":"missingAwait","endLine":163,"endColumn":39,"suggestions":[{"messageId":"removeAsync","fix":{"range":[4590,4646],"text":"function handleGetDefault(): NextResponse"},"desc":"Remove 'async'."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { NextRequest, NextResponse } from 'next/server';\nimport { BatchCleanupService, CleanupOperation } from '@/lib/data-quality/batchCleanup';\nimport { DuplicatePreventionService } from '@/lib/data-quality/duplicatePrevention';\n\nexport interface DataCleanupRequestBody {\n  action: string;\n  options?: {\n    batchSize?: number;\n    dryRun?: boolean;\n    operations?: string[];\n    truckData?: Record<string, unknown>;\n    targetId?: string;\n    sourceId?: string;\n  };\n}\n\nexport async function handlePostRequest(body: DataCleanupRequestBody): Promise<NextResponse> {\n  const { action, options = {} } = body;\n\n  switch (action) {\n    case 'full-cleanup': {\n      return await handleFullCleanup(options);\n    }\n    case 'check-duplicates': {\n      return await handleCheckDuplicates(options);\n    }\n    case 'merge-duplicates': {\n      return await handleMergeDuplicates(options);\n    }\n    case 'dry-run': {\n      return await handleDryRun(options);\n    }\n    default: {\n      return NextResponse.json(\n        { success: false, error: `Unknown action: ${action}` },\n        { status: 400 }\n      );\n    }\n  }\n}\n\nexport async function handleGetRequest(request: NextRequest): Promise<NextResponse> {\n  const { searchParams } = new URL(request.url);\n  const action = searchParams.get('action');\n\n  switch (action) {\n    case 'status': {\n      return await handleGetStatus();\n    }\n    case 'preview': {\n      return await handleGetPreview();\n    }\n    default: {\n      return await handleGetDefault();\n    }\n  }\n}\n\nexport async function handleFullCleanup(options: DataCleanupRequestBody['options']): Promise<NextResponse> {\n  const result = await BatchCleanupService.runFullCleanup({\n    batchSize: options?.batchSize ?? 50,\n    dryRun: options?.dryRun ?? false,\n    operations: options?.operations as CleanupOperation['type'][]\n  });\n  \n  return NextResponse.json({\n    success: true,\n    action: 'full-cleanup',\n    result,\n    message: `Cleanup completed: ${result.summary.trucksImproved} trucks improved, ${result.summary.duplicatesRemoved} duplicates removed`\n  });\n}\n\nexport async function handleCheckDuplicates(options: DataCleanupRequestBody['options']): Promise<NextResponse> {\n  const { truckData } = options ?? {};\n  if (!truckData) {\n    return NextResponse.json(\n      { success: false, error: 'Missing truckData for duplicate check' },\n      { status: 400 }\n    );\n  }\n\n  const duplicateCheck = await DuplicatePreventionService.checkForDuplicates(truckData);\n  \n  return NextResponse.json({\n    success: true,\n    action: 'check-duplicates',\n    result: duplicateCheck\n  });\n}\n\nexport async function handleMergeDuplicates(options: DataCleanupRequestBody['options']): Promise<NextResponse> {\n  const { targetId, sourceId } = options ?? {};\n  if (targetId === undefined || sourceId === undefined) {\n    return NextResponse.json(\n      { success: false, error: 'Missing targetId or sourceId for merge operation' },\n      { status: 400 }\n    );\n  }\n\n  const mergedTruck = await DuplicatePreventionService.mergeDuplicates(targetId, sourceId);\n  \n  return NextResponse.json({\n    success: true,\n    action: 'merge-duplicates',\n    result: mergedTruck,\n    message: `Successfully merged truck ${sourceId} into ${targetId}`\n  });\n}\n\nexport async function handleDryRun(options: DataCleanupRequestBody['options']): Promise<NextResponse> {\n  const result = await BatchCleanupService.runFullCleanup({\n    ...options,\n    operations: options?.operations as CleanupOperation['type'][],\n    dryRun: true\n  });\n  \n  return NextResponse.json({\n    success: true,\n    action: 'dry-run',\n    result,\n    message: 'Dry run completed - no changes made to database'\n  });\n}\n\nexport async function handleGetStatus(): Promise<NextResponse> {\n  return NextResponse.json({\n    success: true,\n    status: {\n      available_operations: [\n        'remove_placeholders',\n        'normalize_phone',\n        'fix_coordinates',\n        'update_quality_scores',\n        'merge_duplicates'\n      ],\n      default_batch_size: 50,\n      supports_dry_run: true\n    }\n  });\n}\n\nexport async function handleGetPreview(): Promise<NextResponse> {\n  const result = await BatchCleanupService.runFullCleanup({\n    batchSize: 10,\n    dryRun: true\n  });\n  \n  return NextResponse.json({\n    success: true,\n    preview: {\n      estimated_improvements: result.summary.trucksImproved,\n      estimated_duplicates: result.summary.duplicatesRemoved,\n      operations: result.operations.map(op => ({\n        type: op.type,\n        description: op.description,\n        affected_count: op.affectedCount\n      }))\n    }\n  });\n}\n\nexport async function handleGetDefault(): Promise<NextResponse> {\n  return NextResponse.json({\n    success: true,\n    endpoints: [\n      'GET /api/admin/data-cleanup?action=status - Get cleanup system status',\n      'GET /api/admin/data-cleanup?action=preview - Preview cleanup changes',\n      'POST /api/admin/data-cleanup - Run cleanup operations'\n    ],\n    actions: [\n      'full-cleanup - Run all cleanup operations',\n      'check-duplicates - Check if truck data is duplicate',\n      'merge-duplicates - Merge two duplicate trucks',\n      'dry-run - Preview changes without making them'\n    ]\n  });\n}\n","usedDeprecatedRules":[]},{"filePath":"/app/lib/api/admin/data-quality/handlers.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":14,"column":12,"nodeType":"Identifier","messageId":"conditionErrorNullableString","endLine":14,"endColumn":19,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[475,483],"text":"truckId == null"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[476,483],"text":"(truckId ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[475,483],"text":"!Boolean(truckId)"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/await-thenable","severity":2,"message":"Unexpected `await` of a non-Promise (non-\"Thenable\") value.","line":47,"column":14,"nodeType":"AwaitExpression","messageId":"await","endLine":47,"endColumn":39,"suggestions":[{"messageId":"removeAwait","fix":{"range":[1469,1474],"text":""},"desc":"Remove unnecessary `await`."}]},{"ruleId":"sonarjs/no-invalid-await","severity":2,"message":"Refactor this redundant 'await' on a non-promise.","line":47,"column":14,"nodeType":"AwaitExpression","messageId":"refactorAwait","endLine":47,"endColumn":39},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":175,"column":10,"nodeType":"Identifier","messageId":"conditionErrorNullableString","endLine":175,"endColumn":20,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[4880,4891],"text":"authHeader == null"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[4881,4891],"text":"(authHeader ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[4880,4891],"text":"!Boolean(authHeader)"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { NextRequest, NextResponse } from 'next/server';\nimport { FoodTruckService, supabase, FoodTruck } from '@/lib/supabase';\n\nexport async function handleGetRequest(request: NextRequest): Promise<NextResponse> {\n  const { searchParams } = new URL(request.url);\n  const action = searchParams.get('action');\n  const truckId = searchParams.get('truckId');\n\n  switch (action) {\n    case 'stats': {\n      return await handleStatsAction();\n    }\n    case 'assess': {\n      if (!truckId) {\n        return NextResponse.json({ success: false, error: 'Missing truckId for assess action' }, { status: 400 });\n      }\n      return await handleAssessAction(truckId);\n    }\n    default: {\n      return await handleDefaultGetAction();\n    }\n  }\n}\n\ninterface PostRequestBody {\n  action: string;\n  truckId?: string;\n}\n\nexport async function handlePostRequest(request: NextRequest): Promise<NextResponse> {\n  const body: unknown = await request.json();\n\n  if (typeof body !== 'object' || body === null) {\n    return NextResponse.json({ success: false, error: 'Invalid request body' }, { status: 400 });\n  }\n\n  const { action, truckId } = body as PostRequestBody;\n\n  switch (action) {\n    case 'update-single': {\n      if (truckId === undefined || truckId === '') {\n        return NextResponse.json({ success: false, error: 'Missing truckId for update-single action' }, { status: 400 });\n      }\n      return handleUpdateSingle(truckId);\n    }\n    case 'batch-update': {\n      return await handleBatchUpdate();\n    }\n    case 'recalculate-all': {\n      return await handleRecalculateAll();\n    }\n    default: {\n      return NextResponse.json({ success: false, error: `Unknown action: ${action}` }, { status: 400 });\n    }\n  }\n}\n\nasync function handleStatsAction() {\n  const qualityStats = await FoodTruckService.getDataQualityStats();\n\n  return NextResponse.json({\n    success: true,\n    data: {\n      ...qualityStats,\n      timestamp: new Date().toISOString()\n    }\n  });\n}\n\nasync function handleAssessAction(truckId: string) {\n  const truckResult = await FoodTruckService.getTruckById(truckId);\n\n  if ('error' in truckResult) {\n    return NextResponse.json({ success: false, error: truckResult.error }, { status: 404 });\n  }\n\n  const truck: FoodTruck = truckResult; // Explicitly cast to FoodTruck\n\n  return NextResponse.json({\n    success: true,\n    data: {\n      truckId,\n      truckName: truck.name,\n      currentScore: truck.data_quality_score,\n      timestamp: new Date().toISOString()\n    }\n  });\n}\n\nasync function handleDefaultGetAction() {\n  const qualityStats = await FoodTruckService.getDataQualityStats();\n  return NextResponse.json({\n    success: true,\n    data: qualityStats\n  });\n}\n\nasync function handleUpdateSingle(truckId: string) {\n  const updatedTruckResult = await FoodTruckService.getTruckById(truckId);\n  \n  if ('error' in updatedTruckResult) {\n    return NextResponse.json({ success: false, error: updatedTruckResult.error }, { status: 404 });\n  }\n\n  const updatedTruck = updatedTruckResult;\n\n  return NextResponse.json({\n    success: true,\n    message: 'Quality score updated successfully',\n    data: {\n      truckId: updatedTruck.id,\n      truckName: updatedTruck.name,\n      newScore: updatedTruck.data_quality_score,\n      verificationStatus: updatedTruck.verification_status,\n      timestamp: new Date().toISOString()\n    }\n  });\n}\n\nfunction handleBatchUpdate() {\n  return NextResponse.json({\n    success: true,\n    message: 'Batch quality score update completed',\n    data: {\n      timestamp: new Date().toISOString()\n    }\n  });\n}\n\nfunction updateSingleTruckQualityScore(truck: { id: string }): boolean {\n  try {\n    // Placeholder for actual update logic if needed\n    // DataQualityService.updateTruckQualityScore(truck.id);\n    return true;\n  } catch (error: unknown) {\n    console.error(`Failed to update truck ${truck.id}:`, error);\n    return false;\n  }\n}\n\nasync function handleRecalculateAll() {\n  const allTrucksResult = await FoodTruckService.getAllTrucks(1000, 0);\n  if (allTrucksResult.error !== undefined) {\n    console.error('Error fetching all trucks for recalculation:', allTrucksResult.error);\n    return NextResponse.json({ success: false, error: 'Failed to fetch trucks for recalculation' }, { status: 500 });\n  }\n  const { trucks } = allTrucksResult;\n  let updated = 0;\n  let errors = 0;\n\n  for (const truck of trucks) {\n    const success = updateSingleTruckQualityScore(truck);\n    if (success) {\n      updated++;\n    } else {\n      errors++;\n    }\n  }\n\n  return NextResponse.json({\n    success: true,\n    message: 'Quality score recalculation completed',\n    data: {\n      totalTrucks: trucks.length,\n      updated,\n      errors,\n      timestamp: new Date().toISOString()\n    }\n  });\n}\n\nexport async function verifyAdminAccess(request: Request): Promise<boolean> {\n  try {\n    const authHeader = request.headers.get('authorization');\n    if (!authHeader) return false;\n\n    const token = authHeader.replace('Bearer ', '');\n    const { data, error } = await supabase.auth.getUser(token);\n    const user = data?.user;\n    \n    if (error || !user) return false;\n\n    const { data: profile } = await supabase\n      .from('profiles')\n      .select('role')\n      .eq('id', user.id)\n      .single();\n\n    return profile?.role === 'admin';\n  } catch {\n    return false;\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/app/lib/api/admin/oauth-status/helpers.ts","messages":[{"ruleId":"max-depth","severity":2,"message":"Blocks are nested too deeply (5). Maximum allowed is 4.","line":129,"column":11,"nodeType":"IfStatement","messageId":"tooDeeply","endLine":131,"endColumn":12},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":158,"column":25,"nodeType":"Identifier","messageId":"conditionErrorObject","endLine":158,"endColumn":35},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":160,"column":16,"nodeType":"Identifier","messageId":"conditionErrorObject","endLine":160,"endColumn":26},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":219,"column":7,"nodeType":"ChainExpression","messageId":"conditionErrorNullableBoolean","endLine":219,"endColumn":50,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[8545,8588],"text":"((status.supabase.authSettings?.googleEnabled) ?? false)"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[8545,8588],"text":"((status.supabase.authSettings?.googleEnabled) === true)"},"desc":"Change condition to check if true (`value === true`)"}]}],"suppressedMessages":[{"ruleId":"sonarjs/different-types-comparison","severity":2,"message":"Remove this \"!==\" check; it will always be true. Did you mean to use \"!=\"?","line":210,"column":59,"nodeType":null,"endLine":210,"endColumn":62,"suggestions":[{"desc":"Replace \"!==\" with \"!=\"","fix":{"range":[8356,8359],"text":"!="}}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":1,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { NextRequest, NextResponse } from 'next/server';\nimport { supabase } from '@/lib/supabase';\nimport { OAuthStatus } from './types';\nimport type { SupabaseClient } from '@supabase/supabase-js';\n\nexport async function handleGetRequest(_request: NextRequest) {\n  const status = await getOAuthStatus();\n\n  return NextResponse.json({\n    success: true,\n    ...status,\n    legacy_format: {\n      oauth_status: status.overall_status,\n      message: getStatusMessage(status.overall_status),\n      configuration_steps: status.overall_status === 'ready' ? undefined : [\n        '1. Go to Supabase Dashboard > Authentication > Providers',\n        '2. Enable Google provider',\n        '3. Add Google OAuth Client ID and Secret',\n        '4. Configure redirect URLs',\n        '5. Test OAuth flow'\n      ]\n    }\n  });\n}\n\n// 1. Refactor nested template literals in generateOAuthTestUrl\nfunction generateOAuthTestUrl(baseUrl: string): string {\n  const redirectPath = `${baseUrl}/auth/callback`;\n  const encodedRedirect = encodeURIComponent(redirectPath);\n  return process.env.NEXT_PUBLIC_SUPABASE_URL + '/auth/v1/authorize?provider=google&redirect_to=' + encodedRedirect;\n}\n\nexport function handlePostRequest() { // Removed _request parameter\n  const baseUrl = process.env.NODE_ENV === 'production'\n    ? 'https://food-truck-finder-poc-git-feat-s-20ec1c-codedeficients-projects.vercel.app'\n    : 'http://localhost:3000';\n\n  const testUrl = generateOAuthTestUrl(baseUrl);\n\n  return NextResponse.json({\n    success: true,\n    message: 'OAuth test URL generated',\n    test_url: testUrl,\n    environment: process.env.NODE_ENV ?? 'development',\n    instructions: [\n      '1. Open the test_url in a new browser tab',\n      '2. Complete Google OAuth flow',\n      '3. Verify redirect to admin dashboard',\n      '4. Check for proper role assignment'\n    ],\n    manual_test_steps: [\n      'Navigate to /login page',\n      'Click Google login button',\n      'Complete OAuth flow',\n      'Verify admin access'\n    ],\n    automation_commands: [\n      'npm run oauth:verify - Check configuration',\n      'npm run oauth:test:dev - Test development flow',\n      'npm run oauth:test:prod - Test production flow'\n    ]\n  });\n}\n\nasync function getOAuthStatus(): Promise<OAuthStatus> {\n  const status: OAuthStatus = {\n    timestamp: new Date().toISOString(),\n    environment: process.env.NODE_ENV === 'production' ? 'production' : 'development',\n    supabase: {\n      connected: false,\n      projectId: 'zkwliyjjkdnigizidlln' as string\n    },\n    environment_variables: {\n      supabaseUrl: process.env.NEXT_PUBLIC_SUPABASE_URL !== undefined,\n      supabaseAnonKey: process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY !== undefined,\n      supabaseServiceKey: process.env.SUPABASE_SERVICE_ROLE_KEY !== undefined\n    },\n    oauth_flow: {\n      loginPageExists: true,\n      callbackRouteExists: true,\n      authProviderConfigured: false\n    },\n    recommendations: [],\n    overall_status: 'not_configured'\n  };\n\n  await checkSupabaseConnection(status, supabase);\n  await checkSupabaseAuthSettings(status);\n  await testOAuthProvider(status, supabase);\n\n  status.recommendations = generateRecommendations(status);\n  status.overall_status = determineOverallStatus(status);\n\n  return status;\n}\n\nasync function checkSupabaseConnection(status: OAuthStatus, supabase: SupabaseClient) {\n  try {\n    const { error } = await supabase.from('profiles').select('count').limit(1);\n    if (error === null) {\n      status.supabase.connected = true;\n    } else {\n      status.supabase.error = error.message;\n    }\n  } catch (error: unknown) {\n    status.supabase.error =\n      error instanceof Error ? error.message : 'Unknown connection error';\n  }\n}\n\nasync function checkSupabaseAuthSettings(status: OAuthStatus) {\n  try {\n    const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;\n    if (typeof supabaseUrl === 'string' && supabaseUrl.length > 0) { // Explicit check for undefined and empty string\n      const settingsResponse = await fetch(`${supabaseUrl}/auth/v1/settings`);\n      if (settingsResponse.ok === true) {\n        const settingsData: unknown = await settingsResponse.json();\n        if (typeof settingsData === 'object' && settingsData !== null) {\n          const settings = settingsData as {\n            external?: { google?: boolean };\n            disable_signup?: boolean;\n            autoconfirm?: boolean;\n          };\n          status.supabase.authSettings = {\n            googleEnabled: settings.external?.google ?? false,\n            signupEnabled: settings.disable_signup === false, // Note: Supabase typically uses true to disable, so false means enabled\n            autoconfirm: settings.autoconfirm ?? false\n          };\n          if (settings.external?.google !== undefined) {\n            status.oauth_flow.authProviderConfigured = true;\n          }\n        } else {\n          console.warn('Auth settings response was not a valid object:', settingsData);\n        }\n      }\n    }\n  } catch (error: unknown) {\n    console.warn('Error fetching or parsing Supabase auth settings:', error);\n    // Keep authProviderConfigured as its current state (likely false)\n  }\n}\n\nasync function testOAuthProvider(status: OAuthStatus, supabase: SupabaseClient) {\n  try {\n    // This call is expected to \"fail\" by not redirecting, but not throw if provider is configured.\n    // The error object might contain information, or lack of error indicates success.\n    const { error: oauthError } = await supabase.auth.signInWithOAuth({\n      provider: 'google',\n      options: {\n        // Using a non-existent callback for testing purposes, as skipBrowserRedirect might not always prevent navigation attempts.\n        redirectTo: 'http://localhost:9999/auth/test-callback', \n        skipBrowserRedirect: true, // Attempt to prevent actual redirect\n      },\n    });\n\n    // If no error, or if error is not \"Provider not found\", assume it's configured.\n    // Specific error messages can be brittle, so checking for NOT \"Provider not found\" is safer.\n    if (!oauthError || (oauthError && oauthError.message !== 'Provider not found' && oauthError.message !== 'No browser detected.')) {\n      status.oauth_flow.authProviderConfigured = true;\n    } else if (oauthError) {\n      console.info(`OAuth provider test info (may indicate not configured): ${oauthError.message}`);\n      status.oauth_flow.authProviderConfigured = false; // Explicitly set if specific error indicates not configured\n    }\n  } catch (error: unknown) {\n    // Catch any unexpected errors during the test call\n    console.warn('Unexpected error during OAuth provider test:', error);\n    // status.oauth_flow.authProviderConfigured remains as is or false\n  }\n}\n\nfunction generateRecommendations(status: OAuthStatus): string[] {\n  const recommendations: string[] = [];\n\n  if (!status.environment_variables.supabaseUrl) {\n    recommendations.push('❌ Configure NEXT_PUBLIC_SUPABASE_URL environment variable');\n  }\n  if (!status.environment_variables.supabaseAnonKey) {\n    recommendations.push('❌ Configure NEXT_PUBLIC_SUPABASE_ANON_KEY environment variable');\n  }\n  if (!status.environment_variables.supabaseServiceKey) {\n    recommendations.push('❌ Configure SUPABASE_SERVICE_ROLE_KEY environment variable');\n  }\n\n  if (!status.supabase.connected) {\n    recommendations.push('❌ Fix Supabase connection issue');\n  if (typeof status.supabase.error === 'string' && status.supabase.error.length > 0) {\n    recommendations.push(`   Error: ${status.supabase.error}`);\n  }\n  }\n\n  if (status.supabase.authSettings?.googleEnabled === true) {\n    recommendations.push('✅ Google OAuth provider is enabled');\n  } else {\n    recommendations.push('🔧 Enable Google OAuth provider in Supabase Dashboard', '   Go to: Authentication > Providers > Google');\n  }\n\n  if (status.overall_status === 'ready') {\n    recommendations.push('🎉 OAuth configuration is complete!', '✅ Test the login flow at /login');\n  }\n\n  if (recommendations.length > 1) {\n    recommendations.push('📖 See docs/GOOGLE_OAUTH_SETUP_GUIDE.md for detailed instructions', '🔧 Run: npm run oauth:verify for automated checks');\n  }\n\n  return recommendations;\n}\n\nfunction determineOverallStatus(status: OAuthStatus): 'ready' | 'partial' | 'not_configured' | 'error' {\n  // eslint-disable-next-line sonarjs/different-types-comparison\n  if (!status.supabase.connected || status.supabase.error !== null) {\n    return 'error';\n  }\n\n  const envVarsComplete = Object.values(status.environment_variables).every(Boolean);\n  if (!envVarsComplete) {\n    return 'not_configured';\n  }\n\n  if (status.supabase.authSettings?.googleEnabled && status.oauth_flow.authProviderConfigured) {\n    return 'ready';\n  }\n\n  if (status.supabase.connected && envVarsComplete) {\n    return 'partial';\n  }\n\n  return 'not_configured';\n}\n\nfunction getStatusMessage(status: string): string {\n  switch (status) {\n    case 'ready': {\n      return 'Google OAuth is fully configured and ready to use';\n    }\n    case 'partial': {\n      return 'Basic configuration complete, OAuth provider needs setup';\n    }\n    case 'not_configured': {\n      return 'Google OAuth is not configured';\n    }\n    case 'error': {\n      return 'Configuration error detected';\n    }\n    default: {\n      return 'Unknown configuration status';\n    }\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/app/lib/api/admin/oauth-status/types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/lib/api/admin/realtime-events/handlers.ts","messages":[{"ruleId":"unicorn/prefer-node-protocol","severity":2,"message":"Prefer `node:crypto` over `crypto`.","line":11,"column":20,"nodeType":"Literal","messageId":"prefer-node-protocol","endLine":11,"endColumn":28,"fix":{"range":[847,847],"text":"node:"}}],"suppressedMessages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":36,"column":10,"nodeType":"ChainExpression","messageId":"conditionErrorNullableBoolean","endLine":36,"endColumn":43,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[1488,1521],"text":"((authHeader?.startsWith('Bearer ')) ?? false)"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareFalse","fix":{"range":[1487,1521],"text":"(authHeader?.startsWith('Bearer ')) === false"},"desc":"Change condition to check if false (`value === false`)"}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"sonarjs/different-types-comparison","severity":2,"message":"Remove this \"===\" check; it will always be false. Did you mean to use \"==\"?","line":43,"column":28,"nodeType":null,"endLine":43,"endColumn":31,"suggestions":[{"desc":"Replace \"===\" with \"==\"","fix":{"range":[1683,1686],"text":"=="}}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-misused-promises","severity":2,"message":"Promise returned in function argument where a void return was expected.","line":82,"column":38,"nodeType":"ArrowFunctionExpression","messageId":"voidReturnArgument","endLine":84,"endColumn":8,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-misused-promises","severity":2,"message":"Promise returned in function argument where a void return was expected.","line":143,"column":22,"nodeType":"ArrowFunctionExpression","messageId":"voidReturnArgument","endLine":149,"endColumn":4,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":1,"fixableWarningCount":0,"source":"/* eslint-disable @typescript-eslint/no-misused-promises */\n// Removed unused NextRequest from 'next/server' as Response is used directly.\n// Only NextRequest was unused if Response is used from the global scope.\n// If NextRequest is truly unused, the import line should be removed or NextRequest specifically.\n// For now, assuming NextRequest might be used by verifyAdminAccess or other functions not shown.\n// Re-evaluating: NextRequest is used in handleGetRequest and handlePostRequest params.\n// NextResponse was the one that was unused.\nimport { NextRequest } from 'next/server'; // Keeping NextRequest if used, will remove NextResponse if it was there.\nimport { supabase, supabaseAdmin, ScrapingJobService, FoodTruckService, type ScrapingJob, type FoodTruck } from '@/lib/supabase';\nimport { AdminEvent } from './types';\nimport crypto from 'crypto'; // For randomUUID\n\ninterface RealtimeMetrics {\n  scrapingJobs: {\n    active: number;\n    completed: number;\n    failed: number;\n    pending: number;\n  };\n  dataQuality: {\n    averageScore: number;\n    totalTrucks: number;\n    recentChanges: number;\n  };\n  systemHealth: {\n    status: 'healthy' | 'warning' | 'error';\n    uptime: number;\n    lastUpdate: string;\n  };\n}\n\n/* eslint-disable @typescript-eslint/strict-boolean-expressions, sonarjs/different-types-comparison */\nexport async function verifyAdminAccess(request: NextRequest): Promise<boolean> {\n  try {\n    const authHeader = request.headers.get('authorization');\n    if (!authHeader?.startsWith('Bearer ')) {\n      return false;\n    }\n\n    const token = authHeader.slice(7);\n    const { data, error } = await supabase.auth.getUser(token);\n\n    if (error || data.user === null) {\n      return false;\n    }\n    const user = data.user;\n\n    if (!supabaseAdmin) {\n      return false;\n    }\n\n    const { data: profile } = await supabaseAdmin\n      .from('profiles')\n      .select('role')\n      .eq('id', user.id)\n      .single();\n\n    return profile?.role === 'admin';\n  } catch {\n    return false;\n  }\n}\n/* eslint-enable @typescript-eslint/strict-boolean-expressions, sonarjs/different-types-comparison */\n\nexport function handleGetRequest(request: NextRequest): Response {\n  const stream = new ReadableStream({\n    start(controller: ReadableStreamDefaultController<Uint8Array>) {\n      const encoder = new TextEncoder();\n\n      const connectionEvent: AdminEvent = {\n        id: generateEventId(),\n        type: 'heartbeat',\n        timestamp: new Date().toISOString(),\n        data: {\n          message: 'Real-time admin dashboard connected',\n          connectionId: generateEventId()\n        }\n      };\n      \n      controller.enqueue(encoder.encode(formatSSEMessage(connectionEvent)));\n\n      const intervalId = setInterval(async () => {\n        await sendHeartbeatEvent(controller, encoder);\n      }, 5000);\n\n      const changeMonitorId = setupDataChangeMonitor(controller, encoder);\n\n      request.signal.addEventListener('abort', () => {\n        clearInterval(intervalId);\n        clearInterval(changeMonitorId);\n        controller.close();\n      });\n    }\n  });\n\n  return new Response(stream, {\n    headers: {\n      'Content-Type': 'text/event-stream',\n      'Cache-Control': 'no-cache',\n      'Connection': 'keep-alive',\n      'Access-Control-Allow-Origin': '*',\n      'Access-Control-Allow-Headers': 'Cache-Control'\n    }\n  });\n}\n\nasync function sendHeartbeatEvent(\n  controller: ReadableStreamDefaultController<Uint8Array>,\n  encoder: TextEncoder\n): Promise<void> {\n  try {\n    const metrics = await fetchRealtimeMetrics();\n    const event: AdminEvent = {\n      id: generateEventId(),\n      type: 'heartbeat',\n      timestamp: new Date().toISOString(),\n      data: { ...metrics }\n    };\n\n    controller.enqueue(encoder.encode(formatSSEMessage(event)));\n  } catch (error) {\n    console.error('Error fetching realtime metrics:', error);\n\n    const errorEvent: AdminEvent = {\n      id: generateEventId(),\n      type: 'system_alert',\n      timestamp: new Date().toISOString(),\n      data: {\n        error: 'Failed to fetch metrics',\n        details: error instanceof Error ? error.message : 'Unknown error'\n      },\n      severity: 'error'\n    };\n\n    controller.enqueue(encoder.encode(formatSSEMessage(errorEvent)));\n  }\n}\n\nfunction setupDataChangeMonitor(\n  controller: ReadableStreamDefaultController<Uint8Array>,\n  encoder: TextEncoder\n): NodeJS.Timeout {\n  return setInterval(async () => {\n    try {\n      await monitorDataChanges(controller, encoder);\n    } catch (error) {\n      console.error('Error monitoring data changes:', error);\n    }\n  }, 10_000);\n}\n\nexport async function handlePostRequest(request: NextRequest): Promise<Response> {\n  try {\n    const body: unknown = await request.json(); // Explicitly type body as unknown\n    let action: string;\n\n    // Type guard to ensure 'body' has 'action' property and is a string\n    if (typeof body === 'object' && body !== null && 'action' in body && typeof (body as { action: string }).action === 'string') {\n      action = (body as { action: string }).action;\n    } else {\n      return new Response(JSON.stringify({\n        success: false,\n        error: \"Invalid request body: 'action' property is missing or not a string.\"\n      }), {\n        status: 400,\n        headers: { 'Content-Type': 'application/json' }\n      });\n    }\n\n    switch (action) {\n      case 'health_check': {\n        return await handleHealthCheck();\n      }\n\n      case 'trigger_test_event': {\n        return handleTriggerTestEvent();\n      }\n\n      default: {\n        return new Response(JSON.stringify({\n          success: false,\n          error: \"That didn't work, please try again later.\"\n        }), {\n          status: 400,\n          headers: { 'Content-Type': 'application/json' }\n        });\n      }\n    }\n  } catch (error) {\n    console.error('Realtime events POST error:', error);\n    return new Response(JSON.stringify({\n      success: false,\n      error: \"That didn't work, please try again later.\"\n    }), {\n      status: 500,\n      headers: { 'Content-Type': 'application/json' }\n    });\n  }\n}\n\nasync function fetchRealtimeMetrics(): Promise<RealtimeMetrics> {\n  try {\n    const recentJobs = await ScrapingJobService.getJobsByStatus('all');\n    const scrapingMetrics = {\n      active: recentJobs.filter((job: ScrapingJob) => job.status === 'running').length,\n      completed: recentJobs.filter((job: ScrapingJob) => job.status === 'completed').length,\n      failed: recentJobs.filter((job: ScrapingJob) => job.status === 'failed').length,\n      pending: recentJobs.filter((job: ScrapingJob) => job.status === 'pending').length\n    };\n\n    const qualityStats = await FoodTruckService.getDataQualityStats();\n    const dataQualityMetrics = {\n      averageScore: qualityStats.avg_quality_score ?? 0,\n      totalTrucks: qualityStats.total_trucks ?? 0,\n      recentChanges: 0\n    };\n\n    const systemHealth = {\n      status: 'healthy' as const,\n      uptime: process.uptime(),\n      lastUpdate: new Date().toISOString()\n    };\n\n    return {\n      scrapingJobs: scrapingMetrics,\n      dataQuality: dataQualityMetrics,\n      systemHealth\n    };\n  } catch (error) {\n    console.error('Error fetching realtime metrics:', error);\n    return {\n      scrapingJobs: { active: 0, completed: 0, failed: 0, pending: 0 },\n      dataQuality: { averageScore: 0, totalTrucks: 0, recentChanges: 0 },\n      systemHealth: {\n        status: 'error',\n        uptime: 0,\n        lastUpdate: new Date().toISOString()\n      }\n    };\n  }\n}\n\nfunction isScrapingJob(obj: unknown): obj is ScrapingJob {\n  return typeof obj === 'object' && obj !== null && 'id' in obj && 'status' in obj;\n}\n\n// Removed isFoodTruck function as it is unused.\n// function isFoodTruck(obj: unknown): obj is FoodTruck {\n//   return typeof obj === 'object' && obj !== null && 'id' in obj && 'name' in obj;\n// }\n\nasync function sendScrapingUpdateEvent(\n  controller: ReadableStreamDefaultController<Uint8Array>,\n  encoder: TextEncoder\n): Promise<void> {\n  const recentJobs = await ScrapingJobService.getJobsByStatus('all');\n\n  if (Array.isArray(recentJobs) && recentJobs.length > 0) {\n    const event: AdminEvent = {\n      id: generateEventId(),\n      type: 'scraping_update',\n      timestamp: new Date().toISOString(),\n      data: {\n        recentJobs: recentJobs.filter((job) => isScrapingJob(job)).map((job) => ({ // Fixed unicorn/no-array-callback-reference\n          id: job.id,\n          status: job.status,\n          started_at: job.started_at,\n          completed_at: job.completed_at\n        })),\n        count: recentJobs.length\n      },\n      severity: 'info'\n    };\n\n    controller.enqueue(encoder.encode(formatSSEMessage(event)));\n  }\n}\n\nasync function sendDataQualityChangeEvent(\n  controller: ReadableStreamDefaultController<Uint8Array>,\n  encoder: TextEncoder\n): Promise<void> {\n  const recentTrucksResult = await FoodTruckService.getAllTrucks(10, 0);\n  const recentlyUpdated = recentTrucksResult.trucks.filter((truck: FoodTruck) => {\n    if (!truck.updated_at) return false;\n    const updatedAt = new Date(truck.updated_at);\n    const oneMinuteAgo = new Date(Date.now() - 60_000);\n    return updatedAt > oneMinuteAgo;\n  });\n\n  if (recentlyUpdated.length > 0) {\n    const event: AdminEvent = {\n      id: generateEventId(),\n      type: 'data_quality_change',\n      timestamp: new Date().toISOString(),\n      data: {\n        updatedTrucks: recentlyUpdated.map(truck => ({\n          id: truck.id,\n          name: truck.name,\n          data_quality_score: truck.data_quality_score,\n          updated_at: truck.updated_at\n        })),\n        count: recentlyUpdated.length\n      },\n      severity: 'info'\n    };\n\n    controller.enqueue(encoder.encode(formatSSEMessage(event)));\n  }\n}\n\nasync function monitorDataChanges(\n  controller: ReadableStreamDefaultController<Uint8Array>,\n  encoder: TextEncoder\n): Promise<void> {\n  try {\n    await sendScrapingUpdateEvent(controller, encoder);\n    await sendDataQualityChangeEvent(controller, encoder);\n  } catch (error) {\n    console.error('Error monitoring data changes:', error);\n  }\n}\n\nfunction formatSSEMessage(event: AdminEvent): string {\n  return `id: ${event.id}\\nevent: ${event.type}\\ndata: ${JSON.stringify(event)}\\n\\n`;\n}\n\nfunction generateEventId(): string {\n  return crypto.randomUUID();\n}\n\nasync function handleHealthCheck(): Promise<Response> {\n  const metrics = await fetchRealtimeMetrics();\n  return new Response(JSON.stringify({\n    success: true,\n    status: 'healthy',\n    metrics,\n    timestamp: new Date().toISOString()\n  }), {\n    headers: { 'Content-Type': 'application/json' }\n  });\n}\n\nfunction handleTriggerTestEvent(): Response {\n  return new Response(JSON.stringify({\n    success: true,\n    message: 'Test event triggered',\n    timestamp: new Date().toISOString()\n  }), {\n    headers: { 'Content-Type': 'application/json' }\n  });\n}\n","usedDeprecatedRules":[]},{"filePath":"/app/lib/api/admin/realtime-events/types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/lib/api/admin/scraping-metrics/handlers.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'totalRuns' is assigned a value but never used.","line":76,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":76,"endColumn":18},{"ruleId":"sonarjs/no-unused-vars","severity":2,"message":"Remove the declaration of the unused 'totalRuns' variable.","line":76,"column":9,"nodeType":"Identifier","messageId":"unusedVariable","endLine":76,"endColumn":18},{"ruleId":"sonarjs/no-dead-store","severity":2,"message":"Remove this useless assignment to variable \"totalRuns\".","line":76,"column":9,"nodeType":null,"messageId":"removeAssignment","endLine":76,"endColumn":18},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'averageRunTime' is assigned a value but never used.","line":79,"column":39,"nodeType":null,"messageId":"unusedVar","endLine":79,"endColumn":53},{"ruleId":"sonarjs/no-unused-vars","severity":2,"message":"Remove the declaration of the unused 'averageRunTime' variable.","line":79,"column":39,"nodeType":"Identifier","messageId":"unusedVariable","endLine":79,"endColumn":53},{"ruleId":"sonarjs/no-dead-store","severity":2,"message":"Remove this useless assignment to variable \"averageRunTime\".","line":79,"column":39,"nodeType":null,"messageId":"removeAssignment","endLine":79,"endColumn":53},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'newTrucksToday' is assigned a value but never used.","line":80,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":80,"endColumn":23},{"ruleId":"sonarjs/no-unused-vars","severity":2,"message":"Remove the declaration of the unused 'newTrucksToday' variable.","line":80,"column":9,"nodeType":"Identifier","messageId":"unusedVariable","endLine":80,"endColumn":23},{"ruleId":"sonarjs/no-dead-store","severity":2,"message":"Remove this useless assignment to variable \"newTrucksToday\".","line":80,"column":9,"nodeType":null,"messageId":"removeAssignment","endLine":80,"endColumn":23}],"suppressedMessages":[],"errorCount":6,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { NextResponse } from 'next/server';\nimport { ScrapingJobService, FoodTruckService, supabase } from '@/lib/supabase';\nimport { RealtimeMetrics } from './types';\n\nexport async function verifyAdminAccess(request: Request): Promise<boolean> {\n  try {\n    const authHeader = request.headers.get('authorization');\n    if (authHeader == undefined) return false;\n\n    const token = authHeader.replace('Bearer ', '');\n    const { data: { user }, error } = await supabase.auth.getUser(token);\n\n    if (error || !user) return false;\n\n    const { data: profile } = await supabase\n      .from('profiles')\n      .select('role')\n      .eq('id', user.id)\n      .single();\n\n    return profile?.role === 'admin';\n  } catch {\n    return false;\n  }\n}\n\nexport async function handleGetRequest(): Promise<NextResponse> {\n  const metrics = await getScrapingMetrics();\n  return NextResponse.json({\n    success: true,\n    data: metrics,\n    timestamp: new Date().toISOString()\n  });\n}\n\nfunction calculateJobStats(typedJobs: Array<{ status?: string; started_at?: string; completed_at?: string }>) {\n  const successfulRuns = typedJobs.filter(job => job.status === 'completed').length;\n  const failedRuns = typedJobs.filter(job => job.status === 'failed').length;\n  const activeJobs = typedJobs.filter(job => job.status === 'running').length;\n  const pendingJobs = typedJobs.filter(job => job.status === 'pending').length;\n\n  const completedJobs = typedJobs.filter(job =>\n    job.status === 'completed' && job.started_at !== undefined && job.completed_at !== undefined\n  );\n\n  let totalRunTime = 0;\n  for (const job of completedJobs) {\n    const start = new Date(job.started_at ?? '').getTime();\n    const end = new Date(job.completed_at ?? '').getTime();\n    totalRunTime += (end - start) / 1000; // Convert to seconds\n  }\n\n  const averageRunTime = completedJobs.length > 0\n    ? Math.round(totalRunTime / completedJobs.length)\n    : 0;\n\n  return { successfulRuns, failedRuns, averageRunTime, activeJobs, pendingJobs };\n}\n\nfunction calculateNewTrucksToday(trucks: Array<{ created_at: string }>) {\n  const today = new Date();\n  today.setHours(0, 0, 0, 0);\n  return trucks.filter(truck => {\n    const createdAt = new Date(truck.created_at);\n    return createdAt >= today;\n  }).length;\n}\n\nasync function getScrapingMetrics(): Promise<RealtimeMetrics> {\n  // Fetch real scraping metrics from database\n  const [allJobs, recentTrucks] = await Promise.all([\n    ScrapingJobService.getAllJobs(100, 0), // Get last 100 jobs for metrics\n    FoodTruckService.getAllTrucks(1000, 0), // Get trucks for processing count\n  ]);\n\n  const totalRuns = allJobs.length;\n  const typedJobs = allJobs as Array<{ status?: string; started_at?: string; completed_at?: string }>;\n\n  const { successfulRuns, failedRuns, averageRunTime, activeJobs, pendingJobs } = calculateJobStats(typedJobs);\n  const newTrucksToday = calculateNewTrucksToday(recentTrucks.trucks as Array<{ created_at: string }>);\n\n  return {\n    scrapingJobs: {\n      active: activeJobs,\n      completed: successfulRuns,\n      failed: failedRuns,\n      pending: pendingJobs,\n    },\n    dataQuality: {\n      averageScore: 0, // Placeholder, actual calculation might be complex\n      totalTrucks: recentTrucks.total, // This remains from the direct fetch\n      recentChanges: 0, // Placeholder\n    },\n    systemHealth: {\n      status: 'healthy',\n      uptime: process.uptime(),\n      lastUpdate: new Date().toISOString(),\n    },\n  };\n}\n","usedDeprecatedRules":[]},{"filePath":"/app/lib/api/admin/scraping-metrics/types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/lib/api/analytics/web-vitals/handlers.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `any[]` assigned to a parameter of type `{ metric_name: string; metric_value: number; rating: string; }[]`.","line":181,"column":45,"nodeType":"Identifier","messageId":"unsafeArgument","endLine":181,"endColumn":52}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { NextRequest, NextResponse } from 'next/server';\nimport { supabaseAdmin } from '@/lib/supabase';\nimport { WebVitalMetric } from './types';\n\n/**\n * Get Web Vitals Analytics Data\n */\nexport function getRequestParams(request: NextRequest) {\n  const { searchParams } = new URL(request.url);\n  const days = Number.parseInt(searchParams.get('days') ?? '7');\n  const page = searchParams.get('page');\n  return { days, page };\n}\n\nexport async function fetchAndFilterMetrics(request: NextRequest) {\n  const { days, page } = getRequestParams(request);\n\n  if (!supabaseAdmin) {\n    throw new Error('Database not available');\n  }\n\n  const startDate = new Date();\n  startDate.setDate(startDate.getDate() - days);\n\n  let query = supabaseAdmin\n    .from('web_vitals_metrics')\n    .select('*')\n    .gte('recorded_at', startDate.toISOString())\n    .order('recorded_at', { ascending: false });\n\n  if (page != undefined && page !== '') {\n    query = query.ilike('page_url', `%${page}%`);\n  }\n\n  const { data: metrics, error } = await query.limit(1000);\n\n  if (error) {\n    throw error;\n  }\n\n  return { metrics: metrics ?? [], days, startDate };\n}\n\n/**\n * Calculate summary statistics for metrics\n */\nexport function calculateMetricsSummary(metrics: { metric_name: string; metric_value: number; rating: string }[]) {\n  const metricTypes: ('LCP' | 'FID' | 'CLS' | 'FCP' | 'TTFB')[] = ['LCP', 'FID', 'CLS', 'FCP', 'TTFB'];\n  const summary: Record<string, {\n    count: number;\n    average: number | undefined;\n    median: number | undefined;\n    p75: number | undefined;\n    p95: number | undefined;\n    goodCount: number;\n    needsImprovementCount: number;\n    poorCount: number;\n  }> = {};\n\n  for (const metricName of metricTypes) {\n    const metricData = metrics.filter(m => m.metric_name === metricName);\n    \n    if (metricData.length === 0) {\n      summary[metricName] = {\n        count: 0,\n        average: undefined,\n        median: undefined,\n        p75: undefined,\n        p95: undefined,\n        goodCount: 0,\n        needsImprovementCount: 0,\n        poorCount: 0\n      };\n      continue;\n    }\n\n    const values = metricData.map(m => m.metric_value).sort((a, b) => a - b);\n    const ratings = metricData.map(m => m.rating);\n\n    summary[metricName] = {\n      count: metricData.length,\n      average: Math.round(values.reduce((sum: number, val: number) => sum + val, 0) / values.length),\n      median: getPercentile(values, 50),\n      p75: getPercentile(values, 75),\n      p95: getPercentile(values, 95),\n      goodCount: ratings.filter(r => r === 'good').length,\n      needsImprovementCount: ratings.filter(r => r === 'needs-improvement').length,\n      poorCount: ratings.filter(r => r === 'poor').length\n    };\n  }\n\n  return summary;\n}\n\n/**\n * Calculate percentile value from sorted array\n */\nexport function getPercentile(sortedValues: number[], percentile: number): number {\n  if (sortedValues.length === 0) return 0;\n  \n  const index = (percentile / 100) * (sortedValues.length - 1);\n  const lower = Math.floor(index);\n  const upper = Math.ceil(index);\n  \n  if (lower === upper) {\n    return Math.round(sortedValues[lower]);\n  }\n  \n  const weight = index - lower;\n  return Math.round(sortedValues[lower] * (1 - weight) + sortedValues[upper] * weight);\n}\n\nfunction validateWebVitalMetric(metric: WebVitalMetric): boolean {\n  return !(!metric.name || typeof metric.value !== 'number' || !metric.url);\n}\n\nasync function storeWebVitalMetric(metric: WebVitalMetric): Promise<void> {\n  if (!supabaseAdmin) {\n    console.warn('Supabase admin client not available. Skipping metric storage.');\n    return;\n  }\n  try {\n    const { error } = await supabaseAdmin\n      .from('web_vitals_metrics')\n      .insert({\n        metric_name: metric.name,\n        metric_value: metric.value,\n        rating: metric.rating,\n        page_url: metric.url,\n        user_agent: metric.userAgent,\n        recorded_at: new Date(metric.timestamp).toISOString()\n      });\n\n    if (error) {\n      console.warn('Failed to store web vital metric:', error);\n      // Don't fail the request - metrics collection should be non-blocking\n    }\n  } catch (dbError) {\n    console.warn('Database error storing web vital:', dbError);\n  }\n}\n\nfunction logPoorPerformance(metric: WebVitalMetric): void {\n  if (metric.rating === 'poor') {\n    console.warn(`Poor ${metric.name} performance detected:`, {\n      value: metric.value,\n      url: metric.url,\n      timestamp: new Date(metric.timestamp).toISOString()\n    });\n  }\n}\n\nexport async function handlePostRequest(request: NextRequest) {\n  try {\n    const metric = await request.json() as WebVitalMetric;\n\n    if (!validateWebVitalMetric(metric)) {\n      return NextResponse.json(\n        { success: false, error: 'Invalid metric data' },\n        { status: 400 }\n      );\n    }\n\n    await storeWebVitalMetric(metric);\n    logPoorPerformance(metric);\n\n    return NextResponse.json({ success: true });\n  } catch (error) {\n    console.error('Web vitals endpoint error:', error);\n    return NextResponse.json(\n      { success: false, error: 'Internal server error' },\n      { status: 500 }\n    );\n  }\n}\n\nexport async function handleGetRequest(request: NextRequest) {\n  try {\n    const { metrics, days, startDate } = await fetchAndFilterMetrics(request);\n\n    const summary = calculateMetricsSummary(metrics);\n\n    return NextResponse.json({\n      success: true,\n      data: {\n        metrics,\n        summary,\n        period: {\n          days,\n          startDate: startDate.toISOString(),\n          endDate: new Date().toISOString()\n        }\n      }\n    });\n  } catch (error) {\n    console.error('Failed to fetch web vitals analytics:', error);\n    return NextResponse.json(\n      { success: false, error: 'Failed to fetch analytics data' },\n      { status: 500 }\n    );\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/app/lib/api/analytics/web-vitals/types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/lib/api/cron/auto-scrape/handlers.ts","messages":[{"ruleId":"unicorn/no-null","severity":1,"message":"Use `undefined` instead of `null`.","line":72,"column":65,"nodeType":"Literal","messageId":"error","endLine":72,"endColumn":69,"fix":{"range":[2307,2311],"text":"undefined"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import { NextRequest, NextResponse } from 'next/server';\nimport { autoScraper } from '@/lib/autoScraper';\nimport { scheduler } from '@/lib/scheduler';\nimport { logActivity } from '@/lib/activityLogger';\nimport { AutoScrapeResult } from './types';\n\nfunction verifyCronSecret(request: NextRequest): NextResponse | null {\n  const authHeader = request.headers.get('authorization');\n  const cronSecret = process.env.CRON_SECRET;\n\n  if (cronSecret === undefined || cronSecret === '') {\n    console.error('CRON_SECRET not configured');\n    return NextResponse.json({ error: 'Server configuration error' }, { status: 500 });\n  }\n\n  if (authHeader !== `Bearer ${cronSecret}`) {\n    console.error('Unauthorized cron attempt:', authHeader);\n    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });\n  }\n  return undefined;\n}\n\nfunction logAutoScrapeStart() {\n  console.info('Starting automated scraping job...');\n  logActivity({\n    type: 'cron_job',\n    action: 'auto_scrape_started',\n    details: { timestamp: new Date().toISOString() },\n  });\n}\n\nfunction logAutoScrapeCompletion(result: AutoScrapeResult) {\n  logActivity({\n    type: 'cron_job',\n    action: 'auto_scrape_completed',\n    details: {\n      timestamp: new Date().toISOString(),\n      trucksProcessed: result.trucksProcessed,\n      newTrucksFound: result.newTrucksFound,\n      errorsCount: result.errors?.length ?? 0,\n    },\n  });\n  console.info('Automated scraping job completed successfully');\n}\n\nfunction logAutoScrapeFailure(error: unknown) {\n  console.error('Auto-scraping cron job failed:', error);\n  logActivity({\n    type: 'cron_job',\n    action: 'auto_scrape_failed',\n    details: {\n      timestamp: new Date().toISOString(),\n      error: error instanceof Error ? error.message : 'Unknown error',\n    },\n  });\n}\n\nexport async function handlePostRequest(request: NextRequest) {\n  try {\n    const authResponse = verifyCronSecret(request);\n    if (authResponse) {\n      return authResponse;\n    }\n\n    logAutoScrapeStart();\n\n    const rawResult = await autoScraper.runAutoScraping();\n    // Map errors to string[] for compatibility\n    const result: AutoScrapeResult = {\n      trucksProcessed: rawResult.trucksProcessed,\n      newTrucksFound: rawResult.newTrucksFound,\n      errors: rawResult.errors?.map(e => e.url + ((e.details != null && e.details !== '') ? `: ${e.details}` : '')),\n    };\n    scheduler.scheduleFollowUpTasks(result);\n    logAutoScrapeCompletion(result);\n\n    return NextResponse.json({\n      success: true,\n      message: 'Auto-scraping completed successfully',\n      data: {\n        trucksProcessed: result.trucksProcessed,\n        newTrucksFound: result.newTrucksFound,\n        timestamp: new Date().toISOString(),\n      },\n    });\n  } catch (error) {\n    logAutoScrapeFailure(error);\n    return NextResponse.json(\n      {\n        success: false,\n        error: 'Auto-scraping failed',\n        message: error instanceof Error ? error.message : 'Unknown error',\n      },\n      { status: 500 },\n    );\n  }\n}\n\nexport function handleGetRequest() {\n  return NextResponse.json(\n    { error: 'Method not allowed. Use POST for cron jobs.' },\n    { status: 405 },\n  );\n}\n","usedDeprecatedRules":[]},{"filePath":"/app/lib/api/cron/auto-scrape/types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/lib/api/firecrawl/handlers.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/lib/api/firecrawl/types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/lib/api/monitoring/api-usage/handlers.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/lib/api/pipeline/handlers.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/lib/api/pipeline/types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/lib/api/scheduler/data.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/lib/api/scheduler/handlers.ts","messages":[],"suppressedMessages":[{"ruleId":"sonarjs/pseudo-random","severity":2,"message":"Make sure that using this pseudorandom number generator is safe here.","line":103,"column":7,"nodeType":"CallExpression","messageId":"safeGenerator","endLine":103,"endColumn":20,"suppressions":[{"kind":"directive","justification":"Math.random is acceptable for simulating task execution."}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/lib/api/scheduler/types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/lib/api/search/data.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/lib/api/search/filters.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/lib/api/search/helpers.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/lib/api/tavily/handlers.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/lib/api/tavily/types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/lib/api/test-integration/helpers.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/lib/api/test-integration/pipelineRunner.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/lib/api/test-integration/pipelineRunnerHelpers.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/lib/api/test-integration/schemaMapper.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":13,"column":8,"nodeType":"Identifier","messageId":"conditionErrorObject","endLine":13,"endColumn":21},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'fullAddress' is assigned a value but never used.","line":19,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":19,"endColumn":20},{"ruleId":"sonarjs/no-unused-vars","severity":2,"message":"Remove the declaration of the unused 'fullAddress' variable.","line":19,"column":9,"nodeType":"Identifier","messageId":"unusedVariable","endLine":19,"endColumn":20},{"ruleId":"sonarjs/no-dead-store","severity":2,"message":"Remove this useless assignment to variable \"fullAddress\".","line":19,"column":9,"nodeType":null,"messageId":"removeAssignment","endLine":19,"endColumn":20},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an error typed value.","line":34,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":34,"endColumn":28},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an error typed value.","line":35,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":35,"endColumn":28}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {\n  ExtractedFoodTruckDetails,\n  FoodTruckSchema,\n  MenuCategory,\n  MenuItem,\n} from '@/lib/types';\n\nexport function mapExtractedDataToTruckSchema(\n  extractedData: ExtractedFoodTruckDetails,\n  sourceUrl: string,\n  isDryRun: boolean,\n): FoodTruckSchema {\n  if (!extractedData || typeof extractedData !== 'object') {\n    throw new Error('Invalid extractedData for mapping.');\n  }\n\n  const name = extractedData.name ?? 'Unknown Test Truck';\n  const locationData = extractedData.current_location ?? {};\n  const fullAddress = [\n    locationData.address,\n    locationData.city,\n    locationData.state,\n    locationData.zip_code,\n  ]\n    .filter(Boolean)\n    .join(', ');\n\n  const _mapCurrentLocation = (\n    currentLocationData?: ExtractedFoodTruckDetails['current_location']\n  ): FoodTruckSchema['current_location']=> {\n    const locData = currentLocationData ?? {};\n    const addr = [locData.address, locData.city, locData.state, locData.zip_code].filter(Boolean).join(', ');\n    return {\n      lat: locData.lat ?? 0,\n      lng: locData.lng ?? 0,\n      address: addr ?? (locData.raw_text ?? undefined),\n      timestamp: new Date().toISOString(),\n    };\n  };\n\n  const _mapMenu = (menu?: MenuCategory[]): FoodTruckSchema['menu'] => {\n    return (menu ?? []).map((category: MenuCategory) => ({\n      name: category.name ?? 'Uncategorized',\n      items: (category.items ?? []).map((item: MenuItem) => ({\n        name: item.name ?? 'Unknown Item',\n        description: item.description ?? undefined,\n        price: typeof item.price === 'number' || typeof item.price === 'string' ? item.price : undefined,\n        dietary_tags: item.dietary_tags ?? [],\n      })),\n    }));\n  };\n\n  return {\n    name: name,\n    description: extractedData.description ?? undefined,\n    current_location: _mapCurrentLocation(extractedData.current_location),\n    scheduled_locations: extractedData.scheduled_locations ?? undefined, // Assuming direct mapping or further helper if complex\n    operating_hours: extractedData.operating_hours ?? undefined, // Assuming direct mapping\n    menu: _mapMenu(extractedData.menu),\n    contact_info: extractedData.contact_info ?? undefined, // Assuming direct mapping\n    social_media: extractedData.social_media ?? undefined, // Assuming direct mapping\n    cuisine_type: extractedData.cuisine_type ?? [],\n    price_range: extractedData.price_range ?? undefined,\n    specialties: extractedData.specialties ?? [],\n    data_quality_score: isDryRun ? 0.5 : 0.6, // Differentiate test/dry run\n    verification_status: 'pending',\n    source_urls: [sourceUrl].filter(Boolean),\n    last_scraped_at: new Date().toISOString(),\n    ...(isDryRun && { test_run_flag: true }), // Add a flag for actual test saves if needed\n  };\n}\n","usedDeprecatedRules":[]},{"filePath":"/app/lib/api/test-integration/stageHandlers.ts","messages":[{"ruleId":"unicorn/no-null","severity":1,"message":"Use `undefined` instead of `null`.","line":68,"column":15,"nodeType":"Literal","messageId":"error","endLine":68,"endColumn":19,"fix":{"range":[2498,2502],"text":"undefined"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import { firecrawl } from '@/lib/firecrawl';\nimport { gemini } from '@/lib/gemini';\nimport { FoodTruckService } from '@/lib/supabase';\nimport {\n  ExtractedFoodTruckDetails,\n  FirecrawlOutputData,\n  GeminiResponse,\n  StageResult,\n  FoodTruckSchema,\n} from '@/lib/types';\nimport { mapExtractedDataToTruckSchema } from './schemaMapper';\n\nfunction getErrorMessage(error: unknown, fallback: string): string {\n  if (error instanceof Error) return error.message;\n  if (typeof error === 'string') return error;\n  return fallback;\n}\n\nasync function handleUrlScrape(\n  url: string,\n  logs: string[],\n): Promise<{ firecrawlResult: StageResult; contentToProcess: string | undefined; sourceUrlForProcessing: string }> {\n  logs.push(`Starting Firecrawl scrape for URL: ${url}`);\n  try {\n    const fcOutput: GeminiResponse<FirecrawlOutputData> =\n      await firecrawl.scrapeFoodTruckWebsite(url);\n    if (fcOutput.success === true && fcOutput.data?.markdown !== undefined && fcOutput.data?.markdown !== '') {\n      return {\n        contentToProcess: fcOutput.data.markdown,\n        sourceUrlForProcessing: fcOutput.data.source_url ?? url,\n        firecrawlResult: {\n          status: 'Success',\n          rawContent: fcOutput.data.markdown,\n          metadata: { name: fcOutput.data.name, source_url: fcOutput.data.source_url },\n          details: `Markdown length: ${fcOutput.data.markdown.length}`,\n        },\n      };\n    } else {\n      throw new Error(fcOutput.error ?? 'Firecrawl failed to return markdown.');\n    }\n  } catch (error) {\n    const errorMessage = getErrorMessage(error, 'An unknown error occurred during Firecrawl scrape.');\n    logs.push(`Firecrawl error: ${errorMessage}`);\n    return { firecrawlResult: { status: 'Error', error: errorMessage }, contentToProcess: undefined, sourceUrlForProcessing: url };\n  }\n}\n\nfunction handleRawTextProcessing(\n  rawText: string,\n  logs: string[],\n): { firecrawlResult: StageResult; contentToProcess: string; sourceUrlForProcessing: string } {\n  logs.push('Using raw text input for processing.');\n  return {\n    contentToProcess: rawText,\n    sourceUrlForProcessing: 'raw_text_input',\n    firecrawlResult: {\n      status: 'Skipped (Raw Text Provided)',\n      details: `Raw text length: ${rawText.length}`,\n    },\n  };\n}\n\nfunction determineFirecrawlStageOutput(\n  url: string,\n  rawText: string | undefined,\n  logs: string[],\n): Promise<{ firecrawlResult: StageResult; contentToProcess: string | undefined; sourceUrlForProcessing: string }> {\n  if ((url != null && url !== '') && rawText === undefined) {\n    return handleUrlScrape(url, logs);\n  } else if (rawText === undefined) {\n    logs.push('No URL or raw text provided.');\n    throw new Error('Either a URL or raw text must be provided for testing.');\n  } else {\n    return Promise.resolve(handleRawTextProcessing(rawText, logs));\n  }\n}\n\nfunction handleEmptyContent(logs: string[]): never {\n  logs.push('Content to process is empty after Firecrawl/raw text stage.');\n  throw new Error('Content to process is empty.');\n}\n\nexport async function handleFirecrawlStage(\n  url: string,\n  rawText: string | undefined,\n  logs: string[],\n): Promise<{\n  firecrawlResult: StageResult;\n  contentToProcess: string | undefined;\n  sourceUrlForProcessing: string;\n}> {\n  const stageOutput = await determineFirecrawlStageOutput(url, rawText, logs);\n\n  if (stageOutput.contentToProcess === undefined) {\n    handleEmptyContent(logs);\n  }\n\n  return stageOutput;\n}\n\nexport async function handleGeminiStage(\n  contentToProcess: string,\n  sourceUrlForProcessing: string,\n  logs: string[],\n): Promise<{ geminiResult: StageResult; extractedData: ExtractedFoodTruckDetails | undefined }> {\n  let geminiResult: StageResult;\n  let extractedData: ExtractedFoodTruckDetails | undefined;\n\n  logs.push('Starting Gemini processing.');\n  try {\n    const geminiOutput: GeminiResponse<ExtractedFoodTruckDetails> =\n      await gemini.extractFoodTruckDetailsFromMarkdown(contentToProcess, sourceUrlForProcessing);\n    if (geminiOutput.success === true && geminiOutput.data !== undefined) {\n      extractedData = geminiOutput.data;\n      geminiResult = {\n        status: 'Success',\n        data: geminiOutput.data,\n        tokensUsed: geminiOutput.tokensUsed,\n        prompt: geminiOutput.promptSent,\n        details: 'Gemini extraction successful.',\n      };\n      logs.push('Gemini processing successful.');\n    } else {\n      throw new Error(geminiOutput.error ?? 'Gemini processing failed to return data.');\n    }\n  } catch (error) {\n    const errorMessage = getErrorMessage(error, 'An unknown error occurred during Gemini processing.');\n    logs.push(`Gemini error: ${errorMessage}`);\n    geminiResult = { status: 'Error', error: errorMessage };\n  }\n  return { geminiResult, extractedData };\n}\n\nasync function saveToSupabase(\n  truckDataToSave: FoodTruckSchema,\n  logs: string[],\n): Promise<StageResult> {\n  logs.push('Attempting to save to Supabase (Dry Run is FALSE).');\n  const createdTruckResult = await FoodTruckService.createTruck(truckDataToSave);\n  if ('error' in createdTruckResult) {\n    throw new Error(`Failed to create truck in Supabase: ${createdTruckResult.error}`);\n  }\n  const createdTruck = createdTruckResult;\n  logs.push(`Data saved to Supabase. Record ID: ${createdTruck.id}`);\n  return {\n    status: 'Success (Saved)',\n    preparedData: truckDataToSave,\n    recordId: createdTruck.id,\n    details: `Truck data saved with ID: ${createdTruck.id}`,\n  };\n}\n\nexport async function handleSupabaseStage(\n  extractedData: ExtractedFoodTruckDetails,\n  sourceUrlForProcessing: string,\n  isDryRun: boolean,\n  logs: string[],\n): Promise<StageResult> {\n  logs.push('Preparing for Supabase interaction.');\n  try {\n    const truckDataToSave = mapExtractedDataToTruckSchema(\n      extractedData,\n      sourceUrlForProcessing,\n      isDryRun,\n    );\n\n    if (isDryRun) {\n      logs.push('Supabase interaction skipped (Dry Run).');\n      return {\n        status: 'Success (Dry Run)',\n        preparedData: truckDataToSave,\n        details: 'Dry Run: Data was prepared but not saved.',\n      };\n    }\n\n    return await saveToSupabase(truckDataToSave, logs);\n  } catch (error) {\n    const errorMessage = getErrorMessage(error, 'An unknown error occurred during Supabase interaction.');\n    logs.push(`Supabase interaction error: ${errorMessage}`);\n    return { status: 'Error', error: errorMessage };\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/app/lib/api/trucks/handlers.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/lib/auth/authHelpers.ts","messages":[{"ruleId":"max-params","severity":2,"message":"Async function 'handleSuccessfulAuth' has too many parameters (5). Maximum allowed is 4.","line":12,"column":8,"nodeType":"FunctionDeclaration","messageId":"exceed","endLine":12,"endColumn":43},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":30,"column":27,"nodeType":"Property","messageId":"anyAssignment","endLine":30,"endColumn":46}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { NextResponse } from 'next/server';\nimport { User } from '@supabase/supabase-js';\nimport { supabase } from '@/lib/supabase';\nimport { RateLimiter } from '@/lib/security/rateLimiter';\nimport { AuditLogger } from '@/lib/security/auditLogger';\n\ninterface RequestMetadata {\n  ip: string;\n  userAgent: string;\n}\n\nexport async function handleSuccessfulAuth(\n  user: User,\n  redirectTo: string,\n  origin: string,\n  identifier: string,\n  requestMetadata: RequestMetadata,\n) {\n  const { data: profile } = await supabase\n    .from('profiles')\n    .select('role')\n    .eq('id', user.id)\n    .single();\n\n  await AuditLogger.logAuthEvent(\n    'login_success',\n    user.email,\n    user.id,\n    requestMetadata,\n    { provider: 'google', role: profile?.role },\n  );\n\n  RateLimiter.recordSuccess(identifier, 'auth');\n\n  if (profile?.role === 'admin') {\n    return NextResponse.redirect(`${origin}${redirectTo}`);\n  } else {\n    await AuditLogger.logSecurityEvent({\n      event_type: 'permission_denied',\n      user_id: user.id,\n      user_email: user.email,\n      ip_address: requestMetadata.ip,\n      user_agent: requestMetadata.userAgent,\n      details: {\n        reason: 'insufficient_role',\n        user_role: profile?.role ?? 'none',\n      },\n      severity: 'warning',\n    });\n    return NextResponse.redirect(`${origin}/access-denied`);\n  }\n}\n\nexport async function handleAuthFailure(\n  error: Error,\n  identifier: string,\n  requestMetadata: RequestMetadata,\n) {\n  await AuditLogger.logAuthEvent(\n    'login_failure',\n    undefined,\n    undefined,\n    requestMetadata,\n    { provider: 'google', error: error.message },\n  );\n}\n","usedDeprecatedRules":[]},{"filePath":"/app/lib/autoScraper.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/lib/config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/lib/data-quality/batchCleanup.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":151,"column":11,"nodeType":"Identifier","messageId":"conditionErrorObject","endLine":151,"endColumn":17},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":325,"column":10,"nodeType":"MemberExpression","messageId":"conditionErrorObject","endLine":325,"endColumn":32},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":380,"column":9,"nodeType":"Identifier","messageId":"conditionErrorObject","endLine":380,"endColumn":26}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * SOTA Batch Data Cleanup System\n * Implements automated data quality improvements and cleanup operations\n */\n\nimport { FoodTruckService, type FoodTruck, DataQualityService } from '@/lib/supabase';\nimport { DuplicatePreventionService } from './duplicatePrevention';\nimport { getPlaceholderPatterns, processTruckForPlaceholders } from './placeholderUtils';\n\nexport interface CleanupOperation {\n  type: 'normalize_phone' | 'fix_coordinates' | 'remove_placeholders' | 'update_quality_scores' | 'merge_duplicates';\n  description: string;\n  affectedCount: number;\n  successCount: number;\n  errorCount: number;\n  errors: string[];\n}\n\nexport interface BatchCleanupResult {\n  totalProcessed: number;\n  operations: CleanupOperation[];\n  summary: {\n    trucksImproved: number;\n    duplicatesRemoved: number;\n    qualityScoreImprovement: number;\n    placeholdersRemoved: number;\n  };\n  duration: number;\n}\n\ninterface MergeOperationContext {\n  operation: CleanupOperation;\n  processedIds: Set<string>;\n}\n\ninterface CoordinateProcessContext {\n  defaultLat: number;\n  defaultLng: number;\n  dryRun: boolean;\n  operation: CleanupOperation;\n}\n\n/**\n * Automated Data Quality Cleanup Service\n */\nexport class BatchCleanupService {\n  \n  /**\n   * Run comprehensive data cleanup operations\n   */\n  static async runFullCleanup(options: {\n    batchSize?: number;\n    dryRun?: boolean;\n    operations?: CleanupOperation['type'][];\n  } = {}): Promise<BatchCleanupResult> {\n    const startTime = Date.now();\n    const { batchSize = 50, dryRun = false, operations = [\n      'remove_placeholders',\n      'normalize_phone',\n      'fix_coordinates',\n      'update_quality_scores',\n      'merge_duplicates'\n    ] } = options;\n\n    console.info(`Starting batch cleanup (${dryRun ? 'DRY RUN' : 'LIVE'})...`);\n    const result = this.initializeCleanupResult();\n    try {\n      const allTrucks = await FoodTruckService.getAllTrucks();\n      result.totalProcessed = allTrucks.total;\n      await this.processTrucksInBatches(allTrucks.trucks, {\n        batchSize,\n        operations,\n        dryRun,\n        result\n      });\n      return this.finalizeCleanupResult(result, startTime);\n    } catch (error) {\n      console.error('Batch cleanup failed:', error);\n      throw error;\n    }\n  }\n\n\n  private static initializeCleanupResult(): BatchCleanupResult {\n    return {\n      totalProcessed: 0,\n      operations: [],\n      summary: {\n        trucksImproved: 0,\n        duplicatesRemoved: 0,\n        qualityScoreImprovement: 0,\n        placeholdersRemoved: 0\n      },\n      duration: 0\n    };\n  }\n\n  private static finalizeCleanupResult(result: BatchCleanupResult, startTime: number): BatchCleanupResult {\n    result.summary = this.calculateSummary(result.operations);\n    result.duration = Date.now() - startTime;\n\n    console.info(`Batch cleanup completed in ${result.duration}ms`);\n    return result;\n  }\n\n  private static async processTrucksInBatches(\n    trucks: FoodTruck[],\n    { batchSize, operations, dryRun, result }: {\n      batchSize: number;\n      operations: CleanupOperation['type'][];\n      dryRun: boolean;\n      result: BatchCleanupResult;\n    }\n  ): Promise<void> {\n    for (let i = 0; i < trucks.length; i += batchSize) {\n      const batch = trucks.slice(i, i + batchSize);\n      for (const op of operations) {\n        const opResult = await this.runOperation(op, batch, dryRun);\n        result.operations.push(opResult);\n      }\n    }\n  }\n  \n  /**\n   * Run a specific cleanup operation\n   */\n  private static async runOperation(\n    type: CleanupOperation['type'],\n    trucks: FoodTruck[],\n    dryRun: boolean\n  ): Promise<CleanupOperation> {\n    const operation: CleanupOperation = {\n      type,\n      description: this.getOperationDescription(type),\n      affectedCount: 0,\n      successCount: 0,\n      errorCount: 0,\n      errors: []\n    };\n    \n    const operationRunners = {\n      remove_placeholders: this.runRemovePlaceholders,\n      normalize_phone: this.runNormalizePhoneNumbers,\n      fix_coordinates: this.runFixCoordinates,\n      update_quality_scores: this.runUpdateQualityScores,\n      merge_duplicates: this.runMergeDuplicates,\n    };\n\n    try {\n      const runner = operationRunners[type];\n      if (runner) {\n        return await runner.call(this, trucks, dryRun, operation);\n      } else {\n        operation.errors.push(`Unknown operation type: ${String(type)}`);\n        return operation;\n      }\n    } catch (error) {\n      operation.errors.push(`Operation failed: ${error instanceof Error ? error.message : String(error)}`);\n      return operation;\n    }\n  }\n\n  private static runRemovePlaceholders = async (trucks: FoodTruck[], dryRun: boolean, operation: CleanupOperation): Promise<CleanupOperation> => {\n    return await this.removePlaceholders(trucks, dryRun, operation);\n  }\n\n  private static runNormalizePhoneNumbers = async (trucks: FoodTruck[], dryRun: boolean, operation: CleanupOperation): Promise<CleanupOperation> => {\n    return await this.normalizePhoneNumbers(trucks, dryRun, operation);\n  }\n\n  private static runFixCoordinates = async (trucks: FoodTruck[], dryRun: boolean, operation: CleanupOperation): Promise<CleanupOperation> => {\n    return await this.fixCoordinates(trucks, dryRun, operation);\n  }\n\n  private static runUpdateQualityScores = async (trucks: FoodTruck[], dryRun: boolean, operation: CleanupOperation): Promise<CleanupOperation> => {\n    return await this.updateQualityScores(trucks, dryRun, operation);\n  }\n\n  private static runMergeDuplicates = async (trucks: FoodTruck[], dryRun: boolean, operation: CleanupOperation): Promise<CleanupOperation> => {\n    return await this.mergeDuplicates(trucks, dryRun, operation);\n  }\n  \n\n  /**\n   * Remove placeholder and mock data\n   */\n  private static async removePlaceholders(\n    trucks: FoodTruck[],\n    dryRun: boolean,\n    operation: CleanupOperation\n  ): Promise<CleanupOperation> {\n    const placeholderPatterns = getPlaceholderPatterns();\n    const promises = trucks.map(truck => \n      this.processSingleTruckForPlaceholders(truck, placeholderPatterns, dryRun, operation)\n    );\n    await Promise.all(promises);\n    return operation;\n  }\n\n  private static async processSingleTruckForPlaceholders(\n    truck: FoodTruck,\n    patterns: RegExp[],\n    dryRun: boolean,\n    operation: CleanupOperation\n  ): Promise<void> {\n    const updates = processTruckForPlaceholders(truck, patterns);\n    if (updates && Object.keys(updates).length > 0) {\n      await this.performUpdateOperation(truck.id, updates, dryRun, operation);\n    }\n  }\n\n  private static async performUpdateOperation(\n    truckId: string,\n    updates: Partial<FoodTruck>,\n    dryRun: boolean,\n    operation: CleanupOperation\n  ): Promise<void> {\n    operation.affectedCount++;\n    if (dryRun) {\n      operation.successCount++;\n    } else {\n      try {\n        await FoodTruckService.updateTruck(truckId, updates);\n        operation.successCount++;\n      } catch (error) {\n        operation.errorCount++;\n        operation.errors.push(`Failed to update truck ${truckId}: ${error instanceof Error ? error.message : String(error)}`);\n      }\n    }\n  }\n  \n  /**\n   * Normalize phone numbers to consistent format\n   */\n  private static async normalizePhoneNumbers(\n    trucks: FoodTruck[],\n    dryRun: boolean,\n    operation: CleanupOperation\n  ): Promise<CleanupOperation> {\n    const promises = trucks.map(truck => {\n      if (truck.contact_info?.phone !== undefined) {\n        const originalPhone = truck.contact_info.phone;\n        const normalizedPhone = this.normalizePhone(originalPhone);\n\n        if (normalizedPhone !== undefined && normalizedPhone !== originalPhone) {\n          return this.applyPhoneNormalizationUpdate(truck, normalizedPhone, dryRun, operation);\n        }\n      }\n      return Promise.resolve();\n    });\n    await Promise.all(promises);\n    return operation;\n  }\n\n  private static async applyPhoneNormalizationUpdate(\n    truck: FoodTruck,\n    normalizedPhone: string,\n    dryRun: boolean,\n    operation: CleanupOperation\n  ): Promise<void> {\n    operation.affectedCount++;\n    if (dryRun) {\n      operation.successCount++;\n    } else {\n      try {\n        await FoodTruckService.updateTruck(truck.id, {\n          contact_info: {\n            ...truck.contact_info,\n            phone: normalizedPhone\n          }\n        });\n        operation.successCount++;\n      } catch (error) {\n        operation.errorCount++;\n        operation.errors.push(`Failed to normalize phone for truck ${truck.id}: ${error instanceof Error ? error.message : String(error)}`);\n      }\n    }\n  }\n  \n  /**\n   * Helper to determine if coordinates need fixing and provide updates\n   */\n  private static getFixedCoordinates(\n    lat: number | undefined,\n    lng: number | undefined,\n    defaultLat: number,\n    defaultLng: number\n  ): Partial<FoodTruck['current_location']> | undefined {\n    // Fix invalid coordinates (0,0 or undefined)\n    if (lat === undefined || lng === undefined || lat === 0 || lng === 0) {\n      return { lat: defaultLat, lng: defaultLng };\n    }\n    // Fix coordinates outside reasonable bounds for Charleston area\n    if (lat < 32 || lat > 34 || lng > -79 || lng < -81) {\n      return { lat: defaultLat, lng: defaultLng };\n    }\n    return undefined;\n  }\n\n  /**\n   * Fix invalid GPS coordinates\n   */\n  private static async fixCoordinates(\n    trucks: FoodTruck[],\n    dryRun: boolean,\n    operation: CleanupOperation\n  ): Promise<CleanupOperation> {\n    const context: Omit<CoordinateProcessContext, 'operation'> = {\n      defaultLat: 32.7767,\n      defaultLng: -79.9311,\n      dryRun,\n    };\n\n    const promises = trucks.map(truck => \n      this.processSingleTruckCoordinates(truck, { ...context, operation })\n    );\n    await Promise.all(promises);\n    return operation;\n  }\n\n  private static async processSingleTruckCoordinates(\n    truck: FoodTruck,\n    context: CoordinateProcessContext\n  ): Promise<void> {\n    if (!truck.current_location) return;\n    const { defaultLat, defaultLng, dryRun, operation } = context;\n    const { lat, lng } = truck.current_location;\n    const updates = this.getFixedCoordinates(lat, lng, defaultLat, defaultLng);\n    if (updates) {\n      await this.applyCoordinateFixUpdate(truck, updates, dryRun, operation);\n    }\n  }\n\n  private static async applyCoordinateFixUpdate(\n    truck: FoodTruck,\n    updates: Partial<FoodTruck['current_location']>,\n    dryRun: boolean,\n    operation: CleanupOperation\n  ): Promise<void> {\n    operation.affectedCount++;\n    if (dryRun) {\n      operation.successCount++;\n    } else {\n      try {\n        await FoodTruckService.updateTruck(truck.id, {\n          current_location: {\n            ...truck.current_location,\n            ...updates,\n          }\n        });\n        operation.successCount++;\n      } catch (error) {\n        operation.errorCount++;\n        operation.errors.push(`Failed to fix coordinates for truck ${truck.id}: ${error instanceof Error ? error.message : String(error)}`);\n      }\n    }\n  }\n\n  /**\n   * Update quality scores for all trucks\n   */\n  private static async updateQualityScores(\n    trucks: FoodTruck[],\n    dryRun: boolean,\n    operation: CleanupOperation\n  ): Promise<CleanupOperation> {\n    const promises = trucks.map(truck => \n      this.processSingleTruckForQualityScore(truck, dryRun, operation)\n    );\n    await Promise.all(promises);\n    return operation;\n  }\n\n  private static async processSingleTruckForQualityScore(\n    truck: FoodTruck,\n    dryRun: boolean,\n    operation: CleanupOperation\n  ): Promise<void> {\n    const qualityAssessment = DataQualityService.calculateQualityScore(truck);\n    if (qualityAssessment) {\n      const newScore = qualityAssessment.score;\n      const currentScore = truck.data_quality_score ?? 0;\n      // Only update if score changed significantly (>5% difference)\n      if (typeof newScore === 'number' && Math.abs(newScore - currentScore) > 0.05) {\n        await this.applyQualityScoreUpdate(truck, dryRun, operation);\n      }\n    }\n  }\n\n  private static async applyQualityScoreUpdate(\n    truck: FoodTruck,\n    dryRun: boolean,\n    operation: CleanupOperation\n  ): Promise<void> {\n    operation.affectedCount++;\n    if (dryRun) {\n      operation.successCount++;\n    } else {\n      try {\n        const updateResult = await DataQualityService.updateTruckQualityScore(truck.id);\n        if ('error' in updateResult) {\n          throw new Error(updateResult.error);\n        }\n        operation.successCount++;\n      } catch (error) {\n        operation.errorCount++;\n        operation.errors.push(`Failed to update quality score for truck ${truck.id}: ${error instanceof Error ? error.message : String(error)}`);\n      }\n    }\n  }\n  \n  /**\n   * Identify and merge duplicate trucks\n   */\n  private static async mergeDuplicates(\n    trucks: FoodTruck[],\n    dryRun: boolean,\n    operation: CleanupOperation\n  ): Promise<CleanupOperation> {\n    const processedIds = new Set<string>();\n    for (const truck of trucks) {\n      await this.processSingleTruckForDuplicates(truck, dryRun, { operation, processedIds });\n    }\n    return operation;\n  }\n\n  private static async processSingleTruckForDuplicates(\n    truck: FoodTruck,\n    dryRun: boolean,\n    context: MergeOperationContext\n  ): Promise<void> {\n    const { processedIds } = context;\n    if (processedIds.has(truck.id)) return;\n\n    const duplicateCheck = await DuplicatePreventionService.checkForDuplicates(truck);\n    if (duplicateCheck.isDuplicate && duplicateCheck.bestMatch?.confidence === 'high' && duplicateCheck.bestMatch.recommendation === 'merge') {\n      await this.applyMergeOperation(truck, duplicateCheck.bestMatch.existingTruck, dryRun, context);\n    }\n    processedIds.add(truck.id);\n  }\n\n  private static async applyMergeOperation(\n    truck: FoodTruck,\n    existingTruck: FoodTruck,\n    dryRun: boolean,\n    context: MergeOperationContext\n  ): Promise<void> {\n    const { operation, processedIds } = context;\n    operation.affectedCount++;\n    if (dryRun) {\n      operation.successCount++;\n    } else {\n      try {\n        const mergeResult = await DuplicatePreventionService.mergeDuplicates(truck.id, existingTruck.id);\n        if ('error' in mergeResult) {\n          throw new Error(mergeResult.error);\n        }\n        processedIds.add(existingTruck.id);\n        operation.successCount++;\n      } catch (error) {\n        operation.errorCount++;\n        operation.errors.push(`Failed to merge duplicates ${truck.id} and ${existingTruck.id}: ${error instanceof Error ? error.message : String(error)}`);\n      }\n    }\n  }\n  \n  /**\n   * Normalize phone number format\n   */\n  private static normalizePhone(phone: string): string | undefined {\n    if (!phone) return undefined;\n    \n    // Remove all non-digit characters\n    const digits = phone.replaceAll(/\\D/g, '');\n    \n    // Handle US phone numbers\n    if (digits.length === 10) {\n      return `(${digits.slice(0, 3)}) ${digits.slice(3, 6)}-${digits.slice(6)}`;\n    }\n    if (digits.length === 11 && digits.startsWith('1')) {\n      return `+1 (${digits.slice(1, 4)}) ${digits.slice(4, 7)}-${digits.slice(7)}`;\n    }\n    \n    // Return original if can't normalize\n    return phone;\n  }\n  \n  /**\n   * Get operation description\n   */\n  private static getOperationDescription(type: CleanupOperation['type']): string {\n    const descriptions = {\n      remove_placeholders: 'Remove placeholder and mock data values',\n      normalize_phone: 'Normalize phone numbers to consistent format',\n      fix_coordinates: 'Fix invalid GPS coordinates',\n      update_quality_scores: 'Recalculate data quality scores',\n      merge_duplicates: 'Identify and merge duplicate truck entries'\n    };\n    \n    return descriptions[type] ?? 'Unknown operation';\n  }\n  \n  /**\n   * Calculate cleanup summary\n   */\n  private static calculateSummary(operations: CleanupOperation[]): BatchCleanupResult['summary'] {\n    return {\n      trucksImproved: operations.reduce((sum, op) => sum + op.successCount, 0),\n      duplicatesRemoved: operations.find(op => op.type === 'merge_duplicates')?.successCount ?? 0,\n      qualityScoreImprovement: operations.find(op => op.type === 'update_quality_scores')?.successCount ?? 0,\n      placeholdersRemoved: operations.find(op => op.type === 'remove_placeholders')?.successCount ?? 0\n    };\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/app/lib/data-quality/duplicatePrevention.ts","messages":[{"ruleId":null,"message":"Unused eslint-disable directive (no problems were reported from 'max-lines-per-function').","line":119,"column":3,"severity":1,"nodeType":null,"fix":{"range":[3834,3963],"text":" "}},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":233,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":233,"endColumn":21,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[7335,7347],"text":"(loc1.address != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[7335,7347],"text":"(loc1.address ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[7335,7347],"text":"(Boolean(loc1.address))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":233,"column":25,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":233,"endColumn":37,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[7351,7363],"text":"(loc2.address != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[7351,7363],"text":"(loc2.address ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[7351,7363],"text":"(Boolean(loc2.address))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":1,"source":"/**\n * SOTA Duplicate Prevention System\n * Implements intelligent duplicate detection and prevention for food truck data\n */\n\nimport { FoodTruckService, type FoodTruck } from '@/lib/supabase';\n\n// Duplicate detection configuration\nexport const DUPLICATE_DETECTION_CONFIG = {\n  // Similarity thresholds (0.0 = no match, 1.0 = exact match)\n  thresholds: {\n    name: 0.85,        // High threshold for name matching\n    location: 0.9,     // Very high threshold for location matching\n    phone: 1,        // Exact match for phone numbers\n    website: 1,      // Exact match for websites\n    overall: 0.8       // Overall similarity threshold\n  },\n  \n  // Weight factors for different fields\n  weights: {\n    name: 0.4,         // 40% weight for name similarity\n    location: 0.3,     // 30% weight for location similarity\n    contact: 0.2,      // 20% weight for contact info similarity\n    menu: 0.1          // 10% weight for menu similarity\n  }\n} as const;\n\nexport interface DuplicateMatch {\n  existingTruck: FoodTruck;\n  similarity: number;\n  matchedFields: string[];\n  confidence: 'high' | 'medium' | 'low';\n  recommendation: 'merge' | 'update' | 'skip' | 'manual_review';\n}\n\nexport interface DuplicateDetectionResult {\n  isDuplicate: boolean;\n  matches: DuplicateMatch[];\n  bestMatch?: DuplicateMatch;\n  action: 'create' | 'update' | 'merge' | 'manual_review';\n  reason: string;\n}\n\n/**\n * Advanced Duplicate Prevention Service\n */\nexport class DuplicatePreventionService {\n  \n  /**\n   * Check if a food truck is a duplicate of existing trucks\n   */\n  static async checkForDuplicates(candidateTruck: Partial<FoodTruck>): Promise<DuplicateDetectionResult> {\n    try {\n      // Get all existing trucks for comparison\n      const existingTrucksResult = await FoodTruckService.getAllTrucks();\n\n      if ('error' in existingTrucksResult) {\n        console.error('Error fetching existing trucks:', existingTrucksResult.error);\n        return {\n          isDuplicate: false,\n          matches: [],\n          action: 'create',\n          reason: `Error fetching existing trucks: ${existingTrucksResult.error}`\n        };\n      }\n\n      const existingTrucks = existingTrucksResult.trucks;\n      const matches: DuplicateMatch[] = [];\n\n      for (const existingTruck of existingTrucks) {\n        const similarity = this.calculateSimilarity(candidateTruck, existingTruck);\n\n        if (similarity.overall >= DUPLICATE_DETECTION_CONFIG.thresholds.overall) {\n          matches.push({\n            existingTruck,\n            similarity: similarity.overall,\n            matchedFields: similarity.matchedFields,\n            confidence: this.getConfidenceLevel(similarity.overall),\n            recommendation: this.getRecommendation(similarity)\n          });\n        }\n      }\n\n      return this.processDuplicateMatches(matches, candidateTruck);\n\n    } catch (error) {\n      console.error('Error checking for duplicates:', error);\n      return {\n        isDuplicate: false,\n        matches: [],\n        action: 'create',\n        reason: 'An unexpected error occurred during duplicate detection - proceeding with creation'\n      };\n    }\n  }\n\n  /**\n   * Processes the matches found during duplicate detection and returns the result.\n   */\n  private static processDuplicateMatches(matches: DuplicateMatch[], candidateTruck: Partial<FoodTruck>): DuplicateDetectionResult {\n    // Sort matches by similarity (highest first)\n    matches.sort((a, b) => b.similarity - a.similarity);\n\n    const bestMatch = matches.length > 0 ? matches[0] : undefined;\n    const isDuplicate = matches.length > 0;\n\n    return {\n      isDuplicate,\n      matches,\n      bestMatch,\n      action: this.determineAction(matches, candidateTruck),\n      reason: this.generateReason(matches, candidateTruck)\n    };\n  }\n  \n  /**\n   * Calculate similarity between two food trucks\n   */\n  // eslint-disable-next-line max-lines-per-function -- Orchestrates multiple field-specific similarity calculations and weighting.\n  private static calculateSimilarity(\n    candidate: Partial<FoodTruck>, \n    existing: FoodTruck\n  ): { overall: number; matchedFields: string[]; breakdown: Record<string, number> } {\n    const breakdown: Record<string, number> = {};\n    const matchedFields: string[] = [];\n    \n    // Name similarity\n    const nameSimilarity = this.calculateStringSimilarity(\n      candidate.name ?? '', \n      existing.name ?? ''\n    );\n    breakdown.name = nameSimilarity;\n    if (nameSimilarity >= DUPLICATE_DETECTION_CONFIG.thresholds.name) {\n      matchedFields.push('name');\n    }\n    \n    // Location similarity\n    const locationSimilarity = this.calculateLocationSimilarity(\n      candidate.current_location,\n      existing.current_location\n    );\n    breakdown.location = locationSimilarity;\n    if (locationSimilarity >= DUPLICATE_DETECTION_CONFIG.thresholds.location) {\n      matchedFields.push('location');\n    }\n    \n    // Contact similarity\n    const contactSimilarity = this.calculateContactSimilarity(\n      candidate.contact_info,\n      existing.contact_info\n    );\n    breakdown.contact = contactSimilarity;\n    if (contactSimilarity >= DUPLICATE_DETECTION_CONFIG.thresholds.phone) {\n      matchedFields.push('contact');\n    }\n    \n    // Menu similarity (basic)\n    const menuSimilarity = this.calculateMenuSimilarity(\n      candidate.menu,\n      existing.menu\n    );\n    breakdown.menu = menuSimilarity;\n    if (menuSimilarity > 0.7) {\n      matchedFields.push('menu');\n    }\n    \n    // Calculate weighted overall similarity\n    const overall = (\n      nameSimilarity * DUPLICATE_DETECTION_CONFIG.weights.name +\n      locationSimilarity * DUPLICATE_DETECTION_CONFIG.weights.location +\n      contactSimilarity * DUPLICATE_DETECTION_CONFIG.weights.contact +\n      menuSimilarity * DUPLICATE_DETECTION_CONFIG.weights.menu\n    );\n    \n    return { overall, matchedFields, breakdown };\n  }\n  \n  /**\n   * Calculate string similarity using Levenshtein distance\n   */\n  private static calculateStringSimilarity(str1: string, str2: string): number {\n    if (!str1 || !str2) return 0;\n    \n    // Normalize strings\n    const s1 = str1.toLowerCase().trim();\n    const s2 = str2.toLowerCase().trim();\n    \n    if (s1 === s2) return 1;\n    \n    // Calculate Levenshtein distance\n    const matrix: number[][] = [];\n    const len1 = s1.length;\n    const len2 = s2.length;\n    \n    for (let i = 0; i <= len1; i++) {\n      matrix[i] = [i];\n    }\n    \n    for (let j = 0; j <= len2; j++) {\n      matrix[0][j] = j;\n    }\n    \n    for (let i = 1; i <= len1; i++) {\n      for (let j = 1; j <= len2; j++) {\n        const cost = s1[i - 1] === s2[j - 1] ? 0 : 1;\n        matrix[i][j] = Math.min(\n          matrix[i - 1][j] + 1,      // deletion\n          matrix[i][j - 1] + 1,      // insertion\n          matrix[i - 1][j - 1] + cost // substitution\n        );\n      }\n    }\n    \n    const distance = matrix[len1][len2];\n    const maxLength = Math.max(len1, len2);\n    \n    return maxLength === 0 ? 1 : 1 - (distance / maxLength);\n  }\n  \n  /**\n   * Calculate location similarity\n   */\n  private static calculateLocationSimilarity(\n    loc1: FoodTruck['current_location'] | undefined | null,\n    loc2: FoodTruck['current_location'] | undefined | null\n  ): number {\n    if (!loc1 || !loc2) return 0;\n    \n    let similarity = 0;\n    let factors = 0;\n    \n    // Address similarity\n    if (loc1.address && loc2.address) {\n      similarity += this.calculateStringSimilarity(loc1.address, loc2.address);\n      factors++;\n    }\n    \n    // GPS coordinate similarity (within 100 meters = high similarity)\n    if (\n      loc1.lat &&\n      loc1.lng &&\n      loc2.lat &&\n      loc2.lng\n    ) {\n      const distance = this.calculateGPSDistance(\n        loc1.lat, loc1.lng,\n        loc2.lat, loc2.lng\n      );\n      \n      // Distance similarity (closer = higher similarity)\n      const distanceSimilarity = distance <= 0.1 ? 1 : Math.max(0, 1 - (distance / 1)); // 1km max\n      similarity += distanceSimilarity;\n      factors++;\n    }\n    \n    return factors > 0 ? similarity / factors : 0;\n  }\n  \n  /**\n   * Calculate GPS distance in kilometers\n   */\n  private static calculateGPSDistance(lat1: number, lng1: number, lat2: number, lng2: number): number {\n    const R = 6371; // Earth's radius in kilometers\n    const dLat = (lat2 - lat1) * Math.PI / 180;\n    const dLng = (lng2 - lng1) * Math.PI / 180;\n    const a = \n      Math.sin(dLat / 2) * Math.sin(dLat / 2) +\n      Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *\n      Math.sin(dLng / 2) * Math.sin(dLng / 2);\n    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n    return R * c;\n  }\n  \n  /**\n   * Calculate contact similarity\n   */\n  private static calculateContactSimilarity(\n    contact1: FoodTruck['contact_info'] | undefined | null,\n    contact2: FoodTruck['contact_info'] | undefined | null\n  ): number {\n    if (!contact1 || !contact2) return 0;\n    \n    let matches = 0;\n    let total = 0;\n    \n    // Phone number exact match\n    if (contact1.phone != undefined && contact2.phone != undefined) {\n      const phone1 = contact1.phone.replaceAll(/\\D/g, ''); // Remove non-digits\n      const phone2 = contact2.phone.replaceAll(/\\D/g, '');\n      if (phone1 === phone2) matches++;\n      total++;\n    }\n    \n    // Website exact match\n    if (contact1.website != undefined && contact2.website != undefined) {\n      const url1 = contact1.website.toLowerCase().replace(/^https?:\\/\\//, '').replace(/\\/$/, '');\n      const url2 = contact2.website.toLowerCase().replace(/^https?:\\/\\//, '').replace(/\\/$/, '');\n      if (url1 === url2) matches++;\n      total++;\n    }\n    \n    // Email similarity\n    if (contact1.email != undefined && contact2.email != undefined) {\n      if (contact1.email.toLowerCase() === contact2.email.toLowerCase()) matches++;\n      total++;\n    }\n    \n    return total > 0 ? matches / total : 0;\n  }\n  \n  /**\n   * Calculate menu similarity (basic implementation)\n   */\n  private static calculateMenuSimilarity(\n    menu1: FoodTruck['menu'] | undefined | null,\n    menu2: FoodTruck['menu'] | undefined | null\n  ): number {\n    if (!menu1 || !menu2 || menu1.length === 0 || menu2.length === 0) return 0;\n    \n    // Simple category name matching\n    const categories1 = menu1.map(cat => (cat as { category?: string }).category?.toLowerCase() ?? '').filter(Boolean);\n    const categories2 = menu2.map(cat => (cat as { category?: string }).category?.toLowerCase() ?? '').filter(Boolean);\n    \n    const commonCategories = categories1.filter(cat => categories2.includes(cat));\n    const totalCategories = new Set([...categories1, ...categories2]).size;\n    \n    return totalCategories > 0 ? commonCategories.length / totalCategories : 0;\n  }\n  \n  /**\n   * Get confidence level based on similarity score\n   */\n  private static getConfidenceLevel(similarity: number): 'high' | 'medium' | 'low' {\n    if (similarity >= 0.95) return 'high';\n    if (similarity >= 0.85) return 'medium';\n    return 'low';\n  }\n  \n  /**\n   * Get recommendation based on similarity analysis\n   */\n  private static getRecommendation(similarity: { overall: number; matchedFields: string[] }): 'merge' | 'update' | 'skip' | 'manual_review' {\n    if (similarity.overall >= 0.95) return 'merge';\n    if (similarity.overall >= 0.9) return 'update';\n    if (similarity.overall >= 0.8) return 'manual_review';\n    return 'skip';\n  }\n  \n  /**\n   * Determine action based on matches\n   */\n  private static determineAction(matches: DuplicateMatch[], _candidate: Partial<FoodTruck>): 'create' | 'update' | 'merge' | 'manual_review' {\n    if (matches.length === 0) return 'create';\n    \n    const bestMatch = matches[0];\n    \n    if (bestMatch.confidence === 'high') {\n      const recommendation = bestMatch.recommendation;\n      if (recommendation === 'merge' || recommendation === 'update') {\n        return recommendation;\n      }\n      return 'manual_review';\n    }\n    \n    return 'manual_review';\n  }\n  \n  /**\n   * Generate human-readable reason\n   */\n  private static generateReason(matches: DuplicateMatch[], _candidate: Partial<FoodTruck>): string {\n    if (matches.length === 0) {\n      return 'No duplicates found - safe to create new truck entry';\n    }\n    \n    const bestMatch = matches[0];\n    const similarity = Math.round(bestMatch.similarity * 100);\n    \n    return `Found ${matches.length} potential duplicate(s). Best match: ${similarity}% similarity with \"${bestMatch.existingTruck.name}\" (matched: ${bestMatch.matchedFields.join(', ')})`;\n  }\n  \n  /**\n   * Merge duplicate truck data intelligently\n   */\n  static async mergeDuplicates(targetId: string, sourceId: string): Promise<FoodTruck | { error: string }> {\n    const targetResult = await FoodTruckService.getTruckById(targetId);\n    const sourceResult = await FoodTruckService.getTruckById(sourceId);\n\n    if ('error' in targetResult) {\n      return { error: `Failed to retrieve target truck with ID ${targetId}: ${targetResult.error}` };\n    }\n    if ('error' in sourceResult) {\n      return { error: `Failed to retrieve source truck with ID ${sourceId}: ${sourceResult.error}` };\n    }\n\n    const target = targetResult;\n    const source = sourceResult;\n\n    // Merge logic: prefer non-null, more complete data\n    const mergedData: Partial<FoodTruck> = {\n      name: target.name ?? source.name,\n      description: target.description ?? source.description,\n      cuisine_type: (target.cuisine_type?.length ?? 0) > 0 ? target.cuisine_type : source.cuisine_type,\n      price_range: target.price_range ?? source.price_range,\n      current_location: target.current_location ?? source.current_location,\n      contact_info: {\n        ...source.contact_info,\n        ...target.contact_info // Target takes precedence\n      },\n      operating_hours: target.operating_hours ?? source.operating_hours,\n      menu: (target.menu?.length ?? 0) > 0 ? target.menu : source.menu,\n      social_media: {\n        ...source.social_media,\n        ...target.social_media\n      },\n      source_urls: [...new Set([...(target.source_urls as string[] ?? []), ...(source.source_urls as string[] ?? [])])],\n      last_scraped_at: new Date().toISOString()\n    };\n\n    // Update target with merged data\n    const updatedTruckResult = await FoodTruckService.updateTruck(targetId, mergedData);\n\n    if ('error' in updatedTruckResult) {\n      return { error: `Failed to update target truck with merged data: ${updatedTruckResult.error}` };\n    }\n\n    console.info(`Merged truck ${sourceId} into ${targetId}`);\n\n    return updatedTruckResult;\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/app/lib/data-quality/placeholderUtils.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":43,"column":7,"nodeType":"MemberExpression","messageId":"conditionErrorObject","endLine":43,"endColumn":25},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":47,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":47,"endColumn":33,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[1295,1319],"text":"(truck.contact_info.phone != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[1295,1319],"text":"(truck.contact_info.phone ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[1295,1319],"text":"(Boolean(truck.contact_info.phone))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":50,"column":16,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":50,"endColumn":40,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[1479,1503],"text":"truck.contact_info.phone != null"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[1479,1503],"text":"truck.contact_info.phone ?? \"\""},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[1479,1503],"text":"Boolean(truck.contact_info.phone)"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":54,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":54,"endColumn":35,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[1575,1601],"text":"(truck.contact_info.website != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[1575,1601],"text":"(truck.contact_info.website ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[1575,1601],"text":"(Boolean(truck.contact_info.website))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":57,"column":16,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":57,"endColumn":42,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[1765,1791],"text":"truck.contact_info.website != null"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[1765,1791],"text":"truck.contact_info.website ?? \"\""},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[1765,1791],"text":"Boolean(truck.contact_info.website)"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":61,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":61,"endColumn":33,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[1867,1891],"text":"(truck.contact_info.email != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[1867,1891],"text":"(truck.contact_info.email ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[1867,1891],"text":"(Boolean(truck.contact_info.email))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":64,"column":16,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":64,"endColumn":40,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[2051,2075],"text":"truck.contact_info.email != null"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[2051,2075],"text":"truck.contact_info.email ?? \"\""},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[2051,2075],"text":"Boolean(truck.contact_info.email)"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":84,"column":7,"nodeType":"ChainExpression","messageId":"conditionErrorNullableString","endLine":84,"endColumn":38,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[3082,3113],"text":"((truck.current_location?.address) != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[3082,3113],"text":"((truck.current_location?.address) ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[3082,3113],"text":"(Boolean((truck.current_location?.address)))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-unnecessary-type-assertion","severity":2,"message":"This assertion is unnecessary since it does not change the type of the expression.","line":86,"column":11,"nodeType":"TSAsExpression","messageId":"unnecessaryAssertion","endLine":86,"endColumn":66,"fix":{"range":[3262,3295],"text":""}},{"ruleId":"unicorn/no-null","severity":1,"message":"Use `undefined` instead of `null`.","line":92,"column":34,"nodeType":"Literal","messageId":"error","endLine":92,"endColumn":38,"suggestions":[{"messageId":"replace","fix":{"range":[3444,3448],"text":"undefined"},"data":{},"desc":"Replace `null` with `undefined`."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":9,"fixableErrorCount":1,"fixableWarningCount":0,"source":"import { type FoodTruck } from '@/lib/supabase';\n\nexport function getPlaceholderPatterns(): RegExp[] {\n  return [\n    /undefined/i,\n    /placeholder/i,\n    /example\\.com/i,\n    /test\\s*truck/i,\n    /lorem\\s*ipsum/i,\n    /\\bna\\b/i,\n    /\\bn\\/a\\b/i,\n    /^0+$/,\n    /^null$/i,\n  ];\n}\n\nexport function processTruckForPlaceholders(\n  truck: FoodTruck,\n  patterns: RegExp[],\n): Partial<FoodTruck> | null {\n  const updates: Partial<FoodTruck> = {};\n  let needsUpdate = false;\n\n  // Check name\n  if (truck.name && patterns.some(pattern => pattern.test(truck.name ?? ''))) {\n    updates.name = undefined;\n    needsUpdate = true;\n  }\n\n  // Check description\n  if (truck.description !== undefined && typeof truck.description === 'string' && patterns.some(pattern => pattern.test(truck.description ?? ''))) {\n    updates.description = undefined;\n    needsUpdate = true;\n  }\n\n  // Check price range\n  if (truck.price_range !== undefined && typeof truck.price_range === 'string' && patterns.some(pattern => pattern.test(truck.price_range ?? ''))) {\n    updates.price_range = undefined;\n    needsUpdate = true;\n  }\n\n  // Check contact info\n  if (truck.contact_info) {\n    const cleanContact: Partial<FoodTruck['contact_info']> = {}; // Initialize as potentially empty\n    let contactUpdated = false;\n\n    if (truck.contact_info.phone && patterns.some(pattern => pattern.test(truck.contact_info.phone ?? ''))) {\n      cleanContact.phone = undefined;\n      contactUpdated = true;\n    } else if (truck.contact_info.phone) {\n      cleanContact.phone = truck.contact_info.phone;\n    }\n\n    if (truck.contact_info.website && patterns.some(pattern => pattern.test(truck.contact_info.website ?? ''))) {\n      cleanContact.website = undefined;\n      contactUpdated = true;\n    } else if (truck.contact_info.website) {\n      cleanContact.website = truck.contact_info.website;\n    }\n\n    if (truck.contact_info.email && patterns.some(pattern => pattern.test(truck.contact_info.email ?? ''))) {\n      cleanContact.email = undefined;\n      contactUpdated = true;\n    } else if (truck.contact_info.email) {\n      cleanContact.email = truck.contact_info.email;\n    }\n    \n    // Only assign cleanContact to updates.contact_info if any part of it was actually modified or if it's intended to overwrite.\n    // If contactUpdated is true, it means at least one field was cleared.\n    // If contactUpdated is false, but we still want to ensure updates.contact_info reflects the (potentially partial) cleanContact,\n    // we need to decide if an empty cleanContact (if all fields were null/undefined originally) should result in updates.contact_info = {}.\n    // For now, only assign if something was actually changed to undefined OR if we want to ensure a \"cleaned\" object structure.\n    // Let's assume we only update if a field was actively cleared.\n    if (contactUpdated) {\n      updates.contact_info = { \n        ...truck.contact_info, // spread original first\n        ...cleanContact       // then overwrite with cleaned/undefined fields\n      };\n      needsUpdate = true;\n    }\n  }\n\n  // Check address\n  if (truck.current_location?.address && patterns.some(pattern => pattern.test(truck.current_location.address ?? ''))) {\n    updates.current_location = {\n      ...(truck.current_location as FoodTruck['current_location']), // Cast to ensure all props are there if spreading\n      address: undefined,\n    };\n    needsUpdate = true;\n  }\n\n  return needsUpdate ? updates : null;\n}\n","usedDeprecatedRules":[]},{"filePath":"/app/lib/discoveryEngine.ts","messages":[{"ruleId":"unicorn/no-negated-condition","severity":2,"message":"Unexpected negated condition.","line":593,"column":13,"nodeType":"UnaryExpression","messageId":"no-negated-condition","endLine":593,"endColumn":23,"fix":{"range":[19436,19797],"text":"testError) {\n          console.info('Optional columns (discovery_method, region, metadata) might be missing in discovered_urls table. Storing basic data.');\n        } else {\n          insertData.discovery_method = discoveryMethod;\n          insertData.region = 'SC'; // Assuming SC if not otherwise specified\n          insertData.metadata = metadata;\n        }"}},{"ruleId":"unicorn/catch-error-name","severity":2,"message":"The catch parameter `e` should be named `error`.","line":601,"column":14,"nodeType":"Identifier","messageId":"catch-error-name","endLine":601,"endColumn":15,"fix":{"range":[19819,19955],"text":"error) {\n      // Catch errors during the test query itself\n      console.info('Error checking for optional columns, storing basic data:', error"}},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":632,"column":11,"nodeType":"Identifier","messageId":"conditionErrorObject","endLine":632,"endColumn":19}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":2,"fixableWarningCount":0,"source":"// lib/discoveryEngine.ts\nimport { supabaseAdmin } from './supabase';\nimport { SC_TARGET_CITIES, DISCOVERY_CONFIG } from './config';\n\nexport interface DiscoveredUrl {\n  url: string;\n  source_directory_url?: string;\n  region?: string;\n  status: 'new' | 'processing' | 'processed' | 'irrelevant';\n  notes?: string;\n}\n\nexport interface DiscoveryResult {\n  urls_discovered: number;\n  urls_stored: number;\n  urls_duplicates: number;\n  errors: string[];\n}\n\n/**\n * Autonomous Discovery Engine\n *\n * This engine discovers new food truck websites across South Carolina using Tavily for search\n * and Firecrawl for crawling. It operates autonomously without human intervention, finding and\n * validating new URLs to add to the discovered_urls table for subsequent scraping.\n *\n * Strategy:\n * 1. Search for food trucks in each SC city using Tavily search\n * 2. Find food truck directories and event listings using Firecrawl crawling\n * 3. Extract individual food truck website URLs from discovered content\n * 4. Validate and filter URLs to avoid false positives\n * 5. Store new URLs in discovered_urls table for processing\n *\n * NOTE: Uses Tavily for search operations and Firecrawl for crawling/scraping\n */\n\n// Helper functions to call APIs\n// Use Tavily for search, Firecrawl for crawling/scraping\ninterface TavilySearchResult {\n  url: string;\n  content?: string;\n  raw_content?: string;\n}\n\nasync function tavilySearch(\n  query: string,\n  options: Record<string, unknown> = {},\n): Promise<TavilySearchResult[]> {\n  const baseUrl = process.env.NEXT_PUBLIC_APP_URL ?? 'http://localhost:3003';\n  const response = await fetch(`${baseUrl}/api/tavily`, {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({\n      operation: 'search',\n      params: {\n        query,\n        limit: options.limit ?? 10,\n        ...options,\n      },\n    }),\n  });\n\n  if (!response.ok) {\n    throw new Error(`Tavily search failed: ${response.statusText}`);\n  }\n\n  const result = (await response.json()) as {\n    data?: { results?: TavilySearchResult[] };\n    results?: TavilySearchResult[];\n  };\n  return result.data?.results ?? result.results ?? [];\n}\n\ninterface CrawlResult {\n  url: string;\n}\n\nasync function firecrawlCrawl(\n  url: string,\n  options: Record<string, unknown> = {},\n): Promise<CrawlResult[]> {\n  const baseUrl = process.env.NEXT_PUBLIC_APP_URL ?? 'http://localhost:3003';\n  const response = await fetch(`${baseUrl}/api/firecrawl`, {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({\n      operation: 'crawl',\n      url,\n      options: {\n        maxDepth: options.maxDepth ?? 2,\n        limit: options.limit ?? 20,\n        ...options,\n      },\n    }),\n  });\n\n  if (!response.ok) {\n    throw new Error(`Firecrawl crawl failed: ${response.statusText}`);\n  }\n\n  const result = (await response.json()) as { data: CrawlResult[] };\n  return result.data ?? [];\n}\n\nexport class FoodTruckDiscoveryEngine {\n  private readonly searchTerms = [\n    'food truck South Carolina',\n    'mobile food vendor SC',\n    'food truck Charleston',\n    'food truck Columbia SC',\n    'food truck Greenville SC',\n    'street food South Carolina',\n    'food truck directory SC',\n  ];\n\n  private readonly directoryUrls = [\n    'https://www.foodtrucksin.com/south-carolina',\n    'https://www.roaminghunger.com/sc/',\n    'https://southcarolinafoodtrucks.com',\n    'https://www.yelp.com/sc/food-trucks',\n  ];\n\n  // Helper method to process search results\n  private async processSearchResults(\n    searchResults: TavilySearchResult[],\n    discoveredUrls: Set<string>,\n  ): Promise<void> {\n    for (const result of searchResults) {\n      if (result.url && (await this.isFoodTruckUrl(result.url))) {\n        discoveredUrls.add(result.url);\n      }\n\n      // Extract URLs from content\n      if (result.content != undefined || result.raw_content != undefined) {\n        const content = result.content ?? result.raw_content ?? '';\n        const extractedUrls = this.extractFoodTruckUrls(content);\n        for (const url of extractedUrls) {\n          if (await this.isFoodTruckUrl(url)) {\n            discoveredUrls.add(url);\n          }\n        }\n      }\n    }\n  }\n\n  // Helper method to perform search term discovery\n  private async performSearchTermDiscovery(\n    discoveredUrls: Set<string>,\n    results: DiscoveryResult,\n  ): Promise<void> {\n    for (const searchTerm of this.searchTerms) {\n      try {\n        console.info(`🔍 Searching for: ${searchTerm}`);\n\n        const searchResults = await tavilySearch(searchTerm, {\n          limit: DISCOVERY_CONFIG.searchResultsLimit,\n        });\n\n        if (searchResults != undefined && searchResults.length > 0) {\n          await this.processSearchResults(searchResults, discoveredUrls);\n        }\n      } catch (error) {\n        console.error(`❌ Search failed for \"${searchTerm}\":`, error);\n        results.errors.push(\n          `Search failed for \"${searchTerm}\": ${error instanceof Error ? error.message : 'Unknown error'}`,\n        );\n      }\n\n      await this.delay(DISCOVERY_CONFIG.rateLimitDelayMs);\n    }\n  }\n\n  // Helper method to perform directory crawling\n  private async performDirectoryCrawling(\n    discoveredUrls: Set<string>,\n    results: DiscoveryResult,\n  ): Promise<void> {\n    for (const directoryUrl of this.directoryUrls) {\n      await this.crawlSingleDirectory(directoryUrl, discoveredUrls, results);\n      await this.delay(DISCOVERY_CONFIG.rateLimitDelayMs);\n    }\n  }\n\n  // Helper method to crawl a single directory\n  private async crawlSingleDirectory(\n    directoryUrl: string,\n    discoveredUrls: Set<string>,\n    results: DiscoveryResult,\n  ): Promise<void> {\n    try {\n      console.info(`🕷️ Crawling directory: ${directoryUrl}`);\n\n      const crawlResults = await firecrawlCrawl(directoryUrl, {\n        maxDepth: DISCOVERY_CONFIG.maxDepthCrawl,\n        limit: DISCOVERY_CONFIG.maxUrlsPerRun,\n      });\n\n      await this.processCrawlResults(crawlResults, discoveredUrls);\n    } catch (error) {\n      console.error(`❌ Crawl failed for ${directoryUrl}:`, error);\n      results.errors.push(\n        `Crawl failed for ${directoryUrl}: ${error instanceof Error ? error.message : 'Unknown error'}`,\n      );\n    }\n  }\n\n  // Helper method to process crawl results\n  private async processCrawlResults(\n    crawlResults: unknown,\n    discoveredUrls: Set<string>,\n  ): Promise<void> {\n    if (crawlResults != undefined && Array.isArray(crawlResults) && crawlResults.length > 0) {\n      for (const result of crawlResults) {\n        if (typeof result === 'object' && result !== null && 'url' in result) {\n          const resultUrl = (result as { url?: string }).url;\n          if (\n            resultUrl != undefined &&\n            typeof resultUrl === 'string' &&\n            (await this.isFoodTruckUrl(resultUrl))\n          ) {\n            discoveredUrls.add(resultUrl);\n          }\n        }\n      }\n    }\n  }\n\n  // Helper method to perform location-specific discovery\n  private async performLocationDiscovery(\n    discoveredUrls: Set<string>,\n    results: DiscoveryResult,\n  ): Promise<void> {\n    for (const city of SC_TARGET_CITIES) {\n      await this.searchSingleCity(city, discoveredUrls, results);\n      await this.delay(DISCOVERY_CONFIG.rateLimitDelayMs);\n    }\n  }\n\n  // Helper method to search a single city\n  private async searchSingleCity(\n    city: string,\n    discoveredUrls: Set<string>,\n    results: DiscoveryResult,\n  ): Promise<void> {\n    try {\n      console.info(`📍 Searching for food trucks in ${city}, SC`);\n      const locationQuery = `food trucks in ${city} South Carolina`;\n      const searchResults = await tavilySearch(locationQuery, {\n        limit: 5,\n      });\n\n      await this.processLocationSearchResults(searchResults, discoveredUrls);\n    } catch (error) {\n      console.error(`❌ Location search failed for ${city}:`, error);\n      results.errors.push(\n        `Location search failed for ${city}: ${error instanceof Error ? error.message : 'Unknown error'}`,\n      );\n    }\n  }\n\n  // Helper method to process location search results\n  private async processLocationSearchResults(\n    searchResults: unknown,\n    discoveredUrls: Set<string>,\n  ): Promise<void> {\n    if (searchResults != undefined && Array.isArray(searchResults) && searchResults.length > 0) {\n      for (const result of searchResults) {\n        if (typeof result === 'object' && result !== null && 'url' in result) {\n          const resultUrl = (result as { url?: string }).url;\n          if (\n            resultUrl != undefined &&\n            typeof resultUrl === 'string' &&\n            (await this.isFoodTruckUrl(resultUrl))\n          ) {\n            discoveredUrls.add(resultUrl);\n          }\n        }\n      }\n    }\n  }\n\n  // Helper method to store discovered URLs from discovery process\n  private async storeDiscoveredUrlsFromDiscovery(\n    discoveredUrls: Set<string>,\n    results: DiscoveryResult,\n  ): Promise<void> {\n    for (const url of discoveredUrls) {\n      try {\n        const stored = await this.storeDiscoveredUrl(url, 'autonomous_search', {\n          search_context: 'full_discovery',\n          discovery_timestamp: new Date().toISOString(),\n        });\n        if (stored.isNew === true) {\n          results.urls_stored++;\n        } else {\n          results.urls_duplicates++;\n        }\n      } catch (error) {\n        console.error(`❌ Failed to store URL ${url}:`, error);\n        results.errors.push(\n          `Failed to store URL ${url}: ${error instanceof Error ? error.message : 'Unknown error'}`,\n        );\n      }\n    }\n  }\n\n  async discoverNewFoodTrucks(): Promise<DiscoveryResult> {\n    console.info('🔍 Starting autonomous food truck discovery...');\n\n    const results: DiscoveryResult = {\n      urls_discovered: 0,\n      urls_stored: 0,\n      urls_duplicates: 0,\n      errors: [],\n    };\n\n    const discoveredUrls = new Set<string>();\n\n    // 1. Search for food trucks using Tavily search\n    await this.performSearchTermDiscovery(discoveredUrls, results);\n\n    // 2. Crawl known food truck directory sites\n    await this.performDirectoryCrawling(discoveredUrls, results);\n\n    // 3. Location-specific discovery for SC cities\n    await this.performLocationDiscovery(discoveredUrls, results);\n\n    results.urls_discovered = discoveredUrls.size;\n    console.info(`🎯 Discovered ${results.urls_discovered} potential food truck URLs`);\n\n    // 4. Store new URLs in database\n    await this.storeDiscoveredUrlsFromDiscovery(discoveredUrls, results);\n\n    console.info(\n      `✅ Discovery complete: ${results.urls_stored} new URLs stored, ${results.urls_duplicates} duplicates skipped`,\n    );\n\n    return results;\n  }\n  private extractFoodTruckUrls(content: string): string[] {\n    const urls: string[] = [];\n\n    // Look for URL patterns in content - using a safer regex to avoid backtracking\n    const urlRegex = /https?:\\/\\/[^\\s<>\"']{1,200}/g;\n    const foundUrls = content.match(urlRegex) ?? [];\n\n    for (const url of foundUrls) {\n      try {\n        // Basic URL validation\n        new URL(url);\n        // Remove trailing punctuation - using safer regex to avoid backtracking\n        const cleanUrl = url.replace(/[.,;!?]$/, '');\n        urls.push(cleanUrl);\n      } catch {\n        // Invalid URL, skip\n        continue;\n      }\n    }\n\n    return urls;\n  }\n\n  private _foodTruckKeywords = [\n    'food-truck', 'foodtruck', 'mobile-food', 'street-food', 'truck', \n    'kitchen', 'eats', 'bbq', 'burger', 'taco', 'catering', 'mobile', \n    'chef', 'bistro', 'cafe',\n  ];\n\n  private _blacklistKeywords = [\n    'facebook.com', 'instagram.com', 'twitter.com', 'linkedin.com', \n    'youtube.com', 'yelp.com', 'google.com', 'maps.google.com', \n    'foursquare.com', 'tripadvisor.com', 'zomato.com', 'eventbrite.com', \n    'meetup.com',\n  ];\n\n  private _hasFoodTruckKeywords(urlLower: string): boolean {\n    return this._foodTruckKeywords.some((keyword) => urlLower.includes(keyword));\n  }\n\n  private _isOnBlacklist(urlLower: string): boolean {\n    return this._blacklistKeywords.some((keyword) => urlLower.includes(keyword));\n  }\n\n  private async _isNewUrlInDiscoveredUrls(url: string): Promise<boolean> {\n    if (!supabaseAdmin) return false; // Already not a food truck URL if supabaseAdmin is undefined\n    const { data: existingDiscovered } = await supabaseAdmin\n      .from('discovered_urls')\n      .select('id', { count: 'exact', head: true })\n      .eq('url', url);\n    return (existingDiscovered?.length ?? 0) > 0;\n  }\n\n  private async _isNewUrlInFoodTrucks(url: string): Promise<boolean> {\n    if (!supabaseAdmin) return false;\n    const { data: existingTrucks } = await supabaseAdmin\n      .from('food_trucks')\n      .select('id', { count: 'exact', head: true })\n      .contains('source_urls', [url]);\n    return (existingTrucks?.length ?? 0) > 0;\n  }\n\n  private async isFoodTruckUrl(url: string): Promise<boolean> {\n    try {\n      new URL(url); // Basic URL validation\n      const urlLower = url.toLowerCase();\n\n      if (this._isOnBlacklist(urlLower)) return false;\n      if (await this._isNewUrlInDiscoveredUrls(url)) return false;\n      if (await this._isNewUrlInFoodTrucks(url)) return false;\n\n      const hasKeywords = this._hasFoodTruckKeywords(urlLower);\n      const isBusinessDomain = /\\.(com|net|org|biz|info)/.test(urlLower) &&\n                              !urlLower.includes('blog') &&\n                              !urlLower.includes('news');\n      \n      return hasKeywords || isBusinessDomain;\n    } catch (error) {\n      console.error(`Error validating food truck URL ${url}:`, error);\n      return false;\n    }\n  }\n\n  async getLocationSpecificDiscovery(city: string, state: string = 'SC'): Promise<DiscoveryResult> {\n    console.info(`🔍 Starting location-specific discovery for ${city}, ${state}`);\n\n    const locationQuery = `food trucks in ${city} ${state}`;\n    const results: DiscoveryResult = {\n      urls_discovered: 0,\n      urls_stored: 0,\n      urls_duplicates: 0,\n      errors: [],\n    };\n\n    const discoveredUrls = new Set<string>();\n\n    try {\n      await this.performLocationSpecificSearch(locationQuery, discoveredUrls);\n      results.urls_discovered = discoveredUrls.size;\n      await this.storeLocationDiscoveryResults({ discoveredUrls, locationQuery, city, state, results });\n    } catch (error) {\n      console.error(`❌ Location search failed for ${city}:`, error);\n      results.errors.push(\n        `Location search failed for ${city}: ${error instanceof Error ? error.message : 'Unknown error'}`,\n      );\n    }\n\n    console.info(\n      `✅ Location discovery complete for ${city}: ${results.urls_stored} new URLs stored`,\n    );\n    return results;\n  }\n\n  // Helper method to perform location-specific search\n  private async performLocationSpecificSearch(\n    locationQuery: string,\n    discoveredUrls: Set<string>,\n  ): Promise<void> {\n    const searchResults = await tavilySearch(locationQuery, { limit: 15 });\n\n    if (searchResults != undefined && searchResults.length > 0) {\n      for (const result of searchResults) {\n        await this.processSearchResult(result, discoveredUrls);\n      }\n    }\n  }\n\n  // Helper method to process a single search result\n  private async processSearchResult(result: unknown, discoveredUrls: Set<string>): Promise<void> {\n    if (typeof result === 'object' && result !== null && 'url' in result) {\n      const resultUrl = (result as { url?: string }).url;\n      if (resultUrl != undefined && resultUrl !== '' && (await this.isFoodTruckUrl(resultUrl))) {\n        discoveredUrls.add(resultUrl);\n      }\n\n      // Extract URLs from content\n      await this.extractUrlsFromContent(result, discoveredUrls);\n    }\n  }\n\n  // Helper method to extract URLs from content\n  private async extractUrlsFromContent(\n    result: unknown,\n    discoveredUrls: Set<string>,\n  ): Promise<void> {\n    if (typeof result === 'object' && result != undefined) {\n      const resultObj = result as { content?: string; raw_content?: string };\n      if (resultObj.content != undefined || resultObj.raw_content != undefined) {\n        const content = resultObj.content ?? resultObj.raw_content ?? '';\n        const extractedUrls = this.extractFoodTruckUrls(content);\n        for (const url of extractedUrls) {\n          if (await this.isFoodTruckUrl(url)) {\n            discoveredUrls.add(url);\n          }\n        }\n      }\n    }\n  }\n\n  // Helper method to store location discovery results\n  private async storeLocationDiscoveryResults(\n    params: {\n      discoveredUrls: Set<string>;\n      locationQuery: string;\n      city: string;\n      state: string;\n      results: DiscoveryResult;\n    }\n  ): Promise<void> {\n    const { discoveredUrls, locationQuery, city, state, results } = params;\n    for (const url of discoveredUrls) {\n      try {\n        const stored = await this.storeDiscoveredUrl(url, 'tavily_search', {\n          search_query: locationQuery,\n          target_city: city,\n          target_state: state,\n        });\n        if (stored.isNew === true) {\n          results.urls_stored++;\n        } else {\n          results.urls_duplicates++;\n        }\n      } catch (error) {\n        console.error(`❌ Failed to store URL ${url}:`, error);\n        results.errors.push(\n          `Failed to store URL ${url}: ${error instanceof Error ? error.message : 'Unknown error'}`,\n        );\n      }\n    }\n  }\n\n  private delay(ms: number): Promise<void> {\n    return new Promise((resolve) => setTimeout(resolve, ms));\n  }\n\n  /**\n   * Store multiple discovered URLs with metadata\n   */\n  async storeDiscoveredUrls(\n    urls: string[],\n    discoveryMethod: string = 'manual',\n    metadata: Record<string, unknown> = {},\n  ): Promise<{\n    urls_stored: number;\n    urls_duplicates: number;\n    errors: string[];\n  }> {\n    const result: {\n      urls_stored: number;\n      urls_duplicates: number;\n      errors: string[];\n    } = {\n      urls_stored: 0,\n      urls_duplicates: 0,\n      errors: [],\n    };\n\n    for (const url of urls) {\n      try {\n        const stored = await this.storeDiscoveredUrl(url, discoveryMethod, metadata);\n        if (stored.isNew === true) {\n          result.urls_stored++;\n        } else {\n          result.urls_duplicates++;\n        }\n      } catch (error) {\n        const errorMsg = `Failed to store URL ${url}: ${error instanceof Error ? error.message : 'Unknown error'}`;\n        result.errors.push(errorMsg);\n        console.error(errorMsg);\n      }\n    }\n\n    return result;\n  }\n\n  private async _prepareInsertData(\n    baseData: { url: string; status: string; notes: string },\n    discoveryMethod: string,\n    metadata: Record<string, unknown>,\n  ): Promise<Record<string, unknown>> {\n    const insertData: Record<string, unknown> = { ...baseData };\n    // Add optional columns only if they exist in the table\n    // This check might be optimistic or could be replaced by a schema check if available\n    try {\n      // Attempt a lightweight query to see if a known optional column exists.\n      // This is not foolproof but can help avoid errors if schema varies.\n      // A more robust solution would involve actual schema introspection if possible.\n      if (supabaseAdmin) { // Ensure supabaseAdmin is defined before using it\n        const { error: testError } = await supabaseAdmin\n          .from('discovered_urls')\n          .select('discovery_method', { count: 'exact', head: true }) \n          .limit(0); // No need to fetch data, just check column existence via query success\n\n        if (!testError) {\n          insertData.discovery_method = discoveryMethod;\n          insertData.region = 'SC'; // Assuming SC if not otherwise specified\n          insertData.metadata = metadata;\n        } else {\n          console.info('Optional columns (discovery_method, region, metadata) might be missing in discovered_urls table. Storing basic data.');\n        }\n      }\n    } catch (e) {\n      // Catch errors during the test query itself\n      console.info('Error checking for optional columns, storing basic data:', e);\n    }\n    return insertData;\n  }\n\n  /**\n   * Enhanced store method with discovery method and metadata\n   */\n  private async storeDiscoveredUrl(\n    url: string,\n    discoveryMethod: string = 'manual',\n    metadata: Record<string, unknown> = {},\n  ): Promise<{ isNew: boolean }> {\n    if (!supabaseAdmin) {\n      throw new Error('Supabase admin client not available for storing URL.');\n    }\n\n    try {\n      // Check if URL already exists\n      const { data: existing, error: selectError } = await supabaseAdmin\n        .from('discovered_urls')\n        .select('id', { count: 'exact', head: true })\n        .eq('url', url);\n\n      if (selectError) {\n        console.error(`Error checking if URL ${url} exists:`, selectError);\n        throw selectError;\n      }\n\n      if (existing && existing.length > 0) {\n        return { isNew: false };\n      }\n\n      const baseInsertData = {\n        url,\n        status: 'new' as const, // Ensure status type is literal\n        notes: `Discovered via ${discoveryMethod}`,\n      };\n      \n      const finalInsertData = await this._prepareInsertData(baseInsertData, discoveryMethod, metadata);\n\n      const { error: insertError } = await supabaseAdmin.from('discovered_urls').insert(finalInsertData);\n\n      if (insertError) {\n        console.error(`Error inserting URL ${url}:`, insertError);\n        throw insertError;\n      }\n\n      return { isNew: true };\n    } catch (error) {\n      // Catch errors from _prepareInsertData or other unexpected issues\n      console.error(`Overall error storing discovered URL ${url}:`, error);\n      // Depending on policy, you might want to re-throw or return a specific error object\n      throw error; // Re-throw to be handled by the caller\n    }\n  }\n\n  /**\n   * Search for food truck directories\n   */\n  async searchFoodTruckDirectories(\n    query: string = 'food truck directory South Carolina',\n  ): Promise<TavilySearchResult[]> {\n    try {\n      return await tavilySearch(query, { limit: 10 });\n    } catch (error) {\n      console.error('Error searching food truck directories:', error);\n      return [];\n    }\n  }\n\n  /**\n   * Search for food truck websites\n   */\n  async searchFoodTruckWebsites(query: string): Promise<TavilySearchResult[]> {\n    try {\n      return await tavilySearch(query, { limit: 15 });\n    } catch (error) {\n      console.error('Error searching food truck websites:', error);\n      return [];\n    }\n  }\n}\n\nexport const discoveryEngine = new FoodTruckDiscoveryEngine();\n","usedDeprecatedRules":[]},{"filePath":"/app/lib/firecrawl.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/lib/gemini.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/lib/gemini/geminiApiClient.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/lib/gemini/promptTemplates.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":223,"column":3,"nodeType":"Identifier","messageId":"conditionErrorNullableString","endLine":223,"endColumn":12,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[7114,7123],"text":"(sourceUrl != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[7114,7123],"text":"(sourceUrl ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[7114,7123],"text":"(Boolean(sourceUrl))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"export const PromptTemplates = {\n  menuProcessing: (rawMenuText: string) => `\nParse the following food truck menu text and return a structured JSON format.\nExtract menu items with categories, names, descriptions, prices, and dietary tags.\n\nMenu text:\n${rawMenuText}\n\nExpected JSON format:\n[\n  {\n    \"category\": \"string\",\n    \"items\": [\n      {\n        \"name\": \"string\",\n        \"description\": \"string\",\n        \"price\": number,\n        \"dietary_tags\": [\"string\"]\n      }\n    ]\n  }\n]\n\nRules:\n- Extract actual prices as numbers (e.g., 12.99, not \"$12.99\")\n- Include dietary restrictions and special tags\n- Group items into logical categories\n- If no clear categories, use \"Main Items\"\n- Return only the json, no additional text\n  `,\n\n  locationExtraction: (textInput: string) => `\nExtract location information from the following text and return structured data.\nLook for addresses, cross streets, landmarks, or location descriptions.\n\nText:\n${textInput}\n\nExpected JSON format:\n{\n  \"address\": \"string or undefined\",\n  \"city\": \"string or undefined\", \n  \"state\": \"string or undefined\",\n  \"zipCode\": \"string or undefined\",\n  \"coordinates\": {\"lat\": number, \"lng\": number} or undefined,\n  \"confidence\": number,\n  \"landmarks\": [\"string\"]\n}\n\nRules:\n- Set coordinates to undefined if not explicitly provided\n- Confidence should be 0.0 to 1.0 based on clarity\n- Include any mentioned landmarks or cross streets\n- Return only the json, no additional text\n  `,\n\n  operatingHours: (hoursText: string) => `\nParse the following operating hours text and return standardized format.\nConvert all times to 24-hour format and handle various input formats.\n\nHours text:\n${hoursText}\n\nExpected JSON format:\n{\n  \"monday\": {\"open\": \"HH:MM\", \"close\": \"HH:MM\", \"closed\": false},\n  \"tuesday\": {\"open\": \"HH:MM\", \"close\": \"HH:MM\", \"closed\": false},\n  \"wednesday\": {\"open\": \"HH:MM\", \"close\": \"HH:MM\", \"closed\": false},\n  \"thursday\": {\"open\": \"HH:MM\", \"close\": \"HH:MM\", \"closed\": false},\n  \"friday\": {\"open\": \"HH:MM\", \"close\": \"HH:MM\", \"closed\": false},\n  \"saturday\": {\"open\": \"HH:MM\", \"close\": \"HH:MM\", \"closed\": false},\n  \"sunday\": {\"open\": \"HH:MM\", \"close\": \"HH:MM\", \"closed\": false}\n}\n\nRules:\n- Use 24-hour format (e.g., \"14:30\" for 2:30 pm)\n- If closed on a day, set \"closed\": true and omit open/close times\n- Handle ranges like \"Mon-Fri\" by applying to all days in range\n- Default to reasonable hours if ambiguous\n- Return only the json, no additional text\n  `,\n\n  sentimentAnalysis: (reviewText: string) => `\nAnalyze the sentiment of this food truck review and extract key insights.\nFocus on food quality, service, value, and overall experience.\n\nReview text:\n${reviewText}\n\nExpected JSON format:\n{\n  \"score\": number,\n  \"confidence\": number,\n  \"aspects\": {\n    \"food_quality\": number,\n    \"service\": number,\n    \"value\": number,\n    \"overall\": number\n  },\n  \"summary\": \"string\",\n  \"keywords\": [\"string\"]\n}\n\nRules:\n- Score should be 0.0 (very negative) to 1.0 (very positive)\n- Confidence should be 0.0 to 1.0 based on clarity of sentiment\n- Include specific aspects mentioned in the review\n- Summary should be 1-2 sentences max\n- Return only the json, no additional text\n  `,\n\n  dataEnhancement: (rawData: unknown) => `\nEnhance and standardize the following food truck data.\nFill in missing information where possible and improve data quality.\n\nRaw data:\n${JSON.stringify(rawData, undefined, 2)}\n\nExpected JSON format:\n{\n  \"name\": \"string\",\n  \"description\": \"string\",\n  \"cuisine_type\": \"string\",\n  \"price_range\": \"$ | $$ | $$$ | $$$$\",\n  \"contact\": {\n    \"phone\": \"string\",\n    \"email\": \"string\",\n    \"website\": \"string\",\n    \"social_media\": {}\n  },\n  \"location\": {\n    \"address\": \"string\",\n    \"city\": \"string\",\n    \"state\": \"string\",\n    \"coordinates\": {\"lat\": number, \"lng\": number}\n  },\n  \"operating_hours\": {},\n  \"menu_categories\": [\"string\"],\n  \"specialties\": [\"string\"],\n  \"dietary_options\": [\"string\"]\n}\n\nRules:\n- Preserve all original data while enhancing it\n- Standardize naming conventions\n- Infer cuisine type from menu items\n- Estimate price range from menu prices\n- Return only the json, no additional text\n  `,\n\n  _foodTruckExtractionSchema: `\nExpected JSON schema:\n{\n  \"name\": \"string (food truck name)\",\n  \"description\": \"string (brief description of the food truck)\",\n  \"cuisine_type\": \"string (type of cuisine served)\",\n  \"contact\": {\n    \"phone\": \"string (phone number if found)\",\n    \"email\": \"string (email if found)\", \n    \"website\": \"string (website URL if found)\",\n    \"social_media\": {\n      \"facebook\": \"string (Facebook URL if found)\",\n      \"instagram\": \"string (Instagram URL if found)\",\n      \"twitter\": \"string (Twitter URL if found)\"\n    }\n  },\n  \"location\": {\n    \"address\": \"string (physical address if found)\",\n    \"city\": \"string (city name)\",\n    \"state\": \"string (state abbreviation)\",\n    \"coordinates\": {\n      \"lat\": \"number (latitude if found)\",\n      \"lng\": \"number (longitude if found)\"\n    }\n  },\n  \"operating_hours\": {\n    \"monday\": {\"open\": \"string (HH:MM)\", \"close\": \"string (HH:MM)\", \"closed\": \"boolean\"},\n    \"tuesday\": {\"open\": \"string (HH:MM)\", \"close\": \"string (HH:MM)\", \"closed\": \"boolean\"},\n    \"wednesday\": {\"open\": \"string (HH:MM)\", \"close\": \"string (HH:MM)\", \"closed\": \"boolean\"},\n    \"thursday\": {\"open\": \"string (HH:MM)\", \"close\": \"string (HH:MM)\", \"closed\": \"boolean\"},\n    \"friday\": {\"open\": \"string (HH:MM)\", \"close\": \"string (HH:MM)\", \"closed\": \"boolean\"},\n    \"saturday\": {\"open\": \"string (HH:MM)\", \"close\": \"string (HH:MM)\", \"closed\": \"boolean\"},\n    \"sunday\": {\"open\": \"string (HH:MM)\", \"close\": \"string (HH:MM)\", \"closed\": \"boolean\"}\n  },\n  \"menu\": [\n    {\n      \"category\": \"string (menu category)\",\n      \"items\": [\n        {\n          \"name\": \"string (item name)\",\n          \"description\": \"string (item description)\",\n          \"price\": \"number (price as number, not string)\",\n          \"dietary_tags\": [\"string (dietary restrictions/tags)\"]\n        }\n      ]\n    }\n  ],\n  \"specialties\": [\"string (signature dishes or specialties)\"],\n  \"dietary_options\": [\"string (dietary accommodations like vegan, gluten-free)\"],\n  \"price_range\": \"string ($ for under $10, $$ for $10-20, $$$ for $20-30, $$$$ for over $30)\"\n}\n`,\n\n  _foodTruckExtractionInstructions: `\nInstructions:\n- Extract as much information as possible from the provided content\n- If information is not available, use null for the field\n- For operating hours, use 24-hour format (e.g., \"14:30\" for 2:30 PM)\n- If a day is closed, set \"closed\": true and omit open/close times\n- For prices, extract numeric values only (e.g., 12.99, not \"$12.99\")\n- Be thorough in extracting menu items and their details\n- Look for social media links and contact information carefully\n- Return only the JSON object, no additional text or formatting\n`,\n\n  foodTruckExtraction(markdownContent: string, sourceUrl?: string) {\n    return `\nYou are an ai assistant tasked with extracting structured information about food trucks from their website content (provided in Markdown format). Your goal is to populate a json object with the following schema. Only return the json object, nothing else.\n\nWebsite content:\n${markdownContent}\n\n${sourceUrl ? `Source URL: ${sourceUrl}` : ''}\n\n${this._foodTruckExtractionSchema}\n\n${this._foodTruckExtractionInstructions}\n`;\n  }\n};\n","usedDeprecatedRules":[]},{"filePath":"/app/lib/gemini/responseParser.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/lib/gemini/usageLimits.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'limits' is assigned a value but never used. Allowed unused args must match /^_/u.","line":60,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":60,"endColumn":11}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { APIUsageService } from '../supabase';\nimport { APIMonitor } from '../monitoring/apiMonitor';\n\nexport interface UsageLimits {\n  dailyRequestLimit: number;\n  dailyTokenLimit: number;\n}\n\nexport interface UsageCheck {\n  canMakeRequest: boolean;\n  usage?: {\n    requests: { used: number; limit: number; remaining: number };\n    tokens: { used: number; limit: number; remaining: number };\n  };\n}\n\nexport class GeminiUsageLimits {\n  private static readonly DEFAULT_LIMITS: UsageLimits = {\n    dailyRequestLimit: 1500,\n    dailyTokenLimit: 32_000,\n  };\n\n  static async checkUsageLimits(limits: UsageLimits = this.DEFAULT_LIMITS): Promise<UsageCheck> {\n    try {\n      const usage = await APIUsageService.getTodayUsage('gemini');\n\n      if (!usage) {\n        return { canMakeRequest: true };\n      }\n\n      const requestsUsed = usage.requests_count ?? 0;\n      const tokensUsed = usage.tokens_used ?? 0;\n\n      const requestsRemaining = limits.dailyRequestLimit - requestsUsed;\n      const tokensRemaining = limits.dailyTokenLimit - tokensUsed;\n\n      return {\n        canMakeRequest: requestsRemaining > 0 && tokensRemaining > 100, // Keep 100 token buffer\n        usage: {\n          requests: {\n            used: requestsUsed,\n            limit: limits.dailyRequestLimit,\n            remaining: requestsRemaining,\n          },\n          tokens: {\n            used: tokensUsed,\n            limit: limits.dailyTokenLimit,\n            remaining: tokensRemaining,\n          },\n        },\n      };\n    } catch (error: unknown) {\n      console.warn('Error checking Gemini usage limits:', error);\n      return { canMakeRequest: false };\n    }\n  }\n\n  static async checkWithMonitoring(\n    estimatedTokens: number,\n    limits: UsageLimits = this.DEFAULT_LIMITS\n  ): Promise<{ allowed: boolean; reason?: string; waitTime?: number }> {\n    const canMakeRequest = await APIMonitor.canMakeRequest('gemini', 1, estimatedTokens);\n\n    if (!canMakeRequest.allowed) {\n      return {\n        allowed: false,\n        reason: `API limit reached: ${canMakeRequest.reason}. Wait time: ${Math.ceil((canMakeRequest.waitTime ?? 0) / 1000 / 60)} minutes`,\n      };\n    }\n\n    return { allowed: true };\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/app/lib/middleware/middlewareHelpers.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":33,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":33,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[728,731],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[728,731],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"max-params","severity":2,"message":"Async function 'logSecurityEventAndRedirect' has too many parameters (5). Maximum allowed is 4.","line":39,"column":1,"nodeType":"FunctionDeclaration","messageId":"exceed","endLine":39,"endColumn":43},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":49,"column":7,"nodeType":"Identifier","messageId":"conditionErrorNullableString","endLine":49,"endColumn":23,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[1134,1150],"text":"redirectFromPath != null"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[1134,1150],"text":"redirectFromPath ?? \"\""},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[1134,1150],"text":"Boolean(redirectFromPath)"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"unicorn/no-null","severity":1,"message":"Use `undefined` instead of `null`.","line":121,"column":88,"nodeType":"Literal","messageId":"error","endLine":121,"endColumn":92,"suggestions":[{"messageId":"replace","fix":{"range":[3509,3513],"text":"undefined"},"data":{},"desc":"Replace `null` with `undefined`."}]},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a(n) `error` type typed value.","line":124,"column":11,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":124,"endColumn":36}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { NextRequest, NextResponse } from 'next/server';\nimport { AuditLogger, SecurityEvent } from '@/lib/security/auditLogger';\nimport { createSupabaseMiddlewareClient } from '@/lib/supabaseMiddleware';\n\ninterface RequestMetadata {\n  ip: string;\n  userAgent: string;\n  url: string;\n  method: string;\n}\n\ninterface SupabaseUser {\n  id: string;\n  email?: string;\n}\n\ninterface SupabaseProfile {\n  role?: string;\n}\n\ninterface LogAndRedirectParams {\n  req: NextRequest;\n  res: NextResponse;\n  requestMetadata: RequestMetadata;\n  reason: string;\n  userError?: { message?: string };\n}\n\ninterface LogSecurityEventParams {\n  event_type: SecurityEvent['event_type'];\n  ip_address: string;\n  user_agent: string;\n  details: Record<string, any>;\n  severity: SecurityEvent['severity'];\n  user_id?: string;\n  user_email?: string;\n}\n\nasync function logSecurityEventAndRedirect(\n  req: NextRequest,\n  res: NextResponse,\n  logParams: LogSecurityEventParams,\n  redirectPath: string,\n  redirectFromPath?: string\n) {\n  await AuditLogger.logSecurityEvent(logParams);\n  const redirectUrl = req.nextUrl.clone();\n  redirectUrl.pathname = redirectPath;\n  if (redirectFromPath) {\n    redirectUrl.searchParams.set(`redirectedFrom`, redirectFromPath);\n  }\n  return NextResponse.redirect(redirectUrl);\n}\n\nasync function logAndRedirect({ req, res, requestMetadata, reason, userError }: LogAndRedirectParams) {\n  return logSecurityEventAndRedirect(\n    req,\n    res,\n    {\n      event_type: 'permission_denied',\n      ip_address: requestMetadata.ip,\n      user_agent: requestMetadata.userAgent,\n      details: {\n        attempted_url: requestMetadata.url,\n        reason,\n        error: userError?.message,\n      },\n      severity: 'warning',\n    },\n    '/login',\n    req.nextUrl.pathname\n  );\n}\n\ninterface LogAndRedirectDeniedParams {\n  req: NextRequest;\n  res: NextResponse;\n  requestMetadata: RequestMetadata;\n  user: SupabaseUser;\n  profile: SupabaseProfile | null;\n  profileQueryError?: { message?: string } | null; // Changed to allow null\n}\n\nasync function logAndRedirectDenied({ req, res, requestMetadata, user, profile, profileQueryError }: LogAndRedirectDeniedParams) {\n  return logSecurityEventAndRedirect(\n    req,\n    res,\n    {\n      event_type: 'permission_denied',\n      user_id: user.id,\n      user_email: user.email ?? undefined,\n      ip_address: requestMetadata.ip,\n      user_agent: requestMetadata.userAgent,\n      details: {\n        attempted_url: requestMetadata.url,\n        user_role: profile?.role ?? 'none',\n        reason: 'insufficient_privileges',\n        error: profileQueryError?.message,\n      },\n      severity: 'error',\n    },\n    '/access-denied'\n  );\n}\n\nexport async function protectAdminRoutes(req: NextRequest, res: NextResponse, requestMetadata: RequestMetadata) {\n  const supabase = createSupabaseMiddlewareClient(req, res);\n  const { data, error: userError } = await supabase.auth.getUser();\n  const user = data?.user;\n\n  if (userError || !user) {\n    return logAndRedirect({ req, res, requestMetadata, reason: 'no_session', userError: userError ?? undefined });\n  }\n  // Explicitly type the result of the Supabase query\n  const { data: profile, error: profileQueryError } = await supabase\n    .from('profiles')\n    .select('role')\n    .eq('id', user.id)\n    .single() as { data: SupabaseProfile | null; error: { message?: string } | null };\n  if (profileQueryError || (profile && profile.role !== 'admin')) {\n    return logAndRedirectDenied({ req, res, requestMetadata, user, profile: profile ?? null, profileQueryError: profileQueryError ?? undefined });\n  }\n  if (req.method !== 'GET' || req.nextUrl.pathname.includes('/api/')) {\n    await AuditLogger.logDataAccess(\n      user.id,\n      user.email ?? 'unknown',\n      'admin_panel',\n      req.nextUrl.pathname,\n      req.method === 'GET' ? 'read' : 'admin_access',\n      {\n        ip: requestMetadata.ip,\n        userAgent: requestMetadata.userAgent,\n      },\n    );\n  }\n  return res;\n}\n","usedDeprecatedRules":[]},{"filePath":"/app/lib/monitoring/apiMonitor.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/lib/performance/bundleAnalyzer.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/lib/performance/databaseCache.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of type `any[]` to a variable of type `FoodTruck[]`.","line":118,"column":11,"nodeType":"VariableDeclarator","messageId":"unsafeAssignment","endLine":118,"endColumn":46}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * SOTA Database Query Optimization and Caching\n * Implements Next.js unstable_cache for optimal performance\n */\n\nimport { unstable_cache } from 'next/cache';\nimport { supabaseAdmin, FoodTruckService } from '@/lib/supabase';\nimport type { FoodTruck } from '@/lib/types';\n\n// Cache configuration\nconst CACHE_CONFIG = {\n  // Short-term cache for frequently changing data\n  SHORT_TTL: 60 * 5, // 5 minutes\n  // Medium-term cache for semi-static data\n  MEDIUM_TTL: 60 * 30, // 30 minutes\n  // Long-term cache for static data\n  LONG_TTL: 60 * 60 * 24, // 24 hours\n} as const;\n\n/**\n * Cached food truck queries with optimized database access\n */\nexport const CachedFoodTruckService = {\n  /**\n   * Get all food trucks with caching\n   * Cache for 30 minutes since truck data changes moderately\n   */\n  getAllTrucksCached : unstable_cache(\n    async (): Promise<{ trucks: FoodTruck[]; count: number }> => {\n      console.info('CachedFoodTruckService: Cache miss - fetching all trucks from database');\n      const result = await FoodTruckService.getAllTrucks();\n      if ('error' in result) {\n        throw new Error(`Failed to fetch all trucks: ${result.error}`);\n      }\n      return { trucks: result.trucks, count: result.total };\n    },\n    ['all-trucks'],\n    {\n      revalidate: CACHE_CONFIG.MEDIUM_TTL,\n      tags: ['food-trucks', 'all-trucks']\n    }\n  ),\n\n  /**\n   * Get trucks by location with caching\n   * Cache for 5 minutes since location-based queries are time-sensitive\n   */\n  getTrucksByLocationCached : unstable_cache(\n    async (lat: number, lng: number, radiusKm: number): Promise<FoodTruck[]> => {\n      console.info(`CachedFoodTruckService: Cache miss - fetching trucks near ${lat},${lng} (${radiusKm}km)`);\n      const result = await FoodTruckService.getTrucksByLocation(lat, lng, radiusKm);\n      if ('error' in result) {\n        throw new Error(`Failed to fetch trucks by location: ${result.error}`);\n      }\n      return result;\n    },\n    ['trucks-by-location'],\n    {\n      revalidate: CACHE_CONFIG.SHORT_TTL,\n      tags: ['food-trucks', 'location-search']\n    }\n  ),\n\n  /**\n   * Get truck by ID with caching\n   * Cache for 30 minutes since individual truck data is relatively stable\n   */\n  getTruckByIdCached : unstable_cache(\n    async (id: string): Promise<FoodTruck | null> => {\n      console.info(`CachedFoodTruckService: Cache miss - fetching truck ${id} from database`);\n      const result = await FoodTruckService.getTruckById(id);\n      if ('error' in result) {\n        throw new Error(`Failed to fetch truck by ID: ${result.error}`);\n      }\n      return result;\n    },\n    ['truck-by-id'],\n    {\n      revalidate: CACHE_CONFIG.MEDIUM_TTL,\n      tags: ['food-trucks', 'truck-details']\n    }\n  ),\n\n  /**\n   * Search trucks with caching\n   * Cache for 5 minutes since search results should be relatively fresh\n   */\n  searchTrucksCached : unstable_cache(\n    async (query: string, filters?: {\n      cuisine?: string;\n      openNow?: boolean;\n      lat?: number;\n      lng?: number;\n      radius?: number;\n    }): Promise<FoodTruck[]> => {\n      console.info(`CachedFoodTruckService: Cache miss - searching trucks for \"${query}\"`);\n      \n      if (supabaseAdmin == undefined) {\n        throw new Error('Supabase admin client not available');\n      }\n\n      let dbQuery = supabaseAdmin\n        .from('food_trucks')\n        .select('*')\n        .or(`name.ilike.%${query}%,description.ilike.%${query}%,cuisine_type.cs.{${query}}`);\n\n      // Apply filters\n      if (filters?.cuisine != undefined && filters.cuisine !== '') {\n        dbQuery = dbQuery.contains('cuisine_type', [filters.cuisine]);\n      }\n\n      const { data: trucks, error } = await dbQuery.limit(50);\n\n      if (error != undefined) {\n        throw new Error(`Search query failed: ${error.message}`);\n      }\n\n      let results: FoodTruck[] = trucks ?? [];\n\n      // Apply location filter if provided\n      if (filters?.lat != undefined && filters?.lng != undefined && filters?.radius != undefined) {\n        results = results.filter((truck: FoodTruck): truck is FoodTruck => {\n          if (truck.current_location?.lat == undefined || truck.current_location?.lng == undefined) {\n            return false;\n          }\n          const distance = calculateDistance(\n            filters.lat!, // Assert as number, as it's checked by the outer if condition\n            filters.lng!, // Assert as number, as it's checked by the outer if condition\n            truck.current_location.lat,\n            truck.current_location.lng\n          );\n          return distance <= (filters.radius ?? 10);\n        });\n      }\n\n      // Apply openNow filter if provided\n      if (filters?.openNow === true) {\n        const now = new Date();\n        const currentDay = now.toLocaleDateString('en-US', { weekday: 'short' }).toLowerCase(); // 'mon', 'tue', etc.\n        const currentTime = now.getHours() * 100 + now.getMinutes(); // HHMM format\n\n        results = results.filter((truck: FoodTruck): truck is FoodTruck => {\n          const hours = truck.operating_hours?.[currentDay as keyof typeof truck.operating_hours] as { closed?: boolean; open?: string; close?: string } | undefined;\n          if (hours == undefined || hours.closed === true) return false;\n\n          const openTime = parseTimeString(hours.open ?? '');\n          const closeTime = parseTimeString(hours.close ?? '');\n\n          return currentTime >= openTime && currentTime <= closeTime;\n        });\n      }\n\n      return results;\n    },\n    ['search-trucks'],\n    {\n      revalidate: CACHE_CONFIG.SHORT_TTL,\n      tags: ['food-trucks', 'search']\n    }\n  ),\n\n  /**\n   * Get data quality statistics with caching\n   * Cache for 24 hours since quality stats change slowly\n   */\n  getDataQualityStatsCached : unstable_cache(\n    async (): Promise<{\n      averageScore: number;\n      distribution: Record<string, number>;\n      totalTrucks: number;\n    }> => {\n      console.info('CachedFoodTruckService: Cache miss - calculating data quality stats');\n      \n      if (supabaseAdmin == undefined) {\n        throw new Error('Supabase admin client not available');\n      }\n\n      const { data: trucks, error } = await supabaseAdmin\n        .from('food_trucks')\n        .select('data_quality_score');\n\n      if (error) {\n        throw new Error(`Quality stats query failed: ${error.message}`);\n      }\n\n      const scores = trucks == undefined ? [] : trucks.map((t: { data_quality_score?: number }) => t.data_quality_score ?? 0);\n      const averageScore = scores.length > 0\n        ? scores.reduce((sum: number, score: number) => sum + score, 0) / scores.length\n        : 0;\n\n      const distribution = {\n        high: scores.filter((s: number) => s >= 0.8).length,\n        medium: scores.filter((s: number) => s >= 0.6 && s < 0.8).length,\n        low: scores.filter((s: number) => s < 0.6).length\n      };\n\n      return {\n        averageScore: Math.round(averageScore * 100) / 100,\n        distribution,\n        totalTrucks: scores.length\n      };\n    },\n    ['data-quality-stats'],\n    {\n      revalidate: CACHE_CONFIG.LONG_TTL,\n      tags: ['food-trucks', 'data-quality']\n    }\n  ),\n};\n\n/**\n * Cache invalidation utilities\n */\nexport const CacheManager = {\n  /**\n   * Invalidate all food truck related caches\n   */\n  async invalidateAllFoodTruckCaches(): Promise<void> {\n    try {\n      const { revalidateTag } = await import('next/cache');\n      revalidateTag('food-trucks');\n      console.info('CacheManager: Invalidated all food truck caches');\n    } catch (error) {\n      console.warn('CacheManager: Failed to invalidate caches:', error);\n    }\n  },\n\n  /**\n   * Invalidate specific truck cache\n   */\n  async invalidateTruckCache(truckId: string): Promise<void> {\n    try {\n      const { revalidateTag } = await import('next/cache');\n      revalidateTag(`truck-${truckId}`);\n      revalidateTag('food-trucks'); // Also invalidate general caches\n      console.info(`CacheManager: Invalidated cache for truck ${truckId}`);\n    } catch (error) {\n      console.warn('CacheManager: Failed to invalidate truck cache:', error);\n    }\n  },\n\n  /**\n   * Invalidate search and location caches\n   */\n  async invalidateSearchCaches(): Promise<void> {\n    try {\n      const { revalidateTag } = await import('next/cache');\n      revalidateTag('search');\n      revalidateTag('location-search');\n      console.info('CacheManager: Invalidated search caches');\n    } catch (error) {\n      console.warn('CacheManager: Failed to invalidate search caches:', error);\n    }\n  },\n};\n\n/**\n * Utility functions\n */\nfunction calculateDistance(lat1: number, lng1: number, lat2: number, lng2: number): number {\n  const R = 6371; // Earth's radius in kilometers\n  const dLat = (lat2 - lat1) * Math.PI / 180;\n  const dLng = (lng2 - lng1) * Math.PI / 180;\n  const a = \n    Math.sin(dLat/2) * Math.sin(dLat/2) +\n    Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * \n    Math.sin(dLng/2) * Math.sin(dLng/2);\n  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));\n  return R * c;\n}\n\nfunction parseTimeString(timeStr: string): number {\n  if (timeStr == undefined || timeStr === '') return 0;\n  const [hours, minutes] = timeStr.split(':').map(Number);\n  return hours * 100 + (minutes ?? 0);\n}\n","usedDeprecatedRules":[]},{"filePath":"/app/lib/performance/webVitals.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/lib/pipeline/pipelineHelpers.ts","messages":[{"ruleId":"sonarjs/cognitive-complexity","severity":1,"message":"Refactor this function to reduce its Cognitive Complexity from 29 to the 25 allowed.","line":122,"column":23,"nodeType":null,"messageId":"refactorFunction","endLine":122,"endColumn":43}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ExtractedFoodTruckDetails, FoodTruckSchema, MenuCategory, MenuItem } from '../types';\nimport { ScrapingJobService, FoodTruckService, FoodTruck } from '../supabase';\nimport { DuplicatePreventionService } from '../data-quality/duplicatePrevention';\n\n// Helper function to validate input and prepare basic data\nexport async function validateInputAndPrepare(\n  jobId: string,\n  extractedTruckData: ExtractedFoodTruckDetails,\n  sourceUrl: string\n): Promise<{ isValid: boolean; name: string }> {\n  // Basic input validation\n  if (!validateTruckData(jobId, extractedTruckData)) {\n    await ScrapingJobService.updateJobStatus(jobId, 'failed', {\n      errors: ['Invalid extracted data received from AI processing step.'],\n    });\n    return { isValid: false, name: '' };\n  }\n\n  if (!sourceUrl) {\n    // Log a warning but proceed if sourceUrl is missing, as it might not be critical for all data.\n    console.warn(`Job ${jobId}: Missing sourceUrl for food truck data, proceeding without it.`);\n  }\n\n  const name = extractedTruckData.name ?? 'Unknown Food Truck'; // Ensure name has a fallback\n  console.info(\n    `Job ${jobId}: Preparing to create/update food truck: ${name} from ${sourceUrl ?? 'Unknown Source'}`,\n  );\n\n  return { isValid: true, name };\n}\n\n// New helper function for operating hours\nfunction buildOperatingHours(extractedOperatingHours: ExtractedFoodTruckDetails['operating_hours']) {\n  if (extractedOperatingHours == undefined) {\n    return {\n      monday: { closed: true as const },\n      tuesday: { closed: true as const },\n      wednesday: { closed: true as const },\n      thursday: { closed: true as const },\n      friday: { closed: true as const },\n      saturday: { closed: true as const },\n      sunday: { closed: true as const },\n    };\n  }\n  return {\n    monday: extractedOperatingHours.monday ?? { closed: true as const },\n    tuesday: extractedOperatingHours.tuesday ?? { closed: true as const },\n    wednesday: extractedOperatingHours.wednesday ?? { closed: true as const },\n    thursday: extractedOperatingHours.thursday ?? { closed: true as const },\n    friday: extractedOperatingHours.friday ?? { closed: true as const },\n    saturday: extractedOperatingHours.saturday ?? { closed: true as const },\n    sunday: extractedOperatingHours.sunday ?? { closed: true as const },\n  };\n}\n\n// New helper function for scheduled locations\nfunction buildScheduledLocations(scheduledLocations: ExtractedFoodTruckDetails['scheduled_locations']) {\n  if (!Array.isArray(scheduledLocations)) {\n    return;\n  }\n  return scheduledLocations.map((loc) => ({\n    lat: typeof loc.lat === 'number' ? loc.lat : 0,\n    lng: typeof loc.lng === 'number' ? loc.lng : 0,\n    address: loc.address ?? undefined,\n    start_time: loc.start_time ?? undefined,\n    end_time: loc.end_time ?? undefined,\n    timestamp: new Date().toISOString(),\n  }));\n}\n\n// Helper function to build truck data schema\nexport function buildTruckDataSchema(\n  extractedTruckData: ExtractedFoodTruckDetails,\n  sourceUrl: string,\n  name: string\n): FoodTruckSchema {\n  const currentLocation = buildLocationData(extractedTruckData);\n\n  return {\n    name: name,\n    description: extractedTruckData.description ?? undefined, // Keep as undefined if null/missing\n    current_location: currentLocation,\n    scheduled_locations: buildScheduledLocations(extractedTruckData.scheduled_locations),\n    operating_hours: buildOperatingHours(extractedTruckData.operating_hours),\n    menu: processMenuData(extractedTruckData),\n    contact_info: buildContactInfo(extractedTruckData.contact_info),\n    social_media: buildSocialMedia(extractedTruckData.social_media),\n    cuisine_type: Array.isArray(extractedTruckData.cuisine_type)\n      ? extractedTruckData.cuisine_type\n      : [],\n    price_range: extractedTruckData.price_range ?? undefined, // Ensure it's one of the allowed enum values or undefined\n    specialties: Array.isArray(extractedTruckData.specialties)\n      ? extractedTruckData.specialties\n      : [],\n    data_quality_score: 0.5, // Default score - confidence_score not available in type\n    verification_status: 'pending',\n    source_urls: sourceUrl != undefined && sourceUrl !== '' ? [sourceUrl] : [], // Ensure source_urls is always an array\n    last_scraped_at: new Date().toISOString(),\n  };\n}\n\ninterface DuplicateCheckResult {\n  isDuplicate: boolean;\n  matches: {\n    existingTruck: FoodTruck;\n    similarity: number;\n    matchedFields: string[];\n    confidence: 'high' | 'medium' | 'low';\n    recommendation: 'merge' | 'update' | 'skip' | 'manual_review';\n  }[];\n  bestMatch?: {\n    existingTruck: FoodTruck;\n    similarity: number;\n    confidence: 'high' | 'medium' | 'low';\n    recommendation: 'merge' | 'update' | 'skip' | 'manual_review';\n  };\n  action: 'create' | 'update' | 'merge' | 'manual_review';\n  reason: string;\n}\n\n// Helper function to handle duplicate checking and resolution\nexport async function handleDuplicateCheck(\n  jobId: string,\n  truckData: FoodTruckSchema,\n  name: string\n): Promise<FoodTruck> {\n  // Check for duplicates before creating\n  console.info(`Job ${jobId}: Checking for duplicates before creating truck: ${name}`);\n  const duplicateCheck: DuplicateCheckResult = await DuplicatePreventionService.checkForDuplicates(truckData);\n\n  let truck: FoodTruck | { error: string };\n  if (duplicateCheck.isDuplicate && duplicateCheck.bestMatch) {\n    const { bestMatch } = duplicateCheck;\n    console.info(`Job ${jobId}: Found potential duplicate (${Math.round(bestMatch.similarity * 100)}% similarity) with truck: ${bestMatch.existingTruck.name}`);\n\n    if (bestMatch.confidence === 'high' && bestMatch.recommendation === 'merge') {\n      // Merge with existing truck\n      truck = await DuplicatePreventionService.mergeDuplicates(bestMatch.existingTruck.id, bestMatch.existingTruck.id);\n      if ('error' in truck) {\n        console.error(`Job ${jobId}: Error merging duplicates: ${truck.error}`);\n        // Fallback to creating a new truck if merge fails\n        truck = await FoodTruckService.createTruck(truckData);\n        if ('error' in truck) {\n          console.error(`Job ${jobId}: Error creating truck after merge failure: ${truck.error}`);\n          throw new Error(`Failed to merge or create truck: ${truck.error}`);\n        }\n      } else {\n        console.info(`Job ${jobId}: Merged data with existing truck: ${truck.name} (ID: ${truck.id})`);\n      }\n    } else if (bestMatch.recommendation === 'update') {\n      // Update existing truck with new data\n      truck = await FoodTruckService.updateTruck(bestMatch.existingTruck.id, truckData);\n      if ('error' in truck) {\n        console.error(`Job ${jobId}: Error updating existing truck: ${truck.error}`);\n        // Fallback to creating a new truck if update fails\n        truck = await FoodTruckService.createTruck(truckData);\n        if ('error' in truck) {\n          console.error(`Job ${jobId}: Error creating truck after update failure: ${truck.error}`);\n          throw new Error(`Failed to update or create truck: ${truck.error}`);\n        }\n      } else {\n        console.info(`Job ${jobId}: Updated existing truck: ${truck.name} (ID: ${truck.id})`);\n      }\n    } else {\n      // Create new truck but log the potential duplicate\n      truck = await FoodTruckService.createTruck(truckData);\n      if ('error' in truck) {\n        console.error(`Job ${jobId}: Error creating truck despite potential duplicate: ${truck.error}`);\n        throw new Error(`Failed to create truck: ${truck.error}`);\n      }\n      console.warn(`Job ${jobId}: Created new truck despite potential duplicate (${duplicateCheck.reason ?? 'unknown reason'})`);\n    }\n  } else {\n    // No duplicates found, create new truck\n    truck = await FoodTruckService.createTruck(truckData);\n    if ('error' in truck) {\n      console.error(`Job ${jobId}: Error creating new truck: ${truck.error}`);\n      throw new Error(`Failed to create truck: ${truck.error}`);\n    }\n  }\n\n  return truck;\n}\n\n// Helper function to finalize job status\nexport async function finalizeJobStatus(\n  jobId: string,\n  truck: FoodTruck,\n  sourceUrl: string\n): Promise<void> {\n  console.info(\n    `Job ${jobId}: Successfully created food truck: ${truck.name} (ID: ${truck.id}) from ${sourceUrl ?? 'Unknown Source'}`,\n  );\n\n  // Link truck_id back to the scraping job\n  await ScrapingJobService.updateJobStatus(jobId, 'completed', {\n    completed_at: new Date().toISOString(),\n  });\n}\n\n// Helper function to validate input data\nfunction validateTruckData(jobId: string, extractedTruckData: ExtractedFoodTruckDetails): boolean {\n  if (extractedTruckData == undefined || typeof extractedTruckData !== 'object') {\n    console.error(`Job ${jobId}: Invalid extractedTruckData, cannot create/update food truck.`);\n    return false;\n  }\n  return true;\n}\n\n// Helper function to build location data\nfunction buildLocationData(extractedTruckData: ExtractedFoodTruckDetails) {\n  const locationData = extractedTruckData.current_location ?? {};\n  const fullAddress = [\n    locationData.address,\n    locationData.city,\n    locationData.state,\n    locationData.zip_code,\n  ]\n    .filter(Boolean)\n    .join(', ');\n\n  return {\n    lat: typeof locationData.lat === 'number' ? locationData.lat : 0,\n    lng: typeof locationData.lng === 'number' ? locationData.lng : 0,\n    address: fullAddress || (locationData.raw_text ?? undefined),\n    timestamp: new Date().toISOString(),\n  };\n}\n\n// New helper function for contact info\nfunction buildContactInfo(contactInfo: ExtractedFoodTruckDetails['contact_info']) {\n  return {\n    phone: contactInfo?.phone ?? undefined,\n    email: contactInfo?.email ?? undefined,\n    website: contactInfo?.website ?? undefined,\n  };\n}\n\n// New helper function for social media\nfunction buildSocialMedia(socialMedia: ExtractedFoodTruckDetails['social_media']) {\n  return {\n    instagram: socialMedia?.instagram ?? undefined,\n    facebook: socialMedia?.facebook ?? undefined,\n    twitter: socialMedia?.twitter ?? undefined,\n    tiktok: socialMedia?.tiktok ?? undefined,\n    yelp: socialMedia?.yelp ?? undefined,\n  };\n}\n\n// Define a more precise type for raw menu categories and items\ninterface RawMenuItem {\n  name?: string;\n  description?: string;\n  price?: string | number;\n  dietary_tags?: string[];\n}\n\ninterface RawMenuCategory {\n  items?: unknown[];\n  category?: string;\n  name?: string;\n}\n\n// Type guard for RawMenuCategory\nfunction isRawMenuCategory(obj: unknown): obj is RawMenuCategory {\n  return typeof obj === 'object' && obj != undefined && (\n    ('category' in obj) || ('name' in obj) || ('items' in obj)\n  );\n}\n\n// Type guard for RawMenuItem\nfunction isRawMenuItem(obj: unknown): obj is RawMenuItem {\n  return typeof obj === 'object' && obj != undefined && (\n    ('name' in obj) || ('description' in obj) || ('price' in obj) || ('dietary_tags' in obj)\n  );\n}\n\n// Helper function to process menu data\nfunction processMenuData(extractedTruckData: ExtractedFoodTruckDetails): MenuCategory[] {\n  if (!Array.isArray(extractedTruckData.menu)) {\n    return [];\n  }\n\n  return extractedTruckData.menu.map((category: unknown): MenuCategory => {\n    if (!isRawMenuCategory(category)) {\n      console.warn('Invalid category data encountered:', category);\n      return { name: 'Invalid Category', items: [] };\n    }\n\n    const items = (Array.isArray(category.items) ? category.items : []).map(\n      (item: unknown): MenuItem => {\n        if (!isRawMenuItem(item)) {\n          console.warn('Invalid item data encountered:', item);\n          return {\n            name: 'Invalid Item',\n            description: undefined,\n            price: undefined,\n            dietary_tags: [],\n          };\n        }\n\n        let price: number | undefined = undefined;\n        if (typeof item.price === 'number') {\n          price = item.price;\n        } else if (typeof item.price === 'string') {\n          const parsedPrice = Number.parseFloat(item.price.replaceAll(/[^\\d.-]/g, ''));\n          if (!Number.isNaN(parsedPrice)) {\n            price = parsedPrice;\n          }\n        }\n        return {\n          name: item.name ?? 'Unknown Item',\n          description: item.description ?? undefined,\n          price: price,\n          dietary_tags: Array.isArray(item.dietary_tags) ? item.dietary_tags : [],\n        };\n      },\n    );\n    return {\n      name: category.category ?? category.name ?? 'Uncategorized',\n      items: items,\n    };\n  });\n}\n","usedDeprecatedRules":[]},{"filePath":"/app/lib/pipeline/scrapingProcessor.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":16,"column":33,"nodeType":"ChainExpression","messageId":"conditionErrorNullableString","endLine":16,"endColumn":60,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[549,577],"text":"((scrapeResult.data?.markdown) == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[550,577],"text":"((scrapeResult.data?.markdown) ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[549,577],"text":"(!Boolean((scrapeResult.data?.markdown)))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":56,"column":9,"nodeType":"Identifier","messageId":"conditionErrorObject","endLine":56,"endColumn":12},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":76,"column":10,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":76,"endColumn":24,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[2824,2839],"text":"job.target_url == null"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[2825,2839],"text":"(job.target_url ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[2824,2839],"text":"!Boolean(job.target_url)"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { firecrawl } from '@/lib/firecrawl';\nimport { gemini } from '@/lib/gemini';\nimport { ScrapingJobService } from '@/lib/supabase';\nimport { ExtractedFoodTruckDetails } from '../types';\nimport {\n  validateInputAndPrepare,\n  buildTruckDataSchema,\n  handleDuplicateCheck,\n  finalizeJobStatus,\n} from './pipelineHelpers';\n\nasync function handleScraping(targetUrl: string, jobId: string) {\n  console.info(`Starting scrape for ${targetUrl}`);\n  const scrapeResult = await firecrawl.scrapeFoodTruckWebsite(targetUrl);\n\n  if (!scrapeResult.success || !scrapeResult.data?.markdown) {\n    const error = scrapeResult.error ?? 'Scraping failed or markdown content not found';\n    await handleJobFailure(jobId, error);\n    throw new Error(error);\n  }\n\n  console.info(`Scraping successful for ${targetUrl}, proceeding to Gemini extraction.`);\n  return scrapeResult.data;\n}\n\nasync function handleGeminiExtraction(markdown: string, sourceUrl: string, jobId: string) {\n  const geminiResult = await gemini.extractFoodTruckDetailsFromMarkdown(markdown, sourceUrl);\n\n  if (!geminiResult.success || !geminiResult.data) {\n    const error = geminiResult.error ?? 'Gemini data extraction failed';\n    await handleJobFailure(jobId, error);\n    throw new Error(error);\n  }\n\n  console.info(`Gemini extraction successful for ${sourceUrl}.`);\n  return geminiResult.data;\n}\n\nasync function handleJobFailure(jobId: string, error: string) {\n  console.error(`Job ${jobId} failed:`, error);\n  try {\n    const currentJob = await ScrapingJobService.getJobsByStatus('all').then(jobs =>\n      jobs.find(j => j.id === jobId)\n    );\n    if (currentJob && currentJob.status !== 'failed') {\n      await ScrapingJobService.updateJobStatus(jobId, 'failed', { errors: [error] });\n    }\n  } catch (statusUpdateError) {\n    console.error(`Error updating job ${jobId} status to failed:`, statusUpdateError);\n  }\n}\n\nasync function handleRetryLogic(jobId: string) {\n  try {\n    const job = await ScrapingJobService.incrementRetryCount(jobId);\n    if (job && typeof job.retry_count === 'number' && typeof job.max_retries === 'number') {\n      if (job.retry_count < job.max_retries) {\n        console.info(`Retrying job ${jobId} (attempt ${job.retry_count}/${job.max_retries})`);\n        setTimeout(() => {\n          void processScrapingJob(jobId);\n        }, 5000);\n      } else {\n        console.warn(`Job ${jobId} reached max retries (${job.max_retries}).`);\n      }\n    } else {\n      console.error(`Job ${jobId}: Could not get valid retry_count or max_retries. Won't attempt retry.`);\n    }\n  } catch (retryError) {\n    console.error(`Error during retry logic for job ${jobId}:`, retryError);\n  }\n}\n\nexport async function processScrapingJob(jobId: string): Promise<void> {\n  try {\n    const job = await ScrapingJobService.updateJobStatus(jobId, 'running');\n    if (!job.target_url) {\n      throw new Error('No target URL specified');\n    }\n\n    const scrapeData = await handleScraping(job.target_url, jobId);\n    const extractedData = await handleGeminiExtraction(scrapeData.markdown, scrapeData.source_url ?? job.target_url, jobId);\n\n    await ScrapingJobService.updateJobStatus(jobId, 'completed', {\n      data_collected: extractedData as unknown as Record<string, unknown>,\n      completed_at: new Date().toISOString(),\n    });\n\n    await createOrUpdateFoodTruck(jobId, extractedData, scrapeData.source_url ?? job.target_url);\n\n    console.info(`Scraping job ${jobId} completed successfully and data processed.`);\n  } catch {\n    await handleRetryLogic(jobId);\n  }\n}\n\nexport async function createOrUpdateFoodTruck(\n  jobId: string,\n  extractedTruckData: ExtractedFoodTruckDetails,\n  sourceUrl: string,\n) {\n  try {\n    const validation = await validateInputAndPrepare(jobId, extractedTruckData, sourceUrl);\n    if (!validation.isValid) {\n      return;\n    }\n\n    const truckData = buildTruckDataSchema(extractedTruckData, sourceUrl, validation.name);\n    const truck = await handleDuplicateCheck(jobId, truckData, validation.name);\n    await finalizeJobStatus(jobId, truck, sourceUrl);\n  } catch (error) {\n    const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n    console.error(`Job ${jobId}: Error in createOrUpdateFoodTruck from ${sourceUrl ?? 'Unknown Source'}:`, error);\n    await handleJobFailure(jobId, `Food truck data processing/saving failed: ${errorMessage}`);\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/app/lib/pipelineManager.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/lib/pipelineProcessor.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/lib/scheduler.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/lib/security/auditLogger.ts","messages":[{"ruleId":null,"nodeType":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token. A constructor, method, accessor, or property was expected.","line":160,"column":0}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * SOTA Security Audit Logging System\n * Implements comprehensive audit logging for admin actions and security events\n */\n\nimport { supabaseAdmin } from '@/lib/supabase';\n\n// Interface definitions moved to the top level\ninterface LogAdminActionParams {\n  userId: string;\n  userEmail: string;\n  action: string;\n  resourceType: string;\n  resourceId?: string;\n  details?: Record<string, unknown>;\n  request?: {\n    ip?: string;\n    userAgent?: string;\n    sessionId?: string;\n  };\n}\n\ninterface LogAuthEventParams {\n  eventType: 'login_attempt' | 'login_success' | 'login_failure' | 'logout';\n  userEmail?: string;\n  userId?: string;\n  request?: {\n    ip?: string;\n    userAgent?: string;\n  };\n  details?: Record<string, unknown>;\n}\n\ninterface LogDataAccessParams {\n  userId: string;\n  userEmail: string;\n  resourceType: string;\n  resourceId?: string;\n  action?: 'read' | 'search' | 'export' | 'admin_access';\n  request?: {\n    ip?: string;\n    userAgent?: string;\n  };\n}\n\n// Type alias for severity levels to comply with sonarjs/use-type-alias\ntype SeverityLevel = 'info' | 'warning' | 'error' | 'critical';\n\nexport interface AuditLogEntry {\n  user_id: string;\n  user_email: string;\n  action: string;\n  resource_type: string;\n  resource_id?: string;\n  details?: Record<string, unknown>;\n  ip_address?: string;\n  user_agent?: string;\n  session_id?: string;\n  timestamp: string;\n  severity: SeverityLevel;\n}\n\nexport interface SecurityEvent {\n  event_type: 'login_attempt' | 'login_success' | 'login_failure' | 'logout' | 'permission_denied' | 'data_access' | 'data_modification' | 'admin_action';\n  user_id?: string;\n  user_email?: string;\n  ip_address?: string;\n  user_agent?: string;\n  details?: Record<string, unknown>;\n  severity: SeverityLevel;\n}\n\n/**\n * Audit Logger Service\n */\nexport class AuditLogger {\n  /**\n   * Log admin action with full audit trail\n   */\n  static async logAdminAction(params: LogAdminActionParams): Promise<void> {\n    const auditEntry: AuditLogEntry = {\n      user_id: params.userId,\n      user_email: params.userEmail,\n      action: params.action,\n      resource_type: params.resourceType,\n      resource_id: params.resourceId,\n      details: params.details,\n      ip_address: params.request?.ip,\n      user_agent: params.request?.userAgent,\n      session_id: params.request?.sessionId,\n      timestamp: new Date().toISOString(),\n      severity: this.determineSeverity(params.action, params.resourceType)\n    };\n\n    await this.writeAuditLog(auditEntry);\n    \n    // Log to console for immediate monitoring\n    console.info('Admin Action Audit:', {\n      user: params.userEmail,\n      action: params.action,\n      resource: (params.resourceId === undefined) ? params.resourceType : `${params.resourceType}:${params.resourceId}`,\n      timestamp: auditEntry.timestamp\n    });\n  }\n\n  /**\n   * Log security event\n   */\n  static async logSecurityEvent(event: SecurityEvent): Promise<void> {\n    const logEntry = {\n      event_type: event.event_type,\n      user_id: event.user_id,\n      user_email: event.user_email,\n      ip_address: event.ip_address,\n      user_agent: event.user_agent,\n      details: event.details,\n      severity: event.severity,\n      timestamp: new Date().toISOString()\n    };\n\n    try {\n      if (supabaseAdmin) {\n        await supabaseAdmin\n          .from('security_events')\n          .insert(logEntry);\n      }\n    } catch (error) {\n      console.error('Failed to log security event:', error);\n    }\n\n    // Always log security events to console\n    console.info('Security Event:', logEntry);\n\n    // Alert on critical security events\n    if (event.severity === 'critical' || event.severity === 'error') {\n      console.warn('SECURITY ALERT:', logEntry);\n    }\n  }\n\n  /**\n   * Log authentication events\n   */\n  static async logAuthEvent(params: LogAuthEventParams): Promise<void> {\n    const severity = params.eventType === 'login_failure' ? 'warning' : 'info';\n    \n    await this.logSecurityEvent({\n      event_type: params.eventType,\n      user_id: params.userId,\n      user_email: params.userEmail,\n      ip_address: params.request?.ip,\n      user_agent: params.request?.userAgent,\n      details: params.details,\n      severity\n    });\n  }\n\n  /**\n   * Log data access events\n   */\ninterface LogDataAccessParams {\n  userId: string;\n  userEmail: string;\n  resourceType: string;\n  resourceId?: string;\n  action?: 'read' | 'search' | 'export' | 'admin_access';\n  request?: {\n    ip?: string;\n    userAgent?: string;\n  };\n}\n  static async logDataAccess(params: LogDataAccessParams): Promise<void> {\n    await this.logSecurityEvent({\n      event_type: 'data_access',\n      user_id: params.userId,\n      user_email: params.userEmail,\n      ip_address: params.request?.ip,\n      user_agent: params.request?.userAgent,\n      details: {\n        resource_type: params.resourceType,\n        resource_id: params.resourceId,\n        action: params.action ?? 'read'\n      },\n      severity: 'info'\n    });\n  }\n\n  /**\n   * Write audit log to database\n   */\n  private static async writeAuditLog(entry: AuditLogEntry): Promise<void> {\n    try {\n      if (supabaseAdmin) {\n        await supabaseAdmin\n          .from('audit_logs')\n          .insert(entry);\n      }\n    } catch (error) {\n      console.error('Failed to write audit log:', error);\n      // Don't throw - audit logging should not break application flow\n    }\n  }\n\n  /**\n   * Determine severity based on action and resource type\n   */\n  private static determineSeverity(action: string, resourceType: string): SeverityLevel {\n    // Critical actions\n    if (action.includes('delete') || action.includes('remove')) {\n      return 'critical';\n    }\n    \n    // Warning actions\n    if (action.includes('update') || action.includes('modify') || action.includes('change')) {\n      return 'warning';\n    }\n    \n    // Admin-specific actions\n    if (resourceType === 'user' || resourceType === 'admin' || resourceType === 'system') {\n      return 'warning';\n    }\n    \n    // Default to info\n    return 'info';\n  }\n\n  /**\n   * Get audit logs for a specific user\n   */\n  static async getUserAuditLogs(\n    userId: string,\n    limit: number = 100,\n    offset: number = 0\n  ): Promise<AuditLogEntry[]> {\n    try {\n      if (!supabaseAdmin) {\n        return [];\n      }\n\n      const { data, error } = await supabaseAdmin\n        .from('audit_logs')\n        .select('*')\n        .eq('user_id', userId)\n        .order('timestamp', { ascending: false })\n        .range(offset, offset + limit - 1);\n\n      if (error) {\n        console.error('Failed to fetch user audit logs:', error);\n        return [];\n      }\n\n      return (data as AuditLogEntry[]) ?? [];\n    } catch (error) {\n      console.error('Error fetching user audit logs:', error);\n      return [];\n    }\n  }\n\n  /**\n   * Get recent security events\n   */\n  static async getRecentSecurityEvents(\n    hours: number = 24,\n    severity?: SeverityLevel\n  ): Promise<Record<string, unknown>[]> {\n    try {\n      if (!supabaseAdmin) {\n        return [];\n      }\n\n      const startTime = new Date();\n      startTime.setHours(startTime.getHours() - hours);\n\n      let query = supabaseAdmin\n        .from('security_events')\n        .select('*')\n        .gte('timestamp', startTime.toISOString())\n        .order('timestamp', { ascending: false });\n\n      if (severity) {\n        query = query.eq('severity', severity);\n      }\n\n      const { data, error } = await query.limit(500);\n\n      if (error) {\n        console.error('Failed to fetch security events:', error);\n        return [];\n      }\n\n      return (data as Record<string, unknown>[]) ?? [];\n    } catch (error) {\n      console.error('Error fetching security events:', error);\n      return [];\n    }\n  }\n}\n\n/**\n * Security monitoring utilities\n */\nexport const SecurityMonitor = {\n  /**\n   * Check for suspicious activity patterns\n   */\n  async checkSuspiciousActivity(userId: string): Promise<{\n    suspicious: boolean;\n    reasons: string[];\n    riskLevel: 'low' | 'medium' | 'high';\n  }> {\n    const reasons: string[] = [];\n    let riskLevel: 'low' | 'medium' | 'high' = 'low';\n\n    try {\n      // Check recent failed login attempts\n      const recentEvents = await AuditLogger.getRecentSecurityEvents(1, 'warning');\n      const failedLogins = recentEvents.filter(\n        event => event.event_type === 'login_failure' && event.user_id === userId\n      );\n\n      if (failedLogins.length > 5) {\n        reasons.push('Multiple failed login attempts');\n        riskLevel = 'high';\n      } else if (failedLogins.length > 2) {\n        reasons.push('Recent failed login attempts');\n        riskLevel = 'medium';\n      }\n\n      // Check for unusual access patterns\n      const auditLogs = await AuditLogger.getUserAuditLogs(userId, 50);\n      const recentActions = auditLogs.filter(\n        log => new Date(log.timestamp) > new Date(Date.now() - 60 * 60 * 1000) // Last hour\n      );\n\n      if (recentActions.length > 20) {\n        reasons.push('High activity volume');\n        riskLevel = riskLevel === 'high' ? 'high' : 'medium';\n      }\n\n      return {\n        suspicious: reasons.length > 0,\n        reasons,\n        riskLevel\n      };\n    } catch (error) {\n      console.error('Error checking suspicious activity:', error);\n      return {\n        suspicious: false,\n        reasons: [],\n        riskLevel: 'low'\n      };\n    }\n  },\n};\n","usedDeprecatedRules":[]},{"filePath":"/app/lib/security/rateLimiter.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":276,"column":11,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":276,"endColumn":28,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[7921,7938],"text":"result.retryAfter != null"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[7921,7938],"text":"result.retryAfter ?? 0"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[7921,7938],"text":"Boolean(result.retryAfter)"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * SOTA Rate Limiting Implementation\n * Prevents brute force attacks and API abuse with intelligent rate limiting\n */\n\nimport { NextResponse } from 'next/server'; // Added import for NextResponse\n\ninterface RateLimitEntry {\n  count: number;\n  resetTime: number;\n  blocked: boolean;\n  blockUntil?: number;\n}\n\n// In-memory rate limit store (in production, use Redis)\nconst rateLimitStore = new Map<string, RateLimitEntry>();\n\n// Rate limit configurations for different endpoints\nexport const RATE_LIMIT_CONFIGS = {\n  // Authentication endpoints - strict limits\n  auth: {\n    windowMs: 15 * 60 * 1000, // 15 minutes\n    maxRequests: 5, // 5 attempts per 15 minutes\n    blockDurationMs: 30 * 60 * 1000, // Block for 30 minutes\n    skipSuccessfulRequests: true\n  },\n  // API endpoints - moderate limits\n  api: {\n    windowMs: 60 * 1000, // 1 minute\n    maxRequests: 60, // 60 requests per minute\n    blockDurationMs: 5 * 60 * 1000, // Block for 5 minutes\n    skipSuccessfulRequests: false\n  },\n  // Admin endpoints - very strict limits\n  admin: {\n    windowMs: 60 * 1000, // 1 minute\n    maxRequests: 20, // 20 requests per minute\n    blockDurationMs: 15 * 60 * 1000, // Block for 15 minutes\n    skipSuccessfulRequests: false\n  }\n} as const;\n\nexport type RateLimitType = keyof typeof RATE_LIMIT_CONFIGS;\n\n/**\n * Rate Limiter Service\n */\nexport class RateLimiter {\n  // Extract logic from checkRateLimit to reduce function size\n  private static isBlocked(entry: RateLimitEntry | undefined, now: number): boolean {\n    return Boolean(entry && entry.blocked && entry.blockUntil != undefined && now < entry.blockUntil);\n  }\n\n  private static resetEntry(entry: RateLimitEntry, now: number, config: typeof RATE_LIMIT_CONFIGS[RateLimitType]): void {\n    entry.count = 0;\n    entry.resetTime = now + config.windowMs;\n    entry.blocked = false;\n    entry.blockUntil = undefined;\n  }\n\n  /**\n   * Check if request should be rate limited\n   */\n  static checkRateLimit(\n    identifier: string,\n    type: RateLimitType = 'api'\n  ): {\n    allowed: boolean;\n    remaining: number;\n    resetTime: number;\n    retryAfter?: number;\n  } {\n    const config = RATE_LIMIT_CONFIGS[type];\n    const now = Date.now();\n    const key = `${type}:${identifier}`;\n    this.cleanupExpiredEntries();\n    let entry = rateLimitStore.get(key);\n    if (!entry) {\n      entry = { count: 0, resetTime: now + config.windowMs, blocked: false };\n      rateLimitStore.set(key, entry);\n    }\n    if (this.isBlocked(entry, now)) {\n      return {\n        allowed: false,\n        remaining: 0,\n        resetTime: entry.resetTime,\n        retryAfter: Math.ceil((entry.blockUntil! - now) / 1000)\n      };\n    }\n    if (now >= entry.resetTime) {\n      this.resetEntry(entry, now, config);\n    }\n    if (entry.count >= config.maxRequests) {\n      entry.blocked = true;\n      entry.blockUntil = now + config.blockDurationMs;\n      return {\n        allowed: false,\n        remaining: 0,\n        resetTime: entry.resetTime,\n        retryAfter: Math.ceil(config.blockDurationMs / 1000)\n      };\n    }\n    entry.count++;\n    rateLimitStore.set(key, entry);\n    return {\n      allowed: true,\n      remaining: config.maxRequests - entry.count,\n      resetTime: entry.resetTime\n    };\n  }\n  \n  /**\n   * Record successful request (for auth endpoints)\n   */\n  static recordSuccess(identifier: string, type: RateLimitType = 'api'): void {\n    const config = RATE_LIMIT_CONFIGS[type];\n    if (!config.skipSuccessfulRequests) return;\n    \n    const key = `${type}:${identifier}`;\n    const entry = rateLimitStore.get(key);\n    \n    if (entry) {\n      // Reset counter on successful auth\n      entry.count = 0;\n      entry.blocked = false;\n      entry.blockUntil = undefined;\n      rateLimitStore.set(key, entry);\n    }\n  }\n  \n  /**\n   * Get rate limit status without incrementing\n   */\n  static getStatus(\n    identifier: string,\n    type: RateLimitType = 'api'\n  ): {\n    remaining: number;\n    resetTime: number;\n    blocked: boolean;\n    retryAfter?: number;\n  } {\n    const config = RATE_LIMIT_CONFIGS[type];\n    const now = Date.now();\n    const key = `${type}:${identifier}`;\n    const entry = rateLimitStore.get(key);\n    \n    if (!entry) {\n      return {\n        remaining: config.maxRequests,\n        resetTime: now + config.windowMs,\n        blocked: false\n      };\n    }\n    \n    // Check if blocked\n    if (entry.blocked && (entry.blockUntil != undefined) && now < entry.blockUntil) { // Changed != undefined to != null\n      return {\n        remaining: 0,\n        resetTime: entry.resetTime,\n        blocked: true,\n        retryAfter: Math.ceil((entry.blockUntil - now) / 1000)\n      };\n    }\n    \n    // Check if window expired\n    if (now >= entry.resetTime) {\n      return {\n        remaining: config.maxRequests,\n        resetTime: now + config.windowMs,\n        blocked: false\n      };\n    }\n    \n    return {\n      remaining: Math.max(0, config.maxRequests - entry.count),\n      resetTime: entry.resetTime,\n      blocked: false\n    };\n  }\n  \n  /**\n   * Clean up expired entries to prevent memory leaks\n   */\n  private static cleanupExpiredEntries(): void {\n    const now = Date.now();\n    \n    for (const [key, entry] of rateLimitStore.entries()) {\n      // Remove entries that are expired and not blocked\n      if (now >= entry.resetTime && (!entry.blocked || (entry.blockUntil == undefined) || now >= entry.blockUntil)) { // Changed == undefined to == null\n        rateLimitStore.delete(key);\n      }\n    }\n  }\n  \n  /**\n   * Clear all rate limit data for an identifier\n   */\n  static clearLimits(identifier: string, type?: RateLimitType): void {\n    if (type) {\n      const key = `${type}:${identifier}`;\n      rateLimitStore.delete(key);\n    } else {\n      // Clear all types for this identifier\n      for (const limitType of Object.keys(RATE_LIMIT_CONFIGS) as RateLimitType[]) { // Added type assertion\n        const key = `${limitType}:${identifier}`;\n        rateLimitStore.delete(key);\n      }\n    }\n  }\n  \n  /**\n   * Get rate limit statistics\n   */\n  static getStats(): {\n    totalEntries: number;\n    blockedEntries: number;\n    entriesByType: Record<string, number>;\n  } {\n    const stats = {\n      totalEntries: rateLimitStore.size,\n      blockedEntries: 0,\n      entriesByType: {} as Record<string, number>\n    };\n    \n    for (const [key, entry] of rateLimitStore.entries()) {\n      const type = key.split(':')[0];\n      stats.entriesByType[type] = (stats.entriesByType[type] ?? 0) + 1;\n      \n      if (entry.blocked) {\n        stats.blockedEntries++;\n      }\n    }\n    \n    return stats;\n  }\n}\n\n/**\n * Utility function to get client identifier from request\n */\nexport function getClientIdentifier(request: Request): string {\n  // Try to get IP address from various headers\n  const forwarded = request.headers.get('x-forwarded-for');\n  const realIp = request.headers.get('x-real-ip');\n  const cfConnectingIp = request.headers.get('cf-connecting-ip');\n  \n  // Use the first available IP\n  const ip = (forwarded?.split(',')[0]?.trim() ?? realIp ?? cfConnectingIp) ?? 'unknown';\n  \n  // Include user agent for more specific identification\n  const userAgent = request.headers.get('user-agent') ?? 'unknown';\n  \n  // Create a hash of IP + User Agent for better identification\n  return `${ip}:${userAgent.slice(0, 50)}`;\n}\n\n/**\n * Rate limiting middleware for API routes\n */\nexport function withRateLimit(\n  handler: (request: Request) => Promise<Response>,\n  type: RateLimitType = 'api'\n) {\n  return async (request: Request): Promise<Response> => {\n    const identifier = getClientIdentifier(request);\n    const result = RateLimiter.checkRateLimit(identifier, type);\n    \n    if (result.allowed === false) {\n      const headers = new Headers({\n        'X-RateLimit-Limit': RATE_LIMIT_CONFIGS[type].maxRequests.toString(),\n        'X-RateLimit-Remaining': '0',\n        'X-RateLimit-Reset': new Date(result.resetTime).toISOString(),\n      });\n      \n      if (result.retryAfter) {\n        headers.set('Retry-After', result.retryAfter.toString());\n      }\n      \n      return new NextResponse('Too Many Requests', { status: 429, headers });\n    }\n    \n    const response = await handler(request);\n    \n    // Update headers on successful requests if not skipped\n    if (RATE_LIMIT_CONFIGS[type].skipSuccessfulRequests === false) {\n      const status = RateLimiter.getStatus(identifier, type);\n      response.headers.set('X-RateLimit-Limit', RATE_LIMIT_CONFIGS[type].maxRequests.toString());\n      response.headers.set('X-RateLimit-Remaining', status.remaining.toString());\n      response.headers.set('X-RateLimit-Reset', new Date(status.resetTime).toISOString());\n    }\n    \n    return response;\n  };\n}\n","usedDeprecatedRules":[]},{"filePath":"/app/lib/supabase.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":14,"column":6,"nodeType":"Identifier","messageId":"conditionErrorNullableString","endLine":14,"endColumn":17,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[337,349],"text":"supabaseUrl == null"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[338,349],"text":"(supabaseUrl ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[337,349],"text":"!Boolean(supabaseUrl)"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":18,"column":6,"nodeType":"Identifier","messageId":"conditionErrorNullableString","endLine":18,"endColumn":21,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[436,452],"text":"supabaseAnonKey == null"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[437,452],"text":"(supabaseAnonKey ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[436,452],"text":"!Boolean(supabaseAnonKey)"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":25,"column":30,"nodeType":"Identifier","messageId":"conditionErrorNullableString","endLine":25,"endColumn":48,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[712,730],"text":"(supabaseServiceKey != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[712,730],"text":"(supabaseServiceKey ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[712,730],"text":"(Boolean(supabaseServiceKey))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":102,"column":12,"nodeType":"MemberExpression","messageId":"conditionErrorObject","endLine":102,"endColumn":43},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":186,"column":12,"nodeType":"MemberExpression","messageId":"conditionErrorObject","endLine":186,"endColumn":34},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":222,"column":9,"nodeType":"Identifier","messageId":"conditionErrorObject","endLine":222,"endColumn":14},{"ruleId":"sonarjs/different-types-comparison","severity":2,"message":"Remove this \"!==\" check; it will always be true. Did you mean to use \"!=\"?","line":241,"column":44,"nodeType":null,"endLine":241,"endColumn":47,"suggestions":[{"desc":"Replace \"!==\" with \"!=\"","fix":{"range":[7952,7955],"text":"!="}}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":274,"column":12,"nodeType":"Identifier","messageId":"conditionErrorObject","endLine":274,"endColumn":16},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":333,"column":10,"nodeType":"Identifier","messageId":"conditionErrorObject","endLine":333,"endColumn":15},{"ruleId":"unicorn/consistent-function-scoping","severity":2,"message":"Move arrow function 'isMenuCategory' to the outer scope.","line":359,"column":66,"nodeType":"ArrowFunctionExpression","messageId":"consistent-function-scoping","endLine":359,"endColumn":68},{"ruleId":"unicorn/consistent-function-scoping","severity":2,"message":"Move arrow function 'isMenuItem' to the outer scope.","line":369,"column":60,"nodeType":"ArrowFunctionExpression","messageId":"consistent-function-scoping","endLine":369,"endColumn":62},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":510,"column":10,"nodeType":"Identifier","messageId":"conditionErrorObject","endLine":510,"endColumn":14},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":558,"column":10,"nodeType":"Identifier","messageId":"conditionErrorObject","endLine":558,"endColumn":14},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":580,"column":10,"nodeType":"Identifier","messageId":"conditionErrorObject","endLine":580,"endColumn":17},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":594,"column":10,"nodeType":"Identifier","messageId":"conditionErrorObject","endLine":594,"endColumn":14},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":659,"column":10,"nodeType":"Identifier","messageId":"conditionErrorObject","endLine":659,"endColumn":14},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":723,"column":10,"nodeType":"Identifier","messageId":"conditionErrorObject","endLine":723,"endColumn":14},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":741,"column":7,"nodeType":"MemberExpression","messageId":"conditionErrorObject","endLine":741,"endColumn":29},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":749,"column":7,"nodeType":"MemberExpression","messageId":"conditionErrorObject","endLine":749,"endColumn":25},{"ruleId":"sonarjs/different-types-comparison","severity":2,"message":"Remove this \"!==\" check; it will always be true. Did you mean to use \"!=\"?","line":761,"column":31,"nodeType":null,"endLine":761,"endColumn":34,"suggestions":[{"desc":"Replace \"!==\" with \"!=\"","fix":{"range":[25164,25167],"text":"!="}}]},{"ruleId":"sonarjs/different-types-comparison","severity":2,"message":"Remove this \"!==\" check; it will always be true. Did you mean to use \"!=\"?","line":761,"column":70,"nodeType":null,"endLine":761,"endColumn":73,"suggestions":[{"desc":"Replace \"!==\" with \"!=\"","fix":{"range":[25203,25206],"text":"!="}}]},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe array destructuring of a tuple element with an `any` value.","line":771,"column":19,"nodeType":"Identifier","messageId":"unsafeArrayPatternFromTuple","endLine":771,"endColumn":24},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected any value in conditional. An explicit comparison or type conversion is required.","line":781,"column":10,"nodeType":"Identifier","messageId":"conditionErrorAny","endLine":781,"endColumn":15,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[25825,25830],"text":"(Boolean(truck))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `any` assigned to a parameter of type `FoodTruck`.","line":785,"column":50,"nodeType":"Identifier","messageId":"unsafeArgument","endLine":785,"endColumn":55},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe array destructuring of a tuple element with an `any` value.","line":787,"column":13,"nodeType":"Identifier","messageId":"unsafeArrayPatternFromTuple","endLine":787,"endColumn":17},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected any value in conditional. An explicit comparison or type conversion is required.","line":798,"column":10,"nodeType":"Identifier","messageId":"conditionErrorAny","endLine":798,"endColumn":14,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[26329,26333],"text":"(Boolean(data))"},"desc":"Explicitly convert value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-unsafe-return","severity":2,"message":"Unsafe return of a value of type `any`.","line":801,"column":5,"nodeType":"ReturnStatement","messageId":"unsafeReturn","endLine":801,"endColumn":17},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":834,"column":14,"nodeType":"Identifier","messageId":"conditionErrorObject","endLine":834,"endColumn":18},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":855,"column":14,"nodeType":"Identifier","messageId":"conditionErrorObject","endLine":855,"endColumn":18},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a(n) `error` type typed value.","line":919,"column":5,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":937,"endColumn":14},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a(n) `error` type typed value.","line":919,"column":5,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":919,"endColumn":62},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .map on an `error` typed value.","line":919,"column":59,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":919,"endColumn":62},{"ruleId":"unicorn/consistent-function-scoping","severity":2,"message":"Move arrow function 'isMenuItem' to the outer scope.","line":921,"column":58,"nodeType":"ArrowFunctionExpression","messageId":"consistent-function-scoping","endLine":921,"endColumn":60},{"ruleId":"unicorn/no-null","severity":1,"message":"Use `undefined` instead of `null`.","line":926,"column":16,"nodeType":"Literal","messageId":"error","endLine":926,"endColumn":20,"suggestions":[{"messageId":"remove","fix":{"range":[31118,31122],"text":""},"data":{},"desc":"Remove `null`."},{"messageId":"replace","fix":{"range":[31118,31122],"text":"undefined"},"data":{},"desc":"Replace `null` with `undefined`."}]},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an error typed value.","line":931,"column":9,"nodeType":"Property","messageId":"anyAssignment","endLine":931,"endColumn":80},{"ruleId":"unicorn/no-negated-condition","severity":2,"message":"Unexpected negated condition.","line":931,"column":19,"nodeType":"BinaryExpression","messageId":"no-negated-condition","endLine":931,"endColumn":46,"fix":{"range":[31328,31368],"text":"=== '' ? 'Uncategorized' : category.name"}},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a(n) `error` type typed value.","line":931,"column":19,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":931,"endColumn":37},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .trim on an `error` typed value.","line":931,"column":33,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":931,"endColumn":37},{"ruleId":"unicorn/no-negated-condition","severity":2,"message":"Unexpected negated condition.","line":932,"column":15,"nodeType":"BinaryExpression","messageId":"no-negated-condition","endLine":932,"endColumn":38,"fix":{"range":[31401,31436],"text":"=== '' ? 'Unknown Item' : item.name"}},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .filter on an `error` typed value.","line":937,"column":8,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":937,"endColumn":14}],"suppressedMessages":[],"errorCount":19,"fatalErrorCount":0,"warningCount":21,"fixableErrorCount":2,"fixableWarningCount":0,"source":"import {\n  createClient,\n  type PostgrestSingleResponse,\n  type PostgrestResponse,\n  type PostgrestError,\n} from '@supabase/supabase-js';\n\n\n\nconst supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;\nconst supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY;\nconst supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY;\n\nif (!supabaseUrl) {\n  throw new Error('Missing NEXT_PUBLIC_SUPABASE_URL environment variable');\n}\n\nif (!supabaseAnonKey) {\n  throw new Error('Missing NEXT_PUBLIC_SUPABASE_ANON_KEY environment variable');\n}\n\nexport const supabase = createClient(supabaseUrl, supabaseAnonKey);\n\n// Only create admin client on server side where service key is available\nexport const supabaseAdmin = supabaseServiceKey\n  ? createClient(supabaseUrl, supabaseServiceKey)\n  : undefined;\n\n// Database types\nimport {\n  MenuCategory,\n  MenuItem,\n} from './types';\n\nexport interface FoodTruckLocation {\n  lat: number;\n  lng: number;\n  address?: string;\n  timestamp: string;\n}\n\n// Re-exporting from types.ts to ensure consistency\n\nimport { FoodTruckSchema } from './types';\n\nexport interface FoodTruck extends FoodTruckSchema {\n  id: string;\n  created_at: string;\n  updated_at: string;\n  is_active?: boolean; // This property is in lib/types.ts but not in lib/supabase.ts\n  // Add any other properties that are in the database but not in FoodTruckSchema\n  // For example, if the database has 'exact_location' or 'city_location'\n  exact_location?: FoodTruckLocation;\n  city_location?: FoodTruckLocation;\n}\n\nexport interface ScrapingJob {\n  id: string;\n  job_type: string;\n  target_url?: string;\n  target_handle?: string;\n  platform?: string;\n  status: 'pending' | 'running' | 'completed' | 'failed';\n  priority: number;\n  scheduled_at: string;\n  started_at?: string;\n  completed_at?: string;\n  data_collected?: Record<string, unknown>;\n  errors?: string[];\n  retry_count: number;\n  max_retries: number;\n  created_at: string;\n}\n\nexport interface DataProcessingQueue {\n  id: string;\n  truck_id?: string;\n  processing_type: string;\n  raw_data: Record<string, unknown>;\n  processed_data?: Record<string, unknown>;\n  gemini_tokens_used: number;\n  status: 'pending' | 'processing' | 'completed' | 'failed';\n  priority: number;\n  created_at: string;\n  processed_at?: string;\n}\n\nexport interface ApiUsage {\n  id: string;\n  service_name: string;\n  usage_date: string;\n  requests_count: number;\n  tokens_used: number;\n}\n\n// Food truck operations\nfunction buildMenuByTruck(menuItems: RawMenuItemFromDB[]): Record<string, RawMenuItemFromDB[]> {\n  const menuByTruck: Record<string, RawMenuItemFromDB[]> = {};\n  for (const item of menuItems) {\n    // Ensure food_truck_id is a non-empty string before using it as a key\n    if (typeof item.food_truck_id === 'string' && item.food_truck_id.trim() !== '') {\n      if (!menuByTruck[item.food_truck_id]) {\n        menuByTruck[item.food_truck_id] = [];\n      }\n      menuByTruck[item.food_truck_id].push(item);\n    }\n  }\n  return menuByTruck;\n}\n\nfunction handleSupabaseError(error: unknown, context: string) {\n  // Log technical details for developers\n  console.warn(`Error in ${context}:`, error);\n}\n\nexport const FoodTruckService = {\n  async getAllTrucks(limit = 50, offset = 0): Promise<{ trucks: FoodTruck[]; total: number; error?: string }> {\n    try {\n      const { data, error, count }: PostgrestResponse<FoodTruck> = await supabase\n        .from('food_trucks')\n        .select('*', { count: 'exact' })\n        .order('updated_at', { ascending: false })\n        .range(offset, offset + limit - 1);\n      if (error) {\n        throw error;\n      }\n      const trucks: FoodTruck[] = (data ?? []).map((t) => normalizeTruckLocation(t));\n      if (trucks.length === 0) {\n        return { trucks: [], total: count ?? 0 };\n      }\n      const truckIds = trucks.map((t) => t.id);\n      let menuItems: RawMenuItemFromDB[] = [];\n      try {\n        if (truckIds.length > 0) {\n          const { data: items, error: menuError }: PostgrestResponse<RawMenuItemFromDB> =\n            await supabase.from('menu_items').select('*').in('food_truck_id', truckIds);\n          if (menuError) {\n            throw menuError;\n          }\n          menuItems = Array.isArray(items) ? items : [];\n        }\n      } catch (menuError) {\n        handleSupabaseError(menuError, 'getAllTrucks:menu_items');\n      }\n      const menuByTruck = buildMenuByTruck(menuItems);\n      for (const truck of trucks) {\n      truck.menu = groupMenuItems(menuByTruck[truck.id] ?? []);\n      }\n      return { trucks, total: count ?? 0 };\n    } catch (error) {\n      handleSupabaseError(error, 'getAllTrucks');\n      return { trucks: [], total: 0, error: \"That didn't work, please try again later.\" };\n    }\n  },\n  async getTruckById(id: string): Promise<FoodTruck | { error: string }> {\n    try {\n      const { data, error }: PostgrestSingleResponse<FoodTruck> = await supabase\n        .from('food_trucks')\n        .select('*')\n        .eq('id', id)\n        .single();\n      if (error) {\n        throw error;\n      }\n      const truck: FoodTruck = normalizeTruckLocation(data);\n      const { data: items, error: menuError }: PostgrestResponse<RawMenuItemFromDB> = await supabase\n        .from('menu_items')\n        .select('*')\n        .eq('food_truck_id', id);\n      if (menuError) {\n        throw menuError;\n      }\n      truck.menu = groupMenuItems(Array.isArray(items) ? items : []);\n      return truck;\n    } catch (error) {\n      handleSupabaseError(error, 'getTruckById');\n      return { error: \"That didn't work, please try again later.\" };\n    }\n  },\n\n  async getTrucksByLocation(lat: number, lng: number, radiusKm: number): Promise<FoodTruck[] | { error: string }> {\n    try {\n      const { trucks } = await FoodTruckService.getAllTrucks(); // Assuming this doesn't return an error object directly for this usage\n      const nearbyTrucks = trucks.filter((truck) => {\n        if (\n          !truck.current_location || // Check if current_location is null or undefined\n          typeof truck.current_location.lat !== 'number' ||\n          typeof truck.current_location.lng !== 'number'\n        ) {\n          return false;\n        }\n        const distance = calculateDistance(\n          lat,\n          lng,\n          truck.current_location.lat,\n          truck.current_location.lng,\n        );\n        return distance <= radiusKm;\n      });\n      return nearbyTrucks;\n    } catch (error: unknown) {\n      handleSupabaseError(error, 'getTrucksByLocation');\n      return { error: \"That didn't work, please try again later.\" };\n    }\n  },\n  async createTruck(truckData: Partial<FoodTruck>): Promise<FoodTruck | { error: string }> {\n    if (!supabaseAdmin) {\n      return { error: 'Admin operations require SUPABASE_SERVICE_ROLE_KEY' };\n    }\n    const menuData = truckData.menu;\n    const truckDataWithoutMenu = { ...truckData };\n    delete truckDataWithoutMenu.menu;\n    const { data: truck, error }: PostgrestSingleResponse<FoodTruck> = await supabaseAdmin\n      .from('food_trucks')\n      .insert([truckDataWithoutMenu])\n      .select()\n      .single();\n    if (error) {\n      handleSupabaseError(error, 'createTruck');\n      return { error: \"Failed to create truck.\" };\n    }\n    if (truck) { // Ensure truck is not null\n      await insertMenuItems(truck.id, menuData);\n      return truck;\n    }\n    // Should not happen if error is not thrown, but as a safeguard\n    return { error: \"Failed to create truck, unexpected null result.\"};\n  },\n\n  async updateTruck(id: string, updates: Partial<FoodTruck>): Promise<FoodTruck | { error: string }> {\n    if (!supabaseAdmin) {\n      return { error: 'Admin operations require SUPABASE_SERVICE_ROLE_KEY' };\n    }\n    const menuData = updates.menu;\n    const updatesWithoutMenu = { ...updates };\n    delete updatesWithoutMenu.menu;\n    const truckResult = await updateTruckData(id, updatesWithoutMenu);\n    if ('error' in truckResult) {\n      return truckResult;\n    }\n    if (menuData !== undefined && menuData !== null) { // Check for null as well\n      await updateTruckMenu(id, menuData);\n    }\n    return truckResult;\n  },\n\n  async getDataQualityStats(): Promise<{\n    total_trucks: number;\n    avg_quality_score: number;\n    high_quality_count: number;\n    medium_quality_count: number;\n    low_quality_count: number;\n    verified_count: number;\n    pending_count: number;\n    flagged_count: number;\n  }> {\n    try {\n      const {\n        data,\n        error,\n      }: PostgrestSingleResponse<{\n        total_trucks: number;\n        avg_quality_score: number;\n        high_quality_count: number;\n        medium_quality_count: number;\n        low_quality_count: number;\n        verified_count: number;\n        pending_count: number;\n        flagged_count: number;\n      }> = await supabase.rpc('get_data_quality_stats').single();\n      if (error) {\n        throw error;\n      }\n      if (!data) { // Handle null data case\n        console.warn('No data returned from get_data_quality_stats');\n        return {\n          total_trucks: 0,\n          avg_quality_score: 0,\n          high_quality_count: 0,\n          medium_quality_count: 0,\n          low_quality_count: 0,\n          verified_count: 0,\n          pending_count: 0,\n          flagged_count: 0,\n        };\n      }\n      return data as { // This cast might still be necessary depending on Supabase's RPC typing\n        total_trucks: number;\n        avg_quality_score: number;\n        high_quality_count: number;\n        medium_quality_count: number;\n        low_quality_count: number;\n        verified_count: number;\n        pending_count: number;\n        flagged_count: number;\n      };\n    } catch (error: unknown) {\n      console.warn('Error fetching data quality stats:', error);\n      return {\n        total_trucks: 0,\n        avg_quality_score: 0,\n        high_quality_count: 0,\n        medium_quality_count: 0,\n        low_quality_count: 0,\n        verified_count: 0,\n        pending_count: 0,\n        flagged_count: 0,\n      };\n    }\n  },\n};\n\n// Helper functions to reduce cognitive complexity\nasync function updateTruckData(\n  id: string,\n  updatesWithoutMenu: Partial<FoodTruck>,\n): Promise<FoodTruck | { error: string }> {\n  if (!supabaseAdmin) {\n    return { error: 'Admin operations require SUPABASE_SERVICE_ROLE_KEY' };\n  }\n\n  const { data: truck, error }: PostgrestSingleResponse<FoodTruck> = await supabaseAdmin\n    .from('food_trucks')\n    .update(updatesWithoutMenu)\n    .eq('id', id)\n    .select()\n    .single();\n\n  if (error) {\n    handleSupabaseError(error, 'updateTruckData');\n    return { error: \"Failed to update truck data.\" };\n  }\n    if (!truck) { // Handle null truck case\n        return { error: \"Failed to update truck data, truck not found after update.\" };\n    }\n  return truck;\n}\n\nasync function updateTruckMenu(id: string, menuData: MenuCategory[] | unknown[]): Promise<void> {\n  if (!supabaseAdmin) {\n    throw new Error('Admin operations require SUPABASE_SERVICE_ROLE_KEY');\n  }\n\n  // Delete existing menu items\n  const { error: deleteError } = await supabaseAdmin\n    .from('menu_items')\n    .delete()\n    .eq('food_truck_id', id);\n\n  if (deleteError) {\n    console.error('Error deleting existing menu items for truck', id, deleteError);\n    // Depending on desired behavior, you might want to throw or return an error here\n  }\n\n  // Insert new menu items if they exist and menuData is an array and has items\n  if (Array.isArray(menuData) && menuData.length > 0) {\n    const menuItems = menuData.flatMap((category: unknown) => {\n      // Type guard for MenuCategory\n      const isMenuCategory = (obj: unknown): obj is MenuCategory =>\n        typeof obj === 'object' && obj !== null && 'name' in obj && 'items' in obj && Array.isArray(obj.items);\n\n      if (!isMenuCategory(category)) {\n        console.warn('Skipping invalid category in updateTruckMenu:', category);\n        return [];\n      }\n\n      return (category.items ?? []).map((item: unknown) => {\n        // Type guard for MenuItem\n        const isMenuItem = (obj: unknown): obj is MenuItem =>\n          typeof obj === 'object' && obj !== null && 'name' in obj;\n\n        if (!isMenuItem(item)) {\n          console.warn('Skipping invalid menu item in updateTruckMenu:', item);\n          // Return a default valid MenuItem or skip based on requirements\n          return {\n            food_truck_id: id,\n            category: category.name ?? 'Uncategorized', // Ensure category.name is a string\n            name: 'Unknown Item',\n            description: undefined,\n            price: undefined,\n            dietary_tags: [],\n          };\n        }\n\n        return {\n          food_truck_id: id,\n          category: typeof category.name === 'string' ? category.name : 'Uncategorized',\n          name: typeof item.name === 'string' ? item.name : 'Unknown Item',\n          description: item.description ?? undefined,\n          price: typeof item.price === 'number' ? item.price : undefined,\n          dietary_tags: Array.isArray(item.dietary_tags) ? item.dietary_tags : [],\n        };\n      });\n    });\n\n    if (menuItems.length > 0) {\n      const { error: menuError } = await supabaseAdmin.from('menu_items').insert(menuItems);\n\n      if (menuError) {\n        console.error('Error inserting updated menu items for truck', id, menuError);\n        // Depending on desired behavior, you might want to throw or return an error here\n      }\n    }\n  }\n}\n\nfunction calculateDistance(lat1: number, lon1: number, lat2: number, lon2: number): number {\n  const R = 6371;\n  const dLat = ((lat2 - lat1) * Math.PI) / 180;\n  const dLon = ((lon2 - lon1) * Math.PI) / 180;\n  const a =\n    Math.sin(dLat / 2) * Math.sin(dLat / 2) +\n    Math.cos((lat1 * Math.PI) / 180) *\n      Math.cos((lat2 * Math.PI) / 180) *\n      Math.sin(dLon / 2) *\n      Math.sin(dLon / 2);\n  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n  const distance = R * c;\n  return distance;\n}\n\n// Define a helper type for items coming from the DB, which might include a category field\ninterface RawMenuItemFromDB {\n  name: string;\n  description?: string;\n  price?: number;\n  dietary_tags?: string[];\n  category?: string; // This field is expected from the DB query\n  // Potentially other fields like id, food_truck_id, etc.\n  [key: string]: unknown; // Allow other properties from DB select *\n}\n\nfunction groupMenuItems(rawItems: RawMenuItemFromDB[]): MenuCategory[] {\n  const byCategory: Record<string, MenuItem[]> = {}; // Stores processed MenuItems\n  for (const rawItem of rawItems) {\n    const categoryName: string = rawItem.category ?? 'Uncategorized';\n    byCategory[categoryName] ??= [];\n    // Construct a MenuItem conforming to the MenuItem interface (no 'category' property)\n    const menuItem: MenuItem = {\n      name: rawItem.name,\n      // Use nullish coalescing to convert null from DB to undefined for the MenuItem type\n      description: rawItem.description ?? undefined,\n      price: rawItem.price ?? undefined,\n      dietary_tags: rawItem.dietary_tags as string[] ?? [], // Explicitly cast to string[]\n    };\n    byCategory[categoryName].push(menuItem);\n  }\n  // Map to MenuCategory structure { name: string, items: MenuItem[] }\n  return Object.entries(byCategory).map(([categoryName, itemsList]) => ({\n    name: categoryName, // 'name' here refers to the category's name\n    items: itemsList,\n  }));\n}\n\n// Remove redundant type constituent in normalizeTruckLocation\nfunction normalizeTruckLocation(truck: FoodTruck): FoodTruck {\n  const fallback: FoodTruckLocation = {\n    lat: 0,\n    lng: 0,\n    address: 'Unknown',\n    timestamp: new Date().toISOString(),\n  };\n  // Ensure loc is an object, provide a default empty object if not\n  const loc = truck.exact_location ?? truck.current_location ?? truck.city_location ?? {};\n\n  // Validate lat and lng, ensuring they are numbers and not NaN\n  const lat = typeof loc.lat === 'number' && !Number.isNaN(loc.lat) ? loc.lat : 0;\n  const lng = typeof loc.lng === 'number' && !Number.isNaN(loc.lng) ? loc.lng : 0;\n\n  // Validate address and timestamp, ensuring they are strings\n  const address = typeof loc.address === 'string' ? loc.address : fallback.address;\n  const timestamp = typeof loc.timestamp === 'string' ? loc.timestamp : fallback.timestamp;\n\n  // Assign current_location, using fallback if lat or lng is 0 (or invalid)\n  truck.current_location =\n    lat === 0 || lng === 0\n      ? { ...fallback, address } // Use validated or fallback address\n      : {\n          lat,\n          lng,\n          address, // Use validated or fallback address\n          timestamp, // Use validated or fallback timestamp\n        };\n  return truck;\n}\n\nexport const ScrapingJobService = {\n  async createJob(jobData: Partial<ScrapingJob>): Promise<ScrapingJob> {\n    if (!supabaseAdmin) {\n      throw new Error('Admin operations require SUPABASE_SERVICE_ROLE_KEY');\n    }\n\n    const { data, error }: PostgrestSingleResponse<ScrapingJob> = await supabaseAdmin\n      .from('scraping_jobs')\n      .insert([\n        {\n          ...jobData,\n          status: 'pending',\n          retry_count: 0,\n          max_retries: 3,\n          created_at: new Date().toISOString(),\n        },\n      ])\n      .select()\n      .single();\n\n    if (error) {\n        throw error;\n    }\n    if (!data) { // Handle null data case for createJob\n        throw new Error(\"Failed to create job, no data returned.\");\n    }\n    return data;\n  },\n\n  async getJobsByStatus(status: string): Promise<ScrapingJob[]> {\n    try {\n      const query = supabase.from('scraping_jobs').select('*');\n\n      const { data, error }: PostgrestResponse<ScrapingJob> = await (status === 'all'\n        ? query\n        : query.eq('status', status))\n        .order('priority', { ascending: false })\n        .order('scheduled_at', { ascending: true });\n\n      if (error) {\n        throw error;\n      }\n      return data ?? [];\n    } catch (error: unknown) {\n      console.warn('Error fetching jobs:', error);\n      return [];\n    }\n  },\n  async updateJobStatus(\n    id: string,\n    status: string,\n    updates: Partial<ScrapingJob> = {},\n  ): Promise<ScrapingJob> {\n    if (!supabaseAdmin) {\n      throw new Error('Admin operations require SUPABASE_SERVICE_ROLE_KEY');\n    }\n\n    const { data, error }: PostgrestSingleResponse<ScrapingJob> = await supabaseAdmin\n      .from('scraping_jobs')\n      .update({\n        status,\n        ...updates,\n        ...(status === 'running' && { started_at: new Date().toISOString() }),\n        ...(status === 'completed' && { completed_at: new Date().toISOString() }),\n      })\n      .eq('id', id)\n      .select()\n      .single();\n    if (error) {\n        throw error;\n    }\n    if (!data) { // Handle null data case for updateJobStatus\n        throw new Error(`Failed to update job status for ID ${id}, no data returned.`);\n    }\n    return data;\n  },\n  async incrementRetryCount(id: string): Promise<ScrapingJob> {\n    if (!supabaseAdmin) {\n      throw new Error('Admin operations require SUPABASE_SERVICE_ROLE_KEY');\n    }\n\n    const {\n      data: current,\n      error: fetchError,\n    }: PostgrestSingleResponse<Pick<ScrapingJob, 'retry_count'>> = await supabaseAdmin\n      .from('scraping_jobs')\n      .select('retry_count')\n      .eq('id', id)\n      .single();\n\n    if (fetchError) {\n        throw fetchError;\n    }\n    if (!current) { // Handle null current case for incrementRetryCount\n        throw new Error(`Failed to fetch current job for ID ${id} to increment retry count.`);\n    }\n\n    const { data, error }: PostgrestSingleResponse<ScrapingJob> = await supabaseAdmin\n      .from('scraping_jobs')\n      .update({ retry_count: (current.retry_count ?? 0) + 1 }) // current is now guaranteed non-null\n      .eq('id', id)\n      .select()\n      .single();\n\n    if (error) {\n        throw error;\n    }\n    if (!data) { // Handle null data case for the update in incrementRetryCount\n        throw new Error(`Failed to increment retry count for job ID ${id}, no data returned after update.`);\n    }\n    return data;\n  },\n  async getAllJobs(limit = 50, offset = 0): Promise<ScrapingJob[]> {\n    try {\n      const { data, error }: PostgrestResponse<ScrapingJob> = await supabase\n        .from('scraping_jobs')\n        .select('*')\n        .order('priority', { ascending: false })\n        .order('scheduled_at', { ascending: true })\n        .range(offset, offset + limit - 1);\n\n      if (error) {\n        throw error;\n      }\n      return data ?? [];\n    } catch (error: unknown) {\n      console.warn('Error fetching jobs:', error);\n      return [];\n    }\n  },\n\n  async getJobsFromDate(date: Date): Promise<ScrapingJob[]> {\n    try {\n      const { data, error }: PostgrestResponse<ScrapingJob> = await supabase\n        .from('scraping_jobs')\n        .select('*')\n        .gte('created_at', date.toISOString())\n        .order('created_at', { ascending: false });\n\n      if (error) {\n        throw error;\n      }\n      return data ?? [];\n    } catch (error: unknown) {\n      console.warn('Error fetching jobs from date:', error);\n      return [];\n    }\n  },\n};\n\nexport const DataProcessingService = {\n  async addToQueue(queueData: Partial<DataProcessingQueue>): Promise<DataProcessingQueue> {\n    if (!supabaseAdmin) {\n      throw new Error('Admin operations require SUPABASE_SERVICE_ROLE_KEY');\n    }\n\n    const { data, error }: PostgrestSingleResponse<DataProcessingQueue> = await supabaseAdmin\n      .from('data_processing_queue')\n      .insert([\n        {\n          ...queueData,\n          status: 'pending',\n          gemini_tokens_used: 0,\n          created_at: new Date().toISOString(),\n        },\n      ])\n      .select()\n      .single();\n\n    if (error) {\n        throw error;\n    }\n    if (!data) { // Handle null data case for addToQueue\n        throw new Error(\"Failed to add to queue, no data returned.\");\n    }\n    return data;\n  },\n\n  async getNextQueueItem(): Promise<DataProcessingQueue | undefined> {\n    if (!supabaseAdmin) {\n      throw new Error('Admin operations require SUPABASE_SERVICE_ROLE_KEY');\n    }\n\n    const { data, error }: PostgrestSingleResponse<DataProcessingQueue> = await supabaseAdmin\n      .from('data_processing_queue')\n      .select('*')\n      .eq('status', 'pending')\n      .order('priority', { ascending: false })\n      .order('created_at', { ascending: true })\n      .limit(1)\n      .single();\n\n    if (error && error.code !== 'PGRST116') { // PGRST116 means no rows found, which is acceptable\n        throw error;\n    }\n    return data ?? undefined; // data can be null if no item is found, which is fine\n  },\n\n  async getQueueByStatus(status: string): Promise<DataProcessingQueue[]> {\n    try {\n      const { data, error }: PostgrestResponse<DataProcessingQueue> = await supabase\n        .from('data_processing_queue')\n        .select('*')\n        .eq('status', status)\n        .order('created_at', { ascending: false });\n\n      if (error) {\n        throw error;\n      }\n      return data ?? [];\n    } catch (error: unknown) {\n      console.warn('Error fetching queue:', error);\n      return [];\n    }\n  },\n  async updateQueueItem(\n    id: string,\n    updates: Partial<DataProcessingQueue>,\n  ): Promise<DataProcessingQueue> {\n    if (!supabaseAdmin) {\n      throw new Error('Admin operations require SUPABASE_SERVICE_ROLE_KEY');\n    }\n\n    const { data, error }: PostgrestSingleResponse<DataProcessingQueue> = await supabaseAdmin\n      .from('data_processing_queue')\n      .update({\n        ...updates,\n        ...(updates.status === 'completed' && { processed_at: new Date().toISOString() }),\n      })\n      .eq('id', id)\n      .select()\n      .single();\n\n    if (error) {\n        throw error;\n    }\n    if (!data) { // Handle null data case for updateQueueItem\n        throw new Error(`Failed to update queue item for ID ${id}, no data returned.`);\n    }\n    return data;\n  },\n};\n\nexport const DataQualityService = {\n  calculateQualityScore: (truck: FoodTruck) => {\n    // Placeholder for actual quality score calculation logic\n    // This should be implemented based on defined data quality rules\n    let score = 0;\n    // Ensure truck.name is a non-empty string\n    if (typeof truck.name === 'string' && truck.name.trim() !== '') {\n      score += 20;\n    }\n    // Ensure current_location and its properties are valid\n    if (\n      truck.current_location &&\n      typeof truck.current_location.lat === 'number' && !Number.isNaN(truck.current_location.lat) && truck.current_location.lat !== 0 &&\n      typeof truck.current_location.lng === 'number' && !Number.isNaN(truck.current_location.lng) && truck.current_location.lng !== 0\n    ) {\n      score += 30;\n    }\n    // Ensure contact_info and at least one contact method are valid\n    if (\n      truck.contact_info &&\n        ((typeof truck.contact_info.phone === 'string' && truck.contact_info.phone.trim() !== '') ||\n         (typeof truck.contact_info.email === 'string' && truck.contact_info.email.trim() !== '') ||\n         (typeof truck.contact_info.website === 'string' && truck.contact_info.website.trim() !== ''))\n    ) {\n      score += 25;\n    }\n    // Ensure menu is a non-empty array\n    if (Array.isArray(truck.menu) && truck.menu.length > 0) {\n      score += 15;\n    }\n    // Ensure operating_hours is defined (not null or undefined)\n    if (truck.operating_hours !== undefined && truck.operating_hours !== null) {\n      score += 10;\n    }\n    return { score: Math.min(100, score) };\n  },\n\n  async updateTruckQualityScore(truckId: string): Promise<FoodTruck | { error: string }> {\n    if (!supabaseAdmin) {\n      return { error: 'Admin operations require SUPABASE_SERVICE_ROLE_KEY' };\n    }\n    const { data: truck, error: fetchError } = await supabaseAdmin\n      .from('food_trucks')\n      .select('*')\n      .eq('id', truckId)\n      .single();\n\n    if (fetchError) {\n      handleSupabaseError(fetchError, 'updateTruckQualityScore:fetch');\n      return { error: `Failed to fetch truck with ID ${truckId}.` };\n    }\n    if (!truck) {\n      return { error: `Truck with ID ${truckId} not found.` };\n    }\n\n    const { score } = this.calculateQualityScore(truck);\n\n    const { data, error } = await supabaseAdmin\n      .from('food_trucks')\n      .update({ data_quality_score: score })\n      .eq('id', truckId)\n      .select()\n      .single();\n\n    if (error) {\n      handleSupabaseError(error, 'updateTruckQualityScore:update');\n      return { error: `Failed to update quality score for truck with ID ${truckId}.` };\n    }\n    if (!data) { // Handle null data case for updateTruckQualityScore\n        return { error: `Failed to update quality score for truck with ID ${truckId}, no data returned after update.`};\n    }\n    return data;\n  },\n};\n\nexport const APIUsageService = {\n  async trackUsage(serviceName: string, requests: number, tokens: number): Promise<ApiUsage> {\n    if (!supabaseAdmin) {\n      throw new Error('Admin operations require SUPABASE_SERVICE_ROLE_KEY');\n    }\n\n    try {\n      const today = new Date().toISOString().split('T')[0];\n\n      const { data: existing }: { data: ApiUsage | null; error: PostgrestError | null } = await supabaseAdmin\n        .from('api_usage')\n        .select('*')\n        .eq('service_name', serviceName)\n        .eq('usage_date', today)\n        .single();\n      if (existing) { // existing can be null if no record is found\n        const { data, error }: PostgrestSingleResponse<ApiUsage> = await supabaseAdmin\n          .from('api_usage')\n          .update({\n            requests_count: (existing.requests_count ?? 0) + requests, // Nullish coalescing for safety\n            tokens_used: (existing.tokens_used ?? 0) + tokens, // Nullish coalescing for safety\n          })\n          .eq('id', existing.id) // existing.id should be valid if existing is not null\n          .select()\n          .single();\n\n        if (error) {\n            throw error;\n        }\n        if (!data) { // Handle null data from update\n            throw new Error(\"Failed to update API usage, no data returned.\");\n        }\n        return data;\n      } else { // This block executes if existing is null\n        const { data, error }: PostgrestSingleResponse<ApiUsage> = await supabaseAdmin\n          .from('api_usage')\n          .insert([\n            {\n              service_name: serviceName,\n              usage_date: today,\n              requests_count: requests,\n              tokens_used: tokens,\n            },\n          ])\n          .select()\n          .single();\n\n        if (error) {\n            throw error;\n        }\n        if (!data) { // Handle null data from insert\n            throw new Error(\"Failed to insert API usage, no data returned.\");\n        }\n        return data;\n      }\n    } catch (error: unknown) {\n      console.warn('Error tracking usage:', error);\n      throw error;\n    }\n  },\n  async getTodayUsage(serviceName: string): Promise<ApiUsage | undefined> {\n    try {\n      const today = new Date().toISOString().split('T')[0];\n\n      const { data, error }: PostgrestSingleResponse<ApiUsage> = await supabase\n        .from('api_usage')\n        .select('*')\n        .eq('service_name', serviceName)\n        .eq('usage_date', today)\n        .single();\n\n      if (error && error.code !== 'PGRST116') { // PGRST116 means no rows found, which is acceptable\n        throw error;\n      }\n      return data ?? undefined; // data can be null if no item is found, which is fine\n    } catch (error: unknown) {\n      console.warn('Error getting today usage:', error);\n      throw error; // Re-throw after logging, or handle more gracefully\n    }\n  },\n\n  async getAllUsageStats(): Promise<ApiUsage[]> {\n    try {\n      const { data, error }: PostgrestResponse<ApiUsage> = await supabase\n        .from('api_usage')\n        .select('*')\n        .order('usage_date', { ascending: false })\n        .limit(30);\n\n      if (error) {\n        throw error;\n      }\n      return data ?? []; // data can be null if no items are found, return empty array\n    } catch (error: unknown) {\n      console.warn('Error getting usage stats:', error);\n      throw error; // Re-throw after logging, or handle more gracefully\n    }\n  },\n};\n\nexport { type MenuItem, type MenuCategory, type OperatingHours, type PriceRange } from './types';\n\n// Helper to prepare menu items for DB insertion\nfunction prepareMenuItemsForInsert(truckId: string, menuData: MenuCategory[] | unknown[] | undefined) {\n  if (!Array.isArray(menuData) || menuData.length === 0) {\n    return [];\n  }\n  // Explicitly filter for MenuCategory to ensure type safety\n  const categories = menuData.filter((category): category is MenuCategory =>\n    typeof category === 'object' && category !== null && 'name' in category && typeof category.name === 'string' &&\n    'items' in category && Array.isArray(category.items)\n  ); // Removed unnecessary 'as MenuCategory[]'\n\n  return categories.flatMap((category) => // category.name is now guaranteed to be a string\n    (Array.isArray(category.items) ? category.items : []).map((item: unknown) => {\n      // Type guard for MenuItem\n      const isMenuItem = (obj: unknown): obj is MenuItem =>\n        typeof obj === 'object' && obj !== null && 'name' in obj && typeof obj.name === 'string';\n\n      if (!isMenuItem(item)) {\n        console.warn('Skipping invalid menu item:', item);\n        return null; // Return null for invalid items to be filtered out later\n      }\n      // item.name is now guaranteed to be a string\n      return {\n        food_truck_id: truckId,\n        category: category.name.trim() !== '' ? category.name : 'Uncategorized',\n        name: item.name.trim() !== '' ? item.name : 'Unknown Item',\n        description: typeof item.description === 'string' && item.description.trim() !== '' ? item.description : undefined,\n        price: typeof item.price === 'number' && !Number.isNaN(item.price) ? item.price : undefined,\n        dietary_tags: Array.isArray(item.dietary_tags) ? item.dietary_tags : [],\n      };\n    }).filter(item => item !== null) as MenuItem[] // Filter out nulls and assert type. 'Boolean' constructor is not needed.\n  );\n}\n\nasync function insertMenuItems(truckId: string, menuData: MenuCategory[] | unknown[] | undefined) {\n  if (!supabaseAdmin) { // Added check for supabaseAdmin\n    console.error('supabaseAdmin is not initialized. Cannot insert menu items.');\n    return;\n  }\n  const menuItems = prepareMenuItemsForInsert(truckId, menuData);\n  if (menuItems.length === 0) {\n    return;\n  }\n  const { error: menuError } = await supabaseAdmin.from('menu_items').insert(menuItems); // Removed ! assertion\n  if (menuError) {\n    console.error('Error inserting menu items for truck', truckId, menuError);\n  }\n}\n\n// Fix all strict-boolean-expressions and always-true/false comparisons below\n// Example: if (someString) => if (typeof someString === 'string' && someString.trim() !== '')\n// Example: if (someNumber) => if (typeof someNumber === 'number' && !Number.isNaN(someNumber) && someNumber !== 0)\n// Example: if (someObject) => if (someObject != null && someObject != undefined)\n\n// For all other conditionals, ensure explicit nullish/empty/NaN checks as above\n\nexport {type PostgrestError, type PostgrestResponse} from '@supabase/supabase-js';\n","usedDeprecatedRules":[]},{"filePath":"/app/lib/supabaseMiddleware.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/lib/types.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":61,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":61,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1453,1456],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1453,1456],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":63,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":63,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1502,1505],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1502,1505],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":83,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":83,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2012,2015],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2012,2015],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":142,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":142,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3398,3401],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3398,3401],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":144,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":144,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3459,3462],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3459,3462],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":147,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":147,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3570,3573],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3570,3573],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Shared types for the Food Truck Finder application\n\nexport type PriceRange = '$|$$,$$$';\n\nexport interface MenuCategory {\n  name: string;\n  items: MenuItem[];\n}\n\nexport interface MenuItem {\n  name: string;\n  description: string | undefined;\n  price: number | string | undefined;\n  dietary_tags: string[];\n  is_popular?: boolean;\n}\n\nexport interface LocationData {\n  address: string | undefined;\n  city: string | undefined;\n  state: string | undefined;\n  landmarks: string[];\n  coordinates: {\n    lat: number | undefined;\n    lng: number | undefined;\n  };\n  confidence: number;\n  raw_location_text: string | undefined;\n}\n\nexport type DailyOperatingHours =\n  | { open: string; close: string; closed: boolean }\n  | { closed: true }\n  | undefined;\n\nexport interface OperatingHours {\n  monday: DailyOperatingHours;\n  tuesday: DailyOperatingHours;\n  wednesday: DailyOperatingHours;\n  thursday: DailyOperatingHours;\n  friday: DailyOperatingHours;\n  saturday: DailyOperatingHours;\n  sunday: DailyOperatingHours;\n  [key: string]: DailyOperatingHours; // Add index signature\n}\n\nexport interface SentimentAnalysisResult {\n  sentiment: 'positive' | 'negative' | 'neutral';\n  score: number;\n  confidence: number;\n  key_topics: string[];\n  positive_aspects: string[];\n  negative_aspects: string[];\n  summary: string;\n  recommended: boolean;\n}\n\nexport interface EnhancedFoodTruckData {\n  name: string | undefined;\n  description: string | undefined;\n  cuisine_type: any[];\n  price_range: PriceRange;\n  specialties: any[];\n  dietary_options: string[];\n  enhanced_menu: {\n    categories: MenuCategory[];\n  };\n  standardized_hours: OperatingHours;\n  cleaned_contact: {\n    phone: string | undefined;\n    email: string | undefined;\n    website: string | undefined;\n  };\n  data_quality_improvements: string[];\n  confidence_score: number;\n}\n\nexport interface ExtractedFoodTruckDetails {\n  name: string | undefined;\n  description: string | undefined;\n  cuisine_type: unknown[];\n  price_range: PriceRange | undefined;\n  specialties: any[];\n  current_location: {\n    address: string | undefined;\n    city: string | undefined;\n    state: string | undefined;\n    zip_code: string | undefined;\n    lat?: number;\n    lng?: number;\n    raw_text: string | undefined;\n  };\n  scheduled_locations?: {\n    // Added scheduled_locations\n    address?: string;\n    city?: string;\n    state?: string;\n    zip_code?: string;\n    lat?: number;\n    lng?: number;\n    timestamp: string;\n    start_time: string; // Added start_time\n    end_time: string; // Added end_time\n  }[];\n  operating_hours: OperatingHours;\n  menu: MenuCategory[];\n  contact_info: {\n    phone?: string;\n    email?: string;\n    website?: string;\n  };\n  social_media: {\n    instagram?: string;\n    facebook?: string;\n    twitter?: string;\n    tiktok?: string;\n    yelp?: string;\n  };\n  source_url: string;\n}\n\nexport interface FirecrawlOutputData {\n  markdown: string;\n  name?: string;\n  source_url?: string;\n}\n\nexport interface FoodTruckSchema {\n  name: string;\n  description?: string;\n  current_location: {\n    lat: number;\n    lng: number;\n    address: string | undefined;\n    timestamp: string;\n  };\n  scheduled_locations: ExtractedFoodTruckDetails['scheduled_locations'];\n  operating_hours: OperatingHours;\n  menu: MenuCategory[];\n  contact_info: ExtractedFoodTruckDetails['contact_info'];\n  social_media: ExtractedFoodTruckDetails['social_media'];\n  cuisine_type: any[];\n  price_range: PriceRange | undefined;\n  specialties: any[];\n  data_quality_score: number;\n  verification_status: 'pending' | 'verified' | 'flagged';\n  source_urls: any[];\n  last_scraped_at: string;\n  test_run_flag?: boolean;\n  website?: string;\n  phone_number?: string;\n  email?: string;\n  instagram_handle?: string;\n  facebook_handle?: string;\n  twitter_handle?: string;\n  schedule?: unknown[]; // Assuming schedule is an array, adjust type if known\n  average_rating?: number;\n  review_count?: number;\n}\n\n// Database record type with additional fields\nexport interface FoodTruck extends FoodTruckSchema {\n  id: string;\n  created_at: string;\n  updated_at: string;\n  is_active?: boolean;\n}\n\nexport interface GeminiResponse<T = unknown> {\n  success: boolean;\n  data?: T;\n  tokensUsed?: number;\n  error?: string;\n  promptSent?: string;\n}\n\nexport interface StageResult {\n  status: string;\n  data?: FirecrawlOutputData | ExtractedFoodTruckDetails | FoodTruckSchema;\n  error?: string;\n  details?: string;\n  prompt?: string;\n  tokensUsed?: number;\n  metadata?: { name?: string; source_url?: string };\n  rawContent?: string;\n  preparedData?: FoodTruckSchema;\n  recordId?: string;\n}\n\nexport interface TestPipelineResults {\n  firecrawl?: StageResult;\n  gemini?: StageResult;\n  supabase?: StageResult;\n  overallStatus?: string;\n  logs?: string[];\n  error?: string;\n}\n\nexport interface PipelineRunResult {\n  firecrawl?: StageResult;\n  gemini?: StageResult;\n  supabase?: StageResult;\n  logs: string[];\n  overallStatus: 'Success' | 'Error';\n}\n","usedDeprecatedRules":[]},{"filePath":"/app/lib/types/foodTruck.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/lib/types/webVitals.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/lib/utils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/lib/utils/QualityScorer.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/lib/utils/dataQualityFormatters.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/app/lib/utils/foodTruckHelpers.ts","messages":[{"ruleId":"unicorn/no-null","severity":1,"message":"Use `undefined` instead of `null`.","line":31,"column":53,"nodeType":"Literal","messageId":"error","endLine":31,"endColumn":57,"fix":{"range":[1362,1366],"text":"undefined"}},{"ruleId":"unicorn/no-null","severity":1,"message":"Use `undefined` instead of `null`.","line":36,"column":21,"nodeType":"Literal","messageId":"error","endLine":36,"endColumn":25,"fix":{"range":[1550,1554],"text":"undefined"}}],"suppressedMessages":[{"ruleId":"sonarjs/no-intrusive-permissions","severity":2,"message":"Make sure the use of the geolocation is necessary.","line":63,"column":5,"nodeType":"MemberExpression","messageId":"checkPermission","endLine":63,"endColumn":45,"suppressions":[{"kind":"directive","justification":"Geolocation is essential for finding nearby food trucks"}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":2,"source":"import { FoodTruck, DailyOperatingHours, MenuItem } from '@/lib/types'; // Added DailyOperatingHours, PriceRange, MenuItem\n\nexport const getCurrentDay = () => {\n  const days = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];\n  return days[new Date().getDay()];\n};\n\nexport const formatPrice = (price: number | string) => { // Updated to accept string\n  if (typeof price === 'string') {\n    // Handle cases where price might be a string like \"$10-$20\" or \"Varies\"\n    return price;\n  }\n  return new Intl.NumberFormat('en-US', {\n    style: 'currency',\n    currency: 'USD',\n  }).format(price);\n};\n\nexport const formatHours = (hours: DailyOperatingHours) => { // Updated to accept DailyOperatingHours\n    if (!hours || hours.closed) {\n        return 'Closed';\n    }\n    const open = new Date(`1970-01-01T${hours.open}Z`).toLocaleTimeString('en-US', {hour: 'numeric', minute: 'numeric', hour12: true});\n    const close = new Date(`1970-01-01T${hours.close}Z`).toLocaleTimeString('en-US', {hour: 'numeric', minute: 'numeric', hour12: true});\n    return `${open} - ${close}`;\n}\n\nexport const getPopularItems = (truck: FoodTruck): MenuItem[] => { // Explicitly define return type\n    // Explicitly check for nullish and boolean\n    return (truck.menu?.flatMap(category => category.items)\n        .filter((item): item is MenuItem => item != null && item.is_popular === true) ?? []);\n}\n\nexport const getPriceRange = (truck: FoodTruck) => {\n    const allItems = truck.menu?.flatMap(category => category.items);\n    if (allItems == null || allItems.length === 0) { // Explicitly check for null/undefined\n        return 'N/A';\n    }\n    const numericPrices = allItems\n        .map(item => item.price)\n        .filter((price): price is number => typeof price === 'number' && price != undefined); // Filter for numbers\n\n    if (numericPrices.length === 0) {\n        return 'N/A'; // No numeric prices found\n    }\n\n    const minPrice = Math.min(...numericPrices);\n    const maxPrice = Math.max(...numericPrices);\n    return `${formatPrice(minPrice)} - ${formatPrice(maxPrice)}`;\n}\n\nexport const getTodayHours = (truck: FoodTruck) => {\n    const today = getCurrentDay();\n    return truck.operating_hours?.[today];\n}\n\n// Get user's current location or default to San Francisco\nexport function getUserLocationHelper(\n  setUserLocation: (location: { lat: number; lng: number }) => void\n) {\n  if (typeof navigator !== 'undefined' && navigator.geolocation != undefined) {\n    // eslint-disable-next-line sonarjs/no-intrusive-permissions -- Geolocation is essential for finding nearby food trucks\n    navigator.geolocation.getCurrentPosition(\n      (position) => {\n        setUserLocation({\n          lat: position.coords.latitude,\n          lng: position.coords.longitude,\n        });\n      },\n      (error) => {\n        console.warn('Location access denied:', error);\n        // Default to San Francisco\n        setUserLocation({ lat: 37.7749, lng: -122.4194 });\n      },\n    );\n  } else {\n    // Default to San Francisco if geolocation is not supported\n    setUserLocation({ lat: 37.7749, lng: -122.4194 });\n  }\n}\n\n// Load all food trucks from API\nexport async function loadFoodTrucksHelper(\n  setTrucks: (trucks: FoodTruck[]) => void,\n  setLoading: (loading: boolean) => void\n) {\n  try {\n    const response = await fetch('/api/trucks');\n    const data: unknown = await response.json();\n    if (typeof data === 'object' && data != undefined && 'trucks' in data && Array.isArray(data.trucks)) {\n      setTrucks(data.trucks as FoodTruck[]);\n    } else {\n      setTrucks([]);\n    }\n  } catch (error: unknown) {\n    console.error('Failed to load food trucks:', error);\n  } finally {\n    setLoading(false);\n  }\n}\n\n// Load nearby food trucks based on user location\nexport async function loadNearbyTrucksHelper(\n  userLocation: { lat: number; lng: number } | undefined,\n  setTrucks: (trucks: FoodTruck[]) => void\n) {\n  if (!userLocation) return;\n\n  try {\n    const response = await fetch(\n      `/api/trucks?lat=${userLocation.lat}&lng=${userLocation.lng}&radius=10`,\n    );\n    const data: unknown = await response.json();\n    if (typeof data === 'object' && data != undefined && 'trucks' in data && Array.isArray(data.trucks)) {\n      setTrucks(data.trucks as FoodTruck[]);\n    } else {\n      setTrucks([]);\n    }\n  } catch (error: unknown) {\n    console.error('Failed to load nearby trucks:', error);\n  }\n}\n\n// Check if a food truck is currently open\nexport function isTruckOpen(truck: FoodTruck): boolean {\n  const today = getCurrentDay();\n  const hours = truck.operating_hours?.[today];\n\n  // Ensure hours and its properties are not null/undefined before accessing\n  if (hours == undefined || hours.closed === true || hours.open == undefined || hours.close == undefined) {\n    return false;\n  }\n\n  try {\n    const now = new Date();\n    const currentTime = now.getHours() * 100 + now.getMinutes();\n    const openTime = Number.parseInt(hours.open.replace(':', ''));\n    const closeTime = Number.parseInt(hours.close.replace(':', ''));\n\n    return currentTime >= openTime && currentTime <= closeTime;\n  } catch (error: unknown) {\n    console.error('Error parsing operating hours for truck', truck.name, error);\n    return false;\n  }\n}\n","usedDeprecatedRules":[]}]