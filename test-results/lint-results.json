[
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\app\\access-denied\\page.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\app\\admin\\analytics\\page.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\app\\admin\\auto-scraping\\page.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\app\\admin\\data-cleanup\\page.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\app\\admin\\data-quality\\page.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\app\\admin\\events\\page.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\app\\admin\\food-trucks\\[id]\\page.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\app\\admin\\food-trucks\\page.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\app\\admin\\layout.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\app\\admin\\monitoring\\page.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\app\\admin\\page.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\app\\admin\\pipeline\\page.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\app\\admin\\test-pipeline\\page.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\app\\admin\\users\\page.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\app\\api\\admin\\automated-cleanup\\route.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\app\\api\\admin\\cron-status\\route.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\app\\api\\admin\\data-cleanup\\route.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\app\\api\\admin\\data-quality\\route.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\app\\api\\admin\\oauth-status\\route.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\app\\api\\admin\\realtime-events\\route.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\app\\api\\admin\\scraping-metrics\\route.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\app\\api\\analytics\\web-vitals\\route.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\app\\api\\auto-scrape-initiate\\route.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\app\\api\\autonomous-discovery\\route.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\app\\api\\cron\\auto-scrape\\route.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\app\\api\\cron\\quality-check\\route.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\app\\api\\dashboard\\route.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\app\\api\\enhanced-pipeline\\route.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\app\\api\\firecrawl\\route.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\app\\api\\gemini\\route.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\app\\api\\monitoring\\api-usage\\route.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\app\\api\\pipeline\\route.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\app\\api\\scheduler\\route.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\app\\api\\scrape\\route.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\app\\api\\search\\route.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\app\\api\\tavily\\route.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\app\\api\\test-integration\\route.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\app\\api\\test-pipeline-run\\route.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\app\\api\\trucks\\[id]\\route.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\app\\api\\trucks\\route.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\app\\auth\\AuthProvider.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\app\\auth\\callback\\route.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\app\\layout.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\app\\loading.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\app\\login\\page.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\app\\middleware.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\app\\page.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\app\\trucks\\[id]\\page.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\FoodTruckInfoCard.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\MapDisplay.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\ModeToggle.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\SearchFilters.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\ThemeProvider.tsx",
    "messages": [],
    "suppressedMessages": [
      {
        "ruleId": "sonarjs/different-types-comparison",
        "severity": 2,
        "message": "Remove this \"===\" check; it will always be false. Did you mean to use \"==\"?",
        "line": 30,
        "column": 15,
        "nodeType": null,
        "endLine": 30,
        "endColumn": 18,
        "suggestions": [
          { "desc": "Replace \"===\" with \"==\"", "fix": { "range": [860, 863], "text": "==" } }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      }
    ],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\TruckCard.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\WebVitalsReporter.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\admin\\AdminNavLinks.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\admin\\DataCleanupDashboard.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\admin\\RealtimeStatusIndicator.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\admin\\UserMenu.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\admin\\cleanup\\CleanupGuide.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\admin\\cleanup\\CleanupHeader.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\admin\\cleanup\\CleanupOperationDetails.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\admin\\cleanup\\CleanupPreview.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\admin\\cleanup\\CleanupResults.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\admin\\cleanup\\CleanupSummaryCards.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\admin\\cleanup\\OperationSelector.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\admin\\dashboard\\DataQualityScoreCard.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\admin\\dashboard\\PipelineStatusCard.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\admin\\dashboard\\QualityDistributionCard.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\admin\\dashboard\\RecentErrorsCard.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\admin\\dashboard\\TotalFoodTrucksCard.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\admin\\food-trucks\\detail\\BasicInfoCard.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\admin\\food-trucks\\detail\\ContactField.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 33,
        "column": 10,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 33,
        "endColumn": 14,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [916, 920], "text": "(href != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [916, 920], "text": "(href ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [916, 920], "text": "(Boolean(href))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import React from 'react';\r\n// Removed Mail, Phone, Globe imports as they are not directly used here\r\n\r\ninterface ContactFieldProps {\r\n  readonly icon: React.ComponentType<{ className?: string }>;\r\n  readonly label: string;\r\n  readonly value?: string;\r\n  readonly href?: string;\r\n  readonly unavailableText: string;\r\n}\r\n\r\nexport function ContactField({\r\n  icon: Icon,\r\n  label,\r\n  value,\r\n  href,\r\n  unavailableText\r\n}: Readonly<ContactFieldProps>) {\r\n  if (value == undefined || value.length === 0) {\r\n    return (\r\n      <div className=\"flex items-center gap-3 text-gray-400\">\r\n        <Icon className=\"h-4 w-4\" />\r\n        <span className=\"text-sm\">{unavailableText}</span>\r\n      </div>\r\n    );\r\n  }\r\n\r\n  return (\r\n    <div className=\"flex items-center gap-3\">\r\n      <Icon className=\"h-4 w-4 text-gray-500\" />\r\n      <div>\r\n        <label className=\"text-sm font-medium text-gray-500\">{label}</label>\r\n        {href ? (\r\n          <a\r\n            href={href}\r\n            target=\"_blank\"\r\n            rel=\"noopener noreferrer\"\r\n            className=\"text-blue-600 hover:text-blue-800 underline\"\r\n          >\r\n            {value}\r\n          </a>\r\n        ) : (\r\n          <p className=\"text-gray-900\">{value}</p>\r\n        )}\r\n      </div>\r\n    </div>\r\n  );\r\n}\r\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\admin\\food-trucks\\detail\\ContactInfoCard.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\admin\\food-trucks\\detail\\DataQualityCard.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\admin\\food-trucks\\detail\\LocationInfoCard.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\admin\\food-trucks\\detail\\OperatingHoursCard.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\admin\\food-trucks\\detail\\QualityMetricsGrid.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\admin\\food-trucks\\detail\\QualityScoreMetric.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\admin\\food-trucks\\detail\\RatingsReviewsCard.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\admin\\food-trucks\\detail\\SocialMediaLinks.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\admin\\food-trucks\\detail\\TruckDetailHeader.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\admin\\food-trucks\\detail\\TruckNotFound.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\admin\\pipeline\\FailedProcessingQueueTable.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\admin\\pipeline\\PipelineStatisticsCards.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\admin\\pipeline\\RecentScrapingJobsTable.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\admin\\pipeline\\ScrapingJobRow.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\admin\\pipeline\\ScrapingJobsTableContent.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\admin\\realtime\\AlertListDisplay.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\admin\\realtime\\AlertToggleButton.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\admin\\realtime\\ConnectionStatusHeader.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\admin\\realtime\\EventControls.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\admin\\realtime\\RealtimeStatusDisplay.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\admin\\realtime\\ScrapingJobsStatus.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\admin\\realtime\\StatusHelpers.tsx",
    "messages": [
      {
        "ruleId": "sonarjs/function-return-type",
        "severity": 2,
        "message": "Refactor this function to always return the same type.",
        "line": 23,
        "column": 64,
        "nodeType": null,
        "endLine": 23,
        "endColumn": 66
      },
      {
        "ruleId": "sonarjs/function-return-type",
        "severity": 2,
        "message": "Refactor this function to always return the same type.",
        "line": 40,
        "column": 63,
        "nodeType": null,
        "endLine": 40,
        "endColumn": 65
      },
      {
        "ruleId": "unicorn/no-null",
        "severity": 1,
        "message": "Use `undefined` instead of `null`.",
        "line": 47,
        "column": 14,
        "nodeType": "Literal",
        "messageId": "error",
        "endLine": 47,
        "endColumn": 18,
        "suggestions": [
          {
            "messageId": "remove",
            "fix": { "range": [1338, 1342], "text": "" },
            "data": {},
            "desc": "Remove `null`."
          },
          {
            "messageId": "replace",
            "fix": { "range": [1338, 1342], "text": "undefined" },
            "data": {},
            "desc": "Replace `null` with `undefined`."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 2,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import React from 'react';\nimport { AlertTriangle, CheckCircle, Clock, TrendingUp, TrendingDown } from 'lucide-react';\n\ntype Status = 'healthy' | 'warning' | 'error' | 'unknown';\n\nexport const getStatusColor = (status: Status): string => {\n  switch (status) {\n    case 'healthy': {\n      return 'text-green-600 bg-green-50 border-green-200';\n    }\n    case 'warning': {\n      return 'text-yellow-600 bg-yellow-50 border-yellow-200';\n    }\n    case 'error': {\n      return 'text-red-600 bg-red-50 border-red-200';\n    }\n    default: {\n      return 'text-gray-600 bg-gray-50 border-gray-200';\n    }\n  }\n};\n\nexport const getStatusIcon = (status: Status): React.ReactNode => {\n  switch (status) {\n    case 'healthy': {\n      return <CheckCircle className=\"h-4 w-4 text-green-600\" />;\n    }\n    case 'warning': {\n      return <AlertTriangle className=\"h-4 w-4 text-yellow-600\" />;\n    }\n    case 'error': {\n      return <AlertTriangle className=\"h-4 w-4 text-red-600\" />;\n    }\n    default: {\n      return <Clock className=\"h-4 w-4 text-gray-600\" />;\n    }\n  }\n};\n\nexport const getTrendIcon = (trend?: string): React.ReactNode => {\n  switch (trend) {\n    case 'up': { return <TrendingUp className=\"h-3 w-3 text-green-600\" />;\n    }\n    case 'down': { return <TrendingDown className=\"h-3 w-3 text-red-600\" />;\n    }\n    default: {\n      return null; // Explicitly return null when no icon is needed\n    }\n  }\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\admin\\realtime\\SystemAlertItem.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\admin\\realtime\\SystemAlerts.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\admin\\realtime\\SystemMetricsGrid.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\admin\\realtime\\useSystemAlertsLogic.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\admin\\realtime\\useSystemMetrics.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\admin\\users\\UserTable.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\home\\AppHeader.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\home\\LoadingScreen.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\home\\MainContent.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\home\\MapSection.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\home\\TruckAccordionContent.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\home\\TruckListHeader.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\home\\TruckListSection.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\login\\EmailFormFields.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\map\\MapContent.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\map\\MapLoadingFallback.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\map\\MapViewUpdater.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\map\\TruckMarkers.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\map\\UserLocationMarker.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\map\\mapHelpers.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\monitoring\\ApiMonitoringDashboard.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\monitoring\\FeatureCard.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\monitoring\\FeatureList.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\monitoring\\FeatureOverviewCards.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\monitoring\\FeatureOverviewContent.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\monitoring\\MonitoringFeaturesCard.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\monitoring\\MonitoringFeaturesContent.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\monitoring\\MonitoringPageHeader.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\monitoring\\TechnicalDetailsCard.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\search\\AdvancedFilters.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\search\\CuisineTypesSection.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\search\\DistanceSliderSection.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\search\\FilterToggleButton.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\search\\MainSearchSection.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\search\\QuickFiltersSection.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\search\\SearchFilterContent.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\search\\SearchInputWithIcon.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\test-pipeline\\ErrorDisplay.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\test-pipeline\\StageResultCard.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\test-pipeline\\StageResultDetails.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\test-pipeline\\TestPipelineForm.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\test-pipeline\\TestPipelineSubmitHandler.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\test-pipeline\\TestResultsDisplay.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\trucks\\ContactSection.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\trucks\\MenuSection.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\trucks\\OperatingHoursSection.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\trucks\\RatingSection.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\trucks\\SocialMediaSection.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\trucks\\TruckAccordionItem.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'selectedTruckId' is defined but never used. Allowed unused args must match /^_/u.",
        "line": 21,
        "column": 3,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 21,
        "endColumn": 18
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import React from 'react';\r\nimport {\r\n  AccordionContent,\r\n  AccordionItem,\r\n  AccordionTrigger,\r\n} from '@/components/ui/accordion';\r\nimport { Badge } from '@/components/ui/badge';\r\nimport { TruckCard } from '@/components/TruckCard';\r\nimport { FoodTruck } from '@/lib/types/foodTruck';\r\n\r\ninterface TruckAccordionItemProps {\r\n  readonly truck: FoodTruck;\r\n  readonly selectedTruckId: string | undefined;\r\n  readonly setSelectedTruckId: (id: string | undefined) => void;\r\n  readonly isOpen: (truck: FoodTruck) => boolean;\r\n  readonly userLocation: { lat: number; lng: number } | undefined;\r\n}\r\n\r\nexport function TruckAccordionItem({\r\n  truck,\r\n  selectedTruckId,\r\n  setSelectedTruckId,\r\n  isOpen,\r\n  userLocation,\r\n}: TruckAccordionItemProps) {\r\n  return (\r\n    <AccordionItem value={truck.id} key={truck.id}>\r\n      <AccordionTrigger className=\"flex items-center justify-between p-4 hover:bg-gray-50 dark:hover:bg-slate-700 rounded-md\">\r\n        <div className=\"flex-1 text-left\">\r\n          <h4 className=\"font-medium dark:text-gray-100\">{truck.name}</h4>\r\n          {truck.current_location?.address && (\r\n            <p className=\"text-sm text-gray-600 dark:text-gray-400 line-clamp-1\">\r\n              {truck.current_location.address}\r\n            </p>\r\n          )}\r\n        </div>\r\n        <Badge variant={isOpen(truck) ? 'default' : 'secondary'}>\r\n          {isOpen(truck) ? 'Open' : 'Closed'}\r\n        </Badge>\r\n      </AccordionTrigger>\r\n      <AccordionContent>\r\n        <TruckCard\r\n          truck={truck}\r\n          isOpen={isOpen(truck)}\r\n          onSelectTruck={() => setSelectedTruckId(truck.id)}\r\n          userLocation={userLocation}\r\n          hideHeader={true}\r\n        />\r\n      </AccordionContent>\r\n    </AccordionItem>\r\n  );\r\n}\r\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\trucks\\TruckBasicInfo.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected object value in conditional. The condition is always true.",
        "line": 30,
        "column": 10,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorObject",
        "endLine": 30,
        "endColumn": 28
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import React from 'react';\r\nimport { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';\r\nimport { Badge } from '@/components/ui/badge';\r\nimport type { FoodTruck } from '@/lib/supabase';\r\n\r\ninterface TruckBasicInfoProps {\r\n  readonly truck: FoodTruck;\r\n}\r\n\r\nexport function TruckBasicInfo({ truck }: Readonly<TruckBasicInfoProps>) {\r\n  return (\r\n    <Card className=\"dark:bg-slate-800 dark:border-slate-700\">\r\n      <CardHeader>\r\n        <CardTitle className=\"dark:text-gray-100\">About</CardTitle>\r\n        <CardDescription className=\"dark:text-gray-400\">Food truck information</CardDescription>\r\n      </CardHeader>\r\n      <CardContent className=\"space-y-4\">\r\n        <div>\r\n          <label className=\"text-sm font-medium text-gray-500 dark:text-gray-400\">Name</label>\r\n          <p className=\"text-lg font-semibold dark:text-gray-100\">{truck.name}</p>\r\n        </div>\r\n        \r\n        {truck.description != undefined && (\r\n          <div>\r\n            <label className=\"text-sm font-medium text-gray-500 dark:text-gray-400\">Description</label>\r\n            <p className=\"text-gray-900 dark:text-gray-200\">{truck.description}</p>\r\n          </div>\r\n        )}\r\n\r\n        {truck.cuisine_type && (\r\n          <div>\r\n            <label className=\"text-sm font-medium text-gray-500 dark:text-gray-400\">Cuisine Type</label>\r\n            <p className=\"text-gray-900 dark:text-gray-200\">{truck.cuisine_type}</p>\r\n          </div>\r\n        )}\r\n\r\n        {truck.price_range && (\r\n          <div>\r\n            <label className=\"text-sm font-medium text-gray-500 dark:text-gray-400\">Price Range</label>\r\n            <Badge variant=\"outline\" className=\"ml-2\">\r\n              {truck.price_range}\r\n            </Badge>\r\n          </div>\r\n        )}\r\n      </CardContent>\r\n    </Card>\r\n  );\r\n}\r\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\trucks\\TruckCardContent.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 24,
        "column": 8,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 24,
        "endColumn": 25,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [804, 821], "text": "(truck.description != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [804, 821], "text": "(truck.description ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [804, 821], "text": "(Boolean(truck.description))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import React from 'react';\r\nimport { Badge } from '@/components/ui/badge';\r\nimport { FoodTruck, DailyOperatingHours, MenuItem } from '@/lib/types';\r\nimport { RatingSection } from './RatingSection';\r\nimport { MenuSection } from './MenuSection';\r\nimport { ContactSection } from './ContactSection';\r\nimport { SocialMediaSection } from './SocialMediaSection';\r\nimport { OperatingHoursSection } from './OperatingHoursSection';\r\nimport { formatHours } from '@/lib/utils/foodTruckHelpers';\r\n\r\ninterface TruckCardContentProps {\r\n  readonly truck: FoodTruck;\r\n  readonly todayHours?: DailyOperatingHours;\r\n  readonly popularItems: MenuItem[]; // Use the full MenuItem type\r\n}\r\n\r\nexport function TruckCardContent({\r\n  truck,\r\n  todayHours,\r\n  popularItems,\r\n}: TruckCardContentProps) {\r\n  return (\r\n    <>\r\n      {truck.description && (\r\n        <p className=\"text-gray-600 dark:text-gray-400 mb-4 line-clamp-2\">{truck.description}</p>\r\n      )}\r\n      <div className=\"space-y-4\">\r\n        {/* Ratings & Hours Row */}\r\n        <div className=\"grid grid-cols-1 md:grid-cols-2 gap-4\">\r\n          <RatingSection averageRating={truck.average_rating} reviewCount={truck.review_count} />\r\n          <OperatingHoursSection todayHours={todayHours} formatHours={formatHours} />\r\n        </div>\r\n\r\n        {/* Menu & Contact Row */}\r\n        <div className=\"grid grid-cols-1 md:grid-cols-2 gap-4\">\r\n          <MenuSection popularItems={popularItems} />\r\n          <ContactSection contactInfo={truck.contact_info} verificationStatus={truck.verification_status} />\r\n        </div>\r\n\r\n        <SocialMediaSection socialMedia={truck.social_media} />\r\n      </div>\r\n      {truck.verification_status && (\r\n        <div className=\"mt-2\">\r\n          <Badge variant={truck.verification_status === 'verified' ? 'default' : 'secondary'}>\r\n            <span className=\"capitalize\">{truck.verification_status}</span>\r\n          </Badge>\r\n        </div>\r\n      )}\r\n    </>\r\n  );\r\n}\r\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\trucks\\TruckCardFooter.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\trucks\\TruckCardHeader.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected value in conditional. A boolean expression is required.",
        "line": 35,
        "column": 42,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorOther",
        "endLine": 35,
        "endColumn": 52
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 35,
        "column": 57,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 35,
        "endColumn": 67,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [1384, 1394], "text": "(priceRange != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [1384, 1394], "text": "(priceRange ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [1384, 1394], "text": "(Boolean(priceRange))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 2,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import React from 'react';\r\nimport { CardHeader, CardTitle, CardDescription } from '@/components/ui/card';\r\nimport { Badge } from '@/components/ui/badge';\r\nimport { MapPin } from 'lucide-react';\r\nimport { FoodTruck } from '@/lib/types';\r\n\r\ninterface TruckCardHeaderProps {\r\n  readonly truck: FoodTruck;\r\n  readonly isOpen: boolean;\r\n  readonly popularItems: Array<{ name: string; price: number | string | undefined }>;\r\n  readonly priceRange: string | undefined;\r\n}\r\n\r\nexport function TruckCardHeader({\r\n  truck,\r\n  isOpen,\r\n  popularItems,\r\n  priceRange\r\n}: TruckCardHeaderProps) {\r\n  return (\r\n    <CardHeader>\r\n      <div className=\"flex justify-between items-start\">\r\n        <div className=\"flex-1\">\r\n          <CardTitle className=\"text-lg dark:text-gray-100\">{truck.name}</CardTitle>\r\n          {(truck.current_location?.address != undefined) && (\r\n            <CardDescription className=\"flex items-center mt-1 dark:text-gray-400\">\r\n              <MapPin className=\"h-4 w-4 mr-1\" />\r\n              {truck.current_location.address}\r\n            </CardDescription>\r\n          )}\r\n        </div>\r\n        <div className=\"flex flex-col items-end space-y-1\">\r\n          <Badge variant={isOpen ? 'default' : 'secondary'}>{isOpen ? 'Open' : 'Closed'}</Badge>\r\n          {/* Show price range fallback if no explicit prices */}\r\n          {popularItems.every((item) => !item.price) && priceRange && (\r\n            <Badge variant=\"outline\" className=\"mt-1\">\r\n              {priceRange}\r\n            </Badge>\r\n          )}\r\n        </div>\r\n      </div>\r\n    </CardHeader>\r\n  );\r\n}\r\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\trucks\\TruckContactInfo.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 39,
        "column": 10,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 39,
        "endColumn": 14,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [1183, 1187], "text": "(href != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [1183, 1187], "text": "(href ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [1183, 1187], "text": "(Boolean(href))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 108,
        "column": 17,
        "nodeType": "ChainExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 108,
        "endColumn": 42,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [3800, 3825], "text": "((truck.contact_info?.phone) != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [3800, 3825], "text": "((truck.contact_info?.phone) ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [3800, 3825], "text": "(Boolean((truck.contact_info?.phone)))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 116,
        "column": 17,
        "nodeType": "ChainExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 116,
        "endColumn": 42,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [4077, 4102], "text": "((truck.contact_info?.email) != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [4077, 4102], "text": "((truck.contact_info?.email) ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [4077, 4102], "text": "(Boolean((truck.contact_info?.email)))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 3,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import React from 'react';\r\nimport { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';\r\nimport { Phone, Mail, Globe } from 'lucide-react';\r\nimport type { FoodTruck } from '@/lib/supabase';\r\n\r\ninterface TruckContactInfoProps {\r\n  readonly truck: FoodTruck;\r\n}\r\n\r\ninterface ContactFieldProps {\r\n  readonly icon: React.ComponentType<{ className?: string }>;\r\n  readonly label: string;\r\n  readonly value?: string | null;\r\n  readonly href?: string;\r\n  readonly unavailableText: string;\r\n}\r\n\r\nfunction ContactField({ \r\n  icon: Icon, \r\n  label, \r\n  value, \r\n  href, \r\n  unavailableText \r\n}: Readonly<ContactFieldProps>) {\r\n  if (value == undefined || value.length === 0) { // Handles null, undefined, and empty string\r\n    return (\r\n      <div className=\"flex items-center gap-3 text-gray-400\">\r\n        <Icon className=\"h-4 w-4\" />\r\n        <span className=\"text-sm\">{unavailableText}</span>\r\n      </div>\r\n    );\r\n  }\r\n\r\n  return (\r\n    <div className=\"flex items-center gap-3\">\r\n      <Icon className=\"h-4 w-4 text-gray-500\" />\r\n      <div>\r\n        <label className=\"text-sm font-medium text-gray-500 dark:text-gray-400\">{label}</label>\r\n        {href ? (\r\n          <a \r\n            href={href}\r\n            target={href.startsWith('http') ? '_blank' : undefined}\r\n            rel={href.startsWith('http') ? 'noopener noreferrer' : undefined}\r\n            className=\"block text-blue-600 hover:text-blue-800 dark:text-blue-400 dark:hover:text-blue-300 underline\"\r\n          >\r\n            {href.startsWith('http') ? 'Visit Website' : value}\r\n          </a>\r\n        ) : (\r\n          <p className=\"text-gray-900 dark:text-gray-200\">{value}</p>\r\n        )}\r\n      </div>\r\n    </div>\r\n  );\r\n}\r\n\r\nfunction SocialMediaLinks({ socialMedia }: Readonly<{ readonly socialMedia?: Record<string, string> }>) {\r\n  if (socialMedia == undefined || Object.keys(socialMedia).length === 0) {\r\n    return;\r\n  }\r\n\r\n  const socialPlatforms = [\r\n    { key: 'instagram', name: 'Instagram', baseUrl: 'https://instagram.com/', color: 'pink' },\r\n    { key: 'facebook', name: 'Facebook', baseUrl: 'https://facebook.com/', color: 'blue' },\r\n    { key: 'twitter', name: 'Twitter', baseUrl: 'https://twitter.com/', color: 'sky' },\r\n  ];\r\n\r\n  return (\r\n    <div>\r\n      <label className=\"text-sm font-medium text-gray-500 dark:text-gray-400\">Social Media</label>\r\n      <div className=\"flex flex-wrap gap-2 mt-2\">\r\n        {socialPlatforms.map(({ key, name, baseUrl, color }) => {\r\n          const handle = socialMedia[key];\r\n          if (handle == undefined || handle.length === 0) return; // Handles null, undefined, and empty string\r\n\r\n          return (\r\n            <a\r\n              key={key}\r\n              href={`${baseUrl}${handle}`}\r\n              target=\"_blank\"\r\n              rel=\"noopener noreferrer\"\r\n              className={`flex items-center gap-1 px-2 py-1 bg-${color}-100 text-${color}-800 rounded-md text-sm hover:bg-${color}-200 dark:bg-${color}-900 dark:text-${color}-200`}\r\n            >\r\n              <Globe className=\"h-3 w-3\" />\r\n              {name}\r\n            </a>\r\n          );\r\n        })}\r\n      </div>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport function TruckContactInfo({ truck }: Readonly<TruckContactInfoProps>) {\r\n  return (\r\n    <Card className=\"dark:bg-slate-800 dark:border-slate-700\">\r\n      <CardHeader>\r\n        <CardTitle className=\"flex items-center gap-2 dark:text-gray-100\">\r\n          <Phone className=\"h-5 w-5\" />\r\n          Contact Information\r\n        </CardTitle>\r\n        <CardDescription className=\"dark:text-gray-400\">Get in touch</CardDescription>\r\n      </CardHeader>\r\n      <CardContent className=\"space-y-4\">\r\n        <ContactField\r\n          icon={Phone}\r\n          label=\"Phone\"\r\n          value={truck.contact_info?.phone}\r\n          href={truck.contact_info?.phone ? `tel:${truck.contact_info.phone}` : undefined}\r\n          unavailableText=\"No phone number available\"\r\n        />\r\n\r\n        <ContactField\r\n          icon={Mail}\r\n          label=\"Email\"\r\n          value={truck.contact_info?.email}\r\n          href={truck.contact_info?.email ? `mailto:${truck.contact_info.email}` : undefined}\r\n          unavailableText=\"No email available\"\r\n        />\r\n\r\n        <ContactField\r\n          icon={Globe}\r\n          label=\"Website\"\r\n          value={truck.contact_info?.website}\r\n          href={truck.contact_info?.website}\r\n          unavailableText=\"No website available\"\r\n        />\r\n\r\n        <SocialMediaLinks socialMedia={truck.social_media} />\r\n      </CardContent>\r\n    </Card>\r\n  );\r\n}\r\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\trucks\\TruckDetailHeader.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\trucks\\TruckLocationInfo.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\trucks\\TruckNotFound.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\trucks\\TruckOperatingHours.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected object value in conditional. The condition is always true.",
        "line": 31,
        "column": 29,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorObject",
        "endLine": 31,
        "endColumn": 50
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import React from 'react';\r\nimport { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';\r\nimport { Clock } from 'lucide-react';\r\nimport type { FoodTruck } from '@/lib/supabase';\r\n\r\ninterface TruckOperatingHoursProps {\r\n  readonly truck: FoodTruck;\r\n}\r\n\r\ninterface DayData {\r\n  closed?: boolean;\r\n  open?: string;\r\n  close?: string;\r\n}\r\n\r\nfunction DaySchedule({ day, dayData }: Readonly<{ day: string; dayData?: DayData }>) {\r\n  const dayName = day.charAt(0).toUpperCase() + day.slice(1);\r\n  \r\n  return (\r\n    <div className=\"flex justify-between items-center\">\r\n      <span className=\"text-sm font-medium dark:text-gray-200\">{dayName}</span>\r\n      <span className=\"text-sm text-gray-600 dark:text-gray-400\">\r\n        {dayData?.closed === true ? 'Closed' : `${dayData?.open ?? 'N/A'} - ${dayData?.close ?? 'N/A'}`}\r\n      </span>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport function TruckOperatingHours({ truck }: TruckOperatingHoursProps) {\r\n  const daysOfWeek = ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday'];\r\n  const hasOperatingHours = truck.operating_hours && Object.keys(truck.operating_hours).length > 0;\r\n\r\n  return (\r\n    <Card className=\"dark:bg-slate-800 dark:border-slate-700\">\r\n      <CardHeader>\r\n        <CardTitle className=\"flex items-center gap-2 dark:text-gray-100\">\r\n          <Clock className=\"h-5 w-5\" />\r\n          Operating Hours\r\n        </CardTitle>\r\n        <CardDescription className=\"dark:text-gray-400\">Daily schedule</CardDescription>\r\n      </CardHeader>\r\n      <CardContent>\r\n        {hasOperatingHours ? (\r\n          <div className=\"space-y-2\">\r\n            {daysOfWeek.map((day) => {\r\n              const dayData = truck.operating_hours?.[day as keyof typeof truck.operating_hours] as DayData | undefined;\r\n              return (\r\n                <DaySchedule key={day} day={day} dayData={dayData} />\r\n              );\r\n            })}\r\n          </div>\r\n        ) : (\r\n          <p className=\"text-gray-400 text-sm\">Operating hours not available</p>\r\n        )}\r\n      </CardContent>\r\n    </Card>\r\n  );\r\n}\r\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\trucks\\TruckRatingsReviews.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\ui\\AlertDialog.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\ui\\AspectRatio.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\ui\\ContextMenu.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\ui\\DropdownMenu.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\ui\\HoverCard.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\ui\\InputOtp.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\ui\\NavigationMenu.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\ui\\RadioGroup.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\ui\\ScrollArea.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\ui\\SimpleQualityPanel.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-misused-promises",
        "severity": 2,
        "message": "Promise-returning function provided to attribute where a void return was expected.",
        "line": 106,
        "column": 21,
        "nodeType": "JSXExpressionContainer",
        "messageId": "voidReturnAttribute",
        "endLine": 106,
        "endColumn": 43
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "'use client';\r\n\r\nimport React, { useState } from 'react';\r\nimport { Button } from '@/components/ui/button';\r\nimport { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';\r\nimport { Badge } from '@/components/ui/badge';\r\nimport { RefreshCw, Settings, Loader2 } from 'lucide-react';\r\n\r\ninterface SimpleQualityPanelProps {\r\n  readonly onRefresh?: () => void;\r\n}\r\n\r\ninterface RecalculateAllResult {\r\n  success: boolean;\r\n  data?: {\r\n    updated: number;\r\n    errors: number;\r\n  };\r\n  error?: string;\r\n}\r\n\r\nconst recalculateAllScores = async (): Promise<RecalculateAllResult> => {\r\n  const response = await fetch('/api/admin/data-quality', {\r\n    method: 'POST',\r\n    headers: {\r\n      'Content-Type': 'application/json',\r\n    },\r\n    body: JSON.stringify({\r\n      action: 'recalculate_all',\r\n    }),\r\n  });\r\n\r\n  const result: unknown = await response.json();\r\n\r\n  if (typeof result === 'object' && result !== null && 'success' in result) {\r\n    return result.success === true ? {\r\n        success: true,\r\n        data: {\r\n          updated: (result as { data?: { updated?: number } }).data?.updated ?? 0,\r\n          errors: (result as { data?: { errors?: number } }).data?.errors ?? 0,\r\n        },\r\n      } : {\r\n        success: false,\r\n        error: (result as { error?: string }).error ?? 'Failed to recalculate quality scores',\r\n      };\r\n  }\r\n  return { success: false, error: 'Invalid response format' };\r\n};\r\n\r\nconst QualityScoreThresholds: React.FC = () => (\r\n  <div className=\"border rounded-lg p-4 bg-blue-50/50\">\r\n    <h4 className=\"font-medium mb-2 text-blue-900\">Quality Score Thresholds</h4>\r\n    <div className=\"space-y-1 text-sm text-blue-800\">\r\n      <div className=\"flex justify-between\">\r\n        <span>High Quality:</span>\r\n        <Badge className=\"bg-green-100 text-green-800\">≥ 80%</Badge>\r\n      </div>\r\n      <div className=\"flex justify-between\">\r\n        <span>Medium Quality:</span>\r\n        <Badge className=\"bg-yellow-100 text-yellow-800\">60% - 79%</Badge>\r\n      </div>\r\n      <div className=\"flex justify-between\">\r\n        <span>Low Quality:</span>\r\n        <Badge className=\"bg-red-100 text-red-800\">{`< 60%`}</Badge>\r\n      </div>\r\n    </div>\r\n  </div>\r\n);\r\n\r\nexport const SimpleQualityPanel: React.FC<SimpleQualityPanelProps> = ({ onRefresh }) => {\r\n  const [isRecalculating, setIsRecalculating] = useState(false);\r\n\r\n  const handleRecalculateAll = async () => {\r\n    setIsRecalculating(true);\r\n\r\n    try {\r\n      const result = await recalculateAllScores();\r\n      if (result.success) {\r\n        alert(`Quality scores updated successfully! ${result.data?.updated} trucks updated, ${result.data?.errors} errors.`);\r\n        onRefresh?.();\r\n      } else {\r\n        throw new Error(result.error);\r\n      }\r\n    } catch (error) {\r\n      console.error('Error recalculating quality scores:', error);\r\n      alert('Failed to recalculate quality scores. Please try again.');\r\n    } finally {\r\n      setIsRecalculating(false);\r\n    }\r\n  };\r\n\r\n  return (\r\n    <Card>\r\n      <CardHeader>\r\n        <CardTitle className=\"flex items-center gap-2\">\r\n          <Settings className=\"h-5 w-5\" />\r\n          Quality Management Operations\r\n        </CardTitle>\r\n        <CardDescription>\r\n          Bulk operations for managing data quality scores across all food trucks\r\n        </CardDescription>\r\n      </CardHeader>\r\n      <CardContent className=\"space-y-6\">\r\n        <div className=\"grid grid-cols-1 md:grid-cols-2 gap-4\">\r\n          <Button\r\n            onClick={handleRecalculateAll}\r\n            disabled={isRecalculating}\r\n            className=\"flex items-center gap-2\"\r\n            variant=\"default\"\r\n          >\r\n            {isRecalculating ? (\r\n              <Loader2 className=\"h-4 w-4 animate-spin\" />\r\n            ) : (\r\n              <RefreshCw className=\"h-4 w-4\" />\r\n            )}\r\n            Recalculate All Scores\r\n          </Button>\r\n        </div>\r\n\r\n        <QualityScoreThresholds />\r\n\r\n        <div className=\"text-xs text-muted-foreground\">\r\n          <p>\r\n            <strong>Recalculate All:</strong> Updates quality scores for all food trucks using the latest algorithm.\r\n          </p>\r\n        </div>\r\n      </CardContent>\r\n    </Card>\r\n  );\r\n};\r\n\r\nexport default SimpleQualityPanel;\r\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\ui\\ToggleGroup.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\ui\\UseMobile.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\ui\\UseToast.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\ui\\accordion.tsx",
    "messages": [],
    "suppressedMessages": [
      {
        "ruleId": "sonarjs/deprecation",
        "severity": 2,
        "message": "'ElementRef' is deprecated.",
        "line": 13,
        "column": 9,
        "nodeType": null,
        "messageId": "deprecation",
        "endLine": 13,
        "endColumn": 19,
        "suppressions": [{ "kind": "directive", "justification": "" }]
      }
    ],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\ui\\alert.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\ui\\avatar.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\ui\\badge.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\ui\\breadcrumb.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\ui\\button.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\ui\\calendar.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\ui\\card.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\ui\\carousel.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\ui\\chart.tsx",
    "messages": [
      {
        "ruleId": null,
        "nodeType": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: Merge conflict marker encountered.",
        "line": 177,
        "column": 0
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "'use client';\r\n\r\nimport * as React from 'react';\r\nimport * as RechartsPrimitive from 'recharts';\r\nimport {\r\n  NameType,\r\n  Payload,\r\n  ValueType,\r\n} from 'recharts/types/component/DefaultTooltipContent';\r\n\r\nimport { cn } from '@/lib/utils';\r\nimport { useTooltipLabel } from './chart/useTooltipLabel';\r\nimport { TooltipIndicator } from './chart/TooltipIndicator';\r\nimport { TooltipItemContent } from './chart/TooltipItemContent';\r\nimport { getPayloadConfigFromPayload } from './chart/getPayloadConfigFromPayload';\r\n\r\n// Format: { THEME_NAME: CSS_SELECTOR }\r\nconst THEMES = { light: '', dark: '.dark' } as const;\r\n\r\nexport type ChartConfig = {\r\n  [k in string]: {\r\n    label?: React.ReactNode;\r\n    icon?: React.ComponentType;\r\n  } & (\r\n    | { color?: string; theme?: never }\r\n    | { color?: never; theme: Record<keyof typeof THEMES, string> }\r\n  );\r\n};\r\n\r\ntype ChartContextProps = {\r\n  config: ChartConfig;\r\n};\r\n\r\nconst ChartContext = React.createContext<ChartContextProps | undefined>(undefined);\r\n\r\nfunction useChart() {\r\n  const context = React.useContext(ChartContext);\r\n  if (context === undefined) {\r\n    throw new Error('useChart must be used within a <ChartContainer />');\r\n  }\r\n  return context;\r\n}\r\n\r\nconst ChartContainer = React.forwardRef<\r\n  HTMLDivElement,\r\n  React.ComponentProps<'div'> & {\r\n    readonly config: ChartConfig;\r\n    readonly children: React.ComponentProps<typeof RechartsPrimitive.ResponsiveContainer>['children'];\r\n  }\r\n>(({ id, className, children, config, ...props }, ref) => {\r\n  const uniqueId = React.useId();\r\n  const chartId = `chart-${id ?? uniqueId.replaceAll(':', '')}`;\r\n\r\n  return (\r\n    <ChartContext.Provider value={{ config }}>\r\n      <div\r\n        data-chart={chartId}\r\n        ref={ref}\r\n        className={cn(\r\n          \"flex aspect-video justify-center text-xs [&_.recharts-cartesian-axis-tick_text]:fill-muted-foreground [&_.recharts-cartesian-grid_line[stroke='#ccc']]:stroke-border/50 [&_.recharts-curve.recharts-tooltip-cursor]:stroke-border [&_.recharts-dot[stroke='#fff']]:stroke-transparent [&_.recharts-layer]:outline-none [&_.recharts-polar-grid_[stroke='#ccc']]:stroke-border [&_.recharts-radial-bar-background-sector]:fill-muted [&_.recharts-rectangle.recharts-tooltip-cursor]:fill-muted [&_.recharts-reference-line_[stroke='#ccc']]:stroke-border [&_.recharts-sector[stroke='#fff']]:stroke-transparent [&_.recharts-sector]:outline-none [&_.recharts-surface]:outline-none\",\r\n          className,\r\n        )}\r\n        {...props}\r\n      >\r\n        <ChartStyle id={chartId} config={config} />\r\n        <RechartsPrimitive.ResponsiveContainer>{children}</RechartsPrimitive.ResponsiveContainer>\r\n      </div>\r\n    </ChartContext.Provider>\r\n  );\r\n});\r\nChartContainer.displayName = 'Chart';\r\n\r\nconst ChartStyle = ({ id, config }: { readonly id: string; readonly config: ChartConfig }) => {\r\n  const colorConfig = Object.entries(config).filter(([_, itemConfig]) => (itemConfig.theme ?? itemConfig.color) !== undefined);\r\n  if (colorConfig.length === 0) {\r\n    return;\r\n  }\r\n\r\n  return (\r\n    <style\r\n      dangerouslySetInnerHTML={{\r\n        __html: Object.entries(THEMES)\r\n          .map(\r\n            ([theme, prefix]) => `\r\n${prefix} [data-chart=${id}] {\r\n${colorConfig\r\n  .map(([key, itemConfig]) => {\r\n    const color = itemConfig.theme?.[theme as keyof typeof itemConfig.theme] ?? itemConfig.color;\r\n    return color !== undefined && color !== '' ? `  --color-${key}: ${color};` : undefined;\r\n  })\r\n  .join('\\n')}\r\n}\r\n`,\r\n          )\r\n          .join('\\n'),\r\n      }}\r\n    />\r\n  );\r\n};\r\n\r\nconst ChartTooltip = RechartsPrimitive.Tooltip;\r\n\r\nfunction isNonEmptyArray<T>(arr: T[] | undefined): arr is T[] {\r\n  return Array.isArray(arr) && arr.length > 0;\r\n}\r\n\r\ntype TooltipFormatter = (value: number, name: string, item: unknown, index: number, payload: Record<string, unknown>[]) => React.ReactNode;\r\ntype TooltipItemData = { name?: string; dataKey?: string; payload?: Record<string, unknown>; color?: string; value?: number };\r\n\r\n\r\ntype ChartTooltipIndicatorAndContentProps = {\r\n  indicator: 'line' | 'dot' | 'dashed';\r\n  hideIndicator: boolean;\r\n  indicatorColor?: string;\r\n  nestLabel: boolean;\r\n  itemConfig: Record<string, unknown>;\r\n  formatter: TooltipFormatter | undefined;\r\n  itemData: TooltipItemData;\r\n  item: Payload<ValueType, NameType>;\r\n  index: number;\r\n  tooltipLabel: React.ReactNode;\r\n};\r\n\r\nfunction ChartTooltipIndicatorAndContent(props: Readonly<ChartTooltipIndicatorAndContentProps>) {\r\n  const {\r\n    indicator,\r\n    hideIndicator,\r\n    indicatorColor,\r\n    nestLabel,\r\n    itemConfig,\r\n    formatter,\r\n    itemData,\r\n    item,\r\n    index,\r\n    tooltipLabel,\r\n  } = props;\r\n  return (\r\n    <>\r\n      <TooltipIndicator\r\n        indicator={indicator}\r\n        hideIndicator={hideIndicator}\r\n        indicatorColor={indicatorColor}\r\n        nestLabel={nestLabel}\r\n        itemConfig={itemConfig}\r\n      />\r\n      <TooltipItemContent\r\n        formatter={formatter}\r\n        itemData={itemData}\r\n        item={item}\r\n        index={index}\r\n        itemConfig={itemConfig}\r\n        nestLabel={nestLabel}\r\n        tooltipLabel={tooltipLabel}\r\n      />\r\n    </>\r\n  );\r\n}\r\n\r\ntype ChartTooltipItemProps = {\r\n  item: Payload<ValueType, NameType>;\r\n  index: number;\r\n  indicatorProps: {\r\n    indicator: 'line' | 'dot' | 'dashed';\r\n    hideIndicator: boolean;\r\n    color?: string;\r\n    nestLabel: boolean;\r\n    config: ChartConfig;\r\n    nameKey?: string;\r\n    tooltipLabel: React.ReactNode;\r\n    formatter: TooltipFormatter | undefined;\r\n  };\r\n};\r\n\r\nfunction ChartTooltipItem({ item, index, indicatorProps }: Readonly<ChartTooltipItemProps>) {\r\n  const { indicator, hideIndicator, color, nestLabel, config, nameKey, tooltipLabel, formatter } = indicatorProps;\r\n  const dataKey = typeof item.dataKey === 'string' ? item.dataKey : undefined;\r\n>>>>>>> f3b1b3f (fix(supabase): remove unsafe return from getDataQualityStats)\r\n  const itemData: TooltipItemData = {\r\n    name: item.name === undefined ? undefined : String(item.name),\r\n    dataKey,\r\n    payload: typeof item.payload === 'object' && item.payload ? (item.payload as Record<string, unknown>) : undefined,\r\n    color: typeof item.color === 'string' ? item.color : undefined,\r\n    value: typeof item.value === 'number' ? item.value : undefined,\r\n  };\r\n  const key = nameKey ?? itemData.name ?? itemData.dataKey ?? 'value';\r\n  const itemConfig = getPayloadConfigFromPayload(config, item, key) as Record<string, unknown>;\r\n  const indicatorColor =\r\n    color ??\r\n    (itemData.payload && typeof itemData.payload === 'object' && 'fill' in itemData.payload\r\n      ? String(itemData.payload.fill)\r\n      : undefined) ??\r\n    itemData.color;\r\n  return (\r\n    <div\r\n      key={itemData.dataKey ?? index}\r\n      className={cn(\r\n        'flex w-full flex-wrap items-stretch gap-2 [&>svg]:h-2.5 [&>svg]:w-2.5 [&>svg]:text-muted-foreground',\r\n        indicator === 'dot' && 'items-center',\r\n      )}\r\n    >\r\n      <ChartTooltipIndicatorAndContent\r\n        indicator={indicator}\r\n        hideIndicator={hideIndicator}\r\n        indicatorColor={indicatorColor}\r\n        nestLabel={nestLabel}\r\n        itemConfig={itemConfig}\r\n        formatter={formatter}\r\n        itemData={itemData}\r\n        item={item}\r\n        index={index}\r\n        tooltipLabel={tooltipLabel}\r\n      />\r\n    </div>\r\n  );\r\n}\r\n\r\ntype ChartTooltipItemsProps = {\r\n  safePayload: Payload<ValueType, NameType>[];\r\n  indicatorProps: {\r\n    indicator: 'line' | 'dot' | 'dashed';\r\n    hideIndicator: boolean;\r\n    formatter: TooltipFormatter | undefined;\r\n    nameKey?: string;\r\n    color?: string;\r\n    tooltipLabel: React.ReactNode;\r\n    config: ChartConfig;\r\n    nestLabel: boolean;\r\n  };\r\n};\r\n\r\nfunction ChartTooltipItems(props: Readonly<ChartTooltipItemsProps>) {\r\n  const { safePayload, indicatorProps } = props;\r\n  return (\r\n    <div className=\"grid gap-1.5\">\r\n      {safePayload.map((item, index) => (\r\n        <ChartTooltipItem\r\n          key={item.dataKey ?? index}\r\n          item={item}\r\n          index={index}\r\n          indicatorProps={indicatorProps}\r\n        />\r\n      ))}\r\n    </div>\r\n  );\r\n}\r\n\r\nconst ChartTooltipContent = React.forwardRef<\r\n  HTMLDivElement,\r\n  React.ComponentProps<typeof RechartsPrimitive.Tooltip> &\r\n    React.ComponentProps<'div'> & {\r\n      readonly hideLabel?: boolean;\r\n      readonly hideIndicator?: boolean;\r\n      readonly indicator?: 'line' | 'dot' | 'dashed';\r\n      readonly nameKey?: string;\r\n      readonly labelKey?: string;\r\n    }\r\n>(({\r\n  active,\r\n  payload,\r\n  className,\r\n  indicator = 'dot',\r\n  hideLabel = false,\r\n  hideIndicator = false,\r\n  label,\r\n  labelFormatter,\r\n  labelClassName,\r\n  formatter,\r\n  color,\r\n  nameKey,\r\n  labelKey,\r\n}, ref) => {\r\n    const { config } = useChart();\r\n    const safePayload: Payload<ValueType, NameType>[] = isNonEmptyArray(payload) ? payload : [];\r\n    const tooltipLabel = useTooltipLabel({\r\n      hideLabel,\r\n      payload: safePayload,\r\n      label,\r\n      labelFormatter,\r\n      labelClassName,\r\n      config,\r\n      labelKey\r\n    });\r\n\r\n    if (!active || !isNonEmptyArray(safePayload)) {\r\n      return;\r\n    }\r\n\r\n    const nestLabel = safePayload.length === 1 && indicator !== 'dot';\r\n\r\n    return (\r\n      <div\r\n        ref={ref}\r\n        className={cn(\r\n          'grid min-w-[8rem] items-start gap-1.5 rounded-lg border border-border/50 bg-background px-2.5 py-1.5 text-xs shadow-xl',\r\n          className,\r\n        )}\r\n      >\r\n        {!nestLabel && tooltipLabel}\r\n        <ChartTooltipItems\r\n          safePayload={safePayload}\r\n          indicatorProps={{\r\n            indicator,\r\n            hideIndicator,\r\n            formatter: formatter as TooltipFormatter | undefined,\r\n            nameKey,\r\n            color,\r\n            tooltipLabel,\r\n            config,\r\n            nestLabel,\r\n          }}\r\n        />\r\n      </div>\r\n    );\r\n  },\r\n);\r\nChartTooltipContent.displayName = 'ChartTooltip';\r\n\r\nconst ChartLegend = RechartsPrimitive.Legend;\r\n\r\ninterface ChartLegendItemProps {\r\n  item: Payload<ValueType, NameType>;\r\n  idx: number;\r\n  hideIcon: boolean;\r\n  nameKey?: string;\r\n  config: ChartConfig;\r\n}\r\n\r\nfunction ChartLegendItem({ item, idx, hideIcon, nameKey, config }: Readonly<ChartLegendItemProps>) {\r\n  const dataKey = item.dataKey?.toString();\r\n  const itemData = {\r\n    dataKey,\r\n    value: item.value?.toString(),\r\n    color: item.color?.toString(),\r\n  };\r\n  const key = nameKey ?? dataKey ?? 'value';\r\n  const itemConfig = getPayloadConfigFromPayload(config, item, key);\r\n\r\n  return (\r\n    <div\r\n      key={itemData.value ?? idx}\r\n      className={cn(\r\n        'flex items-center gap-1.5 [&>svg]:h-3 [&>svg]:w-3 [&>svg]:text-muted-foreground',\r\n      )}\r\n    >\r\n      {itemConfig?.icon && !hideIcon ? (\r\n        <itemConfig.icon />\r\n      ) : (\r\n        <div\r\n          className=\"h-2 w-2 shrink-0 rounded-[2px]\"\r\n          style={{\r\n            backgroundColor: itemData.color,\r\n          }}\r\n        />\r\n      )}\r\n      {itemConfig?.label}\r\n    </div>\r\n  );\r\n}\r\n\r\nconst ChartLegendContent = React.forwardRef<\r\n  HTMLDivElement,\r\n  React.ComponentProps<typeof RechartsPrimitive.Legend> &\r\n    Pick<RechartsPrimitive.LegendProps, 'payload' | 'verticalAlign'> & {\r\n      hideIcon?: boolean;\r\n      nameKey?: string;\r\n    }\r\n>(({ className, hideIcon = false, payload, verticalAlign = 'bottom', nameKey }, ref) => {\r\n  const { config } = useChart();\r\n  const safePayload: Payload<ValueType, NameType>[] = isNonEmptyArray(payload) ? payload as Payload<ValueType, NameType>[] : [];\r\n  if (!isNonEmptyArray(safePayload)) {\r\n    return;\r\n  }\r\n\r\n  return (\r\n    <div\r\n      ref={ref}\r\n      className={cn(\r\n        'flex items-center justify-center gap-4',\r\n        verticalAlign === 'top' ? 'pb-3' : 'pt-3',\r\n        className,\r\n      )}\r\n    >\r\n      {safePayload.map((item, idx) => (\r\n        <ChartLegendItem\r\n          key={item.dataKey ?? idx}\r\n          item={item}\r\n          idx={idx}\r\n          hideIcon={hideIcon}\r\n          nameKey={nameKey}\r\n          config={config}\r\n        />\r\n      ))}\r\n    </div>\r\n  );\r\n});\r\nChartLegendContent.displayName = 'ChartLegend';\r\n\r\nexport {\r\n  ChartContainer,\r\n  ChartTooltip,\r\n  ChartTooltipContent,\r\n  ChartLegend,\r\n  ChartLegendContent,\r\n  ChartStyle,\r\n};\r\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\ui\\chart\\QualityPieChart.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 2,
        "message": "Unsafe argument of type error typed assigned to a parameter of type `ArrayLike<unknown> | { [s: string]: unknown; }`.",
        "line": 37,
        "column": 35,
        "nodeType": "Identifier",
        "messageId": "unsafeArgument",
        "endLine": 37,
        "endColumn": 49
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import React from 'react';\r\nimport { PieChart, Pie, Cell, Tooltip, ResponsiveContainer } from 'recharts';\r\nimport { QUALITY_COLORS } from '../dataQualityCharts';\r\nimport { CustomTooltip } from '../dataQualityCharts';\r\n\r\ninterface QualityPieChartProps {\r\n  readonly data: {\r\n    name: string;\r\n    value: number;\r\n    percentage: string;\r\n  }[];\r\n}\r\n\r\nexport function QualityPieChart({ data }: QualityPieChartProps) {\r\n  return (\r\n    <ResponsiveContainer width=\"100%\" height={300}>\r\n      <PieChart>\r\n        <Pie\r\n          data={data}\r\n          cx=\"50%\"\r\n          cy=\"50%\"\r\n          labelLine={false}\r\n          label={({\r\n            name,\r\n            percentage\r\n          }: {\r\n            name?: string;\r\n            percentage?: string;\r\n          }) => `${name ?? 'Unknown'}: ${percentage ?? '0'}%`}\r\n          outerRadius={80}\r\n          fill=\"#8884d8\"\r\n          dataKey=\"value\"\r\n        >\r\n          {data.map((entry, index) => (\r\n            <Cell \r\n              key={`cell-${index}`} \r\n              fill={Object.values(QUALITY_COLORS)[index]} \r\n            />\r\n          ))}\r\n        </Pie>\r\n        <Tooltip content={<CustomTooltip />} />\r\n      </PieChart>\r\n    </ResponsiveContainer>\r\n  );\r\n}\r\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\ui\\chart\\TooltipIndicator.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\ui\\chart\\TooltipItemContent.tsx",
    "messages": [
      {
        "ruleId": "max-params",
        "severity": 2,
        "message": "Function has too many parameters (5). Maximum allowed is 4.",
        "line": 5,
        "column": 24,
        "nodeType": "TSFunctionType",
        "messageId": "exceed",
        "endLine": 5,
        "endColumn": 24
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import React from 'react';\r\nimport { cn } from '@/lib/utils';\r\n\r\ninterface TooltipItemContentProps {\r\n  readonly formatter?: (value: number, name: string, item: unknown, index: number, payload: Record<string, unknown>[]) => React.ReactNode;\r\n  readonly itemData: { name?: string; dataKey?: string; payload?: unknown; color?: string; value?: number };\r\n  readonly item: unknown;\r\n  readonly index: number;\r\n  readonly itemConfig?: { label?: React.ReactNode };\r\n  readonly nestLabel: boolean;\r\n  readonly tooltipLabel: React.ReactNode;\r\n}\r\n\r\nexport function TooltipItemContent(props: TooltipItemContentProps) {\r\n  const { formatter, itemData, item, index, itemConfig, nestLabel, tooltipLabel } = props;\r\n  if (formatter !== undefined && itemData?.value !== undefined && itemData.name !== undefined && itemData.name !== '') {\r\n    const payloadArray = Array.isArray(itemData.payload)\r\n      ? (itemData.payload as Record<string, unknown>[])\r\n      : [];\r\n    return <>{formatter(itemData.value, itemData.name, item, index, payloadArray)}</>;\r\n  }\r\n\r\n  return (\r\n    <div\r\n      className={cn(\r\n        'flex flex-1 justify-between leading-none',\r\n        nestLabel ? 'items-end' : 'items-center',\r\n      )}\r\n    >\r\n      <div className=\"grid gap-1.5\">\r\n        {nestLabel ? tooltipLabel : undefined}\r\n        <span className=\"text-muted-foreground\">\r\n          {itemConfig?.label ?? itemData.name}\r\n        </span>\r\n      </div>\r\n      {itemData.value !== undefined && itemData.value !== 0 && (\r\n        <span className=\"font-mono font-medium tabular-nums text-foreground\">\r\n          {itemData.value.toLocaleString()}\r\n        </span>\r\n      )}\r\n    </div>\r\n  );\r\n}\r\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\ui\\chart\\getPayloadConfigFromPayload.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\ui\\chart\\useTooltipLabel.tsx",
    "messages": [
      {
        "ruleId": "unicorn/no-null",
        "severity": 1,
        "message": "Use `undefined` instead of `null`.",
        "line": 29,
        "column": 14,
        "nodeType": "Literal",
        "messageId": "error",
        "endLine": 29,
        "endColumn": 18,
        "suggestions": [
          {
            "messageId": "remove",
            "fix": { "range": [917, 921], "text": "" },
            "data": {},
            "desc": "Remove `null`."
          },
          {
            "messageId": "replace",
            "fix": { "range": [917, 921], "text": "undefined" },
            "data": {},
            "desc": "Replace `null` with `undefined`."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import React from 'react';\r\nimport { cn } from '@/lib/utils';\r\nimport { ChartConfig } from '../chart';\r\nimport { Payload, ValueType, NameType } from 'recharts/types/component/DefaultTooltipContent';\r\n\r\nimport { getPayloadConfigFromPayload } from './getPayloadConfigFromPayload';\r\n\r\ninterface UseTooltipLabelProps {\r\n  readonly hideLabel: boolean;\r\n  readonly payload: Payload<ValueType, NameType>[] | undefined;\r\n  readonly label: unknown;\r\n  readonly labelFormatter?: (value: unknown, payload: Payload<ValueType, NameType>[]) => React.ReactNode;\r\n  readonly labelClassName?: string;\r\n  readonly config: ChartConfig;\r\n  readonly labelKey?: string;\r\n}\r\n\r\nexport function useTooltipLabel({\r\n  hideLabel,\r\n  payload,\r\n  label,\r\n  labelFormatter,\r\n  labelClassName,\r\n  config,\r\n  labelKey\r\n}: UseTooltipLabelProps) {\r\n  return React.useMemo(() => {\r\n    if (hideLabel || !payload || payload.length === 0) {\r\n      return null; // Return null or an empty div if no label or payload\r\n    }\r\n\r\n    const [item] = payload;\r\n\r\n    const key = `${labelKey ?? (item as { dataKey?: string; name?: string }).dataKey ?? (item as { dataKey?: string; name?: string }).name ?? 'value'}`;\r\n    const itemConfig = getPayloadConfigFromPayload(config, item, key);\r\n    const value =\r\n      (labelKey === undefined && typeof label === 'string') ? config[label]?.label ?? label : itemConfig?.label;\r\n\r\n    if (labelFormatter) {\r\n      return (\r\n        <div className={cn('font-medium', labelClassName)}>{labelFormatter(value, payload)}</div>\r\n      );\r\n    }\r\n\r\n    if (value === undefined || value === null || value === '') {\r\n      \r\n    }\r\n\r\n    return <div className={cn('font-medium', labelClassName)}>{value}</div>;\r\n  }, [label, labelFormatter, payload, hideLabel, labelClassName, config, labelKey]);\r\n}\r\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\ui\\checkbox.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\ui\\collapsible.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\ui\\command.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\ui\\dataQualityCharts.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\ui\\dialog.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\ui\\drawer.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\ui\\form.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\ui\\input.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\ui\\label.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\ui\\menubar.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\ui\\pagination.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\ui\\popover.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\ui\\progress.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\ui\\resizable.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\ui\\select.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\ui\\separator.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\ui\\sheet.tsx",
    "messages": [
      {
        "ruleId": "sonarjs/deprecation",
        "severity": 2,
        "message": "'ElementRef' is deprecated.",
        "line": 19,
        "column": 9,
        "nodeType": null,
        "messageId": "deprecation",
        "endLine": 19,
        "endColumn": 19
      },
      {
        "ruleId": "sonarjs/deprecation",
        "severity": 2,
        "message": "'ElementRef' is deprecated.",
        "line": 57,
        "column": 9,
        "nodeType": null,
        "messageId": "deprecation",
        "endLine": 57,
        "endColumn": 19
      }
    ],
    "suppressedMessages": [],
    "errorCount": 2,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "'use client';\r\n\r\nimport * as React from 'react';\r\nimport * as SheetPrimitive from '@radix-ui/react-dialog';\r\nimport { cva, type VariantProps } from 'class-variance-authority';\r\nimport { X } from 'lucide-react';\r\n\r\nimport { cn } from '@/lib/utils';\r\n\r\nconst Sheet = SheetPrimitive.Root;\r\n\r\nconst SheetTrigger = SheetPrimitive.Trigger;\r\n\r\nconst SheetClose = SheetPrimitive.Close;\r\n\r\nconst SheetPortal = SheetPrimitive.Portal;\r\n\r\nconst SheetOverlay = React.forwardRef<\r\n  React.ElementRef<typeof SheetPrimitive.Overlay>,\r\n  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Overlay>\r\n>(({ className, ...props }, ref) => (\r\n  <SheetPrimitive.Overlay\r\n    className={cn(\r\n      'fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0',\r\n      className,\r\n    )}\r\n    {...props}\r\n    ref={ref}\r\n  />\r\n));\r\nSheetOverlay.displayName = SheetPrimitive.Overlay.displayName;\r\n\r\nconst sheetVariants = cva(\r\n  'fixed z-50 gap-4 bg-background p-6 shadow-lg transition ease-in-out data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:duration-300 data-[state=open]:duration-500',\r\n  {\r\n    variants: {\r\n      side: {\r\n        top: 'inset-x-0 top-0 border-b data-[state=closed]:slide-out-to-top data-[state=open]:slide-in-from-top',\r\n        bottom:\r\n          'inset-x-0 bottom-0 border-t data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom',\r\n        left: 'inset-y-0 left-0 h-full w-3/4 border-r data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left sm:max-w-sm',\r\n        right:\r\n          'inset-y-0 right-0 h-full w-3/4  border-l data-[state=closed]:slide-out-to-right data-[state=open]:slide-in-from-right sm:max-w-sm',\r\n      },\r\n    },\r\n    defaultVariants: {\r\n      side: 'right',\r\n    },\r\n  },\r\n);\r\n\r\ninterface SheetContentProps\r\n  extends React.ComponentPropsWithoutRef<typeof SheetPrimitive.Content>,\r\n    VariantProps<typeof sheetVariants> {}\r\n\r\nconst SheetContent = React.forwardRef<\r\n  React.ElementRef<typeof SheetPrimitive.Content>,\r\n  SheetContentProps\r\n>(({ side = 'right', className, children, ...props }, ref) => (\r\n  <SheetPortal>\r\n    <SheetOverlay />\r\n    <SheetPrimitive.Content\r\n      ref={ref}\r\n      className={cn(sheetVariants({ side }), className)}\r\n      {...props}\r\n    >\r\n      {children}\r\n      <SheetPrimitive.Close className=\"absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-secondary\">\r\n        <X className=\"h-4 w-4\" />\r\n        <span className=\"sr-only\">Close</span>\r\n      </SheetPrimitive.Close>\r\n    </SheetPrimitive.Content>\r\n  </SheetPortal>\r\n));\r\nSheetContent.displayName = SheetPrimitive.Content.displayName;\r\n\r\nconst SheetHeader = ({ className, ...props }: React.HTMLAttributes<HTMLDivElement>) => (\r\n  <div className={cn('flex flex-col space-y-2 text-center sm:text-left', className)} {...props} />\r\n);\r\nSheetHeader.displayName = 'SheetHeader';\r\n\r\nconst SheetFooter = ({ className, ...props }: React.HTMLAttributes<HTMLDivElement>) => (\r\n  <div\r\n    className={cn('flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2', className)}\r\n    {...props}\r\n  />\r\n);\r\nSheetFooter.displayName = 'SheetFooter';\r\n\r\nconst SheetTitle = React.forwardRef<\r\n  HTMLHeadingElement,\r\n  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Title>\r\n>(({ className, ...props }, ref) => (\r\n  <SheetPrimitive.Title\r\n    ref={ref}\r\n    className={cn('text-lg font-semibold text-foreground', className)}\r\n    {...props}\r\n  />\r\n));\r\nSheetTitle.displayName = SheetPrimitive.Title.displayName;\r\n\r\nconst SheetDescription = React.forwardRef<\r\n  HTMLParagraphElement,\r\n  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Description>\r\n>(({ className, ...props }, ref) => (\r\n  <SheetPrimitive.Description\r\n    ref={ref}\r\n    className={cn('text-sm text-muted-foreground', className)}\r\n    {...props}\r\n  />\r\n));\r\nSheetDescription.displayName = SheetPrimitive.Description.displayName;\r\n\r\nexport {\r\n  Sheet,\r\n  SheetPortal,\r\n  SheetOverlay,\r\n  SheetTrigger,\r\n  SheetClose,\r\n  SheetContent,\r\n  SheetHeader,\r\n  SheetFooter,\r\n  SheetTitle,\r\n  SheetDescription,\r\n};\r\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\ui\\sidebar.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\ui\\skeleton.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\ui\\slider.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\ui\\sonner.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\ui\\switch.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\ui\\table.tsx",
    "messages": [],
    "suppressedMessages": [
      {
        "ruleId": "sonarjs/table-header",
        "severity": 2,
        "message": "Add a valid header row or column to this \"<table>\".",
        "line": 9,
        "column": 7,
        "nodeType": "JSXElement",
        "endLine": 9,
        "endColumn": 96,
        "suppressions": [{ "kind": "directive", "justification": "" }]
      }
    ],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\ui\\tabs.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\ui\\textarea.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\ui\\toast.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\ui\\toaster.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\ui\\toggle.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\components\\ui\\tooltip.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\hooks\\UseMobile.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\hooks\\UseToast.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\hooks\\realtime\\connectionManagementHelpers.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\hooks\\realtime\\createEventSourceConnection.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\hooks\\realtime\\setupEventSourceListeners.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\hooks\\realtime\\useAutoConnect.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\hooks\\realtime\\useConnectionManagement.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\hooks\\realtime\\useConnectionState.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\hooks\\realtime\\useEventHandlers.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\hooks\\realtime\\useRealtimeAdminEventsLogic.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\hooks\\useAdminAuth.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\hooks\\useAuthHandlers.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\hooks\\useDataCleanup.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\hooks\\useFoodTruckDetails.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\hooks\\useFoodTruckFinder.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\hooks\\useRealtimeAdminEvents.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\hooks\\useRealtimeAdminEvents.types.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\hooks\\useRealtimeAdminEventsHelpers.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\hooks\\useSearchFiltersLogic.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\hooks\\useSidebarKeyboardShortcut.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\hooks\\useSystemAlerts.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\hooks\\useSystemAlertsLogic.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\hooks\\useTruckCard.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\lib\\ScraperEngine.ts",
    "messages": [
      {
        "ruleId": "sonarjs/no-redundant-optional",
        "severity": 2,
        "message": "Consider removing 'undefined' type or '?' specifier, one of them is redundant.",
        "line": 701,
        "column": 30,
        "nodeType": null,
        "endLine": 701,
        "endColumn": 31,
        "suggestions": [
          { "desc": "Remove \"?\" operator", "fix": { "range": [23091, 23092], "text": "" } },
          {
            "desc": "Remove \"undefined\" type annotation",
            "fix": { "range": [23094, 23112], "text": "number" }
          }
        ]
      },
      {
        "ruleId": "sonarjs/no-redundant-optional",
        "severity": 2,
        "message": "Consider removing 'undefined' type or '?' specifier, one of them is redundant.",
        "line": 704,
        "column": 30,
        "nodeType": null,
        "endLine": 704,
        "endColumn": 31,
        "suggestions": [
          { "desc": "Remove \"?\" operator", "fix": { "range": [23222, 23223], "text": "" } },
          {
            "desc": "Remove \"undefined\" type annotation",
            "fix": { "range": [23225, 23243], "text": "number" }
          }
        ]
      }
    ],
    "suppressedMessages": [
      {
        "ruleId": "sonarjs/pseudo-random",
        "severity": 2,
        "message": "Make sure that using this pseudorandom number generator is safe here.",
        "line": 319,
        "column": 24,
        "nodeType": "CallExpression",
        "messageId": "safeGenerator",
        "endLine": 319,
        "endColumn": 37,
        "suppressions": [
          {
            "kind": "directive",
            "justification": "Math.random is acceptable for non-security-critical user agent selection."
          }
        ]
      },
      {
        "ruleId": "sonarjs/pseudo-random",
        "severity": 2,
        "message": "Make sure that using this pseudorandom number generator is safe here.",
        "line": 335,
        "column": 29,
        "nodeType": "CallExpression",
        "messageId": "safeGenerator",
        "endLine": 335,
        "endColumn": 42,
        "suppressions": [
          {
            "kind": "directive",
            "justification": "Math.random is acceptable for non-security-critical random delays."
          }
        ]
      },
      {
        "ruleId": "sonarjs/no-redundant-optional",
        "severity": 2,
        "message": "Consider removing 'undefined' type or '?' specifier, one of them is redundant.",
        "line": 374,
        "column": 8,
        "nodeType": null,
        "endLine": 374,
        "endColumn": 9,
        "suggestions": [
          { "desc": "Remove \"?\" operator", "fix": { "range": [12108, 12109], "text": "" } },
          {
            "desc": "Remove \"undefined\" type annotation",
            "fix": { "range": [12111, 12129], "text": "number" }
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "sonarjs/no-redundant-optional",
        "severity": 2,
        "message": "Consider removing 'undefined' type or '?' specifier, one of them is redundant.",
        "line": 376,
        "column": 8,
        "nodeType": null,
        "endLine": 376,
        "endColumn": 9,
        "suggestions": [
          { "desc": "Remove \"?\" operator", "fix": { "range": [12202, 12203], "text": "" } },
          {
            "desc": "Remove \"undefined\" type annotation",
            "fix": { "range": [12205, 12223], "text": "number" }
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      }
    ],
    "errorCount": 2,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { firecrawl } from './firecrawl'; // Import the firecrawl singleton\r\nimport * as crypto from 'node:crypto'; // Node.js crypto for secure randomness\r\n\r\ninterface InstagramPost {\r\n  id: string;\r\n  caption: string;\r\n  timestamp: string;\r\n  location: string;\r\n  hashtags: string[];\r\n  engagement: { likes: number; comments: number };\r\n}\r\n\r\ninterface InstagramProfile {\r\n  followers: number;\r\n  following: number;\r\n  posts_count: number;\r\n  bio: string;\r\n  contact_info: { email: string; phone: string };\r\n}\r\n\r\ninterface FacebookPost {\r\n  id: string;\r\n  content: string;\r\n  timestamp: string;\r\n  reactions: { likes: number; loves: number; shares: number };\r\n  comments: number;\r\n}\r\n\r\ninterface FacebookPageInfo {\r\n  likes: number;\r\n  followers: number;\r\n  check_ins: number;\r\n  about: string;\r\n  hours: Record<string, string>;\r\n}\r\n\r\ninterface TwitterTweet {\r\n  id: string;\r\n  text: string;\r\n  timestamp: string;\r\n  retweets: number;\r\n  likes: number;\r\n  replies: number;\r\n  location: string;\r\n}\r\n\r\ninterface TwitterProfile {\r\n  followers: number;\r\n  following: number;\r\n  tweets_count: number;\r\n  bio: string;\r\n  location: string;\r\n  website: string;\r\n}\r\n\r\ninterface InstagramData {\r\n  posts: InstagramPost[];\r\n  profile: InstagramProfile;\r\n}\r\n\r\ninterface FacebookData {\r\n  posts: FacebookPost[];\r\n  page_info: FacebookPageInfo;\r\n}\r\n\r\ninterface TwitterData {\r\n  tweets: TwitterTweet[];\r\n  profile: TwitterProfile;\r\n}\r\n\r\nexport interface WebsiteScrapeData {\r\n  markdown?: string;\r\n  html?: string;\r\n  metadata?: Record<string, unknown>;\r\n  is_fallback?: boolean;\r\n}\r\n\r\nexport interface ExtractedHTMLData {\r\n  name?: string;\r\n  location?: string;\r\n  phone?: string;\r\n  hours?: string;\r\n  menu?: { item: string; price: string }[];\r\n}\r\n\r\ninterface ScrapeResult {\r\n  success: boolean;\r\n  error?: string;\r\n  data?: InstagramData | FacebookData | TwitterData | WebsiteScrapeData | ExtractedHTMLData;\r\n  timestamp: string;\r\n  source: string;\r\n  note?: string;\r\n}\r\n\r\n// Core scraping engine with anti-detection measures\r\nexport class ScraperEngine {\r\n  private userAgents: string[];\r\n  private requestDelay: number;\r\n  private maxRetries: number;\r\n\r\n  constructor() {\r\n    this.userAgents = [\r\n      'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',\r\n      'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',\r\n      'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',\r\n    ];\r\n    this.requestDelay = 2000;\r\n    this.maxRetries = 3;\r\n  }\r\n\r\n  private async performFallbackScrape(url: string): Promise<ScrapeResult> {\r\n    try {\r\n      const response = await fetch(url, { headers: { 'User-Agent': this.getRandomUserAgent() } });\r\n      if (!response.ok) {\r\n        throw new Error(\r\n          `HTTP error ${response.status}: ${response.statusText} during fallback fetch.`,\r\n        );\r\n      }\r\n      const htmlContent = await response.text();\r\n      return {\r\n        success: true,\r\n        data: {\r\n          html: htmlContent,\r\n          is_fallback: true,\r\n        },\r\n        timestamp: new Date().toISOString(),\r\n        source: url,\r\n        note: 'Fetched using basic fetch as Firecrawl failed.',\r\n      };\r\n    } catch (fallbackError) {\r\n      const errMsg = fallbackError instanceof Error ? fallbackError.message : 'Unknown fallback fetch error';\r\n      console.warn(`Fallback fetch error for ${url}:`, errMsg);\r\n      return {\r\n        success: false,\r\n        error: \"That didn't work, please try again later.\",\r\n        timestamp: new Date().toISOString(),\r\n        source: url,\r\n      };\r\n    }\r\n  }\r\n\r\n  async scrapeWebsite(url: string, _selectors?: Record<string, string>): Promise<ScrapeResult> {\r\n    try {\r\n      const firecrawlResult = await firecrawl.scrapeUrl(url, {\r\n        formats: ['markdown', 'html'],\r\n        onlyMainContent: true,\r\n      });\r\n\r\n      if (firecrawlResult.success !== true || firecrawlResult.data == undefined) {\r\n        throw new Error(firecrawlResult.error ?? 'Firecrawl scraping failed to return data.');\r\n      }\r\n\r\n      const returnedData: WebsiteScrapeData = {};\r\n      if (typeof firecrawlResult.data.markdown === 'string' && firecrawlResult.data.markdown !== '') {\r\n        returnedData.markdown = firecrawlResult.data.markdown;\r\n      }\r\n      if (typeof firecrawlResult.data.html === 'string' && firecrawlResult.data.html !== '') {\r\n        returnedData.html = firecrawlResult.data.html;\r\n      }\r\n      if (firecrawlResult.data.metadata != undefined && typeof firecrawlResult.data.metadata === 'object') {\r\n        returnedData.metadata = firecrawlResult.data.metadata as Record<string, unknown>;\r\n      }\r\n\r\n      if (\r\n        (returnedData.markdown == undefined || returnedData.markdown === '') &&\r\n        (returnedData.html == undefined || returnedData.html === '')\r\n      ) {\r\n        throw new Error('Firecrawl returned no markdown or HTML content.');\r\n      }\r\n\r\n      return {\r\n        success: true,\r\n        data: returnedData,\r\n        timestamp: new Date().toISOString(),\r\n        source: url,\r\n      };\r\n    } catch (error: unknown) {\r\n      console.warn(`Scraping error for ${url} using Firecrawl:`, error);\r\n      console.info(`Falling back to basic fetch for ${url}`);\r\n      return await this.performFallbackScrape(url);\r\n    }\r\n  }\r\n\r\n  async scrapeSocialMedia(platform: string, handle: string): Promise<ScrapeResult> {\r\n    try {\r\n      await this.randomDelay();\r\n\r\n      switch (platform) {\r\n        case 'instagram': {\r\n          return await this.scrapeInstagram(handle);\r\n        }\r\n        case 'facebook': {\r\n          return await this.scrapeFacebook(handle);\r\n        }\r\n        case 'twitter': {\r\n          return await this.scrapeTwitter(handle);\r\n        }\r\n        default: {\r\n          throw new Error(`Unsupported platform: ${platform}`);\r\n        }\r\n      }\r\n    } catch (error) {\r\n      console.warn(`Social media scraping error for ${platform}/${handle}:`, error);\r\n      return {\r\n        success: false,\r\n        error: \"That didn't work, please try again later.\",\r\n        timestamp: new Date().toISOString(),\r\n        source: `social_media:${platform}:${handle}`,\r\n      };\r\n    }\r\n  }\r\n\r\n  private async scrapeInstagram(handle: string): Promise<ScrapeResult> {\r\n    await this.randomDelay();\r\n    const posts: InstagramPost[] = [\r\n      {\r\n        id: 'post_001',\r\n        caption: 'Fresh tacos available now at Mission St! 🌮 #foodtruck #tacos',\r\n        timestamp: new Date(Date.now() - 3_600_000).toISOString(),\r\n        location: 'Mission St, San Francisco',\r\n        hashtags: ['foodtruck', 'tacos', 'fresh'],\r\n        engagement: { likes: 45, comments: 8 },\r\n      },\r\n    ];\r\n    const profile: InstagramProfile = {\r\n      followers: 1250,\r\n      following: 340,\r\n      posts_count: 156,\r\n      bio: 'Best tacos in SF 🌮 Follow for daily locations!',\r\n      contact_info: {\r\n        email: 'contact@tacoparadise.com',\r\n        phone: '+1-555-0456',\r\n      },\r\n    };\r\n    return {\r\n      success: true,\r\n      data: { posts, profile },\r\n      timestamp: new Date().toISOString(),\r\n      source: `instagram:${handle}`,\r\n    };\r\n  }\r\n\r\n  private async scrapeFacebook(handle: string): Promise<ScrapeResult> {\r\n    await this.randomDelay();\r\n    const posts: FacebookPost[] = [\r\n      {\r\n        id: 'fb_post_001',\r\n        content:\r\n          \"Today we'll be at Union Square from 11 AM to 3 PM! Come try our new BBQ burger!\",\r\n        timestamp: new Date(Date.now() - 7_200_000).toISOString(),\r\n        reactions: { likes: 23, loves: 5, shares: 3 },\r\n        comments: 12,\r\n      },\r\n    ];\r\n    const page_info: FacebookPageInfo = {\r\n      likes: 890,\r\n      followers: 1100,\r\n      check_ins: 450,\r\n      about: 'Gourmet food truck serving the Bay Area',\r\n      hours: {\r\n        monday: '11:00-15:00',\r\n        tuesday: '11:00-15:00',\r\n        wednesday: '11:00-15:00',\r\n        thursday: '11:00-15:00',\r\n        friday: '11:00-20:00',\r\n        saturday: '12:00-20:00',\r\n        sunday: '12:00-16:00',\r\n      },\r\n    };\r\n    return {\r\n      success: true,\r\n      data: { posts, page_info },\r\n      timestamp: new Date().toISOString(),\r\n      source: `facebook:${handle}`,\r\n    };\r\n  }\r\n\r\n  private async scrapeTwitter(handle: string): Promise<ScrapeResult> {\r\n    await this.randomDelay();\r\n    const tweets: TwitterTweet[] = [\r\n      {\r\n        id: 'tweet_001',\r\n        text: 'LIVE at Dolores Park! Fresh burritos and quesadillas available now 🌯',\r\n        timestamp: new Date(Date.now() - 1_800_000).toISOString(),\r\n        retweets: 8,\r\n        likes: 34,\r\n        replies: 5,\r\n        location: 'Dolores Park, San Francisco',\r\n      },\r\n    ];\r\n    const profile: TwitterProfile = {\r\n      followers: 2340,\r\n      following: 567,\r\n      tweets_count: 1890,\r\n      bio: '🚚 SF Food Truck | Fresh Mexican Food | Follow for locations',\r\n      location: 'San Francisco, CA',\r\n      website: 'https://tacoparadise.com',\r\n    };\r\n    return {\r\n      success: true,\r\n      data: { tweets, profile },\r\n      timestamp: new Date().toISOString(),\r\n      source: `twitter:${handle}`,\r\n    };\r\n  }\r\n\r\n  private getRandomUserAgent(): string {\r\n    // Use Node.js crypto for stronger randomness if available, fallback to Math.random otherwise.\r\n    let idx: number;\r\n    if (globalThis.window?.crypto?.getRandomValues != undefined) {\r\n      const array = globalThis.window.crypto.getRandomValues(new Uint32Array(1));\r\n      idx = array[0] % this.userAgents.length;\r\n    } else if (typeof crypto.randomInt === 'function') {\r\n      idx = crypto.randomInt(0, this.userAgents.length);\r\n    } else {\r\n      // Fallback to Math.random for environments where crypto is not available.\r\n      // This is acceptable for non-security-critical random number generation like user agent selection.\r\n      // eslint-disable-next-line sonarjs/pseudo-random -- Math.random is acceptable for non-security-critical user agent selection.\r\n      idx = Math.floor(Math.random() * this.userAgents.length);\r\n    }\r\n    return this.userAgents[idx];\r\n  }\r\n\r\n  private randomDelay(): Promise<void> {\r\n    let randomMs: number;\r\n    if (globalThis.window?.crypto?.getRandomValues != undefined) {\r\n      const array = globalThis.window.crypto.getRandomValues(new Uint32Array(1));\r\n      randomMs = array[0] % 1000;\r\n    } else if (typeof crypto.randomInt === 'function') {\r\n      randomMs = crypto.randomInt(0, 1000);\r\n    } else {\r\n      // Fallback to Math.random for environments where crypto is not available.\r\n      // This is acceptable for non-security-critical random delays.\r\n      // eslint-disable-next-line sonarjs/pseudo-random -- Math.random is acceptable for non-security-critical random delays.\r\n      randomMs = Math.floor(Math.random() * 1000);\r\n    }\r\n    const delay = this.requestDelay + randomMs;\r\n    return new Promise((resolve) => setTimeout(resolve, delay));\r\n  }\r\n\r\n   handleRateLimit(retryAfter: number): Promise<void> {\r\n    console.info(`Rate limited. Waiting ${retryAfter} seconds before retry...`);\r\n    return new Promise((resolve) => setTimeout(resolve, retryAfter * 1000));\r\n  }\r\n\r\n  async retryWithBackoff<T>(\r\n    operation: () => Promise<T>,\r\n    maxRetries: number = this.maxRetries,\r\n  ): Promise<T> {\r\n    let lastError: unknown;\r\n\r\n    for (let attempt = 1; attempt <= maxRetries; attempt++) {\r\n      try {\r\n        return await operation();\r\n      } catch (error: unknown) {\r\n        lastError = error;\r\n        if (attempt === maxRetries) {\r\n          throw lastError instanceof Error ? lastError : new Error(String(lastError));\r\n        }\r\n\r\n        const backoffDelay = Math.pow(2, attempt) * 1000;\r\n        console.info(`Attempt ${attempt} failed. Retrying in ${backoffDelay}ms...`);\r\n        await new Promise((resolve) => setTimeout(resolve, backoffDelay));\r\n      }\r\n    }\r\n\r\n    throw lastError instanceof Error ? lastError : new Error('Request failed after all retries');\r\n  }\r\n}\r\n\r\ninterface LocationData {\r\n  current?: {\r\n    // eslint-disable-next-line sonarjs/no-redundant-optional\r\n    lat?: number | undefined;\r\n    // eslint-disable-next-line sonarjs/no-redundant-optional\r\n    lng?: number | undefined;\r\n    address?: string;\r\n  };\r\n}\r\n\r\ninterface ContactInfo {\r\n  phone?: string;\r\n  email?: string;\r\n}\r\n\r\ninterface OperatingHours {\r\n  [key: string]: {\r\n    open: string;\r\n    close: string;\r\n    closed: boolean;\r\n  };\r\n}\r\n\r\ninterface MenuItem {\r\n  name: string;\r\n  description?: string;\r\n  price: number;\r\n  dietary_tags?: string[];\r\n}\r\n\r\ninterface MenuCategory {\r\n  category: string;\r\n  items: MenuItem[];\r\n}\r\n\r\ninterface TruckData {\r\n  name: string;\r\n  location: LocationData;\r\n  contact?: ContactInfo;\r\n  operating_hours?: OperatingHours;\r\n  menu?: MenuCategory[];\r\n  last_updated?: string;\r\n}\r\n\r\nexport class DataQualityAssessor {\r\n  private assessBasicInfo(truckData: TruckData, issues: string[], score: number): number {\r\n    if (truckData.name == undefined || truckData.name.trim().length === 0) {\r\n      issues.push('Missing or empty truck name');\r\n      score -= 20;\r\n    }\r\n    return score;\r\n  }\r\n\r\n  private assessLocationInfo(truckData: TruckData, issues: string[], score: number): number {\r\n    if (truckData.location?.current == undefined) {\r\n      issues.push('Missing current location data');\r\n      score -= 25;\r\n    } else {\r\n      if (\r\n        truckData.location.current.lat == undefined || \r\n        truckData.location.current.lng == undefined\r\n      ) {\r\n        issues.push('Missing GPS coordinates');\r\n        score -= 15;\r\n      }\r\n      if (truckData.location.current.address == undefined || truckData.location.current.address === '') {\r\n        issues.push('Missing address information');\r\n        score -= 10;\r\n      }\r\n    }\r\n    return score;\r\n  }\r\n\r\n  private assessContactInfo(truckData: TruckData, issues: string[], score: number): number {\r\n    if (truckData.contact) {\r\n      const hasPhone = typeof truckData.contact.phone === 'string' && truckData.contact.phone.trim() !== '';\r\n      const hasEmail = typeof truckData.contact.email === 'string' && truckData.contact.email.trim() !== '';\r\n\r\n      if (!hasPhone && !hasEmail) {\r\n        issues.push('No phone or email contact available');\r\n        score -= 15;\r\n      }\r\n      if (hasPhone && !this.isValidPhone(truckData.contact.phone as string)) {\r\n        issues.push('Invalid phone number format');\r\n        score -= 5;\r\n      }\r\n      if (hasEmail && !this.isValidEmail(truckData.contact.email as string)) {\r\n        issues.push('Invalid email format');\r\n        score -= 5;\r\n      }\r\n    } else {\r\n      issues.push('Missing contact information');\r\n      score -= 20;\r\n    }\r\n    return score;\r\n  }\r\n\r\n  private assessOperatingHours(truckData: TruckData, issues: string[], score: number): number {\r\n    if (truckData.operating_hours == undefined || Object.keys(truckData.operating_hours).length === 0) {\r\n      issues.push('Missing operating hours');\r\n      score -= 15;\r\n    }\r\n    return score;\r\n  }\r\n\r\n  private assessMenuInfo(truckData: TruckData, issues: string[], score: number): number {\r\n    if (truckData.menu == undefined || truckData.menu.length === 0) {\r\n      issues.push('Missing menu information');\r\n      score -= 10;\r\n    } else {\r\n      const menuIssues = this.validateMenuData(truckData.menu);\r\n      issues.push(...menuIssues);\r\n      score -= menuIssues.length * 2;\r\n    }\r\n    return score;\r\n  }\r\n\r\n  private assessLastUpdated(truckData: TruckData, issues: string[], score: number): number {\r\n    if (truckData.last_updated != undefined && truckData.last_updated !== '') {\r\n      const lastUpdate = new Date(truckData.last_updated);\r\n      const daysSinceUpdate = (Date.now() - lastUpdate.getTime()) / (1000 * 60 * 60 * 24);\r\n\r\n      if (daysSinceUpdate > 7) {\r\n        issues.push('Data is more than 7 days old');\r\n        score -= 10;\r\n      } else if (daysSinceUpdate > 3) {\r\n        issues.push('Data is more than 3 days old');\r\n        score -= 5;\r\n      }\r\n    }\r\n    return score;\r\n  }\r\n\r\n  assessTruckData(truckData: TruckData): { score: number; issues: string[] } {\r\n    const issues: string[] = [];\r\n    let score = 100;\r\n\r\n    score = this.assessBasicInfo(truckData, issues, score);\r\n    score = this.assessLocationInfo(truckData, issues, score);\r\n    score = this.assessContactInfo(truckData, issues, score);\r\n    score = this.assessOperatingHours(truckData, issues, score);\r\n    score = this.assessMenuInfo(truckData, issues, score);\r\n    score = this.assessLastUpdated(truckData, issues, score);\r\n\r\n    return {\r\n      score: Math.max(0, score) / 100,\r\n      issues,\r\n    };\r\n  }\r\n\r\n  private validateMenuCategory(category: MenuCategory, categoryIndex: number, issues: string[]): void {\r\n    if (category.category == undefined || category.category.trim().length === 0) {\r\n      issues.push(`Menu category ${categoryIndex + 1} missing name`);\r\n    }\r\n  }\r\n\r\n  private validateMenuItems(category: MenuCategory, issues: string[]): void {\r\n    if (category.items == undefined || category.items.length === 0) {\r\n      issues.push(`Menu category \"${category.category ?? 'Unknown'}\" has no items`);\r\n    } else {\r\n      for (const [itemIndex, item] of category.items.entries()) {\r\n        if (item.name == undefined || item.name.trim().length === 0) {\r\n          issues.push(`Menu item ${itemIndex + 1} in \"${category.category ?? 'Unknown'}\" missing name`);\r\n        }\r\n        if (typeof item.price !== 'number' || item.price <= 0) {\r\n          issues.push(`Menu item \"${item.name ?? 'Unknown'}\" has invalid price`);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  private validateMenuData(menu: MenuCategory[]): string[] {\r\n    const issues: string[] = [];\r\n\r\n    for (const [categoryIndex, category] of menu.entries()) {\r\n      this.validateMenuCategory(category, categoryIndex, issues);\r\n      this.validateMenuItems(category, issues);\r\n    }\r\n\r\n    return issues;\r\n  }\r\n  private isValidPhone(phone: string): boolean {\r\n    // Regex for phone number validation. Not vulnerable to super-linear runtime due to backtracking.\r\n    // Accepts +, digits, spaces, dashes, and parentheses. At least 10 digits.\r\n    const phoneRegex = /^\\+?[\\d\\s\\-()]{10,}$/;\r\n    return phoneRegex.test(phone);\r\n  }\r\n  private isValidEmail(email: string): boolean {\r\n    // Regex for email validation optimized to avoid backtracking\r\n    const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[a-zA-Z]{2,}$/;\r\n    return emailRegex.test(email);\r\n  }\r\n}\r\n\r\ninterface GeminiLocationData {\r\n  address: string;\r\n  city: string;\r\n  state: string;\r\n  coordinates: {\r\n    lat?: number;\r\n    lng?: number;\r\n  };\r\n  confidence: number;\r\n}\r\n\r\ninterface GeminiOperatingHours {\r\n  monday: { open: string; close: string; closed: boolean };\r\n  tuesday: { open: string; close: string; closed: boolean };\r\n  wednesday: { open: string; close: string; closed: boolean };\r\n  thursday: { open: string; close: string; closed: boolean };\r\n  friday: { open: string; close: string; closed: boolean };\r\n  saturday: { open: string; close: string; closed: boolean };\r\n  sunday: { open: string; close: string; closed: boolean };\r\n}\r\n\r\ninterface GeminiSentimentAnalysis {\r\n  sentiment: 'positive' | 'negative' | 'neutral';\r\n  score: number;\r\n  key_topics: string[];\r\n  summary: string;\r\n}\r\n\r\nexport class GeminiDataProcessor {\r\n  private _apiKey: string;\r\n  private _baseUrl: string;\r\n  private requestCount: number;\r\n  private tokenCount: number;\r\n  private dailyLimit: { requests: number; tokens: number };\r\n\r\n  constructor(apiKey: string) {\r\n    this._apiKey = apiKey;\r\n    this._baseUrl = 'https://generativelanguage.googleapis.com/v1beta';\r\n    this.requestCount = 0;\r\n    this.tokenCount = 0;\r\n    this.dailyLimit = { requests: 1500, tokens: 32_000 };\r\n  }\r\n  async processMenuData(rawMenuText: string): Promise<{ categories: MenuCategory[] }> {\r\n    if (!this.canMakeRequest()) {\r\n      throw new Error('Gemini API rate limit exceeded');\r\n    }\r\n\r\n    try {\r\n      const prompt = `\r\n        Parse the following food truck menu text and return a structured JSON format:\r\n        \r\n        ${rawMenuText}\r\n        \r\n        Return format:\r\n        {\r\n          \"categories\": [\r\n            {\r\n              \"name\": \"category_name\",\r\n              \"items\": [\r\n                {\r\n                  \"name\": \"item_name\",\r\n                  \"description\": \"item_description\",\r\n                  \"price\": 0.00,\r\n                  \"dietary_tags\": [\"vegetarian\", \"vegan\", \"gluten-free\", etc.]\r\n                }\r\n              ]\r\n            }\r\n          ]\r\n        }\r\n        \r\n        Only return valid JSON, no additional text.\r\n      `;\r\n\r\n      const response = await this.makeGeminiRequest(prompt);\r\n      this.updateUsageCounters(1, prompt.length + response.length);\r\n\r\n      // Ensure type safety for parsed response\r\n      const parsed: unknown = JSON.parse(response);\r\n      if (typeof parsed !== 'object' || parsed == undefined || !('categories' in parsed) || !Array.isArray((parsed as { categories: unknown[] }).categories)) {\r\n        throw new Error('Invalid Gemini menu response: missing or malformed categories array');\r\n      }\r\n      return parsed as { categories: MenuCategory[] };\r\n    } catch (error) {\r\n      console.error('Error processing menu data with Gemini:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  async extractLocationFromText(text: string): Promise<GeminiLocationData> {\r\n    if (!this.canMakeRequest()) {\r\n      throw new Error('Gemini API rate limit exceeded');\r\n    }\r\n\r\n    try {\r\n      const prompt = `\r\n        Extract location information from the following text and return structured data:\r\n        \r\n        \"${text}\"\r\n        \r\n        Return format:\r\n        {\r\n          \"address\": \"full_address\",\r\n          \"city\": \"city_name\",\r\n          \"state\": \"state\",\r\n          \"coordinates\": {\r\n            \"lat\": 0.0,\r\n            \"lng\": 0.0\r\n          },\r\n          \"confidence\": 0.95\r\n        }\r\n        \r\n        If coordinates cannot be determined, set them to undefined. Only return valid JSON.\r\n      `;\r\n      const response = await this.makeGeminiRequest(prompt);\r\n      this.updateUsageCounters(1, prompt.length + response.length);\r\n      const parsedResponse: unknown = JSON.parse(response);\r\n      const validatedResponse = this.validateGeminiLocationResponse(parsedResponse);\r\n      return validatedResponse;\r\n    } catch (error) {\r\n      console.error('Error extracting location with Gemini:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  private validateGeminiLocationResponse(parsedResponse: unknown): GeminiLocationData {\r\n    if (\r\n      parsedResponse == undefined ||\r\n      typeof parsedResponse !== 'object' ||\r\n      !('coordinates' in parsedResponse) ||\r\n      typeof (parsedResponse as Record<string, unknown>).coordinates !== 'object'\r\n    ) {\r\n      throw new Error('Invalid Gemini location response');\r\n    }\r\n    const coordinates = (parsedResponse as { coordinates?: { lat?: unknown; lng?: unknown } }).coordinates;\r\n    if (coordinates && typeof coordinates === 'object') {\r\n      if (typeof coordinates.lat !== 'number') {\r\n        (coordinates as { lat?: number | undefined }).lat = undefined;\r\n      }\r\n      if (typeof coordinates.lng !== 'number') {\r\n        (coordinates as { lng?: number | undefined }).lng = undefined;\r\n      }\r\n    }\r\n    return parsedResponse as GeminiLocationData;\r\n  }\r\n\r\n  async standardizeOperatingHours(hoursText: string): Promise<GeminiOperatingHours> {\r\n    if (!this.canMakeRequest()) {\r\n      throw new Error('Gemini API rate limit exceeded');\r\n    }\r\n\r\n    try {\r\n      const prompt = `\r\n        Parse the following operating hours text and return standardized format:\r\n        \r\n        \"${hoursText}\"\r\n        \r\n        Return format:\r\n        {\r\n          \"monday\": {\"open\": \"HH:MM\", \"close\": \"HH:MM\", \"closed\": false},\r\n          \"tuesday\": {\"open\": \"HH:MM\", \"close\": \"HH:MM\", \"closed\": false},\r\n          \"wednesday\": {\"open\": \"HH:MM\", \"close\": \"HH:MM\", \"closed\": false},\r\n          \"thursday\": {\"open\": \"HH:MM\", \"close\": \"HH:MM\", \"closed\": false},\r\n          \"friday\": {\"open\": \"HH:MM\", \"close\": \"HH:MM\", \"closed\": false},\r\n          \"saturday\": {\"open\": \"HH:MM\", \"close\": \"HH:MM\", \"closed\": false},\r\n          \"sunday\": {\"open\": \"HH:MM\", \"close\": \"HH:MM\", \"closed\": false}\r\n        }\r\n          Use 24-hour format. If closed on a day, set \"closed\": true and omit open/close times.\r\n        Only return valid JSON.\r\n      `;\r\n\r\n      const response = await this.makeGeminiRequest(prompt);\r\n      this.updateUsageCounters(1, prompt.length + response.length);\r\n      const parsed: unknown = JSON.parse(response);\r\n      if (parsed == undefined || typeof parsed !== 'object') {\r\n        throw new Error('Invalid Gemini hours response');\r\n      }\r\n      return parsed as GeminiOperatingHours;\r\n    } catch (error) {\r\n      console.error('Error standardizing hours with Gemini:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  async analyzeSentiment(reviewText: string): Promise<GeminiSentimentAnalysis> {\r\n    if (!this.canMakeRequest()) {\r\n      throw new Error('Gemini API rate limit exceeded');\r\n    }\r\n\r\n    try {\r\n      const prompt = `\r\n        Analyze the sentiment of this food truck review and extract key insights:\r\n        \r\n        \"${reviewText}\"\r\n        \r\n        Return format:\r\n        {\r\n          \"sentiment\": \"positive|negative|neutral\",\r\n          \"score\": 0.85,\r\n          \"key_topics\": [\"food_quality\", \"service\", \"price\", \"location\"],\r\n          \"summary\": \"brief_summary_of_review\"\r\n        }\r\n          Score should be between 0 (very negative) and 1 (very positive).\r\n        Only return valid JSON.\r\n      `;\r\n\r\n      const response = await this.makeGeminiRequest(prompt);\r\n      this.updateUsageCounters(1, prompt.length + response.length);\r\n      const parsed: unknown = JSON.parse(response);\r\n      if (parsed == undefined || typeof parsed !== 'object') {\r\n        throw new Error('Invalid Gemini sentiment response');\r\n      }\r\n      return parsed as GeminiSentimentAnalysis;\r\n    } catch (error) {\r\n      console.error('Error analyzing sentiment with Gemini:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  private async makeGeminiRequest(prompt: string): Promise<string> {\r\n    await new Promise((resolve) => setTimeout(resolve, 1000)); // Simulate API delay\r\n    return this.getMockGeminiResponse(prompt);\r\n  }\r\n\r\n  private getMockGeminiResponse(prompt: string): string {\r\n    if (prompt.includes('menu text')) {\r\n      return JSON.stringify({\r\n        categories: [\r\n          {\r\n            name: 'Burgers',\r\n            items: [\r\n              {\r\n                name: 'Classic Cheeseburger',\r\n                description: 'Beef patty with cheese, lettuce, tomato',\r\n                price: 12.99,\r\n                dietary_tags: [],\r\n              },\r\n            ],\r\n          },\r\n        ],\r\n      });\r\n    } else if (prompt.includes('location information')) {\r\n      return JSON.stringify({\r\n        address: '123 Market St, San Francisco, CA 94105',\r\n        city: 'San Francisco',\r\n        state: 'CA',\r\n        coordinates: {\r\n          lat: 37.7749,\r\n          lng: -122.4194,\r\n        },\r\n        confidence: 0.95,\r\n      });\r\n    } else if (prompt.includes('operating hours')) {\r\n      return JSON.stringify({\r\n        monday: { open: '11:00', close: '15:00', closed: false },\r\n        tuesday: { open: '11:00', close: '15:00', closed: false },\r\n        wednesday: { open: '11:00', close: '15:00', closed: false },\r\n        thursday: { open: '11:00', close: '15:00', closed: false },\r\n        friday: { open: '11:00', close: '20:00', closed: false },\r\n        saturday: { open: '12:00', close: '20:00', closed: false },\r\n        sunday: { open: '12:00', close: '16:00', closed: false },\r\n      });\r\n    } else if (prompt.includes('sentiment')) {\r\n      return JSON.stringify({\r\n        sentiment: 'positive',\r\n        score: 0.85,\r\n        key_topics: ['food_quality', 'service'],\r\n        summary: 'Customer enjoyed the food and service',\r\n      });\r\n    }\r\n    return '{\"processed\": true}';\r\n  }\r\n\r\n  private canMakeRequest(): boolean {\r\n    return this.requestCount < this.dailyLimit.requests && this.tokenCount < this.dailyLimit.tokens;\r\n  }\r\n\r\n  private updateUsageCounters(requests: number, tokens: number): void {\r\n    this.requestCount += requests;\r\n    this.tokenCount += tokens;\r\n  }\r\n\r\n  getUsageStats(): {\r\n    requests: { used: number; limit: number; remaining: number };\r\n    tokens: { used: number; limit: number; remaining: number };\r\n  } {\r\n    return {\r\n      requests: {\r\n        used: this.requestCount,\r\n        limit: this.dailyLimit.requests,\r\n        remaining: this.dailyLimit.requests - this.requestCount,\r\n      },\r\n      tokens: {\r\n        used: this.tokenCount,\r\n        limit: this.dailyLimit.tokens,\r\n        remaining: this.dailyLimit.tokens - this.tokenCount,\r\n      },\r\n    };\r\n  }\r\n}\r\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\lib\\activityLogger.ts",
    "messages": [],
    "suppressedMessages": [
      {
        "ruleId": "sonarjs/pseudo-random",
        "severity": 2,
        "message": "Make sure that using this pseudorandom number generator is safe here.",
        "line": 45,
        "column": 10,
        "nodeType": "CallExpression",
        "messageId": "safeGenerator",
        "endLine": 45,
        "endColumn": 23,
        "suppressions": [
          {
            "kind": "directive",
            "justification": "Math.random is acceptable for non-security-critical logging IDs."
          }
        ]
      }
    ],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\lib\\api\\admin\\automated-cleanup\\handlers.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\lib\\api\\admin\\automated-cleanup\\types.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\lib\\api\\admin\\data-cleanup\\handlers.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\lib\\api\\admin\\data-quality\\handlers.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 14,
        "column": 12,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 14,
        "endColumn": 19,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [488, 496], "text": "truckId == null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [489, 496], "text": "(truckId ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [488, 496], "text": "!Boolean(truckId)" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/await-thenable",
        "severity": 2,
        "message": "Unexpected `await` of a non-Promise (non-\"Thenable\") value.",
        "line": 47,
        "column": 14,
        "nodeType": "AwaitExpression",
        "messageId": "await",
        "endLine": 47,
        "endColumn": 39,
        "suggestions": [
          {
            "messageId": "removeAwait",
            "fix": { "range": [1515, 1520], "text": "" },
            "desc": "Remove unnecessary `await`."
          }
        ]
      },
      {
        "ruleId": "sonarjs/no-invalid-await",
        "severity": 2,
        "message": "Refactor this redundant 'await' on a non-promise.",
        "line": 47,
        "column": 14,
        "nodeType": "AwaitExpression",
        "messageId": "refactorAwait",
        "endLine": 47,
        "endColumn": 39
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 175,
        "column": 10,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 175,
        "endColumn": 20,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [5054, 5065], "text": "authHeader == null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [5055, 5065], "text": "(authHeader ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [5054, 5065], "text": "!Boolean(authHeader)" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 2,
    "fatalErrorCount": 0,
    "warningCount": 2,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { NextRequest, NextResponse } from 'next/server';\r\nimport { FoodTruckService, supabase, FoodTruck } from '@/lib/supabase';\r\n\r\nexport async function handleGetRequest(request: NextRequest): Promise<NextResponse> {\r\n  const { searchParams } = new URL(request.url);\r\n  const action = searchParams.get('action');\r\n  const truckId = searchParams.get('truckId');\r\n\r\n  switch (action) {\r\n    case 'stats': {\r\n      return await handleStatsAction();\r\n    }\r\n    case 'assess': {\r\n      if (!truckId) {\r\n        return NextResponse.json({ success: false, error: 'Missing truckId for assess action' }, { status: 400 });\r\n      }\r\n      return await handleAssessAction(truckId);\r\n    }\r\n    default: {\r\n      return await handleDefaultGetAction();\r\n    }\r\n  }\r\n}\r\n\r\ninterface PostRequestBody {\r\n  action: string;\r\n  truckId?: string;\r\n}\r\n\r\nexport async function handlePostRequest(request: NextRequest): Promise<NextResponse> {\r\n  const body: unknown = await request.json();\r\n\r\n  if (typeof body !== 'object' || body === null) {\r\n    return NextResponse.json({ success: false, error: 'Invalid request body' }, { status: 400 });\r\n  }\r\n\r\n  const { action, truckId } = body as PostRequestBody;\r\n\r\n  switch (action) {\r\n    case 'update-single': {\r\n      if (truckId === undefined || truckId === '') {\r\n        return NextResponse.json({ success: false, error: 'Missing truckId for update-single action' }, { status: 400 });\r\n      }\r\n      return handleUpdateSingle(truckId);\r\n    }\r\n    case 'batch-update': {\r\n      return await handleBatchUpdate();\r\n    }\r\n    case 'recalculate-all': {\r\n      return await handleRecalculateAll();\r\n    }\r\n    default: {\r\n      return NextResponse.json({ success: false, error: `Unknown action: ${action}` }, { status: 400 });\r\n    }\r\n  }\r\n}\r\n\r\nasync function handleStatsAction() {\r\n  const qualityStats = await FoodTruckService.getDataQualityStats();\r\n\r\n  return NextResponse.json({\r\n    success: true,\r\n    data: {\r\n      ...qualityStats,\r\n      timestamp: new Date().toISOString()\r\n    }\r\n  });\r\n}\r\n\r\nasync function handleAssessAction(truckId: string) {\r\n  const truckResult = await FoodTruckService.getTruckById(truckId);\r\n\r\n  if ('error' in truckResult) {\r\n    return NextResponse.json({ success: false, error: truckResult.error }, { status: 404 });\r\n  }\r\n\r\n  const truck: FoodTruck = truckResult; // Explicitly cast to FoodTruck\r\n\r\n  return NextResponse.json({\r\n    success: true,\r\n    data: {\r\n      truckId,\r\n      truckName: truck.name,\r\n      currentScore: truck.data_quality_score,\r\n      timestamp: new Date().toISOString()\r\n    }\r\n  });\r\n}\r\n\r\nasync function handleDefaultGetAction() {\r\n  const qualityStats = await FoodTruckService.getDataQualityStats();\r\n  return NextResponse.json({\r\n    success: true,\r\n    data: qualityStats\r\n  });\r\n}\r\n\r\nasync function handleUpdateSingle(truckId: string) {\r\n  const updatedTruckResult = await FoodTruckService.getTruckById(truckId);\r\n  \r\n  if ('error' in updatedTruckResult) {\r\n    return NextResponse.json({ success: false, error: updatedTruckResult.error }, { status: 404 });\r\n  }\r\n\r\n  const updatedTruck = updatedTruckResult;\r\n\r\n  return NextResponse.json({\r\n    success: true,\r\n    message: 'Quality score updated successfully',\r\n    data: {\r\n      truckId: updatedTruck.id,\r\n      truckName: updatedTruck.name,\r\n      newScore: updatedTruck.data_quality_score,\r\n      verificationStatus: updatedTruck.verification_status,\r\n      timestamp: new Date().toISOString()\r\n    }\r\n  });\r\n}\r\n\r\nfunction handleBatchUpdate() {\r\n  return NextResponse.json({\r\n    success: true,\r\n    message: 'Batch quality score update completed',\r\n    data: {\r\n      timestamp: new Date().toISOString()\r\n    }\r\n  });\r\n}\r\n\r\nfunction updateSingleTruckQualityScore(truck: { id: string }): boolean {\r\n  try {\r\n    // Placeholder for actual update logic if needed\r\n    // DataQualityService.updateTruckQualityScore(truck.id);\r\n    return true;\r\n  } catch (error: unknown) {\r\n    console.error(`Failed to update truck ${truck.id}:`, error);\r\n    return false;\r\n  }\r\n}\r\n\r\nasync function handleRecalculateAll() {\r\n  const allTrucksResult = await FoodTruckService.getAllTrucks(1000, 0);\r\n  if (allTrucksResult.error !== undefined) {\r\n    console.error('Error fetching all trucks for recalculation:', allTrucksResult.error);\r\n    return NextResponse.json({ success: false, error: 'Failed to fetch trucks for recalculation' }, { status: 500 });\r\n  }\r\n  const { trucks } = allTrucksResult;\r\n  let updated = 0;\r\n  let errors = 0;\r\n\r\n  for (const truck of trucks) {\r\n    const success = updateSingleTruckQualityScore(truck);\r\n    if (success) {\r\n      updated++;\r\n    } else {\r\n      errors++;\r\n    }\r\n  }\r\n\r\n  return NextResponse.json({\r\n    success: true,\r\n    message: 'Quality score recalculation completed',\r\n    data: {\r\n      totalTrucks: trucks.length,\r\n      updated,\r\n      errors,\r\n      timestamp: new Date().toISOString()\r\n    }\r\n  });\r\n}\r\n\r\nexport async function verifyAdminAccess(request: Request): Promise<boolean> {\r\n  try {\r\n    const authHeader = request.headers.get('authorization');\r\n    if (!authHeader) return false;\r\n\r\n    const token = authHeader.replace('Bearer ', '');\r\n    const { data, error } = await supabase.auth.getUser(token);\r\n    const user = data?.user;\r\n    \r\n    if (error || !user) return false;\r\n\r\n    const { data: profile } = await supabase\r\n      .from('profiles')\r\n      .select('role')\r\n      .eq('id', user.id)\r\n      .single();\r\n\r\n    return profile?.role === 'admin';\r\n  } catch {\r\n    return false;\r\n  }\r\n}\r\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\lib\\api\\admin\\oauth-status\\helpers.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.",
        "line": 206,
        "column": 7,
        "nodeType": "ChainExpression",
        "messageId": "conditionErrorNullableBoolean",
        "endLine": 206,
        "endColumn": 50,
        "suggestions": [
          {
            "messageId": "conditionFixDefaultFalse",
            "fix": {
              "range": [7545, 7588],
              "text": "((status.supabase.authSettings?.googleEnabled) ?? false)"
            },
            "desc": "Explicitly treat nullish value the same as false (`value ?? false`)"
          },
          {
            "messageId": "conditionFixCompareTrue",
            "fix": {
              "range": [7545, 7588],
              "text": "((status.supabase.authSettings?.googleEnabled) === true)"
            },
            "desc": "Change condition to check if true (`value === true`)"
          }
        ]
      }
    ],
    "suppressedMessages": [
      {
        "ruleId": "sonarjs/different-types-comparison",
        "severity": 2,
        "message": "Remove this \"!==\" check; it will always be true. Did you mean to use \"!=\"?",
        "line": 197,
        "column": 59,
        "nodeType": null,
        "endLine": 197,
        "endColumn": 62,
        "suggestions": [
          { "desc": "Replace \"!==\" with \"!=\"", "fix": { "range": [7347, 7350], "text": "!=" } }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      }
    ],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { NextRequest, NextResponse } from 'next/server';\r\nimport { supabase } from '@/lib/supabase';\r\nimport { OAuthStatus } from './types';\r\nimport type { SupabaseClient } from '@supabase/supabase-js';\r\n\r\nexport async function handleGetRequest(_request: NextRequest) {\r\n  const status = await getOAuthStatus();\r\n\r\n  return NextResponse.json({\r\n    success: true,\r\n    ...status,\r\n    legacy_format: {\r\n      oauth_status: status.overall_status,\r\n      message: getStatusMessage(status.overall_status),\r\n      configuration_steps: status.overall_status === 'ready' ? undefined : [\r\n        '1. Go to Supabase Dashboard > Authentication > Providers',\r\n        '2. Enable Google provider',\r\n        '3. Add Google OAuth Client ID and Secret',\r\n        '4. Configure redirect URLs',\r\n        '5. Test OAuth flow'\r\n      ]\r\n    }\r\n  });\r\n}\r\n\r\n// 1. Refactor nested template literals in generateOAuthTestUrl\r\nfunction generateOAuthTestUrl(baseUrl: string): string {\r\n  const redirectPath = `${baseUrl}/auth/callback`;\r\n  const encodedRedirect = encodeURIComponent(redirectPath);\r\n  return process.env.NEXT_PUBLIC_SUPABASE_URL + '/auth/v1/authorize?provider=google&redirect_to=' + encodedRedirect;\r\n}\r\n\r\nexport function handlePostRequest() { // Removed _request parameter\r\n  const baseUrl = process.env.NODE_ENV === 'production'\r\n    ? 'https://food-truck-finder-poc-git-feat-s-20ec1c-codedeficients-projects.vercel.app'\r\n    : 'http://localhost:3000';\r\n\r\n  const testUrl = generateOAuthTestUrl(baseUrl);\r\n\r\n  return NextResponse.json({\r\n    success: true,\r\n    message: 'OAuth test URL generated',\r\n    test_url: testUrl,\r\n    environment: process.env.NODE_ENV ?? 'development',\r\n    instructions: [\r\n      '1. Open the test_url in a new browser tab',\r\n      '2. Complete Google OAuth flow',\r\n      '3. Verify redirect to admin dashboard',\r\n      '4. Check for proper role assignment'\r\n    ],\r\n    manual_test_steps: [\r\n      'Navigate to /login page',\r\n      'Click Google login button',\r\n      'Complete OAuth flow',\r\n      'Verify admin access'\r\n    ],\r\n    automation_commands: [\r\n      'npm run oauth:verify - Check configuration',\r\n      'npm run oauth:test:dev - Test development flow',\r\n      'npm run oauth:test:prod - Test production flow'\r\n    ]\r\n  });\r\n}\r\n\r\nasync function getOAuthStatus(): Promise<OAuthStatus> {\r\n  const status: OAuthStatus = {\r\n    timestamp: new Date().toISOString(),\r\n    environment: process.env.NODE_ENV === 'production' ? 'production' : 'development',\r\n    supabase: {\r\n      connected: false,\r\n      projectId: 'zkwliyjjkdnigizidlln' as string\r\n    },\r\n    environment_variables: {\r\n      supabaseUrl: process.env.NEXT_PUBLIC_SUPABASE_URL !== undefined,\r\n      supabaseAnonKey: process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY !== undefined,\r\n      supabaseServiceKey: process.env.SUPABASE_SERVICE_ROLE_KEY !== undefined\r\n    },\r\n    oauth_flow: {\r\n      loginPageExists: true,\r\n      callbackRouteExists: true,\r\n      authProviderConfigured: false\r\n    },\r\n    recommendations: [],\r\n    overall_status: 'not_configured'\r\n  };\r\n\r\n  await checkSupabaseConnection(status, supabase);\r\n  await checkSupabaseAuthSettings(status);\r\n  await testOAuthProvider(status, supabase);\r\n\r\n  status.recommendations = generateRecommendations(status);\r\n  status.overall_status = determineOverallStatus(status);\r\n\r\n  return status;\r\n}\r\n\r\nasync function checkSupabaseConnection(status: OAuthStatus, supabase: SupabaseClient) {\r\n  try {\r\n    const { error } = await supabase.from('profiles').select('count').limit(1);\r\n    if (error === null) {\r\n      status.supabase.connected = true;\r\n    } else {\r\n      status.supabase.error = error.message;\r\n    }\r\n  } catch (error: unknown) {\r\n    status.supabase.error =\r\n      error instanceof Error ? error.message : 'Unknown connection error';\r\n  }\r\n}\r\n\r\nasync function checkSupabaseAuthSettings(status: OAuthStatus) {\r\n  try {\r\n    const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;\r\n    if (typeof supabaseUrl === 'string' && supabaseUrl.length > 0) { // Explicit check for undefined and empty string\r\n      const settingsResponse = await fetch(`${supabaseUrl}/auth/v1/settings`);\r\n      if (settingsResponse.ok === true) {\r\n        const settings: {\r\n          external?: { google?: boolean };\r\n          disable_signup?: boolean;\r\n          autoconfirm?: boolean;\r\n        } = (await settingsResponse.json()) as {\r\n          external?: { google?: boolean };\r\n          disable_signup?: boolean;\r\n          autoconfirm?: boolean;\r\n        };\r\n        status.supabase.authSettings = {\r\n          googleEnabled: settings.external?.google ?? false,\r\n          signupEnabled: settings.disable_signup === false,\r\n          autoconfirm: settings.autoconfirm ?? false\r\n        };\r\n        if (settings.external?.google !== undefined) { // Explicit check for undefined\r\n          status.oauth_flow.authProviderConfigured = true;\r\n        }\r\n      }\r\n    }\r\n  } catch {\r\n    console.info('Auth settings endpoint requires authentication (normal)');\r\n  }\r\n}\r\n\r\nasync function testOAuthProvider(status: OAuthStatus, supabase: SupabaseClient) {\r\n  try {\r\n    const { error: oauthError } = await supabase.auth.signInWithOAuth({\r\n      provider: 'google',\r\n      options: {\r\n        redirectTo: 'http://localhost:3000/auth/callback',\r\n        skipBrowserRedirect: true\r\n      }\r\n    });\r\n    if (oauthError !== null && oauthError.message !== 'Provider not found') { // Explicitly check for oauthError existence\r\n      status.oauth_flow.authProviderConfigured = true;\r\n    }\r\n  } catch (error: unknown) {\r\n    console.info('OAuth provider test failed (may be normal):', error);\r\n  }\r\n}\r\n\r\nfunction generateRecommendations(status: OAuthStatus): string[] {\r\n  const recommendations: string[] = [];\r\n\r\n  if (!status.environment_variables.supabaseUrl) {\r\n    recommendations.push('❌ Configure NEXT_PUBLIC_SUPABASE_URL environment variable');\r\n  }\r\n  if (!status.environment_variables.supabaseAnonKey) {\r\n    recommendations.push('❌ Configure NEXT_PUBLIC_SUPABASE_ANON_KEY environment variable');\r\n  }\r\n  if (!status.environment_variables.supabaseServiceKey) {\r\n    recommendations.push('❌ Configure SUPABASE_SERVICE_ROLE_KEY environment variable');\r\n  }\r\n\r\n  if (!status.supabase.connected) {\r\n    recommendations.push('❌ Fix Supabase connection issue');\r\n  if (typeof status.supabase.error === 'string' && status.supabase.error.length > 0) {\r\n    recommendations.push(`   Error: ${status.supabase.error}`);\r\n  }\r\n  }\r\n\r\n  if (status.supabase.authSettings?.googleEnabled === true) {\r\n    recommendations.push('✅ Google OAuth provider is enabled');\r\n  } else {\r\n    recommendations.push('🔧 Enable Google OAuth provider in Supabase Dashboard', '   Go to: Authentication > Providers > Google');\r\n  }\r\n\r\n  if (status.overall_status === 'ready') {\r\n    recommendations.push('🎉 OAuth configuration is complete!', '✅ Test the login flow at /login');\r\n  }\r\n\r\n  if (recommendations.length > 1) {\r\n    recommendations.push('📖 See docs/GOOGLE_OAUTH_SETUP_GUIDE.md for detailed instructions', '🔧 Run: npm run oauth:verify for automated checks');\r\n  }\r\n\r\n  return recommendations;\r\n}\r\n\r\nfunction determineOverallStatus(status: OAuthStatus): 'ready' | 'partial' | 'not_configured' | 'error' {\r\n  // eslint-disable-next-line sonarjs/different-types-comparison\r\n  if (!status.supabase.connected || status.supabase.error !== null) {\r\n    return 'error';\r\n  }\r\n\r\n  const envVarsComplete = Object.values(status.environment_variables).every(Boolean);\r\n  if (!envVarsComplete) {\r\n    return 'not_configured';\r\n  }\r\n\r\n  if (status.supabase.authSettings?.googleEnabled && status.oauth_flow.authProviderConfigured) {\r\n    return 'ready';\r\n  }\r\n\r\n  if (status.supabase.connected && envVarsComplete) {\r\n    return 'partial';\r\n  }\r\n\r\n  return 'not_configured';\r\n}\r\n\r\nfunction getStatusMessage(status: string): string {\r\n  switch (status) {\r\n    case 'ready': {\r\n      return 'Google OAuth is fully configured and ready to use';\r\n    }\r\n    case 'partial': {\r\n      return 'Basic configuration complete, OAuth provider needs setup';\r\n    }\r\n    case 'not_configured': {\r\n      return 'Google OAuth is not configured';\r\n    }\r\n    case 'error': {\r\n      return 'Configuration error detected';\r\n    }\r\n    default: {\r\n      return 'Unknown configuration status';\r\n    }\r\n  }\r\n}\r\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\lib\\api\\admin\\oauth-status\\types.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\lib\\api\\admin\\realtime-events\\handlers.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.",
        "line": 28,
        "column": 10,
        "nodeType": "ChainExpression",
        "messageId": "conditionErrorNullableBoolean",
        "endLine": 28,
        "endColumn": 43,
        "suggestions": [
          {
            "messageId": "conditionFixDefaultFalse",
            "fix": {
              "range": [809, 842],
              "text": "((authHeader?.startsWith('Bearer ')) ?? false)"
            },
            "desc": "Explicitly treat nullish value the same as false (`value ?? false`)"
          },
          {
            "messageId": "conditionFixCompareFalse",
            "fix": { "range": [808, 842], "text": "(authHeader?.startsWith('Bearer ')) === false" },
            "desc": "Change condition to check if false (`value === false`)"
          }
        ]
      },
      {
        "ruleId": "sonarjs/different-types-comparison",
        "severity": 2,
        "message": "Remove this \"===\" check; it will always be false. Did you mean to use \"==\"?",
        "line": 35,
        "column": 28,
        "nodeType": null,
        "endLine": 35,
        "endColumn": 31,
        "suggestions": [
          { "desc": "Replace \"===\" with \"==\"", "fix": { "range": [1011, 1014], "text": "==" } }
        ]
      },
      {
        "ruleId": "sonarjs/pseudo-random",
        "severity": 2,
        "message": "Make sure that using this pseudorandom number generator is safe here.",
        "line": 320,
        "column": 27,
        "nodeType": "CallExpression",
        "messageId": "safeGenerator",
        "endLine": 320,
        "endColumn": 40
      }
    ],
    "suppressedMessages": [
      {
        "ruleId": "@typescript-eslint/no-misused-promises",
        "severity": 2,
        "message": "Promise returned in function argument where a void return was expected.",
        "line": 73,
        "column": 38,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "voidReturnArgument",
        "endLine": 75,
        "endColumn": 8,
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "@typescript-eslint/no-misused-promises",
        "severity": 2,
        "message": "Promise returned in function argument where a void return was expected.",
        "line": 134,
        "column": 22,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "voidReturnArgument",
        "endLine": 140,
        "endColumn": 4,
        "suppressions": [{ "kind": "directive", "justification": "" }]
      }
    ],
    "errorCount": 2,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/* eslint-disable @typescript-eslint/no-misused-promises */\r\nimport { NextRequest } from 'next/server';\r\nimport { supabase, supabaseAdmin, ScrapingJobService, FoodTruckService, type ScrapingJob, type FoodTruck } from '@/lib/supabase';\r\nimport { AdminEvent } from './types';\r\n\r\ninterface RealtimeMetrics {\r\n  scrapingJobs: {\r\n    active: number;\r\n    completed: number;\r\n    failed: number;\r\n    pending: number;\r\n  };\r\n  dataQuality: {\r\n    averageScore: number;\r\n    totalTrucks: number;\r\n    recentChanges: number;\r\n  };\r\n  systemHealth: {\r\n    status: 'healthy' | 'warning' | 'error';\r\n    uptime: number;\r\n    lastUpdate: string;\r\n  };\r\n}\r\n\r\nexport async function verifyAdminAccess(request: NextRequest): Promise<boolean> {\r\n  try {\r\n    const authHeader = request.headers.get('authorization');\r\n    if (!authHeader?.startsWith('Bearer ')) {\r\n      return false;\r\n    }\r\n\r\n    const token = authHeader.slice(7);\r\n    const { data, error } = await supabase.auth.getUser(token);\r\n\r\n    if (error || data.user === null) {\r\n      return false;\r\n    }\r\n    const user = data.user;\r\n\r\n    if (!supabaseAdmin) {\r\n      return false;\r\n    }\r\n\r\n    const { data: profile } = await supabaseAdmin\r\n      .from('profiles')\r\n      .select('role')\r\n      .eq('id', user.id)\r\n      .single();\r\n\r\n    return profile?.role === 'admin';\r\n  } catch {\r\n    return false;\r\n  }\r\n}\r\n\r\nexport function handleGetRequest(request: NextRequest): Response {\r\n  const stream = new ReadableStream({\r\n    start(controller: ReadableStreamDefaultController<Uint8Array>) {\r\n      const encoder = new TextEncoder();\r\n\r\n      const connectionEvent: AdminEvent = {\r\n        id: generateEventId(),\r\n        type: 'heartbeat',\r\n        timestamp: new Date().toISOString(),\r\n        data: {\r\n          message: 'Real-time admin dashboard connected',\r\n          connectionId: generateEventId()\r\n        }\r\n      };\r\n      \r\n      controller.enqueue(encoder.encode(formatSSEMessage(connectionEvent)));\r\n\r\n      const intervalId = setInterval(async () => {\r\n        await sendHeartbeatEvent(controller, encoder);\r\n      }, 5000);\r\n\r\n      const changeMonitorId = setupDataChangeMonitor(controller, encoder);\r\n\r\n      request.signal.addEventListener('abort', () => {\r\n        clearInterval(intervalId);\r\n        clearInterval(changeMonitorId);\r\n        controller.close();\r\n      });\r\n    }\r\n  });\r\n\r\n  return new Response(stream, {\r\n    headers: {\r\n      'Content-Type': 'text/event-stream',\r\n      'Cache-Control': 'no-cache',\r\n      'Connection': 'keep-alive',\r\n      'Access-Control-Allow-Origin': '*',\r\n      'Access-Control-Allow-Headers': 'Cache-Control'\r\n    }\r\n  });\r\n}\r\n\r\nasync function sendHeartbeatEvent(\r\n  controller: ReadableStreamDefaultController<Uint8Array>,\r\n  encoder: TextEncoder\r\n): Promise<void> {\r\n  try {\r\n    const metrics = await fetchRealtimeMetrics();\r\n    const event: AdminEvent = {\r\n      id: generateEventId(),\r\n      type: 'heartbeat',\r\n      timestamp: new Date().toISOString(),\r\n      data: { ...metrics }\r\n    };\r\n\r\n    controller.enqueue(encoder.encode(formatSSEMessage(event)));\r\n  } catch (error) {\r\n    console.error('Error fetching realtime metrics:', error);\r\n\r\n    const errorEvent: AdminEvent = {\r\n      id: generateEventId(),\r\n      type: 'system_alert',\r\n      timestamp: new Date().toISOString(),\r\n      data: {\r\n        error: 'Failed to fetch metrics',\r\n        details: error instanceof Error ? error.message : 'Unknown error'\r\n      },\r\n      severity: 'error'\r\n    };\r\n\r\n    controller.enqueue(encoder.encode(formatSSEMessage(errorEvent)));\r\n  }\r\n}\r\n\r\nfunction setupDataChangeMonitor(\r\n  controller: ReadableStreamDefaultController<Uint8Array>,\r\n  encoder: TextEncoder\r\n): NodeJS.Timeout {\r\n  return setInterval(async () => {\r\n    try {\r\n      await monitorDataChanges(controller, encoder);\r\n    } catch (error) {\r\n      console.error('Error monitoring data changes:', error);\r\n    }\r\n  }, 10_000);\r\n}\r\n\r\nexport async function handlePostRequest(request: NextRequest): Promise<Response> {\r\n  try {\r\n    const body: unknown = await request.json(); // Explicitly type body as unknown\r\n    let action: string;\r\n\r\n    // Type guard to ensure 'body' has 'action' property and is a string\r\n    if (typeof body === 'object' && body !== null && 'action' in body && typeof (body as { action: string }).action === 'string') {\r\n      action = (body as { action: string }).action;\r\n    } else {\r\n      return new Response(JSON.stringify({\r\n        success: false,\r\n        error: \"Invalid request body: 'action' property is missing or not a string.\"\r\n      }), {\r\n        status: 400,\r\n        headers: { 'Content-Type': 'application/json' }\r\n      });\r\n    }\r\n\r\n    switch (action) {\r\n      case 'health_check': {\r\n        return await handleHealthCheck();\r\n      }\r\n\r\n      case 'trigger_test_event': {\r\n        return handleTriggerTestEvent();\r\n      }\r\n\r\n      default: {\r\n        return new Response(JSON.stringify({\r\n          success: false,\r\n          error: \"That didn't work, please try again later.\"\r\n        }), {\r\n          status: 400,\r\n          headers: { 'Content-Type': 'application/json' }\r\n        });\r\n      }\r\n    }\r\n  } catch (error) {\r\n    console.error('Realtime events POST error:', error);\r\n    return new Response(JSON.stringify({\r\n      success: false,\r\n      error: \"That didn't work, please try again later.\"\r\n    }), {\r\n      status: 500,\r\n      headers: { 'Content-Type': 'application/json' }\r\n    });\r\n  }\r\n}\r\n\r\nasync function fetchRealtimeMetrics(): Promise<RealtimeMetrics> {\r\n  try {\r\n    const recentJobs = await ScrapingJobService.getJobsByStatus('all');\r\n    const scrapingMetrics = {\r\n      active: recentJobs.filter((job: ScrapingJob) => job.status === 'running').length,\r\n      completed: recentJobs.filter((job: ScrapingJob) => job.status === 'completed').length,\r\n      failed: recentJobs.filter((job: ScrapingJob) => job.status === 'failed').length,\r\n      pending: recentJobs.filter((job: ScrapingJob) => job.status === 'pending').length\r\n    };\r\n\r\n    const qualityStats = await FoodTruckService.getDataQualityStats();\r\n    const dataQualityMetrics = {\r\n      averageScore: qualityStats.avg_quality_score ?? 0,\r\n      totalTrucks: qualityStats.total_trucks ?? 0,\r\n      recentChanges: 0\r\n    };\r\n\r\n    const systemHealth = {\r\n      status: 'healthy' as const,\r\n      uptime: process.uptime(),\r\n      lastUpdate: new Date().toISOString()\r\n    };\r\n\r\n    return {\r\n      scrapingJobs: scrapingMetrics,\r\n      dataQuality: dataQualityMetrics,\r\n      systemHealth\r\n    };\r\n  } catch (error) {\r\n    console.error('Error fetching realtime metrics:', error);\r\n    return {\r\n      scrapingJobs: { active: 0, completed: 0, failed: 0, pending: 0 },\r\n      dataQuality: { averageScore: 0, totalTrucks: 0, recentChanges: 0 },\r\n      systemHealth: {\r\n        status: 'error',\r\n        uptime: 0,\r\n        lastUpdate: new Date().toISOString()\r\n      }\r\n    };\r\n  }\r\n}\r\n\r\nfunction isScrapingJob(obj: unknown): obj is ScrapingJob {\r\n  return typeof obj === 'object' && obj !== null && 'id' in obj && 'status' in obj;\r\n}\r\n\r\n// Removed isFoodTruck function as it is unused.\r\n// function isFoodTruck(obj: unknown): obj is FoodTruck {\r\n//   return typeof obj === 'object' && obj !== null && 'id' in obj && 'name' in obj;\r\n// }\r\n\r\nasync function sendScrapingUpdateEvent(\r\n  controller: ReadableStreamDefaultController<Uint8Array>,\r\n  encoder: TextEncoder\r\n): Promise<void> {\r\n  const recentJobs = await ScrapingJobService.getJobsByStatus('all');\r\n\r\n  if (Array.isArray(recentJobs) && recentJobs.length > 0) {\r\n    const event: AdminEvent = {\r\n      id: generateEventId(),\r\n      type: 'scraping_update',\r\n      timestamp: new Date().toISOString(),\r\n      data: {\r\n        recentJobs: recentJobs.filter((job) => isScrapingJob(job)).map((job) => ({ // Fixed unicorn/no-array-callback-reference\r\n          id: job.id,\r\n          status: job.status,\r\n          started_at: job.started_at,\r\n          completed_at: job.completed_at\r\n        })),\r\n        count: recentJobs.length\r\n      },\r\n      severity: 'info'\r\n    };\r\n\r\n    controller.enqueue(encoder.encode(formatSSEMessage(event)));\r\n  }\r\n}\r\n\r\nasync function sendDataQualityChangeEvent(\r\n  controller: ReadableStreamDefaultController<Uint8Array>,\r\n  encoder: TextEncoder\r\n): Promise<void> {\r\n  const recentTrucksResult = await FoodTruckService.getAllTrucks(10, 0);\r\n  const recentlyUpdated = recentTrucksResult.trucks.filter((truck: FoodTruck) => {\r\n    if (!truck.updated_at) return false;\r\n    const updatedAt = new Date(truck.updated_at);\r\n    const oneMinuteAgo = new Date(Date.now() - 60_000);\r\n    return updatedAt > oneMinuteAgo;\r\n  });\r\n\r\n  if (recentlyUpdated.length > 0) {\r\n    const event: AdminEvent = {\r\n      id: generateEventId(),\r\n      type: 'data_quality_change',\r\n      timestamp: new Date().toISOString(),\r\n      data: {\r\n        updatedTrucks: recentlyUpdated.map(truck => ({\r\n          id: truck.id,\r\n          name: truck.name,\r\n          data_quality_score: truck.data_quality_score,\r\n          updated_at: truck.updated_at\r\n        })),\r\n        count: recentlyUpdated.length\r\n      },\r\n      severity: 'info'\r\n    };\r\n\r\n    controller.enqueue(encoder.encode(formatSSEMessage(event)));\r\n  }\r\n}\r\n\r\nasync function monitorDataChanges(\r\n  controller: ReadableStreamDefaultController<Uint8Array>,\r\n  encoder: TextEncoder\r\n): Promise<void> {\r\n  try {\r\n    await sendScrapingUpdateEvent(controller, encoder);\r\n    await sendDataQualityChangeEvent(controller, encoder);\r\n  } catch (error) {\r\n    console.error('Error monitoring data changes:', error);\r\n  }\r\n}\r\n\r\nfunction formatSSEMessage(event: AdminEvent): string {\r\n  return `id: ${event.id}\\nevent: ${event.type}\\ndata: ${JSON.stringify(event)}\\n\\n`;\r\n}\r\n\r\nfunction generateEventId(): string {\r\n  return `${Date.now()}-${Math.random().toString(36).slice(2, 11)}`;\r\n}\r\n\r\nasync function handleHealthCheck(): Promise<Response> {\r\n  const metrics = await fetchRealtimeMetrics();\r\n  return new Response(JSON.stringify({\r\n    success: true,\r\n    status: 'healthy',\r\n    metrics,\r\n    timestamp: new Date().toISOString()\r\n  }), {\r\n    headers: { 'Content-Type': 'application/json' }\r\n  });\r\n}\r\n\r\nfunction handleTriggerTestEvent(): Response {\r\n  return new Response(JSON.stringify({\r\n    success: true,\r\n    message: 'Test event triggered',\r\n    timestamp: new Date().toISOString()\r\n  }), {\r\n    headers: { 'Content-Type': 'application/json' }\r\n  });\r\n}\r\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\lib\\api\\admin\\realtime-events\\types.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\lib\\api\\admin\\scraping-metrics\\handlers.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\lib\\api\\admin\\scraping-metrics\\types.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\lib\\api\\analytics\\web-vitals\\handlers.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\lib\\api\\analytics\\web-vitals\\types.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\lib\\api\\cron\\auto-scrape\\handlers.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 72,
        "column": 51,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 72,
        "endColumn": 60,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [2364, 2373], "text": "(e.details != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [2364, 2373], "text": "(e.details ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [2364, 2373], "text": "(Boolean(e.details))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { NextRequest, NextResponse } from 'next/server';\r\nimport { autoScraper } from '@/lib/autoScraper';\r\nimport { scheduler } from '@/lib/scheduler';\r\nimport { logActivity } from '@/lib/activityLogger';\r\nimport { AutoScrapeResult } from './types';\r\n\r\nfunction verifyCronSecret(request: NextRequest): NextResponse | null {\r\n  const authHeader = request.headers.get('authorization');\r\n  const cronSecret = process.env.CRON_SECRET;\r\n\r\n  if (cronSecret === undefined || cronSecret === '') {\r\n    console.error('CRON_SECRET not configured');\r\n    return NextResponse.json({ error: 'Server configuration error' }, { status: 500 });\r\n  }\r\n\r\n  if (authHeader !== `Bearer ${cronSecret}`) {\r\n    console.error('Unauthorized cron attempt:', authHeader);\r\n    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });\r\n  }\r\n  return undefined;\r\n}\r\n\r\nfunction logAutoScrapeStart() {\r\n  console.info('Starting automated scraping job...');\r\n  logActivity({\r\n    type: 'cron_job',\r\n    action: 'auto_scrape_started',\r\n    details: { timestamp: new Date().toISOString() },\r\n  });\r\n}\r\n\r\nfunction logAutoScrapeCompletion(result: AutoScrapeResult) {\r\n  logActivity({\r\n    type: 'cron_job',\r\n    action: 'auto_scrape_completed',\r\n    details: {\r\n      timestamp: new Date().toISOString(),\r\n      trucksProcessed: result.trucksProcessed,\r\n      newTrucksFound: result.newTrucksFound,\r\n      errorsCount: result.errors?.length ?? 0,\r\n    },\r\n  });\r\n  console.info('Automated scraping job completed successfully');\r\n}\r\n\r\nfunction logAutoScrapeFailure(error: unknown) {\r\n  console.error('Auto-scraping cron job failed:', error);\r\n  logActivity({\r\n    type: 'cron_job',\r\n    action: 'auto_scrape_failed',\r\n    details: {\r\n      timestamp: new Date().toISOString(),\r\n      error: error instanceof Error ? error.message : 'Unknown error',\r\n    },\r\n  });\r\n}\r\n\r\nexport async function handlePostRequest(request: NextRequest) {\r\n  try {\r\n    const authResponse = verifyCronSecret(request);\r\n    if (authResponse) {\r\n      return authResponse;\r\n    }\r\n\r\n    logAutoScrapeStart();\r\n\r\n    const rawResult = await autoScraper.runAutoScraping();\r\n    // Map errors to string[] for compatibility\r\n    const result: AutoScrapeResult = {\r\n      trucksProcessed: rawResult.trucksProcessed,\r\n      newTrucksFound: rawResult.newTrucksFound,\r\n      errors: rawResult.errors?.map(e => e.url + (e.details ? `: ${e.details}` : '')),\r\n    };\r\n    scheduler.scheduleFollowUpTasks(result);\r\n    logAutoScrapeCompletion(result);\r\n\r\n    return NextResponse.json({\r\n      success: true,\r\n      message: 'Auto-scraping completed successfully',\r\n      data: {\r\n        trucksProcessed: result.trucksProcessed,\r\n        newTrucksFound: result.newTrucksFound,\r\n        timestamp: new Date().toISOString(),\r\n      },\r\n    });\r\n  } catch (error) {\r\n    logAutoScrapeFailure(error);\r\n    return NextResponse.json(\r\n      {\r\n        success: false,\r\n        error: 'Auto-scraping failed',\r\n        message: error instanceof Error ? error.message : 'Unknown error',\r\n      },\r\n      { status: 500 },\r\n    );\r\n  }\r\n}\r\n\r\nexport function handleGetRequest() {\r\n  return NextResponse.json(\r\n    { error: 'Method not allowed. Use POST for cron jobs.' },\r\n    { status: 405 },\r\n  );\r\n}\r\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\lib\\api\\cron\\auto-scrape\\types.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\lib\\api\\firecrawl\\handlers.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\lib\\api\\firecrawl\\types.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\lib\\api\\monitoring\\api-usage\\handlers.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\lib\\api\\pipeline\\handlers.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\lib\\api\\pipeline\\types.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\lib\\api\\scheduler\\data.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\lib\\api\\scheduler\\handlers.ts",
    "messages": [],
    "suppressedMessages": [
      {
        "ruleId": "sonarjs/pseudo-random",
        "severity": 2,
        "message": "Make sure that using this pseudorandom number generator is safe here.",
        "line": 103,
        "column": 7,
        "nodeType": "CallExpression",
        "messageId": "safeGenerator",
        "endLine": 103,
        "endColumn": 20,
        "suppressions": [
          {
            "kind": "directive",
            "justification": "Math.random is acceptable for simulating task execution."
          }
        ]
      }
    ],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\lib\\api\\scheduler\\types.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\lib\\api\\search\\data.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\lib\\api\\search\\filters.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\lib\\api\\search\\helpers.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\lib\\api\\tavily\\handlers.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\lib\\api\\tavily\\types.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\lib\\api\\test-integration\\helpers.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\lib\\api\\test-integration\\pipelineRunner.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\lib\\api\\test-integration\\pipelineRunnerHelpers.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\lib\\api\\test-integration\\schemaMapper.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected object value in conditional. The condition is always true.",
        "line": 13,
        "column": 8,
        "nodeType": "Identifier",
        "messageId": "conditionErrorObject",
        "endLine": 13,
        "endColumn": 21
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import {\r\n  ExtractedFoodTruckDetails,\r\n  FoodTruckSchema,\r\n  MenuCategory,\r\n  MenuItem,\r\n} from '@/lib/types';\r\n\r\nexport function mapExtractedDataToTruckSchema(\r\n  extractedData: ExtractedFoodTruckDetails,\r\n  sourceUrl: string,\r\n  isDryRun: boolean,\r\n): FoodTruckSchema {\r\n  if (!extractedData || typeof extractedData !== 'object') {\r\n    throw new Error('Invalid extractedData for mapping.');\r\n  }\r\n\r\n  const name = extractedData.name ?? 'Unknown Test Truck';\r\n  const locationData = extractedData.current_location ?? {};\r\n  const fullAddress = [\r\n    locationData.address,\r\n    locationData.city,\r\n    locationData.state,\r\n    locationData.zip_code,\r\n  ]\r\n    .filter(Boolean)\r\n    .join(', ');\r\n\r\n  return {\r\n    name: name,\r\n    description: extractedData.description ?? undefined,\r\n    current_location: {\r\n      lat: locationData.lat ?? 0,\r\n      lng: locationData.lng ?? 0,\r\n      address: fullAddress ?? (locationData.raw_text ?? undefined),\r\n      timestamp: new Date().toISOString(),\r\n    },\r\n    scheduled_locations: extractedData.scheduled_locations ?? undefined,\r\n    operating_hours: extractedData.operating_hours ?? undefined,\r\n    menu: (extractedData.menu ?? []).map((category: MenuCategory) => ({\r\n      name: category.name ?? 'Uncategorized',\r\n      items: (category.items ?? []).map((item: MenuItem) => ({\r\n        name: item.name ?? 'Unknown Item',\r\n        description: item.description ?? undefined,\r\n        price:\r\n          typeof item.price === 'number' || typeof item.price === 'string'\r\n            ? item.price\r\n            : undefined,\r\n        dietary_tags: item.dietary_tags ?? [],\r\n      })),\r\n    })),\r\n    contact_info: extractedData.contact_info ?? undefined,\r\n    social_media: extractedData.social_media ?? undefined,\r\n    cuisine_type: extractedData.cuisine_type ?? [],\r\n    price_range: extractedData.price_range ?? undefined,\r\n    specialties: extractedData.specialties ?? [],\r\n    data_quality_score: isDryRun ? 0.5 : 0.6, // Differentiate test/dry run\r\n    verification_status: 'pending',\r\n    source_urls: [sourceUrl].filter(Boolean),\r\n    last_scraped_at: new Date().toISOString(),\r\n    ...(isDryRun && { test_run_flag: true }), // Add a flag for actual test saves if needed\r\n  };\r\n}\r\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\lib\\api\\test-integration\\stageHandlers.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\lib\\api\\trucks\\handlers.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\lib\\auth\\authHelpers.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\lib\\autoScraper.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\lib\\config.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\lib\\data-quality\\batchCleanup.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected object value in conditional. The condition is always true.",
        "line": 151,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "conditionErrorObject",
        "endLine": 151,
        "endColumn": 17
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected object value in conditional. The condition is always true.",
        "line": 207,
        "column": 9,
        "nodeType": "Identifier",
        "messageId": "conditionErrorObject",
        "endLine": 207,
        "endColumn": 16
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected object value in conditional. The condition is always true.",
        "line": 325,
        "column": 10,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorObject",
        "endLine": 325,
        "endColumn": 32
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected object value in conditional. The condition is always true.",
        "line": 380,
        "column": 9,
        "nodeType": "Identifier",
        "messageId": "conditionErrorObject",
        "endLine": 380,
        "endColumn": 26
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 4,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\r\n * SOTA Batch Data Cleanup System\r\n * Implements automated data quality improvements and cleanup operations\r\n */\r\n\r\nimport { FoodTruckService, type FoodTruck, DataQualityService } from '@/lib/supabase';\r\nimport { DuplicatePreventionService } from './duplicatePrevention';\r\nimport { getPlaceholderPatterns, processTruckForPlaceholders } from './placeholderUtils';\r\n\r\nexport interface CleanupOperation {\r\n  type: 'normalize_phone' | 'fix_coordinates' | 'remove_placeholders' | 'update_quality_scores' | 'merge_duplicates';\r\n  description: string;\r\n  affectedCount: number;\r\n  successCount: number;\r\n  errorCount: number;\r\n  errors: string[];\r\n}\r\n\r\nexport interface BatchCleanupResult {\r\n  totalProcessed: number;\r\n  operations: CleanupOperation[];\r\n  summary: {\r\n    trucksImproved: number;\r\n    duplicatesRemoved: number;\r\n    qualityScoreImprovement: number;\r\n    placeholdersRemoved: number;\r\n  };\r\n  duration: number;\r\n}\r\n\r\ninterface MergeOperationContext {\r\n  operation: CleanupOperation;\r\n  processedIds: Set<string>;\r\n}\r\n\r\ninterface CoordinateProcessContext {\r\n  defaultLat: number;\r\n  defaultLng: number;\r\n  dryRun: boolean;\r\n  operation: CleanupOperation;\r\n}\r\n\r\n/**\r\n * Automated Data Quality Cleanup Service\r\n */\r\nexport class BatchCleanupService {\r\n  \r\n  /**\r\n   * Run comprehensive data cleanup operations\r\n   */\r\n  static async runFullCleanup(options: {\r\n    batchSize?: number;\r\n    dryRun?: boolean;\r\n    operations?: CleanupOperation['type'][];\r\n  } = {}): Promise<BatchCleanupResult> {\r\n    const startTime = Date.now();\r\n    const { batchSize = 50, dryRun = false, operations = [\r\n      'remove_placeholders',\r\n      'normalize_phone',\r\n      'fix_coordinates',\r\n      'update_quality_scores',\r\n      'merge_duplicates'\r\n    ] } = options;\r\n\r\n    console.info(`Starting batch cleanup (${dryRun ? 'DRY RUN' : 'LIVE'})...`);\r\n    const result = this.initializeCleanupResult();\r\n    try {\r\n      const allTrucks = await FoodTruckService.getAllTrucks();\r\n      result.totalProcessed = allTrucks.total;\r\n      await this.processTrucksInBatches(allTrucks.trucks, {\r\n        batchSize,\r\n        operations,\r\n        dryRun,\r\n        result\r\n      });\r\n      return this.finalizeCleanupResult(result, startTime);\r\n    } catch (error) {\r\n      console.error('Batch cleanup failed:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n\r\n  private static initializeCleanupResult(): BatchCleanupResult {\r\n    return {\r\n      totalProcessed: 0,\r\n      operations: [],\r\n      summary: {\r\n        trucksImproved: 0,\r\n        duplicatesRemoved: 0,\r\n        qualityScoreImprovement: 0,\r\n        placeholdersRemoved: 0\r\n      },\r\n      duration: 0\r\n    };\r\n  }\r\n\r\n  private static finalizeCleanupResult(result: BatchCleanupResult, startTime: number): BatchCleanupResult {\r\n    result.summary = this.calculateSummary(result.operations);\r\n    result.duration = Date.now() - startTime;\r\n\r\n    console.info(`Batch cleanup completed in ${result.duration}ms`);\r\n    return result;\r\n  }\r\n\r\n  private static async processTrucksInBatches(\r\n    trucks: FoodTruck[],\r\n    { batchSize, operations, dryRun, result }: {\r\n      batchSize: number;\r\n      operations: CleanupOperation['type'][];\r\n      dryRun: boolean;\r\n      result: BatchCleanupResult;\r\n    }\r\n  ): Promise<void> {\r\n    for (let i = 0; i < trucks.length; i += batchSize) {\r\n      const batch = trucks.slice(i, i + batchSize);\r\n      for (const op of operations) {\r\n        const opResult = await this.runOperation(op, batch, dryRun);\r\n        result.operations.push(opResult);\r\n      }\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Run a specific cleanup operation\r\n   */\r\n  private static async runOperation(\r\n    type: CleanupOperation['type'],\r\n    trucks: FoodTruck[],\r\n    dryRun: boolean\r\n  ): Promise<CleanupOperation> {\r\n    const operation: CleanupOperation = {\r\n      type,\r\n      description: this.getOperationDescription(type),\r\n      affectedCount: 0,\r\n      successCount: 0,\r\n      errorCount: 0,\r\n      errors: []\r\n    };\r\n    \r\n    const operationRunners = {\r\n      remove_placeholders: this.runRemovePlaceholders,\r\n      normalize_phone: this.runNormalizePhoneNumbers,\r\n      fix_coordinates: this.runFixCoordinates,\r\n      update_quality_scores: this.runUpdateQualityScores,\r\n      merge_duplicates: this.runMergeDuplicates,\r\n    };\r\n\r\n    try {\r\n      const runner = operationRunners[type];\r\n      if (runner) {\r\n        return await runner.call(this, trucks, dryRun, operation);\r\n      } else {\r\n        operation.errors.push(`Unknown operation type: ${String(type)}`);\r\n        return operation;\r\n      }\r\n    } catch (error) {\r\n      operation.errors.push(`Operation failed: ${error instanceof Error ? error.message : String(error)}`);\r\n      return operation;\r\n    }\r\n  }\r\n\r\n  private static runRemovePlaceholders = async (trucks: FoodTruck[], dryRun: boolean, operation: CleanupOperation): Promise<CleanupOperation> => {\r\n    return await this.removePlaceholders(trucks, dryRun, operation);\r\n  }\r\n\r\n  private static runNormalizePhoneNumbers = async (trucks: FoodTruck[], dryRun: boolean, operation: CleanupOperation): Promise<CleanupOperation> => {\r\n    return await this.normalizePhoneNumbers(trucks, dryRun, operation);\r\n  }\r\n\r\n  private static runFixCoordinates = async (trucks: FoodTruck[], dryRun: boolean, operation: CleanupOperation): Promise<CleanupOperation> => {\r\n    return await this.fixCoordinates(trucks, dryRun, operation);\r\n  }\r\n\r\n  private static runUpdateQualityScores = async (trucks: FoodTruck[], dryRun: boolean, operation: CleanupOperation): Promise<CleanupOperation> => {\r\n    return await this.updateQualityScores(trucks, dryRun, operation);\r\n  }\r\n\r\n  private static runMergeDuplicates = async (trucks: FoodTruck[], dryRun: boolean, operation: CleanupOperation): Promise<CleanupOperation> => {\r\n    return await this.mergeDuplicates(trucks, dryRun, operation);\r\n  }\r\n  \r\n\r\n  /**\r\n   * Remove placeholder and mock data\r\n   */\r\n  private static async removePlaceholders(\r\n    trucks: FoodTruck[],\r\n    dryRun: boolean,\r\n    operation: CleanupOperation\r\n  ): Promise<CleanupOperation> {\r\n    const placeholderPatterns = getPlaceholderPatterns();\r\n    const promises = trucks.map(truck => \r\n      this.processSingleTruckForPlaceholders(truck, placeholderPatterns, dryRun, operation)\r\n    );\r\n    await Promise.all(promises);\r\n    return operation;\r\n  }\r\n\r\n  private static async processSingleTruckForPlaceholders(\r\n    truck: FoodTruck,\r\n    patterns: RegExp[],\r\n    dryRun: boolean,\r\n    operation: CleanupOperation\r\n  ): Promise<void> {\r\n    const updates = processTruckForPlaceholders(truck, patterns);\r\n    if (updates && Object.keys(updates).length > 0) {\r\n      await this.performUpdateOperation(truck.id, updates, dryRun, operation);\r\n    }\r\n  }\r\n\r\n  private static async performUpdateOperation(\r\n    truckId: string,\r\n    updates: Partial<FoodTruck>,\r\n    dryRun: boolean,\r\n    operation: CleanupOperation\r\n  ): Promise<void> {\r\n    operation.affectedCount++;\r\n    if (dryRun) {\r\n      operation.successCount++;\r\n    } else {\r\n      try {\r\n        await FoodTruckService.updateTruck(truckId, updates);\r\n        operation.successCount++;\r\n      } catch (error) {\r\n        operation.errorCount++;\r\n        operation.errors.push(`Failed to update truck ${truckId}: ${error instanceof Error ? error.message : String(error)}`);\r\n      }\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Normalize phone numbers to consistent format\r\n   */\r\n  private static async normalizePhoneNumbers(\r\n    trucks: FoodTruck[],\r\n    dryRun: boolean,\r\n    operation: CleanupOperation\r\n  ): Promise<CleanupOperation> {\r\n    const promises = trucks.map(truck => {\r\n      if (truck.contact_info?.phone !== undefined) {\r\n        const originalPhone = truck.contact_info.phone;\r\n        const normalizedPhone = this.normalizePhone(originalPhone);\r\n\r\n        if (normalizedPhone !== undefined && normalizedPhone !== originalPhone) {\r\n          return this.applyPhoneNormalizationUpdate(truck, normalizedPhone, dryRun, operation);\r\n        }\r\n      }\r\n      return Promise.resolve();\r\n    });\r\n    await Promise.all(promises);\r\n    return operation;\r\n  }\r\n\r\n  private static async applyPhoneNormalizationUpdate(\r\n    truck: FoodTruck,\r\n    normalizedPhone: string,\r\n    dryRun: boolean,\r\n    operation: CleanupOperation\r\n  ): Promise<void> {\r\n    operation.affectedCount++;\r\n    if (dryRun) {\r\n      operation.successCount++;\r\n    } else {\r\n      try {\r\n        await FoodTruckService.updateTruck(truck.id, {\r\n          contact_info: {\r\n            ...truck.contact_info,\r\n            phone: normalizedPhone\r\n          }\r\n        });\r\n        operation.successCount++;\r\n      } catch (error) {\r\n        operation.errorCount++;\r\n        operation.errors.push(`Failed to normalize phone for truck ${truck.id}: ${error instanceof Error ? error.message : String(error)}`);\r\n      }\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Helper to determine if coordinates need fixing and provide updates\r\n   */\r\n  private static getFixedCoordinates(\r\n    lat: number | undefined,\r\n    lng: number | undefined,\r\n    defaultLat: number,\r\n    defaultLng: number\r\n  ): Partial<FoodTruck['current_location']> | undefined {\r\n    // Fix invalid coordinates (0,0 or undefined)\r\n    if (lat === undefined || lng === undefined || lat === 0 || lng === 0) {\r\n      return { lat: defaultLat, lng: defaultLng };\r\n    }\r\n    // Fix coordinates outside reasonable bounds for Charleston area\r\n    if (lat < 32 || lat > 34 || lng > -79 || lng < -81) {\r\n      return { lat: defaultLat, lng: defaultLng };\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * Fix invalid GPS coordinates\r\n   */\r\n  private static async fixCoordinates(\r\n    trucks: FoodTruck[],\r\n    dryRun: boolean,\r\n    operation: CleanupOperation\r\n  ): Promise<CleanupOperation> {\r\n    const context: Omit<CoordinateProcessContext, 'operation'> = {\r\n      defaultLat: 32.7767,\r\n      defaultLng: -79.9311,\r\n      dryRun,\r\n    };\r\n\r\n    const promises = trucks.map(truck => \r\n      this.processSingleTruckCoordinates(truck, { ...context, operation })\r\n    );\r\n    await Promise.all(promises);\r\n    return operation;\r\n  }\r\n\r\n  private static async processSingleTruckCoordinates(\r\n    truck: FoodTruck,\r\n    context: CoordinateProcessContext\r\n  ): Promise<void> {\r\n    if (!truck.current_location) return;\r\n    const { defaultLat, defaultLng, dryRun, operation } = context;\r\n    const { lat, lng } = truck.current_location;\r\n    const updates = this.getFixedCoordinates(lat, lng, defaultLat, defaultLng);\r\n    if (updates) {\r\n      await this.applyCoordinateFixUpdate(truck, updates, dryRun, operation);\r\n    }\r\n  }\r\n\r\n  private static async applyCoordinateFixUpdate(\r\n    truck: FoodTruck,\r\n    updates: Partial<FoodTruck['current_location']>,\r\n    dryRun: boolean,\r\n    operation: CleanupOperation\r\n  ): Promise<void> {\r\n    operation.affectedCount++;\r\n    if (dryRun) {\r\n      operation.successCount++;\r\n    } else {\r\n      try {\r\n        await FoodTruckService.updateTruck(truck.id, {\r\n          current_location: {\r\n            ...truck.current_location,\r\n            ...updates,\r\n          }\r\n        });\r\n        operation.successCount++;\r\n      } catch (error) {\r\n        operation.errorCount++;\r\n        operation.errors.push(`Failed to fix coordinates for truck ${truck.id}: ${error instanceof Error ? error.message : String(error)}`);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update quality scores for all trucks\r\n   */\r\n  private static async updateQualityScores(\r\n    trucks: FoodTruck[],\r\n    dryRun: boolean,\r\n    operation: CleanupOperation\r\n  ): Promise<CleanupOperation> {\r\n    const promises = trucks.map(truck => \r\n      this.processSingleTruckForQualityScore(truck, dryRun, operation)\r\n    );\r\n    await Promise.all(promises);\r\n    return operation;\r\n  }\r\n\r\n  private static async processSingleTruckForQualityScore(\r\n    truck: FoodTruck,\r\n    dryRun: boolean,\r\n    operation: CleanupOperation\r\n  ): Promise<void> {\r\n    const qualityAssessment = DataQualityService.calculateQualityScore(truck);\r\n    if (qualityAssessment) {\r\n      const newScore = qualityAssessment.score;\r\n      const currentScore = truck.data_quality_score ?? 0;\r\n      // Only update if score changed significantly (>5% difference)\r\n      if (typeof newScore === 'number' && Math.abs(newScore - currentScore) > 0.05) {\r\n        await this.applyQualityScoreUpdate(truck, dryRun, operation);\r\n      }\r\n    }\r\n  }\r\n\r\n  private static async applyQualityScoreUpdate(\r\n    truck: FoodTruck,\r\n    dryRun: boolean,\r\n    operation: CleanupOperation\r\n  ): Promise<void> {\r\n    operation.affectedCount++;\r\n    if (dryRun) {\r\n      operation.successCount++;\r\n    } else {\r\n      try {\r\n        const updateResult = await DataQualityService.updateTruckQualityScore(truck.id);\r\n        if ('error' in updateResult) {\r\n          throw new Error(updateResult.error);\r\n        }\r\n        operation.successCount++;\r\n      } catch (error) {\r\n        operation.errorCount++;\r\n        operation.errors.push(`Failed to update quality score for truck ${truck.id}: ${error instanceof Error ? error.message : String(error)}`);\r\n      }\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Identify and merge duplicate trucks\r\n   */\r\n  private static async mergeDuplicates(\r\n    trucks: FoodTruck[],\r\n    dryRun: boolean,\r\n    operation: CleanupOperation\r\n  ): Promise<CleanupOperation> {\r\n    const processedIds = new Set<string>();\r\n    for (const truck of trucks) {\r\n      await this.processSingleTruckForDuplicates(truck, dryRun, { operation, processedIds });\r\n    }\r\n    return operation;\r\n  }\r\n\r\n  private static async processSingleTruckForDuplicates(\r\n    truck: FoodTruck,\r\n    dryRun: boolean,\r\n    context: MergeOperationContext\r\n  ): Promise<void> {\r\n    const { processedIds } = context;\r\n    if (processedIds.has(truck.id)) return;\r\n\r\n    const duplicateCheck = await DuplicatePreventionService.checkForDuplicates(truck);\r\n    if (duplicateCheck.isDuplicate && duplicateCheck.bestMatch?.confidence === 'high' && duplicateCheck.bestMatch.recommendation === 'merge') {\r\n      await this.applyMergeOperation(truck, duplicateCheck.bestMatch.existingTruck, dryRun, context);\r\n    }\r\n    processedIds.add(truck.id);\r\n  }\r\n\r\n  private static async applyMergeOperation(\r\n    truck: FoodTruck,\r\n    existingTruck: FoodTruck,\r\n    dryRun: boolean,\r\n    context: MergeOperationContext\r\n  ): Promise<void> {\r\n    const { operation, processedIds } = context;\r\n    operation.affectedCount++;\r\n    if (dryRun) {\r\n      operation.successCount++;\r\n    } else {\r\n      try {\r\n        const mergeResult = await DuplicatePreventionService.mergeDuplicates(truck.id, existingTruck.id);\r\n        if ('error' in mergeResult) {\r\n          throw new Error(mergeResult.error);\r\n        }\r\n        processedIds.add(existingTruck.id);\r\n        operation.successCount++;\r\n      } catch (error) {\r\n        operation.errorCount++;\r\n        operation.errors.push(`Failed to merge duplicates ${truck.id} and ${existingTruck.id}: ${error instanceof Error ? error.message : String(error)}`);\r\n      }\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Normalize phone number format\r\n   */\r\n  private static normalizePhone(phone: string): string | undefined {\r\n    if (!phone) return undefined;\r\n    \r\n    // Remove all non-digit characters\r\n    const digits = phone.replaceAll(/\\D/g, '');\r\n    \r\n    // Handle US phone numbers\r\n    if (digits.length === 10) {\r\n      return `(${digits.slice(0, 3)}) ${digits.slice(3, 6)}-${digits.slice(6)}`;\r\n    }\r\n    if (digits.length === 11 && digits.startsWith('1')) {\r\n      return `+1 (${digits.slice(1, 4)}) ${digits.slice(4, 7)}-${digits.slice(7)}`;\r\n    }\r\n    \r\n    // Return original if can't normalize\r\n    return phone;\r\n  }\r\n  \r\n  /**\r\n   * Get operation description\r\n   */\r\n  private static getOperationDescription(type: CleanupOperation['type']): string {\r\n    const descriptions = {\r\n      remove_placeholders: 'Remove placeholder and mock data values',\r\n      normalize_phone: 'Normalize phone numbers to consistent format',\r\n      fix_coordinates: 'Fix invalid GPS coordinates',\r\n      update_quality_scores: 'Recalculate data quality scores',\r\n      merge_duplicates: 'Identify and merge duplicate truck entries'\r\n    };\r\n    \r\n    return descriptions[type] ?? 'Unknown operation';\r\n  }\r\n  \r\n  /**\r\n   * Calculate cleanup summary\r\n   */\r\n  private static calculateSummary(operations: CleanupOperation[]): BatchCleanupResult['summary'] {\r\n    return {\r\n      trucksImproved: operations.reduce((sum, op) => sum + op.successCount, 0),\r\n      duplicatesRemoved: operations.find(op => op.type === 'merge_duplicates')?.successCount ?? 0,\r\n      qualityScoreImprovement: operations.find(op => op.type === 'update_quality_scores')?.successCount ?? 0,\r\n      placeholdersRemoved: operations.find(op => op.type === 'remove_placeholders')?.successCount ?? 0\r\n    };\r\n  }\r\n}\r\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\lib\\data-quality\\duplicatePrevention.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 232,
        "column": 9,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 232,
        "endColumn": 21,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [7434, 7446], "text": "(loc1.address != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [7434, 7446], "text": "(loc1.address ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [7434, 7446], "text": "(Boolean(loc1.address))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 232,
        "column": 25,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 232,
        "endColumn": 37,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [7450, 7462], "text": "(loc2.address != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [7450, 7462], "text": "(loc2.address ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [7450, 7462], "text": "(Boolean(loc2.address))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 2,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\r\n * SOTA Duplicate Prevention System\r\n * Implements intelligent duplicate detection and prevention for food truck data\r\n */\r\n\r\nimport { FoodTruckService, type FoodTruck } from '@/lib/supabase';\r\n\r\n// Duplicate detection configuration\r\nexport const DUPLICATE_DETECTION_CONFIG = {\r\n  // Similarity thresholds (0.0 = no match, 1.0 = exact match)\r\n  thresholds: {\r\n    name: 0.85,        // High threshold for name matching\r\n    location: 0.9,     // Very high threshold for location matching\r\n    phone: 1,        // Exact match for phone numbers\r\n    website: 1,      // Exact match for websites\r\n    overall: 0.8       // Overall similarity threshold\r\n  },\r\n  \r\n  // Weight factors for different fields\r\n  weights: {\r\n    name: 0.4,         // 40% weight for name similarity\r\n    location: 0.3,     // 30% weight for location similarity\r\n    contact: 0.2,      // 20% weight for contact info similarity\r\n    menu: 0.1          // 10% weight for menu similarity\r\n  }\r\n} as const;\r\n\r\nexport interface DuplicateMatch {\r\n  existingTruck: FoodTruck;\r\n  similarity: number;\r\n  matchedFields: string[];\r\n  confidence: 'high' | 'medium' | 'low';\r\n  recommendation: 'merge' | 'update' | 'skip' | 'manual_review';\r\n}\r\n\r\nexport interface DuplicateDetectionResult {\r\n  isDuplicate: boolean;\r\n  matches: DuplicateMatch[];\r\n  bestMatch?: DuplicateMatch;\r\n  action: 'create' | 'update' | 'merge' | 'manual_review';\r\n  reason: string;\r\n}\r\n\r\n/**\r\n * Advanced Duplicate Prevention Service\r\n */\r\nexport class DuplicatePreventionService {\r\n  \r\n  /**\r\n   * Check if a food truck is a duplicate of existing trucks\r\n   */\r\n  static async checkForDuplicates(candidateTruck: Partial<FoodTruck>): Promise<DuplicateDetectionResult> {\r\n    try {\r\n      // Get all existing trucks for comparison\r\n      const existingTrucksResult = await FoodTruckService.getAllTrucks();\r\n\r\n      if ('error' in existingTrucksResult) {\r\n        console.error('Error fetching existing trucks:', existingTrucksResult.error);\r\n        return {\r\n          isDuplicate: false,\r\n          matches: [],\r\n          action: 'create',\r\n          reason: `Error fetching existing trucks: ${existingTrucksResult.error}`\r\n        };\r\n      }\r\n\r\n      const existingTrucks = existingTrucksResult.trucks;\r\n      const matches: DuplicateMatch[] = [];\r\n\r\n      for (const existingTruck of existingTrucks) {\r\n        const similarity = this.calculateSimilarity(candidateTruck, existingTruck);\r\n\r\n        if (similarity.overall >= DUPLICATE_DETECTION_CONFIG.thresholds.overall) {\r\n          matches.push({\r\n            existingTruck,\r\n            similarity: similarity.overall,\r\n            matchedFields: similarity.matchedFields,\r\n            confidence: this.getConfidenceLevel(similarity.overall),\r\n            recommendation: this.getRecommendation(similarity)\r\n          });\r\n        }\r\n      }\r\n\r\n      return this.processDuplicateMatches(matches, candidateTruck);\r\n\r\n    } catch (error) {\r\n      console.error('Error checking for duplicates:', error);\r\n      return {\r\n        isDuplicate: false,\r\n        matches: [],\r\n        action: 'create',\r\n        reason: 'An unexpected error occurred during duplicate detection - proceeding with creation'\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Processes the matches found during duplicate detection and returns the result.\r\n   */\r\n  private static processDuplicateMatches(matches: DuplicateMatch[], candidateTruck: Partial<FoodTruck>): DuplicateDetectionResult {\r\n    // Sort matches by similarity (highest first)\r\n    matches.sort((a, b) => b.similarity - a.similarity);\r\n\r\n    const bestMatch = matches.length > 0 ? matches[0] : undefined;\r\n    const isDuplicate = matches.length > 0;\r\n\r\n    return {\r\n      isDuplicate,\r\n      matches,\r\n      bestMatch,\r\n      action: this.determineAction(matches, candidateTruck),\r\n      reason: this.generateReason(matches, candidateTruck)\r\n    };\r\n  }\r\n  \r\n  /**\r\n   * Calculate similarity between two food trucks\r\n   */\r\n  private static calculateSimilarity(\r\n    candidate: Partial<FoodTruck>, \r\n    existing: FoodTruck\r\n  ): { overall: number; matchedFields: string[]; breakdown: Record<string, number> } {\r\n    const breakdown: Record<string, number> = {};\r\n    const matchedFields: string[] = [];\r\n    \r\n    // Name similarity\r\n    const nameSimilarity = this.calculateStringSimilarity(\r\n      candidate.name ?? '', \r\n      existing.name ?? ''\r\n    );\r\n    breakdown.name = nameSimilarity;\r\n    if (nameSimilarity >= DUPLICATE_DETECTION_CONFIG.thresholds.name) {\r\n      matchedFields.push('name');\r\n    }\r\n    \r\n    // Location similarity\r\n    const locationSimilarity = this.calculateLocationSimilarity(\r\n      candidate.current_location,\r\n      existing.current_location\r\n    );\r\n    breakdown.location = locationSimilarity;\r\n    if (locationSimilarity >= DUPLICATE_DETECTION_CONFIG.thresholds.location) {\r\n      matchedFields.push('location');\r\n    }\r\n    \r\n    // Contact similarity\r\n    const contactSimilarity = this.calculateContactSimilarity(\r\n      candidate.contact_info,\r\n      existing.contact_info\r\n    );\r\n    breakdown.contact = contactSimilarity;\r\n    if (contactSimilarity >= DUPLICATE_DETECTION_CONFIG.thresholds.phone) {\r\n      matchedFields.push('contact');\r\n    }\r\n    \r\n    // Menu similarity (basic)\r\n    const menuSimilarity = this.calculateMenuSimilarity(\r\n      candidate.menu,\r\n      existing.menu\r\n    );\r\n    breakdown.menu = menuSimilarity;\r\n    if (menuSimilarity > 0.7) {\r\n      matchedFields.push('menu');\r\n    }\r\n    \r\n    // Calculate weighted overall similarity\r\n    const overall = (\r\n      nameSimilarity * DUPLICATE_DETECTION_CONFIG.weights.name +\r\n      locationSimilarity * DUPLICATE_DETECTION_CONFIG.weights.location +\r\n      contactSimilarity * DUPLICATE_DETECTION_CONFIG.weights.contact +\r\n      menuSimilarity * DUPLICATE_DETECTION_CONFIG.weights.menu\r\n    );\r\n    \r\n    return { overall, matchedFields, breakdown };\r\n  }\r\n  \r\n  /**\r\n   * Calculate string similarity using Levenshtein distance\r\n   */\r\n  private static calculateStringSimilarity(str1: string, str2: string): number {\r\n    if (!str1 || !str2) return 0;\r\n    \r\n    // Normalize strings\r\n    const s1 = str1.toLowerCase().trim();\r\n    const s2 = str2.toLowerCase().trim();\r\n    \r\n    if (s1 === s2) return 1;\r\n    \r\n    // Calculate Levenshtein distance\r\n    const matrix: number[][] = [];\r\n    const len1 = s1.length;\r\n    const len2 = s2.length;\r\n    \r\n    for (let i = 0; i <= len1; i++) {\r\n      matrix[i] = [i];\r\n    }\r\n    \r\n    for (let j = 0; j <= len2; j++) {\r\n      matrix[0][j] = j;\r\n    }\r\n    \r\n    for (let i = 1; i <= len1; i++) {\r\n      for (let j = 1; j <= len2; j++) {\r\n        const cost = s1[i - 1] === s2[j - 1] ? 0 : 1;\r\n        matrix[i][j] = Math.min(\r\n          matrix[i - 1][j] + 1,      // deletion\r\n          matrix[i][j - 1] + 1,      // insertion\r\n          matrix[i - 1][j - 1] + cost // substitution\r\n        );\r\n      }\r\n    }\r\n    \r\n    const distance = matrix[len1][len2];\r\n    const maxLength = Math.max(len1, len2);\r\n    \r\n    return maxLength === 0 ? 1 : 1 - (distance / maxLength);\r\n  }\r\n  \r\n  /**\r\n   * Calculate location similarity\r\n   */\r\n  private static calculateLocationSimilarity(\r\n    loc1: FoodTruck['current_location'] | undefined | null,\r\n    loc2: FoodTruck['current_location'] | undefined | null\r\n  ): number {\r\n    if (!loc1 || !loc2) return 0;\r\n    \r\n    let similarity = 0;\r\n    let factors = 0;\r\n    \r\n    // Address similarity\r\n    if (loc1.address && loc2.address) {\r\n      similarity += this.calculateStringSimilarity(loc1.address, loc2.address);\r\n      factors++;\r\n    }\r\n    \r\n    // GPS coordinate similarity (within 100 meters = high similarity)\r\n    if (\r\n      loc1.lat &&\r\n      loc1.lng &&\r\n      loc2.lat &&\r\n      loc2.lng\r\n    ) {\r\n      const distance = this.calculateGPSDistance(\r\n        loc1.lat, loc1.lng,\r\n        loc2.lat, loc2.lng\r\n      );\r\n      \r\n      // Distance similarity (closer = higher similarity)\r\n      const distanceSimilarity = distance <= 0.1 ? 1 : Math.max(0, 1 - (distance / 1)); // 1km max\r\n      similarity += distanceSimilarity;\r\n      factors++;\r\n    }\r\n    \r\n    return factors > 0 ? similarity / factors : 0;\r\n  }\r\n  \r\n  /**\r\n   * Calculate GPS distance in kilometers\r\n   */\r\n  private static calculateGPSDistance(lat1: number, lng1: number, lat2: number, lng2: number): number {\r\n    const R = 6371; // Earth's radius in kilometers\r\n    const dLat = (lat2 - lat1) * Math.PI / 180;\r\n    const dLng = (lng2 - lng1) * Math.PI / 180;\r\n    const a = \r\n      Math.sin(dLat / 2) * Math.sin(dLat / 2) +\r\n      Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *\r\n      Math.sin(dLng / 2) * Math.sin(dLng / 2);\r\n    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\r\n    return R * c;\r\n  }\r\n  \r\n  /**\r\n   * Calculate contact similarity\r\n   */\r\n  private static calculateContactSimilarity(\r\n    contact1: FoodTruck['contact_info'] | undefined | null,\r\n    contact2: FoodTruck['contact_info'] | undefined | null\r\n  ): number {\r\n    if (!contact1 || !contact2) return 0;\r\n    \r\n    let matches = 0;\r\n    let total = 0;\r\n    \r\n    // Phone number exact match\r\n    if (contact1.phone != undefined && contact2.phone != undefined) {\r\n      const phone1 = contact1.phone.replaceAll(/\\D/g, ''); // Remove non-digits\r\n      const phone2 = contact2.phone.replaceAll(/\\D/g, '');\r\n      if (phone1 === phone2) matches++;\r\n      total++;\r\n    }\r\n    \r\n    // Website exact match\r\n    if (contact1.website != undefined && contact2.website != undefined) {\r\n      const url1 = contact1.website.toLowerCase().replace(/^https?:\\/\\//, '').replace(/\\/$/, '');\r\n      const url2 = contact2.website.toLowerCase().replace(/^https?:\\/\\//, '').replace(/\\/$/, '');\r\n      if (url1 === url2) matches++;\r\n      total++;\r\n    }\r\n    \r\n    // Email similarity\r\n    if (contact1.email != undefined && contact2.email != undefined) {\r\n      if (contact1.email.toLowerCase() === contact2.email.toLowerCase()) matches++;\r\n      total++;\r\n    }\r\n    \r\n    return total > 0 ? matches / total : 0;\r\n  }\r\n  \r\n  /**\r\n   * Calculate menu similarity (basic implementation)\r\n   */\r\n  private static calculateMenuSimilarity(\r\n    menu1: FoodTruck['menu'] | undefined | null,\r\n    menu2: FoodTruck['menu'] | undefined | null\r\n  ): number {\r\n    if (!menu1 || !menu2 || menu1.length === 0 || menu2.length === 0) return 0;\r\n    \r\n    // Simple category name matching\r\n    const categories1 = menu1.map(cat => (cat as { category?: string }).category?.toLowerCase() ?? '').filter(Boolean);\r\n    const categories2 = menu2.map(cat => (cat as { category?: string }).category?.toLowerCase() ?? '').filter(Boolean);\r\n    \r\n    const commonCategories = categories1.filter(cat => categories2.includes(cat));\r\n    const totalCategories = new Set([...categories1, ...categories2]).size;\r\n    \r\n    return totalCategories > 0 ? commonCategories.length / totalCategories : 0;\r\n  }\r\n  \r\n  /**\r\n   * Get confidence level based on similarity score\r\n   */\r\n  private static getConfidenceLevel(similarity: number): 'high' | 'medium' | 'low' {\r\n    if (similarity >= 0.95) return 'high';\r\n    if (similarity >= 0.85) return 'medium';\r\n    return 'low';\r\n  }\r\n  \r\n  /**\r\n   * Get recommendation based on similarity analysis\r\n   */\r\n  private static getRecommendation(similarity: { overall: number; matchedFields: string[] }): 'merge' | 'update' | 'skip' | 'manual_review' {\r\n    if (similarity.overall >= 0.95) return 'merge';\r\n    if (similarity.overall >= 0.9) return 'update';\r\n    if (similarity.overall >= 0.8) return 'manual_review';\r\n    return 'skip';\r\n  }\r\n  \r\n  /**\r\n   * Determine action based on matches\r\n   */\r\n  private static determineAction(matches: DuplicateMatch[], _candidate: Partial<FoodTruck>): 'create' | 'update' | 'merge' | 'manual_review' {\r\n    if (matches.length === 0) return 'create';\r\n    \r\n    const bestMatch = matches[0];\r\n    \r\n    if (bestMatch.confidence === 'high') {\r\n      const recommendation = bestMatch.recommendation;\r\n      if (recommendation === 'merge' || recommendation === 'update') {\r\n        return recommendation;\r\n      }\r\n      return 'manual_review';\r\n    }\r\n    \r\n    return 'manual_review';\r\n  }\r\n  \r\n  /**\r\n   * Generate human-readable reason\r\n   */\r\n  private static generateReason(matches: DuplicateMatch[], _candidate: Partial<FoodTruck>): string {\r\n    if (matches.length === 0) {\r\n      return 'No duplicates found - safe to create new truck entry';\r\n    }\r\n    \r\n    const bestMatch = matches[0];\r\n    const similarity = Math.round(bestMatch.similarity * 100);\r\n    \r\n    return `Found ${matches.length} potential duplicate(s). Best match: ${similarity}% similarity with \"${bestMatch.existingTruck.name}\" (matched: ${bestMatch.matchedFields.join(', ')})`;\r\n  }\r\n  \r\n  /**\r\n   * Merge duplicate truck data intelligently\r\n   */\r\n  static async mergeDuplicates(targetId: string, sourceId: string): Promise<FoodTruck | { error: string }> {\r\n    const targetResult = await FoodTruckService.getTruckById(targetId);\r\n    const sourceResult = await FoodTruckService.getTruckById(sourceId);\r\n\r\n    if ('error' in targetResult) {\r\n      return { error: `Failed to retrieve target truck with ID ${targetId}: ${targetResult.error}` };\r\n    }\r\n    if ('error' in sourceResult) {\r\n      return { error: `Failed to retrieve source truck with ID ${sourceId}: ${sourceResult.error}` };\r\n    }\r\n\r\n    const target = targetResult;\r\n    const source = sourceResult;\r\n\r\n    // Merge logic: prefer non-null, more complete data\r\n    const mergedData: Partial<FoodTruck> = {\r\n      name: target.name ?? source.name,\r\n      description: target.description ?? source.description,\r\n      cuisine_type: (target.cuisine_type?.length ?? 0) > 0 ? target.cuisine_type : source.cuisine_type,\r\n      price_range: target.price_range ?? source.price_range,\r\n      current_location: target.current_location ?? source.current_location,\r\n      contact_info: {\r\n        ...source.contact_info,\r\n        ...target.contact_info // Target takes precedence\r\n      },\r\n      operating_hours: target.operating_hours ?? source.operating_hours,\r\n      menu: (target.menu?.length ?? 0) > 0 ? target.menu : source.menu,\r\n      social_media: {\r\n        ...source.social_media,\r\n        ...target.social_media\r\n      },\r\n      source_urls: [...new Set([...(target.source_urls ?? []), ...(source.source_urls ?? [])])],\r\n      last_scraped_at: new Date().toISOString()\r\n    };\r\n\r\n    // Update target with merged data\r\n    const updatedTruckResult = await FoodTruckService.updateTruck(targetId, mergedData);\r\n\r\n    if ('error' in updatedTruckResult) {\r\n      return { error: `Failed to update target truck with merged data: ${updatedTruckResult.error}` };\r\n    }\r\n\r\n    console.info(`Merged truck ${sourceId} into ${targetId}`);\r\n\r\n    return updatedTruckResult;\r\n  }\r\n}\r\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\lib\\data-quality\\placeholderUtils.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\lib\\discoveryEngine.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\lib\\firecrawl.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\lib\\gemini.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\lib\\gemini\\geminiApiClient.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\lib\\gemini\\promptTemplates.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 223,
        "column": 3,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 223,
        "endColumn": 12,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [7319, 7328], "text": "(sourceUrl != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [7319, 7328], "text": "(sourceUrl ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [7319, 7328], "text": "(Boolean(sourceUrl))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "export const PromptTemplates = {\r\n  menuProcessing: (rawMenuText: string) => `\r\nParse the following food truck menu text and return a structured JSON format.\r\nExtract menu items with categories, names, descriptions, prices, and dietary tags.\r\n\r\nMenu text:\r\n${rawMenuText}\r\n\r\nExpected JSON format:\r\n[\r\n  {\r\n    \"category\": \"string\",\r\n    \"items\": [\r\n      {\r\n        \"name\": \"string\",\r\n        \"description\": \"string\",\r\n        \"price\": number,\r\n        \"dietary_tags\": [\"string\"]\r\n      }\r\n    ]\r\n  }\r\n]\r\n\r\nRules:\r\n- Extract actual prices as numbers (e.g., 12.99, not \"$12.99\")\r\n- Include dietary restrictions and special tags\r\n- Group items into logical categories\r\n- If no clear categories, use \"Main Items\"\r\n- Return only the json, no additional text\r\n  `,\r\n\r\n  locationExtraction: (textInput: string) => `\r\nExtract location information from the following text and return structured data.\r\nLook for addresses, cross streets, landmarks, or location descriptions.\r\n\r\nText:\r\n${textInput}\r\n\r\nExpected JSON format:\r\n{\r\n  \"address\": \"string or undefined\",\r\n  \"city\": \"string or undefined\", \r\n  \"state\": \"string or undefined\",\r\n  \"zipCode\": \"string or undefined\",\r\n  \"coordinates\": {\"lat\": number, \"lng\": number} or undefined,\r\n  \"confidence\": number,\r\n  \"landmarks\": [\"string\"]\r\n}\r\n\r\nRules:\r\n- Set coordinates to undefined if not explicitly provided\r\n- Confidence should be 0.0 to 1.0 based on clarity\r\n- Include any mentioned landmarks or cross streets\r\n- Return only the json, no additional text\r\n  `,\r\n\r\n  operatingHours: (hoursText: string) => `\r\nParse the following operating hours text and return standardized format.\r\nConvert all times to 24-hour format and handle various input formats.\r\n\r\nHours text:\r\n${hoursText}\r\n\r\nExpected JSON format:\r\n{\r\n  \"monday\": {\"open\": \"HH:MM\", \"close\": \"HH:MM\", \"closed\": false},\r\n  \"tuesday\": {\"open\": \"HH:MM\", \"close\": \"HH:MM\", \"closed\": false},\r\n  \"wednesday\": {\"open\": \"HH:MM\", \"close\": \"HH:MM\", \"closed\": false},\r\n  \"thursday\": {\"open\": \"HH:MM\", \"close\": \"HH:MM\", \"closed\": false},\r\n  \"friday\": {\"open\": \"HH:MM\", \"close\": \"HH:MM\", \"closed\": false},\r\n  \"saturday\": {\"open\": \"HH:MM\", \"close\": \"HH:MM\", \"closed\": false},\r\n  \"sunday\": {\"open\": \"HH:MM\", \"close\": \"HH:MM\", \"closed\": false}\r\n}\r\n\r\nRules:\r\n- Use 24-hour format (e.g., \"14:30\" for 2:30 pm)\r\n- If closed on a day, set \"closed\": true and omit open/close times\r\n- Handle ranges like \"Mon-Fri\" by applying to all days in range\r\n- Default to reasonable hours if ambiguous\r\n- Return only the json, no additional text\r\n  `,\r\n\r\n  sentimentAnalysis: (reviewText: string) => `\r\nAnalyze the sentiment of this food truck review and extract key insights.\r\nFocus on food quality, service, value, and overall experience.\r\n\r\nReview text:\r\n${reviewText}\r\n\r\nExpected JSON format:\r\n{\r\n  \"score\": number,\r\n  \"confidence\": number,\r\n  \"aspects\": {\r\n    \"food_quality\": number,\r\n    \"service\": number,\r\n    \"value\": number,\r\n    \"overall\": number\r\n  },\r\n  \"summary\": \"string\",\r\n  \"keywords\": [\"string\"]\r\n}\r\n\r\nRules:\r\n- Score should be 0.0 (very negative) to 1.0 (very positive)\r\n- Confidence should be 0.0 to 1.0 based on clarity of sentiment\r\n- Include specific aspects mentioned in the review\r\n- Summary should be 1-2 sentences max\r\n- Return only the json, no additional text\r\n  `,\r\n\r\n  dataEnhancement: (rawData: unknown) => `\r\nEnhance and standardize the following food truck data.\r\nFill in missing information where possible and improve data quality.\r\n\r\nRaw data:\r\n${JSON.stringify(rawData, undefined, 2)}\r\n\r\nExpected JSON format:\r\n{\r\n  \"name\": \"string\",\r\n  \"description\": \"string\",\r\n  \"cuisine_type\": \"string\",\r\n  \"price_range\": \"$ | $$ | $$$ | $$$$\",\r\n  \"contact\": {\r\n    \"phone\": \"string\",\r\n    \"email\": \"string\",\r\n    \"website\": \"string\",\r\n    \"social_media\": {}\r\n  },\r\n  \"location\": {\r\n    \"address\": \"string\",\r\n    \"city\": \"string\",\r\n    \"state\": \"string\",\r\n    \"coordinates\": {\"lat\": number, \"lng\": number}\r\n  },\r\n  \"operating_hours\": {},\r\n  \"menu_categories\": [\"string\"],\r\n  \"specialties\": [\"string\"],\r\n  \"dietary_options\": [\"string\"]\r\n}\r\n\r\nRules:\r\n- Preserve all original data while enhancing it\r\n- Standardize naming conventions\r\n- Infer cuisine type from menu items\r\n- Estimate price range from menu prices\r\n- Return only the json, no additional text\r\n  `,\r\n\r\n  foodTruckExtraction: (markdownContent: string, sourceUrl?: string) => {\r\n    const schema = `\r\nExpected JSON schema:\r\n{\r\n  \"name\": \"string (food truck name)\",\r\n  \"description\": \"string (brief description of the food truck)\",\r\n  \"cuisine_type\": \"string (type of cuisine served)\",\r\n  \"contact\": {\r\n    \"phone\": \"string (phone number if found)\",\r\n    \"email\": \"string (email if found)\", \r\n    \"website\": \"string (website URL if found)\",\r\n    \"social_media\": {\r\n      \"facebook\": \"string (Facebook URL if found)\",\r\n      \"instagram\": \"string (Instagram URL if found)\",\r\n      \"twitter\": \"string (Twitter URL if found)\"\r\n    }\r\n  },\r\n  \"location\": {\r\n    \"address\": \"string (physical address if found)\",\r\n    \"city\": \"string (city name)\",\r\n    \"state\": \"string (state abbreviation)\",\r\n    \"coordinates\": {\r\n      \"lat\": \"number (latitude if found)\",\r\n      \"lng\": \"number (longitude if found)\"\r\n    }\r\n  },\r\n  \"operating_hours\": {\r\n    \"monday\": {\"open\": \"string (HH:MM)\", \"close\": \"string (HH:MM)\", \"closed\": \"boolean\"},\r\n    \"tuesday\": {\"open\": \"string (HH:MM)\", \"close\": \"string (HH:MM)\", \"closed\": \"boolean\"},\r\n    \"wednesday\": {\"open\": \"string (HH:MM)\", \"close\": \"string (HH:MM)\", \"closed\": \"boolean\"},\r\n    \"thursday\": {\"open\": \"string (HH:MM)\", \"close\": \"string (HH:MM)\", \"closed\": \"boolean\"},\r\n    \"friday\": {\"open\": \"string (HH:MM)\", \"close\": \"string (HH:MM)\", \"closed\": \"boolean\"},\r\n    \"saturday\": {\"open\": \"string (HH:MM)\", \"close\": \"string (HH:MM)\", \"closed\": \"boolean\"},\r\n    \"sunday\": {\"open\": \"string (HH:MM)\", \"close\": \"string (HH:MM)\", \"closed\": \"boolean\"}\r\n  },\r\n  \"menu\": [\r\n    {\r\n      \"category\": \"string (menu category)\",\r\n      \"items\": [\r\n        {\r\n          \"name\": \"string (item name)\",\r\n          \"description\": \"string (item description)\",\r\n          \"price\": \"number (price as number, not string)\",\r\n          \"dietary_tags\": [\"string (dietary restrictions/tags)\"]\r\n        }\r\n      ]\r\n    }\r\n  ],\r\n  \"specialties\": [\"string (signature dishes or specialties)\"],\r\n  \"dietary_options\": [\"string (dietary accommodations like vegan, gluten-free)\"],\r\n  \"price_range\": \"string ($ for under $10, $$ for $10-20, $$$ for $20-30, $$$$ for over $30)\"\r\n}\r\n`;\r\n\r\n    const instructions = `\r\nInstructions:\r\n- Extract as much information as possible from the provided content\r\n- If information is not available, use null for the field\r\n- For operating hours, use 24-hour format (e.g., \"14:30\" for 2:30 PM)\r\n- If a day is closed, set \"closed\": true and omit open/close times\r\n- For prices, extract numeric values only (e.g., 12.99, not \"$12.99\")\r\n- Be thorough in extracting menu items and their details\r\n- Look for social media links and contact information carefully\r\n- Return only the JSON object, no additional text or formatting\r\n`;\r\n\r\n    return `\r\nYou are an ai assistant tasked with extracting structured information about food trucks from their website content (provided in Markdown format). Your goal is to populate a json object with the following schema. Only return the json object, nothing else.\r\n\r\nWebsite content:\r\n${markdownContent}\r\n\r\n${sourceUrl ? `Source URL: ${sourceUrl}` : ''}\r\n\r\n${schema}\r\n\r\n${instructions}\r\n`;\r\n  }\r\n};\r\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\lib\\gemini\\responseParser.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\lib\\gemini\\usageLimits.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'limits' is assigned a value but never used. Allowed unused args must match /^_/u.",
        "line": 60,
        "column": 5,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 60,
        "endColumn": 11
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { APIUsageService } from '../supabase';\r\nimport { APIMonitor } from '../monitoring/apiMonitor';\r\n\r\nexport interface UsageLimits {\r\n  dailyRequestLimit: number;\r\n  dailyTokenLimit: number;\r\n}\r\n\r\nexport interface UsageCheck {\r\n  canMakeRequest: boolean;\r\n  usage?: {\r\n    requests: { used: number; limit: number; remaining: number };\r\n    tokens: { used: number; limit: number; remaining: number };\r\n  };\r\n}\r\n\r\nexport class GeminiUsageLimits {\r\n  private static readonly DEFAULT_LIMITS: UsageLimits = {\r\n    dailyRequestLimit: 1500,\r\n    dailyTokenLimit: 32_000,\r\n  };\r\n\r\n  static async checkUsageLimits(limits: UsageLimits = this.DEFAULT_LIMITS): Promise<UsageCheck> {\r\n    try {\r\n      const usage = await APIUsageService.getTodayUsage('gemini');\r\n\r\n      if (!usage) {\r\n        return { canMakeRequest: true };\r\n      }\r\n\r\n      const requestsUsed = usage.requests_count ?? 0;\r\n      const tokensUsed = usage.tokens_used ?? 0;\r\n\r\n      const requestsRemaining = limits.dailyRequestLimit - requestsUsed;\r\n      const tokensRemaining = limits.dailyTokenLimit - tokensUsed;\r\n\r\n      return {\r\n        canMakeRequest: requestsRemaining > 0 && tokensRemaining > 100, // Keep 100 token buffer\r\n        usage: {\r\n          requests: {\r\n            used: requestsUsed,\r\n            limit: limits.dailyRequestLimit,\r\n            remaining: requestsRemaining,\r\n          },\r\n          tokens: {\r\n            used: tokensUsed,\r\n            limit: limits.dailyTokenLimit,\r\n            remaining: tokensRemaining,\r\n          },\r\n        },\r\n      };\r\n    } catch (error: unknown) {\r\n      console.warn('Error checking Gemini usage limits:', error);\r\n      return { canMakeRequest: false };\r\n    }\r\n  }\r\n\r\n  static async checkWithMonitoring(\r\n    estimatedTokens: number,\r\n    limits: UsageLimits = this.DEFAULT_LIMITS\r\n  ): Promise<{ allowed: boolean; reason?: string; waitTime?: number }> {\r\n    const canMakeRequest = await APIMonitor.canMakeRequest('gemini', 1, estimatedTokens);\r\n\r\n    if (!canMakeRequest.allowed) {\r\n      return {\r\n        allowed: false,\r\n        reason: `API limit reached: ${canMakeRequest.reason}. Wait time: ${Math.ceil((canMakeRequest.waitTime ?? 0) / 1000 / 60)} minutes`,\r\n      };\r\n    }\r\n\r\n    return { allowed: true };\r\n  }\r\n}\r\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\lib\\middleware\\middlewareHelpers.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 33,
        "column": 27,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 33,
        "endColumn": 30,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [760, 763], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [760, 763], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "max-params",
        "severity": 2,
        "message": "Async function 'logSecurityEventAndRedirect' has too many parameters (5). Maximum allowed is 4.",
        "line": 39,
        "column": 1,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 39,
        "endColumn": 43
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 49,
        "column": 7,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 49,
        "endColumn": 23,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [1182, 1198], "text": "redirectFromPath != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [1182, 1198], "text": "redirectFromPath ?? \"\"" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [1182, 1198], "text": "Boolean(redirectFromPath)" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "unicorn/no-null",
        "severity": 1,
        "message": "Use `undefined` instead of `null`.",
        "line": 121,
        "column": 88,
        "nodeType": "Literal",
        "messageId": "error",
        "endLine": 121,
        "endColumn": 92,
        "suggestions": [
          {
            "messageId": "replace",
            "fix": { "range": [3629, 3633], "text": "undefined" },
            "data": {},
            "desc": "Replace `null` with `undefined`."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 0,
    "warningCount": 3,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { NextRequest, NextResponse } from 'next/server';\r\nimport { AuditLogger, SecurityEvent } from '@/lib/security/auditLogger';\r\nimport { createSupabaseMiddlewareClient } from '@/lib/supabaseMiddleware';\r\n\r\ninterface RequestMetadata {\r\n  ip: string;\r\n  userAgent: string;\r\n  url: string;\r\n  method: string;\r\n}\r\n\r\ninterface SupabaseUser {\r\n  id: string;\r\n  email?: string;\r\n}\r\n\r\ninterface SupabaseProfile {\r\n  role?: string;\r\n}\r\n\r\ninterface LogAndRedirectParams {\r\n  req: NextRequest;\r\n  res: NextResponse;\r\n  requestMetadata: RequestMetadata;\r\n  reason: string;\r\n  userError?: { message?: string };\r\n}\r\n\r\ninterface LogSecurityEventParams {\r\n  event_type: SecurityEvent['event_type'];\r\n  ip_address: string;\r\n  user_agent: string;\r\n  details: Record<string, any>;\r\n  severity: SecurityEvent['severity'];\r\n  user_id?: string;\r\n  user_email?: string;\r\n}\r\n\r\nasync function logSecurityEventAndRedirect(\r\n  req: NextRequest,\r\n  res: NextResponse,\r\n  logParams: LogSecurityEventParams,\r\n  redirectPath: string,\r\n  redirectFromPath?: string\r\n) {\r\n  await AuditLogger.logSecurityEvent(logParams);\r\n  const redirectUrl = req.nextUrl.clone();\r\n  redirectUrl.pathname = redirectPath;\r\n  if (redirectFromPath) {\r\n    redirectUrl.searchParams.set(`redirectedFrom`, redirectFromPath);\r\n  }\r\n  return NextResponse.redirect(redirectUrl);\r\n}\r\n\r\nasync function logAndRedirect({ req, res, requestMetadata, reason, userError }: LogAndRedirectParams) {\r\n  return logSecurityEventAndRedirect(\r\n    req,\r\n    res,\r\n    {\r\n      event_type: 'permission_denied',\r\n      ip_address: requestMetadata.ip,\r\n      user_agent: requestMetadata.userAgent,\r\n      details: {\r\n        attempted_url: requestMetadata.url,\r\n        reason,\r\n        error: userError?.message,\r\n      },\r\n      severity: 'warning',\r\n    },\r\n    '/login',\r\n    req.nextUrl.pathname\r\n  );\r\n}\r\n\r\ninterface LogAndRedirectDeniedParams {\r\n  req: NextRequest;\r\n  res: NextResponse;\r\n  requestMetadata: RequestMetadata;\r\n  user: SupabaseUser;\r\n  profile: SupabaseProfile | null;\r\n  profileQueryError?: { message?: string } | null; // Changed to allow null\r\n}\r\n\r\nasync function logAndRedirectDenied({ req, res, requestMetadata, user, profile, profileQueryError }: LogAndRedirectDeniedParams) {\r\n  return logSecurityEventAndRedirect(\r\n    req,\r\n    res,\r\n    {\r\n      event_type: 'permission_denied',\r\n      user_id: user.id,\r\n      user_email: user.email ?? undefined,\r\n      ip_address: requestMetadata.ip,\r\n      user_agent: requestMetadata.userAgent,\r\n      details: {\r\n        attempted_url: requestMetadata.url,\r\n        user_role: profile?.role ?? 'none',\r\n        reason: 'insufficient_privileges',\r\n        error: profileQueryError?.message,\r\n      },\r\n      severity: 'error',\r\n    },\r\n    '/access-denied'\r\n  );\r\n}\r\n\r\nexport async function protectAdminRoutes(req: NextRequest, res: NextResponse, requestMetadata: RequestMetadata) {\r\n  const supabase = createSupabaseMiddlewareClient(req, res);\r\n  const { data, error: userError } = await supabase.auth.getUser();\r\n  const user = data?.user;\r\n\r\n  if (userError || !user) {\r\n    return logAndRedirect({ req, res, requestMetadata, reason: 'no_session', userError: userError ?? undefined });\r\n  }\r\n  // Explicitly type the result of the Supabase query\r\n  const { data: profile, error: profileQueryError } = await supabase\r\n    .from('profiles')\r\n    .select('role')\r\n    .eq('id', user.id)\r\n    .single() as { data: SupabaseProfile | null; error: { message?: string } | null };\r\n  if (profileQueryError || (profile && profile.role !== 'admin')) {\r\n    return logAndRedirectDenied({ req, res, requestMetadata, user, profile: profile ?? null, profileQueryError: profileQueryError ?? undefined });\r\n  }\r\n  if (req.method !== 'GET' || req.nextUrl.pathname.includes('/api/')) {\r\n    await AuditLogger.logDataAccess({\r\n      userId: user.id,\r\n      userEmail: user.email ?? 'unknown',\r\n      resourceType: 'admin_panel',\r\n      resourceId: req.nextUrl.pathname,\r\n      action: req.method === 'GET' ? 'read' : 'admin_access',\r\n      request: {\r\n        ip: requestMetadata.ip,\r\n        userAgent: requestMetadata.userAgent,\r\n      },\r\n    });\r\n  }\r\n  return res;\r\n}\r\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\lib\\monitoring\\apiMonitor.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\lib\\performance\\bundleAnalyzer.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\lib\\performance\\databaseCache.ts",
    "messages": [
      {
        "ruleId": "unicorn/no-null",
        "severity": 1,
        "message": "Use `undefined` instead of `null`.",
        "line": 73,
        "column": 16,
        "nodeType": "Literal",
        "messageId": "error",
        "endLine": 73,
        "endColumn": 20,
        "suggestions": [
          {
            "messageId": "remove",
            "fix": { "range": [2595, 2599], "text": "" },
            "data": {},
            "desc": "Remove `null`."
          },
          {
            "messageId": "replace",
            "fix": { "range": [2595, 2599], "text": "undefined" },
            "data": {},
            "desc": "Replace `null` with `undefined`."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 2,
        "message": "Unsafe assignment of type `any[]` to a variable of type `FoodTruck[]`.",
        "line": 113,
        "column": 13,
        "nodeType": "VariableDeclarator",
        "messageId": "unsafeAssignment",
        "endLine": 113,
        "endColumn": 45
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\r\n * SOTA Database Query Optimization and Caching\r\n * Implements Next.js unstable_cache for optimal performance\r\n */\r\n\r\nimport { unstable_cache } from 'next/cache';\r\nimport { supabaseAdmin, FoodTruckService } from '@/lib/supabase';\r\nimport type { FoodTruck } from '@/lib/types';\r\n\r\n// Cache configuration\r\nconst CACHE_CONFIG = {\r\n  // Short-term cache for frequently changing data\r\n  SHORT_TTL: 60 * 5, // 5 minutes\r\n  // Medium-term cache for semi-static data\r\n  MEDIUM_TTL: 60 * 30, // 30 minutes\r\n  // Long-term cache for static data\r\n  LONG_TTL: 60 * 60 * 24, // 24 hours\r\n} as const;\r\n\r\n/**\r\n * Cached food truck queries with optimized database access\r\n */\r\nexport const CachedFoodTruckService = {\r\n  /**\r\n   * Get all food trucks with caching\r\n   * Cache for 30 minutes since truck data changes moderately\r\n   */\r\n  getAllTrucksCached : unstable_cache(\r\n    async (): Promise<{ trucks: FoodTruck[]; count: number }> => {\r\n      console.info('CachedFoodTruckService: Cache miss - fetching all trucks from database');\r\n      const result = await FoodTruckService.getAllTrucks();\r\n      if ('error' in result) {\r\n        throw new Error(`Failed to fetch all trucks: ${result.error}`);\r\n      }\r\n      return { trucks: result.trucks, count: result.total };\r\n    },\r\n    ['all-trucks'],\r\n    {\r\n      revalidate: CACHE_CONFIG.MEDIUM_TTL,\r\n      tags: ['food-trucks', 'all-trucks']\r\n    }\r\n  ),\r\n\r\n  /**\r\n   * Get trucks by location with caching\r\n   * Cache for 5 minutes since location-based queries are time-sensitive\r\n   */\r\n  getTrucksByLocationCached : unstable_cache(\r\n    async (lat: number, lng: number, radiusKm: number): Promise<FoodTruck[]> => {\r\n      console.info(`CachedFoodTruckService: Cache miss - fetching trucks near ${lat},${lng} (${radiusKm}km)`);\r\n      const result = await FoodTruckService.getTrucksByLocation(lat, lng, radiusKm);\r\n      if ('error' in result) {\r\n        throw new Error(`Failed to fetch trucks by location: ${result.error}`);\r\n      }\r\n      return result as FoodTruck[];\r\n    },\r\n    ['trucks-by-location'],\r\n    {\r\n      revalidate: CACHE_CONFIG.SHORT_TTL,\r\n      tags: ['food-trucks', 'location-search']\r\n    }\r\n  ),\r\n\r\n  /**\r\n   * Get truck by ID with caching\r\n   * Cache for 30 minutes since individual truck data is relatively stable\r\n   */\r\n  getTruckByIdCached : unstable_cache(\r\n    async (id: string): Promise<FoodTruck | null> => {\r\n      console.info(`CachedFoodTruckService: Cache miss - fetching truck ${id} from database`);\r\n      const result = await FoodTruckService.getTruckById(id);\r\n      if ('error' in result) {\r\n        return null;\r\n      }\r\n      return result as FoodTruck;\r\n    },\r\n    ['truck-by-id'],\r\n    {\r\n      revalidate: CACHE_CONFIG.MEDIUM_TTL,\r\n      tags: ['food-trucks', 'truck-details']\r\n    }\r\n  ),\r\n\r\n  /**\r\n   * Search trucks with caching\r\n   * Cache for 5 minutes since search results should be relatively fresh\r\n   */\r\n  searchTrucksCached : unstable_cache(\r\n    async (query: string, filters?: {\r\n      cuisine?: string;\r\n      openNow?: boolean;\r\n      lat?: number;\r\n      lng?: number;\r\n      radius?: number;\r\n    }): Promise<FoodTruck[]> => {\r\n      console.info(`CachedFoodTruckService: Cache miss - searching trucks for \"${query}\"`);\r\n      \r\n      if (supabaseAdmin == undefined) {\r\n        throw new Error('Supabase admin client not available');\r\n      }\r\n\r\n      let dbQuery = supabaseAdmin\r\n        .from('food_trucks')\r\n        .select('*')\r\n        .or(`name.ilike.%${query}%,description.ilike.%${query}%,cuisine_type.cs.{${query}}`);\r\n\r\n      // Apply filters\r\n      if (filters?.cuisine != undefined && filters.cuisine !== '') {\r\n        dbQuery = dbQuery.contains('cuisine_type', [filters.cuisine]);\r\n      }\r\n\r\n      const { data, error } = await dbQuery.limit(50);\r\n      const trucks: FoodTruck[] = data ?? [];\r\n\r\n      if (error != undefined) {\r\n        throw new Error(`Search query failed: ${error.message}`);\r\n      }\r\n\r\n      let results: FoodTruck[] = trucks ?? [];\r\n\r\n      // Apply location filter if provided\r\n      if (filters?.lat != undefined && filters?.lng != undefined && filters?.radius != undefined) {\r\n        results = results.filter((truck: FoodTruck): truck is FoodTruck => {\r\n          if (truck.current_location?.lat == undefined || truck.current_location?.lng == undefined) {\r\n            return false;\r\n          }\r\n          const distance = calculateDistance(\r\n            filters.lat!, // Assert as number, as it's checked by the outer if condition\r\n            filters.lng!, // Assert as number, as it's checked by the outer if condition\r\n            truck.current_location.lat,\r\n            truck.current_location.lng\r\n          );\r\n          return distance <= (filters.radius ?? 10);\r\n        });\r\n      }\r\n\r\n      // Apply openNow filter if provided\r\n      if (filters?.openNow === true) {\r\n        const now = new Date();\r\n        const currentDay = now.toLocaleDateString('en-US', { weekday: 'short' }).toLowerCase(); // 'mon', 'tue', etc.\r\n        const currentTime = now.getHours() * 100 + now.getMinutes(); // HHMM format\r\n\r\n        results = results.filter((truck: FoodTruck): truck is FoodTruck => {\r\n          const hours = truck.operating_hours?.[currentDay as keyof typeof truck.operating_hours] as { closed?: boolean; open?: string; close?: string } | undefined;\r\n          if (hours == undefined || hours.closed === true) return false;\r\n\r\n          const openTime = parseTimeString(hours.open ?? '');\r\n          const closeTime = parseTimeString(hours.close ?? '');\r\n\r\n          return currentTime >= openTime && currentTime <= closeTime;\r\n        });\r\n      }\r\n\r\n      return results;\r\n    },\r\n    ['search-trucks'],\r\n    {\r\n      revalidate: CACHE_CONFIG.SHORT_TTL,\r\n      tags: ['food-trucks', 'search']\r\n    }\r\n  ),\r\n\r\n  /**\r\n   * Get data quality statistics with caching\r\n   * Cache for 24 hours since quality stats change slowly\r\n   */\r\n  getDataQualityStatsCached : unstable_cache(\r\n    async (): Promise<{\r\n      averageScore: number;\r\n      distribution: Record<string, number>;\r\n      totalTrucks: number;\r\n    }> => {\r\n      console.info('CachedFoodTruckService: Cache miss - calculating data quality stats');\r\n      \r\n      if (supabaseAdmin == undefined) {\r\n        throw new Error('Supabase admin client not available');\r\n      }\r\n\r\n      const { data: trucks, error } = await supabaseAdmin\r\n        .from('food_trucks')\r\n        .select('data_quality_score');\r\n\r\n      if (error) {\r\n        throw new Error(`Quality stats query failed: ${error.message}`);\r\n      }\r\n\r\n      const scores = trucks == undefined ? [] : trucks.map((t: { data_quality_score?: number }) => t.data_quality_score ?? 0);\r\n      const averageScore = scores.length > 0\r\n        ? scores.reduce((sum: number, score: number) => sum + score, 0) / scores.length\r\n        : 0;\r\n\r\n      const distribution = {\r\n        high: scores.filter((s: number) => s >= 0.8).length,\r\n        medium: scores.filter((s: number) => s >= 0.6 && s < 0.8).length,\r\n        low: scores.filter((s: number) => s < 0.6).length\r\n      };\r\n\r\n      return {\r\n        averageScore: Math.round(averageScore * 100) / 100,\r\n        distribution,\r\n        totalTrucks: scores.length\r\n      };\r\n    },\r\n    ['data-quality-stats'],\r\n    {\r\n      revalidate: CACHE_CONFIG.LONG_TTL,\r\n      tags: ['food-trucks', 'data-quality']\r\n    }\r\n  ),\r\n};\r\n\r\n/**\r\n * Cache invalidation utilities\r\n */\r\nexport const CacheManager = {\r\n  /**\r\n   * Invalidate all food truck related caches\r\n   */\r\n  async invalidateAllFoodTruckCaches(): Promise<void> {\r\n    try {\r\n      const { revalidateTag } = await import('next/cache');\r\n      revalidateTag('food-trucks');\r\n      console.info('CacheManager: Invalidated all food truck caches');\r\n    } catch (error) {\r\n      console.warn('CacheManager: Failed to invalidate caches:', error);\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Invalidate specific truck cache\r\n   */\r\n  async invalidateTruckCache(truckId: string): Promise<void> {\r\n    try {\r\n      const { revalidateTag } = await import('next/cache');\r\n      revalidateTag(`truck-${truckId}`);\r\n      revalidateTag('food-trucks'); // Also invalidate general caches\r\n      console.info(`CacheManager: Invalidated cache for truck ${truckId}`);\r\n    } catch (error) {\r\n      console.warn('CacheManager: Failed to invalidate truck cache:', error);\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Invalidate search and location caches\r\n   */\r\n  async invalidateSearchCaches(): Promise<void> {\r\n    try {\r\n      const { revalidateTag } = await import('next/cache');\r\n      revalidateTag('search');\r\n      revalidateTag('location-search');\r\n      console.info('CacheManager: Invalidated search caches');\r\n    } catch (error) {\r\n      console.warn('CacheManager: Failed to invalidate search caches:', error);\r\n    }\r\n  },\r\n};\r\n\r\n/**\r\n * Utility functions\r\n */\r\nfunction calculateDistance(lat1: number, lng1: number, lat2: number, lng2: number): number {\r\n  const R = 6371; // Earth's radius in kilometers\r\n  const dLat = (lat2 - lat1) * Math.PI / 180;\r\n  const dLng = (lng2 - lng1) * Math.PI / 180;\r\n  const a = \r\n    Math.sin(dLat/2) * Math.sin(dLat/2) +\r\n    Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * \r\n    Math.sin(dLng/2) * Math.sin(dLng/2);\r\n  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));\r\n  return R * c;\r\n}\r\n\r\nfunction parseTimeString(timeStr: string): number {\r\n  if (timeStr == undefined || timeStr === '') return 0;\r\n  const [hours, minutes] = timeStr.split(':').map(Number);\r\n  return hours * 100 + (minutes ?? 0);\r\n}\r\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\lib\\performance\\webVitals.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\lib\\pipelineManager.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\lib\\pipelineProcessor.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\lib\\pipeline\\pipelineHelpers.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\lib\\pipeline\\scrapingProcessor.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 16,
        "column": 33,
        "nodeType": "ChainExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 16,
        "endColumn": 60,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [564, 592], "text": "((scrapeResult.data?.markdown) == null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [565, 592], "text": "((scrapeResult.data?.markdown) ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [564, 592], "text": "(!Boolean((scrapeResult.data?.markdown)))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected object value in conditional. The condition is always true.",
        "line": 56,
        "column": 9,
        "nodeType": "Identifier",
        "messageId": "conditionErrorObject",
        "endLine": 56,
        "endColumn": 12
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 76,
        "column": 10,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableString",
        "endLine": 76,
        "endColumn": 24,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [2899, 2914], "text": "job.target_url == null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [2900, 2914], "text": "(job.target_url ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [2899, 2914], "text": "!Boolean(job.target_url)" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 3,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { firecrawl } from '@/lib/firecrawl';\r\nimport { gemini } from '@/lib/gemini';\r\nimport { ScrapingJobService } from '@/lib/supabase';\r\nimport { ExtractedFoodTruckDetails } from '../types';\r\nimport {\r\n  validateInputAndPrepare,\r\n  buildTruckDataSchema,\r\n  handleDuplicateCheck,\r\n  finalizeJobStatus,\r\n} from './pipelineHelpers';\r\n\r\nasync function handleScraping(targetUrl: string, jobId: string) {\r\n  console.info(`Starting scrape for ${targetUrl}`);\r\n  const scrapeResult = await firecrawl.scrapeFoodTruckWebsite(targetUrl);\r\n\r\n  if (!scrapeResult.success || !scrapeResult.data?.markdown) {\r\n    const error = scrapeResult.error ?? 'Scraping failed or markdown content not found';\r\n    await handleJobFailure(jobId, error);\r\n    throw new Error(error);\r\n  }\r\n\r\n  console.info(`Scraping successful for ${targetUrl}, proceeding to Gemini extraction.`);\r\n  return scrapeResult.data;\r\n}\r\n\r\nasync function handleGeminiExtraction(markdown: string, sourceUrl: string, jobId: string) {\r\n  const geminiResult = await gemini.extractFoodTruckDetailsFromMarkdown(markdown, sourceUrl);\r\n\r\n  if (!geminiResult.success || !geminiResult.data) {\r\n    const error = geminiResult.error ?? 'Gemini data extraction failed';\r\n    await handleJobFailure(jobId, error);\r\n    throw new Error(error);\r\n  }\r\n\r\n  console.info(`Gemini extraction successful for ${sourceUrl}.`);\r\n  return geminiResult.data;\r\n}\r\n\r\nasync function handleJobFailure(jobId: string, error: string) {\r\n  console.error(`Job ${jobId} failed:`, error);\r\n  try {\r\n    const currentJob = await ScrapingJobService.getJobsByStatus('all').then(jobs =>\r\n      jobs.find(j => j.id === jobId)\r\n    );\r\n    if (currentJob && currentJob.status !== 'failed') {\r\n      await ScrapingJobService.updateJobStatus(jobId, 'failed', { errors: [error] });\r\n    }\r\n  } catch (statusUpdateError) {\r\n    console.error(`Error updating job ${jobId} status to failed:`, statusUpdateError);\r\n  }\r\n}\r\n\r\nasync function handleRetryLogic(jobId: string) {\r\n  try {\r\n    const job = await ScrapingJobService.incrementRetryCount(jobId);\r\n    if (job && typeof job.retry_count === 'number' && typeof job.max_retries === 'number') {\r\n      if (job.retry_count < job.max_retries) {\r\n        console.info(`Retrying job ${jobId} (attempt ${job.retry_count}/${job.max_retries})`);\r\n        setTimeout(() => {\r\n          void processScrapingJob(jobId);\r\n        }, 5000);\r\n      } else {\r\n        console.warn(`Job ${jobId} reached max retries (${job.max_retries}).`);\r\n      }\r\n    } else {\r\n      console.error(`Job ${jobId}: Could not get valid retry_count or max_retries. Won't attempt retry.`);\r\n    }\r\n  } catch (retryError) {\r\n    console.error(`Error during retry logic for job ${jobId}:`, retryError);\r\n  }\r\n}\r\n\r\nexport async function processScrapingJob(jobId: string): Promise<void> {\r\n  try {\r\n    const job = await ScrapingJobService.updateJobStatus(jobId, 'running');\r\n    if (!job.target_url) {\r\n      throw new Error('No target URL specified');\r\n    }\r\n\r\n    const scrapeData = await handleScraping(job.target_url, jobId);\r\n    const extractedData = await handleGeminiExtraction(scrapeData.markdown, scrapeData.source_url ?? job.target_url, jobId);\r\n\r\n    await ScrapingJobService.updateJobStatus(jobId, 'completed', {\r\n      data_collected: extractedData as unknown as Record<string, unknown>,\r\n      completed_at: new Date().toISOString(),\r\n    });\r\n\r\n    await createOrUpdateFoodTruck(jobId, extractedData, scrapeData.source_url ?? job.target_url);\r\n\r\n    console.info(`Scraping job ${jobId} completed successfully and data processed.`);\r\n  } catch {\r\n    await handleRetryLogic(jobId);\r\n  }\r\n}\r\n\r\nexport async function createOrUpdateFoodTruck(\r\n  jobId: string,\r\n  extractedTruckData: ExtractedFoodTruckDetails,\r\n  sourceUrl: string,\r\n) {\r\n  try {\r\n    const validation = await validateInputAndPrepare(jobId, extractedTruckData, sourceUrl);\r\n    if (!validation.isValid) {\r\n      return;\r\n    }\r\n\r\n    const truckData = buildTruckDataSchema(extractedTruckData, sourceUrl, validation.name);\r\n    const truck = await handleDuplicateCheck(jobId, truckData, validation.name);\r\n    await finalizeJobStatus(jobId, truck, sourceUrl);\r\n  } catch (error) {\r\n    const errorMessage = error instanceof Error ? error.message : 'Unknown error';\r\n    console.error(`Job ${jobId}: Error in createOrUpdateFoodTruck from ${sourceUrl ?? 'Unknown Source'}:`, error);\r\n    await handleJobFailure(jobId, `Food truck data processing/saving failed: ${errorMessage}`);\r\n  }\r\n}\r\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\lib\\scheduler.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\lib\\security\\auditLogger.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\lib\\security\\rateLimiter.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.",
        "line": 276,
        "column": 11,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorNullableNumber",
        "endLine": 276,
        "endColumn": 28,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [8196, 8213], "text": "result.retryAfter != null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultZero",
            "fix": { "range": [8196, 8213], "text": "result.retryAfter ?? 0" },
            "desc": "Explicitly treat nullish value the same as 0 (`value ?? 0`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [8196, 8213], "text": "Boolean(result.retryAfter)" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\r\n * SOTA Rate Limiting Implementation\r\n * Prevents brute force attacks and API abuse with intelligent rate limiting\r\n */\r\n\r\nimport { NextResponse } from 'next/server'; // Added import for NextResponse\r\n\r\ninterface RateLimitEntry {\r\n  count: number;\r\n  resetTime: number;\r\n  blocked: boolean;\r\n  blockUntil?: number;\r\n}\r\n\r\n// In-memory rate limit store (in production, use Redis)\r\nconst rateLimitStore = new Map<string, RateLimitEntry>();\r\n\r\n// Rate limit configurations for different endpoints\r\nexport const RATE_LIMIT_CONFIGS = {\r\n  // Authentication endpoints - strict limits\r\n  auth: {\r\n    windowMs: 15 * 60 * 1000, // 15 minutes\r\n    maxRequests: 5, // 5 attempts per 15 minutes\r\n    blockDurationMs: 30 * 60 * 1000, // Block for 30 minutes\r\n    skipSuccessfulRequests: true\r\n  },\r\n  // API endpoints - moderate limits\r\n  api: {\r\n    windowMs: 60 * 1000, // 1 minute\r\n    maxRequests: 60, // 60 requests per minute\r\n    blockDurationMs: 5 * 60 * 1000, // Block for 5 minutes\r\n    skipSuccessfulRequests: false\r\n  },\r\n  // Admin endpoints - very strict limits\r\n  admin: {\r\n    windowMs: 60 * 1000, // 1 minute\r\n    maxRequests: 20, // 20 requests per minute\r\n    blockDurationMs: 15 * 60 * 1000, // Block for 15 minutes\r\n    skipSuccessfulRequests: false\r\n  }\r\n} as const;\r\n\r\nexport type RateLimitType = keyof typeof RATE_LIMIT_CONFIGS;\r\n\r\n/**\r\n * Rate Limiter Service\r\n */\r\nexport class RateLimiter {\r\n  // Extract logic from checkRateLimit to reduce function size\r\n  private static isBlocked(entry: RateLimitEntry | undefined, now: number): boolean {\r\n    return Boolean(entry && entry.blocked && entry.blockUntil != undefined && now < entry.blockUntil);\r\n  }\r\n\r\n  private static resetEntry(entry: RateLimitEntry, now: number, config: typeof RATE_LIMIT_CONFIGS[RateLimitType]): void {\r\n    entry.count = 0;\r\n    entry.resetTime = now + config.windowMs;\r\n    entry.blocked = false;\r\n    entry.blockUntil = undefined;\r\n  }\r\n\r\n  /**\r\n   * Check if request should be rate limited\r\n   */\r\n  static checkRateLimit(\r\n    identifier: string,\r\n    type: RateLimitType = 'api'\r\n  ): {\r\n    allowed: boolean;\r\n    remaining: number;\r\n    resetTime: number;\r\n    retryAfter?: number;\r\n  } {\r\n    const config = RATE_LIMIT_CONFIGS[type];\r\n    const now = Date.now();\r\n    const key = `${type}:${identifier}`;\r\n    this.cleanupExpiredEntries();\r\n    let entry = rateLimitStore.get(key);\r\n    if (!entry) {\r\n      entry = { count: 0, resetTime: now + config.windowMs, blocked: false };\r\n      rateLimitStore.set(key, entry);\r\n    }\r\n    if (this.isBlocked(entry, now)) {\r\n      return {\r\n        allowed: false,\r\n        remaining: 0,\r\n        resetTime: entry.resetTime,\r\n        retryAfter: Math.ceil((entry.blockUntil! - now) / 1000)\r\n      };\r\n    }\r\n    if (now >= entry.resetTime) {\r\n      this.resetEntry(entry, now, config);\r\n    }\r\n    if (entry.count >= config.maxRequests) {\r\n      entry.blocked = true;\r\n      entry.blockUntil = now + config.blockDurationMs;\r\n      return {\r\n        allowed: false,\r\n        remaining: 0,\r\n        resetTime: entry.resetTime,\r\n        retryAfter: Math.ceil(config.blockDurationMs / 1000)\r\n      };\r\n    }\r\n    entry.count++;\r\n    rateLimitStore.set(key, entry);\r\n    return {\r\n      allowed: true,\r\n      remaining: config.maxRequests - entry.count,\r\n      resetTime: entry.resetTime\r\n    };\r\n  }\r\n  \r\n  /**\r\n   * Record successful request (for auth endpoints)\r\n   */\r\n  static recordSuccess(identifier: string, type: RateLimitType = 'api'): void {\r\n    const config = RATE_LIMIT_CONFIGS[type];\r\n    if (!config.skipSuccessfulRequests) return;\r\n    \r\n    const key = `${type}:${identifier}`;\r\n    const entry = rateLimitStore.get(key);\r\n    \r\n    if (entry) {\r\n      // Reset counter on successful auth\r\n      entry.count = 0;\r\n      entry.blocked = false;\r\n      entry.blockUntil = undefined;\r\n      rateLimitStore.set(key, entry);\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Get rate limit status without incrementing\r\n   */\r\n  static getStatus(\r\n    identifier: string,\r\n    type: RateLimitType = 'api'\r\n  ): {\r\n    remaining: number;\r\n    resetTime: number;\r\n    blocked: boolean;\r\n    retryAfter?: number;\r\n  } {\r\n    const config = RATE_LIMIT_CONFIGS[type];\r\n    const now = Date.now();\r\n    const key = `${type}:${identifier}`;\r\n    const entry = rateLimitStore.get(key);\r\n    \r\n    if (!entry) {\r\n      return {\r\n        remaining: config.maxRequests,\r\n        resetTime: now + config.windowMs,\r\n        blocked: false\r\n      };\r\n    }\r\n    \r\n    // Check if blocked\r\n    if (entry.blocked && (entry.blockUntil != undefined) && now < entry.blockUntil) { // Changed != undefined to != null\r\n      return {\r\n        remaining: 0,\r\n        resetTime: entry.resetTime,\r\n        blocked: true,\r\n        retryAfter: Math.ceil((entry.blockUntil - now) / 1000)\r\n      };\r\n    }\r\n    \r\n    // Check if window expired\r\n    if (now >= entry.resetTime) {\r\n      return {\r\n        remaining: config.maxRequests,\r\n        resetTime: now + config.windowMs,\r\n        blocked: false\r\n      };\r\n    }\r\n    \r\n    return {\r\n      remaining: Math.max(0, config.maxRequests - entry.count),\r\n      resetTime: entry.resetTime,\r\n      blocked: false\r\n    };\r\n  }\r\n  \r\n  /**\r\n   * Clean up expired entries to prevent memory leaks\r\n   */\r\n  private static cleanupExpiredEntries(): void {\r\n    const now = Date.now();\r\n    \r\n    for (const [key, entry] of rateLimitStore.entries()) {\r\n      // Remove entries that are expired and not blocked\r\n      if (now >= entry.resetTime && (!entry.blocked || (entry.blockUntil == undefined) || now >= entry.blockUntil)) { // Changed == undefined to == null\r\n        rateLimitStore.delete(key);\r\n      }\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Clear all rate limit data for an identifier\r\n   */\r\n  static clearLimits(identifier: string, type?: RateLimitType): void {\r\n    if (type) {\r\n      const key = `${type}:${identifier}`;\r\n      rateLimitStore.delete(key);\r\n    } else {\r\n      // Clear all types for this identifier\r\n      for (const limitType of Object.keys(RATE_LIMIT_CONFIGS) as RateLimitType[]) { // Added type assertion\r\n        const key = `${limitType}:${identifier}`;\r\n        rateLimitStore.delete(key);\r\n      }\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Get rate limit statistics\r\n   */\r\n  static getStats(): {\r\n    totalEntries: number;\r\n    blockedEntries: number;\r\n    entriesByType: Record<string, number>;\r\n  } {\r\n    const stats = {\r\n      totalEntries: rateLimitStore.size,\r\n      blockedEntries: 0,\r\n      entriesByType: {} as Record<string, number>\r\n    };\r\n    \r\n    for (const [key, entry] of rateLimitStore.entries()) {\r\n      const type = key.split(':')[0];\r\n      stats.entriesByType[type] = (stats.entriesByType[type] ?? 0) + 1;\r\n      \r\n      if (entry.blocked) {\r\n        stats.blockedEntries++;\r\n      }\r\n    }\r\n    \r\n    return stats;\r\n  }\r\n}\r\n\r\n/**\r\n * Utility function to get client identifier from request\r\n */\r\nexport function getClientIdentifier(request: Request): string {\r\n  // Try to get IP address from various headers\r\n  const forwarded = request.headers.get('x-forwarded-for');\r\n  const realIp = request.headers.get('x-real-ip');\r\n  const cfConnectingIp = request.headers.get('cf-connecting-ip');\r\n  \r\n  // Use the first available IP\r\n  const ip = (forwarded?.split(',')[0]?.trim() ?? realIp ?? cfConnectingIp) ?? 'unknown';\r\n  \r\n  // Include user agent for more specific identification\r\n  const userAgent = request.headers.get('user-agent') ?? 'unknown';\r\n  \r\n  // Create a hash of IP + User Agent for better identification\r\n  return `${ip}:${userAgent.slice(0, 50)}`;\r\n}\r\n\r\n/**\r\n * Rate limiting middleware for API routes\r\n */\r\nexport function withRateLimit(\r\n  handler: (request: Request) => Promise<Response>,\r\n  type: RateLimitType = 'api'\r\n) {\r\n  return async (request: Request): Promise<Response> => {\r\n    const identifier = getClientIdentifier(request);\r\n    const result = RateLimiter.checkRateLimit(identifier, type);\r\n    \r\n    if (result.allowed === false) {\r\n      const headers = new Headers({\r\n        'X-RateLimit-Limit': RATE_LIMIT_CONFIGS[type].maxRequests.toString(),\r\n        'X-RateLimit-Remaining': '0',\r\n        'X-RateLimit-Reset': new Date(result.resetTime).toISOString(),\r\n      });\r\n      \r\n      if (result.retryAfter) {\r\n        headers.set('Retry-After', result.retryAfter.toString());\r\n      }\r\n      \r\n      return new NextResponse('Too Many Requests', { status: 429, headers });\r\n    }\r\n    \r\n    const response = await handler(request);\r\n    \r\n    // Update headers on successful requests if not skipped\r\n    if (RATE_LIMIT_CONFIGS[type].skipSuccessfulRequests === false) {\r\n      const status = RateLimiter.getStatus(identifier, type);\r\n      response.headers.set('X-RateLimit-Limit', RATE_LIMIT_CONFIGS[type].maxRequests.toString());\r\n      response.headers.set('X-RateLimit-Remaining', status.remaining.toString());\r\n      response.headers.set('X-RateLimit-Reset', new Date(status.resetTime).toISOString());\r\n    }\r\n    \r\n    return response;\r\n  };\r\n}\r\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\lib\\supabase.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 14,
        "column": 6,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 14,
        "endColumn": 17,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [350, 362], "text": "supabaseUrl == null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [351, 362], "text": "(supabaseUrl ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [350, 362], "text": "!Boolean(supabaseUrl)" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 18,
        "column": 6,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 18,
        "endColumn": 21,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [453, 469], "text": "supabaseAnonKey == null" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [454, 469], "text": "(supabaseAnonKey ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [453, 469], "text": "!Boolean(supabaseAnonKey)" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
        "line": 25,
        "column": 30,
        "nodeType": "Identifier",
        "messageId": "conditionErrorNullableString",
        "endLine": 25,
        "endColumn": 48,
        "suggestions": [
          {
            "messageId": "conditionFixCompareNullish",
            "fix": { "range": [736, 754], "text": "(supabaseServiceKey != null)" },
            "desc": "Change condition to check for null/undefined (`value != null`)"
          },
          {
            "messageId": "conditionFixDefaultEmptyString",
            "fix": { "range": [736, 754], "text": "(supabaseServiceKey ?? \"\")" },
            "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
          },
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [736, 754], "text": "(Boolean(supabaseServiceKey))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected object value in conditional. The condition is always true.",
        "line": 101,
        "column": 12,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorObject",
        "endLine": 101,
        "endColumn": 43
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected object value in conditional. The condition is always true.",
        "line": 156,
        "column": 12,
        "nodeType": "Identifier",
        "messageId": "conditionErrorObject",
        "endLine": 156,
        "endColumn": 16
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected object value in conditional. The condition is always true.",
        "line": 665,
        "column": 7,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorObject",
        "endLine": 665,
        "endColumn": 29
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected object value in conditional. The condition is always true.",
        "line": 670,
        "column": 8,
        "nodeType": "MemberExpression",
        "messageId": "conditionErrorObject",
        "endLine": 670,
        "endColumn": 26
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 2,
        "message": "Unsafe array destructuring of a tuple element with an `any` value.",
        "line": 684,
        "column": 19,
        "nodeType": "Identifier",
        "messageId": "unsafeArrayPatternFromTuple",
        "endLine": 684,
        "endColumn": 24
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected any value in conditional. An explicit comparison or type conversion is required.",
        "line": 694,
        "column": 10,
        "nodeType": "Identifier",
        "messageId": "conditionErrorAny",
        "endLine": 694,
        "endColumn": 15,
        "suggestions": [
          {
            "messageId": "conditionFixCastBoolean",
            "fix": { "range": [23272, 23277], "text": "(Boolean(truck))" },
            "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 2,
        "message": "Unsafe argument of type `any` assigned to a parameter of type `FoodTruck`.",
        "line": 698,
        "column": 50,
        "nodeType": "Identifier",
        "messageId": "unsafeArgument",
        "endLine": 698,
        "endColumn": 55
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 2,
        "message": "Unsafe array destructuring of a tuple element with an `any` value.",
        "line": 700,
        "column": 13,
        "nodeType": "Identifier",
        "messageId": "unsafeArrayPatternFromTuple",
        "endLine": 700,
        "endColumn": 17
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-return",
        "severity": 2,
        "message": "Unsafe return of a value of type `any`.",
        "line": 711,
        "column": 5,
        "nodeType": "ReturnStatement",
        "messageId": "unsafeReturn",
        "endLine": 711,
        "endColumn": 17
      }
    ],
    "suppressedMessages": [],
    "errorCount": 4,
    "fatalErrorCount": 0,
    "warningCount": 8,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import {\r\n  createClient,\r\n  type PostgrestSingleResponse,\r\n  type PostgrestResponse,\r\n  type PostgrestError,\r\n} from '@supabase/supabase-js';\r\n\r\n\r\n\r\nconst supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;\r\nconst supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY;\r\nconst supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY;\r\n\r\nif (!supabaseUrl) {\r\n  throw new Error('Missing NEXT_PUBLIC_SUPABASE_URL environment variable');\r\n}\r\n\r\nif (!supabaseAnonKey) {\r\n  throw new Error('Missing NEXT_PUBLIC_SUPABASE_ANON_KEY environment variable');\r\n}\r\n\r\nexport const supabase = createClient(supabaseUrl, supabaseAnonKey);\r\n\r\n// Only create admin client on server side where service key is available\r\nexport const supabaseAdmin = supabaseServiceKey\r\n  ? createClient(supabaseUrl, supabaseServiceKey)\r\n  : undefined;\r\n\r\n// Database types\r\nimport {\r\n  MenuCategory,\r\n  MenuItem,\r\n} from './types';\r\n\r\nexport interface FoodTruckLocation {\r\n  lat: number;\r\n  lng: number;\r\n  address?: string;\r\n  timestamp: string;\r\n}\r\n\r\n// Re-exporting from types.ts to ensure consistency\r\n\r\nimport { FoodTruckSchema } from './types';\r\n\r\nexport interface FoodTruck extends FoodTruckSchema {\r\n  id: string;\r\n  created_at: string;\r\n  updated_at: string;\r\n  is_active?: boolean; // This property is in lib/types.ts but not in lib/supabase.ts\r\n  // Add any other properties that are in the database but not in FoodTruckSchema\r\n  // For example, if the database has 'exact_location' or 'city_location'\r\n  exact_location?: FoodTruckLocation;\r\n  city_location?: FoodTruckLocation;\r\n}\r\n\r\nexport interface ScrapingJob {\r\n  id: string;\r\n  job_type: string;\r\n  target_url?: string;\r\n  target_handle?: string;\r\n  platform?: string;\r\n  status: 'pending' | 'running' | 'completed' | 'failed';\r\n  priority: number;\r\n  scheduled_at: string;\r\n  started_at?: string;\r\n  completed_at?: string;\r\n  data_collected?: Record<string, unknown>;\r\n  errors?: string[];\r\n  retry_count: number;\r\n  max_retries: number;\r\n  created_at: string;\r\n}\r\n\r\nexport interface DataProcessingQueue {\r\n  id: string;\r\n  truck_id?: string;\r\n  processing_type: string;\r\n  raw_data: Record<string, unknown>;\r\n  processed_data?: Record<string, unknown>;\r\n  gemini_tokens_used: number;\r\n  status: 'pending' | 'processing' | 'completed' | 'failed';\r\n  priority: number;\r\n  created_at: string;\r\n  processed_at?: string;\r\n}\r\n\r\nexport interface ApiUsage {\r\n  id: string;\r\n  service_name: string;\r\n  usage_date: string;\r\n  requests_count: number;\r\n  tokens_used: number;\r\n}\r\n\r\n// Food truck operations\r\nfunction buildMenuByTruck(menuItems: RawMenuItemFromDB[]): Record<string, RawMenuItemFromDB[]> {\r\n  const menuByTruck: Record<string, RawMenuItemFromDB[]> = {};\r\n  for (const item of menuItems) {\r\n    if (typeof item.food_truck_id === 'string' && item.food_truck_id.trim() !== '') {\r\n      if (!menuByTruck[item.food_truck_id]) {\r\n        menuByTruck[item.food_truck_id] = [];\r\n      }\r\n      menuByTruck[item.food_truck_id].push(item);\r\n    }\r\n  }\r\n  return menuByTruck;\r\n}\r\n\r\nfunction handleSupabaseError(error: unknown, context: string) {\r\n  // Log technical details for developers\r\n  console.warn(`Error in ${context}:`, error);\r\n}\r\n\r\nexport const FoodTruckService = {\r\n  async getAllTrucks(limit = 50, offset = 0): Promise<{ trucks: FoodTruck[]; total: number; error?: string }> {\r\n    try {\r\n      const { data, error, count }: PostgrestResponse<FoodTruck> = await supabase\r\n        .from('food_trucks')\r\n        .select('*', { count: 'exact' })\r\n        .order('updated_at', { ascending: false })\r\n        .range(offset, offset + limit - 1);\r\n      if (error !== null) throw error;\r\n      const trucks: FoodTruck[] = (data ?? []).map((t: FoodTruck) => normalizeTruckLocation(t));\r\n      if (trucks.length === 0) return { trucks: [], total: count ?? 0 };\r\n      const truckIds = trucks.map((t: FoodTruck) => t.id);\r\n      let menuItems: RawMenuItemFromDB[] = [];\r\n      try {\r\n        if (truckIds.length > 0) {\r\n          const { data: items, error: menuError }: PostgrestResponse<RawMenuItemFromDB> =\r\n            await supabase.from('menu_items').select('*').in('food_truck_id', truckIds);\r\n          if (menuError) throw menuError;\r\n          menuItems = Array.isArray(items) ? items : [];\r\n        }\r\n      } catch (menuError) {\r\n        handleSupabaseError(menuError, 'getAllTrucks:menu_items');\r\n      }\r\n      const menuByTruck = buildMenuByTruck(menuItems);\r\n      for (const truck of trucks) {\r\n      truck.menu = groupMenuItems(menuByTruck[truck.id] ?? []);\r\n      }\r\n      return { trucks, total: count ?? 0 };\r\n    } catch (error) {\r\n      handleSupabaseError(error, 'getAllTrucks');\r\n      return { trucks: [], total: 0, error: \"That didn't work, please try again later.\" };\r\n    }\r\n  },\r\n  async getTruckById(id: string): Promise<FoodTruck | { error: string }> {\r\n    try {\r\n      const { data, error }: PostgrestSingleResponse<FoodTruck> = await supabase\r\n        .from('food_trucks')\r\n        .select('*')\r\n        .eq('id', id)\r\n        .single();\r\n      if (error !== null) throw error;\r\n      if (!data) {\r\n        return { error: \"That didn't work, please try again later.\" };\r\n      }\r\n      const truck: FoodTruck = normalizeTruckLocation(data);\r\n      const { data: items, error: menuError }: PostgrestResponse<RawMenuItemFromDB> = await supabase\r\n        .from('menu_items')\r\n        .select('*')\r\n        .eq('food_truck_id', id);\r\n      if (menuError) throw menuError;\r\n      truck.menu = groupMenuItems(Array.isArray(items) ? items : []);\r\n      return truck;\r\n    } catch (error) {\r\n      handleSupabaseError(error, 'getTruckById');\r\n      return { error: \"That didn't work, please try again later.\" };\r\n    }\r\n  },\r\n\r\n  async getTrucksByLocation(lat: number, lng: number, radiusKm: number): Promise<FoodTruck[] | { error: string }> {\r\n    try {\r\n      const { trucks } = await FoodTruckService.getAllTrucks();\r\n      const nearbyTrucks = trucks.filter((truck: FoodTruck) => {\r\n        if (\r\n          truck.current_location == undefined ||\r\n          typeof truck.current_location.lat !== 'number' ||\r\n          typeof truck.current_location.lng !== 'number'\r\n        ) {\r\n          return false;\r\n        }\r\n        const distance = calculateDistance(\r\n          lat,\r\n          lng,\r\n          truck.current_location.lat,\r\n          truck.current_location.lng,\r\n        );\r\n        return distance <= radiusKm;\r\n      });\r\n      return nearbyTrucks;\r\n    } catch (error: unknown) {\r\n      handleSupabaseError(error, 'getTrucksByLocation');\r\n      return { error: \"That didn't work, please try again later.\" };\r\n    }\r\n  },\r\n  async createTruck(truckData: Partial<FoodTruck>): Promise<FoodTruck | { error: string }> {\r\n    if (!supabaseAdmin) {\r\n      return { error: 'Admin operations require SUPABASE_SERVICE_ROLE_KEY' };\r\n    }\r\n    const menuData = truckData.menu;\r\n    const truckDataWithoutMenu = { ...truckData };\r\n    delete truckDataWithoutMenu.menu;\r\n    const { data: truck, error }: PostgrestSingleResponse<FoodTruck> = await supabaseAdmin\r\n      .from('food_trucks')\r\n      .insert([truckDataWithoutMenu])\r\n      .select()\r\n      .single();\r\n    if (error) {\r\n      handleSupabaseError(error, 'createTruck');\r\n      return { error: \"Failed to create truck.\" };\r\n    }\r\n    await insertMenuItems(truck.id, menuData);\r\n    return truck;\r\n  },\r\n\r\n  async updateTruck(id: string, updates: Partial<FoodTruck>): Promise<FoodTruck | { error: string }> {\r\n    if (!supabaseAdmin) {\r\n      return { error: 'Admin operations require SUPABASE_SERVICE_ROLE_KEY' };\r\n    }\r\n    const menuData = updates.menu;\r\n    const updatesWithoutMenu = { ...updates };\r\n    delete updatesWithoutMenu.menu;\r\n    const truckResult = await updateTruckData(id, updatesWithoutMenu);\r\n    if ('error' in truckResult) {\r\n      return truckResult;\r\n    }\r\n    if (menuData != undefined) {\r\n      await updateTruckMenu(id, menuData);\r\n    }\r\n    return truckResult;\r\n  },\r\n\r\n  async getDataQualityStats(): Promise<{\r\n    total_trucks: number;\r\n    avg_quality_score: number;\r\n    high_quality_count: number;\r\n    medium_quality_count: number;\r\n    low_quality_count: number;\r\n    verified_count: number;\r\n    pending_count: number;\r\n    flagged_count: number;\r\n  }> {\r\n    try {\r\n      const {\r\n        data,\r\n        error,\r\n      }: PostgrestSingleResponse<{\r\n        total_trucks: number;\r\n        avg_quality_score: number;\r\n        high_quality_count: number;\r\n        medium_quality_count: number;\r\n        low_quality_count: number;\r\n        verified_count: number;\r\n        pending_count: number;\r\n        flagged_count: number;\r\n      }> = await supabase.rpc('get_data_quality_stats').single();\r\n      if (error) throw error;\r\n      return data as {\r\n        total_trucks: number;\r\n        avg_quality_score: number;\r\n        high_quality_count: number;\r\n        medium_quality_count: number;\r\n        low_quality_count: number;\r\n        verified_count: number;\r\n        pending_count: number;\r\n        flagged_count: number;\r\n      };\r\n    } catch (error: unknown) {\r\n      console.warn('Error fetching data quality stats:', error);\r\n      return {\r\n        total_trucks: 0,\r\n        avg_quality_score: 0,\r\n        high_quality_count: 0,\r\n        medium_quality_count: 0,\r\n        low_quality_count: 0,\r\n        verified_count: 0,\r\n        pending_count: 0,\r\n        flagged_count: 0,\r\n      };\r\n    }\r\n  },\r\n};\r\n\r\n// Helper functions to reduce cognitive complexity\r\nconst isMenuCategory = (obj: unknown): obj is MenuCategory =>\r\n  typeof obj === 'object' && obj != undefined && 'name' in obj && 'items' in obj && Array.isArray(obj.items);\r\n\r\nconst isMenuItem = (obj: unknown): obj is MenuItem => {\r\n  if (typeof obj !== 'object' || obj === null) return false;\r\n  const item = obj as Record<string, unknown>;\r\n  return (\r\n    typeof item.name === 'string' &&\r\n    (item.description === undefined || typeof item.description === 'string') &&\r\n    (item.price === undefined || typeof item.price === 'number') &&\r\n    (item.dietary_tags === undefined || (Array.isArray(item.dietary_tags) && item.dietary_tags.every(tag => typeof tag === 'string')))\r\n  );\r\n};\r\n\r\nasync function updateTruckData(\r\n  id: string,\r\n  updatesWithoutMenu: Partial<FoodTruck>,\r\n): Promise<FoodTruck | { error: string }> {\r\n  if (!supabaseAdmin) {\r\n    return { error: 'Admin operations require SUPABASE_SERVICE_ROLE_KEY' };\r\n  }\r\n\r\n  const { data: truck, error }: PostgrestSingleResponse<FoodTruck> = await supabaseAdmin\r\n    .from('food_trucks')\r\n    .update(updatesWithoutMenu)\r\n    .eq('id', id)\r\n    .select()\r\n    .single();\r\n\r\n  if (error) {\r\n    handleSupabaseError(error, 'updateTruckData');\r\n    return { error: \"Failed to update truck data.\" };\r\n  }\r\n  return truck;\r\n}\r\n\r\nasync function updateTruckMenu(id: string, menuData: MenuCategory[] | unknown[]): Promise<void> {\r\n  if (!supabaseAdmin) {\r\n    throw new Error('Admin operations require SUPABASE_SERVICE_ROLE_KEY');\r\n  }\r\n\r\n  // Delete existing menu items\r\n  const { error: deleteError } = await supabaseAdmin\r\n    .from('menu_items')\r\n    .delete()\r\n    .eq('food_truck_id', id);\r\n\r\n  if (deleteError) {\r\n    console.error('Error deleting existing menu items for truck', id, deleteError);\r\n  }\r\n\r\n  // Insert new menu items if they exist\r\n  if (menuData != undefined && menuData.length > 0) {\r\n    const menuItems = menuData.flatMap((category: unknown) => {\r\n      if (!isMenuCategory(category)) {\r\n        console.warn('Skipping invalid category in updateTruckMenu:', category);\r\n        return [];\r\n      }\r\n\r\n      return (category.items ?? []).map((item: unknown) => {\r\n        if (!isMenuItem(item)) {\r\n          console.warn('Skipping invalid menu item in updateTruckMenu:', item);\r\n          // Return a default valid MenuItem or skip based on requirements\r\n          return {\r\n            food_truck_id: id,\r\n            category: category.name ?? 'Uncategorized',\r\n            name: 'Unknown Item',\r\n            description: undefined,\r\n            price: undefined,\r\n            dietary_tags: [],\r\n          };\r\n        }\r\n\r\n        return {\r\n          food_truck_id: id,\r\n          category: category.name ?? 'Uncategorized',\r\n          name: item.name ?? 'Unknown Item',\r\n          description: item.description ?? undefined,\r\n          price: typeof item.price === 'number' ? item.price : undefined,\r\n          dietary_tags: Array.isArray(item.dietary_tags) ? item.dietary_tags : [],\r\n        };\r\n      });\r\n    });\r\n\r\n    if (menuItems.length > 0) {\r\n      const { error: menuError } = await supabaseAdmin.from('menu_items').insert(menuItems);\r\n\r\n      if (menuError) {\r\n        console.error('Error inserting updated menu items for truck', id, menuError);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction calculateDistance(lat1: number, lon1: number, lat2: number, lon2: number): number {\r\n  const R = 6371;\r\n  const dLat = ((lat2 - lat1) * Math.PI) / 180;\r\n  const dLon = ((lon2 - lon1) * Math.PI) / 180;\r\n  const a =\r\n    Math.sin(dLat / 2) * Math.sin(dLat / 2) +\r\n    Math.cos((lat1 * Math.PI) / 180) *\r\n      Math.cos((lat2 * Math.PI) / 180) *\r\n      Math.sin(dLon / 2) *\r\n      Math.sin(dLon / 2);\r\n  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\r\n  const distance = R * c;\r\n  return distance;\r\n}\r\n\r\n// Define a helper type for items coming from the DB, which might include a category field\r\ninterface RawMenuItemFromDB {\r\n  name: string;\r\n  description?: string;\r\n  price?: number;\r\n  dietary_tags?: string[];\r\n  category?: string; // This field is expected from the DB query\r\n  // Potentially other fields like id, food_truck_id, etc.\r\n  [key: string]: unknown; // Allow other properties from DB select *\r\n}\r\n\r\nfunction groupMenuItems(rawItems: RawMenuItemFromDB[]): MenuCategory[] {\r\n  const byCategory: Record<string, MenuItem[]> = {}; // Stores processed MenuItems\r\n  for (const rawItem of rawItems) {\r\n    const categoryName: string = rawItem.category ?? 'Uncategorized';\r\n    byCategory[categoryName] ??= [];\r\n    // Construct a MenuItem conforming to the MenuItem interface (no 'category' property)\r\n    const menuItem: MenuItem = {\r\n      name: rawItem.name,\r\n    // Use nullish coalescing to convert null from DB to undefined for the MenuItem type\r\n      description: rawItem.description ?? undefined,\r\n      price: rawItem.price ?? undefined,\r\n      dietary_tags: rawItem.dietary_tags as string[] ?? [], // Explicitly cast to string[]\r\n    };\r\n    byCategory[categoryName].push(menuItem);\r\n  }\r\n  // Map to MenuCategory structure { name: string, items: MenuItem[] }\r\nreturn Object.entries(byCategory).map(([categoryName, itemsList]: [string, MenuItem[]]) => ({\r\n  name: categoryName,\r\n  items: itemsList,\r\n}));\r\n}\r\n\r\n// Remove redundant type constituent in normalizeTruckLocation\r\nfunction normalizeTruckLocation(truck: FoodTruck): FoodTruck {\r\n  const fallback: FoodTruckLocation = {\r\n    lat: 0,\r\n    lng: 0,\r\n    address: 'Unknown',\r\n    timestamp: new Date().toISOString(),\r\n  };\r\n  const loc = truck.exact_location ?? truck.current_location ?? truck.city_location ?? {};\r\n  const lat = typeof loc.lat === 'number' ? loc.lat : 0;\r\n  const lng = typeof loc.lng === 'number' ? loc.lng : 0;\r\n  const address = loc.address;\r\n  const timestamp = loc.timestamp;\r\n\r\n  truck.current_location =\r\n    lat === 0 || lng === 0\r\n      ? { ...fallback, address: address ?? fallback.address }\r\n      : {\r\n          lat,\r\n          lng,\r\n          address: address ?? fallback.address,\r\n          timestamp: timestamp ?? fallback.timestamp,\r\n        };\r\n  return truck;\r\n}\r\n\r\nexport const ScrapingJobService = {\r\n  async createJob(jobData: Partial<ScrapingJob>): Promise<ScrapingJob> {\r\n    if (!supabaseAdmin) {\r\n      throw new Error('Admin operations require SUPABASE_SERVICE_ROLE_KEY');\r\n    }\r\n\r\n    const { data, error }: PostgrestSingleResponse<ScrapingJob> = await supabaseAdmin\r\n      .from('scraping_jobs')\r\n      .insert([\r\n        {\r\n          ...jobData,\r\n          status: 'pending',\r\n          retry_count: 0,\r\n          max_retries: 3,\r\n          created_at: new Date().toISOString(),\r\n        },\r\n      ])\r\n      .select()\r\n      .single();\r\n\r\n    if (error) throw error;\r\n    return data;\r\n  },\r\n\r\n  async getJobsByStatus(status: string): Promise<ScrapingJob[]> {\r\n    try {\r\n      const query = supabase.from('scraping_jobs').select('*');\r\n\r\n      const { data, error }: PostgrestResponse<ScrapingJob> = await (status === 'all'\r\n        ? query\r\n        : query.eq('status', status))\r\n        .order('priority', { ascending: false })\r\n        .order('scheduled_at', { ascending: true });\r\n\r\n      if (error) throw error;\r\n      return data ?? [];\r\n    } catch (error: unknown) {\r\n      console.warn('Error fetching jobs:', error);\r\n      return [];\r\n    }\r\n  },\r\n  async updateJobStatus(\r\n    id: string,\r\n    status: string,\r\n    updates: Partial<ScrapingJob> = {},\r\n  ): Promise<ScrapingJob> {\r\n    if (!supabaseAdmin) {\r\n      throw new Error('Admin operations require SUPABASE_SERVICE_ROLE_KEY');\r\n    }\r\n\r\n    const { data, error }: PostgrestSingleResponse<ScrapingJob> = await supabaseAdmin\r\n      .from('scraping_jobs')\r\n      .update({\r\n        status,\r\n        ...updates,\r\n        ...(status === 'running' && { started_at: new Date().toISOString() }),\r\n        ...(status === 'completed' && { completed_at: new Date().toISOString() }),\r\n      })\r\n      .eq('id', id)\r\n      .select()\r\n      .single();\r\n    if (error) throw error;\r\n    return data;\r\n  },\r\n  async incrementRetryCount(id: string): Promise<ScrapingJob> {\r\n    if (!supabaseAdmin) {\r\n      throw new Error('Admin operations require SUPABASE_SERVICE_ROLE_KEY');\r\n    }\r\n\r\n    const {\r\n      data: current,\r\n      error: fetchError,\r\n    }: PostgrestSingleResponse<Pick<ScrapingJob, 'retry_count'>> = await supabaseAdmin\r\n      .from('scraping_jobs')\r\n      .select('retry_count')\r\n      .eq('id', id)\r\n      .single();\r\n\r\n    if (fetchError) throw fetchError;\r\n\r\n    const { data, error }: PostgrestSingleResponse<ScrapingJob> = await supabaseAdmin\r\n      .from('scraping_jobs')\r\n      .update({ retry_count: (current?.retry_count ?? 0) + 1 })\r\n      .eq('id', id)\r\n      .select()\r\n      .single();\r\n\r\n    if (error) throw error;\r\n    return data;\r\n  },\r\n  async getAllJobs(limit = 50, offset = 0): Promise<ScrapingJob[]> {\r\n    try {\r\n      const { data, error }: PostgrestResponse<ScrapingJob> = await supabase\r\n        .from('scraping_jobs')\r\n        .select('*')\r\n        .order('priority', { ascending: false })\r\n        .order('scheduled_at', { ascending: true })\r\n        .range(offset, offset + limit - 1);\r\n\r\n      if (error) throw error;\r\n      return data ?? [];\r\n    } catch (error: unknown) {\r\n      console.warn('Error fetching jobs:', error);\r\n      return [];\r\n    }\r\n  },\r\n\r\n  async getJobsFromDate(date: Date): Promise<ScrapingJob[]> {\r\n    try {\r\n      const { data, error }: PostgrestResponse<ScrapingJob> = await supabase\r\n        .from('scraping_jobs')\r\n        .select('*')\r\n        .gte('created_at', date.toISOString())\r\n        .order('created_at', { ascending: false });\r\n\r\n      if (error) throw error;\r\n      return data ?? [];\r\n    } catch (error: unknown) {\r\n      console.warn('Error fetching jobs from date:', error);\r\n      return [];\r\n    }\r\n  },\r\n};\r\n\r\nexport const DataProcessingService = {\r\n  async addToQueue(queueData: Partial<DataProcessingQueue>): Promise<DataProcessingQueue> {\r\n    if (!supabaseAdmin) {\r\n      throw new Error('Admin operations require SUPABASE_SERVICE_ROLE_KEY');\r\n    }\r\n\r\n    const { data, error }: PostgrestSingleResponse<DataProcessingQueue> = await supabaseAdmin\r\n      .from('data_processing_queue')\r\n      .insert([\r\n        {\r\n          ...queueData,\r\n          status: 'pending',\r\n          gemini_tokens_used: 0,\r\n          created_at: new Date().toISOString(),\r\n        },\r\n      ])\r\n      .select()\r\n      .single();\r\n\r\n    if (error) throw error;\r\n    return data;\r\n  },\r\n\r\n  async getNextQueueItem(): Promise<DataProcessingQueue | undefined> {\r\n    if (!supabaseAdmin) {\r\n      throw new Error('Admin operations require SUPABASE_SERVICE_ROLE_KEY');\r\n    }\r\n\r\n    const { data, error }: PostgrestSingleResponse<DataProcessingQueue> = await supabaseAdmin\r\n      .from('data_processing_queue')\r\n      .select('*')\r\n      .eq('status', 'pending')\r\n      .order('priority', { ascending: false })\r\n      .order('created_at', { ascending: true })\r\n      .limit(1)\r\n      .single();\r\n\r\n    if (error && error.code !== 'PGRST116') throw error;\r\n    return data ?? undefined;\r\n  },\r\n\r\n  async getQueueByStatus(status: string): Promise<DataProcessingQueue[]> {\r\n    try {\r\n      const { data, error }: PostgrestResponse<DataProcessingQueue> = await supabase\r\n        .from('data_processing_queue')\r\n        .select('*')\r\n        .eq('status', status)\r\n        .order('created_at', { ascending: false });\r\n\r\n      if (error) throw error;\r\n      return data ?? [];\r\n    } catch (error: unknown) {\r\n      console.warn('Error fetching queue:', error);\r\n      return [];\r\n    }\r\n  },\r\n  async updateQueueItem(\r\n    id: string,\r\n    updates: Partial<DataProcessingQueue>,\r\n  ): Promise<DataProcessingQueue> {\r\n    if (!supabaseAdmin) {\r\n      throw new Error('Admin operations require SUPABASE_SERVICE_ROLE_KEY');\r\n    }\r\n\r\n    const { data, error }: PostgrestSingleResponse<DataProcessingQueue> = await supabaseAdmin\r\n      .from('data_processing_queue')\r\n      .update({\r\n        ...updates,\r\n        ...(updates.status === 'completed' && { processed_at: new Date().toISOString() }),\r\n      })\r\n      .eq('id', id)\r\n      .select()\r\n      .single();\r\n\r\n    if (error) throw error;\r\n    return data;\r\n  },\r\n};\r\n\r\nexport const DataQualityService = {\r\n  calculateQualityScore: (truck: FoodTruck) => {\r\n    // Placeholder for actual quality score calculation logic\r\n    // This should be implemented based on defined data quality rules\r\n    let score = 0;\r\n    if (typeof truck.name === 'string' && truck.name.trim() !== '') score += 20;\r\n    if (\r\n      truck.current_location &&\r\n      typeof truck.current_location.lat === 'number' && !Number.isNaN(truck.current_location.lat) &&\r\n      typeof truck.current_location.lng === 'number' && !Number.isNaN(truck.current_location.lng)\r\n    ) score += 30;\r\n    if (\r\n      (truck.contact_info &&\r\n        ((typeof truck.contact_info.phone === 'string' && truck.contact_info.phone.trim() !== '') ||\r\n         (typeof truck.contact_info.email === 'string' && truck.contact_info.email.trim() !== '') ||\r\n         (typeof truck.contact_info.website === 'string' && truck.contact_info.website.trim() !== '')))\r\n    ) score += 25;\r\n    if (Array.isArray(truck.menu) && truck.menu.length > 0) score += 15;\r\n    if (truck.operating_hours != undefined) score += 10;\r\n    return { score: Math.min(100, score) };\r\n  },\r\n\r\n  async updateTruckQualityScore(truckId: string): Promise<FoodTruck | { error: string }> {\r\n    if (!supabaseAdmin) {\r\n      return { error: 'Admin operations require SUPABASE_SERVICE_ROLE_KEY' };\r\n    }\r\n    const { data: truck, error: fetchError } = await supabaseAdmin\r\n      .from('food_trucks')\r\n      .select('*')\r\n      .eq('id', truckId)\r\n      .single();\r\n\r\n    if (fetchError) {\r\n      handleSupabaseError(fetchError, 'updateTruckQualityScore:fetch');\r\n      return { error: `Failed to fetch truck with ID ${truckId}.` };\r\n    }\r\n    if (!truck) {\r\n      return { error: `Truck with ID ${truckId} not found.` };\r\n    }\r\n\r\n    const { score } = this.calculateQualityScore(truck);\r\n\r\n    const { data, error } = await supabaseAdmin\r\n      .from('food_trucks')\r\n      .update({ data_quality_score: score })\r\n      .eq('id', truckId)\r\n      .select()\r\n      .single();\r\n\r\n    if (error) {\r\n      handleSupabaseError(error, 'updateTruckQualityScore:update');\r\n      return { error: `Failed to update quality score for truck with ID ${truckId}.` };\r\n    }\r\n    return data;\r\n  },\r\n};\r\n\r\nexport const APIUsageService = {\r\n  async trackUsage(serviceName: string, requests: number, tokens: number): Promise<ApiUsage> {\r\n    if (!supabaseAdmin) {\r\n      throw new Error('Admin operations require SUPABASE_SERVICE_ROLE_KEY');\r\n    }\r\n\r\n    try {\r\n      const today = new Date().toISOString().split('T')[0];\r\n\r\n      const { data: existing }: { data: ApiUsage | null; error: PostgrestError | null } = await supabaseAdmin\r\n        .from('api_usage')\r\n        .select('*')\r\n        .eq('service_name', serviceName)\r\n        .eq('usage_date', today)\r\n        .single();\r\n      if (existing) {\r\n        const { data, error }: PostgrestSingleResponse<ApiUsage> = await supabaseAdmin\r\n          .from('api_usage')\r\n          .update({\r\n            requests_count: (existing.requests_count ?? 0) + requests,\r\n            tokens_used: (existing.tokens_used ?? 0) + tokens,\r\n          })\r\n          .eq('id', existing.id)\r\n          .select()\r\n          .single();\r\n\r\n        if (error) throw error;\r\n        return data;\r\n      } else {\r\n        const { data, error }: PostgrestSingleResponse<ApiUsage> = await supabaseAdmin\r\n          .from('api_usage')\r\n          .insert([\r\n            {\r\n              service_name: serviceName,\r\n              usage_date: today,\r\n              requests_count: requests,\r\n              tokens_used: tokens,\r\n            },\r\n          ])\r\n          .select()\r\n          .single();\r\n\r\n        if (error) throw error;\r\n        return data;\r\n      }\r\n    } catch (error: unknown) {\r\n      console.warn('Error tracking usage:', error);\r\n      throw error;\r\n    }\r\n  },\r\n  async getTodayUsage(serviceName: string): Promise<ApiUsage | undefined> {\r\n    try {\r\n      const today = new Date().toISOString().split('T')[0];\r\n\r\n      const { data, error }: PostgrestSingleResponse<ApiUsage> = await supabase\r\n        .from('api_usage')\r\n        .select('*')\r\n        .eq('service_name', serviceName)\r\n        .eq('usage_date', today)\r\n        .single();\r\n\r\n      if (error && error.code !== 'PGRST116') throw error;\r\n      return data ?? undefined;\r\n    } catch (error: unknown) {\r\n      console.warn('Error getting today usage:', error);\r\n      throw error;\r\n    }\r\n  },\r\n\r\n  async getAllUsageStats(): Promise<ApiUsage[]> {\r\n    try {\r\n      const { data, error }: PostgrestResponse<ApiUsage> = await supabase\r\n        .from('api_usage')\r\n        .select('*')\r\n        .order('usage_date', { ascending: false })\r\n        .limit(30);\r\n\r\n      if (error) throw error;\r\n      return data ?? [];\r\n    } catch (error: unknown) {\r\n      console.warn('Error getting usage stats:', error);\r\n      throw error;\r\n    }\r\n  },\r\n};\r\n\r\nexport { type MenuItem, type MenuCategory, type OperatingHours, type PriceRange } from './types';\r\n\r\n// Helper to prepare menu items for DB insertion\r\nfunction prepareMenuItemsForInsert(truckId: string, menuData: MenuCategory[] | unknown[] | undefined) {\r\n  if (!Array.isArray(menuData) || menuData.length === 0) return [];\r\n  // Explicitly filter for MenuCategory to ensure type safety\r\n  const categories = menuData.filter((category): category is MenuCategory =>\r\n    typeof category === 'object' && category != undefined && 'name' in category && 'items' in category && Array.isArray(category.items)\r\n  ) as MenuCategory[];\r\n\r\n  return categories.flatMap((category) =>\r\n    (Array.isArray(category.items) ? category.items : []).map((item: unknown) => {\r\n      if (!isMenuItem(item)) {\r\n        console.warn('Skipping invalid menu item:', item);\r\n        return; // Return undefined for invalid items to be filtered out later\r\n      }\r\n\r\n      return {\r\n        food_truck_id: truckId,\r\n        category: typeof category.name === 'string' && category.name !== '' ? category.name : 'Uncategorized',\r\n        name: typeof item.name === 'string' && item.name !== '' ? item.name : 'Unknown Item',\r\n        description: typeof item.description === 'string' && item.description !== '' ? item.description : undefined,\r\n        price: typeof item.price === 'number' && !Number.isNaN(item.price) ? item.price : undefined,\r\n        dietary_tags: Array.isArray(item.dietary_tags) ? item.dietary_tags : [],\r\n      };\r\n    }).filter(Boolean) as MenuItem[] // Filter out nulls and assert type\r\n  );\r\n}\r\n\r\nasync function insertMenuItems(truckId: string, menuData: MenuCategory[] | unknown[] | undefined) {\r\n  const menuItems = prepareMenuItemsForInsert(truckId, menuData);\r\n  if (menuItems.length === 0) return;\r\n  const { error: menuError } = await supabaseAdmin!.from('menu_items').insert(menuItems);\r\n  if (menuError) {\r\n    console.error('Error inserting menu items for truck', truckId, menuError);\r\n  }\r\n}\r\n\r\n// Fix all strict-boolean-expressions and always-true/false comparisons below\r\n// Example: if (someString) => if (typeof someString === 'string' && someString.trim() !== '')\r\n// Example: if (someNumber) => if (typeof someNumber === 'number' && !Number.isNaN(someNumber) && someNumber !== 0)\r\n// Example: if (someObject) => if (someObject != null && someObject != undefined)\r\n\r\n// For all other conditionals, ensure explicit nullish/empty/NaN checks as above\r\n\r\nexport {type PostgrestError, type PostgrestResponse} from '@supabase/supabase-js';\r\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\lib\\supabaseMiddleware.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\lib\\types.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 14,
        "column": 15,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 14,
        "endColumn": 18,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [309, 312], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [309, 312], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "// Shared types for the Food Truck Finder application\r\n\r\nexport type PriceRange = '$|$$,$$$';\r\n\r\nexport interface MenuCategory {\r\n  name: string;\r\n  items: MenuItem[];\r\n}\r\n\r\nexport interface MenuItem {\r\n  name: string;\r\n  description: string | undefined;\r\n  price: number | string | undefined;\r\ndietary_tags: any[];\r\n  is_popular?: boolean;\r\n}\r\n\r\nexport interface LocationData {\r\n  address: string | undefined;\r\n  city: string | undefined;\r\n  state: string | undefined;\r\n  landmarks: string[];\r\n  coordinates: {\r\n    lat: number | undefined;\r\n    lng: number | undefined;\r\n  };\r\n  confidence: number;\r\n  raw_location_text: string | undefined;\r\n}\r\n\r\nexport type DailyOperatingHours =\r\n  | { open: string; close: string; closed: boolean }\r\n  | { closed: true }\r\n  | undefined;\r\n\r\nexport interface OperatingHours {\r\n  monday: DailyOperatingHours;\r\n  tuesday: DailyOperatingHours;\r\n  wednesday: DailyOperatingHours;\r\n  thursday: DailyOperatingHours;\r\n  friday: DailyOperatingHours;\r\n  saturday: DailyOperatingHours;\r\n  sunday: DailyOperatingHours;\r\n  [key: string]: DailyOperatingHours; // Add index signature\r\n}\r\n\r\nexport interface SentimentAnalysisResult {\r\n  sentiment: 'positive' | 'negative' | 'neutral';\r\n  score: number;\r\n  confidence: number;\r\n  key_topics: string[];\r\n  positive_aspects: string[];\r\n  negative_aspects: string[];\r\n  summary: string;\r\n  recommended: boolean;\r\n}\r\n\r\nexport interface EnhancedFoodTruckData {\r\n  name: string | undefined;\r\n  description: string | undefined;\r\n  cuisine_type: string[];\r\n  price_range: PriceRange;\r\n  specialties: string[];\r\n  dietary_options: string[];\r\n  enhanced_menu: {\r\n    categories: MenuCategory[];\r\n  };\r\n  standardized_hours: OperatingHours;\r\n  cleaned_contact: {\r\n    phone: string | undefined;\r\n    email: string | undefined;\r\n    website: string | undefined;\r\n  };\r\n  data_quality_improvements: string[];\r\n  confidence_score: number;\r\n}\r\n\r\nexport interface ExtractedFoodTruckDetails {\r\n  name: string | undefined;\r\n  description: string | undefined;\r\n  cuisine_type: string[];\r\n  price_range: PriceRange | undefined;\r\n  specialties: string[];\r\n  current_location: {\r\n    address: string | undefined;\r\n    city: string | undefined;\r\n    state: string | undefined;\r\n    zip_code: string | undefined;\r\n    lat?: number;\r\n    lng?: number;\r\n    raw_text: string | undefined;\r\n  };\r\n  scheduled_locations?: {\r\n    // Added scheduled_locations\r\n    address?: string;\r\n    city?: string;\r\n    state?: string;\r\n    zip_code?: string;\r\n    lat?: number;\r\n    lng?: number;\r\n    timestamp: string;\r\n    start_time: string; // Added start_time\r\n    end_time: string; // Added end_time\r\n  }[];\r\n  operating_hours: OperatingHours;\r\n  menu: MenuCategory[];\r\n  contact_info: {\r\n    phone?: string;\r\n    email?: string;\r\n    website?: string;\r\n  };\r\n  social_media: {\r\n    instagram?: string;\r\n    facebook?: string;\r\n    twitter?: string;\r\n    tiktok?: string;\r\n    yelp?: string;\r\n  };\r\n  source_url: string;\r\n}\r\n\r\nexport interface FirecrawlOutputData {\r\n  markdown: string;\r\n  name?: string;\r\n  source_url?: string;\r\n}\r\n\r\nexport interface FoodTruckSchema {\r\n  name: string;\r\n  description?: string;\r\n  current_location: {\r\n    lat: number;\r\n    lng: number;\r\n    address: string | undefined;\r\n    timestamp: string;\r\n  };\r\n  scheduled_locations: ExtractedFoodTruckDetails['scheduled_locations'];\r\n  operating_hours: OperatingHours;\r\n  menu: MenuCategory[];\r\n  contact_info: ExtractedFoodTruckDetails['contact_info'];\r\n  social_media: ExtractedFoodTruckDetails['social_media'];\r\n  cuisine_type: string[];\r\n  price_range: PriceRange | undefined;\r\n  specialties: string[];\r\n  data_quality_score: number;\r\n  verification_status: 'pending' | 'verified' | 'flagged';\r\n  source_urls: string[];\r\n  last_scraped_at: string;\r\n  test_run_flag?: boolean;\r\n  website?: string;\r\n  phone_number?: string;\r\n  email?: string;\r\n  instagram_handle?: string;\r\n  facebook_handle?: string;\r\n  twitter_handle?: string;\r\n  schedule?: unknown[]; // Assuming schedule is an array, adjust type if known\r\n  average_rating?: number;\r\n  review_count?: number;\r\n}\r\n\r\n// Database record type with additional fields\r\nexport interface FoodTruck extends FoodTruckSchema {\r\n  id: string;\r\n  created_at: string;\r\n  updated_at: string;\r\n  is_active?: boolean;\r\n}\r\n\r\nexport interface GeminiResponse<T = unknown> {\r\n  success: boolean;\r\n  data?: T;\r\n  tokensUsed?: number;\r\n  error?: string;\r\n  promptSent?: string;\r\n}\r\n\r\nexport interface StageResult {\r\n  status: string;\r\n  data?: FirecrawlOutputData | ExtractedFoodTruckDetails | FoodTruckSchema;\r\n  error?: string;\r\n  details?: string;\r\n  prompt?: string;\r\n  tokensUsed?: number;\r\n  metadata?: { name?: string; source_url?: string };\r\n  rawContent?: string;\r\n  preparedData?: FoodTruckSchema;\r\n  recordId?: string;\r\n}\r\n\r\nexport interface TestPipelineResults {\r\n  firecrawl?: StageResult;\r\n  gemini?: StageResult;\r\n  supabase?: StageResult;\r\n  overallStatus?: string;\r\n  logs?: string[];\r\n  error?: string;\r\n}\r\n\r\nexport interface PipelineRunResult {\r\n  firecrawl?: StageResult;\r\n  gemini?: StageResult;\r\n  supabase?: StageResult;\r\n  logs: string[];\r\n  overallStatus: 'Success' | 'Error';\r\n}\r\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\lib\\types\\foodTruck.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\lib\\types\\webVitals.d.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\lib\\utils.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\lib\\utils\\QualityScorer.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\lib\\utils\\dataQualityFormatters.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\lib\\utils\\foodTruckHelpers.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected object value in conditional. The condition is always true.",
        "line": 31,
        "column": 53,
        "nodeType": "Identifier",
        "messageId": "conditionErrorObject",
        "endLine": 31,
        "endColumn": 57
      },
      {
        "ruleId": "@typescript-eslint/strict-boolean-expressions",
        "severity": 1,
        "message": "Unexpected object value in conditional. The condition is always true.",
        "line": 36,
        "column": 10,
        "nodeType": "Identifier",
        "messageId": "conditionErrorObject",
        "endLine": 36,
        "endColumn": 18
      }
    ],
    "suppressedMessages": [
      {
        "ruleId": "sonarjs/no-intrusive-permissions",
        "severity": 2,
        "message": "Make sure the use of the geolocation is necessary.",
        "line": 63,
        "column": 5,
        "nodeType": "MemberExpression",
        "messageId": "checkPermission",
        "endLine": 63,
        "endColumn": 45,
        "suppressions": [
          {
            "kind": "directive",
            "justification": "Geolocation is essential for finding nearby food trucks"
          }
        ]
      }
    ],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 2,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { FoodTruck, DailyOperatingHours, MenuItem } from '@/lib/types'; // Added DailyOperatingHours, PriceRange, MenuItem\r\n\r\nexport const getCurrentDay = () => {\r\n  const days = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];\r\n  return days[new Date().getDay()];\r\n};\r\n\r\nexport const formatPrice = (price: number | string) => { // Updated to accept string\r\n  if (typeof price === 'string') {\r\n    // Handle cases where price might be a string like \"$10-$20\" or \"Varies\"\r\n    return price;\r\n  }\r\n  return new Intl.NumberFormat('en-US', {\r\n    style: 'currency',\r\n    currency: 'USD',\r\n  }).format(price);\r\n};\r\n\r\nexport const formatHours = (hours: DailyOperatingHours) => { // Updated to accept DailyOperatingHours\r\n    if (!hours || hours.closed) {\r\n        return 'Closed';\r\n    }\r\n    const open = new Date(`1970-01-01T${hours.open}Z`).toLocaleTimeString('en-US', {hour: 'numeric', minute: 'numeric', hour12: true});\r\n    const close = new Date(`1970-01-01T${hours.close}Z`).toLocaleTimeString('en-US', {hour: 'numeric', minute: 'numeric', hour12: true});\r\n    return `${open} - ${close}`;\r\n}\r\n\r\nexport const getPopularItems = (truck: FoodTruck): MenuItem[] => { // Explicitly define return type\r\n    // Explicitly check for nullish and boolean\r\n    return (truck.menu?.flatMap(category => category.items)\r\n        .filter((item): item is MenuItem => Boolean(item && item.is_popular === true)) ?? []);\r\n}\r\n\r\nexport const getPriceRange = (truck: FoodTruck) => {\r\n    const allItems = truck.menu?.flatMap(category => category.items);\r\n    if (!allItems || allItems.length === 0) {\r\n        return 'N/A';\r\n    }\r\n    const numericPrices = allItems\r\n        .map(item => item.price)\r\n        .filter((price): price is number => typeof price === 'number' && price != undefined); // Filter for numbers\r\n\r\n    if (numericPrices.length === 0) {\r\n        return 'N/A'; // No numeric prices found\r\n    }\r\n\r\n    const minPrice = Math.min(...numericPrices);\r\n    const maxPrice = Math.max(...numericPrices);\r\n    return `${formatPrice(minPrice)} - ${formatPrice(maxPrice)}`;\r\n}\r\n\r\nexport const getTodayHours = (truck: FoodTruck) => {\r\n    const today = getCurrentDay();\r\n    return truck.operating_hours?.[today];\r\n}\r\n\r\n// Get user's current location or default to San Francisco\r\nexport function getUserLocationHelper(\r\n  setUserLocation: (location: { lat: number; lng: number }) => void\r\n) {\r\n  if (typeof navigator !== 'undefined' && navigator.geolocation != undefined) {\r\n    // eslint-disable-next-line sonarjs/no-intrusive-permissions -- Geolocation is essential for finding nearby food trucks\r\n    navigator.geolocation.getCurrentPosition(\r\n      (position) => {\r\n        setUserLocation({\r\n          lat: position.coords.latitude,\r\n          lng: position.coords.longitude,\r\n        });\r\n      },\r\n      (error) => {\r\n        console.warn('Location access denied:', error);\r\n        // Default to San Francisco\r\n        setUserLocation({ lat: 37.7749, lng: -122.4194 });\r\n      },\r\n    );\r\n  } else {\r\n    // Default to San Francisco if geolocation is not supported\r\n    setUserLocation({ lat: 37.7749, lng: -122.4194 });\r\n  }\r\n}\r\n\r\n// Load all food trucks from API\r\nexport async function loadFoodTrucksHelper(\r\n  setTrucks: (trucks: FoodTruck[]) => void,\r\n  setLoading: (loading: boolean) => void\r\n) {\r\n  try {\r\n    const response = await fetch('/api/trucks');\r\n    const data: unknown = await response.json();\r\n    if (typeof data === 'object' && data != undefined && 'trucks' in data && Array.isArray(data.trucks)) {\r\n      setTrucks(data.trucks as FoodTruck[]);\r\n    } else {\r\n      setTrucks([]);\r\n    }\r\n  } catch (error: unknown) {\r\n    console.error('Failed to load food trucks:', error);\r\n  } finally {\r\n    setLoading(false);\r\n  }\r\n}\r\n\r\n// Load nearby food trucks based on user location\r\nexport async function loadNearbyTrucksHelper(\r\n  userLocation: { lat: number; lng: number } | undefined,\r\n  setTrucks: (trucks: FoodTruck[]) => void\r\n) {\r\n  if (!userLocation) return;\r\n\r\n  try {\r\n    const response = await fetch(\r\n      `/api/trucks?lat=${userLocation.lat}&lng=${userLocation.lng}&radius=10`,\r\n    );\r\n    const data: unknown = await response.json();\r\n    if (typeof data === 'object' && data != undefined && 'trucks' in data && Array.isArray(data.trucks)) {\r\n      setTrucks(data.trucks as FoodTruck[]);\r\n    } else {\r\n      setTrucks([]);\r\n    }\r\n  } catch (error: unknown) {\r\n    console.error('Failed to load nearby trucks:', error);\r\n  }\r\n}\r\n\r\n// Check if a food truck is currently open\r\nexport function isTruckOpen(truck: FoodTruck): boolean {\r\n  const today = getCurrentDay();\r\n  const hours = truck.operating_hours?.[today];\r\n\r\n  // Ensure hours and its properties are not null/undefined before accessing\r\n  if (hours == undefined || hours.closed === true || hours.open == undefined || hours.close == undefined) {\r\n    return false;\r\n  }\r\n\r\n  try {\r\n    const now = new Date();\r\n    const currentTime = now.getHours() * 100 + now.getMinutes();\r\n    const openTime = Number.parseInt(hours.open.replace(':', ''));\r\n    const closeTime = Number.parseInt(hours.close.replace(':', ''));\r\n\r\n    return currentTime >= openTime && currentTime <= closeTime;\r\n  } catch (error: unknown) {\r\n    console.error('Error parsing operating hours for truck', truck.name, error);\r\n    return false;\r\n  }\r\n}\r\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\AI\\food-truck-finder-poc\\next-env.d.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  }
]
