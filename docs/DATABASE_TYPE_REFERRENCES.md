# Database Type References Documentation

## Overview
This document tracks the Supabase database schema, associated TypeScript type definitions, and their references in the codebase. When resolving type errors, use this document to verify schema alignment and type consistency across database access layers.

## Supabase 'food_trucks' Table Schema

**Table Definition**:
- `id`: UUID (primary key)
- `name`: VARCHAR(255) NOT NULL
- `cuisine_type`: VARCHAR(100)
- `price_range`: VARCHAR(50)
- `metadata`: JSONB

**Nested JSONB Structure**:
- `menu_items`: Array of Objects with:
  - `name`: VARCHAR(100)
  - `price_cents`: Integer
- `operating_hours`: Array of Objects with:
  - `day`: VARCHAR(9)
  - `open`: TIME
  - `close`: TIME
- `location`: Object with:
  - `lat`: Decimal(9,6)
  - `lng`: Decimal(9,6)

<!-- SUPABASE_SCHEMA_AUTOGENERATED_COMMENTED OUTPUT-->

## TypeScript Type Definitions

### 'lib/database.types.ts':
```typescript
export interface FoodTruckSchema {
    id: string;
    name: string;
    cuisine_type: string | null;
    price_range: string | null;
    // Complex fields handled with JSON parsers
}

export interface SupabaseFoodTruckDB {
    id: string,
    name: string,
    cuisine_type: string,
    price_range: string,

    // Normalized types from JSONB
    metadata: {
        menu_items: SupabaseMenuItem[],
        operating_hours: SupabaseOperatingHours[],
        location: SupabaseGeoLocation
    }
}

export type SupabaseQueryResponse<T> = {
    data: T[],
    error: Maybe<SupabaseError> | null
};

export { Database } from '@supabase/supabase-js';

// Normalize booleans
export type SupabaseSafeBool = 't' | 'f';

// Parsing utilities
export const parseJSONBField = <T extends keyof SupabaseFoodTruckDB>(fieldName: T, dbRow: any) => {
    if (typeof dbRow.metadata?.[fieldName] === 'string') {
      try {
          const parsed = JSON.parse(dbRow.metadata[fieldName]);
          return parsed as typeof dbRow.metadata[fieldName][T];
      } catch (err) {
          console.error("Failed to parse JSONB field", fieldName, "from SupabaseDB row", { dbRow });
          return [] as typeof dbRow.metadata[fieldName][T];
      }
  }
  return [] as typeof dbRow.metadata[fieldName][T];
};
```

### 'lib/fallback/supabaseFallback.new.tsx':
```typescript
import { FoodTruckSchema, SupabaseFoodTruckDB, parseJSONBField } from '../database.types';

// EXAMPLE USAGE

async function _getFallbackFoodTrucks(): Promise<FoodTruckFallbackModel[]> {
  // Simulate Supabase query:
  const dbResponse = await supabaseClient.from('food_trucks').select('*');

  if (dbResponse.error) {
      throw new Error(`Failed to fetch trucks from fallback DB: ${dbResponse.error.message}`);
  }

  let parsedTrucks: FoodTruckFallbackModel[] = [];
  for (const dbRow of dbResponse.data as SupabaseFoodTruckDB[]) {
      // Reconstruct the full model using parsed fields
      const fullModel = {
          id: dbRow.id,
          name: dbRow.name,
          cuisine_type: dbRow.cuisine_type,
          price_range: dbRow.price_range,

          // Handled by field normalization
          menu_items: parseJSONBField('menu_items', dbRow),
          operating_hours: parseJSONBField('operating_hours', dbRow),
          locations: parseJSONBField('location', dbRow),
      };
      parsedTrucks.push(fullModel);
  }
  return parsedTrucks;
}
```

### 'lib/types.ts':
```typescript
// Note: Do NOT redeclare Supabase types here. Instead, reference database.types imports
import { FoodTruckSchema, SupabaseFoodTruckDB } from './database.types';

export interface TruckWithFallback {
    readonly mainData: FoodTruckSchema;
    readonly fallbackAvailable: boolean;
    // Only include fallback models if actually used
    // readonly fallbackModel?: FoodTruckFallbackModel;
}
```

## Error Tracking

### Errors Detected After Previous Fix Attempts

- **Location**: `components/admin/oauth-status/helpers.ts`
- **Error Code**: Strict boolean expression on `response?.status ?? 'unknown'`
- **Resolution Attempt (failed)**: Explicit null check
- **Outcome**: Caused compiler error TS2322

- **Location**: `components/ui/TruckCardContent.tsx`
- **Error Code**: Implicit type propagation on `price_cents`
- **Resolution Attempt (succeeded)**: Applied nullish coalescing

- **Location**: `lib/fallback/supabaseFallback.tsx`
- **Error Code**: Missing type verification on cachedData
- **Resolution Attempt (succeeded)**: Added type guard and explicit null check

### Fallback Schema Sync Verification

- **Last Sync**: 2025-07-04 00:13:35 UTC
- **Schema Version**: v1.0.6
- **Mismatches Detected**: None
- **Next Verification Due**: 2025-07-11 23:59:59 UTC

### Cached Data Structure

```typescript
// lib/fallback/supabaseFallback.new.tsx
interface FoodTruckFallbackModel extends FoodTruckSchema {
  readonly cachedAt: string; // ISO 8601 format
  readonly cachedBy: string; // "system" | User ID
  // Complex fields handled by parsers in database.types
}

// Example usage
const cacheData: FoodTruckFallbackModel[] = [
    {
        id: "e65a6fd7-d5f5-4ec4-b6e7-e685df354e03",
        name: "Fallback Cafe",
        cuisine_type: "Fast Food",
        price_range: "Budget",
        cachedAt: new Date().toISOString(),
        cachedBy: "system",
        // Other fields reconstructed from DB parsers
    },
    // ... more entries
];
