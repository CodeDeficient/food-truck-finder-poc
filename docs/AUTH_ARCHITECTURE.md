# Authentication Architecture Plan

This document outlines the implemented authentication and authorization architecture for the Food Truck Finder application, which uses a Supabase-native Role-Based Access Control (RBAC) system.

## 1. Core Architecture

- **Identity Provider:** Supabase Auth handles all user sign-up, sign-in, and session management.
- **Backend & Database:** [Supabase](https://supabase.com) will serve as the backend, managing the database, storage, and data APIs.
- **Authorization:** Supabase's Row Level Security (RLS) will be used to control data access. Authorization decisions will be based on custom claims embedded in the JSON Web Token (JWT) provided by Firebase.

This decoupled architecture prevents a single point of failure. If Supabase experiences downtime, user authentication remains operational, and vice-versa.

## 2. Implementation Steps

### Step 2.1: Configure Supabase Auth

1.  **Enable Auth Providers:** In the Supabase dashboard, enable the desired authentication providers (e.g., Email/Password, Google, etc.).
2.  **User Table:** Supabase automatically manages the `auth.users` table.
3.  **Profiles Table:** A public `profiles` table is created to store user-specific data, including their role. This table is linked to `auth.users` via the user's `id`.

### Step 2.2: Configure Role-Based Access Control (RBAC)

To enable role-based access control, a `role` column is added to the `profiles` table.

1.  **Assign Default Role:** A database trigger or server-side function assigns a default role (e.g., `authenticated`) to every new user profile.
2.  **Admin Role:** An administrator manually updates a user's role to `admin` directly in the `profiles` table.

### Step 2.3: Configure Next.js Supabase SSR Client
The Supabase SSR client is used in Next.js middleware and server components to securely handle user sessions. It automatically manages JWTs via cookies.

## 3. Admin Access Control & RBAC Implementation

Securing the `/admin` dashboard and implementing a robust Role-Based Access Control system is a top priority.

### 3.1 Database Schema for RBAC

A permissions-based system is implemented directly in the Supabase database.

1.  **Define Custom Types:** Create `enum` types for roles and permissions to ensure data integrity.
    ```sql
    -- Custom types
    create type public.app_role as enum ('admin', 'authenticated');
    create type public.app_permission as enum ('trucks.delete', 'users.edit');
    ```
2.  **Create `role_permissions` Table:** This table will map roles to their specific permissions.
    ```sql
    create table public.role_permissions (
      id           bigint generated by default as identity primary key,
      role         app_role not null,
      permission   app_permission not null,
      unique (role, permission)
    );
    comment on table public.role_permissions is 'Application permissions for each role.';
    ```
3.  **Populate Permissions:** Insert the permissions for each role.
    ```sql
    insert into public.role_permissions (role, permission)
    values
      ('admin', 'trucks.delete'),
      ('admin', 'users.edit');
    ```

### 3.3 Supabase Authorization Function

A central SQL function in Supabase checks permissions and is used in all RLS policies.

1.  **Create `authorize` Function:** This function reads the `role` from the Firebase JWT and checks it against the `role_permissions` table.
    ```sql
    create or replace function public.authorize(
      requested_permission app_permission
    )
    returns boolean as $$
    declare
      bind_permissions int;
      user_role public.app_role;
    begin
      -- Get the user's role from their profile
      select role into user_role from public.profiles where id = auth.uid();
      -- Check if the role has the requested permission
      select count(*)
      into bind_permissions
      from public.role_permissions
      where role_permissions.permission = requested_permission
        and role_permissions.role = user_role;
      return bind_permissions > 0;
    end;
    $$ language plpgsql stable security definer;
    ```

### 3.4 RLS Policies & Middleware

1.  **RLS Policies:** All RLS policies will now use the `authorize` function for cleaner, more maintainable rules.
    ```sql
    -- Example policy for deleting a truck
    CREATE POLICY "Admins can delete trucks"
    ON public.trucks
    FOR DELETE
    TO authenticated
    USING ( public.authorize('trucks.delete') );
    ```
2.  **Middleware Protection:** The Next.js middleware (`app/middleware.ts`) will be updated to:
    a. Verify the user's Supabase session.
    b. Check the user's profile for the `admin` role.
    c. Redirect any user without the `admin` role away from `/admin/*` routes. This provides a fast, user-friendly layer of security before hitting the database.
